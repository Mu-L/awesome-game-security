Project Path: arc_gmh5225_RemnantESP_6hhgb3jk

Source Tree:

```txt
arc_gmh5225_RemnantESP_6hhgb3jk
├── LICENSE
├── README.md
├── RemnantESP
│   ├── App.config
│   ├── Arial8.fnt
│   ├── ESP.cs
│   ├── Engine.cs
│   ├── Extensions.cs
│   ├── FodyWeavers.xml
│   ├── FodyWeavers.xsd
│   ├── Memory.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── RemnantESP.csproj
│   ├── SigScan.cs
│   └── packages.config
├── RemnantESP.sln
└── sample.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 shalzuth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# RemnantESP
 Remnant: From the Ashes example code to make mods using C# on Unreal Engine apps
- ESP
  - Enemies
  - Equipment
  - Traits
  - Items
- Radar
- Infinite Ammo
- No Reload
- Infinite Stamina

![AppPreview](sample.png)

## Credits
atom0s for SigScan.cs

# Feel like buying me a cup of coffee?

[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=4JTD52ECXN4EW)
```

`RemnantESP.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30011.22
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "RemnantESP", "RemnantESP\RemnantESP.csproj", "{79DA8EEC-502C-4046-AD35-B65C4E10AB36}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{79DA8EEC-502C-4046-AD35-B65C4E10AB36}.Debug|x64.ActiveCfg = Debug|x64
		{79DA8EEC-502C-4046-AD35-B65C4E10AB36}.Debug|x64.Build.0 = Debug|x64
		{79DA8EEC-502C-4046-AD35-B65C4E10AB36}.Release|x64.ActiveCfg = Release|x64
		{79DA8EEC-502C-4046-AD35-B65C4E10AB36}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3C1705E4-54FE-42F2-8B8F-26C803607BE1}
	EndGlobalSection
EndGlobal

```

`RemnantESP/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`RemnantESP/ESP.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;
using SharpDX;
using SharpDX.Toolkit;
using SharpDX.Toolkit.Graphics;

namespace RemnantESP
{
    class ESP : Game
    {
        SpriteBatch SpriteBatch;
        SpriteFont SpriteFont;
        public ESP()
        {
            new GraphicsDeviceManager(this);
        }
        protected override void Initialize()
        {
            base.Initialize();
            SpriteBatch = new SpriteBatch(GraphicsDevice);
            SpriteFont = ToDisposeContent(SpriteFont.New(GraphicsDevice, SpriteFontData.Load(Properties.Resources.Arial8)));
            Window.IsMouseVisible = true;
            Window.Title = Window.Name = "ShalzuthPerception";
            ((Form)Window.NativeWindow).FormBorderStyle = FormBorderStyle.None;
            Window.ClientSizeChanged += (s, ea) => { };
            ((Form)Window.NativeWindow).TransparencyKey = System.Drawing.Color.AntiqueWhite;
            Process process = default;
            while (process == default(Process))
            {
                process = Process.GetProcesses().FirstOrDefault(p => p.ProcessName.Contains(Engine.Memory.Process.ProcessName) && p.MainWindowHandle != IntPtr.Zero);
                Thread.Sleep(1000);
            }
            SetWindowLong(((Form)Window.NativeWindow).Handle, -20, GetWindowLong(((Form)Window.NativeWindow).Handle, -20) | 0x80000 | 0x20);
            SetParent(((Form)Window.NativeWindow).Handle, (IntPtr)process.MainWindowHandle);
            SetWindowPos(((Form)Window.NativeWindow).Handle, 0, 0, 0, 1920, 1080, 0);
        }
        static byte[] BitmapToByteArray(System.Drawing.Bitmap bitmap)
        {
            var bmpdata = bitmap.LockBits(new System.Drawing.Rectangle(0, 0, bitmap.Width, bitmap.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, bitmap.PixelFormat);
            int numbytes = bmpdata.Stride * bitmap.Height;
            byte[] bytedata = new byte[numbytes];
            IntPtr ptr = bmpdata.Scan0;
            Marshal.Copy(ptr, bytedata, 0, numbytes);
            bitmap.UnlockBits(bmpdata);
            return bytedata;
        }
        Texture2D box;
        Texture2D line;
        protected override void LoadContent()
        {
            using (var bmp = new System.Drawing.Bitmap(128, 128, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
            {
                using (var g = System.Drawing.Graphics.FromImage(bmp))
                using (var pen = new System.Drawing.Pen(System.Drawing.Color.White))
                {
                    g.DrawRectangle(pen, 0, 0, 128, 128);
                }
                var data = BitmapToByteArray(bmp);
                box = Texture2D.New(GraphicsDevice, bmp.Width, bmp.Height, SharpDX.DXGI.Format.R8G8B8A8_UNorm);
                box.SetData(data);
            }
            using (var bmp = new System.Drawing.Bitmap(8, 128, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
            {
                using (var g = System.Drawing.Graphics.FromImage(bmp))
                using (var brush = new System.Drawing.SolidBrush(System.Drawing.Color.White))
                {
                    g.FillRectangle(brush, 0, 0, 8, 128);
                }
                var data = BitmapToByteArray(bmp);
                line = Texture2D.New(GraphicsDevice, bmp.Width, bmp.Height, SharpDX.DXGI.Format.R8G8B8A8_UNorm);
                line.SetData(data);
            }
            base.LoadContent();
        }
        Vector3 LastRotation = Vector3.Zero;
        Vector3 vAxisX = Vector3.Zero;
        Vector3 vAxisY = Vector3.Zero;
        Vector3 vAxisZ = Vector3.Zero;
        Vector2 WorldToScreen(Vector3 worldLocation, Vector3 cameraLocation, Vector3 cameraRotation, Single fieldOfView)
        {
            if (LastRotation != cameraRotation)
            {
                cameraRotation.GetAxes(out vAxisX, out vAxisY, out vAxisZ);
                LastRotation = cameraRotation;
            }
            var vDelta = worldLocation - cameraLocation;
            var vTransformed = new Vector3(vDelta.Mult(vAxisY), vDelta.Mult(vAxisZ), vDelta.Mult(vAxisX));
            if (vTransformed.Z < 1f)
                vTransformed.Z = 1f;
            float ScreenCenterX = Window.ClientBounds.Width / 2;
            float ScreenCenterY = Window.ClientBounds.Height / 2;
            var fullScreen = new Vector2(ScreenCenterX + vTransformed.X * (ScreenCenterX / (float)Math.Tan(fieldOfView * (float)Math.PI / 360)) / vTransformed.Z,
                ScreenCenterY - vTransformed.Y * (ScreenCenterX / (float)Math.Tan(fieldOfView * (float)Math.PI / 360)) / vTransformed.Z);
            return new Vector2(fullScreen.X, fullScreen.Y);
        }
        Single LastYRotation = 0;
        Single CameraSinTheta = 0;
        Single CameraCosTheta = 0;
        Vector2 WorldToWindow(Vector3 targetLocation, Vector3 playerLocation, Vector3 cameraRotation, Single maxRange, Single radarSize)
        {
            if (LastYRotation != cameraRotation.Y)
            {
                var CameraRadians = (Single)Math.PI * (-cameraRotation.Y - 90.0f) / 180.0f;
                CameraSinTheta = (Single)Math.Sin(CameraRadians);
                CameraCosTheta = (Single)Math.Cos(CameraRadians);
                LastYRotation = cameraRotation.Y;
            }
            radarSize /= 2;
            var diff = targetLocation - playerLocation;
            var radarLoc = new Vector2(radarSize * diff.X / maxRange, radarSize * diff.Y / maxRange);
            radarLoc = new Vector2(CameraCosTheta * radarLoc.X - CameraSinTheta * radarLoc.Y, CameraSinTheta * radarLoc.X + CameraCosTheta * radarLoc.Y);
            radarLoc += new Vector2(radarSize, radarSize);
            return radarLoc;
        }
        void DrawLines(Color color, Vector2[] points)
        {
            for (int i = 0; i < points.Length - 1; i++)
                DrawLine(color, points[i], points[i + 1]);
        }
        void DrawLine(Color color, Vector2 start, Vector2 end)
        {
            var dist = Vector2.Distance(start, end);
            var angle = -Math.PI / 2 - Math.Atan2(-(end.Y - start.Y), end.X - start.X);
            SpriteBatch.Draw(line, new Rectangle((int)(start.X), (int)(start.Y), 2, (int)dist), null, color, (Single)angle, Vector2.Zero, SpriteEffects.None, 0.0f);
        }
        void DrawBox(Vector3 targetPosition, Vector3 targetRotation, Vector3 cameraLocation, Vector3 cameraRotation, Single fieldOfView, Color color)
        {
            var targetTest = WorldToScreen(targetPosition, cameraLocation, cameraRotation, fieldOfView);
            if (targetTest.X < 0 || targetTest.Y < 0 || targetTest.X > Width || targetTest.Y > Height)
                return;

            Single l = 60f, w = 60f, h = 160f, o = 50f;

            var zOffset = -80f;
            var xOffset = -20f;
            var yOffset = -20f;

            var p02 = new Vector3(o - l, w / 2, 0f);
            var p03 = new Vector3(o - l, -w / 2, 0f);
            var p00 = new Vector3(o, -w / 2, 0f);
            var p01 = new Vector3(o, w / 2, 0f);

            var theta1 = 2.0f * (targetRotation.FromRotator().Y);

            var cos = (float)Math.Cos(theta1);
            var sin = (float)Math.Sin(theta1);

            float[] rotMVals =
                {cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1 };
            var rotM = new Matrix(rotMVals);

            var curPos = new Vector3(targetPosition.X + xOffset, targetPosition.Y + yOffset, targetPosition.Z + zOffset);
            p01 = Vector3.TransformCoordinate(p01, rotM) + curPos;
            p03 = Vector3.TransformCoordinate(p03, rotM) + curPos;
            p00 = Vector3.TransformCoordinate(p00, rotM) + curPos;
            p02 = Vector3.TransformCoordinate(p02, rotM) + curPos;

            var s03 = WorldToScreen(p03, cameraLocation, cameraRotation, fieldOfView);
            var s00 = WorldToScreen(p00, cameraLocation, cameraRotation, fieldOfView);
            var s02 = WorldToScreen(p02, cameraLocation, cameraRotation, fieldOfView);
            var s01 = WorldToScreen(p01, cameraLocation, cameraRotation, fieldOfView);

            p03.Z += h; var s032 = WorldToScreen(p03, cameraLocation, cameraRotation, fieldOfView);
            p00.Z += h; var s002 = WorldToScreen(p00, cameraLocation, cameraRotation, fieldOfView);
            p02.Z += h; var s022 = WorldToScreen(p02, cameraLocation, cameraRotation, fieldOfView);
            p01.Z += h; var s012 = WorldToScreen(p01, cameraLocation, cameraRotation, fieldOfView);

            DrawLines(color, new Vector2[] { s00, s01, s02, s03, s00 });
            DrawLines(color, new Vector2[] { s002, s012, s022, s032, s002 });
            DrawLine(color, s03, s032);
            DrawLine(color, s00, s002);
            DrawLine(color, s02, s022);
            DrawLine(color, s01, s012);
        }
        void DrawArrow(Vector3 targetPosition, Vector3 targetRotation, Vector3 playerLocation, Vector3 cameraRotation)
        {
            if (targetPosition == playerLocation)
            {
                SpriteBatch.Draw(line, new Rectangle(100, 100, 2, 2), null, Color.Green, 0, Vector2.Zero, SpriteEffects.None, 0.0f);
                return;
            }
            var radarLoc = WorldToWindow(targetPosition, playerLocation, cameraRotation, 3000, 200);
            if (radarLoc.X > 0 && radarLoc.X < 200 && radarLoc.Y > 0 && radarLoc.Y < 200)
            {
                /*targetRotation.Normalize();
                var endLoc = targetPosition + 500 * targetRotation;
                var endRadarLoc = WorldToWindow(endLoc, playerLocation, cameraRotation, 3000, 200);
                DrawLine(Color.Yellow, radarLoc, endRadarLoc);*/
                SpriteBatch.Draw(line, new Rectangle((int)radarLoc.X, (int)radarLoc.Y, 2, 2), null, Color.Red, 0, Vector2.Zero, SpriteEffects.None, 0.0f);
            }

        }
        void DrawMenu()
        {
            if (GetKeyState((int)Keys.Insert) == 0)
            {
                var i = 0;
                SpriteBatch.DrawString(SpriteFont, "ShaIzuth's ESP", new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "FPS : " + measuredFPS.ToString("0.00"), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Enemies(F1) : " + (GetKeyState((int)Keys.F1) == 0), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Items(F2) : " + (GetKeyState((int)Keys.F2) == 0), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Trash(F3) : " + (GetKeyState((int)Keys.F3) == 1), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Debug(F4) : " + (GetKeyState((int)Keys.F4) == 1), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Ammo+Stamina(F5) : " + (GetKeyState((int)Keys.F5) == 1), new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Hide Menu (Ins)", new Vector2(20, 20 + i++ * 15), Color.White);
                SpriteBatch.DrawString(SpriteFont, "Exit (End) ", new Vector2(20, 20 + i++ * 15), Color.White);
                //SpriteBatch.DrawString(SpriteFont, "Show trash", new Vector2(20, 20 + i++ * 15), Color.White);
            }
        }
        void DrawEsp()
        {
            var World = new Engine.UEObject(Engine.GWorld);
            //var PersistentLevel = World["PersistentLevel"];
            var Levels = World["Levels"];
            var OwningGameInstance = World["OwningGameInstance"];
            //var IsInGameplay = OwningGameInstance["IsInGameplay"];
            //IsInGameplay.Invoke();
            var LocalPlayers = OwningGameInstance["LocalPlayers"];
            var PlayerController = LocalPlayers[0]["PlayerController"];
            var Player = PlayerController["Player"];
            var AcknowledgedPawn = PlayerController["AcknowledgedPawn"];
            if (AcknowledgedPawn == null || !AcknowledgedPawn.IsA("Class Engine.Character")) return;
            //Console.WriteLine(Engine.Instance.DumpClass(PlayerController.ClassAddr));
            var ComputeOffenseLevel = AcknowledgedPawn["ComputeOffenseLevel"].Invoke<UInt32>();
            var RangedWeapon = new Engine.UEObject(AcknowledgedPawn["GetCurrentRangedWeapon"].Invoke<UInt64>());
            Console.WriteLine(Engine.Instance.DumpClass(PlayerController.ClassAddr));
            if (GetKeyState((int)Keys.F5) == 1)
            {
                Engine.Memory.WriteProcessMemory(AcknowledgedPawn["Stamina"]["Value"].Address, BitConverter.GetBytes(50.0f));
                Engine.Memory.WriteProcessMemory(AcknowledgedPawn["LongGunAmmo"]["Value"].Address, BitConverter.GetBytes(100.0f));
                Engine.Memory.WriteProcessMemory(AcknowledgedPawn["HandGunAmmo"]["Value"].Address, BitConverter.GetBytes(100.0f));
                var CachedInventory = AcknowledgedPawn["CachedInventory"];
                var Items = CachedInventory["Items"];
                // item is struct, bigger than normal... need to update class to do Items[itemIndex] correctly
                var ItemsAddr = Engine.Memory.ReadProcessMemory<UInt64>(Items.Address);
                for (var itemIndex = 0u; itemIndex < Items.Num; itemIndex++)
                {
                    var ItemInstanceData = new Engine.UEObject(Engine.Memory.ReadProcessMemory<UInt64>(ItemsAddr + 3 * 8 + itemIndex * 5 * 8));
                    if (ItemInstanceData.IsA("Class GunfireRuntime.RangedWeaponInstanceData")) Engine.Memory.WriteProcessMemory(ItemInstanceData["AmmoInClip"].Address, BitConverter.GetBytes(50));
                    //if (ItemInstanceData.IsA("Class GunfireRuntime.RangedWeaponInstanceData"))
                     //   Console.WriteLine(Engine.Instance.DumpClass(ItemInstanceData.ClassAddr));
                }
            }
            var PersistentBuffs = AcknowledgedPawn["PersistentBuffs"];
            var BuffsAddr = Engine.Memory.ReadProcessMemory<UInt64>(PersistentBuffs.Address);
            for (var buffIndex = 0u; buffIndex < PersistentBuffs.Num; buffIndex++)
            {
                var ItemInstanceData1 = new Engine.UEObject(Engine.Memory.ReadProcessMemory<UInt64>(BuffsAddr + 4 * 8 + buffIndex * 5 * 8));
                var ItemInstanceData2 = new Engine.UEObject(Engine.Memory.ReadProcessMemory<UInt64>(BuffsAddr));
                //if (ItemInstanceData.IsA("Class GunfireRuntime.RangedWeaponInstanceData"))
                   //Console.WriteLine(Engine.Instance.DumpClass(ItemInstanceData1.ClassAddr));
                   //Console.WriteLine(Engine.Instance.DumpClass(ItemInstanceData2.ClassAddr));
            }
            var PlayerCameraManager = PlayerController["PlayerCameraManager"];
            //Console.WriteLine(Engine.Instance.DumpClass(PlayerCameraManager.ClassAddr));
            var CameraCache = PlayerCameraManager["CameraCachePrivate"];
            //Console.WriteLine(Engine.Instance.DumpClass(CameraCache.ClassAddr));
            var CameraPOV = CameraCache["POV"];
            var CameraLocation = Engine.Memory.ReadProcessMemory<Vector3>(CameraPOV["Location"].Address);
            var CameraRotation = Engine.Memory.ReadProcessMemory<Vector3>(CameraPOV["Rotation"].Address);
            var CameraFOV = Engine.Memory.ReadProcessMemory<Single>(CameraPOV["FOV"].Address);

            var PlayerRoot = AcknowledgedPawn["RootComponent"];
            var PlayerRelativeLocation = PlayerRoot["RelativeLocation"];
            var PlayerLocation = Engine.Memory.ReadProcessMemory<Vector3>(PlayerRelativeLocation.Address);
            //Console.WriteLine(Engine.Instance.DumpClass(PlayerRoot.ClassAddr));
            //var PlayerRotation = Engine.Memory.ReadProcessMemory<Vector3>(PlayerRelativeLocation.Address + 24);
            //var SetHealth = AcknowledgedPawn["SetActorScale3D"];
            //var GetHealthMax = AcknowledgedPawn["GetHealthMax"];
            //GetHealthMax.Invoke();
            //var rot = Player["ViewportClient"];
            //var ro2t = Engine.Memory.ReadProcessMemory<Vector3>(PlayerController["ControlRotation"].Address);
            //var ro3t = Engine.Memory.ReadProcessMemory<Vector3>(PlayerController["TargetViewRotation"].Address);
            //var rot = Engine.Memory.ReadProcessMemory<Vector3>(AcknowledgedPawn["ViewRotation"].Address);;
            DrawArrow(PlayerLocation, CameraRotation, PlayerLocation, CameraRotation);
            var bestAngle = Single.MaxValue;
            var bestTurn = Vector3.Zero;
            var bestLocation = Vector3.Zero;
            var bestRotation = Vector3.Zero;
            var target = Vector2.Zero;
            for (var levelIndex = 1u; levelIndex < Levels.Num; levelIndex++)
            {
                var Level = Levels[levelIndex];
                // https://github.com/EpicGames/UnrealEngine/blob/4.22.3-release/Engine/Source/Runtime/Engine/Classes/Engine/Level.h#L376 doesn't exist by string
                var Actors = new Engine.UEObject(Level.Address + 0xA8);
                for (var i = 0u; i < Actors.Num; i++)
                {
                    var Actor = Actors[i];
                    if (Actor.Address == 0) continue;
                    if (Actor.Value == 0) continue;
                    if (Actor.IsA("Class Remnant.RemnantWeaponMod"))
                    {
                        Console.WriteLine("rawr");
                    }
                    if (Actor.IsA("Class GunfireRuntime.Item") || Actor.IsA("Class Remnant.LootContainer"))
                    {
                        var RootComponent = Actor["RootComponent"];
                        if (RootComponent == null || RootComponent.Address == 0 || !RootComponent.ClassName.Contains("Component")) continue;
                        var RelativeLocation = RootComponent["RelativeLocation"];
                        var Location = Engine.Memory.ReadProcessMemory<Vector3>(RelativeLocation.Address);
                        if (Actor["bActorIsBeingDestroyed"].Value == 1) continue;
                        var loc = WorldToScreen(Location, CameraLocation, CameraRotation, CameraFOV);
                        if (loc.X > 0 && loc.Y > 0 && loc.X < Width && loc.Y < Height)
                        {
                            var dist = ((CameraLocation - Location).Length() / 100.0f).ToString("0.0");

                            if (GetKeyState((int)Keys.F2) == 0)
                            {
                                if (Actor.ClassName.Contains("TraitBook")) SpriteBatch.DrawString(SpriteFont, "Trait(" + dist + ")", loc, Color.CornflowerBlue);
                                else if (Actor.ClassName.Contains("LootContainer"))
                                {
                                    var tag = Engine.Memory.ReadProcessMemory<UInt16>(Actor.Address + 0x198);
                                    if (tag != 1) SpriteBatch.DrawString(SpriteFont, "Box(" + dist + ")", loc, Color.Cyan);
                                    //else SpriteBatch.DrawString(SpriteFont, "BoxOpened(" + dist + ")", loc, Color.Cyan);
                                }
                                else if (Actor.ClassName.Contains("Trinket"))
                                {
                                    var ItemName = Actor.ClassName.Substring(Actor.ClassName.IndexOf("Trinket") + 8);
                                    ItemName = ItemName.Substring(0, ItemName.IndexOf("Trinket") - 1);
                                    SpriteBatch.DrawString(SpriteFont, ItemName + "(" + dist + ")", loc, Color.Magenta);
                                }
                                else if (Actor.ClassName.Contains("GenericItem") || Actor.ClassName.Contains("Traits"))
                                {
                                    var InteractLabel = Engine.Memory.ReadProcessMemory<UInt64>(Actor["InteractLabel"].Address);
                                    var ItemNameAddr = Engine.Memory.ReadProcessMemory<UInt64>(InteractLabel + 0x28); ;
                                    var ItemName = Engine.Memory.ReadProcessMemory<String>(ItemNameAddr);
                                    SpriteBatch.DrawString(SpriteFont, ItemName + "(" + dist + ")", loc, Color.Magenta);
                                }
                            }
                            if (GetKeyState((int)Keys.F3) == 1)
                            {
                                if (Actor.ClassName.Contains("Scraps")) SpriteBatch.DrawString(SpriteFont, "Scrap(" + dist + ")", loc, Color.PaleGoldenrod);
                                else if (Actor.ClassName.Contains("Ammo_HandGun")) SpriteBatch.DrawString(SpriteFont, "SAmmo(" + dist + ")", loc, Color.White);
                                else if (Actor.ClassName.Contains("Ammo_LongGun")) SpriteBatch.DrawString(SpriteFont, "PAmmo(" + dist + ")", loc, Color.Red);
                                else if (Actor.ClassName.Contains("Consumable")) SpriteBatch.DrawString(SpriteFont, "Item(" + dist + ")", loc, Color.Green);
                                else if (Actor.ClassName.Contains("Iron")) SpriteBatch.DrawString(SpriteFont, "Iron(" + dist + ")", loc, Color.PaleGoldenrod);
                            }                            
                            if (GetKeyState((int)Keys.F4) == 1)
                                SpriteBatch.DrawString(SpriteFont, "Debug(" + dist + ")" + Actor.ClassName, loc, Color.White);

                        }
                    }
                    if (GetKeyState((int)Keys.F1) == 0 && Actor.IsA("Class Engine.Character"))
                    {
                        var RootComponent = Actor["RootComponent"];
                        if (RootComponent == null || RootComponent.Address == 0 || !RootComponent.IsA("Class Engine.CapsuleComponent")) continue;
                        var RelativeLocation = RootComponent["RelativeLocation"];
                        var Location = Engine.Memory.ReadProcessMemory<Vector3>(RelativeLocation.Address);
                        //var RelativeRotation = RootComponent["RelativeRotation"];
                        var Rotation = Engine.Memory.ReadProcessMemory<Vector3>(RelativeLocation.Address + 24);
                        if (Actor["bActorIsBeingDestroyed"].Value == 1) continue;
                        var hp = Engine.Memory.ReadProcessMemory<Single>(Actor["HealthNormalized"].Address);
                        if (hp == 0) continue;
                        DrawBox(Location, Rotation, CameraLocation, CameraRotation, CameraFOV, Color.Red);
                        DrawArrow(Location, Rotation, PlayerLocation, CameraRotation);
                        var Silhouette = Actor["Silhouette"];
                        var RemnantSilhouette = Actor["RemnantSilhouette"];
                        var DisplayInfoComponent = Actor["DisplayInfoComponent"];
                        var Dormant_Emis = Actor["NonDormant_Emis"];
                        var q = Engine.Memory.ReadProcessMemory<Vector3>(Dormant_Emis.Address); ;
                        var MaxDistance = Silhouette["MaxDistance"];
                        var OutlineAddr = Silhouette["DefaultSilhouetteColorIdx"].Address + 4;
                        //Engine.Memory.WriteProcessMemory(OutlineAddr, BitConverter.GetBytes((UInt16)0x101));
                        var targetTest = WorldToScreen(Location, CameraLocation, CameraRotation, CameraFOV);
                        var test1 = Engine.Memory.ReadProcessMemory<UInt32>(MaxDistance.Address);
                        var test3 = Engine.Memory.ReadProcessMemory<UInt16>(OutlineAddr).ToString("X");
                        var test4 = Engine.Memory.ReadProcessMemory<UInt64>(Silhouette["DefaultSilhouetteColorIdx"].Address + 0x10).ToString("X");
                        /*SpriteBatch.DrawString(SpriteFont, "Debug" + BitConverter.ToSingle(BitConverter.GetBytes(test1), 0)
                            + ": " + test3 + " : rt"
                            + Silhouette["bIsActive"].Value.ToString("X") + " : vt"
                            + Silhouette["ViewerTag"].Value.ToString("X") + " : vis" 
                            + Silhouette["Visibility"].Value.ToString("X") + " : dc" 
                            + Silhouette["DefaultSilhouetteColorIdx"].Value.ToString("X") + " : ??" 
                            + test4
                            , targetTest, Color.White);*/
                        SpriteBatch.DrawString(SpriteFont, Actor.Address.ToString("X")
                            , targetTest, Color.White);
                       // Console.WriteLine(Engine.Instance.DumpClass(DisplayInfoComponent.ClassAddr));
                        if ((GetKeyState((int)Keys.RButton) & 0x100) != 0)
                        {
                            var turnVector = CameraLocation.CalcRotation(Location, CameraRotation, 0.0f);
                            var turnWeight = (Single)(CameraRotation - turnVector).Length();
                            if (turnWeight < bestAngle)
                            {
                                bestTurn = turnVector;
                                bestAngle = turnWeight;
                                bestLocation = Location;
                                bestRotation = Rotation;

                                target = WorldToScreen(Location, CameraLocation, CameraRotation, CameraFOV);
                            }
                        }
                    }
                }
            }
            if ((GetKeyState((int)Keys.RButton) & 0x100) != 0)
            {
                DrawBox(bestLocation, bestRotation, CameraLocation, CameraRotation, CameraFOV, Color.Green);
                //PlayerController["SetControlRotation"].Invoke<UInt32>(bestTurn, true);
                //PlayerController["ClientSetLocation"].Invoke<UInt32>(CameraLocation, CameraRotation);
                //AcknowledgedPawn["Jump"].Invoke<UInt32>();
                //AcknowledgedPawn["SetControlRotation"].Invoke<UInt32>();
                //PlayerCameraManager["K2_SetActorRotation"].Invoke<UInt32>(bestTurn, true, true);
                //AcknowledgedPawn["K2_SetActorRotation"].Invoke<UInt32>(bestTurn, true, true);
                PlayerController["StartFire"].Invoke<UInt32>(true);
                PlayerController["ServerUpdateCamera"].Invoke<UInt32>("wtffix");
                PlayerController["GetHud"].Invoke<UInt32>("wtffix");
                //RangedWeapon["OnFire"].Invoke<UInt32>(PlayerLocation, bestLocation, 1.0f);
                //RangedWeapon["ServerFire"].Invoke<UInt32>(PlayerLocation, bestLocation, 1.0f, (Int32)123, 0, 0, 0, 0, 0, 0);
                //RangedWeapon["ServerUse"].Invoke<UInt32>();
                //AimAtPos(target);
                //Engine.Memory.WriteProcessMemory(PlayerController["ControlRotation"].Address, bestTurn);
                //Engine.Memory.WriteProcessMemory(CameraPOV["Rotation"].Address, bestTurn);
            }
        }
        Int32 Height = 0;
        Int32 Width = 0;
        Stopwatch clock = new Stopwatch();
        long frameCount;
        double measuredFPS;
        protected override void Draw(GameTime gameTime)
        {
            if (GetKeyState((int)Keys.End) == 1)
                Environment.Exit(0);
            if (!clock.IsRunning) clock.Start();
            frameCount++;
            if (clock.ElapsedMilliseconds >= 1000)
            {
                measuredFPS = (double)frameCount / (clock.ElapsedMilliseconds/ 1000.0f);
                frameCount = 0;
                clock.Restart();
            }
            Height = ((Form)Window.NativeWindow).ClientSize.Height;
            Width = ((Form)Window.NativeWindow).ClientSize.Width;
            GraphicsDevice.Clear(Color.AntiqueWhite);
            SpriteBatch.Begin(SpriteSortMode.Immediate, GraphicsDevice.BlendStates.Default);
            DrawMenu();
            DrawEsp();
            SpriteBatch.End();
            base.Draw(gameTime);
        }
        private void AimAtPos(Vector2 location, Single smoothSpeed = 2)
        {
            Single ScreenCenterX = Width / 2;
            Single ScreenCenterY = Height / 2;
            Single TargetX = 0;
            Single TargetY = 0;
            if (location.X > ScreenCenterX)
            {
                TargetX = -(ScreenCenterX - location.X);
                TargetX /= smoothSpeed;
            }
            else if (location.X < ScreenCenterX)
            {
                TargetX = location.X - ScreenCenterX;
                TargetX /= smoothSpeed;
            }
            if (location.Y > ScreenCenterY)
            {
                TargetY = -(ScreenCenterY - location.Y);
                TargetY /= smoothSpeed;
            }
            else if (location.Y < ScreenCenterY)
            {
                TargetY = location.Y - ScreenCenterY;
                TargetY /= smoothSpeed;
            }
            if (TargetX > 10) TargetX = 10;
            if (TargetY > 10) TargetY = 10;
            mouse_event(0x0001, (int)TargetX, (int)TargetY, 0, 0);
        }
        [DllImport("user32")] static extern Int32 GetWindowLong(IntPtr hWnd, int nIndex);
        [DllImport("user32")] static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
        [DllImport("user32")] static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);
        [DllImport("user32")] static extern bool SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
        [DllImport("user32")] static extern IntPtr SetActiveWindow(IntPtr handle);
        [DllImport("user32")] static extern short GetKeyState(int keyCode);
        [DllImport("user32")] static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);
        protected void WndProc(ref Message m)
        {
            if (m.Msg == 0x0021)
            {
                m.Result = (IntPtr)4; // prevent the form from being clicked and gaining focus
                return;
            }
            else if (m.Msg == 6)
            {
                if (((int)m.WParam & 0xFFFF) != 0)
                    if (m.LParam != IntPtr.Zero) SetActiveWindow(m.LParam);
                    else SetActiveWindow(IntPtr.Zero);
            }
        }
    }
}

```

`RemnantESP/Engine.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;

namespace RemnantESP
{
    public class Engine
    {
        public static Engine Instance;
        public static UInt64 GNames;
        public static UInt64 GObjects;
        public static UInt64 GWorld;

        public static Memory Memory;

        public Engine(Memory mem) { Memory = mem; Instance = this; }
        public void UpdateAddresses()
        {
            // https://github.com/EpicGames/UnrealEngine/blob/4.22.3-release/Engine/Source/Runtime/Core/Private/UObject/UnrealNames.cpp#L888 Hardcoded name '%s'
            var GNamesPattern = (UInt64)Memory.FindPattern("48 8B 05 ? ? ? ? 48 85 C0 75 5F");
            // https://github.com/EpicGames/UnrealEngine/blob/4.22.3-release/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3905 r.OneFrameThreadLag
            var GWorldPattern = (UInt64)Memory.FindPattern("48 8B 1D ? ? ? ? 48 85 DB 74 3B 41 B0 01");
            // var obj = (gobject + 8i64 * (index / 0x10000)), inlined/appears multiple
            var GObjectsPattern = (UInt64)Memory.FindPattern("C1 F9 10 48 63 C9 48 8D 14 40 48 8B 05");
            var GObjectsPattern2 = (UInt64)Memory.FindPattern("45 33 F6 4D 8B E0");
            var GObjectsPattern3 = (UInt64)Memory.FindPattern("45 33 F6 3B 05 ? ? ? ? 4D 8B E0");
            //var GObjectsPattern = (UInt64)Memory.FindPattern("4C 8B 15 ? ? ? ? 8D 43 01");

            var offset = Memory.ReadProcessMemory<UInt32>(GNamesPattern + 3);
            GNames = Memory.ReadProcessMemory<UInt64>(GNamesPattern + offset + 7);

            offset = Memory.ReadProcessMemory<UInt32>(GObjectsPattern + 13);
            GObjects = GObjectsPattern + offset + 17 - Memory.BaseAddress;

            offset = Engine.Memory.ReadProcessMemory<UInt32>(GWorldPattern + 3);
            GWorld = Memory.ReadProcessMemory<UInt64>(GWorldPattern + offset + 7);

            // DumpClasses();
            //DumpGNames();
        }
        public String GetName(Int32 i)
        {
            var fNamePtr = Memory.ReadProcessMemory<ulong>(GNames + ((UInt64)i / 0x4000) * 8);
            var fName2 = Memory.ReadProcessMemory<ulong>(fNamePtr + (8 * ((UInt64)i % 0x4000)));
            var fName3 = Memory.ReadProcessMemory<String>(fName2 + 0xC); // 0x10 on some version?
            if (fName3.Contains("/")) return fName3.Substring(fName3.LastIndexOf("/") + 1);
            return fName3;
        }
        ConcurrentDictionary<UInt64, String> AddrToClass = new ConcurrentDictionary<UInt64, String>();
        public String GetFullName(UInt64 entityAddr)
        {
            if (AddrToClass.ContainsKey(entityAddr)) return AddrToClass[entityAddr];
            var classPtr = Memory.ReadProcessMemory<UInt64>(entityAddr + 0x10);
            var classNameIndex = Memory.ReadProcessMemory<Int32>(classPtr + 0x18);
            var name = GetName(classNameIndex);
            UInt64 outerEntityAddr = entityAddr;
            var parentName = "";
            //while ((outerEntityAddr = Memory.ReadProcessMemory<UInt64>(outerEntityAddr + 0x20)) > 0)
            while (true)
            {
                var tempOuterEntityAddr = Memory.ReadProcessMemory<UInt64>(outerEntityAddr + 0x20);
                if (tempOuterEntityAddr == outerEntityAddr || tempOuterEntityAddr == 0) break;
                outerEntityAddr = tempOuterEntityAddr;
                var outerNameIndex = Memory.ReadProcessMemory<Int32>(outerEntityAddr + 0x18);
                var tempName = GetName(outerNameIndex);
                if (tempName == "") break;
                if (tempName == "None") break;
                parentName = tempName + "." + parentName;
            }
            name += " " + parentName;
            var nameIndex = Memory.ReadProcessMemory<Int32>(entityAddr + 0x18);
            name += GetName(nameIndex);
            AddrToClass[entityAddr] = name;
            return name;
        }
        ConcurrentDictionary<String, Boolean> ClassIsSubClass = new ConcurrentDictionary<String, Boolean>();
        public Boolean IsA(UInt64 entityClassAddr, UInt64 targetClassAddr)
        {
            var key = entityClassAddr + ":" + targetClassAddr;
            if (ClassIsSubClass.ContainsKey(key)) return ClassIsSubClass[key];
            if (entityClassAddr == targetClassAddr) return true;
            while (true)
            {
                var tempEntityClassAddr = Memory.ReadProcessMemory<UInt64>(entityClassAddr + 0x40);
                if (entityClassAddr == tempEntityClassAddr || tempEntityClassAddr == 0)
                    break;
                entityClassAddr = tempEntityClassAddr;
                if (entityClassAddr == targetClassAddr)
                {
                    ClassIsSubClass[key] = true;
                    return true;
                }
            }
            ClassIsSubClass[key] = false;
            return false;
        }
        ConcurrentDictionary<String, UInt64> ClassToAddr = new ConcurrentDictionary<String, UInt64>();
        public UInt64 FindClass(String className)
        {
            if (ClassToAddr.ContainsKey(className)) return ClassToAddr[className];
            var masterEntityList = Memory.ReadProcessMemory<UInt64>(Memory.BaseAddress + GObjects);
            var num = Memory.ReadProcessMemory<UInt64>(Memory.BaseAddress + GObjects + 0x14);
            var entityChunk = 0u;
            var entityList = Memory.ReadProcessMemory<UInt64>(masterEntityList);
            for (var i = 0u; i < num; i++)
            {
                if ((i / 0x10000) != entityChunk)
                {
                    entityChunk = (UInt32)(i / 0x10000);
                    entityList = Memory.ReadProcessMemory<UInt64>(masterEntityList + 8 * entityChunk);
                }
                var entityAddr = Memory.ReadProcessMemory<UInt64>(entityList + 24 * (i % 0x10000));
                if (entityAddr == 0) continue;
                var name = GetFullName(entityAddr);
                if (name == className)
                {
                    ClassToAddr[className] = entityAddr;
                    return entityAddr;
                }
            }
            return 0;
        }
        public Int32 FieldIsClass(String className, String fieldName)
        {
            var classAddr = FindClass(className);
            var fieldAddr = GetFieldAddr(classAddr, classAddr, fieldName);
            var offset = GetFieldOffset(fieldAddr);
            return offset;
        }
        ConcurrentDictionary<UInt64, ConcurrentDictionary<String, UInt64>> ClassFieldToAddr = new ConcurrentDictionary<UInt64, ConcurrentDictionary<String, UInt64>>();
        public UInt64 GetFieldAddr(UInt64 origClassAddr, UInt64 classAddr, String fieldName)
        {
            if (ClassFieldToAddr.ContainsKey(origClassAddr) && ClassFieldToAddr[origClassAddr].ContainsKey(fieldName)) return ClassFieldToAddr[origClassAddr][fieldName];
            var field = classAddr + 0x40; // 0x10 on some versions?
            while ((field = Memory.ReadProcessMemory<UInt64>(field + 0x28)) > 0)
            {
                var fName = GetName(Memory.ReadProcessMemory<Int32>(field + 0x18));
                if (fName == fieldName)
                {
                    //var offset = Memory.ReadProcessMemory<Int32>(field + 0x44);
                    if (!ClassFieldToAddr.ContainsKey(origClassAddr))
                        ClassFieldToAddr[origClassAddr] = new ConcurrentDictionary<String, UInt64>();
                    ClassFieldToAddr[origClassAddr][fieldName] = field;
                    return field;
                }
            }
            var parentClass = Memory.ReadProcessMemory<UInt64>(classAddr + 0x40); // 0x30 on some versions
            var c = GetFullName(classAddr);
            var pc = GetFullName(parentClass);
            if (parentClass == classAddr) throw new Exception("parent is me");
            if (parentClass == 0) throw new Exception("bad field");
            return GetFieldAddr(origClassAddr, parentClass, fieldName);
        }
        ConcurrentDictionary<UInt64, Int32> FieldAddrToOffset = new ConcurrentDictionary<UInt64, Int32>();
        public Int32 GetFieldOffset(UInt64 fieldAddr)
        {
            if (FieldAddrToOffset.ContainsKey(fieldAddr)) return FieldAddrToOffset[fieldAddr];
            var offset = Memory.ReadProcessMemory<Int32>(fieldAddr + 0x44);
            FieldAddrToOffset[fieldAddr] = offset;
            return offset;
        }
        ConcurrentDictionary<UInt64, String> FieldAddrToType = new ConcurrentDictionary<UInt64, String>();
        public String GetFieldType(UInt64 fieldAddr)
        {
            if (FieldAddrToType.ContainsKey(fieldAddr)) return FieldAddrToType[fieldAddr];
            var fieldType = Memory.ReadProcessMemory<UInt64>(fieldAddr + 0x10);
            var name = GetName(Memory.ReadProcessMemory<Int32>(fieldType + 0x18));
            FieldAddrToType[fieldAddr] = name;
            return name;
        }
        public String DumpClass(String className)
        {
            var classAddr = FindClass(className);
            return DumpClass(classAddr);
        }
        public String DumpClass(UInt64 classAddr)
        {
            var sb = new StringBuilder();
            var name = GetFullName(classAddr);
            sb.Append(classAddr.ToString("X") + " : " + name);
            var pcAddr = classAddr;
            var c = 0;
            while ((pcAddr = Memory.ReadProcessMemory<UInt64>(pcAddr + 0x40)) > 0 && c++ < 20)
            {
                var super = GetFullName(pcAddr);
                sb.Append(" : " + super);
            }
            sb.AppendLine();

            pcAddr = classAddr;
            //while ((pcAddr = Memory.ReadProcessMemory<UInt64>(pcAddr + 0x40)) > 0)
            while (true)
            {
                var field = pcAddr + 0x40;
                while (true)
                {
                    var nextField = Memory.ReadProcessMemory<UInt64>(field + 0x28);
                    if (nextField == field) break;
                    field = nextField;
                    if (field == 0) break;
                    var fieldName = GetFullName(field);
                    var f = Memory.ReadProcessMemory<UInt64>(field + 0x70);
                    var fType = GetName(Memory.ReadProcessMemory<Int32>(f + 0x18));
                    var fName = GetName(Memory.ReadProcessMemory<Int32>(field + 0x18));
                    var offset = Memory.ReadProcessMemory<Int32>(field + 0x44);
                    if (fType == "None" && String.IsNullOrEmpty(fName)) break;
                    var fieldObj = new UEObject(field);
                    if (fieldObj.ClassName == "Class CoreUObject.Function")
                    {
                        sb.AppendLine("  " + fType + " " + fName + "(" + fieldObj.ClassName + ") : 0x" + offset.ToString("X"));
                        var funcParams = field + 0x20u;
                        while ((funcParams = Memory.ReadProcessMemory<UInt64>(funcParams + 0x28u)) > 0)
                        {
                            sb.AppendLine("      " + GetFullName(funcParams));
                        }
                    }
                    else
                        sb.AppendLine("  " + fType + " " + fName + "(" + fieldObj.ClassName + ") : 0x" + offset.ToString("X"));
                }
                pcAddr = Memory.ReadProcessMemory<UInt64>(pcAddr + 0x40);
                if (pcAddr == 0) break;
            }
            return sb.ToString();
        }
        public void DumpClasses()
        {
            var masterEntityList = Memory.ReadProcessMemory<UInt64>(Memory.BaseAddress + GObjects);
            var num = Memory.ReadProcessMemory<UInt32>(Memory.BaseAddress + GObjects + 0x14);
            var entityChunk = 0u;
            var entityList = Memory.ReadProcessMemory<UInt64>(masterEntityList);
            var sb = new StringBuilder();
            for (var i = 0u; i < num; i++)
            {
                if ((i / 0x10000) != entityChunk)
                {
                    entityChunk = (UInt32)(i / 0x10000);
                    entityList = Memory.ReadProcessMemory<UInt64>(masterEntityList + 8 * entityChunk);
                }
                var entityAddr = Memory.ReadProcessMemory<UInt64>(entityList + 24 * (i % 0x10000));
                if (entityAddr == 0) continue;
                sb.AppendLine(DumpClass(entityAddr).ToString());
            }
            System.IO.File.WriteAllText("classes.txt", sb.ToString());
        }
        public void DumpGNames()
        {
            var count = 0x100000;
            var sb = new StringBuilder();
            for (var i = 0u; i < count; i++)
            {
                var name = GetName((Int32)i);
                var fNamePtr = Memory.ReadProcessMemory<ulong>(GNames + (i / 0x4000) * 8);
                var fName2 = Memory.ReadProcessMemory<ulong>(fNamePtr + (8 * (i % 0x4000)));
                var fNameI = Memory.ReadProcessMemory<Int32>(fName2);
                var fName3 = Memory.ReadProcessMemory<String>(fName2 + 0xc);
                sb.AppendLine(fNameI.ToString("X") + " : " + fName3 + " (" + i.ToString("X") + ")");
                //System.IO.File.AppendAllText("gnames.txt", fNameI.ToString("X") + " : " + fName3 + " (" + i.ToString("X") + ")\n");
                //Console.WriteLine(fNameI.ToString("X") + " : " + fName3 + " (" + i + ")");
            }
            System.IO.File.WriteAllText("gname.txt", sb.ToString());
        }
        public void DumpGObjects()
        {
            var sb = new StringBuilder();
            var entityList = Memory.ReadProcessMemory<UInt64>(Memory.BaseAddress + GObjects);
            var count = Memory.ReadProcessMemory<UInt32>(Memory.BaseAddress + GObjects + 0x14);
            entityList = Memory.ReadProcessMemory<UInt64>(entityList);
            for (var i = 0u; i < count; i++)
            {
                var entityAddr = Memory.ReadProcessMemory<UInt64>((entityList + 8 * (i / 66560)) + 24 * (i % 66560));
                if (entityAddr == 0) continue;
                var name = GetFullName(entityAddr);
                sb.AppendLine(i + " : " + entityAddr.ToString("X") + " : " + name);
            }
            System.IO.File.WriteAllText("gobjects.txt", sb.ToString());
        }
        public void DumpActors()
        {
            var sb = new System.Text.StringBuilder();

            var World = new UEObject(Engine.GWorld);
            var Levels = World["Levels"];
            for (var levelIndex = 0u; levelIndex < Levels.Num; levelIndex++)
            {
                var Level = Levels[levelIndex];
                var Actors = new Engine.UEObject(Level.Address + 0xA8);
                for (var i = 0u; i < Actors.Num; i++)
                {
                    var Actor = Actors[i];
                    var debug = GetFullName(Actor.Address) + " || " + Actor.ClassName + " || " + DumpClass(Actor.ClassAddr);
                    sb.AppendLine(i + " : " + debug);

                }
            }
            System.IO.File.WriteAllText("actors.txt", sb.ToString());
        }
        public class UEObject
        {
            String _className;
            public String ClassName
            {
                get
                {
                    if (_className != null) return _className;
                    _className = Engine.Instance.GetFullName(ClassAddr);
                    return _className;
                }
            }
            static ConcurrentDictionary<UInt64, UInt64> ObjToClass = new ConcurrentDictionary<UInt64, UInt64>();
            UInt64 _classAddr = UInt64.MaxValue;
            public UInt64 ClassAddr
            {
                get
                {
                    if (_classAddr != UInt64.MaxValue) return _classAddr;
                    if (ObjToClass.ContainsKey(Address))
                    {
                        // _classAddr = ObjToClass[Address];
                        // return _classAddr;
                    }
                    _classAddr = Engine.Memory.ReadProcessMemory<UInt64>(Address + 0x10);
                    //ObjToClass[Address] = _classAddr;
                    return _classAddr;
                }
            }
            public UEObject(UInt64 address)
            {
                Address = address;
            }
            public Boolean IsA(String className)
            {
                return Engine.Instance.IsA(ClassAddr, Engine.Instance.FindClass(className));
            }
            public UInt32 FieldOffset;
            public Byte[] Data;
            public UInt64 _value = UInt64.MaxValue;
            public UInt64 Value
            {
                get
                {
                    if (_value != UInt64.MaxValue) return _value;
                    _value = Engine.Memory.ReadProcessMemory<UInt64>(Address);
                    return _value;
                }
                set
                {
                    Engine.Memory.WriteProcessMemory(Address, value);
                }
            }
            public UInt64 Address;
            public UEObject this[String key]
            {
                get
                {
                    var fieldAddr = Engine.Instance.GetFieldAddr(ClassAddr, ClassAddr, key);
                    var fieldType = Engine.Instance.GetFieldType(fieldAddr);
                    var offset = (UInt32)Engine.Instance.GetFieldOffset(fieldAddr);
                    UEObject obj;
                    if (fieldType == "ObjectProperty" || fieldType == "ScriptStruct")
                        obj = new UEObject(Engine.Memory.ReadProcessMemory<UInt64>(Address + offset)) { FieldOffset = offset };
                    else if (fieldType == "ArrayProperty")
                    {
                        obj = new UEObject(Address + offset);
                        obj._classAddr = Engine.Memory.ReadProcessMemory<UInt64>(fieldAddr + 0x10);
                    }
                    else if (fieldType.Contains("Bool"))
                    {
                        obj = new UEObject(Address + offset);
                        obj._classAddr = Engine.Memory.ReadProcessMemory<UInt64>(fieldAddr + 0x10);
                        var boolMask = Engine.Memory.ReadProcessMemory<UInt64>(fieldAddr + 0x70);
                        boolMask = (boolMask >> 16) & 0xff;
                        var fullVal = Engine.Memory.ReadProcessMemory<Byte>(Address + offset);
                        obj._value = ((fullVal & boolMask) == boolMask) ? 1u : 0;
                    }
                    else if (fieldType.Contains("Function"))
                    {
                        obj = new UEObject(fieldAddr);
                        obj.BaseObjAddr = Address;
                    }
                    else
                    {
                        obj = new UEObject(Address + offset);
                        obj._classAddr = Engine.Memory.ReadProcessMemory<UInt64>(fieldAddr + 0x70);
                    }
                    if (obj.Address == 0)
                    {
                        return null;
                        //var classInfo = Engine.Instance.DumpClass(ClassAddr);
                        //throw new Exception("bad addr");
                    }
                    return obj;
                }
            }
            public UInt32 Num { get { return Engine.Memory.ReadProcessMemory<UInt32>(Address + 8); } }
            public UEObject this[UInt32 index]
            {
                get
                {
                    return new UEObject(Engine.Memory.ReadProcessMemory<UInt64>(Engine.Memory.ReadProcessMemory<UInt64>(Address) + index * 8));
                }
            }
            UInt64 BaseObjAddr;
            static UInt32 _vTableVFunc = UInt32.MaxValue;
            UInt32 VTableVFunc
            {
                get
                {
                    if (_vTableVFunc != UInt32.MaxValue) return _vTableVFunc;
                    var v = Engine.Memory.ReadProcessMemory<UInt64>(BaseObjAddr);
                    for (var i = 60u; i < 75; i++)
                    {
                        var s = (IntPtr)Engine.Memory.ReadProcessMemory<UInt64>(v + i * 8);
                        var sig = (UInt64)Engine.Memory.FindPattern("48 8B EA 48 8B D9 FF 90 ? ? ? ? 48 85 C0", s, 0x200);
                        if (sig != 0)
                        {
                            _vTableVFunc = i;
                            return _vTableVFunc;
                        }
                    }
                    throw new Exception("not found");
                }
            }
            public T Invoke<T>(params Object[] args)
            {
                var vTableFunc = Engine.Memory.ReadProcessMemory<UInt64>(BaseObjAddr) + VTableVFunc * 8;
                vTableFunc = Engine.Memory.ReadProcessMemory<UInt64>(vTableFunc);
                return Engine.Memory.Execute<T>((IntPtr)vTableFunc, (IntPtr)BaseObjAddr, (IntPtr)Address, args);
            }
        }
    }
}

```

`RemnantESP/Extensions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;
using SharpDX;
using SharpDX.Direct2D1;
using SharpDX.DirectWrite;
using SharpDX.Toolkit;
using SharpDX.Toolkit.Graphics;

namespace RemnantESP
{
    public static class Extensions
    {
        public static Single Mult(this Vector3 v, Vector3 s) => v.X * s.X + v.Y * s.Y + v.Z * s.Z;
        public static void GetAxes(this Vector3 v, out Vector3 x, out Vector3 y, out Vector3 z)
        {
            var m = v.ToMatrix();

            x = new Vector3(m[0, 0], m[0, 1], m[0, 2]);
            y = new Vector3(m[1, 0], m[1, 1], m[1, 2]);
            z = new Vector3(m[2, 0], m[2, 1], m[2, 2]);
        }
        public static Vector3 FromRotator(this Vector3 v)
        {
            float radPitch = (float)(v.X * Math.PI / 180f);
            float radYaw = (float)(v.Y * Math.PI / 180f);
            float SP = (float)Math.Sin(radPitch);
            float CP = (float)Math.Cos(radPitch);
            float SY = (float)Math.Sin(radYaw);
            float CY = (float)Math.Cos(radYaw);
            return new Vector3(CP * CY, CP * SY, SP);
        }
        public static Single[,] ToMatrix(this Vector3 v, Vector3 origin = default(Vector3))
        {
            if (origin == default)
                origin = default;
            var radPitch = (Single)(v.X * Math.PI / 180f);
            var radYaw = (Single)(v.Y * Math.PI / 180f);
            var radRoll = (Single)(v.Z * Math.PI / 180f);

            var SP = (Single)Math.Sin(radPitch);
            var CP = (Single)Math.Cos(radPitch);
            var SY = (Single)Math.Sin(radYaw);
            var CY = (Single)Math.Cos(radYaw);
            var SR = (Single)Math.Sin(radRoll);
            var CR = (Single)Math.Cos(radRoll);

            var m = new Single[4, 4];
            m[0, 0] = CP * CY;
            m[0, 1] = CP * SY;
            m[0, 2] = SP;
            m[0, 3] = 0f;

            m[1, 0] = SR * SP * CY - CR * SY;
            m[1, 1] = SR * SP * SY + CR * CY;
            m[1, 2] = -SR * CP;
            m[1, 3] = 0f;

            m[2, 0] = -(CR * SP * CY + SR * SY);
            m[2, 1] = CY * SR - CR * SP * SY;
            m[2, 2] = CR * CP;
            m[2, 3] = 0f;

            m[3, 0] = origin.X;
            m[3, 1] = origin.Y;
            m[3, 2] = origin.Z;
            m[3, 3] = 1f;
            return m;
        }

        public static Vector3 CalcRotation(this Vector3 source, Vector3 destination, Vector3 origAngles, Single smooth)
        {
            var angles = new Vector3();
            var diff = source - destination;
            var hyp = Math.Sqrt(diff.X * diff.X + diff.Y * diff.Y);
            angles.Y = (Single)Math.Atan(diff.Y / diff.X) * 57.295779513082f;
            angles.X = -(Single)Math.Atan(diff.Z / hyp) * 57.295779513082f;
            angles.Z = 0.0f;
            if (diff.X >= 0.0)
            {
                if (angles.Y > 0)
                    angles.Y -= 180.0f;
                else
                    angles.Y += 180.0f;
            }
            if (smooth > 0 && Math.Abs(angles.Y - origAngles.Y) < 180.0f)
                angles -= ((angles - origAngles) * smooth);
            return angles;
        }
    }
}

```

`RemnantESP/FodyWeavers.xml`:

```xml
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers>
```

`RemnantESP/FodyWeavers.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Costura" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:all>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged32Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged64Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="PreloadOrder" type="xs:string">
                <xs:annotation>
                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:all>
            <xs:attribute name="CreateTemporaryAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeDebugSymbols" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCompression" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCleanup" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="LoadAtModuleInit" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IgnoreSatelliteAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged32Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged64Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreloadOrder" type="xs:string">
              <xs:annotation>
                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

`RemnantESP/Memory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SharpDX;

namespace RemnantESP
{
    public class Memory : IDisposable
    {
        [DllImport("kernel32")] static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, Int32 bInheritHandle, Int32 dwProcessId);
        [DllImport("kernel32")] static extern Int32 ReadProcessMemory(IntPtr hProcess, UInt64 lpBaseAddress, [In, Out] Byte[] buffer, Int32 size, out Int32 lpNumberOfBytesRead);
        [DllImport("kernel32")] static extern Boolean WriteProcessMemory(IntPtr hProcess, UInt64 lpBaseAddress, Byte[] buffer, Int32 nSize, out Int32 lpNumberOfBytesWritten);
        [DllImport("kernel32")] static extern Int32 CloseHandle(IntPtr hObject);
        [DllImport("kernel32")] static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32")] static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 flAllocationType, Int32 flProtect);
        [DllImport("kernel32")] static extern Boolean VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 dwFreeType);
        private IntPtr procHandle = IntPtr.Zero;
        public Process Process { get; private set; }
        public UInt64 BaseAddress { get { return (UInt64)Process.MainModule.BaseAddress; } }
        public Memory(String name)
        {
            var procs = Process.GetProcessesByName(name);
            Process = procs.FirstOrDefault();
            if (Process == null) return;
            OpenProcess(Process.Id);
        }
        private Dictionary<IntPtr, int> _allocations = new Dictionary<IntPtr, int>();
        public void Dispose()
        {
            foreach (var kvp in _allocations) VirtualFreeEx(procHandle, kvp.Key, kvp.Value, 0x4000);
        }
        public void OpenProcess(Int32 procId)
        {
            procHandle = OpenProcess(0x38, 1, procId);
        }
        public unsafe Object ReadProcessMemory(Type type, UInt64 addr)
        {
            if (type == typeof(String))
            {
                List<Byte> bytes = new List<Byte>();
                var isUtf16 = false;
                for (UInt32 i = 0; i < 32; i++)
                {
                    var letters8 = ReadProcessMemory<UInt64>(addr + i * 8);
                    var tempBytes = BitConverter.GetBytes(letters8);
                    for (int j = 0; j < 8; j++)
                    {
                        if (tempBytes[j] == 0 && j == 1 && bytes.Count == 1)
                            isUtf16 = true;
                        if (isUtf16 && j % 2 == 1)
                            continue;
                        if (tempBytes[j] == 0)
                            return (Object)Encoding.UTF8.GetString(bytes.ToArray());
                        if ((tempBytes[j] < 32 || tempBytes[j] > 126) && tempBytes[j] != '\n')
                            return (Object)"null";
                        bytes.Add(tempBytes[j]);
                    }
                }
                return (Object)Encoding.UTF8.GetString(bytes.ToArray());
            }
            var buffer = new Byte[Marshal.SizeOf(type)];
            ReadProcessMemory(procHandle, addr, buffer, Marshal.SizeOf(type), out Int32 bytesRead);
            var structPtr = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var obj = Marshal.PtrToStructure(structPtr.AddrOfPinnedObject(), type);
            var members = obj.GetType().GetFields();
            foreach (var member in members)
            {
                if (member.FieldType == typeof(String))
                {
                    var offset = Marshal.OffsetOf(type, member.Name).ToInt32();
                    var ptr = BitConverter.ToUInt32(buffer.Skip(offset).Take(4).ToArray(), 0);
                    if (ptr == 0xffffffff || ptr == 0)
                    {
                        member.SetValueDirect(__makeref(obj), "null");
                        continue;
                    }
                    /* var val = member.GetValue(obj);
                     var validStr = true;
                     for (int i = 0; i < 16; i++)
                     {
                         if (buffer[offset + i] == 0 && i > 1)
                             break;
                         if (buffer[offset + i] < 32 || buffer[offset + i] > 126)
                         {
                             validStr = false;
                             break;
                         }
                     }
                     if (validStr)
                         continue;*/
                    var strPtr = Marshal.ReadIntPtr(structPtr.AddrOfPinnedObject(), offset);
                    var str = ReadProcessMemory<String>((UInt32)strPtr);
                    if (str != "null" && str != "")
                        member.SetValueDirect(__makeref(obj), str);
                }
                /*if (member.FieldType.IsPointer)
                {
                    var address = System.Reflection.Pointer.Unbox(member.GetValue(obj));
                    var value = ReadProcessMemory(member.FieldType.GetElementType(), (UInt32)address);
                }*/
            }
            structPtr.Free();
            return obj;
        }
        public T ReadProcessMemory<T>(UInt64 addr)
        {
            return (T)ReadProcessMemory(typeof(T), addr);
        }
        public void WriteProcessMemory(UInt64 addr, Byte[] buffer)
        {
            WriteProcessMemory(procHandle, addr, buffer, buffer.Length, out Int32 bytesRead);
        }
        public void WriteProcessMemory<T>(UInt64 addr, T value)
        {
            var objSize = Marshal.SizeOf(value);
            var objBytes = new Byte[objSize];
            var objPtr = Marshal.AllocHGlobal(objSize);
            Marshal.StructureToPtr(value, objPtr, true);
            Marshal.Copy(objPtr, objBytes, 0, objSize);
            Marshal.FreeHGlobal(objPtr);
            WriteProcessMemory(procHandle, addr, objBytes, objBytes.Length, out Int32 bytesRead);
        }
        public T Execute<T>(IntPtr vtableAddr, IntPtr objAddr, IntPtr funcAddr, params Object[] args)
        {
            //var retValPtr = VirtualAllocEx(procHandle, IntPtr.Zero, 0x40, 0x1000, 0x40);
            //WriteProcessMemory((UInt64)retValPtr, BitConverter.GetBytes((UInt64)0));
            //_allocations.Add(retValPtr, 0x40);
            //var retValPtrInit = ReadProcessMemory<UInt64>((UInt64)retValPtr);
            var dummyParms = VirtualAllocEx(procHandle, IntPtr.Zero, 0x100, 0x1000, 0x40);
            _allocations.Add(dummyParms, 0x100);
            WriteProcessMemory((UInt64)dummyParms, BitConverter.GetBytes((UInt64)0xffffffffffffffff));
            var offset = 0u;
            foreach(var obj in args)
            {
                WriteProcessMemory((UInt64)dummyParms + offset, obj);
                offset += (UInt32)Marshal.SizeOf(obj);
            }

            var asm = new List<Byte>();
            asm.AddRange(new byte[] { 0x48, 0x83, 0xEC }); // sub rsp
            asm.Add(40);
            asm.AddRange(new byte[] { 0x48, 0xB8 }); // mov rax
            asm.AddRange(BitConverter.GetBytes((UInt64)vtableAddr));

            asm.AddRange(new byte[] { 0x48, 0xB9 }); // mov rcx
            asm.AddRange(BitConverter.GetBytes((UInt64)objAddr));

            asm.AddRange(new byte[] { 0x48, 0xBA }); // mov rdx
            asm.AddRange(BitConverter.GetBytes((UInt64)funcAddr));

            asm.AddRange(new byte[] { 0x49, 0xB8 }); // mov r8
            asm.AddRange(BitConverter.GetBytes((UInt64)dummyParms));

            asm.AddRange(new byte[] { 0xFF, 0xD0 }); // call rax
            asm.AddRange(new byte[] { 0x48, 0x83, 0xC4 }); // add rsp
            asm.Add(40);
            //asm.AddRange(new byte[] { 0x48, 0xA3 }); // mov rax to
            //asm.AddRange(BitConverter.GetBytes((UInt64)retValPtr));
            asm.Add(0xC3); // ret
            var codePtr = VirtualAllocEx(procHandle, IntPtr.Zero, asm.Count, 0x1000, 0x40);
            WriteProcessMemory(procHandle, (UInt64)codePtr, asm.ToArray(), asm.Count, out Int32 bytesRead);
            _allocations.Add(codePtr, asm.Count);

            var initFlags = ReadProcessMemory<UInt64>((UInt64)funcAddr + 0x98);
            var nativeFlag = initFlags;
            nativeFlag |= 0x400;
            WriteProcessMemory((UInt64)funcAddr + 0x98, BitConverter.GetBytes(nativeFlag));

            IntPtr thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, codePtr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(thread, 10000);
            WriteProcessMemory((UInt64)funcAddr + 0x98, BitConverter.GetBytes(initFlags));
            var returnValue = ReadProcessMemory<T>((UInt64)dummyParms);
            //var returnValue2 = ReadProcessMemory<UInt64>((UInt64)retValPtr);
            CloseHandle(thread);
            return returnValue;
        }

        public List<UInt64> SearchProcessMemory(String pattern, UInt64 start, UInt64 end, Boolean absolute = true)
        {
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var addresses = new List<UInt64>();
            var iters = 1 + ((end - start) / 0x1000);
            if (iters == 0) iters++;
            for (uint i = 0; i < iters; i++)
            {
                var buffer = new Byte[0x1000];
                ReadProcessMemory(procHandle, (UInt32)(start + i * 0x1000), buffer, 0x1000, out Int32 bytesRead);
                var results = Scan(buffer, arrayOfBytes).Select(j => (UInt64)j + start + i * 0x1000).ToList();
                if (start + (i + 1) * 0x1000 > end && results.Count > 0)
                    results.RemoveAll(r => r > end);
                addresses.AddRange(results);
            }
            if (absolute)
                return addresses;
            else
                return addresses.Select(a => a - start).ToList();
        }
        public List<UInt64> ReSearchProcessMemory(List<UInt64> existing, String pattern)
        {
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var addresses = new List<UInt64>();
            foreach (var val in existing)
            {
                var buffer = new Byte[4];
                ReadProcessMemory(procHandle, (UInt32)val, buffer, 4, out Int32 bytesRead);
                var results = Scan(buffer, arrayOfBytes).Select(j => (UInt64)j + val).ToList();
                addresses.AddRange(results);
            }
            return addresses;
        }
        public String DumpSurroundString(UInt64 start)
        {
            var buffer = new Byte[0x100];
            ReadProcessMemory(procHandle, (UInt32)(start - 0x80), buffer, buffer.Length, out Int32 bytesRead);
            var val = "";
            for (int i = 0x7f; i > 0; i--)
            {
                if (buffer[i] == 0)
                    break;
                val = Encoding.UTF8.GetString(buffer, i, 1) + val;
            }
            for (int i = 0x80; i < 0x100; i++)
            {
                if (buffer[i] == 0)
                    break;
                val += Encoding.UTF8.GetString(buffer, i, 1);
            }
            return val;
        }
        public String GetString(UInt64 start)
        {
            var buffer = new Byte[0x1000];
            ReadProcessMemory(procHandle, (UInt32)(start), buffer, buffer.Length, out Int32 bytesRead);
            return String.Join(",", buffer.Select(b => "0x" + b.ToString("X2")));
        }
        void IDisposable.Dispose()
        {
            CloseHandle(procHandle);
        }

        static Byte[] FileBytes;
        public static List<Int32> Scan(Byte[] buf, Int32[] pattern)
        {
            var addresses = new List<Int32>();

            for (int i = 0; i <= buf.Length - pattern.Length; i++)
            {
                var found = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (pattern[j] == -1)
                        continue;
                    if (buf[i + j] != pattern[j])
                    {
                        found = false;
                        break;
                    }
                }
                if (found)
                    addresses.Add(i);
            }
            return addresses;
        }

        public static void SetImageFile(String file)
        {
            FileBytes = System.IO.File.ReadAllBytes(file);
        }
        public static UInt32 GetImageBase()
        {
            var pe = BitConverter.ToUInt16(FileBytes, 0x3c);
            return BitConverter.ToUInt32(FileBytes, pe + 0x34);
        }
        public static UInt32 FindAddr(String sig, Int32 offset, Boolean isOffset = false)
        {
            var arrayOfBytes = sig.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var offs = Scan(FileBytes, arrayOfBytes);
            if (isOffset)
                return BitConverter.ToUInt32(FileBytes, offs.First() + offset);
            var addr = BitConverter.ToUInt32(FileBytes, offs.First() + offset) - GetImageBase();
            return addr;
        }
        public static UInt32 FindAddr(String sig)
        {
            var arrayOfBytes = sig.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var offs = Scan(FileBytes, arrayOfBytes);
            return (UInt32)offs.First() + GetImageBase();
        }
        public IntPtr FindPattern(String pattern)
        {
            return FindPattern(pattern, Process.MainModule.BaseAddress, Process.MainModule.ModuleMemorySize);
        }
        public IntPtr FindPattern(String pattern, IntPtr start, Int32 length)
        {
            //var skip = pattern.ToLower().Contains("cc") ? 0xcc : pattern.ToLower().Contains("aa") ? 0xaa : 0;
            var sigScan = new SigScan(Process, start, length);
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? (Byte)0 : (Byte)Convert.ToInt32(b, 16)).ToArray();
            var strMask = String.Join("", pattern.Split(' ').Select(b => b.Contains("?") ? '?' : 'x'));
            return sigScan.FindPattern(arrayOfBytes, strMask, 0);
        }
        public List<IntPtr> FindPatterns(String pattern)
        {
            //var skip = pattern.ToLower().Contains("cc") ? 0xcc : pattern.ToLower().Contains("aa") ? 0xaa : 0;
            var sigScan = new SigScan(Process, Process.MainModule.BaseAddress, Process.MainModule.ModuleMemorySize);
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? (Byte)0 : (Byte)Convert.ToInt32(b, 16)).ToArray();
            var strMask = String.Join("", pattern.Split(' ').Select(b => b.Contains("?") ? '?' : 'x'));
            return sigScan.FindPatterns(arrayOfBytes, strMask, 0);
        }
    }
}
```

`RemnantESP/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

namespace RemnantESP
{
    static class Program
    {
        static void Main()
        {
            var oldProcs = Process.GetProcessesByName(Process.GetCurrentProcess().ProcessName).Where(p=>p.Id != Process.GetCurrentProcess().Id);
            foreach(var oldProc in oldProcs) oldProc.Kill();
            var procName = "Remnant-Win64-Shipping";
            new Engine(new Memory(procName)).UpdateAddresses();
            var esp = new ESP();
            esp.Run();
        }
    }
}

```

`RemnantESP/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RemnantESP")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("RemnantESP")]
[assembly: AssemblyCopyright("Copyright © Shalzuth 2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("79da8eec-502c-4046-ad35-b65c4e10ab36")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`RemnantESP/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace RemnantESP.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("RemnantESP.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] Arial8 {
            get {
                object obj = ResourceManager.GetObject("Arial8", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`RemnantESP/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Arial8" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Arial8.fnt;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`RemnantESP/RemnantESP.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Costura.Fody.4.1.0\build\Costura.Fody.props" Condition="Exists('..\packages\Costura.Fody.4.1.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{79DA8EEC-502C-4046-AD35-B65C4E10AB36}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>RemnantESP</RootNamespace>
    <AssemblyName>RemnantESP</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Costura, Version=4.1.0.0, Culture=neutral, PublicKeyToken=9919ef960d84173d, processorArchitecture=MSIL">
      <HintPath>..\packages\Costura.Fody.4.1.0\lib\net40\Costura.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Direct3D11">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.Direct3D11.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.DXGI">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.DXGI.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Toolkit">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.Toolkit.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Toolkit.Game">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.Toolkit.Game.dll</HintPath>
    </Reference>
    <Reference Include="SharpDX.Toolkit.Graphics">
      <HintPath>$(SharpDXPackageBinDir)\SharpDX.Toolkit.Graphics.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Engine.cs" />
    <Compile Include="ESP.cs" />
    <Compile Include="Extensions.cs" />
    <Compile Include="Memory.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="SigScan.cs" />
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <None Include="Arial8.fnt" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\Fody.6.0.0\build\Fody.targets" Condition="Exists('..\packages\Fody.6.0.0\build\Fody.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Fody.6.0.0\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Fody.6.0.0\build\Fody.targets'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.4.1.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.4.1.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('..\packages\SharpDX.2.6.3\build\SharpDX.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\SharpDX.2.6.3\build\SharpDX.targets'))" />
    <Error Condition="!Exists('..\packages\SharpDX.Toolkit.2.6.3\build\SharpDX.Toolkit.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\SharpDX.Toolkit.2.6.3\build\SharpDX.Toolkit.targets'))" />
  </Target>
  <Import Project="..\packages\SharpDX.2.6.3\build\SharpDX.targets" Condition="Exists('..\packages\SharpDX.2.6.3\build\SharpDX.targets')" />
  <Import Project="..\packages\SharpDX.Toolkit.2.6.3\build\SharpDX.Toolkit.targets" Condition="Exists('..\packages\SharpDX.Toolkit.2.6.3\build\SharpDX.Toolkit.targets')" />
</Project>
```

`RemnantESP/SigScan.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Collections.Generic;

//
// sigScan C# Implementation - Written by atom0s [aka Wiccaan]
// Class Version: 2.0.0
//
// [ CHANGE LOG ] -------------------------------------------------------------------------
//
//      2.0.0
//          - Updated to no longer require unsafe or fixed code.
//          - Removed unneeded methods and code.
//
//      1.0.0
//          - First version written and release.
//
// [ CREDITS ] ----------------------------------------------------------------------------
//
// sigScan is based on the FindPattern code written by
// dom1n1k and Patrick at GameDeception.net
//
// Full credit to them for the purpose of this code. I, atom0s, simply
// take credit for converting it to C#.
//
// [ USAGE ] ------------------------------------------------------------------------------
//
// Examples:
//
//      SigScan _sigScan = new SigScan();
//      _sigScan.Process = someProc;
//      _sigScan.Address = new IntPtr(0x123456);
//      _sigScan.Size = 0x1000;
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
//      SigScan _sigScan = new SigScan(someProc, new IntPtr(0x123456), 0x1000);
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
// ----------------------------------------------------------------------------------------
namespace RemnantESP
{
    public class SignatureEntity
    {
        public int StartAddress { get; set; }
        public int SearchRange { get; set; }
        public byte[] WantedBytes { get; set; }
        public String Mask { get; set; }
        public int AddressOffset { get; set; }

        public SignatureEntity(int startSAddress, int searchRange, byte[] wantedBytes, String mask, int addressOffset)
        {
            StartAddress = startSAddress;
            SearchRange = searchRange;
            WantedBytes = wantedBytes;
            Mask = mask;
            AddressOffset = addressOffset;
        }

        public IntPtr ScanSignature(Process process)
        {
            SigScan sigScan = new SigScan(process, new IntPtr(StartAddress), SearchRange);
            return sigScan.FindPattern(WantedBytes, Mask, AddressOffset);
        }
    }


    public class SigScan
    {
        /// <summary>
        /// ReadProcessMemory
        /// 
        ///     API import definition for ReadProcessMemory.
        /// </summary>
        /// <param name="hProcess">Handle to the process we want to read from.</param>
        /// <param name="lpBaseAddress">The base address to start reading from.</param>
        /// <param name="lpBuffer">The return buffer to write the read data to.</param>
        /// <param name="dwSize">The size of data we wish to read.</param>
        /// <param name="lpNumberOfBytesRead">The number of bytes successfully read.</param>
        /// <returns></returns>
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool ReadProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            [Out()] byte[] lpBuffer,
            int dwSize,
            out int lpNumberOfBytesRead
            );

        /// <summary>
        /// m_vDumpedRegion
        /// 
        ///     The memory dumped from the external process.
        /// </summary>
        private byte[] m_vDumpedRegion;

        /// <summary>
        /// m_vProcess
        /// 
        ///     The process we want to read the memory of.
        /// </summary>
        private Process m_vProcess;

        /// <summary>
        /// m_vAddress
        /// 
        ///     The starting address we want to begin reading at.
        /// </summary>
        private IntPtr m_vAddress;

        /// <summary>
        /// m_vSize
        /// 
        ///     The number of bytes we wish to read from the process.
        /// </summary>
        private Int32 m_vSize;


        #region "sigScan Class Construction"
        /// <summary>
        /// SigScan
        /// 
        ///     Main class constructor that uses no params. 
        ///     Simply initializes the class properties and 
        ///     expects the user to set them later.
        /// </summary>
        public SigScan()
        {
            this.m_vProcess = null;
            this.m_vAddress = IntPtr.Zero;
            this.m_vSize = 0;
            this.m_vDumpedRegion = null;
        }
        /// <summary>
        /// SigScan
        /// 
        ///     Overloaded class constructor that sets the class
        ///     properties during construction.
        /// </summary>
        /// <param name="proc">The process to dump the memory from.</param>
        /// <param name="addr">The started address to begin the dump.</param>
        /// <param name="size">The size of the dump.</param>
        public SigScan(Process proc, IntPtr addr, int size)
        {
            this.m_vProcess = proc;
            this.m_vAddress = addr;
            this.m_vSize = size;
        }
        #endregion

        #region "sigScan Class Private Methods"
        /// <summary>
        /// DumpMemory
        /// 
        ///     Internal memory dump function that uses the set class
        ///     properties to dump a memory region.
        /// </summary>
        /// <returns>Boolean based on RPM results and valid properties.</returns>
        private bool DumpMemory()
        {
            try
            {
                // Checks to ensure we have valid data.
                if (this.m_vProcess == null)
                    return false;
                if (this.m_vProcess.HasExited == true)
                    return false;
                if (this.m_vAddress == IntPtr.Zero)
                    return false;
                if (this.m_vSize == 0)
                    return false;

                // Create the region space to dump into.
                this.m_vDumpedRegion = new byte[this.m_vSize];

                bool bReturn = false;
                int nBytesRead = 0;

                // Dump the memory.
                bReturn = ReadProcessMemory(
                    this.m_vProcess.Handle, this.m_vAddress, this.m_vDumpedRegion, this.m_vSize, out nBytesRead
                    );

                // Validation checks.
                if (bReturn == false || nBytesRead != this.m_vSize)
                    return false;
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// MaskCheck
        /// 
        ///     Compares the current pattern byte to the current memory dump
        ///     byte to check for a match. Uses wildcards to skip bytes that
        ///     are deemed unneeded in the compares.
        /// </summary>
        /// <param name="nOffset">Offset in the dump to start at.</param>
        /// <param name="btPattern">Pattern to scan for.</param>
        /// <param name="strMask">Mask to compare against.</param>
        /// <returns>Boolean depending on if the pattern was found.</returns>
        private bool MaskCheck(int nOffset, byte[] btPattern, string strMask)
        {
            // Loop the pattern and compare to the mask and dump.
            for (int x = 0; x < btPattern.Length; x++)
            {
                // If the mask char is a wildcard, just continue.
                if (strMask[x] == '?')
                    continue;

                // If the mask char is not a wildcard, ensure a match is made in the pattern.
                if ((strMask[x] == 'x') && (btPattern[x] != this.m_vDumpedRegion[nOffset + x]))
                    return false;
            }

            // The loop was successful so we found the pattern.
            return true;
        }
        #endregion

        #region "sigScan Class Public Methods"
        /// <summary>
        /// FindPattern
        /// 
        ///     Attempts to locate the given pattern inside the dumped memory region
        ///     compared against the given mask. If the pattern is found, the offset
        ///     is added to the located address and returned to the user.
        /// </summary>
        /// <param name="btPattern">Byte pattern to look for in the dumped region.</param>
        /// <param name="strMask">The mask string to compare against.</param>
        /// <param name="nOffset">The offset added to the result address.</param>
        /// <returns>IntPtr - zero if not found, address if found.</returns>
        public IntPtr FindPattern(byte[] btPattern, string strMask, int nOffset)
        {
            try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return IntPtr.Zero;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return IntPtr.Zero;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        return IntPtr.Add(this.m_vAddress, x + nOffset);
                    }
                }

                // Pattern was not found.
                return IntPtr.Zero;
            }
            catch (Exception)
            {
                return IntPtr.Zero;
            }
        }
        public List<IntPtr> FindPatterns(byte[] btPattern, string strMask, int nOffset)
        {
            var ptrs = new List<IntPtr>();
            try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return null;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return null;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        ptrs.Add(IntPtr.Add(this.m_vAddress,x + nOffset));
                    }
                }

                // Pattern was not found.
                return ptrs;
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ResetRegion
        /// 
        ///     Resets the memory dump array to nothing to allow
        ///     the class to redump the memory.
        /// </summary>
        public void ResetRegion()
        {
            this.m_vDumpedRegion = null;
        }
        #endregion

        #region "sigScan Class Properties"
        public Process Process
        {
            get { return this.m_vProcess; }
            set { this.m_vProcess = value; }
        }
        public IntPtr Address
        {
            get { return this.m_vAddress; }
            set { this.m_vAddress = value; }
        }
        public Int32 Size
        {
            get { return this.m_vSize; }
            set { this.m_vSize = value; }
        }
        #endregion

    }
}
```

`RemnantESP/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Costura.Fody" version="4.1.0" targetFramework="net472" />
  <package id="Fody" version="6.0.0" targetFramework="net472" developmentDependency="true" />
  <package id="SharpDX" version="2.6.3" targetFramework="net472" />
  <package id="SharpDX.Direct3D11" version="2.6.3" targetFramework="net472" />
  <package id="SharpDX.DXGI" version="2.6.3" targetFramework="net472" />
  <package id="SharpDX.Toolkit" version="2.6.3" targetFramework="net472" />
  <package id="SharpDX.Toolkit.Game" version="2.6.3" targetFramework="net472" />
  <package id="SharpDX.Toolkit.Graphics" version="2.6.3" targetFramework="net472" />
</packages>
```