Project Path: arc_gmh5225_NMI-nmi_callback_u7pp70ld

Source Tree:

```txt
arc_gmh5225_NMI-nmi_callback_u7pp70ld
├── README.md
├── demo.PNG
├── nmi_callback
│   ├── nmi_callback.inf
│   ├── nmi_callback.vcxproj
│   ├── nmi_callback.vcxproj.filters
│   └── src
│       ├── hal.c
│       ├── helper.c
│       ├── main.c
│       └── stuff.h
└── nmi_callback.sln

```

`README.md`:

```md
# nmi_callback
This driver will fire a non-maskable interrupt (NMI) on your 1st cpu core and attempt to handle it using an NMI callback.
If it succeeds, you will see following result in WinDbg:

![alt text](https://github.com/cryotb/nmi_callback/blob/master/demo.PNG)

In order to get this done, i am doing the following:
  1. Allocate KAFFINITY_EX structure.
  2. Pass it to KeInitializeAffinityEx.
  3. Add the CPU core the NMI should be run at to the affinity, by calling KeAddProcessorAffinityEx.
  4. Finally calling HalSendNMI to send it. parameter is the affinity of course.

Note that all of these APIs listed above are not publicly documented so there might be inconsistencies on return value, prototype etc...

```

`nmi_callback.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32510.428
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nmi_callback", "nmi_callback\nmi_callback.vcxproj", "{9180B6D2-48AE-42D1-A651-2324A16AF74A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM.ActiveCfg = Debug|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM.Build.0 = Debug|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM.Deploy.0 = Debug|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM64.Build.0 = Debug|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x64.ActiveCfg = Debug|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x64.Build.0 = Debug|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x64.Deploy.0 = Debug|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x86.ActiveCfg = Debug|Win32
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x86.Build.0 = Debug|Win32
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Debug|x86.Deploy.0 = Debug|Win32
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM.ActiveCfg = Release|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM.Build.0 = Release|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM.Deploy.0 = Release|ARM
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM64.ActiveCfg = Release|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM64.Build.0 = Release|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|ARM64.Deploy.0 = Release|ARM64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x64.ActiveCfg = Release|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x64.Build.0 = Release|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x64.Deploy.0 = Release|x64
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x86.ActiveCfg = Release|Win32
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x86.Build.0 = Release|Win32
		{9180B6D2-48AE-42D1-A651-2324A16AF74A}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {052123F8-9C27-47D0-BD07-5857F363FB09}
	EndGlobalSection
EndGlobal

```

`nmi_callback/nmi_callback.inf`:

```inf
;
; nmi_callback.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=nmi_callback.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
nmi_callback_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
nmi_callback.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%nmi_callback.DeviceDesc%=nmi_callback_Device, Root\nmi_callback ; TODO: edit hw-id

[nmi_callback_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
nmi_callback.sys

;-------------- Service installation
[nmi_callback_Device.NT.Services]
AddService = nmi_callback,%SPSVCINST_ASSOCSERVICE%, nmi_callback_Service_Inst

; -------------- nmi_callback driver install sections
[nmi_callback_Service_Inst]
DisplayName    = %nmi_callback.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\nmi_callback.sys

;
;--- nmi_callback_Device Coinstaller installation ------
;

[nmi_callback_Device.NT.CoInstallers]
AddReg=nmi_callback_Device_CoInstaller_AddReg
CopyFiles=nmi_callback_Device_CoInstaller_CopyFiles

[nmi_callback_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[nmi_callback_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[nmi_callback_Device.NT.Wdf]
KmdfService =  nmi_callback, nmi_callback_wdfsect
[nmi_callback_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "nmi_callback Installation Disk"
nmi_callback.DeviceDesc = "nmi_callback Device"
nmi_callback.SVCDESC = "nmi_callback Service"

```

`nmi_callback/nmi_callback.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9180B6D2-48AE-42D1-A651-2324A16AF74A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>nmi_callback</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <Optimization>Disabled</Optimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="nmi_callback.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\hal.c" />
    <ClCompile Include="src\helper.c" />
    <ClCompile Include="src\main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\stuff.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`nmi_callback/nmi_callback.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="nmi_callback.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.c" />
    <ClCompile Include="src\hal.c" />
    <ClCompile Include="src\helper.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\stuff.h" />
  </ItemGroup>
</Project>
```

`nmi_callback/src/hal.c`:

```c
#include "stuff.h"

VOID HalSendNMI(PKAFFINITY_EX affinity)
{
	PVOID addr;
	UNICODE_STRING routineName;

	RtlInitUnicodeString(&routineName, L"HalSendNMI");
	addr = MmGetSystemRoutineAddress(&routineName);

	if (!addr) __debugbreak();

	( (VOID(__fastcall*)(PKAFFINITY_EX))addr )(affinity);
}

```

`nmi_callback/src/helper.c`:

```c
#include "stuff.h"

INT64 HLP_SecInNs(INT64 nSec)
{
	return (nSec * 10000000);
}

VOID HLP_DelayExecutionThread(INT64 nSeconds)
{
	LARGE_INTEGER nDelay;
	memset(&nDelay, 0, sizeof(nDelay));

	nDelay.QuadPart -= HLP_SecInNs(nSeconds);

	KeDelayExecutionThread(KernelMode, FALSE, &nDelay);
}

BOOLEAN HLP_FireNMI(INT core, PKAFFINITY_EX affinity)
{
	KeInitializeAffinityEx(affinity);
	KeAddProcessorAffinityEx(affinity, core);

	HalSendNMI(affinity);

	return TRUE;
}

```

`nmi_callback/src/main.c`:

```c
#include "stuff.h"

PVOID g_NmiCallbackHandle;
PKAFFINITY_EX g_NmiAffinity;
PNMI_CONTEXT g_NmiContext;

BOOLEAN NmiCallback(PVOID context, BOOLEAN handled)
{
	PNMI_CONTEXT cpuContext = &((PNMI_CONTEXT)context)[KeGetCurrentProcessorNumberEx(NULL)];

	++cpuContext->NumFired;

	return TRUE;
}

VOID DriverUnload(PDRIVER_OBJECT drvObj)
{
	DbgPrint("[nmi_cb]  unload\n");
	
	if (g_NmiCallbackHandle) KeDeregisterNmiCallback(g_NmiCallbackHandle);
	if (g_NmiAffinity) ExFreePoolWithTag(g_NmiAffinity, NMI_CB_POOL_TAG);
	if (g_NmiContext) ExFreePoolWithTag(g_NmiContext, NMI_CB_POOL_TAG);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT drvObj, PUNICODE_STRING regPath)
{
	DbgPrint("\n[nmi_cb]  entry\n");

	ULONG numCores = KeQueryActiveProcessorCountEx(NULL);

	drvObj->DriverUnload = DriverUnload;

	ULONG nmiContextLength = numCores * sizeof(NMI_CONTEXT);

	g_NmiAffinity = ExAllocatePoolWithTag(NonPagedPool, sizeof(KAFFINITY_EX), NMI_CB_POOL_TAG);
	g_NmiContext = (PNMI_CONTEXT)ExAllocatePoolWithTag(NonPagedPool, nmiContextLength, NMI_CB_POOL_TAG);
	g_NmiCallbackHandle = KeRegisterNmiCallback(NmiCallback, g_NmiContext);

	if (!g_NmiAffinity || !g_NmiContext || !g_NmiCallbackHandle)
		return STATUS_FAILED_DRIVER_ENTRY;

	memset(g_NmiContext, 0, nmiContextLength);

	HLP_FireNMI(0, g_NmiAffinity); /* this will fire an NMI on CPU #0 */
	HLP_DelayExecutionThread(2); /* can adjust this delay, it's been arbitrarily chosen. */

	for (ULONG i = 0; i < numCores; i++)
	{
		PNMI_CONTEXT cpuContext = &g_NmiContext[i];

		DbgPrint("[nmi_cb]  CPU#%i NmiCallbackInvokes=%i\n", i, cpuContext->NumFired);
	}

	return STATUS_SUCCESS;
}

```

`nmi_callback/src/stuff.h`:

```h
#pragma once

#include <intrin.h>
#include <ntddk.h>

#define NMI_CB_POOL_TAG 'BCmN'

//0xa8 bytes (sizeof)
typedef struct _KAFFINITY_EX
{
    USHORT Count;                                                           //0x0
    USHORT Size;                                                            //0x2
    ULONG Reserved;                                                         //0x4
    ULONGLONG Bitmap[20];                                                   //0x8
} KAFFINITY_EX, *PKAFFINITY_EX;

typedef struct _NMI_CONTEXT
{
    INT NumFired;
} NMI_CONTEXT, *PNMI_CONTEXT;

EXTERN_C INT64 HLP_SecInNs(INT64 nSec);
EXTERN_C VOID HLP_DelayExecutionThread(INT64 nSeconds);
EXTERN_C BOOLEAN HLP_FireNMI(INT core, PKAFFINITY_EX affinity);

EXTERN_C VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
EXTERN_C VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);

EXTERN_C VOID HalSendNMI(PKAFFINITY_EX affinity);

```