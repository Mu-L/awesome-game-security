Project Path: arc_gmh5225_antidbg-Baka_x7onv_9u

Source Tree:

```txt
arc_gmh5225_antidbg-Baka_x7onv_9u
├── Baka
│   ├── AntiDebug.h
│   ├── ApiWrapper.h
│   ├── Baka.cpp
│   ├── Baka.vcxproj
│   ├── Baka.vcxproj.filters
│   ├── Baka.vcxproj.user
│   ├── CRCSections.h
│   ├── CRCpp.h
│   ├── CheckBigBool.h
│   ├── NoCRT.h
│   ├── NtApi.h
│   ├── Struct.h
│   ├── SyscallHelp.hpp
│   ├── TestModeCheck.h
│   ├── WoW64ext.h
│   └── custom_dos_stub.bin
├── Baka.sln
├── Detect TitanHide by bad hook.png
├── HyperHide.png
├── README.md
└── ShyllaHide.png

```

`Baka.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Baka", "Baka\Baka.vcxproj", "{23267294-279A-4406-B71B-E64D94C426FC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{23267294-279A-4406-B71B-E64D94C426FC}.Debug|x64.ActiveCfg = Debug|x64
		{23267294-279A-4406-B71B-E64D94C426FC}.Debug|x64.Build.0 = Debug|x64
		{23267294-279A-4406-B71B-E64D94C426FC}.Debug|x86.ActiveCfg = Debug|Win32
		{23267294-279A-4406-B71B-E64D94C426FC}.Debug|x86.Build.0 = Debug|Win32
		{23267294-279A-4406-B71B-E64D94C426FC}.Release|x64.ActiveCfg = Release|x64
		{23267294-279A-4406-B71B-E64D94C426FC}.Release|x64.Build.0 = Release|x64
		{23267294-279A-4406-B71B-E64D94C426FC}.Release|x86.ActiveCfg = Release|Win32
		{23267294-279A-4406-B71B-E64D94C426FC}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {918DC5C7-05DA-4F31-A6B3-1E708C5861FF}
	EndGlobalSection
EndGlobal

```

`Baka/AntiDebug.h`:

```h
#pragma once

#include "SyscallHelp.hpp"
#include "WoW64ext.h"


 
namespace AntiDebug
{

	namespace ShellCode
	{

		__forceinline bool IsDebugPort()
		{
			DWORD64  DebugPort = NULL;
			NTSTATUS status = STATUS_UNSUCCESSFUL;


			unsigned char shellSysCall64[] = {
				0xB8, 0x0, 0x0, 0x0, 0x0,   // mov eax,syscallNumber
				0x4C, 0x8B, 0xD1,           // mov r10,rcx
				0x0F, 0x05,                 // syscall
				0xC3                        // retn
			};
			
			auto SyscallNumber = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtQueryInformationProcess");// Get auto syscall number

			// can't find automatic sycall number ,so we get manual by Windows number
			if (!SyscallNumber)
			{
				ApiWrapper::printf(L"[!] Can't get syscall auto!\n");

				auto numberWindows = ApiWrapper::GetWindowsNumber();
				if (numberWindows > WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 25;

				}
				else if (numberWindows == WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 24;
				}
				else if (numberWindows == WINDOWS_NUMBER_8)
				{
					SyscallNumber = 23;
				}
				else if (numberWindows < WINDOWS_NUMBER_8)
				{
					SyscallNumber = 22;
				}
			}

			auto addressShellCode = (t_NtQueryInformationProcess)VirtualAlloc(0, 0x1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (!addressShellCode)
			{
				return FALSE;
			}

			NoCRT::mem::memcpy(&shellSysCall64[1], &SyscallNumber, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressShellCode, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64

			status = addressShellCode(NtCurrentProcess, ProcessDebugPort, &DebugPort, sizeof(DebugPort), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressShellCode,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugPort,
				(DWORD64)&DebugPort,
				(DWORD64)sizeof(DebugPort),
				(DWORD64)0);


#endif // 

			//compare byte's
			if (NoCRT::mem::memicmp((void*)addressShellCode, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			VirtualFree((PVOID)addressShellCode, 0, MEM_RELEASE);
			if (NT_SUCCESS(status) && DebugPort != 0)
			{
				return TRUE;
			}
			return FALSE;
		}


		__forceinline	bool IsDebugObjectHandle()
		{
			DWORD64	DebugObject = NULL;
			NTSTATUS  status = STATUS_UNSUCCESSFUL;


			unsigned char shellSysCall64[] = {
				0xB8, 0x0, 0x0, 0x0, 0x0,   // mov eax,syscallNumber
				0x4C, 0x8B, 0xD1,           // mov r10,rcx
				0x0F, 0x05,                 // syscall
				0xC3                        // retn
			};

			auto SyscallNumber = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtQueryInformationProcess");// Get auto syscall number

			// can't find automatic sycall number ,so we get manual by Windows number
			if (!SyscallNumber)
			{
				auto numberWindows = ApiWrapper::GetWindowsNumber();
				if (numberWindows > WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 25;

				}
				else if (numberWindows == WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 24;
				}
				else if (numberWindows == WINDOWS_NUMBER_8)
				{
					SyscallNumber = 23;
				}
				else if (numberWindows < WINDOWS_NUMBER_8)
				{
					SyscallNumber = 22;
				}
			}

			auto addressShellCode = (t_NtQueryInformationProcess)VirtualAlloc(0, 0x1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (!addressShellCode)
			{
				return FALSE;
			}

			NoCRT::mem::memcpy(&shellSysCall64[1], &SyscallNumber, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressShellCode, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64

			status = addressShellCode(NtCurrentProcess, ProcessDebugObjectHandle, &DebugObject, sizeof(DebugObject), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressShellCode,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugObjectHandle,
				(DWORD64)&DebugObject,
				(DWORD64)sizeof(DebugObject),
				(DWORD64)0);


#endif // 

			//compare byte's
			if (NoCRT::mem::memicmp((void*)addressShellCode, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			VirtualFree((PVOID)addressShellCode, 0, MEM_RELEASE);
			if (NT_SUCCESS(status) && DebugObject != 0)
			{
				return TRUE;
			}
			return FALSE;
		}



		__forceinline bool IsDebugFlag()
		{
			DWORD  DebugFlag = NULL;
			NTSTATUS  status = STATUS_UNSUCCESSFUL;


			unsigned char shellSysCall64[] = {
				0xB8, 0x0, 0x0, 0x0, 0x0,   // mov eax,syscallNumber
				0x4C, 0x8B, 0xD1,           // mov r10,rcx
				0x0F, 0x05,                 // syscall
				0xC3                        // retn
			};

			auto SyscallNumber = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtQueryInformationProcess");// Get auto syscall number


			/// can't find automatic sycall number ,so we get manual by Windows number
			if (!SyscallNumber)
			{
				auto numberWindows = ApiWrapper::GetWindowsNumber();
				if (numberWindows > WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 25;

				}
				else if (numberWindows == WINDOWS_NUMBER_8_1)
				{
					SyscallNumber = 24;
				}
				else if (numberWindows == WINDOWS_NUMBER_8)
				{
					SyscallNumber = 23;
				}
				else if (numberWindows < WINDOWS_NUMBER_8)
				{
					SyscallNumber = 22;
				}
			}

			auto addressShellCode = VirtualAlloc(0, 0x1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (!addressShellCode)
			{
				return FALSE;
			}

			NoCRT::mem::memcpy(&shellSysCall64[1], &SyscallNumber, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressShellCode, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64

			status = ((t_NtQueryInformationProcess)addressShellCode)(NtCurrentProcess, ProcessDebugFlags, &DebugFlag, sizeof(DebugFlag), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressShellCode,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugFlags,
				(DWORD64)&DebugFlag,
				(DWORD64)sizeof(DebugFlag),
				(DWORD64)0);


#endif // 

			//compare byte's
			if (NoCRT::mem::memicmp((void*)addressShellCode, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			VirtualFree((PVOID)addressShellCode, 0, MEM_RELEASE);
			if (status == STATUS_SUCCESS && DebugFlag == 0)
			{
				return TRUE;
			}
			return FALSE;
		}

		 

	}


	namespace OverWriteSyscall
	{
		bool IsDebugFlagHooked()
		{
			DWORD32  DebugFlag = NULL;
			NTSTATUS status = STATUS_UNSUCCESSFUL;
			DWORD protect = NULL;
			BYTE safeByte[20];
			unsigned char shellSysCall64[] = {
				0xB8, 0x0, 0x0, 0x0, 0x0,   // mov eax,syscallNumber
				0x4C, 0x8B, 0xD1,           // mov r10,rcx
				0x0F, 0x05,                 // syscall
				0xC3                        // retn
			};
			NoCRT::mem::memset(safeByte, 0, sizeof(safeByte));
			auto syscallNumberQueryInformationProcess = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtQueryInformationProcess");// Get auto syscall number
			auto syscallSetInformationProcess = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtSetInformationProcess");// Get auto syscall number

			/// can't find automatic sycall number ,so we get manual by Windows number
			if (!syscallNumberQueryInformationProcess || !syscallSetInformationProcess)
			{

				auto numberWindows = ApiWrapper::GetWindowsNumber();
				if (numberWindows > WINDOWS_NUMBER_8_1)
				{
					syscallNumberQueryInformationProcess = 25;
					syscallSetInformationProcess = 28;

				}
				else if (numberWindows == WINDOWS_NUMBER_8_1)
				{
					syscallNumberQueryInformationProcess = 24;
					syscallSetInformationProcess = 27;
				}
				else if (numberWindows == WINDOWS_NUMBER_8)
				{
					syscallNumberQueryInformationProcess = 23;
					syscallSetInformationProcess = 26;
				}
				else if (numberWindows < WINDOWS_NUMBER_8)
				{
					syscallNumberQueryInformationProcess = 22;
					syscallSetInformationProcess = 25;
				}
			}
			auto addressApi = (DWORD64*)ApiWrapper::GetRandomSyscallAddress();
			if (!addressApi)
			{
				return FALSE;
			}
			//We write shellcode in ntdll Api for present allocate memory
			VirtualProtect(addressApi, 0x1024, PAGE_EXECUTE_READWRITE, &protect);
			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallNumberQueryInformationProcess, 2); //set syscall
			NoCRT::mem::memcpy(safeByte, addressApi, sizeof(safeByte));
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64

			status = (t_NtQueryInformationProcess(addressApi))(NtCurrentProcess, ProcessDebugFlags, &DebugFlag, sizeof(DebugFlag), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugFlags,
				(DWORD64)&DebugFlag,
				(DWORD64)sizeof(DebugFlag),
				(DWORD64)0);


#endif // 

			if (NT_SUCCESS(status) && DebugFlag == 0)
			{
				return TRUE;
			}

			//compare byte's
			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallSetInformationProcess, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode
			DebugFlag = 0;

			/*
			We set DebugFlag and check this +
			TitanHide don't hook NtSetInformationProcess and return all time in NtQueryInformationProcess NoDebugInherit = TRUE,
			so we can detect this
			*/
#ifdef _WIN64

			status = (t_NtSetInformationProcess(addressApi))(NtCurrentProcess, ProcessDebugFlags, &DebugFlag, sizeof(DebugFlag));
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugFlags,
				(DWORD64)&DebugFlag,
				(DWORD64)sizeof(DebugFlag),
				(DWORD64)0);


#endif // 
			if (!NT_SUCCESS(status))
			{
				NoCRT::mem::memcpy(addressApi, safeByte, sizeof(safeByte));
				VirtualProtect(addressApi, 0x1024, protect, &protect);
				return FALSE;
			}
			//compare byte's
			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			DebugFlag = 1;
			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallNumberQueryInformationProcess, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode
			// Goodbuy TitanHide
#ifdef _WIN64

			status = (t_NtQueryInformationProcess(addressApi))(NtCurrentProcess, ProcessDebugFlags, &DebugFlag, sizeof(DebugFlag), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugFlags,
				(DWORD64)&DebugFlag,
				(DWORD64)sizeof(DebugFlag),
				(DWORD64)0);


#endif // 
			if (NT_SUCCESS(status) && DebugFlag != 0)
			{
				return TRUE;
			}

			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallSetInformationProcess, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode
			DebugFlag = 1;
#ifdef _WIN64

			status = (t_NtSetInformationProcess(addressApi))(NtCurrentProcess, ProcessDebugFlags, &DebugFlag, sizeof(DebugFlag));
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				5,
				(DWORD64)-1,	//NtCurrentProcess
				(DWORD64)ProcessDebugFlags,
				(DWORD64)&DebugFlag,
				(DWORD64)sizeof(DebugFlag),
				(DWORD64)0);


#endif // 
			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			NoCRT::mem::memcpy(addressApi ,safeByte, sizeof(safeByte));
			VirtualProtect(addressApi, 0x1024, protect, &protect);
			
			return FALSE;



		}





			bool IsBadHideThread()
		{

			NTSTATUS  status = STATUS_UNSUCCESSFUL;
			bool IsThreadHide = FALSE;
			DWORD64 badGuy = NULL;
			DWORD protect = NULL;
			BYTE safeByte[20];
			unsigned char shellSysCall64[] = {
				0xB8, 0x0, 0x0, 0x0, 0x0,   // mov eax,syscallNumber
				0x4C, 0x8B, 0xD1,           // mov r10,rcx
				0x0F, 0x05,                 // syscall
				0xC3                        // retn
			};

			auto syscallNumberSetInformathion = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtSetInformationThread");// Get auto syscall number

			auto syscallNumberQueryInfThread = SyscallStub::GetSyscallNumber(L"ntdll.dll", "NtQueryInformationThread");// Get auto syscall number

			if (!syscallNumberSetInformathion || !syscallNumberQueryInfThread)
			{
				// can't find automatic value ,so we get manual by Windows number
				auto numberWindows = ApiWrapper::GetWindowsNumber();
				if (numberWindows > WINDOWS_NUMBER_8_1)
				{
					syscallNumberSetInformathion = 13;
					syscallNumberQueryInfThread = 37;
				}
				else if (numberWindows == WINDOWS_NUMBER_8_1)
				{
					syscallNumberSetInformathion = 12;
					syscallNumberQueryInfThread = 36;
				}
				else if (numberWindows == WINDOWS_NUMBER_8)
				{
					syscallNumberSetInformathion = 11;
					syscallNumberQueryInfThread = 35;
				}
				else if (numberWindows < WINDOWS_NUMBER_8)
				{
					syscallNumberSetInformathion = 10;
					syscallNumberQueryInfThread = 34;
				}
			}
			auto addressApi = (t_NtQueryInformationProcess)ApiWrapper::GetRandomSyscallAddress();
			if (!addressApi)
			{
				return FALSE;
			}
			VirtualProtect(addressApi, 0x1024, PAGE_EXECUTE_READWRITE, &protect);
			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallNumberSetInformathion, 2); //set syscall
			NoCRT::mem::memcpy(safeByte, addressApi, sizeof(safeByte));// sade byte
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64

			status = ((t_NtSetInformationThread)addressApi)(NtCurrentThread, ThreadHideFromDebugger, &badGuy, 0x999);


		
 
#else


			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				4,
				(DWORD64)-2,	//NtCurrentThread
				(DWORD64)0x11,	//HideFromDebugger
				(DWORD64)&badGuy,
				(DWORD64)0x999);

			

#endif

			if (NT_SUCCESS(status))
			{
				return TRUE;
			}


			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}


#ifdef  _WIN64

			status = ((t_NtSetInformationThread)addressApi)(NtCurrentThread, ThreadHideFromDebugger, 0, 0);
#else 

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				4,
				(DWORD64)-2,	//NtCurrentThread
				(DWORD64)0x11,	//HideFromDebugger
				(DWORD64)0,
				(DWORD64)0);
#endif

			if (!NT_SUCCESS(status))
			{
				return FALSE;
			}


			NoCRT::mem::memcpy(&shellSysCall64[1], &syscallNumberQueryInfThread, 2); //set syscall
			NoCRT::mem::memcpy((void*)addressApi, shellSysCall64, sizeof(shellSysCall64));// write shellcode

#ifdef _WIN64
			status = ((t_NtQueryInformationThread)addressApi)(NtCurrentThread, ThreadHideFromDebugger, &IsThreadHide, sizeof(bool), 0);
#else

			status = WoW64Help::X64Call(
				(DWORD64)addressApi,
				5,
				(DWORD64)-2,	//NtCurrentThread
				(DWORD64)0x11,	//HideFromDebugger
				(DWORD64)&IsThreadHide,
				(DWORD64)sizeof(bool),
				(DWORD64)0
			);
#endif

			if (NoCRT::mem::memicmp((void*)addressApi, &shellSysCall64, sizeof(shellSysCall64)))
			{
				return TRUE;
			}

			NoCRT::mem::memcpy(addressApi, safeByte, sizeof(safeByte));
			VirtualProtect(addressApi, 0x1024, protect, &protect);
			if (NT_SUCCESS(status) && !IsThreadHide)
			{
				return TRUE;
			}
			return FALSE;
		}
	



}

	namespace Util
	{

		//wallking in all known module end check PAGE_GUARD hook (x64dbg use this for memory page)
		__forceinline bool IsGuardHook()
		{


			MEMORY_BASIC_INFORMATION memory_info;


#ifdef _WIN64
			PEB* peb = (PEB*)__readgsqword(0x60);

#else
			PEB* peb = (PEB*)__readfsdword(0x30);
#endif



			LIST_ENTRY head = peb->Ldr->InMemoryOrderModuleList;

			LIST_ENTRY curr = head;

			for (auto curr = head; curr.Flink != &peb->Ldr->InMemoryOrderModuleList; curr = *curr.Flink)
			{
				LDR_DATA_TABLE_ENTRY* mod = (LDR_DATA_TABLE_ENTRY*)CONTAINING_RECORD(curr.Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

				if (mod->BaseDllName.Buffer)
				{
					auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(mod->DllBase) + static_cast<PIMAGE_DOS_HEADER>(mod->DllBase)->e_lfanew);
					auto* sections = IMAGE_FIRST_SECTION(headers);

					for (auto i = 0; i <= headers->FileHeader.NumberOfSections; i++)
					{
						auto* section = &sections[i];

						auto virtualAddress = static_cast<PBYTE>(mod->DllBase) + section->VirtualAddress;

						if (VirtualQuery(virtualAddress, &memory_info, sizeof(MEMORY_BASIC_INFORMATION)))
						{
							//know memory and  page have PAGE_GUARD protecthion
							if (memory_info.State == MEM_COMMIT && (memory_info.Protect & PAGE_GUARD))
								return TRUE;

						}

					}


				}
			}
			return FALSE;
		}

		/*
		Check only in execute module for present false detect
		 0xcc - can be code cave
		*/
		__forceinline bool IsModuleHaveBP() 
		{
				auto base = (PVOID)ApiWrapper::GetModuleBaseAddress(NULL);

				auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
				auto* sections = IMAGE_FIRST_SECTION(headers);

				for (auto i = 0; i <= headers->FileHeader.NumberOfSections;i++)
				{
					auto* section = &sections[i];
					//Check secthion rules
					auto virtualAddress = static_cast<PBYTE>(base) + section->VirtualAddress;
					if ((section->Characteristics & IMAGE_SCN_MEM_READ && section->Characteristics & IMAGE_SCN_MEM_EXECUTE) && !(section->Characteristics & IMAGE_SCN_MEM_WRITE))
					{
						for (size_t j = 0; j <= section->Misc.VirtualSize; j++)
						{
#ifdef _WIN64


							if (*(virtualAddress + j) == 0x0f && *(virtualAddress + j + 1) == 0xb//ud2 breakpoint
							&& (*(virtualAddress + j + 2)) != NULL 
							&& *(virtualAddress + j + 3) != NULL)
							{ 
								return TRUE;
							}

#else  //False detect by IsStartedWithDisableDSE@CheckTestMode
						 if (*(virtualAddress + j) == 0xcd && *(virtualAddress + j + 1) == 0x3 //long int 
								&& (*(virtualAddress + j + 2)) != NULL
								&& *(virtualAddress + j + 3) != NULL)
							{
								return TRUE;
							}
#endif
						}
					}
				
				}
				return FALSE;
		}


		//We fast check hook in some ntapi 
		__forceinline bool IsNtApiCorrupted()
		{
		 

			auto base = (DWORD64)ApiWrapper::GetModuleBaseAddress(L"ntdll.dll");

			if (!base)
				return 0;
			auto pDOS = (PIMAGE_DOS_HEADER)base;
			if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
				return 0;
			auto pNT = (PIMAGE_NT_HEADERS)((DWORD64)base + (DWORD)pDOS->e_lfanew);
			if (pNT->Signature != IMAGE_NT_SIGNATURE)
				return 0;
			auto pExport = (PIMAGE_EXPORT_DIRECTORY)(base + pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
			if (!pExport)
				return 0;
			auto names = (PDWORD)(base + pExport->AddressOfNames);
			auto ordinals = (PWORD)(base + pExport->AddressOfNameOrdinals);
			auto functions = (PDWORD)(base + pExport->AddressOfFunctions);

			for (int j = 0, i = 0; i < pExport->NumberOfFunctions; ++i) {
				auto name = (LPCSTR)(base + names[i]);
				if (name[0] == 'N' && name[1] == 't')
				{
					if
						(
						//We check byte's syscall/sysentry for present false detect(like:NtGetTickCount)
#ifdef _WIN64			
						!ApiWrapper::IsNormalSyscallByte(base + functions[ordinals[i]]) &&
						*(BYTE*)(base + functions[ordinals[i]] + 0x12) == 0x0F && //syscall
						*(BYTE*)(base + functions[ordinals[i]] + 0x13) == 0X05
#else
						!ApiWrapper::IsNormalSyscallByte(base + functions[ordinals[i]]) &&
						*(BYTE*)(base + functions[ordinals[i]] + 0xA) == 0xFF &&  //sysentry
						*(BYTE*)(base + functions[ordinals[i]] + 0xB) == 0XD2
#endif // _WIN64
						)
					{
						return TRUE;
					}
				}
			}
			return FALSE;
		}

		/*
		Anti UM plugin change build number for bypass manual syscall in VMP and we will be check this
		*/
		__forceinline bool BuildNumberIsHooked()
		{
			 
			auto buildNumberNtdll = ApiWrapper::GetNtdllBuild();

			//Check start check OSBuildNumber in PEB 
			if (ApiWrapper::GetWindowsNumber() >= WINDOWS_NUMBER_10)
			{
				// we can safe check by read  NtBuildNumber in KUSER_SHARED_DATA
				if (ApiWrapper::GetNumberBuild() != ApiWrapper::PEBGetNumberBuild())
				{
					return TRUE;
				}
				else if 
				(ApiWrapper::GetNumberBuild() - buildNumberNtdll > 2000 )
				{
					return TRUE;
				}

			}
			else
			{
				// windows number < 10 we check by RtlGetVersion
				RTL_OSVERSIONINFOW  lpVersionInformation;

				lpVersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);


				auto   RtlGetVersion = (t_RtlGetVersion)ApiWrapper::GetProcAddress(L"ntdll.dll", "RtlGetVersion");

				if (RtlGetVersion)
				{
					RtlGetVersion(&lpVersionInformation);
					if (lpVersionInformation.dwBuildNumber != ApiWrapper::PEBGetNumberBuild())
					{
						  return TRUE;
					}
					else if
						((lpVersionInformation.dwBuildNumber - buildNumberNtdll > 2000) 
					{
						return TRUE;
					}

				}
			}


			return FALSE;
		}




#ifndef _WIN64



		// thanks colby57 https://github.com/colby57
		__forceinline bool IsWow64Hooked()
		{


			/*
			hooked(ShyllaHide)

			777C7000  | EA 52189000 2300                         | jmp far 23:901852                                       | 0023:00901852:"`QPè»ÿÿÿø"
			777C7007  | 0000                                     | add byte ptr ds:[eax],al                                |
			777C7009  | 41                                       | inc ecx                                                 |
			777C700A  | FFA7 F8000000                            | jmp dword ptr ds:[edi+F8]                               |


			don't hooked
			777C7000  | EA 09707C77 3300                         | jmp far 33:777C7009                                     | 0033:777C7009:"Aÿ§ø"
			777C7007  | 0000                                     | add byte ptr ds:[eax],al                                |
			777C7009  | 41                                       | inc ecx                                                 |
			777C700A  | FFA7 F8000000                            | jmp dword ptr ds:[edi+F8]                               |
			*/
			auto nt_status = STATUS_UNSUCCESSFUL;
			auto bDetect = TRUE;
			BYTE buffer[10];
			NoCRT::mem::memset(buffer, 0, sizeof(buffer));
			auto wow64Address = (PBYTE)__readfsdword(0xC0); 
			auto NtReadVirtualMemory = (t_NtReadVirtualMemory)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtReadVirtualMemory");
			if (NtReadVirtualMemory)
			{
				//try read memory by NtReadVirtualMemory for present PB
				 nt_status = NtReadVirtualMemory(NtCurrentProcess, wow64Address, &buffer, 6, NULL);
				 if (NT_SUCCESS(nt_status))
				 {
					 for (BYTE i = 0; i <= 6; i++)
					 {
						 if (buffer[i] == 0x33)
						 {
							 bDetect = FALSE;
						 }

					 }
				 }
			}
			else if(!NT_SUCCESS(nt_status) || !NtReadVirtualMemory) //bad status or we can get address NtApi
			{
				


				for (BYTE i = 0; i <= 6; i++)
				{
					if (*(wow64Address + i) == 0x33)
					{
						bDetect = FALSE;
					}

				}
			}
			

			return bDetect;
		}
#endif 


	}

}

```

`Baka/ApiWrapper.h`:

```h
#pragma once
#include "NoCRT.h"

namespace ApiWrapper
{
    __forceinline    UNICODE_STRING InitUnicodeString(static const wchar_t* string_to_init)
    {

        UNICODE_STRING stringInit;
        if (string_to_init)
        {
            stringInit.Length = NoCRT::string::wstrlen(string_to_init) * sizeof(wchar_t);
            stringInit.MaximumLength = stringInit.Length + 2;
            stringInit.Buffer = (wchar_t*)string_to_init;
        }
        return stringInit;

    }





    __forceinline  int CompareUnicodeString(UNICODE_STRING str_1, UNICODE_STRING str_2, bool case_int_sensitive = false)
    {

        //return 0 if equal
        if (case_int_sensitive)
        {
            return NoCRT::string::wstrcmp(str_1.Buffer, str_2.Buffer);
        }
        else
        {
            return NoCRT::string::wstricmp(str_1.Buffer, str_2.Buffer);
        }

    }



    __forceinline  void FreeUnicodeString(PUNICODE_STRING str)
    {

        str->Buffer = 0;
        str->Length = 0;
        str->MaximumLength = 0;
    }

    


    __forceinline  SIZE_T  NTAPI   RtlCompareMemory
    (const VOID* Source1,
        const VOID* Source2,
        SIZE_T Length)
    {
        SIZE_T i;
        for (i = 0; (i < Length) && (((PUCHAR)Source1)[i] == ((PUCHAR)Source2)[i]); i++)
            ;

        return i;
    }

    __forceinline  SIZE_T NTAPI  RtlCompareMemoryUlong
    (
            IN PVOID Source,
            IN SIZE_T Length,
            IN ULONG Value
     )
    {
        PULONG ptr = (PULONG)Source;
        ULONG_PTR len = Length / sizeof(ULONG);
        ULONG_PTR i;

        for (i = 0; i < len; i++)
        {
            if (*ptr != Value)
                break;

            ptr++;
        }

        return (SIZE_T)((PCHAR)ptr - (PCHAR)Source);
    }




    __forceinline   VOID  NTAPI   MyZeroMemory
    (
        PVOID Destination,
        SIZE_T Length)
    {
        NoCRT::mem::memset(Destination, 0, Length);
    }

    __forceinline  VOID NTAPI FillMemoryUlonglong
    (
        PVOID Destination,
        SIZE_T Length,
        ULONGLONG Fill)
    {
        PULONGLONG Dest = (PULONGLONG)Destination;
        SIZE_T Count = Length / sizeof(ULONGLONG);

        while (Count > 0)
        {
            *Dest = Fill;
            Dest++;
            Count--;
        }
    }


    __forceinline DWORD64 GetModuleBaseAddress(const wchar_t* modName)
    {


        LDR_DATA_TABLE_ENTRY* modEntry = nullptr;





#ifdef _WIN64
        PEB* peb = (PEB*)__readgsqword(0x60);

#else
        PEB* peb = (PEB*)__readfsdword(0x30);
#endif



        LIST_ENTRY head = peb->Ldr->InMemoryOrderModuleList;

        LIST_ENTRY curr = head;

        for (auto curr = head; curr.Flink != &peb->Ldr->InMemoryOrderModuleList; curr = *curr.Flink)
        {
            LDR_DATA_TABLE_ENTRY* mod = (LDR_DATA_TABLE_ENTRY*)CONTAINING_RECORD(curr.Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

            if (mod->BaseDllName.Buffer)
            {
                if (!modName)
                {
                    modEntry = mod;
                    break;
                }


                if (NoCRT::string::wstrstr(modName, mod->BaseDllName.Buffer))
                {
                    modEntry = mod;
                    break;
                }


            }
        }
        return (DWORD64)modEntry->DllBase;

    }

    __forceinline DWORD64 GetProcAddress(const wchar_t* modName, const char* ApiName)
    {
        auto base = GetModuleBaseAddress(modName);
        if (!base)
            return 0;
        auto pDOS = (PIMAGE_DOS_HEADER)base;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
            return 0;
        auto pNT = (PIMAGE_NT_HEADERS)(base + (DWORD)pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE)
            return 0;
        auto pExport = (PIMAGE_EXPORT_DIRECTORY)(base + pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
        if (!pExport)
            return 0;
        auto names = (PDWORD)(base + pExport->AddressOfNames);
        auto ordinals = (PWORD)(base + pExport->AddressOfNameOrdinals);
        auto functions = (PDWORD)(base + pExport->AddressOfFunctions);

        for (int i = 0; i < pExport->NumberOfFunctions; ++i) {
            auto name = (LPCSTR)(base + names[i]);
            if (!NoCRT::string::strcmp(name, ApiName))
                return base + functions[ordinals[i]];
        }
        return 0;
    }

    __forceinline bool IsNormalSyscallByte(DWORD64 addressApi)
    {
#ifdef _WIN64

        return (
            *(BYTE*)(addressApi) == 0x4C &&
            *(BYTE*)(addressApi + 1) == 0x8B &&
            *(BYTE*)(addressApi + 2) == 0xD1 &&
            *(BYTE*)(addressApi + 3) == 0xB8 &&
            *(BYTE*)(addressApi + 0x12) == 0x0F &&
            *(BYTE*)(addressApi + 0x13) == 0X05);
#else 

        return (
            *(BYTE*)(addressApi) == 0xB8 &&
            *(BYTE*)(addressApi + 5) == 0xBA &&
            *(BYTE*)(addressApi + 10) == 0xFF &&
            *(BYTE*)(addressApi + 11) == 0XD2);
#endif // _WIN64


    }
     
    //We get randome ntapi and check for hook
    __forceinline    DWORD64 GetRandomSyscallAddress()
    {


        auto base = ApiWrapper::GetModuleBaseAddress(L"ntdll.dll");
        if (!base)
            return 0;
        auto pDOS = (PIMAGE_DOS_HEADER)base;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
            return 0;
        auto pNT = (PIMAGE_NT_HEADERS)(base + (DWORD)pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE)
            return 0;
        auto pExport = (PIMAGE_EXPORT_DIRECTORY)(base + pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
        if (!pExport)
            return 0;
        auto names = (PDWORD)(base + pExport->AddressOfNames);
        auto ordinals = (PWORD)(base + pExport->AddressOfNameOrdinals);
        auto functions = (PDWORD)(base + pExport->AddressOfFunctions);
        auto randomNumber = GetTickCount() % 30; 

        for (int j = 0, i = 0; i < pExport->NumberOfFunctions; ++i)
        {
            if (IsNormalSyscallByte(base + functions[ordinals[i]]))
            {
                j++;
                if (j == randomNumber)
                {
                    return base + functions[ordinals[i]];
                }
            }
        }

        return 0;
    }


    __forceinline DWORD64 GetProcAddress(DWORD64 base, const char* ApiName)
    {

        if (!base)
            return 0;
        auto pDOS = (PIMAGE_DOS_HEADER)base;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
            return 0;
        auto pNT = (PIMAGE_NT_HEADERS)(base + (DWORD)pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE)
            return 0;
        auto pExport = (PIMAGE_EXPORT_DIRECTORY)(base + pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
        if (!pExport)
            return 0;
        auto names = (PDWORD)(base + pExport->AddressOfNames);
        auto ordinals = (PWORD)(base + pExport->AddressOfNameOrdinals);
        auto functions = (PDWORD)(base + pExport->AddressOfFunctions);

        for (int i = 0; i < pExport->NumberOfFunctions; ++i) {
            auto name = (LPCSTR)(base + names[i]);
            if (!NoCRT::string::strcmp(name, ApiName))
                return base + functions[ordinals[i]];
        }
        return 0;
    }

    // Get Windows number by    KUSER_SHARED_DATA(support on Windows XP or leater)
    __forceinline  int GetWindowsNumber()
    {

        auto NtMajorVersion = *(BYTE*)0x7FFE026C;
        if (NtMajorVersion == 10)
        {
            auto NtBuildNumber = *(int*)0x7FFE0260;//NtBuildNumber
            if (NtBuildNumber >= 22000)
            {
                return WINDOWS_NUMBER_11;
            }
            return WINDOWS_NUMBER_10;
        }
        else if (NtMajorVersion == 5)
        {
            return WINDOWS_NUMBER_XP;//Windows XP
        }
        else if (NtMajorVersion == 6)
        {
            /*
            https://www.godeye.club/2021/06/03/002-mhyprot-insider-callbacks.html
            */
            switch (*(BYTE*)0x7FFE0270)  //0x7FFE0270 NtMinorVersion
            {
            case 1:
                return WINDOWS_NUMBER_7;//windows 7
            case 2:
                return WINDOWS_NUMBER_8; //window 8
            case 3:
                return WINDOWS_NUMBER_8_1; //windows 8.1
            default:
                return WINDOWS_NUMBER_11;//windows 11
            }

        }

        return 0;
    }

    // Get windows numbe build by NtBuildNumber in KUSER_SHARED_DATA(support in Windows 10 or leater)
    __forceinline   int GetNumberBuild()
    {
        if (GetWindowsNumber() >= WINDOWS_NUMBER_10)
        {
            return *(int*)0x00000007FFE0260; //NtBuildNumber

        }

        return 0;


    }

    __forceinline DWORD64 GetNtdllBuild()
    {
        auto  pNative = (wchar_t*)ApiWrapper::GetModuleBaseAddress(L"ntdll.dll");
   
        for (; ; pNative++)
         {
           if (NoCRT::string::wstrcmp(pNative, L"FileVersion")==0)
           {
              
              return NoCRT::string::wtoi64(pNative + 18);
            }
         }
    }

    //Get OSBuildNumber in PEB
    __forceinline  int PEBGetNumberBuild()
    {



#ifdef _WIN64
        return *(int*)(__readgsqword(0x60) + 0x120);

#else
        return *(int*)(__readfsdword(0x30) + 0xAC);
#endif 

    }

    void printf(const wchar_t* formatstring, ...)
    {


        DWORD dwRet;
        wchar_t buffer[150];
        NoCRT::mem::memset(buffer, sizeof(wchar_t) * 150, 0);
        va_list v1;
        __crt_va_start(v1, formatstring);
        wvsprintfW(buffer, formatstring, v1);
        auto bufferLength = NoCRT::string::wstrlen(buffer);
        WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), buffer, bufferLength, &dwRet, 0);



    }

   
    wchar_t* cin()
    {

        wchar_t input;

        do {
            DWORD charsRead;
            ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &input, 1, &charsRead, nullptr);
        } while (!input);

        return (wchar_t*)input;
    }
    




}


```

`Baka/Baka.cpp`:

```cpp


#include "AntiDebug.h"
#include "TestModeCheck.h"
#include "CheckBigBool.h"
#include "CRCSections.h"


int Entry()
{

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN); // for fun

	auto baseAddress = (PVOID)ApiWrapper::GetModuleBaseAddress(NULL);
	CRCSecthion::StealsCRCSectionsInit(baseAddress);

	ApiWrapper::printf(L"Is known page have guard hook ->\t%x\n", AntiDebug::Util::IsGuardHook());
	ApiWrapper::printf(L"Some ntapi hooked ->\t%x\n", AntiDebug::Util::IsNtApiCorrupted());
	ApiWrapper::printf(L"execute module have bp ->\t%x\n", AntiDebug::Util::IsModuleHaveBP());




#ifndef _WIN64
		ApiWrapper::printf(L"WoW64Translate is hooded ->\t%x\n", AntiDebug::Util::IsWow64Hooked());
#endif

		

	ApiWrapper::printf(L"[ShellCode] Is debug port exist ->\t%x\n", AntiDebug::ShellCode::IsDebugPort());
	ApiWrapper::printf(L"[ShellCode] Is debug flag exist ->\t%x\n",AntiDebug::ShellCode::IsDebugFlag());
	ApiWrapper::printf(L"[ShellCode] Is debug object exist ->\t%x\n", AntiDebug::ShellCode::IsDebugObjectHandle());

	ApiWrapper::printf(L"[OverWriteSyscall] Is debug flag hooked ->\t%x\n", AntiDebug::OverWriteSyscall::IsDebugFlagHooked());
	ApiWrapper::printf(L"[OverWriteSyscall] Is thread don't hide  ->\t%x\n", AntiDebug::OverWriteSyscall::IsBadHideThread());

	
	


	ApiWrapper::printf(L"Is HyperHide help debugging some process ->\t%x\n", BlackListPool::IsHyperHideDebuggingProcess());
	ApiWrapper::printf(L"Is build number hooked ->\t%x\n", AntiDebug::Util::BuildNumberIsHooked());

	ApiWrapper::printf(L"Anti test mode by NtQuerySystemInformation ->\t%x\n", CheckTestMode::CodeIntCheck());
	ApiWrapper::printf(L"Anti test mode by SystemStartOptions ->\t%x\n", CheckTestMode::IsStartedWithDisableDSE());
	ApiWrapper::printf(L"Anti test mode by Elements in BCD00000000 ->\t%x\n", CheckTestMode::IsBcdLibraryBooleanAllowPrereleaseSignatures());

 





	
	if (GetAsyncKeyState(VK_SPACE))
	{


		if (CRCSecthion::SectionsIsCorrupt() || CRCSecthion::StealsSectionsIsCorrupt())
		{
			ApiWrapper::printf(L"Detect change section!\n");
		}
		else
		{
			ApiWrapper::printf(L"No detect change section!\n");
		}
		Sleep(500);
	}
	
	
   
	ApiWrapper::cin();

	return 0;
}

```

`Baka/Baka.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{23267294-279a-4406-b71b-e64d94c426fc}</ProjectGuid>
    <RootNamespace>Baka</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>Entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <ExceptionHandling>false</ExceptionHandling>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>Entry</EntryPointSymbol>
      <GenerateMapFile>true</GenerateMapFile>
      <AdditionalOptions> /stub:custom_dos_stub.bin %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions> /stub:custom_dos_stub.bin %(AdditionalOptions)</AdditionalOptions>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>Entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Baka.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AntiDebug.h" />
    <ClInclude Include="ApiWrapper.h" />
    <ClInclude Include="CheckBigBool.h" />
    <ClInclude Include="CRCpp.h" />
    <ClInclude Include="CRCSections.h" />
    <ClInclude Include="NoCRT.h" />
    <ClInclude Include="NtApi.h" />
    <ClInclude Include="Struct.h" />
    <ClInclude Include="SyscallHelp.hpp" />
    <ClInclude Include="TestModeCheck.h" />
    <ClInclude Include="WoW64ext.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Baka/Baka.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ApiWrapper">
      <UniqueIdentifier>{2de04f8d-ce81-4e07-a29e-12af40170410}</UniqueIdentifier>
    </Filter>
    <Filter Include="AntiReverse">
      <UniqueIdentifier>{4cfc82ce-5357-4386-a9bc-75669c64e721}</UniqueIdentifier>
    </Filter>
    <Filter Include="AntiReverse\AntiDebug">
      <UniqueIdentifier>{b5a748af-31a5-4780-9247-4ed57f4cd7da}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Baka.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Struct.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="NtApi.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="NoCRT.h">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="ApiWrapper.h">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="AntiDebug.h">
      <Filter>AntiReverse\AntiDebug</Filter>
    </ClInclude>
    <ClInclude Include="SyscallHelp.hpp">
      <Filter>AntiReverse\AntiDebug</Filter>
    </ClInclude>
    <ClInclude Include="WoW64ext.h">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="TestModeCheck.h">
      <Filter>AntiReverse</Filter>
    </ClInclude>
    <ClInclude Include="CRCSections.h">
      <Filter>AntiReverse</Filter>
    </ClInclude>
    <ClInclude Include="CRCpp.h">
      <Filter>ApiWrapper</Filter>
    </ClInclude>
    <ClInclude Include="CheckBigBool.h">
      <Filter>AntiReverse\AntiDebug</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Baka/Baka.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Baka/CRCSections.h`:

```h
#pragma once
#include "ApiWrapper.h"
#include "NtApi.h"
#include "CRCpp.h"


namespace CRCSecthion
{

	SECTION_CRC CRCSectionsResult[10];

	__forceinline uint32_t fletcher32(PVOID  data, size_t len)
	{ 
		uint64_t data2 = (uint64_t)data;
		uint32_t sum1 = 0xffff, sum2 = 0xffff;

		while (len) {
			unsigned tlen = len > 359 ? 359 : len;

			len -= tlen;

			do {
				sum1 += *(uint64_t*)data2++;
				sum2 += sum1;
			} while (--tlen);

			sum1 = (sum1 & 0xffff) + (sum1 >> 16);
			sum2 = (sum2 & 0xffff) + (sum2 >> 16);

		}
		/* Second reduction step to reduce sums to 16 bits */
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16); 
		return sum2 << 16 | sum1;
		
	}

	

	/*
	We try safe read memory for present BP
	*/


	__forceinline    void  StealsCRCSectionsInit(PVOID base)
	{


		PVOID buffer = 0;
		NTSTATUS nt_status = STATUS_UNSUCCESSFUL;
		auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
		auto* sections = IMAGE_FIRST_SECTION(headers);

		for (auto i = 0; i <= headers->FileHeader.NumberOfSections; i++)
		{
			auto* section = &sections[i];
			//Check sections rules

			if ((section->Characteristics & IMAGE_SCN_MEM_READ) && !(section->Characteristics & IMAGE_SCN_MEM_WRITE))
			{
				
				buffer = VirtualAlloc(nullptr, section->Misc.VirtualSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
				if (buffer)
				{

					auto NtReadVirtualMemory = (t_NtReadVirtualMemory)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtReadVirtualMemory");
					if (NtReadVirtualMemory)
					{
						//Write memory in allocated buffer for present fast detect by BP
						nt_status = NtReadVirtualMemory(NtCurrentProcess, static_cast<char*>(base) + section->VirtualAddress, buffer, section->Misc.VirtualSize, NULL);


						if (NT_SUCCESS(nt_status))
						{

							CRCSectionsResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
							CRCSectionsResult[i].virtualSize = section->Misc.VirtualSize;
							CRCSectionsResult[i].resultCRC = CRC::Calculate(buffer, section->Misc.VirtualSize, CRC::CRC_32());
							CRCSectionsResult[i].fletcherCRC = fletcher32(buffer, section->Misc.VirtualSize);

						}
					}
					// bad status NtReadVirtualMemory or can't get address NtReadVirtualMemory
					else if(!NtReadVirtualMemory || !NT_SUCCESS(nt_status)) 
					{
						CRCSectionsResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
						CRCSectionsResult[i].virtualSize = section->Misc.VirtualSize;
						CRCSectionsResult[i].resultCRC = CRC::Calculate(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize, CRC::CRC_32());
						CRCSectionsResult[i].fletcherCRC = fletcher32(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize);

					}
					VirtualFree(buffer, 0, MEM_RELEASE);
				}
				//can't allocate memory
				else
				{
					CRCSectionsResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
					CRCSectionsResult[i].virtualSize = section->Misc.VirtualSize;
					CRCSectionsResult[i].resultCRC = CRC::Calculate(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize, CRC::CRC_32());
					CRCSectionsResult[i].fletcherCRC = fletcher32(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize);

				}

			}
		}

	}



	__forceinline    bool StealsSectionsIsCorrupt()
	{
		PVOID buffer = 0;
		bool secthionIsPatched = false;
		NTSTATUS nt_status = STATUS_UNSUCCESSFUL;
		SECTION_CRC newCRCResult[10];

		auto base = (PVOID)ApiWrapper::GetModuleBaseAddress(NULL);

		auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
		auto* sections = IMAGE_FIRST_SECTION(headers);

		for (auto i = 0; i <= headers->FileHeader.NumberOfSections; i++)
		{
			auto* section = &sections[i];
			//Check secthion rules
			if ((section->Characteristics & IMAGE_SCN_MEM_READ) && !(section->Characteristics & IMAGE_SCN_MEM_WRITE))
			{

				
				buffer = VirtualAlloc(nullptr, section->Misc.VirtualSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
				if (buffer)
				{

					auto NtReadVirtualMemory = (t_NtReadVirtualMemory)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtReadVirtualMemory");
					if (NtReadVirtualMemory)
					{


						//Write memory in allocated buffer for present fast detect by BP
						nt_status = NtReadVirtualMemory(NtCurrentProcess, static_cast<char*>(base) + section->VirtualAddress, buffer, section->Misc.VirtualSize, NULL);


						if (NT_SUCCESS(nt_status))
						{
							newCRCResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
							newCRCResult[i].virtualSize = section->Misc.VirtualSize;
							newCRCResult[i].resultCRC = CRC::Calculate(buffer, section->Misc.VirtualSize, CRC::CRC_32());
							newCRCResult[i].fletcherCRC = fletcher32(buffer, section->Misc.VirtualSize);

							if (
								newCRCResult[i].resultCRC != CRCSectionsResult[i].resultCRC ||
								newCRCResult[i].virtualAddress != CRCSectionsResult[i].virtualAddress ||
								newCRCResult[i].virtualSize != CRCSectionsResult[i].virtualSize || 
								newCRCResult[i].fletcherCRC != CRCSectionsResult[i].fletcherCRC
								)
							{
								secthionIsPatched = TRUE;
							}
						}
					}
					// bad status NtReadVirtualMemory or can't get address NtReadVirtualMemory
					else if(!NtReadVirtualMemory || !NT_SUCCESS(nt_status))
					{
						newCRCResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
						newCRCResult[i].virtualSize = section->Misc.VirtualSize;
						newCRCResult[i].resultCRC = CRC::Calculate(newCRCResult[i].virtualAddress, section->Misc.VirtualSize, CRC::CRC_32());
						newCRCResult[i].fletcherCRC = fletcher32(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize);

						if (
							newCRCResult[i].resultCRC != CRCSectionsResult[i].resultCRC ||
							newCRCResult[i].virtualAddress != CRCSectionsResult[i].virtualAddress ||
							newCRCResult[i].virtualSize != CRCSectionsResult[i].virtualSize ||
							newCRCResult[i].fletcherCRC != CRCSectionsResult[i].fletcherCRC
							)
						{
							secthionIsPatched = TRUE;
						}
					}
					VirtualFree(buffer, 0, MEM_RELEASE);
				}
				//can't allocate memory
				else
				{
					newCRCResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
					newCRCResult[i].virtualSize = section->Misc.VirtualSize;
					newCRCResult[i].resultCRC = CRC::Calculate(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize, CRC::CRC_32());
					newCRCResult[i].fletcherCRC = fletcher32(CRCSectionsResult[i].virtualAddress, section->Misc.VirtualSize);

					if (
						newCRCResult[i].resultCRC != CRCSectionsResult[i].resultCRC ||
						newCRCResult[i].virtualAddress != CRCSectionsResult[i].virtualAddress ||
						newCRCResult[i].virtualSize != CRCSectionsResult[i].virtualSize ||
						newCRCResult[i].fletcherCRC != CRCSectionsResult[i].fletcherCRC
						)
					{
						secthionIsPatched = TRUE;
					}
				}
			}
			
		
		}

		return secthionIsPatched;
	}

	__forceinline    bool SectionsIsCorrupt()
	{
		auto base = (PVOID)ApiWrapper::GetModuleBaseAddress(NULL);
		NTSTATUS nt_status = STATUS_UNSUCCESSFUL;
		SECTION_CRC newCRCResult[10];
		auto secthionCheckResult = NULL;
		auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
		auto* sections = IMAGE_FIRST_SECTION(headers);

		for (auto i = 0; i <= headers->FileHeader.NumberOfSections; i++)
		{

			auto* section = &sections[i];
			//Check section rules
			if ((section->Characteristics & IMAGE_SCN_MEM_READ) && !(section->Characteristics & IMAGE_SCN_MEM_WRITE))
			{

				secthionCheckResult++;

				newCRCResult[i].virtualAddress = static_cast<char*>(base) + section->VirtualAddress;
				newCRCResult[i].virtualSize = section->Misc.VirtualSize;
				newCRCResult[i].resultCRC = CRC::Calculate(newCRCResult[i].virtualAddress, section->Misc.VirtualSize, CRC::CRC_32());
				newCRCResult[i].fletcherCRC = fletcher32(newCRCResult[i].virtualAddress, section->Misc.VirtualSize);

				if (
					newCRCResult[i].resultCRC != CRCSectionsResult[i].resultCRC ||
					newCRCResult[i].virtualAddress != CRCSectionsResult[i].virtualAddress ||
					newCRCResult[i].virtualSize != CRCSectionsResult[i].virtualSize ||
					newCRCResult[i].fletcherCRC != CRCSectionsResult[i].fletcherCRC
					)
				{
					return TRUE;
				}

			}


		}
		if (secthionCheckResult != headers->FileHeader.NumberOfSections - 1) //we have 1 write section
		{
			return TRUE;
		}

		return FALSE;
	}
	
}

```

`Baka/CRCpp.h`:

```h
#pragma once

/**
    @file CRC.h
    @author Daniel Bahr
    @version 1.1.0.0
    @copyright
    @parblock
        CRC++
        Copyright (c) 2021, Daniel Bahr
        All rights reserved.
        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are met:
        * Redistributions of source code must retain the above copyright notice, this
          list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright notice,
          this list of conditions and the following disclaimer in the documentation
          and/or other materials provided with the distribution.
        * Neither the name of CRC++ nor the names of its
          contributors may be used to endorse or promote products derived from
          this software without specific prior written permission.
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    @endparblock
*/

/*
    CRC++ can be configured by setting various #defines before #including this header file:
        #define crcpp_uint8                             - Specifies the type used to store CRCs that have a width of 8 bits or less.
                                                          This type is not used in CRC calculations. Defaults to ::std::uint8_t.
        #define crcpp_uint16                            - Specifies the type used to store CRCs that have a width between 9 and 16 bits (inclusive).
                                                          This type is not used in CRC calculations. Defaults to ::std::uint16_t.
        #define crcpp_uint32                            - Specifies the type used to store CRCs that have a width between 17 and 32 bits (inclusive).
                                                          This type is not used in CRC calculations. Defaults to ::std::uint32_t.
        #define crcpp_uint64                            - Specifies the type used to store CRCs that have a width between 33 and 64 bits (inclusive).
                                                          This type is not used in CRC calculations. Defaults to ::std::uint64_t.
        #define crcpp_size                              - This type is used for loop iteration and function signatures only. Defaults to ::std::size_t.
        #define CRCPP_USE_NAMESPACE                     - Define to place all CRC++ code within the ::CRCPP namespace.
        #define CRCPP_BRANCHLESS                        - Define to enable a branchless CRC implementation. The branchless implementation uses a single integer
                                                          multiplication in the bit-by-bit calculation instead of a small conditional. The branchless implementation
                                                          may be faster on processor architectures which support single-instruction integer multiplication.
        #define CRCPP_USE_CPP11                         - Define to enables C++11 features (move semantics, constexpr, static_assert, etc.).
        #define CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS  - Define to include definitions for little-used CRCs.
*/

#ifndef CRCPP_CRC_H_
#define CRCPP_CRC_H_

#include <climits>  // Includes CHAR_BIT
#ifdef CRCPP_USE_CPP11
#include <cstddef>  // Includes ::std::size_t
#include <cstdint>  // Includes ::std::uint8_t, ::std::uint16_t, ::std::uint32_t, ::std::uint64_t
#else
#include <stddef.h> // Includes size_t
#include <stdint.h> // Includes uint8_t, uint16_t, uint32_t, uint64_t
#endif
#include <limits>   // Includes ::std::numeric_limits
#include <utility>  // Includes ::std::move

#ifndef crcpp_uint8
#   ifdef CRCPP_USE_CPP11
/// @brief Unsigned 8-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint8 ::std::uint8_t
#   else
/// @brief Unsigned 8-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint8 uint8_t
#   endif
#endif

#ifndef crcpp_uint16
#   ifdef CRCPP_USE_CPP11
        /// @brief Unsigned 16-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint16 ::std::uint16_t
#   else
        /// @brief Unsigned 16-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint16 uint16_t
#   endif
#endif

#ifndef crcpp_uint32
#   ifdef CRCPP_USE_CPP11
        /// @brief Unsigned 32-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint32 ::std::uint32_t
#   else
        /// @brief Unsigned 32-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint32 uint32_t
#   endif
#endif

#ifndef crcpp_uint64
#   ifdef CRCPP_USE_CPP11
        /// @brief Unsigned 64-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint64 ::std::uint64_t
#   else
        /// @brief Unsigned 64-bit integer definition, used primarily for parameter definitions.
#       define crcpp_uint64 uint64_t
#   endif
#endif

#ifndef crcpp_size
#   ifdef CRCPP_USE_CPP11
        /// @brief Unsigned size definition, used for specifying data sizes.
#       define crcpp_size ::std::size_t
#   else
        /// @brief Unsigned size definition, used for specifying data sizes.
#       define crcpp_size size_t
#   endif
#endif

#ifdef CRCPP_USE_CPP11
    /// @brief Compile-time expression definition.
#   define crcpp_constexpr constexpr
#else
    /// @brief Compile-time expression definition.
#   define crcpp_constexpr const
#endif

#ifdef CRCPP_USE_NAMESPACE
    namespace CRCPP
{
#endif

    /**
        @brief Static class for computing CRCs.
        @note This class supports computation of full and multi-part CRCs, using a bit-by-bit algorithm or a
            byte-by-byte lookup table. The CRCs are calculated using as many optimizations as is reasonable.
            If compiling with C++11, the constexpr keyword is used liberally so that many calculations are
            performed at compile-time instead of at runtime.
    */
    class CRC
    {
    public:
        // Forward declaration
        template <typename CRCType, crcpp_uint16 CRCWidth>
        struct Table;

        /**
            @brief CRC parameters.
        */
        template <typename CRCType, crcpp_uint16 CRCWidth>
        struct Parameters
        {
            CRCType polynomial;   ///< CRC polynomial
            CRCType initialValue; ///< Initial CRC value
            CRCType finalXOR;     ///< Value to XOR with the final CRC
            bool reflectInput;    ///< true to reflect all input bytes
            bool reflectOutput;   ///< true to reflect the output CRC (reflection occurs before the final XOR)

            Table<CRCType, CRCWidth> MakeTable() const;
        };

        /**
            @brief CRC lookup table. After construction, the CRC parameters are fixed.
            @note A CRC table can be used for multiple CRC calculations.
        */
        template <typename CRCType, crcpp_uint16 CRCWidth>
        struct Table
        {
            // Constructors are intentionally NOT marked explicit.
            Table(const Parameters<CRCType, CRCWidth>& parameters);

#ifdef CRCPP_USE_CPP11
            Table(Parameters<CRCType, CRCWidth>&& parameters);
#endif

            const Parameters<CRCType, CRCWidth>& GetParameters() const;

            const CRCType* GetTable() const;

            CRCType operator[](unsigned char index) const;

        private:
            void InitTable();

            Parameters<CRCType, CRCWidth> parameters; ///< CRC parameters used to construct the table
            CRCType table[1 << CHAR_BIT];             ///< CRC lookup table
        };

        // The number of bits in CRCType must be at least as large as CRCWidth.
        // CRCType must be an unsigned integer type or a custom type with operator overloads.
        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType Calculate(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType Calculate(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType crc);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType Calculate(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType Calculate(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType crc);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateBits(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateBits(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType crc);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateBits(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateBits(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType crc);

        // Common CRCs up to 64 bits.
        // Note: Check values are the computed CRCs when given an ASCII input of "123456789" (without null terminator)
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters< crcpp_uint8, 4>& CRC_4_ITU();
        static const Parameters< crcpp_uint8, 5>& CRC_5_EPC();
        static const Parameters< crcpp_uint8, 5>& CRC_5_ITU();
        static const Parameters< crcpp_uint8, 5>& CRC_5_USB();
        static const Parameters< crcpp_uint8, 6>& CRC_6_CDMA2000A();
        static const Parameters< crcpp_uint8, 6>& CRC_6_CDMA2000B();
        static const Parameters< crcpp_uint8, 6>& CRC_6_ITU();
        static const Parameters< crcpp_uint8, 6>& CRC_6_NR();
        static const Parameters< crcpp_uint8, 7>& CRC_7();
#endif
        static const Parameters< crcpp_uint8, 8>& CRC_8();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters< crcpp_uint8, 8>& CRC_8_EBU();
        static const Parameters< crcpp_uint8, 8>& CRC_8_MAXIM();
        static const Parameters< crcpp_uint8, 8>& CRC_8_WCDMA();
        static const Parameters< crcpp_uint8, 8>& CRC_8_LTE();
        static const Parameters<crcpp_uint16, 10>& CRC_10();
        static const Parameters<crcpp_uint16, 10>& CRC_10_CDMA2000();
        static const Parameters<crcpp_uint16, 11>& CRC_11();
        static const Parameters<crcpp_uint16, 11>& CRC_11_NR();
        static const Parameters<crcpp_uint16, 12>& CRC_12_CDMA2000();
        static const Parameters<crcpp_uint16, 12>& CRC_12_DECT();
        static const Parameters<crcpp_uint16, 12>& CRC_12_UMTS();
        static const Parameters<crcpp_uint16, 13>& CRC_13_BBC();
        static const Parameters<crcpp_uint16, 15>& CRC_15();
        static const Parameters<crcpp_uint16, 15>& CRC_15_MPT1327();
#endif
        static const Parameters<crcpp_uint16, 16>& CRC_16_ARC();
        static const Parameters<crcpp_uint16, 16>& CRC_16_BUYPASS();
        static const Parameters<crcpp_uint16, 16>& CRC_16_CCITTFALSE();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters<crcpp_uint16, 16>& CRC_16_CDMA2000();
        static const Parameters<crcpp_uint16, 16>& CRC_16_CMS();
        static const Parameters<crcpp_uint16, 16>& CRC_16_DECTR();
        static const Parameters<crcpp_uint16, 16>& CRC_16_DECTX();
        static const Parameters<crcpp_uint16, 16>& CRC_16_DNP();
#endif
        static const Parameters<crcpp_uint16, 16>& CRC_16_GENIBUS();
        static const Parameters<crcpp_uint16, 16>& CRC_16_KERMIT();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters<crcpp_uint16, 16>& CRC_16_MAXIM();
        static const Parameters<crcpp_uint16, 16>& CRC_16_MODBUS();
        static const Parameters<crcpp_uint16, 16>& CRC_16_T10DIF();
        static const Parameters<crcpp_uint16, 16>& CRC_16_USB();
#endif
        static const Parameters<crcpp_uint16, 16>& CRC_16_X25();
        static const Parameters<crcpp_uint16, 16>& CRC_16_XMODEM();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters<crcpp_uint32, 17>& CRC_17_CAN();
        static const Parameters<crcpp_uint32, 21>& CRC_21_CAN();
        static const Parameters<crcpp_uint32, 24>& CRC_24();
        static const Parameters<crcpp_uint32, 24>& CRC_24_FLEXRAYA();
        static const Parameters<crcpp_uint32, 24>& CRC_24_FLEXRAYB();
        static const Parameters<crcpp_uint32, 24>& CRC_24_LTEA();
        static const Parameters<crcpp_uint32, 24>& CRC_24_LTEB();
        static const Parameters<crcpp_uint32, 24>& CRC_24_NRC();
        static const Parameters<crcpp_uint32, 30>& CRC_30();
#endif
        static const Parameters<crcpp_uint32, 32>& CRC_32();
        static const Parameters<crcpp_uint32, 32>& CRC_32_BZIP2();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters<crcpp_uint32, 32>& CRC_32_C();
#endif
        static const Parameters<crcpp_uint32, 32>& CRC_32_MPEG2();
        static const Parameters<crcpp_uint32, 32>& CRC_32_POSIX();
#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
        static const Parameters<crcpp_uint32, 32>& CRC_32_Q();
        static const Parameters<crcpp_uint64, 40>& CRC_40_GSM();
        static const Parameters<crcpp_uint64, 64>& CRC_64();
#endif

#ifdef CRCPP_USE_CPP11
        CRC() = delete;
        CRC(const CRC& other) = delete;
        CRC& operator=(const CRC& other) = delete;
        CRC(CRC&& other) = delete;
        CRC& operator=(CRC&& other) = delete;
#endif

    private:
#ifndef CRCPP_USE_CPP11
        CRC();
        CRC(const CRC& other);
        CRC& operator=(const CRC& other);
#endif

        template <typename IntegerType>
        static __forceinline IntegerType Reflect(IntegerType value, crcpp_uint16 numBits);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType Finalize(CRCType remainder, CRCType finalXOR, bool reflectOutput);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType UndoFinalize(CRCType remainder, CRCType finalXOR, bool reflectOutput);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateRemainder(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType remainder);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateRemainder(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType remainder);

        template <typename CRCType, crcpp_uint16 CRCWidth>
        static __forceinline CRCType CalculateRemainderBits(unsigned char byte, crcpp_size numBits, const Parameters<CRCType, CRCWidth>& parameters, CRCType remainder);
    };

    /**
        @brief Returns a CRC lookup table construct using these CRC parameters.
        @note This function primarily exists to allow use of the auto keyword instead of instantiating
            a table directly, since template parameters are not inferred in constructors.
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC lookup table
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRC::Table<CRCType, CRCWidth> CRC::Parameters<CRCType, CRCWidth>::MakeTable() const
    {
        // This should take advantage of RVO and optimize out the copy.
        return CRC::Table<CRCType, CRCWidth>(*this);
    }

    /**
        @brief Constructs a CRC table from a set of CRC parameters
        @param[in] params CRC parameters
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRC::Table<CRCType, CRCWidth>::Table(const Parameters<CRCType, CRCWidth>& params) :
        parameters(params)
    {
        InitTable();
    }

#ifdef CRCPP_USE_CPP11
    /**
        @brief Constructs a CRC table from a set of CRC parameters
        @param[in] params CRC parameters
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRC::Table<CRCType, CRCWidth>::Table(Parameters<CRCType, CRCWidth>&& params) :
        parameters(::std::move(params))
    {
        InitTable();
    }
#endif

    /**
        @brief Gets the CRC parameters used to construct the CRC table
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC parameters
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline const CRC::Parameters<CRCType, CRCWidth>& CRC::Table<CRCType, CRCWidth>::GetParameters() const
    {
        return parameters;
    }

    /**
        @brief Gets the CRC table
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC table
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline const CRCType* CRC::Table<CRCType, CRCWidth>::GetTable() const
    {
        return table;
    }

    /**
        @brief Gets an entry in the CRC table
        @param[in] index Index into the CRC table
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC table entry
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRCType CRC::Table<CRCType, CRCWidth>::operator[](unsigned char index) const
    {
        return table[index];
    }

    /**
        @brief Initializes a CRC table.
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline void CRC::Table<CRCType, CRCWidth>::InitTable()
    {
        // For masking off the bits for the CRC (in the event that the number of bits in CRCType is larger than CRCWidth)
        static crcpp_constexpr CRCType BIT_MASK((CRCType(1) << (CRCWidth - CRCType(1))) |
            ((CRCType(1) << (CRCWidth - CRCType(1))) - CRCType(1)));

        // The conditional expression is used to avoid a -Wshift-count-overflow warning.
        static crcpp_constexpr CRCType SHIFT((CHAR_BIT >= CRCWidth) ? static_cast<CRCType>(CHAR_BIT - CRCWidth) : 0);

        CRCType crc;
        unsigned char byte = 0;

        // Loop over each dividend (each possible number storable in an unsigned char)
        do
        {
            crc = CRC::CalculateRemainder<CRCType, CRCWidth>(&byte, sizeof(byte), parameters, CRCType(0));

            // This mask might not be necessary; all unit tests pass with this line commented out,
            // but that might just be a coincidence based on the CRC parameters used for testing.
            // In any case, this is harmless to leave in and only adds a single machine instruction per loop iteration.
            crc &= BIT_MASK;

            if (!parameters.reflectInput && CRCWidth < CHAR_BIT)
            {
                // Undo the special operation at the end of the CalculateRemainder()
                // function for non-reflected CRCs < CHAR_BIT.
                crc = static_cast<CRCType>(crc << SHIFT);
            }

            table[byte] = crc;
        } while (++byte);
    }

    /**
        @brief Computes a CRC.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bytes
        @param[in] parameters CRC parameters
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::Calculate(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters)
    {
        CRCType remainder = CalculateRemainder(data, size, parameters, parameters.initialValue);

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }
    /**
        @brief Appends additional data to a previous CRC calculation.
        @note This function can be used to compute multi-part CRCs.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bytes
        @param[in] parameters CRC parameters
        @param[in] crc CRC from a previous calculation
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::Calculate(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType crc)
    {
        CRCType remainder = UndoFinalize<CRCType, CRCWidth>(crc, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);

        remainder = CalculateRemainder(data, size, parameters, remainder);

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Computes a CRC via a lookup table.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bytes
        @param[in] lookupTable CRC lookup table
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::Calculate(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable)
    {
        const Parameters<CRCType, CRCWidth>& parameters = lookupTable.GetParameters();

        CRCType remainder = CalculateRemainder(data, size, lookupTable, parameters.initialValue);

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Appends additional data to a previous CRC calculation using a lookup table.
        @note This function can be used to compute multi-part CRCs.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bytes
        @param[in] lookupTable CRC lookup table
        @param[in] crc CRC from a previous calculation
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::Calculate(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType crc)
    {
        const Parameters<CRCType, CRCWidth>& parameters = lookupTable.GetParameters();

        CRCType remainder = UndoFinalize<CRCType, CRCWidth>(crc, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);

        remainder = CalculateRemainder(data, size, lookupTable, remainder);

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Computes a CRC.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bits
        @param[in] parameters CRC parameters
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateBits(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters)
    {
        CRCType remainder = parameters.initialValue;

        // Calculate the remainder on a whole number of bytes first, then call
        // a special-case function for the remaining bits.
        crcpp_size wholeNumberOfBytes = size / CHAR_BIT;
        if (wholeNumberOfBytes > 0)
        {
            remainder = CalculateRemainder(data, wholeNumberOfBytes, parameters, remainder);
        }

        crcpp_size remainingNumberOfBits = size % CHAR_BIT;
        if (remainingNumberOfBits != 0)
        {
            unsigned char lastByte = *(reinterpret_cast<const unsigned char*>(data) + wholeNumberOfBytes);
            remainder = CalculateRemainderBits(lastByte, remainingNumberOfBits, parameters, remainder);
        }

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }
    /**
        @brief Appends additional data to a previous CRC calculation.
        @note This function can be used to compute multi-part CRCs.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bits
        @param[in] parameters CRC parameters
        @param[in] crc CRC from a previous calculation
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateBits(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType crc)
    {
        CRCType remainder = UndoFinalize<CRCType, CRCWidth>(crc, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);

        // Calculate the remainder on a whole number of bytes first, then call
        // a special-case function for the remaining bits.
        crcpp_size wholeNumberOfBytes = size / CHAR_BIT;
        if (wholeNumberOfBytes > 0)
        {
            remainder = CalculateRemainder(data, wholeNumberOfBytes, parameters, parameters.initialValue);
        }

        crcpp_size remainingNumberOfBits = size % CHAR_BIT;
        if (remainingNumberOfBits != 0)
        {
            unsigned char lastByte = *(reinterpret_cast<const unsigned char*>(data) + wholeNumberOfBytes);
            remainder = CalculateRemainderBits(lastByte, remainingNumberOfBits, parameters, remainder);
        }

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Computes a CRC via a lookup table.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bits
        @param[in] lookupTable CRC lookup table
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateBits(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable)
    {
        const Parameters<CRCType, CRCWidth>& parameters = lookupTable.GetParameters();

        CRCType remainder = parameters.initialValue;

        // Calculate the remainder on a whole number of bytes first, then call
        // a special-case function for the remaining bits.
        crcpp_size wholeNumberOfBytes = size / CHAR_BIT;
        if (wholeNumberOfBytes > 0)
        {
            remainder = CalculateRemainder(data, wholeNumberOfBytes, lookupTable, remainder);
        }

        crcpp_size remainingNumberOfBits = size % CHAR_BIT;
        if (remainingNumberOfBits != 0)
        {
            unsigned char lastByte = *(reinterpret_cast<const unsigned char*>(data) + wholeNumberOfBytes);
            remainder = CalculateRemainderBits(lastByte, remainingNumberOfBits, parameters, remainder);
        }

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Appends additional data to a previous CRC calculation using a lookup table.
        @note This function can be used to compute multi-part CRCs.
        @param[in] data Data over which CRC will be computed
        @param[in] size Size of the data, in bits
        @param[in] lookupTable CRC lookup table
        @param[in] crc CRC from a previous calculation
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateBits(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType crc)
    {
        const Parameters<CRCType, CRCWidth>& parameters = lookupTable.GetParameters();

        CRCType remainder = UndoFinalize<CRCType, CRCWidth>(crc, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);

        // Calculate the remainder on a whole number of bytes first, then call
        // a special-case function for the remaining bits.
        crcpp_size wholeNumberOfBytes = size / CHAR_BIT;
        if (wholeNumberOfBytes > 0)
        {
            remainder = CalculateRemainder(data, wholeNumberOfBytes, lookupTable, parameters.initialValue);
        }

        crcpp_size remainingNumberOfBits = size % CHAR_BIT;
        if (remainingNumberOfBits > 0)
        {
            unsigned char lastByte = *(reinterpret_cast<const unsigned char*>(data) + wholeNumberOfBytes);
            remainder = CalculateRemainderBits(lastByte, remainingNumberOfBits, parameters, remainder);
        }

        // No need to mask the remainder here; the mask will be applied in the Finalize() function.

        return Finalize<CRCType, CRCWidth>(remainder, parameters.finalXOR, parameters.reflectInput != parameters.reflectOutput);
    }

    /**
        @brief Reflects (i.e. reverses the bits within) an integer value.
        @param[in] value Value to reflect
        @param[in] numBits Number of bits in the integer which will be reflected
        @tparam IntegerType Integer type of the value being reflected
        @return Reflected value
    */
    template <typename IntegerType>
    inline IntegerType CRC::Reflect(IntegerType value, crcpp_uint16 numBits)
    {
        IntegerType reversedValue(0);

        for (crcpp_uint16 i = 0; i < numBits; ++i)
        {
            reversedValue = static_cast<IntegerType>((reversedValue << 1) | (value & 1));
            value = static_cast<IntegerType>(value >> 1);
        }

        return reversedValue;
    }

    /**
        @brief Computes the final reflection and XOR of a CRC remainder.
        @param[in] remainder CRC remainder to reflect and XOR
        @param[in] finalXOR Final value to XOR with the remainder
        @param[in] reflectOutput true to reflect each byte of the remainder before the XOR
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return Final CRC
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRCType CRC::Finalize(CRCType remainder, CRCType finalXOR, bool reflectOutput)
    {
        // For masking off the bits for the CRC (in the event that the number of bits in CRCType is larger than CRCWidth)
        static crcpp_constexpr CRCType BIT_MASK = (CRCType(1) << (CRCWidth - CRCType(1))) |
            ((CRCType(1) << (CRCWidth - CRCType(1))) - CRCType(1));

        if (reflectOutput)
        {
            remainder = Reflect(remainder, CRCWidth);
        }

        return (remainder ^ finalXOR) & BIT_MASK;
    }

    /**
        @brief Undoes the process of computing the final reflection and XOR of a CRC remainder.
        @note This function allows for computation of multi-part CRCs
        @note Calling UndoFinalize() followed by Finalize() (or vice versa) will always return the original remainder value:
            CRCType x = ...;
            CRCType y = Finalize(x, finalXOR, reflectOutput);
            CRCType z = UndoFinalize(y, finalXOR, reflectOutput);
            assert(x == z);
        @param[in] crc Reflected and XORed CRC
        @param[in] finalXOR Final value XORed with the remainder
        @param[in] reflectOutput true if the remainder is to be reflected
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return Un-finalized CRC remainder
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    inline CRCType CRC::UndoFinalize(CRCType crc, CRCType finalXOR, bool reflectOutput)
    {
        // For masking off the bits for the CRC (in the event that the number of bits in CRCType is larger than CRCWidth)
        static crcpp_constexpr CRCType BIT_MASK = (CRCType(1) << (CRCWidth - CRCType(1))) |
            ((CRCType(1) << (CRCWidth - CRCType(1))) - CRCType(1));

        crc = (crc & BIT_MASK) ^ finalXOR;

        if (reflectOutput)
        {
            crc = Reflect(crc, CRCWidth);
        }

        return crc;
    }

    /**
        @brief Computes a CRC remainder.
        @param[in] data Data over which the remainder will be computed
        @param[in] size Size of the data, in bytes
        @param[in] parameters CRC parameters
        @param[in] remainder Running CRC remainder. Can be an initial value or the result of a previous CRC remainder calculation.
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC remainder
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateRemainder(const void* data, crcpp_size size, const Parameters<CRCType, CRCWidth>& parameters, CRCType remainder)
    {
#ifdef CRCPP_USE_CPP11
        // This static_assert is put here because this function will always be compiled in no matter what
        // the template parameters are and whether or not a table lookup or bit-by-bit algorithm is used.
        static_assert(::std::numeric_limits<CRCType>::digits >= CRCWidth, "CRCType is too small to contain a CRC of width CRCWidth.");
#else
        // Catching this compile-time error is very important. Sadly, the compiler error will be very cryptic, but it's
        // better than nothing.
        enum { static_assert_failed_CRCType_is_too_small_to_contain_a_CRC_of_width_CRCWidth = 1 / (::std::numeric_limits<CRCType>::digits >= CRCWidth ? 1 : 0) };
#endif

        const unsigned char* current = reinterpret_cast<const unsigned char*>(data);

        // Slightly different implementations based on the parameters. The current implementations try to eliminate as much
        // computation from the inner loop (looping over each bit) as possible.
        if (parameters.reflectInput)
        {
            CRCType polynomial = CRC::Reflect(parameters.polynomial, CRCWidth);
            while (size--)
            {
                remainder = static_cast<CRCType>(remainder ^ *current++);

                // An optimizing compiler might choose to unroll this loop.
                for (crcpp_size i = 0; i < CHAR_BIT; ++i)
                {
#ifdef CRCPP_BRANCHLESS
                    // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                    // if (remainder & 1)
                    //     remainder = (remainder >> 1) ^ polynomial;
                    // else
                    //     remainder >>= 1;
                    remainder = static_cast<CRCType>((remainder >> 1) ^ ((remainder & 1) * polynomial));
#else
                    remainder = static_cast<CRCType>((remainder & 1) ? ((remainder >> 1) ^ polynomial) : (remainder >> 1));
#endif
                }
            }
        }
        else if (CRCWidth >= CHAR_BIT)
        {
            static crcpp_constexpr CRCType CRC_WIDTH_MINUS_ONE(CRCWidth - CRCType(1));
#ifndef CRCPP_BRANCHLESS
            static crcpp_constexpr CRCType CRC_HIGHEST_BIT_MASK(CRCType(1) << CRC_WIDTH_MINUS_ONE);
#endif
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CRCWidth >= CHAR_BIT) ? static_cast<CRCType>(CRCWidth - CHAR_BIT) : 0);

            while (size--)
            {
                remainder = static_cast<CRCType>(remainder ^ (static_cast<CRCType>(*current++) << SHIFT));

                // An optimizing compiler might choose to unroll this loop.
                for (crcpp_size i = 0; i < CHAR_BIT; ++i)
                {
#ifdef CRCPP_BRANCHLESS
                    // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                    // if (remainder & CRC_HIGHEST_BIT_MASK)
                    //     remainder = (remainder << 1) ^ parameters.polynomial;
                    // else
                    //     remainder <<= 1;
                    remainder = static_cast<CRCType>((remainder << 1) ^ (((remainder >> CRC_WIDTH_MINUS_ONE) & 1) * parameters.polynomial));
#else
                    remainder = static_cast<CRCType>((remainder & CRC_HIGHEST_BIT_MASK) ? ((remainder << 1) ^ parameters.polynomial) : (remainder << 1));
#endif
                }
            }
        }
        else
        {
            static crcpp_constexpr CRCType CHAR_BIT_MINUS_ONE(CHAR_BIT - 1);
#ifndef CRCPP_BRANCHLESS
            static crcpp_constexpr CRCType CHAR_BIT_HIGHEST_BIT_MASK(CRCType(1) << CHAR_BIT_MINUS_ONE);
#endif
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CHAR_BIT >= CRCWidth) ? static_cast<CRCType>(CHAR_BIT - CRCWidth) : 0);

            CRCType polynomial = static_cast<CRCType>(parameters.polynomial << SHIFT);
            remainder = static_cast<CRCType>(remainder << SHIFT);

            while (size--)
            {
                remainder = static_cast<CRCType>(remainder ^ *current++);

                // An optimizing compiler might choose to unroll this loop.
                for (crcpp_size i = 0; i < CHAR_BIT; ++i)
                {
#ifdef CRCPP_BRANCHLESS
                    // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                    // if (remainder & CHAR_BIT_HIGHEST_BIT_MASK)
                    //     remainder = (remainder << 1) ^ polynomial;
                    // else
                    //     remainder <<= 1;
                    remainder = static_cast<CRCType>((remainder << 1) ^ (((remainder >> CHAR_BIT_MINUS_ONE) & 1) * polynomial));
#else
                    remainder = static_cast<CRCType>((remainder & CHAR_BIT_HIGHEST_BIT_MASK) ? ((remainder << 1) ^ polynomial) : (remainder << 1));
#endif
                }
            }

            remainder = static_cast<CRCType>(remainder >> SHIFT);
        }

        return remainder;
    }

    /**
        @brief Computes a CRC remainder using lookup table.
        @param[in] data Data over which the remainder will be computed
        @param[in] size Size of the data, in bytes
        @param[in] lookupTable CRC lookup table
        @param[in] remainder Running CRC remainder. Can be an initial value or the result of a previous CRC remainder calculation.
        @tparam CRCType Integer type for storing the CRC result
        @tparam CRCWidth Number of bits in the CRC
        @return CRC remainder
    */
    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateRemainder(const void* data, crcpp_size size, const Table<CRCType, CRCWidth>& lookupTable, CRCType remainder)
    {
        const unsigned char* current = reinterpret_cast<const unsigned char*>(data);

        if (lookupTable.GetParameters().reflectInput)
        {
            while (size--)
            {
#if defined(WIN32) || defined(_WIN32) || defined(WINCE)
                // Disable warning about data loss when doing (remainder >> CHAR_BIT) when
                // remainder is one byte long. The algorithm is still correct in this case,
                // though it's possible that one additional machine instruction will be executed.
#   pragma warning (push)
#   pragma warning (disable : 4333)
#endif
                remainder = static_cast<CRCType>((remainder >> CHAR_BIT) ^ lookupTable[static_cast<unsigned char>(remainder ^ *current++)]);
#if defined(WIN32) || defined(_WIN32) || defined(WINCE)
#   pragma warning (pop)
#endif
            }
        }
        else if (CRCWidth >= CHAR_BIT)
        {
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CRCWidth >= CHAR_BIT) ? static_cast<CRCType>(CRCWidth - CHAR_BIT) : 0);

            while (size--)
            {
                remainder = static_cast<CRCType>((remainder << CHAR_BIT) ^ lookupTable[static_cast<unsigned char>((remainder >> SHIFT) ^ *current++)]);
            }
        }
        else
        {
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CHAR_BIT >= CRCWidth) ? static_cast<CRCType>(CHAR_BIT - CRCWidth) : 0);

            remainder = static_cast<CRCType>(remainder << SHIFT);

            while (size--)
            {
                // Note: no need to mask here since remainder is guaranteed to fit in a single byte.
                remainder = lookupTable[static_cast<unsigned char>(remainder ^ *current++)];
            }

            remainder = static_cast<CRCType>(remainder >> SHIFT);
        }

        return remainder;
    }

    template <typename CRCType, crcpp_uint16 CRCWidth>
    __forceinline CRCType CRC::CalculateRemainderBits(unsigned char byte, crcpp_size numBits, const Parameters<CRCType, CRCWidth>& parameters, CRCType remainder)
    {
        // Slightly different implementations based on the parameters. The current implementations try to eliminate as much
        // computation from the inner loop (looping over each bit) as possible.
        if (parameters.reflectInput)
        {
            CRCType polynomial = CRC::Reflect(parameters.polynomial, CRCWidth);
            remainder = static_cast<CRCType>(remainder ^ byte);

            // An optimizing compiler might choose to unroll this loop.
            for (crcpp_size i = 0; i < numBits; ++i)
            {
#ifdef CRCPP_BRANCHLESS
                // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                // if (remainder & 1)
                //     remainder = (remainder >> 1) ^ polynomial;
                // else
                //     remainder >>= 1;
                remainder = static_cast<CRCType>((remainder >> 1) ^ ((remainder & 1) * polynomial));
#else
                remainder = static_cast<CRCType>((remainder & 1) ? ((remainder >> 1) ^ polynomial) : (remainder >> 1));
#endif
            }
        }
        else if (CRCWidth >= CHAR_BIT)
        {
            static crcpp_constexpr CRCType CRC_WIDTH_MINUS_ONE(CRCWidth - CRCType(1));
#ifndef CRCPP_BRANCHLESS
            static crcpp_constexpr CRCType CRC_HIGHEST_BIT_MASK(CRCType(1) << CRC_WIDTH_MINUS_ONE);
#endif
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CRCWidth >= CHAR_BIT) ? static_cast<CRCType>(CRCWidth - CHAR_BIT) : 0);

            remainder = static_cast<CRCType>(remainder ^ (static_cast<CRCType>(byte) << SHIFT));

            // An optimizing compiler might choose to unroll this loop.
            for (crcpp_size i = 0; i < numBits; ++i)
            {
#ifdef CRCPP_BRANCHLESS
                // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                // if (remainder & CRC_HIGHEST_BIT_MASK)
                //     remainder = (remainder << 1) ^ parameters.polynomial;
                // else
                //     remainder <<= 1;
                remainder = static_cast<CRCType>((remainder << 1) ^ (((remainder >> CRC_WIDTH_MINUS_ONE) & 1) * parameters.polynomial));
#else
                remainder = static_cast<CRCType>((remainder & CRC_HIGHEST_BIT_MASK) ? ((remainder << 1) ^ parameters.polynomial) : (remainder << 1));
#endif
            }
        }
        else
        {
            static crcpp_constexpr CRCType CHAR_BIT_MINUS_ONE(CHAR_BIT - 1);
#ifndef CRCPP_BRANCHLESS
            static crcpp_constexpr CRCType CHAR_BIT_HIGHEST_BIT_MASK(CRCType(1) << CHAR_BIT_MINUS_ONE);
#endif
            // The conditional expression is used to avoid a -Wshift-count-overflow warning.
            static crcpp_constexpr CRCType SHIFT((CHAR_BIT >= CRCWidth) ? static_cast<CRCType>(CHAR_BIT - CRCWidth) : 0);

            CRCType polynomial = static_cast<CRCType>(parameters.polynomial << SHIFT);
            remainder = static_cast<CRCType>((remainder << SHIFT) ^ byte);

            // An optimizing compiler might choose to unroll this loop.
            for (crcpp_size i = 0; i < numBits; ++i)
            {
#ifdef CRCPP_BRANCHLESS
                // Clever way to avoid a branch at the expense of a multiplication. This code is equivalent to the following:
                // if (remainder & CHAR_BIT_HIGHEST_BIT_MASK)
                //     remainder = (remainder << 1) ^ polynomial;
                // else
                //     remainder <<= 1;
                remainder = static_cast<CRCType>((remainder << 1) ^ (((remainder >> CHAR_BIT_MINUS_ONE) & 1) * polynomial));
#else
                remainder = static_cast<CRCType>((remainder & CHAR_BIT_HIGHEST_BIT_MASK) ? ((remainder << 1) ^ polynomial) : (remainder << 1));
#endif
            }

            remainder = static_cast<CRCType>(remainder >> SHIFT);
        }

        return remainder;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-4 ITU.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-4 ITU has the following parameters and check value:
            - polynomial     = 0x3
            - initial value  = 0x0
            - final XOR      = 0x0
            - reflect input  = true
            - reflect output = true
            - check value    = 0x7
        @return CRC-4 ITU parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 4>& CRC::CRC_4_ITU()
    {
        static const Parameters<crcpp_uint8, 4> parameters = { 0x3, 0x0, 0x0, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-5 EPC.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-5 EPC has the following parameters and check value:
            - polynomial     = 0x09
            - initial value  = 0x09
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0x00
        @return CRC-5 EPC parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 5>& CRC::CRC_5_EPC()
    {
        static const Parameters<crcpp_uint8, 5> parameters = { 0x09, 0x09, 0x00, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-5 ITU.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-5 ITU has the following parameters and check value:
            - polynomial     = 0x15
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = true
            - reflect output = true
            - check value    = 0x07
        @return CRC-5 ITU parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 5>& CRC::CRC_5_ITU()
    {
        static const Parameters<crcpp_uint8, 5> parameters = { 0x15, 0x00, 0x00, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-5 USB.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-5 USB has the following parameters and check value:
            - polynomial     = 0x05
            - initial value  = 0x1F
            - final XOR      = 0x1F
            - reflect input  = true
            - reflect output = true
            - check value    = 0x19
        @return CRC-5 USB parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 5>& CRC::CRC_5_USB()
    {
        static const Parameters<crcpp_uint8, 5> parameters = { 0x05, 0x1F, 0x1F, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-6 CDMA2000-A.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-6 CDMA2000-A has the following parameters and check value:
            - polynomial     = 0x27
            - initial value  = 0x3F
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0x0D
        @return CRC-6 CDMA2000-A parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 6>& CRC::CRC_6_CDMA2000A()
    {
        static const Parameters<crcpp_uint8, 6> parameters = { 0x27, 0x3F, 0x00, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-6 CDMA2000-B.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-6 CDMA2000-A has the following parameters and check value:
            - polynomial     = 0x07
            - initial value  = 0x3F
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0x3B
        @return CRC-6 CDMA2000-B parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 6>& CRC::CRC_6_CDMA2000B()
    {
        static const Parameters<crcpp_uint8, 6> parameters = { 0x07, 0x3F, 0x00, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-6 ITU.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-6 ITU has the following parameters and check value:
            - polynomial     = 0x03
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = true
            - reflect output = true
            - check value    = 0x06
        @return CRC-6 ITU parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 6>& CRC::CRC_6_ITU()
    {
        static const Parameters<crcpp_uint8, 6> parameters = { 0x03, 0x00, 0x00, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-6 NR.
        @note The parameters are static and are delayed-constructed to reduce memory
       footprint.
        @note CRC-6 NR has the following parameters and check value:
            - polynomial     = 0x21
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0x15
        @return CRC-6 NR parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 6>& CRC::CRC_6_NR()
    {
        static const Parameters<crcpp_uint8, 6> parameters = { 0x21, 0x00, 0x00, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-7 JEDEC.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-7 JEDEC has the following parameters and check value:
            - polynomial     = 0x09
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0x75
        @return CRC-7 JEDEC parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 7>& CRC::CRC_7()
    {
        static const Parameters<crcpp_uint8, 7> parameters = { 0x09, 0x00, 0x00, false, false };
        return parameters;
    }
#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

    /**
        @brief Returns a set of parameters for CRC-8 SMBus.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-8 SMBus has the following parameters and check value:
            - polynomial     = 0x07
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0xF4
        @return CRC-8 SMBus parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 8>& CRC::CRC_8()
    {
        static const Parameters<crcpp_uint8, 8> parameters = { 0x07, 0x00, 0x00, false, false };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-8 EBU (aka CRC-8 AES).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-8 EBU has the following parameters and check value:
            - polynomial     = 0x1D
            - initial value  = 0xFF
            - final XOR      = 0x00
            - reflect input  = true
            - reflect output = true
            - check value    = 0x97
        @return CRC-8 EBU parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 8>& CRC::CRC_8_EBU()
    {
        static const Parameters<crcpp_uint8, 8> parameters = { 0x1D, 0xFF, 0x00, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-8 MAXIM (aka CRC-8 DOW-CRC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-8 MAXIM has the following parameters and check value:
            - polynomial     = 0x31
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = true
            - reflect output = true
            - check value    = 0xA1
        @return CRC-8 MAXIM parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 8>& CRC::CRC_8_MAXIM()
    {
        static const Parameters<crcpp_uint8, 8> parameters = { 0x31, 0x00, 0x00, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-8 WCDMA.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-8 WCDMA has the following parameters and check value:
            - polynomial     = 0x9B
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = true
            - reflect output = true
            - check value    = 0x25
        @return CRC-8 WCDMA parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 8>& CRC::CRC_8_WCDMA()
    {
        static const Parameters<crcpp_uint8, 8> parameters = { 0x9B, 0x00, 0x00, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-8 LTE.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-8 LTE has the following parameters and check value:
            - polynomial     = 0x9B
            - initial value  = 0x00
            - final XOR      = 0x00
            - reflect input  = false
            - reflect output = false
            - check value    = 0xEA
        @return CRC-8 LTE parameters
    */
    inline const CRC::Parameters<crcpp_uint8, 8>& CRC::CRC_8_LTE()
    {
        static const Parameters<crcpp_uint8, 8> parameters = { 0x9B, 0x00, 0x00, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-10 ITU.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-10 ITU has the following parameters and check value:
            - polynomial     = 0x233
            - initial value  = 0x000
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x199
        @return CRC-10 ITU parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 10>& CRC::CRC_10()
    {
        static const Parameters<crcpp_uint16, 10> parameters = { 0x233, 0x000, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-10 CDMA2000.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-10 CDMA2000 has the following parameters and check value:
            - polynomial     = 0x3D9
            - initial value  = 0x3FF
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x233
        @return CRC-10 CDMA2000 parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 10>& CRC::CRC_10_CDMA2000()
    {
        static const Parameters<crcpp_uint16, 10> parameters = { 0x3D9, 0x3FF, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-11 FlexRay.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-11 FlexRay has the following parameters and check value:
            - polynomial     = 0x385
            - initial value  = 0x01A
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x5A3
        @return CRC-11 FlexRay parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 11>& CRC::CRC_11()
    {
        static const Parameters<crcpp_uint16, 11> parameters = { 0x385, 0x01A, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-11 NR.
        @note The parameters are static and are delayed-constructed to reduce memory
       footprint.
        @note CRC-11 NR has the following parameters and check value:
            - polynomial     = 0x621
            - initial value  = 0x000
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x5CA
        @return CRC-11 NR parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 11>& CRC::CRC_11_NR()
    {
        static const Parameters<crcpp_uint16, 11> parameters = { 0x621, 0x000, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-12 CDMA2000.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-12 CDMA2000 has the following parameters and check value:
            - polynomial     = 0xF13
            - initial value  = 0xFFF
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xD4D
        @return CRC-12 CDMA2000 parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 12>& CRC::CRC_12_CDMA2000()
    {
        static const Parameters<crcpp_uint16, 12> parameters = { 0xF13, 0xFFF, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-12 DECT (aka CRC-12 X-CRC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-12 DECT has the following parameters and check value:
            - polynomial     = 0x80F
            - initial value  = 0x000
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xF5B
        @return CRC-12 DECT parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 12>& CRC::CRC_12_DECT()
    {
        static const Parameters<crcpp_uint16, 12> parameters = { 0x80F, 0x000, 0x000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-12 UMTS (aka CRC-12 3GPP).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-12 UMTS has the following parameters and check value:
            - polynomial     = 0x80F
            - initial value  = 0x000
            - final XOR      = 0x000
            - reflect input  = false
            - reflect output = true
            - check value    = 0xDAF
        @return CRC-12 UMTS parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 12>& CRC::CRC_12_UMTS()
    {
        static const Parameters<crcpp_uint16, 12> parameters = { 0x80F, 0x000, 0x000, false, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-13 BBC.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-13 BBC has the following parameters and check value:
            - polynomial     = 0x1CF5
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x04FA
        @return CRC-13 BBC parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 13>& CRC::CRC_13_BBC()
    {
        static const Parameters<crcpp_uint16, 13> parameters = { 0x1CF5, 0x0000, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-15 CAN.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-15 CAN has the following parameters and check value:
            - polynomial     = 0x4599
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x059E
        @return CRC-15 CAN parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 15>& CRC::CRC_15()
    {
        static const Parameters<crcpp_uint16, 15> parameters = { 0x4599, 0x0000, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-15 MPT1327.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-15 MPT1327 has the following parameters and check value:
            - polynomial     = 0x6815
            - initial value  = 0x0000
            - final XOR      = 0x0001
            - reflect input  = false
            - reflect output = false
            - check value    = 0x2566
        @return CRC-15 MPT1327 parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 15>& CRC::CRC_15_MPT1327()
    {
        static const Parameters<crcpp_uint16, 15> parameters = { 0x6815, 0x0000, 0x0001, false, false };
        return parameters;
    }
#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

    /**
        @brief Returns a set of parameters for CRC-16 ARC (aka CRC-16 IBM, CRC-16 LHA).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 ARC has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = true
            - reflect output = true
            - check value    = 0xBB3D
        @return CRC-16 ARC parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_ARC()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0x0000, 0x0000, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 BUYPASS (aka CRC-16 VERIFONE, CRC-16 UMTS).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 BUYPASS has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xFEE8
        @return CRC-16 BUYPASS parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_BUYPASS()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0x0000, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 CCITT FALSE.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 CCITT FALSE has the following parameters and check value:
            - polynomial     = 0x1021
            - initial value  = 0xFFFF
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x29B1
        @return CRC-16 CCITT FALSE parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_CCITTFALSE()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x1021, 0xFFFF, 0x0000, false, false };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-16 CDMA2000.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 CDMA2000 has the following parameters and check value:
            - polynomial     = 0xC867
            - initial value  = 0xFFFF
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x4C06
        @return CRC-16 CDMA2000 parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_CDMA2000()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0xC867, 0xFFFF, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 CMS.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 CMS has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0xFFFF
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xAEE7
        @return CRC-16 CMS parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_CMS()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0xFFFF, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 DECT-R (aka CRC-16 R-CRC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 DECT-R has the following parameters and check value:
            - polynomial     = 0x0589
            - initial value  = 0x0000
            - final XOR      = 0x0001
            - reflect input  = false
            - reflect output = false
            - check value    = 0x007E
        @return CRC-16 DECT-R parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_DECTR()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x0589, 0x0000, 0x0001, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 DECT-X (aka CRC-16 X-CRC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 DECT-X has the following parameters and check value:
            - polynomial     = 0x0589
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x007F
        @return CRC-16 DECT-X parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_DECTX()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x0589, 0x0000, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 DNP.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 DNP has the following parameters and check value:
            - polynomial     = 0x3D65
            - initial value  = 0x0000
            - final XOR      = 0xFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0xEA82
        @return CRC-16 DNP parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_DNP()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x3D65, 0x0000, 0xFFFF, true, true };
        return parameters;
    }
#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

    /**
        @brief Returns a set of parameters for CRC-16 GENIBUS (aka CRC-16 EPC, CRC-16 I-CODE, CRC-16 DARC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 GENIBUS has the following parameters and check value:
            - polynomial     = 0x1021
            - initial value  = 0xFFFF
            - final XOR      = 0xFFFF
            - reflect input  = false
            - reflect output = false
            - check value    = 0xD64E
        @return CRC-16 GENIBUS parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_GENIBUS()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x1021, 0xFFFF, 0xFFFF, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 KERMIT (aka CRC-16 CCITT, CRC-16 CCITT-TRUE).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 KERMIT has the following parameters and check value:
            - polynomial     = 0x1021
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = true
            - reflect output = true
            - check value    = 0x2189
        @return CRC-16 KERMIT parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_KERMIT()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x1021, 0x0000, 0x0000, true, true };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-16 MAXIM.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 MAXIM has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0x0000
            - final XOR      = 0xFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0x44C2
        @return CRC-16 MAXIM parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_MAXIM()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0x0000, 0xFFFF, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 MODBUS.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 MODBUS has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0xFFFF
            - final XOR      = 0x0000
            - reflect input  = true
            - reflect output = true
            - check value    = 0x4B37
        @return CRC-16 MODBUS parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_MODBUS()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0xFFFF, 0x0000, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 T10-DIF.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 T10-DIF has the following parameters and check value:
            - polynomial     = 0x8BB7
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xD0DB
        @return CRC-16 T10-DIF parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_T10DIF()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8BB7, 0x0000, 0x0000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 USB.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 USB has the following parameters and check value:
            - polynomial     = 0x8005
            - initial value  = 0xFFFF
            - final XOR      = 0xFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0xB4C8
        @return CRC-16 USB parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_USB()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x8005, 0xFFFF, 0xFFFF, true, true };
        return parameters;
    }

#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

    /**
        @brief Returns a set of parameters for CRC-16 X-25 (aka CRC-16 IBM-SDLC, CRC-16 ISO-HDLC, CRC-16 B).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 X-25 has the following parameters and check value:
            - polynomial     = 0x1021
            - initial value  = 0xFFFF
            - final XOR      = 0xFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0x906E
        @return CRC-16 X-25 parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_X25()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x1021, 0xFFFF, 0xFFFF, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-16 XMODEM (aka CRC-16 ZMODEM, CRC-16 ACORN, CRC-16 LTE).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-16 XMODEM has the following parameters and check value:
            - polynomial     = 0x1021
            - initial value  = 0x0000
            - final XOR      = 0x0000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x31C3
        @return CRC-16 XMODEM parameters
    */
    inline const CRC::Parameters<crcpp_uint16, 16>& CRC::CRC_16_XMODEM()
    {
        static const Parameters<crcpp_uint16, 16> parameters = { 0x1021, 0x0000, 0x0000, false, false };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-17 CAN.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-17 CAN has the following parameters and check value:
            - polynomial     = 0x1685B
            - initial value  = 0x00000
            - final XOR      = 0x00000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x04F03
        @return CRC-17 CAN parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 17>& CRC::CRC_17_CAN()
    {
        static const Parameters<crcpp_uint32, 17> parameters = { 0x1685B, 0x00000, 0x00000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-21 CAN.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-21 CAN has the following parameters and check value:
            - polynomial     = 0x102899
            - initial value  = 0x000000
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x0ED841
        @return CRC-21 CAN parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 21>& CRC::CRC_21_CAN()
    {
        static const Parameters<crcpp_uint32, 21> parameters = { 0x102899, 0x000000, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 OPENPGP.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-24 OPENPGP has the following parameters and check value:
            - polynomial     = 0x864CFB
            - initial value  = 0xB704CE
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x21CF02
        @return CRC-24 OPENPGP parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0x864CFB, 0xB704CE, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 FlexRay-A.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-24 FlexRay-A has the following parameters and check value:
            - polynomial     = 0x5D6DCB
            - initial value  = 0xFEDCBA
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x7979BD
        @return CRC-24 FlexRay-A parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24_FLEXRAYA()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0x5D6DCB, 0xFEDCBA, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 FlexRay-B.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-24 FlexRay-B has the following parameters and check value:
            - polynomial     = 0x5D6DCB
            - initial value  = 0xABCDEF
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x1F23B8
        @return CRC-24 FlexRay-B parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24_FLEXRAYB()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0x5D6DCB, 0xABCDEF, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 LTE-A/NR-A.
        @note The parameters are static and are delayed-constructed to reduce memory
       footprint.
        @note CRC-24 LTE-A has the following parameters and check value:
            - polynomial     = 0x864CFB
            - initial value  = 0x000000
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xCDE703
        @return CRC-24 LTE-A parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24_LTEA()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0x864CFB, 0x000000, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 LTE-B/NR-B.
        @note The parameters are static and are delayed-constructed to reduce memory
       footprint.
        @note CRC-24 LTE-B has the following parameters and check value:
            - polynomial     = 0x800063
            - initial value  = 0x000000
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x23EF52
        @return CRC-24 LTE-B parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24_LTEB()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0x800063, 0x000000, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-24 NR-C.
        @note The parameters are static and are delayed-constructed to reduce memory
       footprint.
        @note CRC-24 NR-C has the following parameters and check value:
            - polynomial     = 0xB2B117
            - initial value  = 0x000000
            - final XOR      = 0x000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0xF48279
        @return CRC-24 NR-C parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 24>& CRC::CRC_24_NRC()
    {
        static const Parameters<crcpp_uint32, 24> parameters = { 0xB2B117, 0x000000, 0x000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-30 CDMA.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-30 CDMA has the following parameters and check value:
            - polynomial     = 0x2030B9C7
            - initial value  = 0x3FFFFFFF
            - final XOR      = 0x00000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x3B3CB540
        @return CRC-30 CDMA parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 30>& CRC::CRC_30()
    {
        static const Parameters<crcpp_uint32, 30> parameters = { 0x2030B9C7, 0x3FFFFFFF, 0x00000000, false, false };
        return parameters;
    }
#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

    /**
        @brief Returns a set of parameters for CRC-32 (aka CRC-32 ADCCP, CRC-32 PKZip).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 has the following parameters and check value:
            - polynomial     = 0x04C11DB7
            - initial value  = 0xFFFFFFFF
            - final XOR      = 0xFFFFFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0xCBF43926
        @return CRC-32 parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x04C11DB7, 0xFFFFFFFF, 0xFFFFFFFF, true, true };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-32 BZIP2 (aka CRC-32 AAL5, CRC-32 DECT-B, CRC-32 B-CRC).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 BZIP2 has the following parameters and check value:
            - polynomial     = 0x04C11DB7
            - initial value  = 0xFFFFFFFF
            - final XOR      = 0xFFFFFFFF
            - reflect input  = false
            - reflect output = false
            - check value    = 0xFC891918
        @return CRC-32 BZIP2 parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32_BZIP2()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x04C11DB7, 0xFFFFFFFF, 0xFFFFFFFF, false, false };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-32 C (aka CRC-32 ISCSI, CRC-32 Castagnoli, CRC-32 Interlaken).
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 C has the following parameters and check value:
            - polynomial     = 0x1EDC6F41
            - initial value  = 0xFFFFFFFF
            - final XOR      = 0xFFFFFFFF
            - reflect input  = true
            - reflect output = true
            - check value    = 0xE3069283
        @return CRC-32 C parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32_C()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x1EDC6F41, 0xFFFFFFFF, 0xFFFFFFFF, true, true };
        return parameters;
    }
#endif

    /**
        @brief Returns a set of parameters for CRC-32 MPEG-2.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 MPEG-2 has the following parameters and check value:
            - polynomial     = 0x04C11DB7
            - initial value  = 0xFFFFFFFF
            - final XOR      = 0x00000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x0376E6E7
        @return CRC-32 MPEG-2 parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32_MPEG2()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x04C11DB7, 0xFFFFFFFF, 0x00000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-32 POSIX.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 POSIX has the following parameters and check value:
            - polynomial     = 0x04C11DB7
            - initial value  = 0x00000000
            - final XOR      = 0xFFFFFFFF
            - reflect input  = false
            - reflect output = false
            - check value    = 0x765E7680
        @return CRC-32 POSIX parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32_POSIX()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x04C11DB7, 0x00000000, 0xFFFFFFFF, false, false };
        return parameters;
    }

#ifdef CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS
    /**
        @brief Returns a set of parameters for CRC-32 Q.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-32 Q has the following parameters and check value:
            - polynomial     = 0x814141AB
            - initial value  = 0x00000000
            - final XOR      = 0x00000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x3010BF7F
        @return CRC-32 Q parameters
    */
    inline const CRC::Parameters<crcpp_uint32, 32>& CRC::CRC_32_Q()
    {
        static const Parameters<crcpp_uint32, 32> parameters = { 0x814141AB, 0x00000000, 0x00000000, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-40 GSM.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-40 GSM has the following parameters and check value:
            - polynomial     = 0x0004820009
            - initial value  = 0x0000000000
            - final XOR      = 0xFFFFFFFFFF
            - reflect input  = false
            - reflect output = false
            - check value    = 0xD4164FC646
        @return CRC-40 GSM parameters
    */
    inline const CRC::Parameters<crcpp_uint64, 40>& CRC::CRC_40_GSM()
    {
        static const Parameters<crcpp_uint64, 40> parameters = { 0x0004820009, 0x0000000000, 0xFFFFFFFFFF, false, false };
        return parameters;
    }

    /**
        @brief Returns a set of parameters for CRC-64 ECMA.
        @note The parameters are static and are delayed-constructed to reduce memory footprint.
        @note CRC-64 ECMA has the following parameters and check value:
            - polynomial     = 0x42F0E1EBA9EA3693
            - initial value  = 0x0000000000000000
            - final XOR      = 0x0000000000000000
            - reflect input  = false
            - reflect output = false
            - check value    = 0x6C40DF5F0B497347
        @return CRC-64 ECMA parameters
    */
    inline const CRC::Parameters<crcpp_uint64, 64>& CRC::CRC_64()
    {
        static const Parameters<crcpp_uint64, 64> parameters = { 0x42F0E1EBA9EA3693, 0x0000000000000000, 0x0000000000000000, false, false };
        return parameters;
    }
#endif // CRCPP_INCLUDE_ESOTERIC_CRC_DEFINITIONS

#ifdef CRCPP_USE_NAMESPACE
}
#endif

#endif // CRCPP_CRC_H_ 
```

`Baka/CheckBigBool.h`:

```h
#pragma once

#include "NtApi.h" 
#include "ApiWrapper.h"



namespace BlackListPool
{

	/*
	Just wallking in BigPool

	HyperHide:
	PoolTag: HyHd

	*/
	__forceinline bool IsHyperHideDebuggingProcess()
	{
		/*
		HyperHide don't clean big pool then he was unload ^_^ and under debugging NonPagedUsed = 384
		*/

		bool bDetect = FALSE;
		DWORD Lenght = NULL;
		PVOID bufferPoolInformathion = NULL;
		NTSTATUS status = STATUS_UNSUCCESSFUL;

		auto NtQuerySystemInformation = (t_NtQuerySystemInformation)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtQuerySystemInformation");
		if (!NtQuerySystemInformation)
		{
			return FALSE;
		}
		status = NtQuerySystemInformation(SystemPoolTagInformation, bufferPoolInformathion, Lenght, &Lenght);

		while (status == STATUS_INFO_LENGTH_MISMATCH) {
			if (bufferPoolInformathion != NULL)
				VirtualFree(bufferPoolInformathion, 0, MEM_RELEASE);

			bufferPoolInformathion = VirtualAlloc(NULL, Lenght, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			status = NtQuerySystemInformation(SystemPoolTagInformation, bufferPoolInformathion, Lenght, &Lenght);
		}

		if (!NT_SUCCESS(status)) {
			if (bufferPoolInformathion != NULL)
				VirtualFree(bufferPoolInformathion, 0, MEM_RELEASE);
			return FALSE;
		}


		PSYSTEM_POOLTAG_INFORMATION sysPoolTagInfo = (PSYSTEM_POOLTAG_INFORMATION)bufferPoolInformathion;
		PSYSTEM_POOLTAG sysPoolTag = (PSYSTEM_POOLTAG)&sysPoolTagInfo->TagInfo->Tag;
		for (ULONG i = 0; i < sysPoolTagInfo->Count; i++)
		{


			if (NoCRT::string::stricmp((char*)sysPoolTag->Tag, "Hyhd") == 0)
			{
				if (sysPoolTag->PagedAllocs || sysPoolTag->NonPagedAllocs)
				{
					if (sysPoolTag->NonPagedUsed > 10 || sysPoolTag->PagedUsed > 10)//check for detect only for debugging 
					{

						bDetect = TRUE;
					}
				}
			}


			sysPoolTag++;
		}

		VirtualFree(bufferPoolInformathion, 0, MEM_RELEASE);



		return bDetect;
	}
}
```

`Baka/NoCRT.h`:

```h
#pragma once
#include "Struct.h"




namespace NoCRT
{
    namespace mem
    {

        __forceinline  int toupper(int c)
        {
            if (c >= 'a' && c <= 'z') return c - 'a' + 'A';
            return c;
        }

        __forceinline  void* memcpy(void* dest, const void* src, unsigned __int64 count)
        {
            char* char_dest = (char*)dest;
            char* char_src = (char*)src;
            if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
            {
                while (count > 0)
                {
                    *char_dest = *char_src;
                    char_dest++;
                    char_src++;
                    count--;
                }
            }
            else
            {
                char_dest = (char*)dest + count - 1;
                char_src = (char*)src + count - 1;
                while (count > 0)
                {
                    *char_dest = *char_src;
                    char_dest--;
                    char_src--;
                    count--;
                }
            }
            return dest;
        }
        __forceinline  void* memset(void* src, int val, unsigned __int64 count)
        {
            __stosb((unsigned char*)((unsigned long long)(volatile char*)src), val, count);
            return src;
        }
        __forceinline void* memccpy(void* to, const void* from, int c, unsigned __int64 count)
        {
            char t;
            unsigned __int64 i;
            char* dst = (char*)to;
            const char* src = (const char*)from;
            for (i = 0; i < count; i++)
            {
                dst[i] = t = src[i];
                if (t == 0) break;
                if (t == c) return &dst[i + 1];
            }
            return 0;
        }
        __forceinline void* memchr(const void* s, int c, unsigned __int64 n)
        {
            if (n)
            {
                const char* p = (const char*)s;
                do
                {
                    if (*p++ == c) return (void*)(p - 1);
                } while (--n != 0);
            }
            return 0;
        }
        __forceinline  int  memcmp(const void* s1, const void* s2, unsigned __int64 n)
        {
            if (n != 0)
            {
                const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
                do
                {
                    if (*p1++ != *p2++) return (*--p1 - *--p2);
                } while (--n != 0);
            }
            return 0;
        }
        __forceinline int  memicmp(const void* s1, const void* s2, unsigned __int64 n)
        {
            if (n != 0)
            {
                const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
                do
                {
                    if (toupper(*p1) != toupper(*p2)) return (*p1 - *p2);
                    p1++;
                    p2++;
                } while (--n != 0);
            }
            return 0;
        }
        __forceinline  void* memmove(void* dest, const void* src, unsigned __int64 count)
        {
            char* char_dest = (char*)dest;
            char* char_src = (char*)src;
            if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
            {
                while (count > 0)
                {
                    *char_dest = *char_src;
                    char_dest++;
                    char_src++;
                    count--;
                }
            }
            else
            {
                char_dest = (char*)dest + count - 1;
                char_src = (char*)src + count - 1;
                while (count > 0)
                {
                    *char_dest = *char_src;
                    char_dest--;
                    char_src--;
                    count--;
                }
            }
            return dest;
        }

    }
    namespace string
    {
        __forceinline  int toupper(int c)
        {
            if (c >= 'a' && c <= 'z') return c - 'a' + 'A';
            return c;
        }
        __forceinline int tolower(int c)
        {
            if (c >= 'A' && c <= 'Z') return c - 'A' + 'a';
            return c;
        }

        __forceinline char* _cslwr(char* x)
        {
            char* y = x;
            while (*y)
            {
                *y = tolower(*y);
                y++;
            }
            return x;
        }
        __forceinline  char* _csupr(char* x)
        {
            char* y = x;
            while (*y)
            {
                *y = tolower(*y);
                y++;
            }
            return x;
        }

        __forceinline   int strlen(const char* string)
        {
            int cnt = 0;
            if (string)
            {
                for (; *string != 0; ++string) ++cnt;
            }
            return cnt;
        }
        __forceinline  const char* strcpy(char* buffer, const char* string)
        {
            char* ret = buffer;
            while (*string) *buffer++ = *string++;
            *buffer = 0;
            return ret;
        }
        __forceinline   const char* strcpy(char* buffer, const wchar_t* string)
        {
            char* ret = buffer;
            while (*string) *buffer++ = char(*string++);
            *buffer = 0;
            return ret;
        }

        __forceinline  int strcmp(const char* cs, const char* ct)
        {
            if (cs && ct)
            {
                while (*cs == *ct)
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return *cs - *ct;
            }
            return -1;
        }
        __forceinline int stricmp(const char* cs, const char* ct)
        {
            if (cs && ct)
            {
                while (tolower(*cs) == tolower(*ct))
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return tolower(*cs) - tolower(*ct);
            }
            return -1;
        }

        __forceinline int stricmp(UCHAR cs, const char* ct)
        {
            if (ct)
            {
                while (tolower(cs) == tolower(*ct))
                {
                    if (cs == 0 && *ct == 0) return 0;
                    if (cs == 0 || *ct == 0) break;

                    ct++;
                }
                return tolower(cs) - tolower(*ct);
            }
            return -1;
        }










        __forceinline wchar_t* _cslwr(wchar_t* x)
        {
            wchar_t* y = x;
            while (*y)
            {
                *y = towlower(*y);
                y++;
            }
            return x;
        }
        __forceinline  wchar_t* _csupr(wchar_t* x)
        {
            wchar_t* y = x;
            while (*y)
            {
                *y = towupper(*y);
                y++;
            }
            return x;
        }

        __forceinline  int strlen(const wchar_t* string)
        {
            int cnt = 0;
            if (string)
            {
                for (; *string != 0; ++string) ++cnt;
            }
            return cnt;
        }
        __forceinline   const wchar_t* strcpy(wchar_t* buffer, const wchar_t* string)
        {
            wchar_t* ret = buffer;
            while (*string) *buffer++ = *string++;
            *buffer = L'\0';
            return ret;
        }
        const wchar_t* strcpy(wchar_t* buffer, const char* string)
        {
            wchar_t* ret = buffer;
            while (*string) *buffer++ = wchar_t(*string++);
            *buffer = 0;
            return ret;
        }

        __forceinline int strcmp(const wchar_t* cs, const wchar_t* ct)
        {
            if (cs && ct)
            {
                while (*cs == *ct)
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return *cs - *ct;
            }
            return -1;
        }
        __forceinline   int stricmp(const wchar_t* cs, const wchar_t* ct)
        {
            if (cs && ct)
            {
                while (towlower(*cs) == towlower(*ct))
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return towlower(*cs) - towlower(*ct);
            }
            return -1;
        }



        __forceinline  int wtoupper(int c)
        {
            if (c >= L'a' && c <= L'z') return c - L'a' + L'A';
            if (c >= L'à' && c <= L'ÿ') return c - L'à' + L'À';
            if (c == L'¸') return L'¨';
            return c;
        }
        __forceinline  int wtolower(int c)
        {
            if (c >= L'A' && c <= L'Z') return c - L'A' + L'a';
            if (c >= L'À' && c <= L'ß') return c - L'À' + L'à';
            if (c == L'¨') return L'¸';
            return c;
        }

        __forceinline  int towupper(int c)
        {
            if (c >= L'a' && c <= L'z') return c - L'a' + L'A';
            if (c >= L'à' && c <= L'ÿ') return c - L'à' + L'À';
            if (c == L'¸') return L'¨';
            return c;
        }
        int towlower(int c)
        {
            if (c >= L'A' && c <= L'Z') return c - L'A' + L'a';
            if (c >= L'À' && c <= L'ß') return c - L'À' + L'à';
            if (c == L'¨') return L'¸';
            return c;
        }
        __forceinline  int wstrlen(const wchar_t* s)
        {
            int cnt = 0;
            if (!s) return 0;
            for (; *s != 0; ++s) ++cnt;
            return cnt;
        }
        __forceinline   int wstrcmp(const wchar_t* cs, const wchar_t* ct)
        {
            if (cs && ct)
            {
                while (*cs == *ct)
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return *cs - *ct;
            }
            return -1;
        }
        __forceinline int wstricmp(const wchar_t* cs, const wchar_t* ct)
        {
            if (cs && ct)
            {
                while (wtolower(*cs) == wtolower(*ct))
                {
                    if (*cs == 0 && *ct == 0) return 0;
                    if (*cs == 0 || *ct == 0) break;
                    cs++;
                    ct++;
                }
                return wtolower(*cs) - wtolower(*ct);
            }
            return -1;
        }
        wchar_t* wstrstr(const wchar_t* s, const wchar_t* find)
        {
            wchar_t c, sc;
            if ((c = *find++) != 0)
            {
                do
                {
                    do
                    {
                        if ((sc = *s++) == 0)
                            return 0;
                    } while (sc != c);
                } while (wstricmp(s, find) != 0);
                s--;
            }
            return (wchar_t*)s;
        }
        __forceinline  wchar_t* wstrset(wchar_t* szToFill, int szFill)
        {
            wchar_t* t = szToFill;
            while (*szToFill != 0)
            {
                *szToFill = szFill;
                szToFill++;
            }
            return t;
        }
        __forceinline wchar_t* wstrnset(wchar_t* szToFill, int szFill, unsigned __int64 sizeMaxFill)
        {
            wchar_t* t = szToFill;
            int i = 0;
            while (*szToFill != 0 && i < (int)sizeMaxFill)
            {
                *szToFill = szFill;
                szToFill++;
                i++;
            }
            return t;
        }
        __forceinline   wchar_t* wstrrev(wchar_t* s)
        {
            wchar_t a, * b, * e;
            b = e = s;
            while (*e) e++;
            e--;
            while (b < e)
            {
                a = *b;
                *b = *e;
                *e = a;
                b++;
                e--;
            }
            return s;
        }
        __forceinline  int wstrnicmp(const wchar_t* s1, const wchar_t* s2, unsigned __int64 n)
        {
            if (n == 0) return 0;
            do
            {
                if (wtoupper(*s1) != wtoupper(*s2++)) return wtoupper(*(unsigned const char*)s1) - wtoupper(*(unsigned const char*)--s2);
                if (*s1++ == 0) break;
            } while (--n != 0);
            return 0;
        }
        __forceinline  wchar_t* wstrlwr(wchar_t* x)
        {
            wchar_t* y = x;
            while (*y)
            {
                *y = wtolower(*y);
                y++;
            }
            return x;
        }
        __forceinline  wchar_t* wstrchr(const wchar_t* s, wchar_t c)
        {
            wchar_t cc = c;
            const wchar_t* sp = (wchar_t*)0;
            while (*s)
            {
                if (*s == cc) sp = s;
                s++;
            }
            if (cc == 0) sp = s;
            return (wchar_t*)sp;
        }
        __forceinline  wchar_t* wstrtok_s(wchar_t* str, const wchar_t* delim, wchar_t** ctx)
        {
            if (!str) str = *ctx;
            while (*str && wstrchr(delim, *str)) str++;
            if (!*str)
            {
                *ctx = str;
                return 0;
            }
            *ctx = str + 1;
            while (**ctx && !wstrchr(delim, **ctx)) (*ctx)++;
            if (**ctx) *(*ctx)++ = 0;
            return str;
        }
        __forceinline   bool iswdigit(wchar_t c) { return c >= L'0' && c <= L'9'; }
        __forceinline  __int64 wtoi64(const wchar_t* nptr)
        {
            wchar_t* s = (wchar_t*)nptr;
            __int64 acc = 0;
            int neg = 0;
            if (nptr == 0) return 0;
           // while (*s = L' ') s++;
            if (*s == L'-')
            {
                neg = 1;
                s++;
            }
            else if (*s == L'+') s++;
            while (iswdigit(*s))
            {
                acc = 10 * acc + (*s - L'0');
                s++;
            }
            if (neg) acc *= -1;
            return acc;
        }
        __forceinline int wtoi(const wchar_t* nptr)
        {
            wchar_t* s = (wchar_t*)nptr;
            int acc = 0;
            int neg = 0;
            if (nptr == 0) return 0;
           // while (*s = L' ') s++;
            if (*s == L'-')
            {
                neg = 1;
                s++;
            }
            else if (*s == L'+') s++;
            while (iswdigit(*s))
            {
                acc = 10 * acc + (*s - L'0');
                s++;
            }
            if (neg) acc *= -1;
            return acc;
        }
        __forceinline wchar_t* itow(int number, wchar_t* destination, int base)
        {
            int count = 0;
            do
            {
                int digit = number % base;
                destination[count++] = (digit > 9) ? digit - 10 + L'A' : digit + L'0';
            } while ((number /= base) != 0);
            destination[count] = 0;
            int i;
            for (i = 0; i < count / 2; ++i)
            {
                wchar_t symbol = destination[i];
                destination[i] = destination[count - i - 1];
                destination[count - i - 1] = symbol;
            }
            return destination;
        }


        const char* strstr(char const* _Str, char const* _SubStr)
        {
            const char* bp = _SubStr;
            const char* back_pos;
            while (*_Str != 0 && _Str != 0 && _SubStr != 0)
            {
                back_pos = _Str;
                while (tolower(*back_pos++) == tolower(*_SubStr++))
                {
                    if (*_SubStr == 0)
                    {
                        return (char*)(back_pos - strlen(bp));
                    }
                }
                ++_Str;
                _SubStr = bp;
            }
            return 0;
        }





        __forceinline   char* strcatA(char* dest, const char* src)
        {
            if ((dest == 0) || (src == 0))
                return dest;

            while (*dest != 0)
                dest++;

            while (*src != 0) {
                *dest = *src;
                dest++;
                src++;
            }

            *dest = 0;
            return dest;
        }

        __forceinline wchar_t* strcatW(wchar_t* dest, const wchar_t* src)
        {
            if ((dest == 0) || (src == 0))
                return dest;

            while (*dest != 0)
                dest++;

            while (*src != 0) {
                *dest = *src;
                dest++;
                src++;
            }

            *dest = 0;
            return dest;
        }



    }

}
```

`Baka/NtApi.h`:

```h
#pragma once
#include "NOCrt.h"



typedef   NTSTATUS(NTAPI* t_ZwOpenSection)
(
	PHANDLE            SectionHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes
	);





typedef   NTSTATUS(NTAPI* t_ZwMapViewOfSection)
(
	HANDLE          SectionHandle,
	HANDLE          ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR       ZeroBits,
	SIZE_T          CommitSize,
	PLARGE_INTEGER  SectionOffset,
	PSIZE_T         ViewSize,
	SECTION_INHERIT InheritDisposition,
	ULONG           AllocationType,
	ULONG           Win32Protect
	);

typedef   NTSTATUS(NTAPI* t_NtClose)
(
	HANDLE Handle
	);

typedef   NTSTATUS(NTAPI* t_ZwUnmapViewOfSection)
(
	HANDLE ProcessHandle,
	PVOID  BaseAddress
	);



typedef NTSTATUS(NTAPI* t_NtQueryInformationProcess)
(



	IN HANDLE               ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID               ProcessInformation,
	IN ULONG                ProcessInformationLength,
	OUT PULONG              ReturnLength
	);

typedef NTSTATUS(NTAPI* t_NtSetInformationThread)(



	IN HANDLE               ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	IN PVOID                ThreadInformation,
	IN ULONG                ThreadInformationLength);



typedef NTSTATUS(NTAPI* t_NtQuerySystemInformation)
(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID                    SystemInformation,
	ULONG                    SystemInformationLength,
	PULONG                   ReturnLength
	);

typedef NTSTATUS(NTAPI* t_NtQueryInformationThread)
(



	IN HANDLE               ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	OUT PVOID               ThreadInformation,
	IN ULONG                ThreadInformationLength,
	OUT PULONG              ReturnLength OPTIONAL);




typedef  NTSTATUS(NTAPI* t_NtReadVirtualMemory)
(



	IN HANDLE               ProcessHandle,
	IN PVOID                BaseAddress,
	OUT PVOID               Buffer,
	IN ULONG                NumberOfBytesToRead,
	OUT PULONG              NumberOfBytesReaded OPTIONAL);



typedef  NTSTATUS(NTAPI* t_NtAllocateVirtualMemory)(



	IN HANDLE               ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN ULONG                ZeroBits,
	IN OUT PULONG           RegionSize,
	IN ULONG                AllocationType,
	IN ULONG                Protect); 
typedef  NTSTATUS(NTAPI* t_RtlGetVersion)
(
	PRTL_OSVERSIONINFOW lpVersionInformation
	);


typedef  NTSTATUS(NTAPI* t_NtSetInformationProcess)
(



	IN HANDLE               ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	IN PVOID                ProcessInformation,
	IN ULONG                ProcessInformationLength);


```

`Baka/Struct.h`:

```h
#pragma once
#ifndef WIN32_NO_STATUS
#define WIN32_NO_STATUS
#endif
#include <Windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <intrin.h>

#define RTL_MAX_DRIVE_LETTERS 32

#define NT_SUCCESS(Status)              ((NTSTATUS)(Status) >= 0)

#define WINDOWS_NUMBER_XP 6
#define WINDOWS_NUMBER_7 7
#define WINDOWS_NUMBER_8 8
#define WINDOWS_NUMBER_8_1 9
#define WINDOWS_NUMBER_10 10
#define WINDOWS_NUMBER_11 11

#define GDI_HANDLE_BUFFER_SIZE32    34
#define GDI_HANDLE_BUFFER_SIZE64    60

#define NtCurrentProcess        ((HANDLE)(LONG_PTR)-1)
#define NtCurrentThread         ((HANDLE)(LONG_PTR)-2)
#define NtCurrentPeb()          (NtCurrentTeb()->ProcessEnvironmentBlock)
#define NtCurrentProcessId()    (NtCurrentTeb()->ClientId.UniqueProcess)
#define NtCurrentThreadId()     (NtCurrentTeb()->ClientId.UniqueThread)
#define RtlProcessHeap()        (NtCurrentPeb()->ProcessHeap)


#define OBJ_CASE_INSENSITIVE   0x00000040L

#define 	LDR_IS_DATAFILE(handle)   (((ULONG_PTR)(handle)) & (ULONG_PTR)1)

#define 	LDR_DATAFILE_TO_VIEW(x)   ((PVOID)(((ULONG_PTR)(x)) & ~(ULONG_PTR)1))

#define InitializeObjectAttributes(p,n,a,r,s) \
     do { \
         (p)->Length = sizeof(OBJECT_ATTRIBUTES); \
         (p)->RootDirectory = r; \
         (p)->Attributes = a; \
         (p)->ObjectName = n; \
         (p)->SecurityDescriptor = s; \
         (p)->SecurityQualityOfService = NULL; \
     } while (0)


#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif
typedef enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;


typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef enum _THREADINFOCLASS
{
    ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
    ThreadTimes, // q: KERNEL_USER_TIMES
    ThreadPriority, // s: KPRIORITY
    ThreadBasePriority, // s: LONG
    ThreadAffinityMask, // s: KAFFINITY
    ThreadImpersonationToken, // s: HANDLE
    ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress, // q: PVOID
    ThreadZeroTlsCell, // 10
    ThreadPerformanceCount, // q: LARGE_INTEGER
    ThreadAmILastThread, // q: ULONG
    ThreadIdealProcessor, // s: ULONG
    ThreadPriorityBoost, // qs: ULONG
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending, // q: ULONG
    ThreadHideFromDebugger, // s: void
    ThreadBreakOnTermination, // qs: ULONG
    ThreadSwitchLegacyState,
    ThreadIsTerminated, // q: ULONG // 20
    ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority, // qs: IO_PRIORITY_HINT
    ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority, // q: ULONG
    ThreadActualBasePriority,
    ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context, // q: WOW64_CONTEXT
    ThreadGroupInformation, // q: GROUP_AFFINITY // 30
    ThreadUmsInformation, // q: THREAD_UMS_INFORMATION
    ThreadCounterProfiling,
    ThreadIdealProcessorEx, // q: PROCESSOR_NUMBER
    ThreadCpuAccountingInformation, // since WIN8
    ThreadSuspendCount, // since WINBLUE
    ThreadHeterogeneousCpuPolicy, // q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId, // q: GUID
    ThreadNameInformation, // qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation, // q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity, // since THRESHOLD2
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    MaxThreadInfoClass
} THREADINFOCLASS;


typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q
    SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q
    SystemComPlusPackage, // q; s
    SystemNumaAvailableMemory, // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
    SystemEmulationBasicInformation, // q
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s
    SystemObjectSecurityMode, // q // 70
    SystemWatchdogTimerHandler, // s (kernel-mode only)
    SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
    SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q; s (kernel-mode only)
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
    SystemPrefetchPatchInformation, // not implemented
    SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
    SystemNumaProximityNodeInformation, // q
    SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s
    SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
    SystemStoreInformation, // q; s // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
    SystemNativeBasicInformation, // not implemented
    SystemSpare1, // not implemented
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingCallback,
    SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
    SystemThrottleNotificationInformation,
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation,
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
    SystemSpare0,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation,
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation,
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation,
    SystemEdidInformation,
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags,
    SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,
    SystemDmaProtectionInformation, // q: SYSTEM_DMA_PROTECTION_INFORMATION
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation,
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // 180
    SystemSupportedProcessorArchitectures,
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,
    SystemKernelDebuggingAllowed,
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;


typedef enum _PROCESSINFOCLASS
{
    ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters, // q: IO_COUNTERS
    ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes, // q: KERNEL_USER_TIMES
    ProcessBasePriority, // s: KPRIORITY
    ProcessRaisePriority, // s: ULONG
    ProcessDebugPort, // q: HANDLE
    ProcessExceptionPort, // s: HANDLE
    ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize, // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode, // qs: ULONG
    ProcessIoPortHandlers, // (kernel-mode only)
    ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
    ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information,
    ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask, // s: KAFFINITY
    ProcessPriorityBoost, // qs: ULONG
    ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information, // q: ULONG_PTR
    ProcessImageFileName, // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled, // q: ULONG
    ProcessBreakOnTermination, // qs: ULONG
    ProcessDebugObjectHandle, // q: HANDLE // 30
    ProcessDebugFlags, // qs: ULONG
    ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
    ProcessIoPriority, // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags, // qs: ULONG
    ProcessResourceManagement,
    ProcessCookie, // q: ULONG
    ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority, // q: ULONG
    ProcessInstrumentationCallback, // 40
    ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
    ProcessImageFileNameWin32, // q: UNICODE_STRING
    ProcessImageFileMapping, // q: HANDLE (input)
    ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation, // q: USHORT[]
    ProcessTokenVirtualizationEnabled, // s: ULONG
    ProcessConsoleHostProcess, // q: ULONG_PTR
    ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation,
    ProcessHandleCheckingMode,
    ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable, // since WINBLUE
    ProcessCheckStackExtentsMode,
    ProcessCommandLineInformation, // q: UNICODE_STRING // 60
    ProcessProtectionInformation, // q: PS_PROTECTION
    ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation,
    ProcessAllowedCpuSetsInformation,
    ProcessSubsystemProcess,
    ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate, // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose,
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation,
    ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
    ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation,
    ProcessDisableSystemAllowedCpuSets,
    ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
    MaxProcessInfoClass
} PROCESSINFOCLASS;



typedef struct _SYSTEM_POOLTAG
{
    union
    {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    ULONG PagedAllocs;
    ULONG PagedFrees;
    SIZE_T PagedUsed;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedUsed;
}SYSTEM_POOLTAG, * PSYSTEM_POOLTAG;
typedef struct _SYSTEM_POOLTAG_INFORMATION
{
    ULONG Count;
    SYSTEM_POOLTAG TagInfo[ANYSIZE_ARRAY];
}SYSTEM_POOLTAG_INFORMATION, * PSYSTEM_POOLTAG_INFORMATION;

typedef struct _SECTION_CRC
{
    PVOID         virtualAddress;
    DWORD         virtualSize;
    DWORD         resultCRC;
    DWORD         fletcherCRC;
}SECTION_CRC;

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;



typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];


typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, * PCURDIR;

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;


typedef struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        } s;
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    } u;
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PWCHAR Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;
    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD* Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;


typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
    SINGLE_LIST_ENTRY DependencyLink;
    PLDR_DDAG_NODE DependencyNode;
    SINGLE_LIST_ENTRY IncomingDependencyLink;
    PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, * PLDR_DEPENDENCY_RECORD;

typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        } s1;
    } u1;

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        } s2;
    } u2;
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    } u3;
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    PVOID SharedData; // HotpatchInformation
    PVOID* ReadOnlyStaticServerData;

    PVOID AnsiCodePageData; // PCPTABLEINFO
    PVOID OemCodePageData; // PCPTABLEINFO
    PVOID UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps; // PHEAP

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

    SIZE_T MinimumStackCommit;

    PVOID* FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pUnused; // pContextData
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        } s3;
    } u4;
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PVOID TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
} PEB, * PPEB;


typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ReservedFlags5 : 3;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        } s;
    } u;
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
    PVOID Lock;
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    struct _LDRP_LOAD_CONTEXT* LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // Since Windows 10 RS2
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG Length;
    ULONG CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION;


```

`Baka/SyscallHelp.hpp`:

```hpp
#pragma once
#include "NtApi.h"
#include "ApiWrapper.h" 

namespace SyscallStub
{

	/*
	* https://github.com/fengjixuchui/khaleesi/blob/e75a5f117eadaa67db178981745370bae3184ca0/khaleesi/Shared/Helpers.h#L87
	*/
	__forceinline NTSTATUS RemapModule(const  wchar_t* ModuleName, PVOID* ModuleBaseAddress) 
	{
		NTSTATUS status = STATUS_NOT_SUPPORTED;
		HANDLE sectionHandle = nullptr;
		SIZE_T viewSize = NULL;
		UNICODE_STRING usSectionName{};
		OBJECT_ATTRIBUTES objAttrib{};


		wchar_t buffer[MAX_PATH];
		NoCRT::mem::memset(buffer, 0, MAX_PATH);
#ifdef _WIN64
		auto str_KnowDll = L"\\KnownDlls\\";
#else 

		auto str_KnowDll = L"\\KnownDlls32\\";
#endif  

		NoCRT::string::strcatW(buffer, str_KnowDll);

		NoCRT::string::strcatW(buffer, ModuleName);


		usSectionName = ApiWrapper::InitUnicodeString(buffer);


		InitializeObjectAttributes(&objAttrib, &usSectionName, OBJ_CASE_INSENSITIVE, NULL, NULL);

		auto ZwOpenSection = (t_ZwOpenSection)ApiWrapper::GetProcAddress(L"ntdll.dll", "ZwOpenSection");
		auto ZwMapViewOfSection = (t_ZwMapViewOfSection)ApiWrapper::GetProcAddress(L"ntdll.dll", "ZwMapViewOfSection");
		auto NtClose = (t_NtClose)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtClose");

		if (!NtClose || !ZwMapViewOfSection || !ZwOpenSection)
		{
			return FALSE;

		}


		status = ZwOpenSection(&sectionHandle, SECTION_MAP_READ, &objAttrib);

		if (!NT_SUCCESS(status))
		{
			return status;
		}
	
		
		status = ZwMapViewOfSection(sectionHandle, NtCurrentProcess, ModuleBaseAddress, NULL, NULL, nullptr,
				&viewSize, (SECTION_INHERIT)1, NULL, PAGE_READONLY);
			
		
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if (sectionHandle)
		{
			status = NtClose(sectionHandle);
			if (!NT_SUCCESS(status))
			{
				return status;
			}
		}
		return status;
	}

	// Try get  safe syscall number
	__forceinline short GetSyscallNumber(const  wchar_t* nameModule, const char* ApiName)
	{

		int original_syscall = 0;

		PVOID mapped_dll = nullptr;
		RemapModule(nameModule, &mapped_dll);

		auto baseNtDll = ApiWrapper::GetModuleBaseAddress(L"ntdll.dll");
		if (!mapped_dll || !baseNtDll)
		{

			return 0;
		}

		auto originalFunc = ApiWrapper::GetProcAddress((DWORD64)mapped_dll, ApiName);


		auto ZwUnmapViewOfSection = (t_ZwUnmapViewOfSection)ApiWrapper::GetProcAddress(baseNtDll, "ZwUnmapViewOfSection");


// SharpOD(use hook x64 functhion) and ShyllaHide(use wow64 hook) and we can get unsafe syscall
#ifndef _WIN64
		if (!originalFunc)
		{
			originalFunc = ApiWrapper::GetProcAddress(nameModule, ApiName);
		}
	
#endif


		if (!originalFunc) //check for prevent SEH
		{
			//under debugger(x32 only)  return 0 ?????

			ZwUnmapViewOfSection(NtCurrentProcess, mapped_dll);
			return FALSE;
		}
#ifdef _WIN64
		original_syscall = *(short*)(originalFunc + 4);
#else 
		original_syscall = *(short*)(originalFunc + 1);
#endif 


		ZwUnmapViewOfSection(NtCurrentProcess, mapped_dll);
		return original_syscall;

	} 
}

```

`Baka/TestModeCheck.h`:

```h
#pragma once
#include "NtApi.h"

#define CODEINTEGRITY_OPTION_TESTSIGN 0x00000002


namespace CheckTestMode
{

	__forceinline bool CodeIntCheck() {


		SYSTEM_CODEINTEGRITY_INFORMATION cInfo{};
		cInfo.Length = sizeof(cInfo);// set length and don't work without this

			auto NtQuerySystemInformation = (t_NtQuerySystemInformation)ApiWrapper::GetProcAddress(L"ntdll.dll", "NtQuerySystemInformation");
			if (!NtQuerySystemInformation)
			{
				return FALSE;
			}
		NtQuerySystemInformation(
			SystemCodeIntegrityInformation,
			&cInfo,
			sizeof(cInfo),
			NULL
		);



		return (cInfo.CodeIntegrityOptions & CODEINTEGRITY_OPTION_TESTSIGN); 
	}



	 bool IsStartedWithDisableDSE()
	{

		/*
		You can also detect kernel debugger (read -> https://shhoya.github.io/antikernel_kerneldebugging.html	)

		*/

		bool bDetect = FALSE;
		char RegKey[_MAX_PATH];
		DWORD BufSize = _MAX_PATH;
		DWORD dataType = REG_SZ;

		HKEY hKey;


		auto openResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control", NULL, KEY_QUERY_VALUE, &hKey);
		if (openResult == ERROR_SUCCESS)
		{
			auto valSystemOpthion = RegQueryValueExA(hKey, "SystemStartOptions", NULL, &dataType, (LPBYTE)&RegKey, &BufSize);
			if (valSystemOpthion == ERROR_SUCCESS)
			{
				if (NoCRT::string::strstr(RegKey, "TESTSIGNING"))
					bDetect = true;
			}
			RegCloseKey(hKey);
		}


		return bDetect;
	}


	/*
	 originale idea  https://github.com/mq1n/NoMercy/blob/3a375e27f56fe9eec9c553c641ce0abde2c6b22b/Source/Client/NM_Engine/ITestSignatureScanner.cpp#L106
	*/
	__forceinline bool IsBcdLibraryBooleanAllowPrereleaseSignatures()
	{
		HKEY hTestKey;
		if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "BCD00000000\\Objects", 0, KEY_READ, &hTestKey) != ERROR_SUCCESS)
			return false;

		char    achKey[255];
		DWORD    cbName;
		char    achClass[MAX_PATH];
		DWORD    cchClassName = MAX_PATH;
		DWORD    cSubKeys = 0;
		DWORD    cbMaxSubKey;
		DWORD    cchMaxClass;
		DWORD    cValues;
		DWORD    cchMaxValue;
		DWORD    cbMaxValueData;
		DWORD    cbSecurityDescriptor;
		FILETIME ftLastWriteTime;

		bool bDetect = FALSE;

		auto dwReturn = (PDWORD)VirtualAlloc(0, 0x4096, MEM_COMMIT, PAGE_READWRITE);
		DWORD dwBufSize = 0x4096;

		auto dwApiRetCode = RegQueryInfoKeyA(hTestKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey, &cchMaxClass, &cValues, &cchMaxValue, &cbMaxValueData,
			&cbSecurityDescriptor, &ftLastWriteTime);

		
		if (cSubKeys)
		{
			for (DWORD i = 0; i < cSubKeys; i++)
			{
				cbName = 255;
				dwApiRetCode = RegEnumKeyExA(hTestKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime);
				if (dwApiRetCode == ERROR_SUCCESS)
				{
					char* szNewWay = (char*)VirtualAlloc(0, 0x4096, MEM_COMMIT, PAGE_READWRITE);

					NoCRT::mem::memset(szNewWay, 0, 0x4096);

					NoCRT::string::strcatA(szNewWay, "BCD00000000\\Objects\\");
					NoCRT::string::strcatA(szNewWay, achKey);
					NoCRT::string::strcatA(szNewWay, "\\Elements\\16000049"); ;


					HKEY hnewKey;
					long lError = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szNewWay, NULL, KEY_QUERY_VALUE, &hnewKey);
					if (lError == ERROR_SUCCESS)
					{

						long lVal = RegQueryValueExA(hnewKey, "Element", NULL, 0, (LPBYTE)dwReturn, &dwBufSize);
						if (lVal == ERROR_SUCCESS)
						{
							if (dwReturn[0] == 1UL)
								bDetect = true;
						}
						RegCloseKey(hnewKey);
					}
					VirtualFree((PVOID)szNewWay, 0, MEM_RELEASE);

				}
			}
		}
		

		VirtualFree(dwReturn, 0, MEM_RELEASE);
		RegCloseKey(hTestKey);
		return bDetect;
	}

}
```

`Baka/WoW64ext.h`:

```h
#pragma once
#include "ApiWrapper.h"


#ifndef _WIN64

/**
 *
 * WOW64Ext Library
 *
 * Copyright (c) 2014 ReWolf
 * http://blog.rewolf.pl/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
union reg64
{
    DWORD64 v;
    DWORD dw[2];
};

#define EMIT(a) __asm __emit (a)

#define X64_Start_with_CS(_cs) \
    { \
    EMIT(0x6A) EMIT(_cs)                         /*  push   _cs             */ \
    EMIT(0xE8) EMIT(0) EMIT(0) EMIT(0) EMIT(0)   /*  call   $+5             */ \
    EMIT(0x83) EMIT(4) EMIT(0x24) EMIT(5)        /*  add    dword [esp], 5  */ \
    EMIT(0xCB)                                   /*  retf                   */ \
    }

#define X64_End_with_CS(_cs) \
    { \
    EMIT(0xE8) EMIT(0) EMIT(0) EMIT(0) EMIT(0)                                 /*  call   $+5                   */ \
    EMIT(0xC7) EMIT(0x44) EMIT(0x24) EMIT(4) EMIT(_cs) EMIT(0) EMIT(0) EMIT(0) /*  mov    dword [rsp + 4], _cs  */ \
    EMIT(0x83) EMIT(4) EMIT(0x24) EMIT(0xD)                                    /*  add    dword [rsp], 0xD      */ \
    EMIT(0xCB)                                                                 /*  retf                         */ \
    }

#define X64_Start() X64_Start_with_CS(0x33)
#define X64_End() X64_End_with_CS(0x23)

#define _RAX  0
#define _RCX  1
#define _RDX  2
#define _RBX  3
#define _RSP  4
#define _RBP  5
#define _RSI  6
#define _RDI  7
#define _R8   8
#define _R9   9
#define _R10 10
#define _R11 11
#define _R12 12
#define _R13 13
#define _R14 14
#define _R15 15

#define X64_Push(r) EMIT(0x48 | ((r) >> 3)) EMIT(0x50 | ((r) & 7))
#define X64_Pop(r) EMIT(0x48 | ((r) >> 3)) EMIT(0x58 | ((r) & 7))

#define REX_W EMIT(0x48) __asm

namespace WoW64Help
{
#pragma warning(push)
#pragma warning(disable : 4409)
    __forceinline DWORD64 __cdecl X64Call(DWORD64 func, int argC, ...)
    {


        va_list args;
        va_start(args, argC);
        reg64 _rcx = { (argC > 0) ? argC--, va_arg(args, DWORD64) : 0 };
        reg64 _rdx = { (argC > 0) ? argC--, va_arg(args, DWORD64) : 0 };
        reg64 _r8 = { (argC > 0) ? argC--, va_arg(args, DWORD64) : 0 };
        reg64 _r9 = { (argC > 0) ? argC--, va_arg(args, DWORD64) : 0 };
        reg64 _rax = { 0 };

        reg64 restArgs = { (DWORD64)&va_arg(args, DWORD64) };

        // conversion to QWORD for easier use in inline assembly
        reg64 _argC = { (DWORD64)argC };
        DWORD back_esp = 0;
        WORD back_fs = 0;

        __asm
        {
            ;// reset FS segment, to properly handle RFG
            mov    back_fs, fs
                mov    eax, 0x2B
                mov    fs, ax

                ;// keep original esp in back_esp variable
            mov    back_esp, esp

                ;// align esp to 0x10, without aligned stack some syscalls may return errors !
            ;// (actually, for syscalls it is sufficient to align to 8, but SSE opcodes 
            ;// requires 0x10 alignment), it will be further adjusted according to the
            ;// number of arguments above 4
            and esp, 0xFFFFFFF0

                X64_Start();

            ;// below code is compiled as x86 inline asm, but it is executed as x64 code
            ;// that's why it need sometimes REX_W() macro, right column contains detailed
            ;// transcription how it will be interpreted by CPU

            ;// fill first four arguments
            REX_W mov    ecx, _rcx.dw[0];// mov     rcx, qword ptr [_rcx]
            REX_W mov    edx, _rdx.dw[0];// mov     rdx, qword ptr [_rdx]
            push   _r8.v;// push    qword ptr [_r8]
            X64_Pop(_R8); ;// pop     r8
            push   _r9.v;// push    qword ptr [_r9]
            X64_Pop(_R9); ;// pop     r9
            ;//
            REX_W mov    eax, _argC.dw[0];// mov     rax, qword ptr [_argC]
            ;// 
            ;// final stack adjustment, according to the    ;//
            ;// number of arguments above 4                 ;// 
            test   al, 1;// test    al, 1
            jnz    _no_adjust;// jnz     _no_adjust
            sub    esp, 8;// sub     rsp, 8
        _no_adjust:;//
            ;// 
            push   edi;// push    rdi
            REX_W mov    edi, restArgs.dw[0];// mov     rdi, qword ptr [restArgs]
            ;// 
            ;// put rest of arguments on the stack          ;// 
            REX_W test   eax, eax;// test    rax, rax
            jz     _ls_e;// je      _ls_e
            REX_W lea    edi, dword ptr[edi + 8 * eax - 8];// lea     rdi, [rdi + rax*8 - 8]
            ;// 
        _ls:;// 
            REX_W test   eax, eax;// test    rax, rax
            jz     _ls_e;// je      _ls_e
            push   dword ptr[edi];// push    qword ptr [rdi]
            REX_W sub    edi, 8;// sub     rdi, 8
            REX_W sub    eax, 1;// sub     rax, 1
            jmp    _ls;// jmp     _ls
        _ls_e:;// 
            ;// 
            ;// create stack space for spilling registers   ;// 
            REX_W sub    esp, 0x20;// sub     rsp, 20h
            ;// 
            call   func;// call    qword ptr [func]
            ;// 
            ;// cleanup stack                               ;// 
            REX_W mov    ecx, _argC.dw[0];// mov     rcx, qword ptr [_argC]
            REX_W lea    esp, dword ptr[esp + 8 * ecx + 0x20];// lea     rsp, [rsp + rcx*8 + 20h]
            ;// 
            pop    edi;// pop     rdi
            ;// 
    // set return value                             ;// 
            REX_W mov    _rax.dw[0], eax;// mov     qword ptr [_rax], rax

            X64_End();

            mov    ax, ds
                mov    ss, ax
                mov    esp, back_esp

                ;// restore FS segment
            mov    ax, back_fs
                mov    fs, ax
        }
        return _rax.v;
    }
#pragma warning(pop)


}
#endif // !_WIN64
```

`README.md`:

```md
# Baka
Sample anti-debug with detect ScyllaHide/HyperHide and TitanHide

x32\x64 support!  
Peculiarities:  
-Api Wrapper    
-Code don't use CRT  
-Check Test mode  
-check CRC sections  
  
Running under HyperHide ->  
![alt text](https://github.com/LazyAhora/Baka/blob/main/HyperHide.png)  
Detect TitanHide ->  
![alt text](https://github.com/Ahora57/Baka/blob/main/Detect%20TitanHide%20by%20bad%20hook.png) 
Running under ShyllaHide->  
![alt text](https://github.com/LazyAhora/Baka/blob/main/ShyllaHide.png)  

```