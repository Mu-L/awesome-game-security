Project Path: arc_gmh5225_XignCode3-bypass-alternative_16u5b5cp

Source Tree:

```txt
arc_gmh5225_XignCode3-bypass-alternative_16u5b5cp
├── README.md
├── xign_bypass
│   ├── exports.cpp
│   ├── exports.def
│   ├── exports.hpp
│   ├── generic.cpp
│   ├── generic.hpp
│   ├── main.cpp
│   ├── maplestory.cpp
│   ├── maplestory.hpp
│   ├── memory.cpp
│   ├── memory.hpp
│   ├── native.hpp
│   ├── output.cpp
│   ├── output.hpp
│   ├── xign_bypass.vcxproj
│   ├── xign_bypass.vcxproj.filters
│   ├── xigncode.cpp
│   ├── xigncode.hpp
│   ├── xigncode_callback.cpp
│   ├── xigncode_callback.hpp
│   ├── xigncode_manager.cpp
│   └── xigncode_manager.hpp
└── xign_bypass.sln

```

`README.md`:

```md
# XignCode3 bypass
A memory bypass for Wellbia's XignCode3.

Bypasses XignCode's use of APIs and internal functionality through memory-hooks (detours).

```

`xign_bypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.21005.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xign_bypass", "xign_bypass\xign_bypass.vcxproj", "{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}.Debug|Win32.ActiveCfg = Debug|Win32
		{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}.Debug|Win32.Build.0 = Debug|Win32
		{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}.Release|Win32.ActiveCfg = Release|Win32
		{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`xign_bypass/exports.cpp`:

```cpp
#include "exports.hpp"

static FARPROC ijl_spoof_function[6];

void _declspec(naked) ijl15_GetLibVersion()
{
	_asm jmp dword ptr ijl_spoof_function[0]
}

void _declspec(naked) ijl15_Init()
{
	_asm jmp dword ptr ijl_spoof_function[1]
}

void _declspec(naked) ijl15_Free()
{
	_asm jmp dword ptr ijl_spoof_function[2]
}

void _declspec(naked) ijl15_Read()
{
	_asm jmp dword ptr ijl_spoof_function[3]
}

void _declspec(naked) ijl15_Write()
{
	_asm jmp dword ptr ijl_spoof_function[4]
}

void _declspec(naked) ijl15_ErrorStr()
{
	_asm jmp dword ptr ijl_spoof_function[5]
}

namespace exports
{
	bool setup()
	{
		HMODULE ijl15 = LoadLibrary("spoof\\ijl15.dll");
		
		if (!ijl15)
		{
			MessageBox(NULL, "Failed to load library \"spoof\\ijl15.dll\".", NULL, 0);
			return false;
		}
		
		ijl_spoof_function[0] = GetProcAddress(ijl15, "ijlGetLibVersion");
		ijl_spoof_function[1] = GetProcAddress(ijl15, "ijlInit");
		ijl_spoof_function[2] = GetProcAddress(ijl15, "ijlFree");
		ijl_spoof_function[3] = GetProcAddress(ijl15, "ijlRead");
		ijl_spoof_function[4] = GetProcAddress(ijl15, "ijlWrite");
		ijl_spoof_function[5] = GetProcAddress(ijl15, "ijlErrorStr");

		for (int i = 0; i < 6; i++)
		{
			if (!ijl_spoof_function[i])
			{
				MessageBox(NULL, "The ijl15 spoof failed.", NULL, 0);
				return false;
			}
		}

		return true;
	}
}
```

`xign_bypass/exports.def`:

```def
LIBRARY "xign_bypass"

EXPORTS
	ijlGetLibVersion		= ijl15_GetLibVersion					@1		PRIVATE
	ijlInit					= ijl15_Init							@2		PRIVATE
	ijlFree					= ijl15_Free							@3		PRIVATE
	ijlRead					= ijl15_Read							@4		PRIVATE
	ijlWrite				= ijl15_Write							@5		PRIVATE
	ijlErrorStr				= ijl15_ErrorStr						@6		PRIVATE
```

`xign_bypass/exports.hpp`:

```hpp
#pragma once

#include "generic.hpp"

namespace exports
{
	bool setup();
}
```

`xign_bypass/generic.cpp`:

```cpp
#include "generic.hpp"

#pragma comment(lib, "ntdll")
#pragma comment(lib, "version")

namespace function
{
	typedef struct _SYSTEM_HANDLE 
	{
		unsigned int process_id;
		unsigned char object_type_number;
		unsigned char flags;
		unsigned short handle;
		void* object;
		ACCESS_MASK granted_access;
	} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

	typedef struct _SYSTEM_HANDLE_INFORMATION
	{
		unsigned int handle_count;
		SYSTEM_HANDLE handles[1];
	} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

	const int STATUS_SUCCESS = 0x00000000;
	const int STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

	const SYSTEM_INFORMATION_CLASS SystemHandleInformation = static_cast<SYSTEM_INFORMATION_CLASS>(16);
	const OBJECT_INFORMATION_CLASS ObjectNameInformation = static_cast<OBJECT_INFORMATION_CLASS>(1);

	bool close_handle(std::string const& handle_name)
	{
		std::wstring wide_handle_name(handle_name.length(), L' ');
		std::copy(handle_name.begin(), handle_name.end(), wide_handle_name.begin());

		int number_of_handles = 512;
		SYSTEM_HANDLE_INFORMATION* handle_group = nullptr;

		unsigned long length = 0;
		NTSTATUS status = 0;

		do
		{
			free(handle_group);

			number_of_handles *= 2;
			handle_group = reinterpret_cast<SYSTEM_HANDLE_INFORMATION*>(malloc(4 + sizeof(SYSTEM_HANDLE) * number_of_handles));
		
			status = NtQuerySystemInformation(SystemHandleInformation, handle_group, 4 + sizeof(SYSTEM_HANDLE) * number_of_handles, &length);
		}
		while (status == STATUS_INFO_LENGTH_MISMATCH);

		if (status != STATUS_SUCCESS)
		{
			free(handle_group);
			return false;
		}

		for (unsigned int i = 0; i < handle_group->handle_count; i++)
		{
			wchar_t object_name[1024];

			if (NtQueryObject(reinterpret_cast<HANDLE>(handle_group->handles[i].handle), ObjectNameInformation, &object_name, 1024, &length) != STATUS_SUCCESS)
			{
				continue;
			}

			if (wcsstr(object_name, wide_handle_name.c_str()) != NULL)
			{
				HANDLE handle;
				DuplicateHandle(GetCurrentProcess(), reinterpret_cast<HANDLE>(handle_group->handles[i].handle), 0, &handle, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
				CloseHandle(handle);
				free(handle_group);
				return true;
			}
		}
	
		free(handle_group);
		return false;
	}

	bool redirect(bool enable, void** function, void* redirection)
	{
		if (DetourTransactionBegin() != NO_ERROR)
		{
			return false;
		}

		if (DetourUpdateThread(GetCurrentThread()) != NO_ERROR)
		{
			return false;
		}

		if ((enable ? DetourAttach : DetourDetach)(function, redirection) != NO_ERROR)
		{
			return false;
		}

		if (DetourTransactionCommit() == NO_ERROR)
		{
			return true;
		}

		DetourTransactionAbort();
		return false;
	}
	
	bool get_version(std::string const& file_path, version_struct& version)
	{
		std::size_t size = GetFileVersionInfoSize(file_path.c_str(), nullptr);

		if (!size)
		{
			return false;
		}

		unsigned char* data = new unsigned char[size];

		if (!GetFileVersionInfo(file_path.c_str(), NULL, size, data))
		{
			return false;
		}

		VS_FIXEDFILEINFO* version_info = nullptr;

		if (!VerQueryValueA(data, "\\", reinterpret_cast<void**>(&version_info), &size))
		{
			return false;
		}

		if (size == 0 || version_info->dwSignature != 0xfeef04bd)
		{
			return false;
		}

		version = version_struct(version_info->dwFileVersionMS, version_info->dwFileVersionLS);

		delete[] data;
		return true;
	}
}
```

`xign_bypass/generic.hpp`:

```hpp
#pragma once

#define PRINT_STATUS 0

#if (PRINT_STATUS == 1)
#define PRINT_DEBUG_INFO
#endif

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef _STL_SECURE_NO_WARNINGS
#define _STL_SECURE_NO_WARNINGS
#endif

#include <WinSock2.h>
#include <Windows.h>
#include <Winternl.h>

#include <detours.h>
#pragma comment(lib, "detours")

#include <algorithm>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <thread>
#include <vector>

#ifndef Padding
#define Padding(x) struct { unsigned char __padding##x[(x)]; };
#endif

#ifndef WM_SOCKET
#define WM_SOCKET WM_USER + 100
#endif

/* custom version-type */
typedef struct VERSION
{
	VERSION() : _1(0), _2(0), _3(0), _4(0)
	{
		/* constructor */
	}

	VERSION(unsigned int MS, unsigned int LS)
		: MS(MS), LS(LS)
	{
		/* constructor */
	}

	VERSION(unsigned short _1, unsigned short _2, unsigned short _3, unsigned short _4)
		: _1(_1), _2(_2), _3(_3), _4(_4)
	{
		/* constructor */
	}

	union
	{
		struct
		{
			unsigned short _2;
			unsigned short _1;
		};

		unsigned int MS;
	};

	union
	{
		struct
		{
			unsigned short _4;
			unsigned short _3;
		};

		unsigned int LS;
	};

} version_struct;

namespace function
{
	bool close_handle(std::string const& handle_name);
	bool redirect(bool enable, void** function, void* redirection);
	bool get_version(std::string const& file_path, version_struct& version);
}
```

`xign_bypass/main.cpp`:

```cpp
#include "generic.hpp"

#include "exports.hpp"

#include "maplestory.hpp"
#include "xigncode.hpp"

BOOL APIENTRY DllMain(HMODULE module, unsigned long reason, void* reserved)
{
	if (reason == DLL_PROCESS_ATTACH)
	{	
//#ifdef PRINT_DEBUG_INFO
		AllocConsole();
		SetConsoleTitle("XignCode Bypass");
		AttachConsole(GetCurrentProcessId());
	
		FILE* pFile = nullptr;
		freopen_s(&pFile, "CON", "r", stdin);
		freopen_s(&pFile, "CON", "w", stdout);
		freopen_s(&pFile, "CON", "w", stderr);
//#endif
		
		if (exports::setup())
		{
			maplestory::initialize_bypass();
			xigncode::initialize_bypass();
		}

		DisableThreadLibraryCalls(module);
	}
	else if (reason == DLL_PROCESS_DETACH)
	{	
#ifdef PRINT_DEBUG_INFO
		FreeConsole();
#endif
	}

	return TRUE;
}
```

`xign_bypass/maplestory.cpp`:

```cpp
#include "maplestory.hpp"
#include "memory.hpp"

namespace maplestory
{
	unsigned char* image_base = nullptr;
	unsigned char* image_end = nullptr;
	unsigned char* image_copy = nullptr;
	
	//void __thiscall CClientSocket::SendPacket(CClientSocket *this, COutPacket *oPacket)
	const unsigned int send_packet = 0x005C5CC0; // Reference: 8B 0D ? ? ? ? 8D 44 24 ? 50 E8 ? ? ? 00 83 BE ? 00 00 00 00 75
	
	const unsigned int dr_check = 0x005BE630; // BD A1 DE 19 (1st call below)
	const unsigned int logo_skipper = 0x008F17C9; // 74 ? 2B F8 81 FF ? ? 00 00 0F

	/* MapleStory CRCs */
	const unsigned int mscrc_address_1 = 0x01437F49; // 3B 8D 70 FF FF FF 0F 85
	const unsigned int mscrc_return_1 = 0x01438169 + 5; // 8A 11 80 C2 01
	const unsigned int mscrc_skip_1 = 0x01C89377;

	const unsigned int mscrc_address_2 = 0x02104717;
	const unsigned int mscrc_return_2 = mscrc_address_2 + 5;
	
	const unsigned int mscrc_address_3 = 0x01FFAE30;
	const unsigned int mscrc_return_3 = 0x02007F0A;

	const unsigned int mscrc_check_1 = mscrc_address_1 - 6;
	const unsigned int mscrc_check_2 = mscrc_address_1 + 6;
	const unsigned int mscrc_check_3 = mscrc_address_2 - 6;
	const unsigned int mscrc_check_4 = mscrc_address_2 + 6;
	const unsigned int mscrc_check_5 = send_packet - 20;
	const unsigned int mscrc_check_6 = send_packet + 40;

	void __declspec(naked) mscrc_hook_1()
	{
		_asm
		{
			cmp ecx,[ebp-0x00000090]
			je Skip

			xor eax,eax
			add eax,edx
			mov edx,[ebp+0x18]
			sub eax,0x08
			mov eax,[edx]
			shr eax,0x08
			xor ecx,ecx
			mov ecx,eax
			shl ecx,0x08
			mov ecx,[ebp+0x08]
			add ecx,[ebp-0x38]
			xor edx,edx
			mov ebx,[ebp+0x08]

			cmp ecx,image_base
			jl nobypass
			cmp ecx,image_end
			jg nobypass

			sub ecx,image_base
			add ecx,[image_copy]

			nobypass:
			mov dl,[ecx]
			add dl,0x01
			jmp [mscrc_return_1]

			Skip:
			push 0x00
			jmp [mscrc_skip_1]
		}
	}
	
	void __declspec(naked) mscrc_hook_2()
	{
		_asm
		{
			cmp ecx,image_base
			jl nobypass
			cmp ecx,image_end
			jg nobypass

			sub ecx,image_base
			add ecx,[image_copy]

			nobypass:
			add al,[ecx]
			pop ecx
			push cx
			jmp [mscrc_return_2]
		}
	}

	void __declspec(naked) mscrc_hook_3()
	{
		_asm
		{
			cmp edx,[mscrc_check_1]
			jl nobypassa
			cmp edx,[mscrc_check_2]
			jg nobypassa
			jmp bypass

			nobypassa:
			cmp edx,[mscrc_check_3]
			jl nobypassb
			cmp edx,[mscrc_check_4]
			jg nobypassb
			jmp bypass

			nobypassb:
			cmp edx,[mscrc_check_5]
			jl nobypass
			cmp edx,[mscrc_check_6]
			jg nobypass

			bypass:
			sub edx,image_base
			add edx,[image_copy]

			nobypass:
			push [edx]
			jmp [mscrc_return_3]
		}
	}
	
	void set_maplestory_crc()
	{
		static memory mscrc_1(mscrc_address_1, 6);
		mscrc_1.jump(mscrc_hook_1);

		static memory mscrc_2(mscrc_address_2, mscrc_return_2 - mscrc_address_2);
		mscrc_2.jump(mscrc_hook_2);

		static memory mscrc_3(mscrc_address_3, 7);
		mscrc_3.jump(mscrc_hook_3);
		
#ifdef PRINT_DEBUG_INFO
		printf("mscrc 1: %08X -> %08X\n", mscrc_address_1, mscrc_return_1);
		printf("mscrc 2: %08X -> %08X\n", mscrc_address_2, mscrc_return_2);
		printf("mscrc 3: %08X -> %08X\n", mscrc_address_3, mscrc_return_3);
		printf("\n");
#endif
	}

	bool set_image_base()
	{
		PEB* peb = reinterpret_cast<TEB*>(__readfsdword(PcTeb))->ProcessEnvironmentBlock;

		/* Set PEB->ImageBaseAddress to the image_copy */
		peb->Reserved3[1] = image_copy;
	
		/* Set the module's DllBase to image_copy */
		PEB_LDR_DATA* loader_data = reinterpret_cast<PEB_LDR_DATA*>(peb->Ldr);

		if (loader_data->InLoadOrderModuleList.Flink == &loader_data->InLoadOrderModuleList) 
		{
			return false;
		}

		LDR_DATA_TABLE_ENTRY* first = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(&loader_data->InLoadOrderModuleList);

		for (LDR_DATA_TABLE_ENTRY* current = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(first->InLoadOrderLinks.Flink); 
			current != first; current = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(current->InLoadOrderLinks.Flink))
		{
			try
			{
				if (current->DllBase == image_base)
				{
					unsigned long protection;
					VirtualProtect(current, sizeof(LDR_DATA_TABLE_ENTRY), PAGE_EXECUTE_READWRITE, &protection);

					current->DllBase = image_copy;
				}
			}
			catch (...)
			{
				continue;
			}
		}

		return true;
	}
	
	void set_additional_hacks()
	{
		membase::set_memory(reinterpret_cast<unsigned char*>(dr_check), "\x33\xC0\xC3", 3);
		membase::set_memory(reinterpret_cast<unsigned char*>(logo_skipper), "\x90\x90", 2);
	}
	
	void initialize_crc_multi()
	{
		function::close_handle("WvsClientMtx");

		image_base = reinterpret_cast<unsigned char*>(GetModuleHandle("MapleStory.exe"));
		IMAGE_NT_HEADERS* nt_header = PIMAGE_NT_HEADERS(image_base + PIMAGE_DOS_HEADER(image_base)->e_lfanew);

		image_copy = reinterpret_cast<unsigned char*>(malloc(nt_header->OptionalHeader.SizeOfImage));
		memcpy(image_copy, image_base, nt_header->OptionalHeader.SizeOfImage);

		image_end = image_base + nt_header->OptionalHeader.SizeOfImage;

		//set_image_base();
		//set_maplestory_crc();
		//set_additional_hacks();
	}

	bool Hook_RegisterClassExA()
	{
		static decltype(&RegisterClassExA) _RegisterClassExA = RegisterClassExA;

		decltype(&RegisterClassExA) RegisterClassExA_hook = [](const WNDCLASSEXA* lpwcx) -> ATOM
		{
			static WNDPROC _SplashWndProc = nullptr;

			static WNDPROC SplashWndProc = [](HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) -> LRESULT
			{
				if (msg == WM_CREATE)
				{
					char window_caption[256];
					sprintf(window_caption, "MapleStory | PID: %08X (%d)", GetCurrentProcessId(), GetCurrentProcessId());
					SetWindowText(hwnd, window_caption);
				}

				return _SplashWndProc(hwnd, msg, wParam, lParam);
			};

			if (lpwcx->lpszClassName)
			{
				if (!strcmp(lpwcx->lpszClassName, "StartUpDlgClass"))
				{
					initialize_crc_multi();
					return NULL;
				}
				else if (!strcmp(lpwcx->lpszClassName, "MapleStoryClass"))
				{
					_SplashWndProc = lpwcx->lpfnWndProc;
					const_cast<WNDCLASSEXA*>(lpwcx)->lpfnWndProc = SplashWndProc;
				}
				else if (!strcmp(lpwcx->lpszClassName, "NexonADBallon"))
				{
					return NULL;
				}
			}

			return _RegisterClassExA(lpwcx);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_RegisterClassExA), RegisterClassExA_hook);
	}
	
	void initialize_bypass()
	{
		Hook_RegisterClassExA();
	}
}
```

`xign_bypass/maplestory.hpp`:

```hpp
#pragma once

#include "generic.hpp"

namespace maplestory
{
	void initialize_bypass();
}
```

`xign_bypass/memory.cpp`:

```cpp
#include "memory.hpp"

namespace membase
{
	bool set_memory(unsigned char* address, void* data, unsigned int size)
	{
		MEMORY_BASIC_INFORMATION mbi;

		if (VirtualQuery(address, &mbi, sizeof(MEMORY_BASIC_INFORMATION)) != sizeof(MEMORY_BASIC_INFORMATION))
		{
			return false;
		}

		if (!mbi.Protect || (mbi.Protect & PAGE_GUARD))
		{
			return false;
		}
	
		unsigned long protection = 0;

		if (!(mbi.Protect & PAGE_EXECUTE_READWRITE))
		{
			if (!VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &protection))
			{
				return false;
			}
		}

		memcpy(address, data, size);
		return (protection ? VirtualProtect(mbi.BaseAddress, mbi.RegionSize, protection, &protection) != FALSE : true);
	}
}

memory::memory(unsigned int target, unsigned int size)
{
	this->address =  reinterpret_cast<unsigned char*>(target);

	this->size = size;
	this->data.reset(new BYTE[this->size]);

	memcpy(this->data.get(), this->address, this->size);
}

memory::memory(unsigned char* target, unsigned int size)
{
	this->address = target;

	this->size = size;
	this->data.reset(new BYTE[this->size]);

	memcpy(this->data.get(), this->address, this->size);
}

memory::~memory(void)
{

}

bool memory::jump(void* destination)
{
	if (this->size < 5)
	{
		return false;
	}

	MEMORY_BASIC_INFORMATION mbi;

	if (VirtualQuery(this->address, &mbi, sizeof(MEMORY_BASIC_INFORMATION)) != sizeof(MEMORY_BASIC_INFORMATION))
	{
		return false;
	}

	if (!mbi.Protect || (mbi.Protect & PAGE_GUARD))
	{
		return false;
	}
	
	unsigned long protection = 0;

	if (!(mbi.Protect & PAGE_EXECUTE_READWRITE))
	{
		if (!VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &protection))
		{
			return false;
		}
	}

	*reinterpret_cast<unsigned char*>(this->address) = 0xE9;
	*reinterpret_cast<unsigned int*>(this->address + 1) = this->get_distance(this->address, destination);

	unsigned int nops = this->size - 5;

	if (nops != 0)
	{
		memset(this->address + 5, 0x90, nops);
	}

	return (protection ? VirtualProtect(mbi.BaseAddress, mbi.RegionSize, protection, &protection) != FALSE : true);
}

inline unsigned int memory::get_distance(unsigned char* source, void* destination)
{
	return reinterpret_cast<unsigned int>(destination) - reinterpret_cast<unsigned int>(source) - 5;
}
```

`xign_bypass/memory.hpp`:

```hpp
#pragma once

#include "generic.hpp"

#include <memory>

namespace membase
{
	bool set_memory(unsigned char* address, void* data, unsigned int size);
}

class memory
{
public:
	explicit memory(unsigned int target, unsigned int size);
	explicit memory(unsigned char* target, unsigned int size);
	~memory();

	bool jump(void* destination);

private:	
	unsigned int get_distance(unsigned char* source, void* destination);

	std::unique_ptr<unsigned char> data;
	unsigned char* address;
	unsigned int size;
};
```

`xign_bypass/native.hpp`:

```hpp
#pragma once

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <Windows.h>

#include <winternl.h>
#pragma comment(lib, "ntdll")

#include <iostream>

#define STATUS_SUCCESS			((NTSTATUS)0x00000000)
#define STATUS_ACCESS_DENIED	((NTSTATUS)0xC0000022)
	
const OBJECT_INFORMATION_CLASS ObjectNameInformation = static_cast<OBJECT_INFORMATION_CLASS>(1);

typedef struct _CLIENT_ID
{
	DWORD UniqueProcess;
	DWORD UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name;
	WCHAR NameBuffer[1024];
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
```

`xign_bypass/output.cpp`:

```cpp
#include "output.hpp"

namespace output
{
	void hexdump(void* input, int length)
	{
		unsigned char* buffer = reinterpret_cast<unsigned char*>(input);

		for (int i = 0; i < length; i += 16)
		{
			printf("%06X: ", i);

			for (int j = 0; j < 16; j++)
			{
				if (i + j < length)
				{
					printf("%02X ", buffer[i + j]);
				}
				else
				{
					printf("   ");
				}
			}

			printf(" ");

			for (int j = 0; j < 16; j++)
			{
				if (i + j < length)
				{
					printf("%c", isprint(buffer[i + j]) ? buffer[i + j] : '.');
				}
			}

			printf("\n");
		}
	}

	void fhexdump(FILE* file, void* input, int length)
	{
		unsigned char* buffer = reinterpret_cast<unsigned char*>(input);

		for (int i = 0; i < length; i += 16)
		{
			fprintf(file, "%06X: ", i);

			for (int j = 0; j < 16; j++)
			{
				if (i + j < length)
				{
					fprintf(file, "%02X ", buffer[i + j]);
				}
				else
				{
					fprintf(file, "   ");
				}
			}

			fprintf(file, " ");

			for (int j = 0; j < 16; j++)
			{
				if (i + j < length)
				{
					fprintf(file, "%c", isprint(buffer[i + j]) ? buffer[i + j] : '.');
				}
			}

			fprintf(file, "\n");
		}
	}
}
```

`xign_bypass/output.hpp`:

```hpp
#pragma once

#include "generic.hpp"

namespace output
{
	void hexdump(void* input, int length);
	void fhexdump(FILE* file, void* input, int length);
}
```

`xign_bypass/xign_bypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4B4AB58B-A040-4E8C-8DAD-4AD59A929E97}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xign_bypass</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XIGN_BYPASS_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XIGN_BYPASS_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>copy /Y "$(TargetDir)$(ProjectName).dll" "$(TargetDir)$(ProjectName)\ijl15.dll"
copy /Y "$(TargetDir)$(ProjectName).dll" "G:\Games\MapleStory (Europe)\ijl15.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="xigncode.cpp" />
    <ClCompile Include="exports.cpp" />
    <ClCompile Include="generic.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="maplestory.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="output.cpp" />
    <ClCompile Include="xigncode_callback.cpp" />
    <ClCompile Include="xigncode_manager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="xigncode_callback.hpp" />
    <ClInclude Include="xigncode_manager.hpp" />
    <ClInclude Include="xigncode.hpp" />
    <ClInclude Include="exports.hpp" />
    <ClInclude Include="generic.hpp" />
    <ClInclude Include="maplestory.hpp" />
    <ClInclude Include="memory.hpp" />
    <ClInclude Include="native.hpp" />
    <ClInclude Include="output.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`xign_bypass/xign_bypass.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="spoof">
      <UniqueIdentifier>{97cebcee-ed78-497a-b5ac-6c10b9f81d9b}</UniqueIdentifier>
    </Filter>
    <Filter Include="generic">
      <UniqueIdentifier>{afe1d596-1d0a-433c-8002-f0796fe6b0e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="generic\output">
      <UniqueIdentifier>{f64ab0da-1e1e-42b9-9a98-da85da415559}</UniqueIdentifier>
    </Filter>
    <Filter Include="generic\memory">
      <UniqueIdentifier>{7ad79854-5a56-43e5-8637-3f14370a3e59}</UniqueIdentifier>
    </Filter>
    <Filter Include="source">
      <UniqueIdentifier>{2b63320e-20fe-4f41-93f0-20b7233f387e}</UniqueIdentifier>
    </Filter>
    <Filter Include="maplestory">
      <UniqueIdentifier>{a191c1dd-a9d4-4f5c-bfc7-758cca441683}</UniqueIdentifier>
    </Filter>
    <Filter Include="xigncode">
      <UniqueIdentifier>{77b164e5-0976-4289-bc8f-01fac2895cc0}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="exports.cpp">
      <Filter>spoof</Filter>
    </ClCompile>
    <ClCompile Include="generic.cpp">
      <Filter>generic</Filter>
    </ClCompile>
    <ClCompile Include="output.cpp">
      <Filter>generic\output</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>generic\memory</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>source</Filter>
    </ClCompile>
    <ClCompile Include="maplestory.cpp">
      <Filter>maplestory</Filter>
    </ClCompile>
    <ClCompile Include="xigncode.cpp">
      <Filter>xigncode</Filter>
    </ClCompile>
    <ClCompile Include="xigncode_manager.cpp">
      <Filter>xigncode</Filter>
    </ClCompile>
    <ClCompile Include="xigncode_callback.cpp">
      <Filter>xigncode</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="exports.hpp">
      <Filter>spoof</Filter>
    </ClInclude>
    <ClInclude Include="generic.hpp">
      <Filter>generic</Filter>
    </ClInclude>
    <ClInclude Include="output.hpp">
      <Filter>generic\output</Filter>
    </ClInclude>
    <ClInclude Include="memory.hpp">
      <Filter>generic\memory</Filter>
    </ClInclude>
    <ClInclude Include="native.hpp">
      <Filter>xigncode</Filter>
    </ClInclude>
    <ClInclude Include="xigncode.hpp">
      <Filter>xigncode</Filter>
    </ClInclude>
    <ClInclude Include="xigncode_manager.hpp">
      <Filter>xigncode</Filter>
    </ClInclude>
    <ClInclude Include="xigncode_callback.hpp">
      <Filter>xigncode</Filter>
    </ClInclude>
    <ClInclude Include="maplestory.hpp">
      <Filter>maplestory</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def">
      <Filter>spoof</Filter>
    </None>
  </ItemGroup>
</Project>
```

`xign_bypass/xigncode.cpp`:

```cpp
#include "xigncode.hpp"
#include "xigncode_callback.hpp"
#include "xigncode_manager.hpp"

#include <psapi.h>
#pragma comment(lib, "psapi")

#include <intrin.h>

namespace xigncode
{
	bool Hook_WideCharToMultiByte()
	{
		static decltype(&WideCharToMultiByte) _WideCharToMultiByte = &WideCharToMultiByte;

		decltype(&WideCharToMultiByte) WideCharToMultiByte_hook = [](UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar) -> int
		{
			if (lpWideCharStr)
			{
				if (wcsstr(lpWideCharStr, L" => "))
					xigncode_manager::get_instance().add_image(std::wstring(lpWideCharStr));
				
				if (!xigncode_manager::get_instance().is_spider_ok())
					if (wcsstr(lpWideCharStr, L"spider ok"))
						xigncode_manager::get_instance().set_spider_ok();
			}

			HMODULE module = NULL;
			
			if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<LPCSTR>(_ReturnAddress()), &module))
			{
				char module_file_name[1024];
				memset(module_file_name, 0, sizeof(module_file_name));

				if (GetModuleBaseName(GetCurrentProcess(), module, module_file_name, sizeof(module_file_name)) && lstrcmpi(module_file_name, "x3.xem") && !wcsstr(lpWideCharStr, L"0123456789:;<=>?"))
				{
					wchar_t log_output[1024];
					memset(log_output, 0, 1024 * sizeof(wchar_t));

					wsprintfW(log_output, L"[%08X] %ws\n", _ReturnAddress(), lpWideCharStr);
					OutputDebugStringW(log_output);
				}
			}

			return _WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_WideCharToMultiByte), WideCharToMultiByte_hook);
	}
	
	bool Hook_NtCreateSemaphore()
	{
		typedef NTSTATUS (NTAPI* NtCreateSemaphore_t)(PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG InitialCount, ULONG MaximumCount);
		static NtCreateSemaphore_t _NtCreateSemaphore = reinterpret_cast<NtCreateSemaphore_t>(GetProcAddress(GetModuleHandle("ntdll"), "NtCreateSemaphore"));
		
		NtCreateSemaphore_t NtCreateSemaphore_hook = [](PHANDLE SemaphoreHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG InitialCount, ULONG MaximumCount) -> NTSTATUS
		{
			if (ObjectAttributes && ObjectAttributes->ObjectName && ObjectAttributes->ObjectName->Buffer && !wcscmp(ObjectAttributes->ObjectName->Buffer, L"Global\\368457d19197f4eec4a257959dfdb062"))
					return _NtCreateSemaphore(SemaphoreHandle, DesiredAccess, NULL, InitialCount, MaximumCount);
			
			return _NtCreateSemaphore(SemaphoreHandle, DesiredAccess, ObjectAttributes, InitialCount, MaximumCount);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_NtCreateSemaphore), NtCreateSemaphore_hook);
	}

	bool Hook_NtOpenProcess()
	{
		typedef NTSTATUS (NTAPI* NtOpenProcess_t)(PHANDLE ProcessHandle, ACCESS_MASK AccessMask, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
		static NtOpenProcess_t _NtOpenProcess = reinterpret_cast<NtOpenProcess_t>(GetProcAddress(GetModuleHandle("ntdll"), "NtOpenProcess"));
		
		NtOpenProcess_t NtOpenProcess_hook = [](PHANDLE ProcessHandle, ACCESS_MASK AccessMask, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) -> NTSTATUS
		{
			if (ClientId->UniqueProcess != GetCurrentProcessId() || xigncode_manager::get_instance().is_spider_ok())
				return STATUS_ACCESS_DENIED;
			
			return _NtOpenProcess(ProcessHandle, AccessMask, ObjectAttributes, ClientId);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_NtOpenProcess), NtOpenProcess_hook);
	}
	
	bool Hook_NtOpenThread()
	{
		typedef NTSTATUS (NTAPI* NtOpenThread_t)(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
		static NtOpenThread_t _NtOpenThread = reinterpret_cast<NtOpenThread_t>(GetProcAddress(GetModuleHandle("ntdll"), "NtOpenThread"));
		
		NtOpenThread_t NtOpenThread_hook = [](PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) -> NTSTATUS
		{
			if (DesiredAccess & THREAD_QUERY_INFORMATION)
			{
				if (DesiredAccess == THREAD_ALL_ACCESS)
					DesiredAccess &= ~THREAD_QUERY_LIMITED_INFORMATION;

				DesiredAccess &= ~THREAD_QUERY_INFORMATION;
			}

			return _NtOpenThread(ThreadHandle, DesiredAccess, ObjectAttributes, ClientId);
		};

		return	function::redirect(true, reinterpret_cast<void**>(&_NtOpenThread), NtOpenThread_hook);
	}

	bool Hook_NtQuerySystemInformation()
	{
		static decltype(&NtQuerySystemInformation) _NtQuerySystemInformation = &NtQuerySystemInformation;

		decltype(&NtQuerySystemInformation) NtQuerySystemInformation_hook = [](SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength) -> NTSTATUS
		{
			if (SystemInformationClass == SystemProcessInformation && SystemInformation)
			{
				HMODULE module = 0;
				
				if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<LPCSTR>(_ReturnAddress()), &module))
				{
					NTSTATUS status = _NtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);

					if (status == STATUS_SUCCESS)
					{
						for (SYSTEM_PROCESS_INFORMATION* spi = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(SystemInformation); spi->NextEntryOffset != 0; 
							spi = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(reinterpret_cast<unsigned char*>(spi) + spi->NextEntryOffset))
						{
							memset(spi->ImageName.Buffer, 0, spi->ImageName.Length);
							memset(&spi->ImageName, 0, sizeof(UNICODE_STRING));
							spi->UniqueProcessId = 0;
							spi->InheritedFromUniqueProcessId = 0;
							spi->HandleCount = 0;
						}
					}

					return status;
				}
			}
			
			return _NtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
		};
		
		return function::redirect(true, reinterpret_cast<void**>(&_NtQuerySystemInformation), NtQuerySystemInformation_hook);
	}
	
	bool Hook_CreateProcessW()
	{
		static decltype(&CreateProcessW) _CreateProcessW = &CreateProcessW;

		decltype(&CreateProcessW) CreateProcessW_hook = [](LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, 
			BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation) -> BOOL
		{
			if (lpCommandLine && !_wcsicmp(lpCommandLine + wcslen(lpCommandLine) - 5, L".xem\""))
			{
				if (lpProcessInformation)
				{
					lpProcessInformation->dwProcessId = GetCurrentProcessId();
					lpProcessInformation->dwThreadId = GetCurrentThreadId();
					lpProcessInformation->hProcess = GetCurrentProcess();
					lpProcessInformation->hThread = GetCurrentThread();
				}

				return TRUE;
			}

			return _CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
				dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_CreateProcessW), CreateProcessW_hook);
	}
	
	bool Hook_DeviceIoControl()
	{
		static decltype(&DeviceIoControl) _DeviceIoControl = &DeviceIoControl;

		decltype(&DeviceIoControl) DeviceIoControl_hook = [](HANDLE hDevice, DWORD dwIoControlCode, void* lpInBuffer, DWORD nInBufferSize, void* lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped) -> BOOL
		{
			if (dwIoControlCode == FSCTL_QUERY_USN_JOURNAL)
				return FALSE;
			
			return _DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
		};
		
		return function::redirect(true, reinterpret_cast<void**>(&_DeviceIoControl), DeviceIoControl_hook);
	}
	
	bool Hook_StartServiceW()
	{
		static decltype(&StartServiceW) _StartServiceW = &StartServiceW;

		decltype(&StartServiceW) StartServiceW_hook = [](SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR* lpServiceArgVectors) -> BOOL
		{
			return TRUE;
		};
		
		return function::redirect(true, reinterpret_cast<void**>(&_StartServiceW), StartServiceW_hook);
	}
	
	void initialize_bypass()
	{
		Hook_EnterCriticalSection();
		Hook_WideCharToMultiByte();

		Hook_NtCreateSemaphore();
		Hook_NtOpenProcess();
		Hook_NtOpenThread();
		Hook_NtQuerySystemInformation();

		Hook_CreateProcessW();
		Hook_DeviceIoControl();
		Hook_StartServiceW();
	}
}
```

`xign_bypass/xigncode.hpp`:

```hpp
#pragma once

#include "generic.hpp"
#include "native.hpp"

namespace xigncode
{
	void initialize_bypass();
}
```

`xign_bypass/xigncode_callback.cpp`:

```cpp
#include "xigncode_callback.hpp"
#include "xigncode_manager.hpp"

#include <list>
#include <algorithm>

namespace xigncode
{
	CRITICAL_SECTION critical_section;

	void __stdcall detection_callback(void* arg0, void* arg4)
	{

	}
	
	bool __stdcall set_detection_callback(void** function_pointer)
	{
		static std::list<void**> function_pointer_list;

		EnterCriticalSection(&critical_section);

		if (std::find(function_pointer_list.begin(), function_pointer_list.end(), function_pointer) == function_pointer_list.end())
		{
			function_pointer_list.push_back(function_pointer);

			unsigned int function_address = reinterpret_cast<unsigned int>(*function_pointer);

			MEMORY_BASIC_INFORMATION mbi;
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));
			
			if (!VirtualQuery(function_pointer, &mbi, sizeof(MEMORY_BASIC_INFORMATION)))
				return false;
			
			/* see if the detection-callback requested is within xkaga */
			std::pair<unsigned int, unsigned int> xkaga_xem = xigncode_manager::get_instance().get_memory_image(L"xkaga.xem");

			if (xkaga_xem.first != 0 && xkaga_xem.second != 0)
			{
				if (xkaga_xem.first < function_address && function_address < (xkaga_xem.first + xkaga_xem.second))
				{
					// 0x0000AC8A initialization
					// 0x00009FE8 Create a structure?
					// 0x00009AC9 What is the prefetch 
					// 0x0000658A ds b
					// 0x0000E665 unknown 1
					// 0x0000F8E8 vms b
					// 0x00011E96 unknown 2
					// 0x00007E8A detection process

					//printf("xkaga hook: %08X (%08X, %08X)\n", function_address - xkaga_xem.first, xkaga_xem.first, xkaga_xem.second);

					if (function_address - xkaga_xem.first != 0x0000AC8A)
						xigncode_manager::get_instance().set_callback(mbi, function_pointer, detection_callback);
				}
			}		
			
			/* see if the detection-callback requested is within xdl */
			std::pair<unsigned int, unsigned int> xdl_xem = xigncode_manager::get_instance().get_memory_image(L"xdl.xem");
			
			if (xdl_xem.first != 0 && xdl_xem.second != 0)
			{
				if (xdl_xem.first < function_address && function_address < (xdl_xem.first + xdl_xem.second))
				{
					// 0x000141E0 running driver verifier

					//printf("xdl hook: %08X (%08X, %08X)\n", function_address - xdl_xem.first, xdl_xem.first, xdl_xem.second);
					
					if ((function_address - xdl_xem.first) == 0x000141E0)
						xigncode_manager::get_instance().set_callback(mbi, function_pointer, detection_callback);
				}
			}
		}

		LeaveCriticalSection(&critical_section);
		return true;
	}
	
	unsigned char* set_detection_callback_hook_address = nullptr;

	void __declspec(naked) set_detection_callback_hook()
	{
		__asm
		{
			pushad
			mov eax,[eax+0x08]
			mov eax,[eax]
			push eax
			call set_detection_callback
			popad
			jmp dword ptr[set_detection_callback_hook_address]
		}
	}

	bool Hook_EnterCriticalSection()
	{
		static decltype(&EnterCriticalSection) _EnterCriticalSection = &EnterCriticalSection;

		decltype(&EnterCriticalSection) EnterCriticalSection_hook = [](LPCRITICAL_SECTION lpCriticalSection) -> void
		{
			static bool is_done = false;

			if (!is_done)
			{
				unsigned int* return_address = reinterpret_cast<unsigned int*>(_ReturnAddress());

				if (*return_address == 0x78246483)
				{
					InitializeCriticalSection(&critical_section);

					set_detection_callback_hook_address = reinterpret_cast<unsigned char*>(return_address) + 0xD3; // 50 E8 ? ? ? ? FF 74 24 ? 8D 44 24 ? FF (xst)
				
					MEMORY_BASIC_INFORMATION mbi;
					memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));
					
					if (VirtualQuery(set_detection_callback_hook_address, &mbi, sizeof(MEMORY_BASIC_INFORMATION)))
					{
						xigncode_manager::get_instance().set_hook(mbi, reinterpret_cast<void**>(&set_detection_callback_hook_address), set_detection_callback_hook);
					}
					
					is_done = true;
				}
			}

			return _EnterCriticalSection(lpCriticalSection);
		};

		return function::redirect(true, reinterpret_cast<void**>(&_EnterCriticalSection), EnterCriticalSection_hook);
	}
}
```

`xign_bypass/xigncode_callback.hpp`:

```hpp
#pragma once

#include "generic.hpp"

namespace xigncode
{
	bool Hook_EnterCriticalSection();
}
```

`xign_bypass/xigncode_manager.cpp`:

```cpp
#include "xigncode_manager.hpp"
#include "xigncode_callback.hpp"

#include <regex>
#include <string>

bool xigncode_manager::add_image(std::wstring wide_string)
{
	if (wide_string.empty())
		return false;
		
	std::wregex rgx(L"(.+) ([a-zA-Z\\.]+) => ([0-9a-fA-F]{8})");
	std::wsmatch matches;

	if (std::regex_search(wide_string, matches, rgx))
	{
		try
		{
			unsigned int image_start = std::stoul(matches[3].str(), 0, 16);

			if (PIMAGE_DOS_HEADER(image_start)->e_magic != IMAGE_DOS_SIGNATURE)
				return false;

			if (PIMAGE_NT_HEADERS(image_start + PIMAGE_DOS_HEADER(image_start)->e_lfanew)->Signature != IMAGE_NT_SIGNATURE)
				return false;
				
			unsigned int image_size = PIMAGE_NT_HEADERS(image_start + PIMAGE_DOS_HEADER(image_start)->e_lfanew)->OptionalHeader.SizeOfCode;

			wprintf(L"finding... %ws (%08X, %08X)\n", matches[2].str().c_str(), image_start, image_size);
			this->images.push_back({ matches[2].str(), image_start, image_size });
			return true;
		}
		catch (...)	
		{ 

		}
	}

	return false;
}

std::pair<unsigned int, unsigned int> xigncode_manager::get_memory_image(std::wstring image_name)
{
	if (!image_name.empty())
		for (memory_image& image : this->images)
			if (image.name.compare(image_name) == 0)
				return std::make_pair(image.start, image.size);

	return std::make_pair<unsigned int, unsigned int>(0, 0);
}

void xigncode_manager::set_hook(MEMORY_BASIC_INFORMATION& mbi, void** function_pointer, void* hook_function)
{
	unsigned long old_protect = 0;

	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_READWRITE, &old_protect);
	function::redirect(true, function_pointer, hook_function);
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, old_protect, &old_protect);
}

void xigncode_manager::set_callback(MEMORY_BASIC_INFORMATION& mbi, void** function_pointer, void* callback_function)
{
	unsigned long old_protect = 0;

	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_READWRITE, &old_protect);
	*function_pointer = callback_function;
	VirtualProtect(mbi.BaseAddress, mbi.RegionSize, old_protect, &old_protect);
}

xigncode_manager::xigncode_manager()
	: spider_ok(false)
{

}

void xigncode_manager::set_spider_ok(bool is_ok)
{
	this->spider_ok = is_ok;
}

bool xigncode_manager::is_spider_ok()
{
	return this->spider_ok;
}
```

`xign_bypass/xigncode_manager.hpp`:

```hpp
#pragma once

#include "generic.hpp"

class xigncode_manager
{
public:
	static xigncode_manager& get_instance()
	{
		static xigncode_manager instance;
		return instance;
	}
			
	bool add_image(std::wstring wide_string);

	std::pair<unsigned int, unsigned int> get_memory_image(std::wstring image_name);
	
	void set_hook(MEMORY_BASIC_INFORMATION& mbi, void** function_pointer, void* hook_function);
	void set_callback(MEMORY_BASIC_INFORMATION& mbi, void** function_pointer, void* callback_function);

	void set_spider_ok(bool is_ok = true);
	bool is_spider_ok();

private:
	xigncode_manager();

	struct memory_image
	{
		std::wstring name;
		unsigned int start;
		unsigned int size;
	};

	std::vector<memory_image> images;
	bool spider_ok;
};
```