Project Path: arc_gmh5225_bedaisy-bypass_0459r_zr

Source Tree:

```txt
arc_gmh5225_bedaisy-bypass_0459r_zr
├── CMakeLists.txt
├── cmake
│   └── FindWdk.cmake
├── readme.md
└── src
    ├── driver
    │   ├── anticheat
    │   │   ├── battleye.cpp
    │   │   └── battleye.h
    │   ├── driver.cpp
    │   ├── driver.h
    │   └── hooks
    │       ├── execute_syscall.cpp
    │       ├── hooks.h
    │       ├── nt_create_file.cpp
    │       └── nt_read_file.cpp
    ├── main.cpp
    ├── pch.h
    └── util
        ├── util.cpp
        └── util.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.25.1 FATAL_ERROR)
set(PROJECT_NAME driver)
set(CMAKE_CXX_STANDARD 17)

project(${PROJECT_NAME})

list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)

get_filename_component(PROJECT_DIR ${CMAKE_CURRENT_SOURCE_DIR} ABSOLUTE)
set(OUTPUT_DIR ${PROJECT_DIR}/bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${OUTPUT_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${OUTPUT_DIR})
set(CMAKE_CURRENT_BINARY_DIR ${OUTPUT_DIR})
set(CMAKE_BINARY_DIR ${OUTPUT_DIR})
set(PROJECT_BINARY_DIR ${OUTPUT_DIR})
set(EXECUTABLE_OUTPUT_PATH ${OUTPUT_DIR})

find_package(WDK REQUIRED)

include_directories(${PROJECT_SOURCE_DIR}/src/)
include_directories(${WDK_ROOT}/Include/${WDK_INC_VERSION}/shared/)
include_directories(${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/)
include_directories(${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt/)

file(GLOB_RECURSE SRC_FILES ${PROJECT_SOURCE_DIR}/src/*.cpp)

wdk_add_driver(${PROJECT_NAME} KMDF 1.31 NTDDI_VERSION 0x0A000800 ${SRC_FILES})
target_precompile_headers(${PROJECT_NAME} PRIVATE src/pch.h)
```

`cmake/FindWdk.cmake`:

```cmake
# Redistribution and use is allowed under the OSI-approved 3-clause BSD license.
# Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

#.rst:
# FindWDK
# ----------
#
# This module searches for the installed Windows Development Kit (WDK) and
# exposes commands for creating kernel drivers and kernel libraries.
#
# Output variables:
# - `WDK_FOUND` -- if false, do not try to use WDK
# - `WDK_ROOT` -- where WDK is installed
# - `WDK_VERSION` -- the version of the selected WDK
# - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries
#        (default value is `0x0601` and can be changed per target or globally)
# - `WDK_NTDDI_VERSION` -- the NTDDI_VERSION used for kernel drivers and libraries,
#                          if not set, the value will be automatically calculated by WINVER
#        (default value is left blank and can be changed per target or globally)
#
# Example usage:
#
#   find_package(WDK REQUIRED)
#
#   wdk_add_library(KmdfCppLib STATIC KMDF 1.15
#       KmdfCppLib.h
#       KmdfCppLib.cpp
#       )
#   target_include_directories(KmdfCppLib INTERFACE .)
#
#   wdk_add_driver(KmdfCppDriver KMDF 1.15
#       Main.cpp
#       )
#   target_link_libraries(KmdfCppDriver KmdfCppLib)
#

if(DEFINED ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES
        "$ENV{WDKContentRoot}/Include/*/km/ntddk.h" # WDK 10
        "$ENV{WDKContentRoot}/Include/km/ntddk.h" # WDK 8.0, 8.1
    )
else()
    file(GLOB WDK_NTDDK_FILES
        "C:/Program Files*/Windows Kits/*/Include/*/km/ntddk.h" # WDK 10
        "C:/Program Files*/Windows Kits/*/Include/km/ntddk.h" # WDK 8.0, 8.1
    )
endif()

if(WDK_NTDDK_FILES)
    if (NOT CMAKE_VERSION VERSION_LESS 3.18.0)
        list(SORT WDK_NTDDK_FILES COMPARE NATURAL) # sort to use the latest available WDK
    endif()
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if (NOT WDK_LATEST_NTDDK_FILE)
    return()
endif()

get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
if (NOT WDK_ROOT MATCHES ".*/[0-9][0-9.]*$") # WDK 10 has a deeper nesting level
    get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY) # go up once more
    set(WDK_LIB_VERSION "${WDK_VERSION}")
    set(WDK_INC_VERSION "${WDK_VERSION}")
else() # WDK 8.0, 8.1
    set(WDK_INC_VERSION "")
    foreach(VERSION winv6.3 win8 win7)
        if (EXISTS "${WDK_ROOT}/Lib/${VERSION}/")
            set(WDK_LIB_VERSION "${VERSION}")
            break()
        endif()
    endforeach()
    set(WDK_VERSION "${WDK_LIB_VERSION}")
endif()

message(STATUS "WDK_ROOT: " ${WDK_ROOT})
message(STATUS "WDK_VERSION: " ${WDK_VERSION})

set(WDK_WINVER "0x0A00" CACHE STRING "Default WINVER for WDK targets")
set(WDK_NTDDI_VERSION "0x0A00" CACHE STRING "Specified NTDDI_VERSION for WDK targets if needed")

set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")

set(WDK_COMPILE_FLAGS
    "/Zp8" # set struct alignment
    "/GF"  # enable string pooling
    "/GR-" # disable RTTI
    "/Gz" # __stdcall by default
    "/kernel"  # create kernel mode binary
    "/FIwarning.h" # disable warnings in WDK headers
    "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
    "/MP"
    "/GS-"
    "/W4"
    "/Gy"
    "/Zc:wchar_t-"
    "/Zi"
    "/Gm-"
    "/O2"
    "/Zc:inline"
    "/fp:precise"
    "/WX-"
    "/Zc:forScope"
    "/Oy-"
    "/FC"
    "/Os"
    )

set(WDK_COMPILE_DEFINITIONS "WINNT=1")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
set(WDK_PLATFORM "x64")

string(CONCAT WDK_LINK_FLAGS
  "/MANIFEST:NO " #
  "/DRIVER " #
  "/DYNAMICBASE "
  "/RELEASE "
  "/OPT:REF " #
  "/INCREMENTAL:NO " #
  "/OPT:ICF " #
  "/SUBSYSTEM:NATIVE " #
  "/MERGE:_TEXT=.text;_PAGE=PAGE " #
  "/NODEFAULTLIB " # do not link default CRT
  "/VERSION:10.0 " #
  "/MACHINE:X64 "
  "/MAP "
)

# Generate imported targets for WDK lib files
file(GLOB WDK_LIBRARIES "${WDK_ROOT}/Lib/${WDK_LIB_VERSION}/km/${WDK_PLATFORM}/*.lib")
foreach(LIBRARY IN LISTS WDK_LIBRARIES)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES  ${LIBRARY})
endforeach(LIBRARY)
unset(WDK_LIBRARIES)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER;NTDDI_VERSION" "" ${ARGN})

    message(${WDK_NTDDI_VERSION})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
        )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")
    if(WDK_NTDDI_VERSION)
        target_compile_definitions(${_target} PRIVATE NTDDI_VERSION=${WDK_NTDDI_VERSION})
    endif()

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_INC_VERSION}/km/crt"
        )

    target_link_libraries(${_target} WDK::NTOSKRNL WDK::HAL WDK::BUFFEROVERFLOWK WDK::WMILIB)

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
        target_link_libraries(${_target}
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfDriverEntry.lib"
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfLdr.lib"
            )

            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:driver_entry")
    endif()
endfunction()
```

`readme.md`:

```md
# bedaisy-bypass

## Description

`bedaisy-bypass` is a kernel driver designed to bypass reports sent from `BEDaisy.sys` to `BEService.exe`. For users not on a UEFI, the project utilizes Infinity Hook. The driver intercepts data communicated through the named pipe between the two services. On receiving a request, the driver inspects the type of request, decrypts the returned data, and processes it accordingly. Due to the absence of expected data in the report buffers (as opposed to the main usermode shellcode), this mechanism can be exploited to decrypt, nullify, and then re-encrypt data. This ensures that no reports are sent back to the service, while still allowing for a response to be transmitted.

## Installation

1. Download Infinity Hook from [this repository](https://github.com/everdox/InfinityHook).
2. Integrate Infinity Hook into the project and configure it in `main.cpp` as per the provided instructions.
3. For UEFI users: If you are using UEFI, it's likely you have a mechanism in place to hook syscalls from a driver (utilizing `KiSystemServiceCopyEnd`). If so, you should be familiar with the subsequent steps.

## Credits

This project employs FindWDK for cmake, available at [this repository](https://github.com/SergiusTheBest/FindWDK).

```

`src/driver/anticheat/battleye.cpp`:

```cpp
#include "battleye.h"

namespace battleye {
  struct hwid_packet {
    uint8_t m_key; // 0x00
    int m_valid; // 0x01
    int m_process_id; // 0x05
    int m_windows_version_major; // 0x09
    int m_windows_version_minor; // 0x0D
    int m_windows_version; // 0x11
    double m_average_cpu_time; // 0x15
    double m_average_avx_time; // 0x1D
    double m_average_efer_time; // 0x25
    double m_average_cpu_time_delay_1; // 0x2D
    double m_average_avx_time_delay_1; // 0x35
    double m_average_efer_time_delay_1; // 0x3D
    double m_average_cpu_time_delay_2; // 0x45
    double m_average_avx_time_delay_2; // 0x4D
    double m_average_efer_time_delay_2; // 0x55
    char _0x005D[0x7C]; // all hv detection stuff
    uint32_t m_ia32_feature_control; // 0xD9
    int m_hypervisor_vendor_id_signature[3]; // 0xE1
    uint64_t m_cr4; //0xED
    char m_processor_name[0x30]; // 0xF5
    uint8_t m_hdd_serial_length; // 0x125

    char* serial() { return (char*)((uint64_t)&m_hdd_serial_length + 1); }
    char* smart_serial() { return (char*)((uint64_t)&m_hdd_serial_length + 1 + m_hdd_serial_length); }
  };

  struct thread_creation_data_packet {
    bool m_abnormal; // 0x00
    uint32_t m_thread_start_address; // 0x01
    uint64_t m_stack_info[8]; // 0x05
  };

  void crypt_read_irp(uint8_t* data, int size, int key) {
    bool end = false;
    int index = 0;
    int pre_key = key;

    while (index + 3 < size) {
      *(uint32_t*)&data[index] ^= pre_key ^ ~index;
      if (end) break;

      int post_key = pre_key;
      for (uint32_t i = 0; i < (index & 0x8000001F); i++)
        post_key /= 2;

      if (((uint8_t)(post_key) & 1) == 1)
        pre_key = ~(key + 1);
      else pre_key = key;

      uint8_t* pre_key_b = (uint8_t*)&pre_key;
      index += (pre_key_b[index & 0x80000003] & 3) + 1;

      while (index < size && index + 3 >= size) {
        index--;
        end = true;
      }
    }
  }

  void decrypt_report(uint8_t* data, int size, uint8_t init_key) {
    for (int i = size - 1; i >= 0; i--) {
      uint8_t key = 0;
      if (i > 0)
        key = ~(data[i - 1]);
      else key = init_key;
      data[i] ^= 0xA5 ^ (uint8_t)i ^ key;
    }
  }

  void decrypt_report_into(uint8_t* data, int size, uint8_t init_key, uint8_t* target) {
    for (int i = size - 1; i >= 0; i--) {
      uint8_t key = 0;
      if (i > 0)
        key = ~(data[i - 1]);
      else key = init_key;
      target[i] = data[i] ^ (uint8_t)0xA5 ^ (uint8_t)i ^ key;
    }
  }

  void decrypt_hardware_information(uint8_t* data) {
    for (uint32_t i = 0x16C; i > 0; i--) {
      uint8_t key = ~(data[i - 1]);
      if (i == 1) key = data[0];
      data[i] ^= 0xA5 ^ uint8_t(i - 1) ^ key;
    }
  }

  void encrypt_hardware_information(uint8_t* data) {
    uint8_t key = data[0];
    uint32_t index = 0;

    for (uint32_t i = 0; i < 0x16C; i++) {
      uint8_t next_key = (uint8_t)index ^ data[i + 1] ^ key ^ 0xA5;
      data[i + 1] = next_key;
      key = ~next_key;
      index = i + 1;
    }
  }

  void handle_packet(uint8_t* buffer, uint32_t size, int key) {
    switch (size) {
      case 0x208: { // report buffer
        // decrypt
        crypt_read_irp(buffer, size, key);

/*#ifdef DEV
        uint8_t* report_buffer = buffer;
        while (true) {
          uint16_t iteration_size = *(uint16_t*)&report_buffer[0];
          if (iteration_size == 0)
            break;
          
          report_buffer = &report_buffer[2];
          int report_key = *(int*)&report_buffer[0];

          decrypt_report(&report_buffer[4], iteration_size - 4, (uint8_t)report_key);

          LOG("[BattlEye - Report Packet] Report: %i", report_buffer[4]);

          report_buffer = &report_buffer[iteration_size];
        }
#endif*/

        // null out the buffer
        memset(buffer, 0, size);

        // encrypt
        crypt_read_irp(buffer, size, key);
        break;
      }

      /*case 0x3FC: { // hwid buffer
        // decrypt irp
        crypt_read_irp(buffer, size, key);

        // decrypt hwid
        decrypt_hardware_information(buffer);

        // modify if needed
        if (g_driver.m_spoofing.first) {
          hwid_packet* hpacket = (hwid_packet*)buffer;
          strcpy(hpacket->serial(), g_driver.m_serial_spoof_list.get(hpacket->serial()));
          strcpy(hpacket->smart_serial(), g_driver.m_serial_spoof_list.get(hpacket->smart_serial()));
        }

        // encrypt hwid
        encrypt_hardware_information(buffer);

        // encrypt irp
        crypt_read_irp(buffer, size, key);
        break;
      }*/

      case 0x45: { // latest thread created outside of game process data buffer
        // decrypt
        crypt_read_irp(buffer, size, key);

/*#ifdef DEV
        thread_creation_data_packet* packet = (thread_creation_data_packet*)buffer;
        LOG("[BattlEye - Thread Creation Packet] Abnormal: %i", packet->m_abnormal);
        LOG("[BattlEye - Thread Creation Packet] Thread Start Address: 0x%X", packet->m_thread_start_address);
#endif*/

        // null out the buffer
        memset(buffer, 0, size);

        // encrypt
        crypt_read_irp(buffer, size, key);
        break;
      }

      case 0x212: { // blocked file open info buffer
        // no handler needed
        break;
      }

      case 0x4: { // target process id
        // no handler needed
        break;
      }
    }
  }
};
```

`src/driver/anticheat/battleye.h`:

```h
#include "pch.h"
#include "driver/driver.h"

namespace battleye {
  void crypt_read_irp(uint8_t* data, int size, int key);
  void decrypt_report(uint8_t* data, int size, uint8_t init_key);
  void decrypt_report_into(uint8_t* data, int size, uint8_t init_key, uint8_t* target);
  void decrypt_hardware_information(uint8_t* data);
  void encrypt_hardware_information(uint8_t* data);

  void handle_packet(uint8_t* buffer, uint32_t size, int key);
};
```

`src/driver/driver.cpp`:

```cpp
#include "pch.h"
#include "driver.h"

bool driver::get_current_process_name(HANDLE proc, PUNICODE_STRING* name) {
  *name = (PUNICODE_STRING)ALLOCATE(512);
  if (*name != NULL) {
    if (NT_SUCCESS(g_driver.ZwQueryInformationProcess(proc, ProcessImageFileName, (PROCESS_BASIC_INFORMATION*)*name, 512, nullptr))) {
      return true;
    }
  }

  ExFreePoolWithTag(name, (ULONG)'BEBE');
  return false;
}
```

`src/driver/driver.h`:

```h
#pragma once
#include "pch.h"
#include "util/util.h"

enum eDriverEntryStatus : NTSTATUS {
  DriverEntrySuccess = 1,
  DriverEntryFailedResolvingFunctions,
  DriverEntryInvalidKernelBase,
  DriverEntryFailedKiSystemServiceTable,
  DriverEntryFailedSyscallTable,
};

template<typename R, typename T>
struct exported_function {
  T(*m_function);

  exported_function& operator=(uint64_t address) {
    m_function = (decltype(m_function))address;
    return *this;
  }

  bool operator==(uint64_t address) {
    return (uint64_t)m_function == address;
  }

  template<typename... Args>
  R operator()(Args... args) const {
    return m_function(static_cast<Args>(args)...);
  };
};

struct driver {
  pair<uint64_t, uint32_t> m_syscall_table_range {0, 0};
  HANDLE m_battleye {};

  // kernel
  exported_function<NTSTATUS, NTSTATUS(int, PVOID, ULONG, PULONG)> ZwQuerySystemInformation;
  exported_function<NTSTATUS, NTSTATUS(HANDLE, PROCESSINFOCLASS, PROCESS_BASIC_INFORMATION*, ULONG, PULONG)> ZwQueryInformationProcess;

  // syscall table
  exported_function<NTSTATUS, NTSTATUS(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG)> NtCreateFile;
  exported_function<NTSTATUS, NTSTATUS(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG)> NtReadFile;

  bool get_current_process_name(HANDLE proc, PUNICODE_STRING* name);
};

inline driver g_driver {};

#define RESOLVE(var) \
  g_driver.var = util::resolve(L#var); \
  if (g_driver.var == 0) \
    return DriverEntryFailedResolvingFunctions;

#define RESOLVE_SYSCALL(var) \
  g_driver.var = util::resolve_syscall(g_driver.m_syscall_table_range, #var); \
  if (g_driver.var == 0) \
    return DriverEntryFailedResolvingFunctions;
```

`src/driver/hooks/execute_syscall.cpp`:

```cpp
#include "hooks.h"
#include "driver/driver.h"

// function to pass to infinity hook
void hooks::execute_syscall(uint32_t index, void** function) {
  UNREFERENCED_PARAMETER(index);
  
  if (g_driver.NtCreateFile == (uint64_t)*function)
    *function = nt_create_file;
  
  if (g_driver.NtReadFile == (uint64_t)*function)
    *function = nt_read_file;
}
```

`src/driver/hooks/hooks.h`:

```h
#pragma once
#include "pch.h"

namespace hooks {
  void execute_syscall(uint32_t index, void** function);
  
  NTSTATUS nt_create_file(PHANDLE file_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, PIO_STATUS_BLOCK io_status_block, PLARGE_INTEGER allocation_size, ULONG file_attributes, ULONG share_access, ULONG create_disposition, ULONG create_options, PVOID ea_buffer, ULONG ea_length);
  NTSTATUS nt_read_file(HANDLE file_handle, HANDLE event, PIO_APC_ROUTINE apc_routine, PVOID apc_context, PIO_STATUS_BLOCK io_status_block, PVOID buffer, ULONG length, PLARGE_INTEGER byte_offset, PULONG key);
};
```

`src/driver/hooks/nt_create_file.cpp`:

```cpp
#include "hooks.h"
#include "driver/driver.h"

NTSTATUS hooks::nt_create_file(PHANDLE file_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes, PIO_STATUS_BLOCK io_status_block, PLARGE_INTEGER allocation_size, ULONG file_attributes, ULONG share_access, ULONG create_disposition, ULONG create_options, PVOID ea_buffer, ULONG ea_length) {
  NTSTATUS status = g_driver.NtCreateFile(file_handle, desired_access, object_attributes, io_status_block, allocation_size, file_attributes, share_access, create_disposition, create_options, ea_buffer, ea_length);
  if (!NT_SUCCESS(status))
    return status;

  if (object_attributes && object_attributes->ObjectName && object_attributes->ObjectName->Buffer) {
    if (wcsstr(object_attributes->ObjectName->Buffer, L"\\??\\BattlEye"))
      g_driver.m_battleye = *file_handle;
  }

  return status; 
}
```

`src/driver/hooks/nt_read_file.cpp`:

```cpp
#include "hooks.h"
#include "driver/driver.h"
#include "driver/anticheat/battleye.h"

NTSTATUS hooks::nt_read_file(HANDLE file_handle, HANDLE event, PIO_APC_ROUTINE apc_routine, PVOID apc_context, PIO_STATUS_BLOCK io_status_block, PVOID buffer, ULONG length, PLARGE_INTEGER byte_offset, PULONG key) {
  int battleye_key = 0;

  if (file_handle == g_driver.m_battleye && g_driver.m_battleye > 0 && buffer) {
    if (length > 0x04) {
      battleye_key = *(int*)buffer;
    }
  }
  
  NTSTATUS status = g_driver.NtReadFile(file_handle, event, apc_routine, apc_context, io_status_block, buffer, length, byte_offset, key);

  if (!NT_SUCCESS(status))
    return status;

  if (battleye_key > 0) {
    uint8_t* buffer_bytes = (uint8_t*)buffer;
    battleye::handle_packet(buffer_bytes, (uint32_t)length, battleye_key);
  }

  return status;
}
```

`src/main.cpp`:

```cpp
#include "pch.h"
#include "driver/driver.h"
#include "driver/hooks/hooks.h"
#include "util/util.h"

uint8_t KiSystemServiceTable[] = {
	0x4C, 0x8D, 0x3D, 0xCC, 0xCC, 0xCC, 0xCC, 0x41, 0xBC, 0xCC, 0xCC, 0xCC,
	0xCC, 0x4C, 0x8D, 0x77, 0x28, 0x41, 0x8B
};

uint8_t KiSystemServiceTable_Win11_22H2[] = {
  0x4C, 0x8D, 0x35, 0xCC, 0xCC, 0xCC, 0xCC, 0x41, 0xBC, 0xCC, 0xCC, 0xCC, 
  0xCC, 0x48, 0x8D, 0x70, 0x28, 0x41, 0x8B, 0x4E, 0xF8, 0x89, 0x4E, 0x0C, 
  0x4D, 0x8B, 0x3E
};

NTSTATUS driver_entry(_DRIVER_OBJECT* driver_object, PUNICODE_STRING registry_path) {
  UNREFERENCED_PARAMETER(driver_object);
  UNREFERENCED_PARAMETER(registry_path);

  // resolve functions
  RESOLVE(ZwQuerySystemInformation);
  RESOLVE(ZwQueryInformationProcess);

  system_module_information system_module_information;
  memset(&system_module_information, 0, sizeof(system_module_information));

  ULONG return_length {0};
  g_driver.ZwQuerySystemInformation(11, &system_module_information, (ULONG)sizeof(system_module_information), &return_length);
  if (!system_module_information.m_modules[0].m_image_base)
    return DriverEntryInvalidKernelBase;

  pair<uint64_t, uint32_t> kernel_range = { (uint64_t)system_module_information.m_modules[0].m_image_base, (uint32_t)system_module_information.m_modules[0].m_image_size };

  uint64_t ki_system_service_table = util::find_pattern(KiSystemServiceTable, sizeof(KiSystemServiceTable), kernel_range.first, kernel_range.second);
  if (!ki_system_service_table) {
    ki_system_service_table = util::find_pattern(KiSystemServiceTable_Win11_22H2, sizeof(KiSystemServiceTable_Win11_22H2), kernel_range.first, kernel_range.second);
    if (!ki_system_service_table)
      return DriverEntryFailedKiSystemServiceTable;
  }

  g_driver.m_syscall_table_range = {
    util::read_instruction(ki_system_service_table, 3, 7),
    *(uint32_t*)(ki_system_service_table + 0x9)
  };

  if (!g_driver.m_syscall_table_range.first)
    return DriverEntryFailedSyscallTable;

  g_driver.m_syscall_table_range.first -= 0x8;

  // resolve syscalls from the syscall table
  RESOLVE_SYSCALL(NtCreateFile);
  RESOLVE_SYSCALL(NtReadFile);

  // setup infinity hook here, pointing to `hooks::execute_syscall` :)

  return DriverEntrySuccess;
}
```

`src/pch.h`:

```h
#pragma once
#define _AMD64_
#define _WIN64
#define AMD64
#define _KERNEL_MODE

#pragma warning( disable : 4996 )

#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntdef.h>
#include <strsafe.h>
#include <ntdddisk.h>
#include <ntimage.h>
#include <wdm.h>
#include <ntddscsi.h>
#include <ata.h>
#include <scsi.h>
#include <ntddndis.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <classpnp.h>

extern "C" int _fltused = 1;

typedef UINT64 uint64_t;
typedef UINT8 uint8_t;
typedef UINT32 uint32_t;
typedef UINT16 uint16_t;

#define LOG(x, ...) DbgPrintEx(0, 0, x, __VA_ARGS__);

#define ALLOCATE(size) \
  util::allocate_memory((SIZE_T)size)
```

`src/util/util.cpp`:

```cpp
#include "pch.h"
#include "util.h"

namespace util {
  uint64_t resolve(const wchar_t* str) {
		UNICODE_STRING query_info = RTL_CONSTANT_STRING(str);
		RtlInitUnicodeString(&query_info, str);
		return (uint64_t)MmGetSystemRoutineAddress(&query_info);
	}

  uint32_t hash_syscall_name(const char* name) {
    char* pname = (char*)name + 2;
    uint32_t hash = 0;

    while (*pname) {
      hash = ((1025 * (hash + (char)*pname)) >> 6) ^ (1025 * (hash + (char)*pname));
      ++pname;
    }

    return hash;
  }

  uint64_t resolve_syscall(pair<uint64_t, uint32_t> range, const char* str) {
    uint32_t hash = hash_syscall_name(str);

    syscall_table* table = (syscall_table*)range.first;
    for (uint32_t i = 0; i < range.second; i++) {
      if (table[i].m_hash == hash)
        return table[i].m_function;
    }

    return 0;
  }

  PVOID allocate_memory(SIZE_T size) {
    return ExAllocatePoolWithTag(NonPagedPool, size, (ULONG)'BEBE');
  }

  uint64_t read_instruction(uint64_t address, int size, int length) {
    return (uint64_t)(*(int*)(address + size) + address + length);
  }

  bool data_compare(const uint8_t* data, const uint8_t* mask, const char* maskstr) {
    for (; *maskstr; ++maskstr, ++data, ++mask)
      if (*maskstr == 'x' && *data != *mask)
        return 0;
    return (*maskstr) == 0;
  }

  uint64_t find_pattern(uint8_t* pattern, uint32_t length, uint64_t base, uint32_t size) {
    if (!pattern || length == 0)
      return 0;
    
    char* mask = (char*)ALLOCATE(length + 1);
    if (!mask)
      return 0;

    memset(mask, 0, length + 1);

    for (uint32_t i = 0; i < length; i++)
      mask[i] = pattern[i] == 0xCC ? '?' : 'x';

    for (uint64_t i = 0; i < size; i++) {
      if (!MmIsAddressValid((uint8_t*)(base + i)))
        continue;

      if (!data_compare((uint8_t*)(base + i), pattern, mask))
        continue;

      ExFreePoolWithTag(mask, (ULONG)'BEBE');
      return (uint64_t)(base + i);
    }

    ExFreePoolWithTag(mask, (ULONG)'BEBE');
    return 0;
  }
}
```

`src/util/util.h`:

```h
#pragma once
#include "pch.h"

template<typename T1, typename T2>
struct pair {
  T1 first;
  T2 second;
};

struct syscall_table {
  uint32_t m_hash {0};
  uint32_t m_arg_count {0};
  uint64_t m_function {0};
};

struct system_module {
  char _0x0000[0x10];
	PVOID m_image_base;
	ULONG m_image_size;
  char _0x001C[0x10C];
};

struct system_module_information {
	ULONG m_module_count;
	system_module m_modules[1];
};

namespace util {
  PVOID allocate_memory(SIZE_T size);
  uint64_t resolve(const wchar_t* str);
  uint64_t resolve_syscall(pair<uint64_t, uint32_t> range, const char* str);
  uint64_t find_pattern(uint8_t* pattern, uint32_t length, uint64_t base, uint32_t size);
  uint64_t read_instruction(uint64_t address, int size, int length);
};
```