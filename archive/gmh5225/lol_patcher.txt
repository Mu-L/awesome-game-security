Project Path: arc_gmh5225_lol_patcher_wczqeodv

Source Tree:

```txt
arc_gmh5225_lol_patcher_wczqeodv
├── Makefile
├── README.md
├── injector
│   ├── Makefile
│   └── src
│       ├── D3dHook.cpp
│       ├── D3dHook.h
│       ├── Debug.h
│       ├── ExternConfig.cpp
│       ├── ExternConfig.h
│       ├── Process.cpp
│       ├── Process.h
│       ├── Shellcode.cpp
│       ├── Shellcode.h
│       ├── Signature.cpp
│       ├── Signature.h
│       └── main.cpp
├── screenshot.jpg
└── shellcode
    ├── Makefile
    └── src
        ├── CompileTime.h
        ├── Draw.cpp
        ├── Draw.h
        ├── Esp.cpp
        ├── Esp.h
        ├── GameApi.cpp
        ├── GameApi.h
        ├── GameLoop.cpp
        ├── GameLoop.h
        ├── GameObject.h
        ├── GameRenderer.h
        ├── GameString.h
        ├── Hash.h
        ├── HudManager.h
        ├── Log.cpp
        ├── Log.h
        ├── Math.cpp
        ├── Math.h
        ├── PEHeaders.cpp
        ├── PEHeaders.h
        ├── SpellBook.h
        ├── StringEncryption.h
        ├── Vector.h
        ├── WinApi.cpp
        ├── WinApi.h
        ├── chkstk.asm
        ├── faking_call_ret.asm
        ├── main.cpp
        ├── main.h
        ├── printf.cpp
        ├── printf.h
        ├── string.cpp
        └── string.h

```

`Makefile`:

```

all: out out/shellcode.dll out/inj.exe

out:
	mkdir -p out

out/inj.exe:
	cd injector && make
	cp injector/out/injector.exe out/inj.exe

out/shellcode.dll:
	cd shellcode && make
	cp shellcode/out/shellcode.dll out/shellcode.dll

clean:
	rm -f out/inj.exe
	rm -f out/shellcode.dll
	cd shellcode && make clean
	cd injector && make clean
```

`README.md`:

```md
# LoL Patcher

LoL Patcher is an old game mod designed for League of Legends. It's primarily
for educational purposes, created to explore and understand how certain cheat
mechanisms work. This tool has not been updated since February 2020 and was made
purely for experimentation and fun.

Technical Details:

- Injects itself into the game like shellcode (no PE headers, no standard libraries used)
- Memory scanning is performed externally by the injector
- Hooks the Direct3D C++ Virtual Table to display information on the screen
- Uses Return-Oriented Programming (ROP) to manipulate function return addresses
- Includes compile-time encryption for added obfuscation

Features:

- ESP (Extrasensory Perception) for characters and objects
- Last Hit Helper to assist in farming
- Displays skill level and cooldown indicators


## Screenshot

![Screenshot](screenshot.jpg)


# Building

On Ubuntu:

```sh
apt install mingw-w64 nasm
make
```
```

`injector/Makefile`:

```
mingw_lib = $(wildcard /opt/lib/gcc/i686-w64-mingw32/*)
src_cpp = $(wildcard src/*.cpp)
obj_cpp = $(patsubst src/%.cpp,out/%.o,$(src_cpp))
src_asm = $(wildcard src/*.asm)
obj_asm = $(patsubst src/%.asm,out/%.o,$(src_asm))
gpp_flags = -m32 -static
ld_deps_dirs = -L$(mingw_lib) \
               -L/opt/i686-w64-mingw32/lib
ld_deps = -lstdc++ -lpsapi
 
all: out $(obj_asm)
	i686-w64-mingw32-g++ $(gpp_flags) -o out/injector.exe $(obj_asm) $(src_cpp) $(ld_deps) 

out:
	mkdir -p out

out/%.o: src/%.asm
	nasm -f elf -o $@ $<

clean:
	rm -f out/*.o
	rm -f out/injector.exe
```

`injector/src/D3dHook.cpp`:

```cpp
#include "D3dHook.h"
#include "Debug.h"

D3dHook::D3dHook(std::shared_ptr<Process> process) {
  process_ = std::move(process);
}

bool D3dHook::LoadDeviceVtable(const Signature* signature) {
  d3d_vtable_.clear();

  DWORD d3d_device = signature->GetD3DDevice(process_.get());
  debug_printf("d3d_device = 0x%08X\n", d3d_device);
  d3d_device_addr_ = d3d_device;

  DWORD d3d_device_vtable = 0;
  if (!process_->ReadProcMem(d3d_device, &d3d_device_vtable, sizeof(d3d_device_vtable))) {
    debug_printf("Cannot read D3D device vtable\n");
    return false;
  }
  debug_printf("d3d_device_vtable = 0x%08X\n", d3d_device_vtable);

  DWORD d3d_vtable_count = static_cast<DWORD>(D3dVtableMembers::VtableSize);
  d3d_vtable_.resize(d3d_vtable_count);
  if (!process_->ReadProcMem(d3d_device_vtable, d3d_vtable_.data(), d3d_vtable_count * sizeof(d3d_vtable_[0]))) {
    debug_printf("Cannot read D3D device vtable\n");
    d3d_vtable_.clear();
    return false;
  }
  d3d_vtable_original_addr_ = d3d_device_vtable;
  d3d_vtable_addr_ = d3d_device_vtable;

  return true;
}

DWORD D3dHook::GetMemberAddr(D3dVtableMembers member) const {
  if (!d3d_vtable_.size()) {
    debug_printf("Load the device vtable before\n");
    return 0;
  }
  return d3d_vtable_[static_cast<DWORD>(member)];
}

bool D3dHook::MoveVtable() {
  if (!d3d_vtable_.size()) {
    debug_printf("Load the device vtable before\n");
    return 0;
  }
  DWORD vtable_size = d3d_vtable_.size() * sizeof(d3d_vtable_[0]);

  // Allocate the new vtable
  DWORD new_vtable_addr = process_->VirtualAlloc(0, vtable_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  if (!new_vtable_addr) {
    debug_printf("Failed to allocate the new vtable\n");
    return false;
  }
  debug_printf("New vtable addr: 0x%08X\n", new_vtable_addr);

  // Copy the data inside this new vtable
  bool success = process_->WriteProcMem(new_vtable_addr, d3d_vtable_.data(), vtable_size);
  if (!success) {
    debug_printf("Can't write the new vtable\n");
    return false;
  }

  // Set the vtable read only
  success = process_->VirtualProtect(new_vtable_addr, vtable_size, PAGE_READONLY);
  if (!success) {
    debug_printf("Can't change the new vtable to read-only\n");
    return false;
  }

  // Update the vtable pointer
  success = process_->WriteProcMem(d3d_device_addr_, &new_vtable_addr, sizeof(new_vtable_addr));
  if (!success) {
    debug_printf("Can't write the vtable pointer\n");
    return false;
  }
  d3d_vtable_addr_ = new_vtable_addr;

  return true;
}

bool D3dHook::RestoreVtable() {
  bool success =
      process_->WriteProcMem(d3d_device_addr_, &d3d_vtable_original_addr_, sizeof(d3d_vtable_original_addr_));
  if (!success) {
    debug_printf("Can't write the vtable pointer\n");
    return false;
  }

  d3d_vtable_addr_ = d3d_vtable_original_addr_;
  return true;
}

bool D3dHook::HookMember(D3dVtableMembers member, DWORD new_addr) {
  // Set the vtable to read-write
  DWORD vtable_size = d3d_vtable_.size() * sizeof(d3d_vtable_[0]);
  bool success = process_->VirtualProtect(d3d_vtable_addr_, vtable_size, PAGE_READWRITE);
  if (!success) {
    debug_printf("Can't change the vtable to read-write\n");
    return false;
  }

  DWORD function_pointer_addr = d3d_vtable_addr_ + static_cast<DWORD>(member) * sizeof(DWORD);
  success = process_->WriteProcMem(function_pointer_addr, &new_addr, sizeof(new_addr));
  if (!success) {
    debug_printf("Can't write the method pointer in the vtable\n");
    return false;
  }

  debug_printf("HookMember: *0x%08X = 0x%08X\n", function_pointer_addr, new_addr);
  d3d_vtable_[static_cast<DWORD>(member)] = new_addr;

  // Set the vtable read only
  success = process_->VirtualProtect(d3d_vtable_addr_, vtable_size, PAGE_READONLY);
  if (!success) {
    debug_printf("Can't change the vtable to read-only\n");
    return false;
  }

  return true;
}
```

`injector/src/D3dHook.h`:

```h
#pragma once
#include "Process.h"
#include "Signature.h"

class D3dHook {
 public:
  enum class D3dVtableMembers {
    QueryInterface = 0,
    AddRef = 1,
    Release = 2,
    TestCooperativeLevel = 3,
    GetAvailableTextureMem = 4,
    EvictManagedResources = 5,
    GetDirect3D = 6,
    GetDeviceCaps = 7,
    GetDisplayMode = 8,
    GetCreationParameters = 9,
    SetCursorProperties = 10,
    SetCursorPosition = 11,
    ShowCursor = 12,
    CreateAdditionalSwapChain = 13,
    GetSwapChain = 14,
    GetNumberOfSwapChains = 15,
    Reset = 16,
    Present = 17,
    GetBackBuffer = 18,
    GetRasterStatus = 19,
    SetDialogBoxMode = 20,
    SetGammaRamp = 21,
    GetGammaRamp = 22,
    CreateTexture = 23,
    CreateVolumeTexture = 24,
    CreateCubeTexture = 25,
    CreateVertexBuffer = 26,
    CreateIndexBuffer = 27,
    CreateRenderTarget = 28,
    CreateDepthStencilSurface = 29,
    UpdateSurface = 30,
    UpdateTexture = 31,
    GetRenderTargetData = 32,
    GetFrontBufferData = 33,
    StretchRect = 34,
    ColorFill = 35,
    CreateOffscreenPlainSurface = 36,
    SetRenderTarget = 37,
    GetRenderTarget = 38,
    SetDepthStencilSurface = 39,
    GetDepthStencilSurface = 40,
    BeginScene = 41,
    EndScene = 42,
    Clear = 43,
    SetTransform = 44,
    GetTransform = 45,
    MultiplyTransform = 46,
    SetViewport = 47,
    GetViewport = 48,
    SetMaterial = 49,
    GetMaterial = 50,
    SetLight = 51,
    GetLight = 52,
    LightEnable = 53,
    GetLightEnable = 54,
    SetClipPlane = 55,
    GetClipPlane = 56,
    SetRenderState = 57,
    GetRenderState = 58,
    CreateStateBlock = 59,
    BeginStateBlock = 60,
    EndStateBlock = 61,
    SetClipStatus = 62,
    GetClipStatus = 63,
    GetTexture = 64,
    SetTexture = 65,
    GetTextureStageState = 66,
    SetTextureStageState = 67,
    GetSamplerState = 68,
    SetSamplerState = 69,
    ValidateDevice = 70,
    SetPaletteEntries = 71,
    GetPaletteEntries = 72,
    SetCurrentTexturePalette = 73,
    GetCurrentTexturePalette = 74,
    SetScissorRect = 75,
    GetScissorRect = 76,
    SetSoftwareVertexProcessing = 77,
    GetSoftwareVertexProcessing = 78,
    SetNPatchMode = 79,
    GetNPatchMode = 80,
    DrawPrimitive = 81,
    DrawIndexedPrimitive = 82,
    DrawPrimitiveUP = 83,
    DrawIndexedPrimitiveUP = 84,
    ProcessVertices = 85,
    CreateVertexDeclaration = 86,
    SetVertexDeclaration = 87,
    GetVertexDeclaration = 88,
    SetFVF = 89,
    GetFVF = 90,
    CreateVertexShader = 91,
    SetVertexShader = 92,
    GetVertexShader = 93,
    SetVertexShaderConstantF = 94,
    GetVertexShaderConstantF = 95,
    SetVertexShaderConstantI = 96,
    GetVertexShaderConstantI = 97,
    SetVertexShaderConstantB = 98,
    GetVertexShaderConstantB = 99,
    SetStreamSource = 100,
    GetStreamSource = 101,
    SetStreamSourceFreq = 102,
    GetStreamSourceFreq = 103,
    SetIndices = 104,
    GetIndices = 105,
    CreatePixelShader = 106,
    SetPixelShader = 107,
    GetPixelShader = 108,
    SetPixelShaderConstantF = 109,
    GetPixelShaderConstantF = 110,
    SetPixelShaderConstantI = 111,
    GetPixelShaderConstantI = 112,
    SetPixelShaderConstantB = 113,
    GetPixelShaderConstantB = 114,
    DrawRectPatch = 115,
    DrawTriPatch = 116,
    DeletePatch = 117,
    CreateQuery = 118,
    VtableSize = 174
  };

  D3dHook(std::shared_ptr<Process> process);
  bool LoadDeviceVtable(const Signature* signature);
  bool MoveVtable();
  bool RestoreVtable();
  DWORD GetMemberAddr(D3dVtableMembers member) const;
  bool HookMember(D3dVtableMembers member, DWORD new_addr);

  DWORD d3d9_device() { return d3d_device_addr_; }

 private:
  std::shared_ptr<Process> process_;
  DWORD d3d_device_addr_;
  std::vector<DWORD> d3d_vtable_;
  DWORD d3d_vtable_addr_;
  DWORD d3d_vtable_original_addr_;
};
```

`injector/src/Debug.h`:

```h
#pragma once

#include <stdio.h>

#ifndef NO_DEBUG
#define debug_printf(...) fprintf(stderr, __VA_ARGS__)
#else
#define debug_printf while (0)
#endif
```

`injector/src/ExternConfig.cpp`:

```cpp
#include "ExternConfig.h"

ExternConfig::ExternConfig() {
  memset(&config_, 0, sizeof(config_));
}

std::vector<char> ExternConfig::GetConfigBlob() const {
  const char* config = reinterpret_cast<const char*>(&config_);
  std::vector<char> blob(config, config + sizeof(config_));
  return blob;
}
```

`injector/src/ExternConfig.h`:

```h
#pragma once
#include <windows.h>
#include <vector>

class ExternConfig {
 public:
  ExternConfig();
  std::vector<char> GetConfigBlob() const;

  void fn_end_scene(DWORD v) { config_.fn_end_scene = v; }
  void fn_reset(DWORD v) { config_.fn_reset = v; }
  void kernel32(DWORD v) { config_.kernel32 = v; }
  void d3d9_device(DWORD v) { config_.d3d9_device = v; }
  void objects_manager(DWORD v) { config_.objects_manager = v; }
  void pop_ret(DWORD v) { config_.pop_ret = v; }
  void local_player(DWORD v) { config_.local_player = v; }
  void game_renderer(DWORD v) { config_.game_renderer = v; }
  void world_to_screen(DWORD v) { config_.world_to_screen = v; }
  void draw_circle(DWORD v) { config_.draw_circle = v; }
  void game_time(DWORD v) { config_.game_time = v; }
  void issue_order(DWORD v) { config_.issue_order = v; }
  void cast_spell(DWORD v) { config_.cast_spell = v; }
  void hud_instance(DWORD v) { config_.hud_instance = v; }

 private:
#pragma pack(push)
#pragma pack(1)
  struct PackedConfig {
    DWORD fn_end_scene;
    DWORD fn_reset;
    DWORD kernel32;
    DWORD d3d9_device;
    DWORD objects_manager;
    DWORD pop_ret;
    DWORD local_player;
    DWORD game_renderer;
    DWORD world_to_screen;
    DWORD draw_circle;
    DWORD game_time;
    DWORD issue_order;
    DWORD cast_spell;
    DWORD hud_instance;
  };
#pragma pack(pop)

  PackedConfig config_;
};
```

`injector/src/Process.cpp`:

```cpp
#include "Process.h"
#define NO_DEBUG
#include "Debug.h"

#include <psapi.h>

// static
std::unique_ptr<Process> Process::GetProcessByName(const wchar_t* target_name) {
  DWORD pids[1024];
  DWORD cb_needed = 0;
  if (!EnumProcesses(pids, sizeof(pids), &cb_needed)) {
    debug_printf("EnumProcesses error\n");
    return NULL;
  }

  HANDLE process;
  HMODULE module;
  wchar_t process_name[MAX_PATH] = {0};
  const DWORD nb_process = cb_needed / sizeof(*pids);

  for (DWORD i = 0; i < nb_process; i++) {
    process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE,
                          pids[i]);
    if (!process) {
      continue;
    }
    if (!EnumProcessModules(process, &module, sizeof(module), &cb_needed) || !cb_needed) {
      CloseHandle(process);
      continue;
    }

    // Only the first module is interesting at the moment
    process_name[0] = '\0';
    if (!GetModuleBaseNameW(process, module, process_name, _countof(process_name))) {
      continue;
    }

    if (_wcsicmp(process_name, target_name) == 0) {
      return std::make_unique<Process>(process);
    }

    CloseHandle(process);
  }

  return NULL;
}

Process::Process(HANDLE process_handle) : process_handle_(process_handle) {}
Process::~Process() {
  CloseHandle(process_handle_);
}

DWORD Process::GetModuleBase(const wchar_t* target_name, size_t* out_module_size) const {
  if (!process_handle_) {
    return 0;
  }

  HMODULE modules[1024];
  DWORD cb_needed = 0;
  bool success = EnumProcessModules(process_handle_, modules, sizeof(modules), &cb_needed);
  if (!success || !cb_needed) {
    return 0;
  }

  const DWORD nb_modules = cb_needed / sizeof(modules[0]);
  wchar_t module_name[MAX_PATH] = {0};
  for (size_t i = 0; i < nb_modules; i++) {
    if (!GetModuleBaseNameW(process_handle_, modules[i], module_name, _countof(module_name))) {
      return 0;
    }

    if (_wcsicmp(module_name, target_name) == 0) {
      MODULEINFO modinfo;
      if (!GetModuleInformation(process_handle_, modules[i], &modinfo, sizeof(modinfo))) {
        return 0;
      }

      if (out_module_size) {
        *out_module_size = modinfo.SizeOfImage;
      }
      return reinterpret_cast<DWORD>(modinfo.lpBaseOfDll);
    }
  }

  return 0;
}

bool Process::DumpCodeSectionFromModule(DWORD module_base,
                                        size_t module_size,
                                        std::vector<char>& out_buffer,
                                        DWORD* code_section_addr) const {
  if (!process_handle_) {
    return false;
  }
  out_buffer.clear();

  IMAGE_DOS_HEADER dos_header;
  if (!ReadProcMem(module_base, &dos_header, sizeof(dos_header))) {
    debug_printf("DumpCodeSectionFromModule: Can't read DOS header\n");
    return false;
  }
  if (dos_header.e_magic != 0x5a4d) {
    debug_printf("DumpCodeSectionFromModule: Invalid DOS signature\n");
    return false;
  }

  IMAGE_NT_HEADERS32 nt_headers;
  if (!ReadProcMem(module_base + dos_header.e_lfanew, &nt_headers, sizeof(nt_headers))) {
    debug_printf("DumpCodeSectionFromModule: Can't read NT headers\n");
    return false;
  }
  if (nt_headers.Signature != 0x00004550) {
    debug_printf("DumpCodeSectionFromModule: Invalid NT signature\n");
    return false;
  }
  debug_printf("Numbers of section: %d\n", nt_headers.FileHeader.NumberOfSections);
  debug_printf("Base of code: %d\n", nt_headers.OptionalHeader.BaseOfCode);

  auto section_table = std::make_unique<IMAGE_SECTION_HEADER[]>(nt_headers.FileHeader.NumberOfSections);
  bool success = ReadProcMem(module_base + dos_header.e_lfanew + sizeof(nt_headers), section_table.get(),
                             sizeof(IMAGE_SECTION_HEADER) * nt_headers.FileHeader.NumberOfSections);
  if (!success) {
    debug_printf("DumpCodeSectionFromModule: Can't get the sections\n");
    return false;
  }

  IMAGE_SECTION_HEADER* section_code = nullptr;
  for (size_t i = 0; i < nt_headers.FileHeader.NumberOfSections; i++) {
    if (section_table[i].VirtualAddress == nt_headers.OptionalHeader.BaseOfCode) {
      section_code = &section_table[i];
    }
  }
  if (!section_code) {
    debug_printf("DumpCodeSectionFromModule: Code section not found\n");
    return false;
  }

  DWORD code_addr = module_base + section_code->VirtualAddress;
  DWORD code_size = section_code->SizeOfRawData;
  DWORD code_limit_addr = code_addr + code_size;
  debug_printf("Section code of size 0x%x at [0x%08X - 0x%08X]\n", code_size, code_addr, code_limit_addr);

  if (code_section_addr) {
    *code_section_addr = code_addr;
  }

  // Now dump all the memory segments inside the code section which have a
  // different protection that NO_ACCESS
  MEMORY_BASIC_INFORMATION meminfo;
  DWORD target_addr = code_addr;
  DWORD allocation_base = 0;
  DWORD allocation_size = 0;

  while (target_addr < code_limit_addr) {
    if (!VirtualQueryEx(process_handle_, reinterpret_cast<LPCVOID>(target_addr), &meminfo, sizeof(meminfo))) {
      debug_printf("Cannot get memory info at 0x%08X", target_addr);
      return false;
    }
    allocation_base = reinterpret_cast<DWORD>(meminfo.BaseAddress);
    allocation_size = meminfo.RegionSize;
    char* temp_buffer = new char[allocation_size];
    if (meminfo.State & MEM_COMMIT && meminfo.Protect != PAGE_NOACCESS) {
      if (!ReadProcMem(allocation_base, temp_buffer, allocation_size)) {
        debug_printf("Failed to dump 0x%08X\n", allocation_base);
        return false;
      }
    } else {
      memset(temp_buffer, 0, allocation_size);
    }

    out_buffer.insert(out_buffer.end(), temp_buffer, temp_buffer + allocation_size);
    delete[] temp_buffer;
    target_addr += allocation_size;
  }

  return true;
}

DWORD Process::VirtualAlloc(DWORD address, size_t size, DWORD allocation_type, DWORD protect) const {
  void* result = VirtualAllocEx(process_handle_, reinterpret_cast<LPVOID>(address), size, allocation_type, protect);
  return reinterpret_cast<DWORD>(result);
}

bool Process::VirtualProtect(DWORD addr, size_t size, DWORD new_protect) const {
  DWORD old_protect;
  return VirtualProtectEx(process_handle_, reinterpret_cast<LPVOID>(addr), size, new_protect, &old_protect);
}

bool Process::WriteProcMem(DWORD addr, void* buffer, size_t size) const {
  SIZE_T bytes_written = 0;
  bool success = WriteProcessMemory(process_handle_, reinterpret_cast<LPVOID>(addr), buffer, size, &bytes_written);
  return success && bytes_written > 0;
}

bool Process::MemSet(DWORD addr, unsigned char value, size_t size) const {
  unsigned char* block = new unsigned char[size];
  memset(block, value, size);
  bool success = WriteProcMem(addr, block, size);
  delete[] block;
  return success;
}

bool Process::CreateThreadAndWait(DWORD start_addr) const {
  HANDLE thread =
      CreateRemoteThread(process_handle_, NULL, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(start_addr), NULL, 0, NULL);
  if (thread) {
    WaitForSingleObject(thread, INFINITE);
  }
  return thread;
}
```

`injector/src/Process.h`:

```h
#pragma once
#include <windows.h>
#include <memory>
#include <vector>

class Process {
 public:
  static std::unique_ptr<Process> GetProcessByName(const wchar_t* target_name);
  Process(HANDLE process_handle);
  ~Process();

  DWORD GetModuleBase(const wchar_t* target_name, size_t* out_module_size = nullptr) const;
  bool DumpCodeSectionFromModule(DWORD module_base,
                                 size_t module_size,
                                 std::vector<char>& out_buffer,
                                 DWORD* code_section_addr = nullptr) const;
  DWORD VirtualAlloc(DWORD address, size_t size, DWORD allocation_type, DWORD protect) const;
  bool VirtualProtect(DWORD addr, size_t size, DWORD new_protect) const;
  bool WriteProcMem(DWORD addr, void* buffer, size_t size) const;
  bool MemSet(DWORD addr, unsigned char value, size_t size) const;
  bool CreateThreadAndWait(DWORD start_addr) const;

  template <typename T>
  size_t ReadProcMem(DWORD addr, T* obj, size_t obj_size) const {
    if (!process_handle_) {
      return 0;
    }

    DWORD nb_bytes_read = 0;
    bool success = ReadProcessMemory(process_handle_, reinterpret_cast<PVOID>(addr), obj, obj_size, &nb_bytes_read);
    if (!success) {
      return 0;
    }
    return nb_bytes_read;
  }

 private:
  HANDLE process_handle_;
};
```

`injector/src/Shellcode.cpp`:

```cpp
#include "Shellcode.h"
#define NO_DEBUG
#include <windows.h>
#include "Debug.h"

#define SHELLCODE_DLL L"shellcode.dll"
#define ADDR_IS_BTW(addr, down, up) ((addr) >= (down) && (addr) <= (up))

Shellcode::Shellcode() : buffer_(nullptr), buffer_size_(0) {}

/**
  Read and map 'shellcode.dll' in memory.
*/
bool Shellcode::Map() {
  wchar_t filepath[1024];
  size_t path_pos = GetModuleFileNameW(NULL, filepath, sizeof(filepath));
  while (filepath[path_pos] != '\\') {
    path_pos--;
  }
  wcscpy(&filepath[path_pos + 1], SHELLCODE_DLL);

  HANDLE file = CreateFileW(filepath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (file == INVALID_HANDLE_VALUE) {
    debug_printf("Cannot open '%ls': 0x%x\n", filepath, GetLastError());
    return false;
  }

  size_t filesize = 0;
  DWORD filesize_high;
  DWORD filesize_low = GetFileSize(file, &filesize_high);
  if (filesize_low == INVALID_FILE_SIZE) {
    debug_printf("GetFileSize failed: 0x%x\n", GetLastError());
    return false;
  }
  filesize = filesize_low + filesize_high * 0x10000;
  debug_printf("Shellcode size: 0x%x\n", filesize);

  void* buffer = VirtualAlloc(NULL, filesize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  if (!buffer) {
    debug_printf("VirtualAlloc failed\n");
    CloseHandle(file);
    return false;
  }

  DWORD nb_reads = 0;
  bool success = ReadFile(file, buffer, filesize, &nb_reads, NULL);
  if (!success || !nb_reads) {
    debug_printf("ReadFile failed: 0x%x\n", GetLastError());
    VirtualFree(buffer, 0, MEM_RELEASE);
    CloseHandle(file);
    return false;
  }

  CloseHandle(file);
  buffer_ = reinterpret_cast<unsigned char*>(buffer);
  buffer_size_ = filesize;
  debug_printf("Shellcode mapped at 0x%p (size = 0x%x)\n", buffer_, buffer_size_);
  return true;
}

/**
  Inject a PE executable like a shellcode. It loads sections with an arbitrary
  image base, fix the relocations but doesn't import the IAT or EAT and doesn't
  write the PE headers to not be easily detected.
 */
bool Shellcode::InjectInProcess(Process* process, const ExternConfig* config, DWORD* new_end_scene, DWORD* new_reset) {
  if (!buffer_) {
    debug_printf("Map() the shellcode before injecting it\n");
    return false;
  }
  if (!process) {
    debug_printf("Invalid process\n");
    return false;
  }

  // Get the tables. No need to check the headers: we have created this file
  DWORD base = reinterpret_cast<DWORD>(buffer_);
  auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos_header->e_lfanew);
  auto* section_table = reinterpret_cast<IMAGE_SECTION_HEADER*>(base + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));

  DWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
  IMAGE_SECTION_HEADER* reloc_section = nullptr;

  // Allocating the space in memory
  debug_printf("Reserving 0x%x bytes\n", nt_headers->OptionalHeader.SizeOfImage);
  DWORD new_imagebase = process->VirtualAlloc(0, nt_headers->OptionalHeader.SizeOfImage, MEM_RESERVE, PAGE_NOACCESS);
  if (!new_imagebase) {
    debug_printf("Cannot allocate space for all the image\n");
    return false;
  }
  debug_printf("New image base: 0x%x\n", new_imagebase);

  // Map all the sections and search the relocation table
  debug_printf("Mapping the sections\n");
  for (size_t i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
    if (section_table[i].VirtualAddress == reloc_va) {
      debug_printf("  Relocation section found\n");
      reloc_section = &section_table[i];
      continue;
    }

    // Allocating the section
    DWORD target_addr = new_imagebase + section_table[i].VirtualAddress;
    size_t allocation_size = section_table[i].SizeOfRawData;
    if (section_table[i].Misc.VirtualSize > section_table[i].SizeOfRawData) {
      allocation_size = section_table[i].Misc.VirtualSize;
    }

    debug_printf("  Allocating the section '%s' at 0x%08X of size 0x%08x\n", section_table[i].Name, target_addr,
                 allocation_size);
    DWORD success = process->VirtualAlloc(target_addr, allocation_size, MEM_COMMIT, PAGE_READWRITE);
    if (!success) {
      debug_printf("    Cannot allocate the section\n");
      return false;
    }
    process->MemSet(target_addr, 0, allocation_size);

    // Copy the data
    void* src = reinterpret_cast<void*>(base + section_table[i].PointerToRawData);
    size_t copy_size = section_table[i].SizeOfRawData;
    if (section_table[i].Misc.VirtualSize < section_table[i].SizeOfRawData) {
      copy_size = section_table[i].Misc.VirtualSize;
    }
    debug_printf("    Copy 0x%x bytes from 0x%p to 0x%08X\n", copy_size, src, target_addr);
    process->WriteProcMem(target_addr, src, copy_size);
  }

  // Now we do the relocations
  if (!reloc_section) {
    debug_printf("Relocation section not found\n");
    return false;
  }

  char* relocs = reinterpret_cast<char*>(base + reloc_section->PointerToRawData);
  char* relocs_end = relocs + reloc_section->Misc.VirtualSize;
  debug_printf("Parsing relocs from 0x%p to 0x%p\n", relocs, relocs_end);

  while (relocs < relocs_end) {
    const DWORD* base_block_header = reinterpret_cast<DWORD*>(relocs);
    DWORD reloc_page_rva = base_block_header[0];
    DWORD reloc_block_size = base_block_header[1];

    auto* relocs_array = reinterpret_cast<const WORD*>(relocs + 2 * sizeof(DWORD));
    DWORD nb_relocs = (reloc_block_size - 2 * sizeof(DWORD)) / sizeof(WORD);

    debug_printf("  %d relocs (block_size = 0x%x) to proceed starting at 0x08%x\n", nb_relocs, reloc_block_size,
                 reloc_page_rva);
    for (size_t i = 0; i < nb_relocs; i++) {
      WORD type = (relocs_array[i] & 0xf000) >> 12;
      if (type == IMAGE_FILE_MACHINE_UNKNOWN) {  // Used for padding
        continue;
      } else if (type != IMAGE_REL_BASED_HIGHLOW) {
        debug_printf("  Relocation %d but only 32bits relocations supported\n", type);
        return false;
      }

      WORD offset = relocs_array[i] & 0xfff;
      DWORD process_addr = new_imagebase + reloc_page_rva + offset;
      DWORD* local_addr = reinterpret_cast<DWORD*>(base + Rva2FileOffset(reloc_page_rva) + offset);
      DWORD new_value = *local_addr - nt_headers->OptionalHeader.ImageBase + new_imagebase;

      debug_printf("    *0x%08X = 0x%08X => 0x%08X\n", process_addr, *local_addr, new_value);
      process->WriteProcMem(process_addr, &new_value, sizeof(new_value));
    }

    relocs += reloc_block_size;
  }

  // Writing the configuration
  debug_printf("Writing the configuration\n");
  DWORD hk_end_scene_addr = new_imagebase + GetFunctionRVA("_Z10HkEndSceneP16IDirect3DDevice9@4");
  DWORD hk_reset_addr = new_imagebase + GetFunctionRVA("_Z7HkResetP16IDirect3DDevice9P23_D3DPRESENT_PARAMETERS_@8");
  DWORD extern_config_addr = new_imagebase + GetFunctionRVA("extern_config");
  debug_printf("  hk_end_scene:  0x%08X\n", hk_end_scene_addr);
  debug_printf("  hk_reset:      0x%08X\n", hk_reset_addr);
  debug_printf("  extern_config: 0x%08X\n", extern_config_addr);
  *new_end_scene = hk_end_scene_addr;
  *new_reset = hk_reset_addr;

  std::vector<char> config_blob = config->GetConfigBlob();
  process->WriteProcMem(extern_config_addr, config_blob.data(), config_blob.size());

  // Modify the sections protection
  debug_printf("Modifying the sections protections\n");
  for (size_t i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
    if (section_table[i].VirtualAddress == reloc_va) {
      reloc_section = &section_table[i];
      continue;
    }

    DWORD target_addr = new_imagebase + section_table[i].VirtualAddress;
    size_t allocation_size = section_table[i].SizeOfRawData;
    if (section_table[i].Misc.VirtualSize > section_table[i].SizeOfRawData) {
      allocation_size = section_table[i].Misc.VirtualSize;
    }

    const DWORD charac = section_table[i].Characteristics;
    DWORD memprot = 0;
    if (charac & IMAGE_SCN_MEM_EXECUTE) {
      memprot = PAGE_EXECUTE_READ;
    } else if (charac & IMAGE_SCN_MEM_READ && IMAGE_SCN_MEM_WRITE) {
      memprot = PAGE_READWRITE;
    } else {
      memprot = PAGE_READONLY;
    }

    debug_printf("  Modifying the access of 0x%08X to 0x%x\n", target_addr, memprot);
    if (!process->VirtualProtect(target_addr, allocation_size, memprot)) {
      debug_printf("  Cannot modify the section access\n");
      return false;
    }
  }

  // Execute the entrypoint
  // It will be done later via an hooking only, so not in this function
  // debug_printf("Executing the entry point 0x%08x\n", hk_end_scene_addr);
  // process->CreateThreadAndWait(hk_end_scene_addr);

  return true;
}

/**
  Convert a relative address inside a loaded PE executable to a file offset
  inside the executable.
*/
DWORD Shellcode::Rva2FileOffset(DWORD rva) {
  DWORD base = reinterpret_cast<DWORD>(buffer_);
  auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS32*>(base + dos_header->e_lfanew);
  auto* section_table = reinterpret_cast<IMAGE_SECTION_HEADER*>(base + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));

  IMAGE_SECTION_HEADER* section = nullptr;
  for (size_t i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
    if (ADDR_IS_BTW(rva, section_table[i].VirtualAddress,
                    section_table[i].VirtualAddress + section_table[i].SizeOfRawData)) {
      section = &section_table[i];
      break;
    }
  }
  if (!section) {
    return 0;
  }

  // The export directory is not always at the beggining of a section
  DWORD offset = rva - section->VirtualAddress;
  return section->PointerToRawData + offset;
}

/**
  Get the relative offset of a function in the PE executable.
*/
DWORD Shellcode::GetFunctionRVA(const char* function_name) {
  if (!buffer_) {
    debug_printf("GetFunctionRVA: no shellcode loaded\n");
    return 0;
  }

  DWORD base = reinterpret_cast<DWORD>(buffer_);
  auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS32*>(base + dos_header->e_lfanew);
  auto* section_table = reinterpret_cast<IMAGE_SECTION_HEADER*>(base + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));

  // Search the export table
  auto* data_directory = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
  if (!data_directory->VirtualAddress) {
    debug_printf("GetFunctionRVA: No export table\n");
    return 0;
  }
  auto* export_dir = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(base + Rva2FileOffset(data_directory->VirtualAddress));

  // Search the function name
  auto* names = reinterpret_cast<DWORD*>(base + Rva2FileOffset(export_dir->AddressOfNames));
  auto* names_ordinal = reinterpret_cast<WORD*>(base + Rva2FileOffset(export_dir->AddressOfNameOrdinals));
  auto* functions = reinterpret_cast<DWORD*>(base + Rva2FileOffset(export_dir->AddressOfFunctions));

  char* name = nullptr;
  for (size_t i = 0; export_dir->NumberOfFunctions; i++) {
    name = reinterpret_cast<char*>(base + Rva2FileOffset(names[i]));
    if (!_stricmp(name, function_name)) {
      return functions[names_ordinal[i]];
    }
  }

  return 0;
}
```

`injector/src/Shellcode.h`:

```h
#pragma once
#include "ExternConfig.h"
#include "Process.h"

class Shellcode {
 public:
  Shellcode();
  bool Map();
  bool InjectInProcess(Process* process, const ExternConfig* config, DWORD* new_end_scene, DWORD* new_reset);
  DWORD GetFunctionRVA(const char* function_name);

 private:
  DWORD Rva2FileOffset(DWORD rva);

  unsigned char* buffer_;
  size_t buffer_size_;
};
```

`injector/src/Signature.cpp`:

```cpp
#include "Signature.h"
#include "Debug.h"

Signature::Signature(std::vector<char> dump, DWORD dump_rva) {
  dump_ = dump;
  dump_rva_ = dump_rva;
}

const BYTE* Signature::SearchPattern(BYTE* pattern, const char* mask, size_t mask_len) const {
  const BYTE* data = reinterpret_cast<const BYTE*>(dump_.data());
  const BYTE* limit = data + dump_.size();

  size_t pos = 0;
  while (data + pos < limit) {
    if (pos == mask_len) {
      return data;
    }

    if (mask[pos] == '?' || data[pos] == pattern[pos]) {
      pos++;
      continue;
    }
    data++;
    pos = 0;
  }

  return nullptr;
}

DWORD Signature::GetD3DDevice(const Process* process) const {
  // CreateIndexBuffer
  // A1 ? ? ? ? 33 D2 56 57 8B 7C 24 14
  BYTE pattern[] = {0xa1, 0, 0, 0, 0, 0x33, 0xd2, 0x56, 0x57, 0x8b, 0x7c, 0x24, 0x14};
  char mask[] = "x????xxxxxxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetD3DDevice: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("CreateIndexBuffer pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD d3d_renderer_p = 0;
  if (!process->ReadProcMem(sig_addr + 1, &d3d_renderer_p, sizeof(d3d_renderer_p))) {
    debug_printf("Cannot read D3D renderer pointer\n");
    return 0;
  }
  debug_printf("d3d_renderer_p = 0x%08X\n", d3d_renderer_p);

  DWORD d3d_renderer = 0;
  if (!process->ReadProcMem(d3d_renderer_p, &d3d_renderer, sizeof(d3d_renderer))) {
    debug_printf("Cannot read D3D renderer\n");
    return 0;
  }
  debug_printf("d3d_renderer = 0x%08X\n", d3d_renderer);

  DWORD d3d_manager_p = d3d_renderer + 0x18;
  debug_printf("d3d_manager_p = 0x%08X\n", d3d_manager_p);

  DWORD d3d_manager = 0;
  if (!process->ReadProcMem(d3d_manager_p, &d3d_manager, sizeof(d3d_manager))) {
    debug_printf("Cannot read D3D manager\n");
    return 0;
  }
  debug_printf("d3d_manager = 0x%08X\n", d3d_manager);

  DWORD d3d_device_p = d3d_manager + 0x208;
  debug_printf("d3d_device_p = 0x%08X\n", d3d_device_p);

  DWORD d3d_device = 0;
  if (!process->ReadProcMem(d3d_device_p, &d3d_device, sizeof(d3d_device))) {
    debug_printf("Cannot read D3D device\n");
    return 0;
  }

  return d3d_device;
}

DWORD Signature::GetObjectsManager(const Process* process) const {
  // ObjectManager
  // 8B 0D ? ? ? ? E8 ? ? ? ? FF 77
  BYTE pattern[] = {0x8b, 0x0d, 0, 0, 0, 0, 0xe8, 0, 0, 0, 0, 0xff, 0x77};
  char mask[] = "xx????x????xx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetObjectsManager: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD obj_manager_p = 0;
  if (!process->ReadProcMem(sig_addr + 2, &obj_manager_p, sizeof(obj_manager_p))) {
    debug_printf("Cannot read object manager pointer\n");
    return 0;
  }
  debug_printf("obj_manager_p = 0x%08X\n", obj_manager_p);

  DWORD object_manager = 0;
  if (!process->ReadProcMem(obj_manager_p, &object_manager, sizeof(object_manager))) {
    debug_printf("Cannot read object manager renderer\n");
    return 0;
  }
  debug_printf("object_manager = 0x%08X\n", object_manager);

  return object_manager;
}

DWORD Signature::GetLocalPlayer(const Process* process) const {
  // LocalPlayer
  // A1 ? ? ? ? ? ? ? ? 85 C0 74 07 05 ? ? ? ? ? ? ? ? EB 02 33 C0 56
  BYTE pattern[] = {0xA1, 0x00, 0x00, 0x00, 0x00, 0x85, 0xc0, 0x74, 0x07, 0x05};
  char mask[] = "x????xxxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetLocalPlayer: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetLocalPlayer: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD local_player_p = 0;
  if (!process->ReadProcMem(sig_addr + 1, &local_player_p, sizeof(local_player_p))) {
    debug_printf("Cannot read local_player_p\n");
    return 0;
  }
  debug_printf("local_player_p = 0x%08X\n", local_player_p);

  DWORD local_player = 0;
  if (!process->ReadProcMem(local_player_p, &local_player, sizeof(local_player))) {
    debug_printf("Cannot read local_player\n");
    return 0;
  }
  debug_printf("local_player = 0x%08X\n", local_player);

  return local_player;
}

DWORD Signature::GetDrawCircle(const Process* process) const {
  // DrawCircle
  // 81 ec 84 00 00 00 a1 ? ? ? ? 33 c4 89 ? ? ? 00 00 00
  BYTE pattern[] = {0x81, 0xec, 0x84, 0x00, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x00,
                    0x33, 0xc4, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0xf3, 0x0f};
  char mask[] = "xxxxxxx????xxx???xxxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetDrawCircle: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetDrawCircle: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  return sig_addr;
}

DWORD Signature::GetPopRet(const Process* process) const {
  // pop eax ; ret
  // 58 c3
  BYTE pattern[] = {0x58, 0xc3};
  char mask[] = "xx";
  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetPopRet: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetPopRet: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  return sig_addr;
}

DWORD Signature::GetGameRenderer(const Process* process) const {
  // GameRenderer
  // 8B 15 ? ? ? ? 83 EC 08 F3
  BYTE pattern[] = {0x8b, 0x15, 0x00, 0x00, 0x00, 0x00, 0x83, 0xec, 0x08, 0xf3};
  char mask[] = "xx????xxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetGameRenderer: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetGameRenderer: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD value_p = 0;
  if (!process->ReadProcMem(sig_addr + 2, &value_p, sizeof(value_p))) {
    debug_printf("GetGameRenderer: Cannot read value pointer\n");
    return 0;
  }

  DWORD value = 0;
  if (!process->ReadProcMem(value_p, &value, sizeof(value))) {
    debug_printf("GetGameRenderer: Cannot read value\n");
    return 0;
  }

  return value;
}

DWORD Signature::GetWorldToScreen(const Process* process) const {
  // GameRenderer
  // 83 EC 10 56 E8 ? ? ? ? 8B 08
  BYTE pattern[] = {0x83, 0xec, 0x10, 0x56, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x08};
  char mask[] = "xxxxx????xx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetWorldToScreen: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetWorldToScreen: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  return sig_addr;
}

DWORD Signature::GetGameTime(const Process* process) const {
  // GameTime
  // F3 0F 11 05 ? ? ? ? 8B 49
  BYTE pattern[] = {0xf3, 0x0f, 0x11, 0x05, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x49};
  char mask[] = "xxxx????xx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetGameTime: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetGameTime: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD value_p = 0;
  if (!process->ReadProcMem(sig_addr + 4, &value_p, sizeof(value_p))) {
    debug_printf("GetGameTime: Cannot read value pointer\n");
    return 0;
  }

  return value_p;
}

DWORD Signature::GetIssueOrder(const Process* process) const {
  // IssueOrder
  // 81 EC ? ? ? ? 56 57 8B F9 C7
  BYTE pattern[] = {0x81, 0xec, 0, 0, 0, 0, 0x56, 0x57, 0x8b, 0xf9, 0xc7};
  char mask[] = "xx????xxxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetIssueOrder: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetIssueOrder: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  return sig_addr;
}

DWORD Signature::GetCastSpell(const Process* process) const {
  // CastSpell
  // 83 EC 38 56 8B 74 24 40
  BYTE pattern[] = {0x83, 0xec, 0x38, 0x56, 0x8b, 0x74, 0x24, 0x40};
  char mask[] = "xxxxxxxx";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetCastSpell: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetCastSpell: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  return sig_addr;
}

DWORD Signature::GetHudInstance(const Process* process) const {
  // GameTime
  // 8B 0D ? ? ? ? 6A 00 8B 49 34 E8 ? ? ? ? B0
  BYTE pattern[] = {0x8B, 0x0D, 0, 0, 0, 0, 0x6A, 0x00, 0x8B, 0x49, 0x34, 0xE8, 0, 0, 0, 0, 0xB0};
  char mask[] = "xx????xxxxxx????x";

  const BYTE* sig = SearchPattern(pattern, mask, _countof(mask) - 1);
  if (!sig) {
    debug_printf("GetHudInstance: Signature not found\n");
    return 0;
  }

  DWORD sig_offset = reinterpret_cast<const char*>(sig) - dump_.data();
  DWORD sig_addr = dump_rva_ + sig_offset;
  debug_printf("GetHudInstance: Pattern found at offset +0x%X (0x%08X)\n", sig_offset, sig_addr);

  DWORD value_p = 0;
  if (!process->ReadProcMem(sig_addr + 2, &value_p, sizeof(value_p))) {
    debug_printf("GetHudInstance: Cannot read value pointer\n");
    return 0;
  }

  DWORD value = 0;
  if (!process->ReadProcMem(value_p, &value, sizeof(value))) {
    debug_printf("GetHudInstance: Cannot read value\n");
    return 0;
  }

  return value;
}
```

`injector/src/Signature.h`:

```h
#pragma once
#include "Process.h"

class Signature {
 public:
  Signature(std::vector<char> dump, DWORD dump_rva);
  DWORD GetD3DDevice(const Process* process) const;
  DWORD GetObjectsManager(const Process* process) const;
  DWORD GetLocalPlayer(const Process* process) const;
  DWORD GetDrawCircle(const Process* process) const;
  DWORD GetPopRet(const Process* process) const;
  DWORD GetGameRenderer(const Process* process) const;
  DWORD GetWorldToScreen(const Process* process) const;
  DWORD GetGameTime(const Process* process) const;
  DWORD GetIssueOrder(const Process* process) const;
  DWORD GetCastSpell(const Process* process) const;
  DWORD GetHudInstance(const Process* process) const;

 private:
  const BYTE* SearchPattern(BYTE* pattern, const char* mask, size_t mask_len) const;

  std::vector<char> dump_;
  DWORD dump_rva_;
};
```

`injector/src/main.cpp`:

```cpp
#include <windows.h>
#include "D3dHook.h"
#include "Debug.h"
#include "Shellcode.h"

void DumpBuffer(unsigned char* buffer, size_t size) {
  printf("00: ");
  for (size_t i = 0; i < size; i++) {
    printf("%02x ", buffer[i]);
    if (i + 1 != size && (i + 1) % 16 == 0) {
      printf("\n%02X: ", i + 1);
    }
  }
  printf("\n");
}

int main() {
  const wchar_t process_name[] = L"League of legends.exe";
  std::shared_ptr<Process> process = Process::GetProcessByName(process_name);
  if (!process) {
    debug_printf("[-] No LoL process\n");
    return 1;
  }

  size_t module_size = 0;
  DWORD module_base = process->GetModuleBase(process_name, &module_size);
  debug_printf("Module base = 0x%08X\n", module_base);
  if (!module_base) {
    return 1;
  }

  std::vector<char> module_dump;
  DWORD code_section_addr;
  bool success = process->DumpCodeSectionFromModule(module_base, module_size, module_dump, &code_section_addr);
  if (!success) {
    debug_printf("Failed to dump the module\n");
    return 1;
  }
  debug_printf("Dumped a code section of 0x%x bytes from 0x%08X\n", module_dump.size(), code_section_addr);

  Shellcode shellcode;
  if (!shellcode.Map()) {
    debug_printf("Cannot map the shellcode\n");
    return 1;
  }

  Signature signature(module_dump, code_section_addr);
  D3dHook d3d_hook(process);
  success = d3d_hook.LoadDeviceVtable(&signature);
  if (!success) {
    return 1;
  }

  ExternConfig config;
  config.fn_end_scene(d3d_hook.GetMemberAddr(D3dHook::D3dVtableMembers::EndScene));
  config.fn_reset(d3d_hook.GetMemberAddr(D3dHook::D3dVtableMembers::Reset));
  config.kernel32(process->GetModuleBase(L"kernel32.dll"));
  config.d3d9_device(d3d_hook.d3d9_device());
  config.objects_manager(signature.GetObjectsManager(process.get()));
  config.pop_ret(signature.GetPopRet(process.get()));
  config.local_player(signature.GetLocalPlayer(process.get()));
  config.game_renderer(signature.GetGameRenderer(process.get()));
  config.issue_order(signature.GetIssueOrder(process.get()));
  config.cast_spell(signature.GetCastSpell(process.get()));
  config.hud_instance(signature.GetHudInstance(process.get()));

  DWORD world_to_screen = signature.GetWorldToScreen(process.get());
  if (!world_to_screen) {
    return 1;
  }
  config.world_to_screen(world_to_screen);

  DWORD draw_circle = signature.GetDrawCircle(process.get());
  if (!draw_circle) {
    return 1;
  }
  config.draw_circle(draw_circle);

  DWORD game_time = signature.GetGameTime(process.get());
  if (!game_time) {
    return 1;
  }
  config.game_time(game_time);

  DWORD new_end_scene = 0;
  DWORD new_reset = 0;
  success = shellcode.InjectInProcess(process.get(), &config, &new_end_scene, &new_reset);
  if (!success) {
    printf("Cannot inject the shellcode\n");
  }

  d3d_hook.MoveVtable();
  d3d_hook.HookMember(D3dHook::D3dVtableMembers::EndScene, new_end_scene);
  d3d_hook.HookMember(D3dHook::D3dVtableMembers::Reset, new_reset);

  printf("Press a key to unload the hooks...\n");
  getchar();
  d3d_hook.RestoreVtable();

  return 0;
}

```

`shellcode/Makefile`:

```
src_cpp = $(wildcard src/*.cpp)
obj_cpp = $(patsubst src/%.cpp,out/%.o,$(src_cpp))
src_asm = $(wildcard src/*.asm)
obj_asm = $(patsubst src/%.asm,out/%.o,$(src_asm))
obj = $(obj_asm) $(obj_cpp)
gpp_flags = -fno-stack-protector -O2
ld_flags =

all: out $(obj)
	i686-w64-mingw32-ld $(ld_flags) -o out/shellcode.dll $(obj)
	strip out/shellcode.dll

out:
	mkdir -p out

out/%.o: src/%.cpp
	i686-w64-mingw32-g++ $(gpp_flags) -c -o $@ $<

out/%.o: src/%.asm
	nasm -f elf -o $@ $<

clean:
	rm -f out/*.o
	rm -f out/shellcode.dll
```

`shellcode/src/CompileTime.h`:

```h
#pragma once

template <int X>
struct EnsureCompileTime {
  enum : int { value = X };
};

template <unsigned int X>
struct EnsureCompileTimeU {
  enum : unsigned int { value = X };
};

```

`shellcode/src/Draw.cpp`:

```cpp
#include "Draw.h"
#include "Math.h"
#include "WinApi.h"

extern "C" void __cdecl FakingCallRet();

LPDIRECT3DDEVICE9 Draw::d3d9_device_ = nullptr;
size_t Draw::screen_width_ = 0;
size_t Draw::screen_height_ = 0;
type_world_to_screen Draw::fnWorldToScreen_ = nullptr;
type_draw_circle Draw::fnDrawCircle_ = nullptr;
unsigned char* Draw::ebp_ret_ = nullptr;
ID3DXLine* Draw::line_ = nullptr;
LPD3DXFONT Draw::font_ = nullptr;

// static
void Draw::Initialize(LPDIRECT3DDEVICE9 d3d9_device,
                      size_t screen_width,
                      size_t screen_height,
                      type_world_to_screen world_to_screen,
                      type_draw_circle draw_circle) {
  d3d9_device_ = d3d9_device;
  screen_width_ = screen_width;
  screen_height_ = screen_height;
  fnWorldToScreen_ = world_to_screen;
  fnDrawCircle_ = draw_circle;
  line_ = 0;
  font_ = 0;

  // Search: mov ebp esp; pop ebp; ret
  unsigned char* ret_inst = reinterpret_cast<unsigned char*>(fnWorldToScreen_);
  while (*(unsigned long*)ret_inst != 0xc35de58b) {
    ret_inst++;
  }
  ebp_ret_ = ret_inst;
}

// static
bool Draw::WorldToScreen(Vector3* pos, Vector2* pos2D) {
  Vector3 result;

  auto fnWorldToScreenRop =
      reinterpret_cast<void(__cdecl*)(type_world_to_screen, void*, Vector3*, Vector3*)>(FakingCallRet);

  fnWorldToScreenRop(fnWorldToScreen_, ebp_ret_, pos, &result);

  pos2D->x = result.x;
  pos2D->y = result.y;

  if (result.x < 0.f || result.x > screen_width_) {
    return false;
  }
  if (result.y < 0.f || result.y > screen_height_) {
    return false;
  }

  return true;
}

// static
void Draw::DrawLine(Vector2 start, Vector2 end, float width, bool antialias, D3DCOLOR color) {
  if (!line_) {
    WinApi::D3DXCreateLine(d3d9_device_, &line_);
  }
  line_->SetWidth(width);
  if (antialias) {
    line_->SetAntialias(1);
  }

  D3DXVECTOR2 line[] = {start.ToD3DX(), end.ToD3DX()};
  line_->Begin();
  line_->Draw(line, 2, color);
  line_->End();
}

// static
void Draw::DrawCircle3D(Vector3 pos, float radius, GameColor color) {
  auto fnDrawCircleRop =
      reinterpret_cast<void(__cdecl*)(type_draw_circle, void*, Vector3* position, float range, GameColor* color, int a4,
                                      float a5, int a6, float alpha)>(FakingCallRet);

  fnDrawCircleRop(fnDrawCircle_, ebp_ret_, &pos, radius, &color, 0, 0, 0, 1.f);
}

// static
bool Draw::DrawText2D(Vector2 pos, const char* str, D3DCOLOR color) {
  if (!font_) {
    HRESULT result = WinApi::D3DXCreateFont(d3d9_device_, 24, 0, FW_NORMAL, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                            DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Arial", &font_);
    if (result != S_OK || !font_) {
      return false;
    }
  }

  RECT rect;
  rect.left = static_cast<LONG>(pos.x);
  rect.top = static_cast<LONG>(pos.y);
  rect.right = rect.left + 400;
  rect.bottom = rect.top + 400;
  font_->DrawTextA(NULL, str, -1, &rect, DT_LEFT | DT_NOCLIP, color);
  return true;
}

// static
void Draw::LostDevice() {
  if (font_) {
    font_->OnLostDevice();
  }
  if (line_) {
    line_->OnLostDevice();
  }
}

// static
void Draw::ResetDevice() {
  if (font_) {
    font_->OnResetDevice();
  }
  if (line_) {
    line_->OnResetDevice();
  }
}

// static
void Draw::Release() {
  if (font_) {
    font_->Release();
    font_ = nullptr;
  }
  if (line_) {
    line_->Release();
    line_ = nullptr;
  }
}
```

`shellcode/src/Draw.h`:

```h
#pragma once
#include <d3dx9.h>
#include "Vector.h"

class GameColor {
 public:
  unsigned char b, g, r;

  GameColor() : r(0), g(0), b(0) {}
  GameColor(unsigned char r, unsigned char g, unsigned char b) {
    this->r = r;
    this->g = g;
    this->b = b;
  }
};

typedef void(__cdecl* type_world_to_screen)(Vector3* world, Vector3* screen);
typedef void(
    __cdecl* type_draw_circle)(Vector3* position, float range, GameColor* color, int a4, float a5, int a6, float alpha);

class Draw {
 public:
  static void Initialize(LPDIRECT3DDEVICE9 d3d9_device,
                         size_t screen_width,
                         size_t screen_height,
                         type_world_to_screen world_to_screen,
                         type_draw_circle draw_circle);
  static bool WorldToScreen(Vector3* pos, Vector2* pos2D);
  static void DrawLine(Vector2 start, Vector2 end, float width, bool antialias, D3DCOLOR color);
  static void DrawCircle3D(Vector3 pos, float radius, GameColor color);
  static bool DrawText2D(Vector2 pos, const char* str, D3DCOLOR color = 0xffffffff);
  static void ResetDevice();
  static void LostDevice();
  static void Release();

 private:
  static LPDIRECT3DDEVICE9 d3d9_device_;
  static size_t screen_width_;
  static size_t screen_height_;
  static type_world_to_screen fnWorldToScreen_;
  static type_draw_circle fnDrawCircle_;
  static unsigned char* ebp_ret_;
  static ID3DXLine* line_;
  static LPD3DXFONT font_;
};
```

`shellcode/src/Esp.cpp`:

```cpp
#include "Esp.h"
#include "Draw.h"
#include "GameApi.h"
#include "GameLoop.h"

// static
void Esp::DrawEspMinion() {
  GameColor color_last_hit(255, 255, 0);
  for (size_t i = 0; i < GameLoop::nb_minions(); i++) {
    if (GameLoop::minion(i)->GetTeam() == GameLoop::local_player()->GetTeam()) {
      continue;
    }

    // Show only a minion ESP if its life inferior to my base attack
    float attack_damage = GameLoop::local_player()->GetBaseAtk();
    if (GameLoop::minion(i)->GetHealth() <= attack_damage) {
      Draw::DrawCircle3D(*GameLoop::minion(i)->GetPosition(), 100.f, color_last_hit);
    }
  }
}

// static
void Esp::DrawEspTurrets() {
  GameColor color;
  for (size_t i = 0; i < GameLoop::nb_turrets(); i++) {
    if (GameLoop::turret(i)->GetTeam() == GameLoop::local_player()->GetTeam()) {
      color = GameColor(0, 0, 255);
    } else {
      color = GameColor(255, 0, 0);
    }

    Draw::DrawCircle3D(*GameLoop::turret(i)->GetPosition(), 875.f, color);
  }
}

// static
void Esp::DrawEspHeroes() {
  GameColor color(0, 255, 255);
  for (size_t i = 0; i < GameLoop::nb_heroes(); i++) {
    if (GameLoop::heroe(i)->GetTeam() == GameLoop::local_player()->GetTeam()) {
      continue;
    }

    Draw::DrawCircle3D(*GameLoop::heroe(i)->GetPosition(), GameLoop::heroe(i)->GetAtkRange(), color);
  }
}

// static
void Esp::DrawRangeEsp() {
  GameObject* local_player = GameLoop::local_player();

  GameColor color(128, 0, 255);
  Draw::DrawCircle3D(*local_player->GetPosition(), local_player->GetAtkRange(), color);
}

// static
void Esp::DrawEspSpells() {
  GameColor color(0, 255, 255);
  Vector2 pos2d;
  Vector2 text_pos;
  Vector2 cooldown_pos;

  SpellBook::SpellType spell_types[] = {
      SpellBook::SpellType::SpellQ, SpellBook::SpellType::SpellW,  SpellBook::SpellType::SpellE,
      SpellBook::SpellType::SpellR, SpellBook::SpellType::Summon1, SpellBook::SpellType::Summon2,
  };
  SpellBook* spellbook = nullptr;
  SpellSlot* spell_slot = nullptr;
  char spell_str[10] = {0};
  char cooldown_str[10] = {0};
  D3DCOLOR spell_color;
  D3DCOLOR cooldown_color = D3DCOLOR_ARGB(255, 255, 255, 255);

  for (size_t i = 0; i < GameLoop::nb_heroes(); i++) {
    if (!Draw::WorldToScreen(GameLoop::heroe(i)->GetPosition(), &pos2d)) {
      continue;
    }

    // TODO: precise rect and DT_CENTER
    text_pos.x = pos2d.x + 100;
    text_pos.y = pos2d.y - 260;
    spellbook = GameLoop::heroe(i)->GetSpellBook();

    for (size_t spell = 0; spell < _countof(spell_types); spell++) {
      spell_slot = spellbook->GetSpellSlot(spell_types[spell]);
      const int time_still = static_cast<int>(spell_slot->GetCooldownBackTime() - GameApi::game_time());

      // Cooldown
      if (spell_slot->GetLevel() && time_still > 0) {
        cooldown_pos = text_pos;

        if (spell % 2 == 0) {
          cooldown_pos.y -= 20;
        } else {
          cooldown_pos.y += 20;
        }

        itoa(time_still, cooldown_str, 10);
        Draw::DrawText2D(cooldown_pos, cooldown_str, cooldown_color);
      }

      // Level
      if (!spell_slot->GetLevel() || time_still > 0) {
        spell_color = D3DCOLOR_ARGB(255, 255, 0, 0);
      } else {
        spell_color = D3DCOLOR_ARGB(255, 255, 255, 255);
      }

      itoa(spell_slot->GetLevel(), spell_str, 10);
      Draw::DrawText2D(text_pos, spell_str, spell_color);
      text_pos.x += 20;
    }
  }
}

// static
void Esp::DrawAllEsp() {
  DrawEspMinion();
  DrawEspTurrets();
  DrawEspHeroes();
  DrawRangeEsp();
  DrawEspSpells();
}
```

`shellcode/src/Esp.h`:

```h
#pragma once

class Esp {
 public:
  static void DrawEspMinion();
  static void DrawEspTurrets();
  static void DrawEspHeroes();
  static void DrawRangeEsp();
  static void DrawEspSpells();
  static void DrawAllEsp();
};
```

`shellcode/src/GameApi.cpp`:

```cpp
#include "GameApi.h"

float* GameApi::game_time_ = nullptr;

// static
void GameApi::Initialize(float* game_time) {
  game_time_ = game_time;
}

```

`shellcode/src/GameApi.h`:

```h
#pragma once

class GameApi {
 public:
  static void Initialize(float* game_time);
  static float game_time() {
    if (!game_time_) {
      return 0;
    }
    return *game_time_;
  }

 private:
  static float* game_time_;
};
```

`shellcode/src/GameLoop.cpp`:

```cpp
#include "GameLoop.h"
#include <windows.h>
#include "Draw.h"
#include "Log.h"

ObjectManager* GameLoop::object_manager_ = nullptr;
GameObject* GameLoop::local_player_ = nullptr;
GameObject* GameLoop::minions_[100] = {0};
GameObject* GameLoop::turrets_[100] = {0};
GameObject* GameLoop::heroes_[20] = {0};
size_t GameLoop::nb_minions_ = 0;
size_t GameLoop::nb_turrets_ = 0;
size_t GameLoop::nb_heroes_ = 0;

// static
void GameLoop::Update(ObjectManager* object_manager, GameObject* local_player) {
  object_manager_ = object_manager;
  local_player_ = local_player;
  nb_minions_ = 0;
  nb_turrets_ = 0;
  nb_heroes_ = 0;
  if (!object_manager_ || !local_player_) {
    return;
  }

  GameObject** game_objects = object_manager_->GetFirstArrayElement();
  if (!game_objects) {
    return;
  }

  size_t nb_objects = object_manager_->size();
  for (size_t i = 0; i < nb_objects; i++) {
    auto obj = game_objects[i];
    if (!obj || !obj->IsValid()) {
      continue;
    }

    if (obj->IsMinion()) {  // Minion
      if (!obj->GetHealth()) {
        continue;
      }
      if (nb_minions_ >= _countof(minions_)) {
        continue;
      }
      minions_[nb_minions_++] = obj;
    } else if (obj->IsTurret()) {  // Turret
      if (!obj->GetHealth()) {
        continue;
      }
      if (nb_turrets_ >= _countof(turrets_)) {
        continue;
      }
      turrets_[nb_turrets_++] = obj;
    } else if (obj->IsHero()) {  // Hero
      if (!obj->GetHealth()) {
        continue;
      }
      if (nb_heroes_ >= _countof(heroes_)) {
        continue;
      }
      heroes_[nb_heroes_++] = obj;
    }
  }
}
```

`shellcode/src/GameLoop.h`:

```h
#pragma once
#include "GameObject.h"

class GameLoop {
 public:
  static void Update(ObjectManager* object_manager, GameObject* local_player);

  static ObjectManager* object_manager() { return object_manager_; }
  static GameObject* local_player() { return local_player_; }
  static size_t nb_minions() { return nb_minions_; }
  static size_t nb_turrets() { return nb_turrets_; }
  static size_t nb_heroes() { return nb_heroes_; }

  static GameObject* minion(size_t index) {
    if (index >= nb_minions_) {
      return nullptr;
    }
    return minions_[index];
  }
  static GameObject* turret(size_t index) {
    if (index >= nb_turrets_) {
      return nullptr;
    }
    return turrets_[index];
  }
  static GameObject* heroe(size_t index) {
    if (index >= nb_heroes_) {
      return nullptr;
    }
    return heroes_[index];
  }

 private:
  static ObjectManager* object_manager_;
  static GameObject* local_player_;
  static GameObject* minions_[100];
  static GameObject* turrets_[100];
  static GameObject* heroes_[20];
  static size_t nb_minions_;
  static size_t nb_turrets_;
  static size_t nb_heroes_;
};
```

`shellcode/src/GameObject.h`:

```h
#pragma once
#include <d3dx9.h>
#include <windows.h>
#include "GameString.h"
#include "SpellBook.h"

#define DEFINE_SETTERS(type, name, offset) \
  type Get##name() { return *reinterpret_cast<type*>(this + offset); }
#define DEFINE_SETTERS_PTR(type, name, offset) \
  type* Get##name() { return reinterpret_cast<type*>(this + offset); }

struct Vector3;
class GameObject {
 public:
  DEFINE_SETTERS(BYTE, Team, 0x4C)
  DEFINE_SETTERS_PTR(GameString, Name, 0x6C)
  DEFINE_SETTERS(char, NetworkID, 0xCC)
  DEFINE_SETTERS_PTR(Vector3, Position, 0x1D8)
  DEFINE_SETTERS(float, Health, 0xF88)
  DEFINE_SETTERS(float, MaxHealth, 0xF98)
  DEFINE_SETTERS(float, BonusAtk, 0x13CC)
  DEFINE_SETTERS(float, BaseAtk, 0x143C)
  DEFINE_SETTERS(float, Armor, 0x1460)
  DEFINE_SETTERS(float, BonusArmor, 0x1464)
  DEFINE_SETTERS(char, MagicRes, 0x1468)
  DEFINE_SETTERS(char, BonusMagicRes, 0x146C)
  DEFINE_SETTERS(float, MoveSpeed, 0x147C)
  DEFINE_SETTERS(float, AtkRange, 0x1484)
  DEFINE_SETTERS_PTR(SpellBook, SpellBook, 0x2AD0)
  DEFINE_SETTERS_PTR(char, ChampionName, 0x358C)
  DEFINE_SETTERS(char, Level, 0x4EA4)

  DWORD type() {
    DWORD base = reinterpret_cast<DWORD>(this);
    DWORD type_index = *reinterpret_cast<BYTE*>(base + 0x58);
    DWORD general_type = *reinterpret_cast<DWORD*>(base + 0x5c + type_index * 4);

    // DWORD xor
    size_t nb = *reinterpret_cast<BYTE*>(base + 0x51);
    if (nb) {
      DWORD xor_value = *reinterpret_cast<DWORD*>(base + 0x54);
      general_type ^= ~xor_value;
    }

    // BYTE xor
    nb = *reinterpret_cast<BYTE*>(base + 0x52);
    if (nb && nb <= 4) {
      for (size_t i = 0; i < nb; i++) {
        reinterpret_cast<BYTE*>(general_type)[i] ^= ~reinterpret_cast<BYTE*>(base + 0x54)[i];
      }
    }

    return general_type;
  }

  bool IsMinion() { return (type() & 0x800) && GetName()->c_str()[0] == 'M'; }
  bool IsHero() { return type() & 0x1000; }
  bool IsTurret() { return type() & 0x6000; }
  bool IsValid() { return !(reinterpret_cast<DWORD>(this) & 0x1); }
};

struct ObjectManager {
 public:
  DEFINE_SETTERS(GameObject**, FirstArrayElement, 0x14)
  DEFINE_SETTERS(GameObject**, LastArrayElement, 0x18)

  size_t size() {
    return (reinterpret_cast<DWORD>(GetLastArrayElement()) - reinterpret_cast<DWORD>(GetFirstArrayElement())) /
           sizeof(DWORD);
  }
};

#undef DEFINE_SETTERS
#undef DEFINE_SETTERS_PTR
```

`shellcode/src/GameRenderer.h`:

```h
#pragma once
#include <d3dx9.h>
#include <windows.h>

#define DEFINE_SETTERS(type, name, offset) \
  type Get##name() { return *reinterpret_cast<type*>(this + offset); }
#define DEFINE_SETTERS_PTR(type, name, offset) \
  type* Get##name() { return reinterpret_cast<type*>(this + offset); }

class GameRenderer {
 public:
  DEFINE_SETTERS(DWORD, ScreenWidth, 0x14)
  DEFINE_SETTERS(DWORD, ScreenHeight, 0x18)
  DEFINE_SETTERS_PTR(D3DXMATRIX, ViewMatrix, 0x68)
  DEFINE_SETTERS_PTR(D3DXMATRIX, ProjectionMatrix, 0xA8)
};

#undef DEFINE_SETTERS
#undef DEFINE_SETTERS_PTR
```

`shellcode/src/GameString.h`:

```h
#pragma once

class GameString {
 public:
  union {
    char* strPtr;
    char strVal[16];
  };
  int len;
  int max;

  char* c_str() {
    if (max >= 16) {
      return strPtr;
    }
    return strVal;
  }
};
```

`shellcode/src/Hash.h`:

```h
#pragma once
#include <cstdint>
#include "CompileTime.h"

#define DJB_HASH(str) EnsureCompileTimeU<Hash::Djb(str)>::value

class Hash {
 public:
  static constexpr uint32_t Djb(const char* str) {
    uint32_t hash = 5381;
    for (size_t i = 0; str[i]; i++) {
      hash = ((hash << 5) + hash) + str[i];
    }
    return hash;
  }
};

```

`shellcode/src/HudManager.h`:

```h
#pragma once
#include <windows.h>
#include "SpellBook.h"

#define DEFINE_SETTERS(type, name, offset) \
  type Get##name() { return *reinterpret_cast<type*>(this + offset); }
#define DEFINE_SETTERS_PTR(type, name, offset) \
  type* Get##name() { return reinterpret_cast<type*>(this + offset); }

class MouseManager {
 public:
  DEFINE_SETTERS_PTR(Vector3, Position3D, 0x1c)
  DEFINE_SETTERS(SpellInfo*, Spell, 0x84)
};

class HudManager {
 public:
  DEFINE_SETTERS(MouseManager*, Mouse, 0x14)
};

#undef DEFINE_SETTERS
#undef DEFINE_SETTERS_PTR
```

`shellcode/src/Log.cpp`:

```cpp
#include "Log.h"
#include "WinApi.h"
#include "printf.h"

HANDLE Log::logfile_ = nullptr;

// static
void Log::Initialize() {
  logfile_ = WinApi::CreateFileW(L"C:\\Users\\Dimitri\\Desktop\\debug.log", GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
}

// static
void Log::LogStr(const char* msg) {
  DWORD nb_writen = 0;
  if (logfile_) {
    WinApi::WriteFile(logfile_, msg, strlen(msg), &nb_writen, NULL);
    WinApi::FlushFileBuffers(logfile_);
  }
}

// static
void Log::LogPrintf(const char* format, ...) {
  char buffer[2048];
  va_list va;
  va_start(va, format);
  vsnprintf(buffer, sizeof(buffer), format, va);
  va_end(va);

  LogStr(buffer);
}
```

`shellcode/src/Log.h`:

```h
#pragma once
#include <windows.h>

class Log {
 public:
  static void Initialize();
  static void LogStr(const char* msg);
  static void LogPrintf(const char* format, ...);

 private:
  static HANDLE logfile_;
};
```

`shellcode/src/Math.cpp`:

```cpp
#include "Math.h"
#define M_PI 3.141592654f

// static
double Math::Fact(int n) {
  if (n == 1 || n == 0) {
    return 1;
  }

  double result = 1;
  for (int i = n; i > 1; i--) {
    result *= i;
  }

  return result;
}

// static
double Math::Pow(double x, size_t y) {
  if (y == 0) {
    return 1;
  }
  double r = x;
  for (size_t i = 0; i < y - 1; i++) {
    r *= x;
  }
  return r;
}

// static
double Math::IntDist(double a, double b) {
  if (a > b) {
    return a - b;
  } else {
    return b - a;
  }
}

// static
double Math::Cos(double x) {
  if (x > 0) {
    while (x >= 2 * M_PI) {
      x -= 2 * M_PI;
    }
  } else if (x < 0) {
    while (x <= -2 * M_PI) {
      x += 2 * M_PI;
    }
  }
  double y = 1;
  bool neg = true;
  double last_value;
  bool first_loop = true;
  unsigned int n = 1;
  while (true) {
    if (neg) {
      y -= Pow(x, n * 2) / Fact(n * 2);
      neg = false;
    } else {
      y += Pow(x, n * 2) / Fact(n * 2);
      neg = true;
    }

    if (!first_loop) {
      if (IntDist(y, last_value) < 0.00001) {
        break;
      }
    } else {
      first_loop = false;
    }
    last_value = y;
    n++;
  }

  return y;
}

// static
float Math::Cos(float x) {
  return static_cast<float>(Cos(static_cast<double>(x)));
}

// static
double Math::Sin(double x) {
  if (x > 0) {
    while (x >= 2 * M_PI) {
      x -= 2 * M_PI;
    }
  } else if (x < 0) {
    while (x <= -2 * M_PI) {
      x += 2 * M_PI;
    }
  }
  double y = x;
  bool neg = true;
  double last_value;
  bool first_loop = true;
  unsigned int n = 1;

  while (true) {
    if (neg) {
      y -= Pow(x, 2 * n + 1) / Fact(2 * n + 1);
      neg = false;
    } else {
      y += Pow(x, 2 * n + 1) / Fact(2 * n + 1);
      neg = true;
    }

    if (!first_loop) {
      if (IntDist(y, last_value) < 0.00001) {
        break;
      }
    } else {
      first_loop = false;
    }
    last_value = y;
    n++;
  }

  return y;
}

// static
float Math::Sin(float x) {
  return static_cast<float>(Sin(static_cast<double>(x)));
}

```

`shellcode/src/Math.h`:

```h
#pragma once
#include <stddef.h>

class Math {
 public:
  static double Fact(int n);
  static double Pow(double x, size_t y);
  static double IntDist(double a, double b);
  static double Cos(double x);
  static float Cos(float x);
  static double Sin(double x);
  static float Sin(float x);
};
```

`shellcode/src/PEHeaders.cpp`:

```cpp
#include "PEHeaders.h"
#include "Hash.h"
#include "string.h"

// static
void* PEHeaders::GetFuncAddr(void* dll, const char* function_name) {
  const DWORD base = reinterpret_cast<DWORD>(dll);
  auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
    return nullptr;
  }

  auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS32*>(base + dos_header->e_lfanew);
  if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
    return nullptr;
  }

  auto* data_directory = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
  if (!data_directory->VirtualAddress) {
    return nullptr;
  }

  auto* export_dir = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(base + data_directory->VirtualAddress);
  auto* names = reinterpret_cast<DWORD*>(base + export_dir->AddressOfNames);
  auto* names_ordinal = reinterpret_cast<WORD*>(base + export_dir->AddressOfNameOrdinals);
  auto* functions = reinterpret_cast<DWORD*>(base + export_dir->AddressOfFunctions);

  char* name = nullptr;
  for (size_t i = 0; export_dir->NumberOfFunctions; i++) {
    name = reinterpret_cast<char*>(base + names[i]);
    if (stricmp(name, function_name) == 0) {
      return reinterpret_cast<void*>(base + functions[names_ordinal[i]]);
    }
  }

  return nullptr;
}

// static
void* PEHeaders::GetFuncAddr(void* dll, DWORD function_hash) {
  const DWORD base = reinterpret_cast<DWORD>(dll);
  auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
    return nullptr;
  }

  auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS32*>(base + dos_header->e_lfanew);
  if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
    return nullptr;
  }

  auto* data_directory = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
  if (!data_directory->VirtualAddress) {
    return nullptr;
  }

  auto* export_dir = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(base + data_directory->VirtualAddress);
  auto* names = reinterpret_cast<DWORD*>(base + export_dir->AddressOfNames);
  auto* names_ordinal = reinterpret_cast<WORD*>(base + export_dir->AddressOfNameOrdinals);
  auto* functions = reinterpret_cast<DWORD*>(base + export_dir->AddressOfFunctions);

  char* name = nullptr;
  for (size_t i = 0; export_dir->NumberOfFunctions; i++) {
    name = reinterpret_cast<char*>(base + names[i]);
    if (Hash::Djb(name) == function_hash) {
      return reinterpret_cast<void*>(base + functions[names_ordinal[i]]);
    }
  }

  return nullptr;
}

```

`shellcode/src/PEHeaders.h`:

```h
#pragma once
#include <windows.h>

class PEHeaders {
 public:
  /**
    Equivalent of the win32 api GetProcAddress().
  */
  static void* GetFuncAddr(void* dll, const char* function_name);
  static void* GetFuncAddr(void* dll, DWORD function_hash);
};
```

`shellcode/src/SpellBook.h`:

```h
#pragma once
#include "GameString.h"

#define DEFINE_SETTERS(type, name, offset) \
  type Get##name() { return *reinterpret_cast<type*>(this + offset); }
#define DEFINE_SETTERS_PTR(type, name, offset) \
  type* Get##name() { return reinterpret_cast<type*>(this + offset); }

class SpellInfo {
 public:
  DEFINE_SETTERS_PTR(GameString, Name, 0x18)
};

class SpellSlot {
 public:
  DEFINE_SETTERS(DWORD, Level, 0x20)
  DEFINE_SETTERS(float, CooldownBackTime, 0x28)
  DEFINE_SETTERS(float, Cooldown, 0x78)
  DEFINE_SETTERS(float, Damage, 0x90)
  DEFINE_SETTERS(SpellInfo*, Info, 0x134)
};

class SpellBook {
 public:
  enum class SpellType {
    SpellQ,
    SpellW,
    SpellE,
    SpellR,
    Summon1,
    Summon2,
    Item1,
    Item2,
    Item3,
    Item4,
    Item5,
    Item6,
    Trinket,
    Recall
  };

  SpellSlot* GetSpellSlot(SpellType type) {
    SpellSlot** slots = reinterpret_cast<SpellSlot**>(this + 0x510);
    return slots[static_cast<size_t>(type)];
  }
};

#undef DEFINE_SETTERS
#undef DEFINE_SETTERS_PTR
```

`shellcode/src/StringEncryption.h`:

```h
#pragma once
#include "CompileTime.h"

#define RAND_SEED                                                                                              \
  ((__TIME__[7] - '0') * 1 + (__TIME__[6] - '0') * 10 + (__TIME__[4] - '0') * 60 + (__TIME__[3] - '0') * 600 + \
   (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)

constexpr int LinearCongruentGenerator(int rounds) {
  return 1013904223 + 1664525 * ((rounds > 0) ? LinearCongruentGenerator(rounds - 1) : RAND_SEED & 0xFFFFFFFF);
}

#define RAND() EnsureCompileTime<LinearCongruentGenerator(10)>::value  // 10 Rounds
#define RAND_RANGE(min, max) (min + (RAND() % (max - min + 1)))
static constexpr char XOR_KEY = (char)RAND_RANGE(0, 0xff);

template <int... Pack>
struct IndexList {};

template <typename IndexList, int Right>
struct Append;
template <int... Left, int Right>
struct Append<IndexList<Left...>, Right> {
  typedef IndexList<Left..., Right> Result;
};

template <int N>
struct ConstructIndexList {
  typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <>
struct ConstructIndexList<0> {
  typedef IndexList<> Result;
};

constexpr char EncryptCharacter(const char Character, int Index) {
  return Character ^ (XOR_KEY + Index);
}

template <typename IndexList>
class CXorString;
template <int... Index>
class CXorString<IndexList<Index...>> {
 private:
  char Value[sizeof...(Index) + 1];

 public:
  constexpr CXorString(const char* const String) : Value{EncryptCharacter(String[Index], Index)...} {}

  char* decrypt() {
    for (int t = 0; t < sizeof...(Index); t++) {
      Value[t] = Value[t] ^ (XOR_KEY + t);
    }
    Value[sizeof...(Index)] = '\0';
    return Value;
  }

  char* get() { return Value; }
};
#define XorS(X, String) CXorString<ConstructIndexList<sizeof(String) - 1>::Result> X(String)

```

`shellcode/src/Vector.h`:

```h
#pragma once
#include <d3dx9.h>

struct Vector2 {
  float x;
  float y;

  Vector2(float x, float y) {
    this->x = x;
    this->y = y;
  }
  Vector2() : Vector2(0, 0) {}

  D3DXVECTOR2 ToD3DX() {
    D3DXVECTOR2 r;
    r.x = this->x;
    r.y = this->y;
    return r;
  }
};

struct Vector3 {
  float x;
  float y;
  float z;

  Vector3(float x, float y, float z) {
    this->x = x;
    this->y = y;
    this->z = z;
  }
  Vector3() : Vector3(0, 0, 0) {}

  D3DXVECTOR3 ToD3DX() {
    D3DXVECTOR3 r;
    r.x = this->x;
    r.y = this->y;
    r.z = this->z;
    return r;
  }
};
```

`shellcode/src/WinApi.cpp`:

```cpp
#include "WinApi.h"
#include "Hash.h"
#include "PEHeaders.h"
#include "StringEncryption.h"

type_get_module_handle WinApi::GetModuleHandleA = nullptr;
type_create_file WinApi::CreateFileW = nullptr;
type_write_file WinApi::WriteFile = nullptr;
type_flush_file_buffers WinApi::FlushFileBuffers = nullptr;
type_sleep WinApi::Sleep = nullptr;
type_create_line WinApi::D3DXCreateLine = nullptr;
type_create_font WinApi::D3DXCreateFont = nullptr;

// static
void WinApi::Initialize(void* kernel32) {
  WinApi::GetModuleHandleA =
      reinterpret_cast<type_get_module_handle>(PEHeaders::GetFuncAddr(kernel32, DJB_HASH("GetModuleHandleA")));
  WinApi::CreateFileW = reinterpret_cast<type_create_file>(PEHeaders::GetFuncAddr(kernel32, DJB_HASH("CreateFileW")));
  WinApi::WriteFile = reinterpret_cast<type_write_file>(PEHeaders::GetFuncAddr(kernel32, DJB_HASH("WriteFile")));
  WinApi::FlushFileBuffers =
      reinterpret_cast<type_flush_file_buffers>(PEHeaders::GetFuncAddr(kernel32, DJB_HASH("FlushFileBuffers")));
  WinApi::Sleep = reinterpret_cast<type_sleep>(PEHeaders::GetFuncAddr(kernel32, DJB_HASH("Sleep")));

  XorS(d3d9_dll, "d3dx9_39.dll");
  void* d3dx9 = WinApi::GetModuleHandleA(d3d9_dll.decrypt());

  WinApi::D3DXCreateLine =
      reinterpret_cast<type_create_line>(PEHeaders::GetFuncAddr(d3dx9, DJB_HASH("D3DXCreateLine")));
  WinApi::D3DXCreateFont =
      reinterpret_cast<type_create_font>(PEHeaders::GetFuncAddr(d3dx9, DJB_HASH("D3DXCreateFontW")));
}
```

`shellcode/src/WinApi.h`:

```h
#pragma once
#include <d3dx9.h>
#include <windows.h>

typedef HMODULE(WINAPI* type_get_module_handle)(LPCSTR);
typedef HANDLE(WINAPI* type_create_file)(LPCWSTR lpFileName,
                                         DWORD dwDesiredAccess,
                                         DWORD dwShareMode,
                                         LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                         DWORD dwCreationDisposition,
                                         DWORD dwFlagsAndAttributes,
                                         HANDLE hTemplateFile);
typedef BOOL(WINAPI* type_write_file)(HANDLE hFile,
                                      LPCVOID lpBuffer,
                                      DWORD nNumberOfBytesToWrite,
                                      LPDWORD lpNumberOfBytesWritten,
                                      LPOVERLAPPED lpOverlapped);
typedef BOOL(WINAPI* type_flush_file_buffers)(HANDLE hFile);
typedef HRESULT(WINAPI* type_sleep)(DWORD dwMilliseconds);
typedef HRESULT(WINAPI* type_create_line)(LPDIRECT3DDEVICE9 pDevice, LPD3DXLINE* ppLine);
typedef HRESULT(WINAPI* type_create_font)(_In_ LPDIRECT3DDEVICE9 pDevice,
                                          _In_ INT Height,
                                          _In_ UINT Width,
                                          _In_ UINT Weight,
                                          _In_ UINT MipLevels,
                                          _In_ BOOL Italic,
                                          _In_ DWORD CharSet,
                                          _In_ DWORD OutputPrecision,
                                          _In_ DWORD Quality,
                                          _In_ DWORD PitchAndFamily,
                                          _In_ LPCWSTR pFacename,
                                          _Out_ LPD3DXFONT* ppFont);

class WinApi {
 public:
  static void Initialize(void* kernel32);
  static type_get_module_handle GetModuleHandleA;
  static type_create_file CreateFileW;
  static type_write_file WriteFile;
  static type_flush_file_buffers FlushFileBuffers;
  static type_sleep Sleep;
  static type_create_line D3DXCreateLine;
  static type_create_font D3DXCreateFont;
};
```

`shellcode/src/chkstk.asm`:

```asm
; out/main.o:main.cpp:(.text+0x3eb): undefined reference to `__chkstk_ms'
; https://metricpanda.com/rival-fortress-update-45-dealing-with-__chkstk-
; __chkstk_ms-when-cross-compiling-for-windows/

global ___chkstk_ms

section .text

___chkstk_ms:
  ret
```

`shellcode/src/faking_call_ret.asm`:

```asm
global _FakingCallRet

section .text

_FakingCallRet:
  ; Set EBP to return to a second point
  mov ecx, esp
  push ebp        ; save the caller ebp
  push next       ; overwrite the return address
  push esp        ; this value will be popped in EBP
  mov ebp, esp    ; this one will be used to return into @next

  ; Prepare the stack (8 arguments should be enough)
  push dword[ecx+40]  
  push dword[ecx+36]  
  push dword[ecx+32]  
  push dword[ecx+28]  
  push dword[ecx+24]  
  push dword[ecx+20]  
  push dword[ecx+16]  
  push dword[ecx+12]  
  push dword[ecx+8]  ; fake return address

  ; Jump on the targeted function
  mov eax, [ecx+4]  ; arg0: function addr
  jmp eax

  next:
  ; mov eax, 0x41424344
  pop ebp
  ret
```

`shellcode/src/main.cpp`:

```cpp
#include "main.h"

#include <d3dx9core.h>
#include "Esp.h"
#include "GameApi.h"
#include "GameLoop.h"
#include "GameObject.h"
#include "Log.h"
#include "Math.h"
#include "PEHeaders.h"
#include "WinApi.h"
#include "printf.h"
#include "string.h"
#include "GameRenderer.h"

__declspec(dllexport) ExternConfig extern_config;

void DrawPlayerInfo() {
  char str[2048];  // for sprintf

  GameObject* local_player = extern_config.local_player;
  float screen_width = static_cast<float>(extern_config.game_renderer->GetScreenWidth());
  Vector2 text_pos(screen_width - 400, 100);

  sprintf(str, "%.f", *extern_config.game_time);
  Draw::DrawText2D(text_pos, str);
  text_pos.y += 30;

  Draw::DrawText2D(text_pos, local_player->GetName()->c_str());
  text_pos.y += 30;

  MouseManager* mouse = extern_config.hud_instance->GetMouse();
  Vector3* pos = mouse->GetPosition3D();
  sprintf(str, "Mouse: %.f %.f %.f", pos->x, pos->y, pos->z);
  Draw::DrawText2D(text_pos, str);
  text_pos.y += 30;

  SpellInfo* spell = mouse->GetSpell();
  strncpy(str, "Spell selected: ", sizeof(str)-1);
  if (spell) {
    strncat(str, spell->GetName()->c_str(), sizeof(str)-1);
  } else {
    strncat(str, "(none)", sizeof(str)-1);
  }
  Draw::DrawText2D(text_pos, str);
  text_pos.y += 30;
}

void Init(LPDIRECT3DDEVICE9 device) {
  // @todo: check that all the config is valid
  WinApi::Initialize(extern_config.kernel32);
  Log::Initialize();
  GameApi::Initialize(extern_config.game_time);
  Draw::Initialize(device, extern_config.game_renderer->GetScreenWidth(),
                   extern_config.game_renderer->GetScreenHeight(), extern_config.world_to_screen,
                   extern_config.draw_circle);

  Log::LogStr("Injected :D\n");
  Log::LogStr("Dump the configuration:\n");
  Log::LogPrintf("  &extern_config:  0x%p\n", &extern_config);
  Log::LogPrintf("  fn_end_scene:    0x%p\n", extern_config.fn_end_scene);
  Log::LogPrintf("  fn_reset:        0x%p\n", extern_config.fn_reset);
  Log::LogPrintf("  kernel32:        0x%p\n", extern_config.kernel32);
  Log::LogPrintf("  d3d9_device:     0x%p\n", extern_config.d3d9_device);
  Log::LogPrintf("  objects_manager: 0x%p\n", extern_config.objects_manager);
  Log::LogPrintf("  pop_ret:         0x%p\n", extern_config.pop_ret);
  Log::LogPrintf("  local_player:    0x%p\n", extern_config.local_player);
  Log::LogPrintf("  game_renderer:   0x%p\n", extern_config.game_renderer);
  Log::LogPrintf("  game_time:       0x%p\n", extern_config.game_time);
  Log::LogPrintf("  hud_instance:    0x%p\n", extern_config.hud_instance);
  Log::LogStr("\n");
}

bool g_is_init = false;
void OnEndScene(LPDIRECT3DDEVICE9 device) {
  // Save the D3D state and restore ours
  // In fullscreen, only do D3DSBT_VERTEXSTATE
  LPDIRECT3DSTATEBLOCK9 state_block = nullptr;
  device->CreateStateBlock(D3DSBT_ALL, &state_block);

  if (!g_is_init) {
    Init(device);
    g_is_init = true;
  }

  Draw::ResetDevice();

  GameLoop::Update(extern_config.objects_manager, extern_config.local_player);
  Esp::DrawAllEsp();
  DrawPlayerInfo();

  Draw::LostDevice();

  state_block->Apply();
  state_block->Release();
}

HRESULT OnReset(LPDIRECT3DDEVICE9 device, D3DPRESENT_PARAMETERS* pres_parameters) {
  HRESULT result = extern_config.fn_reset(device, pres_parameters);
  return result;
}

__declspec(dllexport) HRESULT WINAPI HkEndScene(LPDIRECT3DDEVICE9 device) {
  OnEndScene(device);
  return extern_config.fn_end_scene(device);
}

__declspec(dllexport) HRESULT WINAPI HkReset(LPDIRECT3DDEVICE9 device, D3DPRESENT_PARAMETERS* pres_parameters) {
  return OnReset(device, pres_parameters);
}
```

`shellcode/src/main.h`:

```h
#pragma once

#include <d3d9.h>
#include <d3dx9.h>
#include <windows.h>
#include "Draw.h"
#include "HudManager.h"

typedef HRESULT(WINAPI* type_end_scene)(LPDIRECT3DDEVICE9 device);
typedef HRESULT(WINAPI* type_reset)(LPDIRECT3DDEVICE9 pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters);

// typedef int*(__thiscall* fnIssueOrder)(void *thisPtr, int Order, Vector *Loc, CObject *Target, bool IsAttackMove, bool IsMinion, DWORD Unknown);
// typedef int* (__thiscall* fnCastSpell)(DWORD spellbook_addr, SpellSlot* spellslot, int SlotID, Vector* targetpos, Vector* startpos, DWORD NetworkID);


class ObjectManager;
class GameObject;
class GameRenderer;

#pragma pack(push)
#pragma pack(1)
struct ExternConfig {
  type_end_scene fn_end_scene;
  type_reset fn_reset;
  void* kernel32;
  LPDIRECT3DDEVICE9 d3d9_device;
  ObjectManager* objects_manager;
  BYTE* pop_ret;
  GameObject* local_player;
  GameRenderer* game_renderer;
  type_world_to_screen world_to_screen;
  type_draw_circle draw_circle;
  float* game_time;
  void* issue_order;
  void* cast_spell;
  HudManager* hud_instance;
};
#pragma pack(pop)

```

`shellcode/src/printf.cpp`:

```cpp
#include "printf.h"

#include <stdbool.h>
#include <stdint.h>

#define PRINTF_DISABLE_SUPPORT_LONG_LONG

// define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
// printf_config.h header file
// default: undefined
#ifdef PRINTF_INCLUDE_CONFIG_H
#include "printf_config.h"
#endif

// 'ntoa' conversion buffer size, this must be big enough to hold one converted
// numeric number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_NTOA_BUFFER_SIZE
#define PRINTF_NTOA_BUFFER_SIZE 32U
#endif

// 'ftoa' conversion buffer size, this must be big enough to hold one converted
// float number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_FTOA_BUFFER_SIZE
#define PRINTF_FTOA_BUFFER_SIZE 32U
#endif

// support for the floating point type (%f)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_FLOAT
#define PRINTF_SUPPORT_FLOAT
#endif

// support for exponential floating point notation (%e/%g)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
#define PRINTF_SUPPORT_EXPONENTIAL
#endif

// define the default floating point precision
// default: 6 digits
#ifndef PRINTF_DEFAULT_FLOAT_PRECISION
#define PRINTF_DEFAULT_FLOAT_PRECISION 6U
#endif

// define the largest float suitable to print with %f
// default: 1e9
#ifndef PRINTF_MAX_FLOAT
#define PRINTF_MAX_FLOAT 1e9
#endif

// support for the long long types (%llu or %p)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
#define PRINTF_SUPPORT_LONG_LONG
#endif

// support for the ptrdiff_t type (%t)
// ptrdiff_t is normally defined in <stddef.h> as long or long long type
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
#define PRINTF_SUPPORT_PTRDIFF_T
#endif

///////////////////////////////////////////////////////////////////////////////

// internal flag definitions
#define FLAGS_ZEROPAD (1U << 0U)
#define FLAGS_LEFT (1U << 1U)
#define FLAGS_PLUS (1U << 2U)
#define FLAGS_SPACE (1U << 3U)
#define FLAGS_HASH (1U << 4U)
#define FLAGS_UPPERCASE (1U << 5U)
#define FLAGS_CHAR (1U << 6U)
#define FLAGS_SHORT (1U << 7U)
#define FLAGS_LONG (1U << 8U)
#define FLAGS_LONG_LONG (1U << 9U)
#define FLAGS_PRECISION (1U << 10U)
#define FLAGS_ADAPT_EXP (1U << 11U)

// import float.h for DBL_MAX
#if defined(PRINTF_SUPPORT_FLOAT)
#include <float.h>
#endif

// output function type
typedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);

// wrapper (used as buffer) for output function type
typedef struct {
  void (*fct)(char character, void* arg);
  void* arg;
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen) {
  if (idx < maxlen) {
    ((char*)buffer)[idx] = character;
  }
}

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen) {
  (void)character;
  (void)buffer;
  (void)idx;
  (void)maxlen;
}

// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen) {
  (void)idx;
  (void)maxlen;
  if (character) {
    // buffer is the output fct pointer
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  }
}

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char* str, size_t maxsize) {
  const char* s;
  for (s = str; *s && maxsize--; ++s)
    ;
  return (unsigned int)(s - str);
}

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) {
  return (ch >= '0') && (ch <= '9');
}

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str) {
  unsigned int i = 0U;
  while (_is_digit(**str)) {
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  }
  return i;
}

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out,
                       char* buffer,
                       size_t idx,
                       size_t maxlen,
                       const char* buf,
                       size_t len,
                       unsigned int width,
                       unsigned int flags) {
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    for (size_t i = len; i < width; i++) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  // reverse string
  while (len) {
    out(buf[--len], buffer, idx++, maxlen);
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
    while (idx - start_idx < width) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  return idx;
}

// internal itoa format
static size_t _ntoa_format(out_fct_type out,
                           char* buffer,
                           size_t idx,
                           size_t maxlen,
                           char* buf,
                           size_t len,
                           bool negative,
                           unsigned int base,
                           unsigned int prec,
                           unsigned int width,
                           unsigned int flags) {
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
      len--;
      if (len && (base == 16U)) {
        len--;
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'x';
    } else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    } else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'b';
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    } else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    } else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}

// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out,
                         char* buffer,
                         size_t idx,
                         size_t maxlen,
                         unsigned long value,
                         bool negative,
                         unsigned long base,
                         unsigned int prec,
                         unsigned int width,
                         unsigned int flags) {
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}

// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out,
                              char* buffer,
                              size_t idx,
                              size_t maxlen,
                              unsigned long long value,
                              bool negative,
                              unsigned long long base,
                              unsigned int prec,
                              unsigned int width,
                              unsigned int flags) {
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
#endif  // PRINTF_SUPPORT_LONG_LONG

#if defined(PRINTF_SUPPORT_FLOAT)

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// forward declaration so that _ftoa can switch to exp notation for values >
// PRINTF_MAX_FLOAT
static size_t _etoa(out_fct_type out,
                    char* buffer,
                    size_t idx,
                    size_t maxlen,
                    double value,
                    unsigned int prec,
                    unsigned int width,
                    unsigned int flags);
#endif

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out,
                    char* buffer,
                    size_t idx,
                    size_t maxlen,
                    double value,
                    unsigned int prec,
                    unsigned int width,
                    unsigned int flags) {
  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len = 0U;
  double diff = 0.0;

  // powers of 10
  static const double pow10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};

  // test for special values
  if (value != value)
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U,
                    width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which
  // could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
#else
    return 0U;
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    buf[len++] = '0';
    prec--;
  }

  int whole = (int)value;
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
    ++frac;
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  } else if (diff < 0.5) {
  } else if ((frac == 0U) || (frac & 1U)) {
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  }

  if (prec == 0U) {
    diff = value - (double)whole;
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
    }
  } else {
    unsigned int count = prec;
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
      --count;
      buf[len++] = (char)(48U + (frac % 10U));
      if (!(frac /= 10U)) {
        break;
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
      buf[len++] = '0';
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
      // add decimal
      buf[len++] = '.';
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
    if (!(whole /= 10)) {
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_FTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    } else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    } else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out,
                    char* buffer,
                    size_t idx,
                    size_t maxlen,
                    double value,
                    unsigned int prec,
                    unsigned int width,
                    unsigned int flags) {
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
    value = -value;
  }

  // default precision
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }

  // determine the decimal exponent
  // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
  union {
    uint64_t U;
    double F;
  } conv;

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln
  // around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see
  // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  // correct for rounding errors
  if (value < conv.F) {
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5
  // characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
      if ((int)prec > expval) {
        prec = (unsigned)((int)prec - expval - 1);
      } else {
        prec = 0;
      }
      flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
      // no characters in exponent
      minwidth = 0U;
      expval = 0;
    } else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
        --prec;
      }
    }
  }

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
    value /= conv.F;
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);

  // output the exponent part
  if (minwidth) {
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth - 1,
                     FLAGS_ZEROPAD | FLAGS_PLUS);
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
      while (idx - start_idx < width)
        out(' ', buffer, idx++, maxlen);
    }
  }
  return idx;
}
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va) {
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  }

  while (*format) {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
      // no
      out(*format, buffer, idx++, maxlen);
      format++;
      continue;
    } else {
      // yes, evaluate it
      format++;
    }

    // evaluate flags
    flags = 0U;
    do {
      switch (*format) {
        case '0':
          flags |= FLAGS_ZEROPAD;
          format++;
          n = 1U;
          break;
        case '-':
          flags |= FLAGS_LEFT;
          format++;
          n = 1U;
          break;
        case '+':
          flags |= FLAGS_PLUS;
          format++;
          n = 1U;
          break;
        case ' ':
          flags |= FLAGS_SPACE;
          format++;
          n = 1U;
          break;
        case '#':
          flags |= FLAGS_HASH;
          format++;
          n = 1U;
          break;
        default:
          n = 0U;
          break;
      }
    } while (n);

    // evaluate width field
    width = 0U;
    if (_is_digit(*format)) {
      width = _atoi(&format);
    } else if (*format == '*') {
      const int w = va_arg(va, int);
      if (w < 0) {
        flags |= FLAGS_LEFT;  // reverse padding
        width = (unsigned int)-w;
      } else {
        width = (unsigned int)w;
      }
      format++;
    }

    // evaluate precision field
    precision = 0U;
    if (*format == '.') {
      flags |= FLAGS_PRECISION;
      format++;
      if (_is_digit(*format)) {
        precision = _atoi(&format);
      } else if (*format == '*') {
        const int prec = (int)va_arg(va, int);
        precision = prec > 0 ? (unsigned int)prec : 0U;
        format++;
      }
    }

    // evaluate length field
    switch (*format) {
      case 'l':
        flags |= FLAGS_LONG;
        format++;
        if (*format == 'l') {
          flags |= FLAGS_LONG_LONG;
          format++;
        }
        break;
      case 'h':
        flags |= FLAGS_SHORT;
        format++;
        if (*format == 'h') {
          flags |= FLAGS_CHAR;
          format++;
        }
        break;
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't':
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
#endif
      case 'j':
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
      case 'z':
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
        format++;
        break;
      default:
        break;
    }

    // evaluate specifier
    switch (*format) {
      case 'd':
      case 'i':
      case 'u':
      case 'x':
      case 'X':
      case 'o':
      case 'b': {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
          base = 16U;
        } else if (*format == 'o') {
          base = 8U;
        } else if (*format == 'b') {
          base = 2U;
        } else {
          base = 10U;
          flags &= ~FLAGS_HASH;  // no hash for dec format
        }
        // uppercase
        if (*format == 'X') {
          flags |= FLAGS_UPPERCASE;
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
          flags &= ~FLAGS_ZEROPAD;
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
          // signed
          if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value),
                                  value < 0, base, precision, width, flags);
#endif
          } else if (flags & FLAGS_LONG) {
            const long value = va_arg(va, long);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base,
                             precision, width, flags);
          } else {
            const int value = (flags & FLAGS_CHAR)
                                  ? (char)va_arg(va, int)
                                  : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base,
                             precision, width, flags);
          }
        } else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision,
                                  width, flags);
#endif
          } else if (flags & FLAGS_LONG) {
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
          } else {
            const unsigned int value =
                (flags & FLAGS_CHAR)
                    ? (unsigned char)va_arg(va, unsigned int)
                    : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
          }
        }
        format++;
        break;
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f':
      case 'F':
        if (*format == 'F')
          flags |= FLAGS_UPPERCASE;
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
        format++;
        break;
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
      case 'e':
      case 'E':
      case 'g':
      case 'G':
        if ((*format == 'g') || (*format == 'G'))
          flags |= FLAGS_ADAPT_EXP;
        if ((*format == 'E') || (*format == 'G'))
          flags |= FLAGS_UPPERCASE;
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
        format++;
        break;
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c': {
        unsigned int l = 1U;
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
        // post padding
        if (flags & FLAGS_LEFT) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        format++;
        break;
      }

      case 's': {
        const char* p = va_arg(va, char*);
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
        // pre padding
        if (flags & FLAGS_PRECISION) {
          l = (l < precision ? l : precision);
        }
        if (!(flags & FLAGS_LEFT)) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
          out(*(p++), buffer, idx++, maxlen);
        }
        // post padding
        if (flags & FLAGS_LEFT) {
          while (l++ < width) {
            out(' ', buffer, idx++, maxlen);
          }
        }
        format++;
        break;
      }

      case 'p': {
        width = sizeof(void*) * 2U;
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width,
                                flags);
        } else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U,
                           precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
        break;
      }

      case '%':
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default:
        out(*format, buffer, idx++, maxlen);
        format++;
        break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
}

///////////////////////////////////////////////////////////////////////////////

int sprintf(char* buffer, const char* format, ...) {
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  va_end(va);
  return ret;
}

int sprintf(char* buffer, const char* format, va_list va) {
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  return ret;
}

int snprintf(char* buffer, size_t count, const char* format, ...) {
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  va_end(va);
  return ret;
}

int vsnprintf(char* buffer, size_t count, const char* format, va_list va) {
  return _vsnprintf(_out_buffer, buffer, count, format, va);
}

int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...) {
  va_list va;
  va_start(va, format);
  const out_fct_wrap_type out_fct_wrap = {out, arg};
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  va_end(va);
  return ret;
}

```

`shellcode/src/printf.h`:

```h
#pragma once
// https://github.com/mpaland/printf

#include <stdarg.h>
#include <stddef.h>

/**
 * Tiny sprintf implementation
 * Due to security reasons (buffer overflow) YOU SHOULD CONSIDER USING
 * (V)SNPRINTF INSTEAD! \param buffer A pointer to the buffer where to store the
 * formatted string. MUST be big enough to store the output! \param format A
 * string that specifies the format of the output \return The number of
 * characters that are WRITTEN into the buffer, not counting the terminating
 * null character
 */
int sprintf(char* buffer, const char* format, ...);
int sprintf(char* buffer, const char* format, va_list va);

/**
 * Tiny snprintf/vsnprintf implementation
 * \param buffer A pointer to the buffer where to store the formatted string
 * \param count The maximum number of characters to store in the buffer,
 * including a terminating null character \param format A string that specifies
 * the format of the output \param va A value identifying a variable arguments
 * list \return The number of characters that COULD have been written into the
 * buffer, not counting the terminating null character. A value equal or larger
 * than count indicates truncation. Only when the returned value is non-negative
 * and less than count, the string has been completely written.
 */
int snprintf(char* buffer, size_t count, const char* format, ...);
int vsnprintf(char* buffer, size_t count, const char* format, va_list va);

/**
 * printf with output function
 * You may use this as dynamic alternative to printf() with its fixed _putchar()
 * output \param out An output function which takes one character and an
 * argument pointer \param arg An argument pointer for user data passed to
 * output function \param format A string that specifies the format of the
 * output \return The number of characters that are sent to the output function,
 * not counting the terminating null character
 */
int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);

```

`shellcode/src/string.cpp`:

```cpp
#include "string.h"

typedef unsigned char BYTE;

void* memcpy(void* dst, const void* src, size_t size) {
  BYTE* dst_b = static_cast<BYTE*>(dst);
  const BYTE* src_b = static_cast<const BYTE*>(src);

  while (size > 0) {
    *dst_b++ = *src_b++;
    size--;
  }
  return dst;
}

void* memset(void* ptr, int value, size_t num) {
  unsigned char* data = static_cast<unsigned char*>(ptr);
  for (size_t i = 0; i < num; i++) {
    data[i] = value;
  }
  return ptr;
}

int strcmp(const char* str1, const char* str2) {
  while (*str1 && *str2 && *str1 == *str2) {
    str1++;
    str2++;
  }
  return *str1 - *str2;
}

int tolower2(int character) {
  if (character >= 'A' && character <= 'Z') {
    return character + ('a' - 'A');
  }
  return character;
}

int stricmp(const char* str1, const char* str2) {
  while (*str1 && *str2 && tolower2(*str1) == tolower2(*str2)) {
    str1++;
    str2++;
  }
  return *str1 - *str2;
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  const char* mem1 = static_cast<const char*>(ptr1);
  const char* mem2 = static_cast<const char*>(ptr2);
  while (num && *mem1 == *mem2) {
    mem1++;
    mem2++;
    num--;
  }
  return *mem1 - *mem2;
}

char* strncpy(char* destination, const char* source, size_t num) {
  while (num) {
    *destination++ = *source;
    num--;

    if (!*source) {
      break;
    }
    source++;
  }
  return destination;
}

char* strncat(char* destination, const char* source, size_t num) {
  char* ret = destination;

  while (*destination) {
    destination++;
    num--;
  }
  while (num && *source) {
    *destination++ = *source++;
    num--;
  }
  *destination = '\x00';

  return ret;
}

size_t strlen(const char* str) {
  size_t len = 0;
  while (*str) {
    str++;
    len++;
  }
  return len;
}

void* memchr(const void* ptr, int c, size_t num) {
  unsigned char* data = const_cast<unsigned char*>(static_cast<const unsigned char*>(ptr));
  while (num) {
    if (*data == static_cast<unsigned char>(c)) {
      return data;
    }
    data++;
    num--;
  }
  return nullptr;
}

void* memmove(void* dest, const void* src, size_t len) {
  char* d = static_cast<char*>(dest);
  const char* s = static_cast<const char*>(src);
  if (d < s) {
    while (len--) {
      *d++ = *s++;
    }
  } else {
    const char* lasts = s + (len - 1);
    char* lastd = d + (len - 1);
    while (len--) {
      *lastd-- = *lasts--;
    }
  }
  return dest;
}

char* itoa(int value, char* out, int base) {
  if (value < 0) {
    out[0] = '-';
  }

  int len = 0;
  int value_copy = value;
  do {
    value_copy /= base;
    len++;
  } while (value_copy);

  out[len] = '\0';

  size_t i = len - 1;
  if (value < 0) {
    value = -value;
    i++;
  }

  do {
    out[i--] = static_cast<char>(value % base) + '0';
    value /= base;
  } while (value);

  return out;
}
```

`shellcode/src/string.h`:

```h
#pragma once
#include <stddef.h>

extern "C" void* memcpy(void* dst, const void* src, size_t size);
extern "C" void* memset(void* ptr, int value, size_t num);
extern "C" int strcmp(const char* str1, const char* str2);
extern "C" int tolower2(int character);
extern "C" int stricmp(const char* str1, const char* str2);
extern "C" int memcmp(const void* ptr1, const void* ptr2, size_t num);
extern "C" char* strncpy(char* destination, const char* source, size_t num);
extern "C" char* strncat(char* destination, const char* source, size_t num);
extern "C" size_t strlen(const char* str);
extern "C" void* memchr(const void* ptr, int c, size_t num);
extern "C" void* memmove(void* dest, const void* src, size_t len);
extern "C" char* itoa(int value, char* out, int base);

```