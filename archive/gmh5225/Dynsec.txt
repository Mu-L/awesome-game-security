Project Path: arc_gmh5225_Dynsec_gpvoc31x

Source Tree:

```txt
arc_gmh5225_Dynsec_gpvoc31x
├── Client
│   ├── Client.vcxproj
│   ├── Client.vcxproj.filters
│   └── src
│       ├── dllmain.cpp
│       ├── dynsec
│       │   ├── crypto
│       │   │   ├── crypto.cpp
│       │   │   └── crypto.hpp
│       │   ├── init
│       │   │   ├── init.cpp
│       │   │   ├── init.hpp
│       │   │   ├── routines
│       │   │   │   ├── routines.cpp
│       │   │   │   └── routines.hpp
│       │   │   ├── tls_manager.cpp
│       │   │   └── tls_manager.hpp
│       │   ├── network
│       │   │   ├── encryption.cpp
│       │   │   ├── encryption.hpp
│       │   │   ├── network_socket.cpp
│       │   │   └── network_socket.hpp
│       │   ├── shellcode
│       │   │   ├── shellcode.cpp
│       │   │   └── shellcode.hpp
│       │   └── types
│       │       ├── init_types.hpp
│       │       ├── packet_types.hpp
│       │       └── routine_types.hpp
│       ├── global
│       │   ├── variables.cpp
│       │   └── variables.hpp
│       ├── stdafx.cpp
│       ├── stdafx.hpp
│       ├── syscall_callback.asm
│       └── utils
│           ├── caller.hpp
│           ├── math.hpp
│           ├── memory
│           │   ├── memory.cpp
│           │   └── memory.hpp
│           ├── scans
│           │   ├── signature_scan.cpp
│           │   └── signature_scan.hpp
│           ├── secure
│           │   ├── module.cpp
│           │   ├── module.hpp
│           │   ├── pointers.cpp
│           │   ├── pointers.hpp
│           │   ├── resolved.cpp
│           │   ├── resolved.hpp
│           │   ├── syscall.cpp
│           │   ├── syscall.hpp
│           │   ├── virtual.cpp
│           │   └── virtual.hpp
│           ├── structs.hpp
│           ├── threads
│           │   ├── async.cpp
│           │   ├── async.hpp
│           │   ├── thread_pool.cpp
│           │   └── thread_pool.hpp
│           ├── utils.cpp
│           ├── utils.hpp
│           ├── va.cpp
│           └── va.hpp
├── DynSec Wrapper
│   ├── DynSec Wrapper.csproj
│   └── DynSec.cs
├── Dynsec.sln
├── NETTestingGrounds
│   ├── NETTestingGrounds.csproj
│   └── Program.cs
└── TestingGrounds
    ├── TestingGrounds.vcxproj
    ├── TestingGrounds.vcxproj.filters
    └── src
        └── TestingGrounds.cpp

```

`Client/Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;CLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir)src\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;CLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir)src\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;CLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir)src\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;CLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir)src\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="src\dynsec\crypto\crypto.hpp" />
    <ClInclude Include="src\dynsec\init\init.hpp" />
    <ClInclude Include="src\dynsec\init\routines\routines.hpp" />
    <ClInclude Include="src\dynsec\init\tls_manager.hpp" />
    <ClInclude Include="src\dynsec\network\encryption.hpp" />
    <ClInclude Include="src\dynsec\network\network_socket.hpp" />
    <ClInclude Include="src\dynsec\shellcode\shellcode.hpp" />
    <ClInclude Include="src\dynsec\types\init_types.hpp" />
    <ClInclude Include="src\dynsec\types\packet_types.hpp" />
    <ClInclude Include="src\dynsec\types\routine_types.hpp" />
    <ClInclude Include="src\global\variables.hpp" />
    <ClInclude Include="src\stdafx.hpp" />
    <ClInclude Include="src\utils\memory\memory.hpp" />
    <ClInclude Include="src\utils\secure\resolved.hpp" />
    <ClInclude Include="src\utils\threads\async.hpp" />
    <ClInclude Include="src\utils\caller.hpp" />
    <ClInclude Include="src\utils\math.hpp" />
    <ClInclude Include="src\utils\scans\signature_scan.hpp" />
    <ClInclude Include="src\utils\secure\pointers.hpp" />
    <ClInclude Include="src\utils\secure\virtual.hpp" />
    <ClInclude Include="src\utils\secure\module.hpp" />
    <ClInclude Include="src\utils\structs.hpp" />
    <ClInclude Include="src\utils\secure\syscall.hpp" />
    <ClInclude Include="src\utils\threads\thread_pool.hpp" />
    <ClInclude Include="src\utils\utils.hpp" />
    <ClInclude Include="src\utils\va.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\dllmain.cpp" />
    <ClCompile Include="src\dynsec\crypto\crypto.cpp" />
    <ClCompile Include="src\dynsec\init\init.cpp" />
    <ClCompile Include="src\dynsec\init\routines\routines.cpp" />
    <ClCompile Include="src\dynsec\init\tls_manager.cpp" />
    <ClCompile Include="src\dynsec\network\encryption.cpp" />
    <ClCompile Include="src\dynsec\network\network_socket.cpp" />
    <ClCompile Include="src\dynsec\shellcode\shellcode.cpp" />
    <ClCompile Include="src\global\variables.cpp" />
    <ClCompile Include="src\stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="src\utils\memory\memory.cpp" />
    <ClCompile Include="src\utils\secure\resolved.cpp" />
    <ClCompile Include="src\utils\threads\async.cpp" />
    <ClCompile Include="src\utils\scans\signature_scan.cpp" />
    <ClCompile Include="src\utils\secure\module.cpp" />
    <ClCompile Include="src\utils\secure\pointers.cpp" />
    <ClCompile Include="src\utils\secure\syscall.cpp" />
    <ClCompile Include="src\utils\secure\virtual.cpp" />
    <ClCompile Include="src\utils\threads\thread_pool.cpp" />
    <ClCompile Include="src\utils\utils.cpp" />
    <ClCompile Include="src\utils\va.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\syscall_callback.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Client/Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\va.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\init\init.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\secure\syscall.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\secure\module.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\secure\virtual.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\network\network_socket.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\network\encryption.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\secure\pointers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\shellcode\shellcode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\crypto\crypto.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\global\variables.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\init\tls_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\dynsec\init\routines\routines.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\scans\signature_scan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\threads\async.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\threads\thread_pool.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\memory\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\secure\resolved.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\stdafx.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\types\init_types.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\va.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\init\init.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\caller.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\structs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\secure\syscall.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\secure\module.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\secure\virtual.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\types\packet_types.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\network\network_socket.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\network\encryption.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\secure\pointers.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\math.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\shellcode\shellcode.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\crypto\crypto.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\global\variables.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\init\tls_manager.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\init\routines\routines.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\scans\signature_scan.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\threads\async.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\threads\thread_pool.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\dynsec\types\routine_types.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\memory\memory.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\secure\resolved.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="src\syscall_callback.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Client/src/dllmain.cpp`:

```cpp
#include "stdafx.hpp"
#include "dynsec/init/init.hpp"
#include "utils/secure/syscall.hpp"
#include "utils/secure/resolved.hpp"
#include "utils/secure/virtual.hpp"
#include "global/variables.hpp"
#include "utils/utils.hpp"
#include "utils/threads/thread_pool.hpp"

extern "C" __declspec(dllexport) void __stdcall InitializeClient(void* pDynsecData) {
	// caller checks here
	return Dynsec::Init::InitializeClient(static_cast<Dynsec::InitTypes::GameDataInit*>(pDynsecData));
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
		Global::Vars::g_ModuleHandle = hModule;
		srand((unsigned int)time(0));

		if (!Utils::Secure::GetSyscalls()->Initialize()) {
			printf("failed GetSyscalls()->Initialize\n");
			return FALSE;
		}

		if (!Utils::Secure::GetResolved()->Initialize()) {
			printf("failed GetResolved()->Initialize\n");
			return FALSE;
		}

		Utils::Threads::GetThreadPool()->CreateThread(0xBEEF, Dynsec::Init::Initialize, nullptr);
	}

	return TRUE;
}
```

`Client/src/dynsec/crypto/crypto.cpp`:

```cpp
#include "crypto.hpp"

namespace Dynsec::Crypto {
#define IS_ALIGNED_32(p) (0 == (3 & ((const char*)(p) - (const char*)0)))
#define ROTR64(Data, Bits) (((Data) >> Bits) | ((Data) << (64 - Bits)))
#define Sigma0(x) (ROTR64((x),28) ^ ROTR64((x),34) ^ ROTR64((x),39))
#define Sigma1(x) (ROTR64((x),14) ^ ROTR64((x),18) ^ ROTR64((x),41))
#define sigma0(x) (ROTR64((x),1) ^ ROTR64((x),8) ^ ((x)>>7))
#define sigma1(x) (ROTR64((x),19) ^ ROTR64((x),61) ^ ((x)>>6))
#define Ch(x,y,z) (((x) & (y)) ^ ((~(x)) & (z)))
#define Maj(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

	static const uint64_t SHA512InitialState[8] = {
		0x6A09E667F3BCC908, 0xBB67AE8584CAA73B, 0x3C6EF372FE94F82B,
		0xA54FF53A5F1D36F1, 0x510E527FADE682D1, 0x9B05688C2B3E6C1F,
		0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179
	};

	static const uint64_t SHA512K[80] = {
		0x428A2F98D728AE22, 0x7137449123EF65CD, 0xB5C0FBCFEC4D3B2F,
		0xE9B5DBA58189DBBC, 0x3956C25BF348B538, 0x59F111F1B605D019,
		0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118, 0xD807AA98A3030242,
		0x12835B0145706FBE, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
		0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x9BDC06A725C71235,
		0xC19BF174CF692694, 0xE49B69C19EF14AD2, 0xEFBE4786384F25E3,
		0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65, 0x2DE92C6F592B0275,
		0x4A7484AA6EA6E483, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
		0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0xB00327C898FB213F,
		0xBF597FC7BEEF0EE4, 0xC6E00BF33DA88FC2, 0xD5A79147930AA725,
		0x06CA6351E003826F, 0x142929670A0E6E70, 0x27B70A8546D22FFC,
		0x2E1B21385C26C926, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
		0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x81C2C92E47EDAEE6,
		0x92722C851482353B, 0xA2BFE8A14CF10364, 0xA81A664BBC423001,
		0xC24B8B70D0F89791, 0xC76C51A30654BE30, 0xD192E819D6EF5218,
		0xD69906245565A910, 0xF40E35855771202A, 0x106AA07032BBD1B8,
		0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x2748774CDF8EEB99,
		0x34B0BCB5E19B48A8, 0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB,
		0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3, 0x748F82EE5DEFB2FC,
		0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
		0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0xBEF9A3F7B2C67915,
		0xC67178F2E372532B, 0xCA273ECEEA26619C, 0xD186B8C721C0C207,
		0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178, 0x06F067AA72176FBA,
		0x0A637DC5A2C898A6, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
		0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC,
		0x431D67C49C100D4C, 0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A,
		0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817
	};

	static const unsigned int CRC32Table[] = {
	  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
	  0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
	  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
	  0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
	  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
	  0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
	  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
	  0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
	  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
	  0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
	  0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
	  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
	  0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
	  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
	  0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
	  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
	  0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
	  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
	  0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
	  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
	  0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
	  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
	  0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
	  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
	  0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
	  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
	  0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
	  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
	  0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
	  0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
	  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
	  0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
	  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
	  0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
	  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
	  0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
	  0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
	  0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
	  0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
	  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
	  0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
	  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
	  0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
	  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
	  0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
	  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
	  0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
	  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
	  0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
	  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
	  0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
	  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
	  0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
	  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
	  0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
	  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
	  0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
	  0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
	  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
	  0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
	};

	uint32_t CRC32(uint8_t* pbInp, uint64_t cbInp) {
		uint32_t crc = 0xffffffff;
		while (cbInp--) {
			crc = (crc << 8) ^ CRC32Table[((crc >> 24) ^ *pbInp) & 255];
			pbInp++;
		}
		return crc;
	}

	void RC4(uint8_t* pbKey, uint32_t cbKey, uint8_t* pbInpOut, uint32_t cbInpOut, uint32_t Offset) {
		unsigned char s[256];
		unsigned char k[256];
		unsigned char temp;
		int i, j;

		for (i = 0; i < 256; i++) {
			s[i] = (unsigned char)i;
			k[i] = pbKey[i % cbKey];
		}

		j = 0;
		for (i = 0; i < 256; i++) {
			j = (j + s[i] + k[i]) % 256;
			temp = s[i];
			s[i] = s[j];
			s[j] = temp;
		}

		i = j = 0;
		for (unsigned int x = Offset; x < cbInpOut; x++) {
			i = (i + 1) % 256;
			j = (j + s[i]) % 256;
			temp = s[i];
			s[i] = s[j];
			s[j] = temp;
			int t = (s[i] + s[j]) % 256;
			pbInpOut[x] ^= s[t];
		}
	}

	void SHA512Init(SHA512State* pShaState) {
		memset(pShaState, 0, sizeof(SHA512State));

		pShaState->m_Count = 0;
		memcpy(&pShaState->m_State, SHA512InitialState, sizeof(SHA512InitialState));
	}

	void SHA512Transform(uint64_t* pDigest, uint64_t* pInp) {
		uint64_t* W = pInp;
		uint64_t X[128 / sizeof(uint64_t)];

		uint64_t A = pDigest[0];
		uint64_t B = pDigest[1];
		uint64_t C = pDigest[2];
		uint64_t D = pDigest[3];
		uint64_t E = pDigest[4];
		uint64_t F = pDigest[5];
		uint64_t G = pDigest[6];
		uint64_t H = pDigest[7];

		int i;

		for (i = 0; i < 16; ++i) {
			uint64_t Temp1 = X[i] = _byteswap_uint64(W[i]);
			uint64_t Temp2 = 0;

			Temp1 += H + Sigma1(E) + Ch(E, F, G) + SHA512K[i];
			Temp2 = Sigma0(A) + Maj(A, B, C);

			H = G;
			G = F;
			F = E;
			E = D + Temp1;
			D = C;
			C = B;
			B = A;
			A = Temp1 + Temp2;
		}

		for (; i < 80; ++i) {
			uint64_t Temp1 = 0;
			uint64_t Temp2 = 0;

			uint64_t S0 = sigma0(X[(i + 1) & 15]);
			uint64_t S1 = sigma1(X[(i + 14) & 15]);

			Temp1 = X[i & 15] += S0 + S1 + X[(i + 9) & 15];
			Temp1 += H + Sigma1(E) + Ch(E, F, G) + SHA512K[i];
			Temp2 = Sigma0(A) + Maj(A, B, C);

			H = G;
			G = F;
			F = E;
			E = D + Temp1;
			D = C;
			C = B;
			B = A;
			A = Temp1 + Temp2;
		}

		pDigest[0] += A;
		pDigest[1] += B;
		pDigest[2] += C;
		pDigest[3] += D;
		pDigest[4] += E;
		pDigest[5] += F;
		pDigest[6] += G;
		pDigest[7] += H;
	}

	void SHA512Update(SHA512State* pShaState, uint8_t* pbInp, uint32_t cbInp) {
		DWORD Index = pShaState->m_Count & 127;

		pShaState->m_Count = pShaState->m_Count + cbInp;

		if (Index) {
			if (Index + cbInp >= 128) {
				memcpy(&pShaState->m_Buffer[Index], pbInp, Index - 128);

				SHA512Transform((uint64_t*)pShaState->m_State, (uint64_t*)pShaState->m_Buffer);

				pbInp += 128;
				cbInp -= 128;
			}
		}

		if (cbInp >= 128) {
			DWORD Blocks = (Index + cbInp) / 128;

			if (IS_ALIGNED_32(pbInp)) {
				for (DWORD i = 0; i < Blocks; ++i) {
					SHA512Transform((uint64_t*)pShaState->m_State, (uint64_t*)pbInp);

					pbInp += 128;
					cbInp -= 128;
				}
			} else {
				for (DWORD i = 0; i < Blocks; ++i) {
					memcpy(pShaState->m_Buffer, pbInp, 128);

					SHA512Transform((uint64_t*)pShaState->m_State, (uint64_t*)pShaState->m_Buffer);

					pbInp += 128;
					cbInp -= 128;
				}
			}
		}

		if (cbInp) {
			memcpy(pShaState->m_Buffer, pbInp, cbInp);
		}
	}

	void SHA512Final(SHA512State* pShaState, uint8_t* pbOut, uint32_t cbOut) {
		DWORD Count = pShaState->m_Count;

		DWORD Index = Count & 127;

		memset(&pShaState->m_Buffer[Index], 0, 128 - Index);

		pShaState->m_Buffer[Index] = 0x80;

		if (128 - Index < 17) {
			SHA512Transform((uint64_t*)pShaState->m_State, (uint64_t*)pShaState->m_Buffer);

			memset(pShaState->m_Buffer, 0, Index + 1);
		}

		Count = Count << 3;

		DWORD* New = (DWORD*)&pShaState->m_Buffer[128 - sizeof(DWORD)];
		DWORD* Input = &Count;

		for (std::size_t i = 0; i < 1; ++i) {
			New[i] = _byteswap_ulong(Input[i]);
		}

		SHA512Transform((uint64_t*)pShaState->m_State, (uint64_t*)pShaState->m_Buffer);

		if (cbOut != 0) {
			for (int i = 0; i < ARRAYSIZE(pShaState->m_State); ++i) {
				pShaState->m_State[i] = _byteswap_uint64(pShaState->m_State[i]);
			}

			if (cbOut < 64) {
				memcpy(pbOut, pShaState->m_State, cbOut);
			} else {
				memcpy(pbOut, pShaState->m_State, 64);
			}
		}
	}
}
```

`Client/src/dynsec/crypto/crypto.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Dynsec::Crypto {
	struct SHA512State {
		uint32_t m_Count;
		uint64_t m_State[8];
		uint8_t m_Buffer[128];
	};

	void RC4(uint8_t* pbKey, uint32_t cbKey, uint8_t* pbInpOut, uint32_t cbInpOut, uint32_t Offset = 0);
	void SHA512Init(SHA512State* pShaState);
	void SHA512Update(SHA512State* pShaState, uint8_t* pbInp, uint32_t cbInp);
	void SHA512Final(SHA512State* pShaState, uint8_t* pbOut, uint32_t cbOut);
	uint32_t CRC32(uint8_t* pbInp, uint64_t cbInp);
}
```

`Client/src/dynsec/init/init.cpp`:

```cpp
#include "init.hpp"
#include "routines/routines.hpp"
#include "tls_manager.hpp"
#include "global/variables.hpp"
#include "utils/secure/syscall.hpp"
#include "utils/secure/virtual.hpp"
#include "utils/threads/thread_pool.hpp"
#include "utils/secure/pointers.hpp"
#include "utils/utils.hpp"
#include "dynsec/crypto/crypto.hpp"

extern "C" void __fastcall hook_wrapper(VOID);

namespace Dynsec::Init {
	void InitializeClient(Dynsec::InitTypes::GameDataInit* InitData) {
		// initialized from client
		Global::Vars::g_GameDataInit = (Dynsec::InitTypes::GameDataInit*)EncodePtr(InitData);

		printf("[Game] -> InitializeClient (%llx)\n", InitData);
	}

	void Initialize(LPVOID lpParam) {

		// Initialize our hacky TLS Callback
		GetTLSManager()->RegisterCallback(Global::Vars::g_ModuleHandle, Dynsec::Routines::ThreadLocalStorageCallback);

		// Initialize our syscall monitor
		PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION InstrumentationCallback;
#ifdef _WIN64
		InstrumentationCallback = { 0, 0, hook_wrapper };
#else
		InstrumentationCallback = { 1, 0, hook_wrapper };
#endif

		// Utils::Secure::GetSyscalls()->NtSetInformationProcess(GetCurrentProcess(), PROCESS_INSTRUMENTATION_CALLBACK, &InstrumentationCallback, sizeof(InstrumentationCallback));

		// Temp add a sig
		Global::Vars::g_MemorySignatures.push_back({ 0x1, false, "[Game] -> InitializeClie" });

		// Temp add a thread shellcode (ExtremeInjector -> ManualMap)
		Global::Vars::g_ThreadEntrySignatures.push_back({ 0x1, "48 89 4C 24 08 48 89 54 24 10 4C 89 44 24 18 4C 89 4C 24 20 48 83 EC 28 48 33 C9 48 BA ? ? ? ? ? ? ? ? 4C 8D 05 ? ? ? ? 48 B8 ? ? ? ? ? ? ? ? FF D0" });

		// Temp add a window title
		Global::Vars::g_WindowTitleSignatures.push_back("AIMWARE");

		// Create the memory scan thread
		Utils::Threads::GetThreadPool()->CreateThread(0xDEAD, Dynsec::Routines::MemoryScanRoutine, nullptr);

		// Create the exploitable module scan thread
		Utils::Threads::GetThreadPool()->CreateThread(0xC0DE, Dynsec::Routines::ExploitableModuleScanRoutine, nullptr);

		// Create the window name scan thread
		Utils::Threads::GetThreadPool()->CreateThread(0x1337, Dynsec::Routines::WindowScanRoutine, nullptr);

		// Close this thread (tmp)
		Utils::Threads::GetThreadPool()->CloseThread(0xBEEF);
	}
}
```

`Client/src/dynsec/init/init.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "dynsec/types/init_types.hpp"

namespace Dynsec::Init {
	void Initialize(LPVOID lpParam);
	void InitializeClient(Dynsec::InitTypes::GameDataInit* InitData);
}
```

`Client/src/dynsec/init/routines/routines.cpp`:

```cpp
#include "routines.hpp"
#include "global/variables.hpp"
#include "utils/utils.hpp"
#include "utils/scans/signature_scan.hpp"
#include "utils/secure/virtual.hpp"
#include "utils/secure/module.hpp"
#include "utils/secure/syscall.hpp"
#include "dynsec/crypto/crypto.hpp"
#include "utils/secure/pointers.hpp"

#include "utils/va.hpp"

namespace Dynsec::Routines {
	void MemoryScanRoutine(LPVOID lpParam) {
		auto MemoryPages = Utils::Secure::GetMemoryPages();
		
		// 5 is a psuedo number for now, basically want to log if the memory page scan was very low (impossible, really)
		if (MemoryPages.size() <= 5) {
			// Report
		}

		auto start = std::chrono::high_resolution_clock::now();
		for (auto& Page : MemoryPages) {
			// Code sections, etc
			bool ExecutableMemory =
				(Page.Protect == PAGE_EXECUTE
					|| Page.Protect == PAGE_EXECUTE_READ
					|| Page.Protect == PAGE_EXECUTE_READWRITE
					|| Page.Protect == PAGE_EXECUTE_WRITECOPY);

			// Data sections, etc
			bool StorageMemory = 
				(Page.Protect == PAGE_READONLY
					|| Page.Protect == PAGE_READWRITE);

			// Skip pages that aren't executable and aren't read/write
			if (!ExecutableMemory && !StorageMemory) continue;

			for (auto& Signature : Global::Vars::g_MemorySignatures) {
				// TODO: Signature encryption (lightweight RC4)
				if ((Signature.m_Executable && ExecutableMemory)
					|| (!Signature.m_Executable && StorageMemory)) {
					// Process
					if (Signature.m_Signature.size()) {
						uint64_t ScanResult = Utils::Scans::PatternScan((uint64_t)Page.BaseAddress, (uint64_t)Page.BaseAddress + Page.RegionSize, Signature.m_Signature.c_str());
						if (ScanResult && ScanResult != (uint64_t)Signature.m_Signature.data()) {
							printf("Scan %x found at %llx\n", Signature.m_Identifier, ScanResult);
						}
					}
				}
			}

			// Check for allocated executable pages outside of mapped modules
			if ((Page.Type == MEM_PRIVATE || Page.Type == MEM_MAPPED) && ExecutableMemory) {
				uint64_t PageAddress = (uint64_t)Page.BaseAddress;

				// Check if the address is in any modules (thanks BE)
				if ((PageAddress & 0xFF0000000000) != 0x7F0000000000
					&& (PageAddress & 0xFFF000000000) != 0x7F000000000
					&& (PageAddress & 0xFFFFF0000000) != 0x70000000
					&& PageAddress != 0x3E0000) {
					if (PageAddress != (uint64_t)Utils::Secure::GetSyscalls()->GetAllocatedPage()) {
						// Report
						printf("Executable memory outside of a mapped module at %llx\n", PageAddress);
					}
				}
			}
		}

		auto elapsed = std::chrono::high_resolution_clock::now() - start;
		long long microseconds = std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
		printf("%i microseconds to scan all memory pages for 1 signature\n", microseconds);

		// Once a minute
		Sleep(1min);
	}

	void ExploitableModuleScanRoutine(LPVOID lpParam) {
		auto MappedModules = Utils::Secure::GetMappedModules();

		for (auto& Module : MappedModules) {
			if (Module) {
				HMODULE ModuleHandle = (HMODULE)(Module->DllBase);
				if (ModuleHandle != Utils::Secure::GetModuleHandle(0)) {
					// Check for executable+writable sections
					auto ModuleSections = Utils::Secure::GetModuleSections(ModuleHandle);
					for (auto& Section : ModuleSections) {
						if (Section) {
							if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE
								&& Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
								if (Module->BaseDllName.Buffer) {
									auto SectionAddress = RVA2VA(uint64_t, ModuleHandle, Section->VirtualAddress);
									printf("%ws is executable and writable (%X)\n", Module->BaseDllName.Buffer, Dynsec::Crypto::CRC32((uint8_t*)SectionAddress, Section->Misc.VirtualSize));
								}

								// Report name, timestamp, crc hash of section
							}
						}
					}
				}
			}
		}

		// Once every 5 minutes
		Sleep(5min);
	}

	void NTAPI ThreadLocalStorageCallback(PVOID DllHandle, DWORD dwReason, PVOID) {
		if (dwReason == DLL_THREAD_ATTACH) {
			uint64_t ThreadEntryPoint = Utils::GetThreadEntryPoint(GetCurrentThread());
			if (ThreadEntryPoint) {
				printf("Thread created with DLL_THREAD_ATTACH at %p (%i)\n", ThreadEntryPoint, dwReason);

				uint64_t PageSize = 0x500;
				for (auto& Signature : Global::Vars::g_ThreadEntrySignatures) {
					// TODO: Signature encryption (lightweight RC4)
					if (Signature.m_Signature.size()) {
						// Scan for signatures
						uint64_t ScanResult = Utils::Scans::PatternScan(ThreadEntryPoint, ThreadEntryPoint + PageSize, Signature.m_Signature.c_str());
						if (ScanResult && ScanResult != (uint64_t)Signature.m_Signature.data()) {
							// Report
							printf("Thread scan %x found at %llx, blocking\n", Signature.m_Identifier, ScanResult);
							ExitThread(0);
							return;
						}

						// TEMP: Resolve jumps
						uint8_t JumpAsm[] = { 0x48, 0xFF, 0x25 };
						if (!memcmp((void*)ThreadEntryPoint, JumpAsm, 3)) {
							uint64_t JumpAddress = (uint64_t)(*(int*)(ThreadEntryPoint + 3) + ThreadEntryPoint + 7);
							if (JumpAddress) {
								JumpAddress = *(uint64_t*)(JumpAddress);
								if (JumpAddress == (uint64_t)GetProcAddress(GetModuleHandleA("KERNELBASE.dll"), "LoadLibraryW")) {
									// Using LoadLibraryW
									printf("LoadLibraryW being used to inject, blocking for now\n");
									ExitThread(0);
									return;
									// TODO: Find where the string is thats loading the dll
								}

								printf("JumpAddress: %llx\n", JumpAddress);
							}
						}
					}
				}
			}
		}
	}

	void WindowScanRoutine(LPVOID lpParam) {
		std::vector<Dynsec::RoutineTypes::WindowInfo> Windows;

		// I guess this is more secure than calling EnumWindows
		for (HWND hwnd = GetTopWindow(0); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {
			// Get window name
			char WindowName[100];
			int WindowNameLength = GetWindowTextA(hwnd, WindowName, 100);

			LONG WindowStyle = GetWindowLong(hwnd, GWL_STYLE);
			LONG WindowExtendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

			DWORD OwningProcessID = 0;
			GetWindowThreadProcessId(hwnd, &OwningProcessID);

			Windows.push_back({ WindowName, WindowStyle, WindowExtendedStyle, GetCurrentProcessId() == OwningProcessID });
		}

		/*BOOL SuccessfullyEnumerated = EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
			// Get window name
			char WindowName[100];
			int WindowNameLength = GetWindowTextA(hwnd, WindowName, 100);

			LONG WindowStyle = GetWindowLong(hwnd, GWL_STYLE);
			LONG WindowExtendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

			DWORD OwningProcessID = 0;
			GetWindowThreadProcessId(hwnd, &OwningProcessID);

			std::vector<Dynsec::RoutineTypes::WindowInfo>& pWindows = *reinterpret_cast<std::vector<Dynsec::RoutineTypes::WindowInfo>*>(lParam);
			pWindows.push_back({ WindowName, WindowStyle, WindowExtendedStyle, GetCurrentProcessId() == OwningProcessID });
			return TRUE;
		}, (LPARAM)&Windows);*/

		std::vector<Dynsec::RoutineTypes::WindowInfo> ReportWindows;

		// Iterate without checking if it was successful, just in case
		for (auto& Window : Windows) {
			// Check for matching names

			bool MatchingName = false;
			if (!Window.m_Name.empty()) {
				for (auto& Name : Global::Vars::g_WindowTitleSignatures) {
					if (strstr(Name.c_str(), Window.m_Name.c_str())) {
						MatchingName = true;
						break;
					}
				}
			}

			// If it matches any conds for styles, report here
			if (MatchingName) {
				auto Exists = std::find_if(ReportWindows.begin(), ReportWindows.end(), [&](Dynsec::RoutineTypes::WindowInfo& Info) {
					return !Info.m_Name.compare(Window.m_Name);
				});

				if (Exists == ReportWindows.end()) {
					ReportWindows.push_back(Window);
				}
			}
		}

		printf("[REPORT] Reporting %i windows\n", ReportWindows.size());
		for (auto& Window : ReportWindows) {
			// Report
			printf("[REPORT] Reporting window -> %s\n", Window.m_Name.c_str());
		}

		if (/*!SuccessfullyEnumerated || */Windows.size() < 1) {
			// Report
			printf("[REPORT] Window iteration failed (lasterr: %i)\n", GetLastError());
		}

		Sleep(1min);
	}

	extern "C" void __fastcall hook_routine(uintptr_t rcx /*return addr*/, uintptr_t rdx /*return result*/) {
		// We want to avoid having a recursion issue if we call other system functions in here
		if (Global::Vars::g_ProcessingSyscallCallback[GetCurrentThread()]) {
			return;
		}

		Global::Vars::g_ProcessingSyscallCallback[GetCurrentThread()] = true;

		// handle syscall here

		Global::Vars::g_ProcessingSyscallCallback[GetCurrentThread()] = false;
	}
}
```

`Client/src/dynsec/init/routines/routines.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Dynsec::Routines {
	void MemoryScanRoutine(LPVOID lpParam);
	void ExploitableModuleScanRoutine(LPVOID lpParam);
	void WindowScanRoutine(LPVOID lpParam);
	void NTAPI ThreadLocalStorageCallback(PVOID DllHandle, DWORD dwReason, PVOID);
}
```

`Client/src/dynsec/init/tls_manager.cpp`:

```cpp
#include "tls_manager.hpp"
#include "global/variables.hpp"
#include "utils/secure/syscall.hpp"
#include "utils/secure/virtual.hpp"
#include "utils/scans/signature_scan.hpp"
#include "utils/memory/memory.hpp"
#include <psapi.h>

namespace Dynsec::Init {
	void TLSManager::Setup() {
		MODULEINFO ModuleInfo;
		GetModuleInformation(GetCurrentProcess(), Utils::Secure::GetModuleHandle(L"ntdll.dll"), &ModuleInfo, sizeof(ModuleInfo));

		uint64_t StartScan = (uint64_t)ModuleInfo.lpBaseOfDll;
		uint64_t EndScan = StartScan + ModuleInfo.SizeOfImage;

		m_pLdrpTlsList = (void*)Utils::Memory::GetAddressFromInstruction(Utils::Scans::PatternScan(StartScan, EndScan, "48 8b 05 ? ? ? ? 48 8d 15 ? ? ? ? EB"));
		m_pInLoadOrderModuleList = (void*)Utils::Memory::GetAddressFromInstruction(Utils::Scans::PatternScan(StartScan, EndScan, "48 8b 3d ? ? ? ? 48 8d 05 ? ? ? ? 48 3b f8 74 ? 4c 8d ? ? ? 49"));

		m_LdrpTlsList = *(PTLS_ENTRY*)m_pLdrpTlsList;
		m_pInLoadOrderModuleList = *(PLIST_ENTRY*)m_pInLoadOrderModuleList;
	}

	PLDR_DATA_TABLE_ENTRY TLSManager::FindLdrTableForModule(HMODULE hModule) {
		for (auto it = m_InLoadOrderModuleList; it != m_pInLoadOrderModuleList; it = *(PLIST_ENTRY*)it) {
			PLDR_DATA_TABLE_ENTRY entry = (PLDR_DATA_TABLE_ENTRY)it;

			if (entry->DllBase == hModule) {
				return entry;
			}
		}

		return nullptr;
	}

	PTLS_ENTRY TLSManager::FindTlsEntryForModule(HMODULE hModule) {
		for (_TLS_ENTRY* it = m_LdrpTlsList; it != m_pLdrpTlsList; it = (_TLS_ENTRY*)it->TlsEntryLinks.Flink) {
			if (!it) {
				continue;
			}

			if (!it->ModuleEntry) {
				continue;
			}

			if (it->ModuleEntry->DllBase == hModule) {
				return it;
			}
		}

		return nullptr;
	}

	SIZE_T TLSManager::GetTlsCallbackCount(PTLS_ENTRY entry) {
		PIMAGE_TLS_CALLBACK* pCallbackList = (PIMAGE_TLS_CALLBACK*)entry->TlsDirectory.AddressOfCallBacks;

		if (!pCallbackList) {
			return 0;
		}

		int count = 0;

		PIMAGE_TLS_CALLBACK currentCallback = *pCallbackList;
		while (true) {
			currentCallback = *pCallbackList;

			if (!currentCallback) {
				break;
			}

			++count;
			++pCallbackList;
		}

		return count;
	}

	SIZE_T TLSManager::FindCallbackIndex(PTLS_ENTRY entry, PIMAGE_TLS_CALLBACK callback) {
		PIMAGE_TLS_CALLBACK* pCallbackList = (PIMAGE_TLS_CALLBACK*)entry->TlsDirectory.AddressOfCallBacks;

		if (!pCallbackList) {
			return 0;
		}

		int count = 0;

		PIMAGE_TLS_CALLBACK currentCallback = *pCallbackList;
		while (true) {
			currentCallback = *pCallbackList;

			if (!*pCallbackList) 
				break;
			

			if (currentCallback == callback)
				return count+1;

			++count;
			++pCallbackList;
		}

		return count;
	}

	bool TLSManager::RegisterCallback(HMODULE module, PIMAGE_TLS_CALLBACK pCallback) {
		if (!m_IsCustomCallbackArray) {
			Setup();
		}

		PTLS_ENTRY entry = FindTlsEntryForModule(module);
		if (!entry) {
			return false;
		}

		SIZE_T nCallbacks = GetTlsCallbackCount(entry);

		uintptr_t* callbacksMemory = new uintptr_t[nCallbacks + 2] {};
		memcpy(callbacksMemory, (void*)entry->TlsDirectory.AddressOfCallBacks, nCallbacks * sizeof(uintptr_t));

		if (m_IsCustomCallbackArray) {
			delete (void*)entry->TlsDirectory.AddressOfCallBacks;
		}

		callbacksMemory[nCallbacks] = (uintptr_t)pCallback;
		callbacksMemory[nCallbacks + 1] = 0;

		entry->TlsDirectory.AddressOfCallBacks = (uintptr_t)callbacksMemory;
		m_IsCustomCallbackArray = true;

		return true;
	}

	bool TLSManager::UnregisterCallback(HMODULE module, PIMAGE_TLS_CALLBACK pCallback) {
		if (!m_IsCustomCallbackArray) {
			Setup();
		}

		PTLS_ENTRY entry = FindTlsEntryForModule(module);
		if (entry == nullptr) {
			return false;
		}

		SIZE_T nCallbacks = GetTlsCallbackCount(entry);
		if (nCallbacks <= 0) {
			return false;
		}

		if (nCallbacks == 1) {
			// Check if it's actually the callback we want to unregister
			if (*(void**)entry->TlsDirectory.AddressOfCallBacks != pCallback) {
				return false;
			}

			entry->TlsDirectory.AddressOfCallBacks = 0;
			return true;
		}

		uintptr_t** callbacks = *(uintptr_t***)entry->TlsDirectory.AddressOfCallBacks;

		SIZE_T iCallbackIndex = FindCallbackIndex(entry, pCallback);

		// We need an array of nCallbacks size because we need to keep in mind that 
		// the array needs the last item to be 0. (last item(0) not counted in nCallbacks)
		uintptr_t* callbacksMemory = new uintptr_t[nCallbacks]{};

		if (iCallbackIndex == 1) {
			memcpy(callbacksMemory, 
				(void*)(entry->TlsDirectory.AddressOfCallBacks + sizeof(uintptr_t)), 
				(nCallbacks - 1) * sizeof(uintptr_t));
		} else if (iCallbackIndex == nCallbacks) {
			memcpy(callbacksMemory, 
				(void*)entry->TlsDirectory.AddressOfCallBacks, 
				(nCallbacks - 1) * sizeof(uintptr_t));
		} else {
			memcpy(callbacksMemory, 
				(void*)entry->TlsDirectory.AddressOfCallBacks, 
				(iCallbackIndex - 1) * sizeof(uintptr_t));

			memcpy(callbacksMemory + (iCallbackIndex - 1), 
				(uintptr_t*)(entry->TlsDirectory.AddressOfCallBacks) + iCallbackIndex, 
				(nCallbacks - iCallbackIndex) * sizeof(uintptr_t));
		}

		if (m_IsCustomCallbackArray) {
			delete (void*)entry->TlsDirectory.AddressOfCallBacks;
		}

		callbacksMemory[nCallbacks] = 0;
		entry->TlsDirectory.AddressOfCallBacks = (uintptr_t)callbacksMemory;
		m_IsCustomCallbackArray = true;

		return true;
	}

	TLSManager* GetTLSManager() {
		static TLSManager Instance;
		return &Instance;
	}
}
```

`Client/src/dynsec/init/tls_manager.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "utils/structs.hpp"
#include "utils/secure/module.hpp"

namespace Dynsec::Init {
	class TLSManager {
	public:
		bool RegisterCallback(HMODULE module, PIMAGE_TLS_CALLBACK pCallback);
		bool UnregisterCallback(HMODULE module, PIMAGE_TLS_CALLBACK pCallback);

	private:
		bool m_IsCustomCallbackArray = false;
		void* m_pLdrpTlsList = nullptr;
		void* m_pInLoadOrderModuleList = nullptr;

		PTLS_ENTRY m_LdrpTlsList = nullptr;
		PLIST_ENTRY m_InLoadOrderModuleList = nullptr;

		void Setup();
		PLDR_DATA_TABLE_ENTRY FindLdrTableForModule(HMODULE hModule);
		PTLS_ENTRY FindTlsEntryForModule(HMODULE hModule);
		SIZE_T GetTlsCallbackCount(PTLS_ENTRY entry);
		SIZE_T FindCallbackIndex(PTLS_ENTRY entry, PIMAGE_TLS_CALLBACK callback);
	};

	TLSManager* GetTLSManager();
}
```

`Client/src/dynsec/network/encryption.cpp`:

```cpp
#include "encryption.hpp"
#include "dynsec/crypto/crypto.hpp"
#include "utils/utils.hpp"

namespace Dynsec::Network {
	void EncryptPacket(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header) {
		uint32_t NetworkBaseHeaderSize = sizeof(Dynsec::PacketTypes::Request::NetworkBaseHeader);

		// First, encrypt the session token
		Dynsec::Crypto::RC4(Header->m_Encryption.m_SessionTokenKey, sizeof(Header->m_Encryption.m_SessionTokenKey), Header->m_SessionToken, sizeof(Header->m_SessionToken));

		// Next, RC4 the body with the generated HMAC sha1 hash of the body's content (PRE ENCRYPTION)
		Dynsec::Crypto::RC4(Header->m_RequestHMAC, sizeof(Header->m_RequestHMAC), (uint8_t*)Header, Header->m_Size, NetworkBaseHeaderSize);

		// Next, XOR using the first XOR key, and NOT the result
		BYTE* ByteArr = (BYTE*)(Header + NetworkBaseHeaderSize);
		for (uint32_t i = 0; i < Header->m_Size; i++) {
			ByteArr[i] ^= Header->m_Encryption.m_FirstXorKey;
			ByteArr[i] = ~ByteArr[i];
		}

		// Finally, RC4 the result
		Dynsec::Crypto::RC4(Header->m_Encryption.m_FinalKey, sizeof(Header->m_Encryption.m_FinalKey), (uint8_t*)Header, Header->m_Size, NetworkBaseHeaderSize);
	}

	void DecryptPacket(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header, Dynsec::PacketTypes::Response::EncryptionKeys* ResponseEncryptionKeys, uint8_t* Bytes, uint32_t Size) {
		// First, RC4 the response with the key used in the request
		Dynsec::Crypto::RC4(Header->m_Encryption.m_FinalKey, sizeof(Header->m_Encryption.m_FinalKey), Bytes, Size);

		// Store the xor keys on the stack
		uint16_t XorKeys[] = {
			0x1234, 0x1723, 0x1823, 0x3481,
			0x8312, 0x1212, 0x4782, 0x3484,
			0x1284, 0x7334, 0x8473, 0x8333,
			0x1244, 0x4747, 0x7733, 0x8334
		};

		// Decrypt the first key
		for (uint8_t i = 0; i < 0x10; i++) {
			ResponseEncryptionKeys->m_Key1[i] ^= 0x1337;
			ResponseEncryptionKeys->m_Key1[i] ^= XorKeys[i];
			ResponseEncryptionKeys->m_Key1[i] = ~ResponseEncryptionKeys->m_Key1[i];
		}

		// Decrypt the second key
		for (uint8_t i = 0; i < 0x10; i++) {
			ResponseEncryptionKeys->m_Key2[i] = ~ResponseEncryptionKeys->m_Key2[i];
			ResponseEncryptionKeys->m_Key2[i] ^= 0x1337;
			ResponseEncryptionKeys->m_Key2[i] ^= XorKeys[0x10 - i - 1];
		}

		// Decrypt the hash using the decrypted keys
		for (uint8_t i = 0; i < 0x10; i++) {
			ResponseEncryptionKeys->m_Hash ^= (ResponseEncryptionKeys->m_Key1[i] ^ ResponseEncryptionKeys->m_Key2[i]);
			ResponseEncryptionKeys->m_Hash ^= ResponseEncryptionKeys->m_Key2[i];
			ResponseEncryptionKeys->m_Hash ^= ResponseEncryptionKeys->m_Key1[i];
			ResponseEncryptionKeys->m_Hash = ~ResponseEncryptionKeys->m_Hash;
		}

		// Convert the decrypted hash to bytes
		auto HashBytes = Utils::ConvertNumberToBytes(ResponseEncryptionKeys->m_Hash);

		// Use said bytes
		for (uint32_t i = 0; i < Size; i++) {
			Bytes[i] ^= HashBytes[3];
			Bytes[i] = ~Bytes[i];
			Bytes[i] ^= HashBytes[2];
			Bytes[i] = ~Bytes[i];
			Bytes[i] ^= HashBytes[1];
			Bytes[i] = ~Bytes[i];
			Bytes[i] ^= HashBytes[0];
		}

		// Finally, RC4 the end result with the session token key
		Dynsec::Crypto::RC4(Header->m_Encryption.m_SessionTokenKey, sizeof(Header->m_Encryption.m_SessionTokenKey), Bytes, Size);
	}
}
```

`Client/src/dynsec/network/encryption.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "dynsec/types/packet_types.hpp"

namespace Dynsec::Network {
	void EncryptPacket(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header);
	void DecryptPacket(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header, Dynsec::PacketTypes::Response::EncryptionKeys* ResponseEncryptionKeys, uint8_t* Bytes, uint32_t Size);
}
```

`Client/src/dynsec/network/network_socket.cpp`:

```cpp
#include "network_socket.hpp"

namespace Dynsec::Network {
	bool TCP::Initialize() {
		static bool IsInitialized = false;
		if (IsInitialized) return true;

		WSADATA wsaData;
		if (WSAStartup(MAKEWORD(2, 2), &wsaData)) return false;

		return IsInitialized = true;
	}

	TCP& TCP::Create(NetworkStatus& Status) {
		if (!Initialize()) {
			Status.m_Successful = false;
			Status.m_Error = "Failed to initialize socket";
			return *this;
		}

		bool IsSocketCreated = false;

		for (int i = 0; i < MAX_SOCKET_CREATE_RETRIES; i++) {
			SocketHandle = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
			if (SocketHandle == SOCKET_ERROR) {
				IsSocketCreated = false;
				printf("Failed to create socket, attempt %i\n", i + 1);
			} else {
				IsSocketCreated = true;
				break;
			}

			Sleep(250);
		}

		if (!IsSocketCreated) {
			Status.m_Successful = false;
			Status.m_Error = "Socket wasn't created";
			return *this;
		}

		Status.m_Successful = true;
		return *this;
	}

	TCP& TCP::Connect(NetworkStatus& Status) {
#undef max
		int SendRecvSize = std::numeric_limits<int>::max();
		setsockopt(SocketHandle, SOL_SOCKET, SO_SNDBUF | SO_RCVBUF, (const char*)&SendRecvSize, sizeof(SendRecvSize));

		int MaxTimeout = SOCKET_TIMEOUT;
		setsockopt(SocketHandle, SOL_SOCKET, SO_SNDTIMEO | SO_RCVTIMEO, (const char*)&MaxTimeout, sizeof(MaxTimeout));

		Dynsec::PacketTypes::GameServer Server(ACTIVE_CLIENT);

		sockaddr_in SocketAddress;
		SocketAddress.sin_family = AF_INET;
		SocketAddress.sin_port = htons(Server.m_Port);
		SocketAddress.sin_addr.S_un.S_addr = htonl(Server.m_IP);

		bool IsConnected = false;

		for (int i = 0; i < MAX_SOCKET_CONNECT_RETRIES; i++) {
			if (connect(SocketHandle, (sockaddr*)&SocketAddress, sizeof(SocketAddress)) == SOCKET_ERROR) {
				IsConnected = false;
				printf("Failed to connect, attempt %i\n", i + 1);
			} else {
				IsConnected = true;
				break;
			}

			Sleep(250);
		}

		if (!IsConnected) {
			closesocket(SocketHandle);
			Status.m_Successful = false;
			Status.m_Error = "Failed to connect";
			return *this;
		}

		Status.m_Successful = true;
		return *this;
	}

	TCP& TCP::Send(void* Buffer, uint32_t Size, NetworkStatus& Status) {
		uint32_t RemainingSize = Size;
		uint32_t SentSize = 0;

		while (RemainingSize > 0) {
			uint32_t SendingSize = min(RemainingSize, 0x1000);
			int Sent = send(SocketHandle, (const char*)Buffer + SentSize, SendingSize, 0);
			
			if (Sent == SOCKET_ERROR) {
				Status.m_Successful = false;
				Status.m_Error = "Failed to send";
				return *this;
			}

			RemainingSize -= Sent;
			SentSize += Sent;
		}

		Status.m_Successful = true;
		return *this;
	}

	TCP& TCP::Receive(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header, void* RecvBuffer, uint32_t RecvSize, NetworkStatus& Status) {
		char* ReceivedBuffer = new char[RecvSize];

		uint32_t RemainingSize = RecvSize;
		uint32_t ReceivedSize = 0;

		while (RemainingSize > 0) {
			uint32_t ReceivingSize = min(RemainingSize, 0x1000);
			uint32_t Received = (uint32_t)recv(SocketHandle, ReceivedBuffer + ReceivedSize, ReceivingSize, 0);
			printf("Received %i bytes\n", Received);

			if (Received == SOCKET_ERROR) {
				Status.m_Successful = false;
				Status.m_Error = "Failed to receive";
				closesocket(SocketHandle);
				return *this;
			}

			if (Received == 0) break;

			RemainingSize -= Received;
			ReceivedSize += Received;
		}

		Status.m_ReadBytes = ReceivedSize;
		Status.m_Successful = true;
		closesocket(SocketHandle);

		// handle decryption shit here

		// temp
		memcpy(RecvBuffer, ReceivedBuffer, ReceivedSize);

		delete[] ReceivedBuffer;
		return *this;
	}
}
```

`Client/src/dynsec/network/network_socket.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "dynsec/types/packet_types.hpp"
#pragma comment(lib, "Ws2_32.lib")

namespace Dynsec::Network {
	// Setup which custom client we're building for
#define CLIENT_TEST1 { 0x7F000001, 1234 } // 123.0.0.1, 1234
#define CLIENT_TEST2 { 0x7F000001, 1235 } // 123.0.0.1, 1235
#define CLIENT_TEST3 { 0x7F000001, 1236 } // 123.0.0.1, 1236
#define ACTIVE_CLIENT CLIENT_TEST2

// networking stuff
#define MAX_SOCKET_CONNECT_RETRIES 10
#define MAX_SOCKET_CREATE_RETRIES 10
#define SOCKET_TIMEOUT 10000

	struct NetworkStatus {
		bool m_Successful;
		const char* m_Error;
		uint32_t m_ReadBytes; // Receive only
	};

	class TCP {
	public:
		static bool Initialize();

		TCP& Create(NetworkStatus& Status);
		TCP& Connect(NetworkStatus& Status);
		TCP& Send(void* Buffer, uint32_t Size, NetworkStatus& Status);
		TCP& Receive(Dynsec::PacketTypes::Request::NetworkBaseHeader* Header, void* RecvBuffer, uint32_t RecvSize, NetworkStatus& Status);
	private:
		sockaddr_in ServerHandle;
		SOCKET SocketHandle;
	};
}
```

`Client/src/dynsec/shellcode/shellcode.cpp`:

```cpp
#include "shellcode.hpp"
#include "utils/caller.hpp"
#include <future>

namespace Dynsec::Shellcode {
	ShellcodeContext* SetupContext() {
		ShellcodeContext* Context = new ShellcodeContext();

		if (Context) {
			Context->m_Sleep = (uint64_t)&Sleep;
			Context->m_Malloc = (uint64_t)&malloc;
			Context->m_Free = (uint64_t)&free;
		}

		return Context;
	}

	void Execute(void* Shellcode) {
		if (Shellcode) {
			// SHELLCODE SHOULD DELETE CONTEXT
			ShellcodeContext* Context = SetupContext();

			auto f = std::async(std::launch::async, [&] {
				Utils::Caller::Call<int>((uint64_t)Shellcode, Context);
			});
		}
	}
}
```

`Client/src/dynsec/shellcode/shellcode.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Dynsec::Shellcode {
	struct ShellcodeContext {
		uint64_t m_Sleep;
		uint64_t m_Malloc;
		uint64_t m_Free;
	};

	void Execute(void* Shellcode);
}
```

`Client/src/dynsec/types/init_types.hpp`:

```hpp
#pragma once

namespace Dynsec::InitTypes {
#pragma pack(push, 1)
	struct GameDataInit {

	};
#pragma pack(pop)
}
```

`Client/src/dynsec/types/packet_types.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Dynsec::PacketTypes {
	struct GameServer {
		uint32_t m_IP;
		uint16_t m_Port;

		GameServer(uint32_t ip, uint16_t port)
			: m_IP(ip), m_Port(port)
		{}
	};

	namespace Request {
		struct EncryptionKeys {
			uint8_t m_FirstXorKey;						// XOR key used after the initial RC4
			uint8_t m_SessionTokenKey[0x8];				// RC4 key for encrypting the session token
			uint8_t m_FinalKey[0x8];					// Final RC4 key ran at the end
		};
		
		struct UserIdentification {
			// ...
		};

		struct GameInformation {
			uint8_t m_GameID;							// ID of the game
			uint16_t m_GameVersion;						// Games version, given to us in InitializeClient
		};

		struct NetworkBaseHeader { // not encrypted
			uint32_t m_Magic;							// Magic for verifying request | 0x44534143 - "DSAC"
			uint32_t m_Size;							// Size of the request after the header (NetworkHeader>)
			uint8_t m_Packet;							// ID of the packet that's being sent. Will most likely be static for init, and dynamic for the rest
			uint8_t m_SessionToken[0x20];				// Session token generated by our server
			uint8_t m_RequestHMAC[0x20];				// HMAC of the request after the header PRE ENCRYPTION to verify it hasn't been tampered
			EncryptionKeys m_Encryption;				// Keys for the encryption used
		};

		struct NetworkHeader : NetworkBaseHeader { // encrypted
			GameInformation m_GameInfo;					// Information on the game, could be modified though so shouldn't be trusted
		};
	}

	namespace Response {
		struct EncryptionKeys {
			uint16_t m_Key1[0x10];
			uint16_t m_Key2[0x10];
			uint32_t m_Hash;
		};
	};
}
```

`Client/src/dynsec/types/routine_types.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Dynsec::RoutineTypes {
	struct MemorySignature {
		uint16_t m_Identifier;							// Identifier sent back to our server for reporting
		bool m_Executable;								// If the signature is for executable only memory
		std::string m_Signature;						// The signature itself
	};

	struct ThreadEntrySignature {
		uint16_t m_Identifier;							// Identifier sent back to our server for reporting
		std::string m_Signature;						// The signature itself
	};

	struct WindowInfo {
		std::string m_Name;								// The title of the window
		LONG m_Style;									// The window style
		LONG m_ExtendedStyle;							// The window extended style
		bool m_CurrentProcess;							// If it belongs to the current process
	};
}
```

`Client/src/global/variables.cpp`:

```cpp
#include "variables.hpp"

namespace Global::Vars {
	HMODULE g_ModuleHandle;
	std::unordered_map<HANDLE, bool> g_ProcessingSyscallCallback;
	Dynsec::InitTypes::GameDataInit* g_GameDataInit;
	std::vector<Dynsec::RoutineTypes::MemorySignature> g_MemorySignatures;
	std::vector<Dynsec::RoutineTypes::ThreadEntrySignature> g_ThreadEntrySignatures;
	std::vector<std::string> g_WindowTitleSignatures;
}
```

`Client/src/global/variables.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "dynsec/types/init_types.hpp"
#include "dynsec/types/routine_types.hpp"

namespace Global::Vars {
	extern HMODULE g_ModuleHandle;
	extern std::unordered_map<HANDLE, bool> g_ProcessingSyscallCallback;
	extern Dynsec::InitTypes::GameDataInit* g_GameDataInit;
	extern std::vector<Dynsec::RoutineTypes::MemorySignature> g_MemorySignatures;
	extern std::vector<Dynsec::RoutineTypes::ThreadEntrySignature> g_ThreadEntrySignatures;
	extern std::vector<std::string> g_WindowTitleSignatures;
}
```

`Client/src/stdafx.cpp`:

```cpp
#include "stdafx.hpp"
```

`Client/src/stdafx.hpp`:

```hpp
#ifndef PCH_H
#define PCH_H

#pragma warning(disable: 4244)
#pragma warning(disable: 4455)

#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <string>
#include <vector>
#include <algorithm>
#include <mutex>
#include <unordered_map>
#include <stdlib.h>
#include <fstream>
#include <stdio.h>
#include <intrin.h>

#define EncodePtr Utils::Secure::GetPointers()->EncodePointer
#define DecodePtr Utils::Secure::GetPointers()->DecodePointer

#undef GetCurrentProcess
#define GetCurrentProcess() (HANDLE)-1

constexpr DWORD operator ""sec(unsigned long long s) {
	return s * 1000;
}

constexpr DWORD operator ""sec(long double s) {
	return s * 1000;
}

constexpr unsigned long long operator ""min(unsigned long long m) {
	return m * 1000 * 60;
}

constexpr unsigned long long operator ""min(long double m) {
	return m * 1000 * 60;
}

#ifdef _WIN64
#define ProcessEnvironmentBlock ((PEB*)__readgsqword(0x60))
#else
#include "utils/structs.hpp"

inline PEB* GetProcessEnvironmentBlockAsm() {
	PEB* peb = nullptr;
	__asm {
		mov eax, fs: [0x30]
		mov peb, eax
	}

	return peb;
}

#define ProcessEnvironmentBlock GetProcessEnvironmentBlockAsm()
#endif

#endif
```

`Client/src/syscall_callback.asm`:

```asm
include ksamd64.inc
EXTERN hook_routine:NEAR

.code
hook_wrapper PROC
	pushfq
	push rax
	push rcx
	push rdx
	push r8
	push r9
	push r11
	push r12
	push r13
	push r14
	push r15
	sub rsp,28h
	mov rcx, r10 ; return address
	mov rdx, rax ; return value
	push r10
	call hook_routine ; we call the cpp code
	pop r10
	add rsp,28h
	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r8
	pop r9
	pop rdx
	pop rcx
	pop rax
	popfq
	jmp r10 ; goto return address
hook_wrapper ENDP

END
```

`Client/src/utils/caller.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Caller {
	template<typename T>
	inline T Call(uint64_t dwAddress) { return ((T(*)())dwAddress)(); }

	template<typename T, typename P1>
	inline T Call(uint64_t dwAddress, P1 p1) { return ((T(*)(P1))dwAddress)(p1); }

	template<typename T, typename P1, typename P2>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2) { return ((T(*)(P1, P2))dwAddress)(p1, p2); }

	template<typename T, typename P1, typename P2, typename P3>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3) { return ((T(*)(P1, P2, P3))dwAddress)(p1, p2, p3); }

	template<typename T, typename P1, typename P2, typename P3, typename P4>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4) { return ((T(*)(P1, P2, P3, P4))dwAddress)(p1, p2, p3, p4); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) { return ((T(*)(P1, P2, P3, P4, P5))dwAddress)(p1, p2, p3, p4, p5); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) { return ((T(*)(P1, P2, P3, P4, P5, P6))dwAddress)(p1, p2, p3, p4, p5, p6); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) { return ((T(*)(P1, P2, P3, P4, P5, P6, P7))dwAddress)(p1, p2, p3, p4, p5, p6, p7); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) { return ((T(*)(P1, P2, P3, P4, P5, P6, P7, P8))dwAddress)(p1, p2, p3, p4, p5, p6, p7, p8); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) { return ((T(*)(P1, P2, P3, P4, P5, P6, P7, P8, P9))dwAddress)(p1, p2, p3, p4, p5, p6, p7, p8, p9); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) { return ((T(*)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))dwAddress)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }

	template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
	inline T Call(uint64_t dwAddress, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11) { return ((T(*)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11))dwAddress)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }
}
```

`Client/src/utils/math.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Math {
	template<class T> T __ROL__(T value, int count) {
		const uint64_t nbits = sizeof(T) * 8;

		if (count > 0) {
			count %= nbits;
			T high = value >> (nbits - count);
			if (T(-1) < 0)
				high &= ~((T(-1) << count));
			value <<= count;
			value |= high;
		} else {
			count = -count % nbits;
			T low = value << (nbits - count);
			value >>= count;
			value |= low;
		}
		return value;
	}

	inline uint8_t __ROL1__(uint8_t value, int count) { return __ROL__(value, count); }
	inline uint8_t __ROR1__(uint8_t value, int count) { return __ROL__(value, -count); }

	inline uint16_t __ROL2__(uint16_t value, int count) { return __ROL__(value, count); }
	inline uint16_t __ROR2__(uint16_t value, int count) { return __ROL__(value, -count); }

	inline uint32_t __ROL4__(uint32_t value, int count) { return __ROL__(value, count); }
	inline uint32_t __ROR4__(uint32_t value, int count) { return __ROL__(value, -count); }

	inline uint64_t __ROL8__(uint64_t value, int count) { return __ROL__(value, count); }
	inline uint64_t __ROR8__(uint64_t value, int count) { return __ROL__(value, -count); }
}
```

`Client/src/utils/memory/memory.cpp`:

```cpp
#include "memory.hpp"

namespace Utils::Memory {
	uint64_t GetAddressFromInstruction(uint64_t Address, uint32_t OpcodeSize, uint32_t OpcodeLength) {
		return (uint64_t)(*(uint32_t*)(Address + OpcodeSize) + Address + OpcodeLength);
	}
}
```

`Client/src/utils/memory/memory.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "utils/secure/virtual.hpp"

namespace Utils::Memory {
	uint64_t GetAddressFromInstruction(uint64_t Address, uint32_t OpcodeSize = 3, uint32_t OpcodeLength = 7);

	template<typename A, typename V>
	void Write(uint32_t PageProtection, A Address, V Value, uint32_t Size = sizeof(Value)) {
		uint32_t OldProtection = 0;
		Utils::Secure::VirtualProtect((void*)Address, Size, PageProtection, &OldProtection);
		memcpy((void*)Address, &Value, Size);
		Utils::Secure::VirtualProtect((void*)Address, Size, OldProtection, &OldProtection);
	}
}
```

`Client/src/utils/scans/signature_scan.cpp`:

```cpp
#include "signature_scan.hpp"
#include "utils/secure/syscall.hpp"
#include <sstream>

namespace Utils::Scans {
	struct PatternByte {
		PatternByte()
			: m_Ignore(true), m_Data(0)
		{};

		PatternByte(const char* Pattern, bool Ignore = false)
			: m_Data(ConvertString(Pattern)), m_Ignore(Ignore)
		{}

		bool m_Ignore;
		uint8_t m_Data;
	private:
		uint8_t ConvertString(const char* Pattern) {
			std::istringstream StringStream(Pattern);
			uint32_t Return = 0;

			if (StringStream >> std::hex >> Return) {
				return (uint8_t)Return;
			}

			return 0;
		}
	};

	uint64_t PatternScan(uint64_t Start, uint64_t End, const char* Pattern) {
		std::vector<PatternByte> PatternBytes;
		std::istringstream StringStream(Pattern);
		std::string CurrentByte = "";

		// Prevent somehow spoofing patterns to be extremely long to slow down scanning
		if (Pattern && strlen(Pattern) < 0x200) {
			while (StringStream >> CurrentByte) {
				if (CurrentByte.data()[0] == '?') {
					PatternBytes.push_back(PatternByte());
				} else if (CurrentByte.length() == 2 && isxdigit(CurrentByte.data()[0]) && isxdigit(CurrentByte.data()[1])) { // Hex
					PatternBytes.push_back(PatternByte(CurrentByte.c_str()));
				} else {
					return 0;
				}
			}

			for (uint64_t i = Start; i < End; i++) {
				uint8_t* Current = (uint8_t*)i;
				bool Found = true;

				for (std::size_t ps = 0; ps < PatternBytes.size(); ps++) {
					if (!PatternBytes[ps].m_Ignore && Current[ps] != PatternBytes[ps].m_Data) {
						Found = false;
						break;
					}
				}

				if (Found) {
					return (uint64_t)Current;
				}
			}
		}

		return 0;
	}

	uint64_t PatternScanExternalProcess(HANDLE Process, uint64_t Start, uint64_t End, const char* Pattern) {
		uint8_t* ProcessBytes = new uint8_t[End - Start];
		memset(ProcessBytes, 0, End - Start);

		ULONG ReadSize = 0;
		if (Utils::Secure::GetSyscalls()->NtReadVirtualMemory(Process, (void*)Start, ProcessBytes, (ULONG)(End - Start), &ReadSize) == 0) {
			uint64_t Return = PatternScan((uint64_t)ProcessBytes, ((uint64_t)ProcessBytes + (End - Start)), Pattern);
			if (Return) {
				Return = (Return - (uint64_t)ProcessBytes) + Start; // Get the offset in the real process where it is
			}

			delete[] ProcessBytes;
			return Return;
		}

		delete[] ProcessBytes;
		return 0;
	}
}
```

`Client/src/utils/scans/signature_scan.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Scans {
	uint64_t PatternScan(uint64_t Start, uint64_t End, const char* Pattern);
	uint64_t PatternScanExternalProcess(HANDLE Process, uint64_t Start, uint64_t End, const char* Pattern);
}
```

`Client/src/utils/secure/module.cpp`:

```cpp
#include "module.hpp"

namespace Utils::Secure {
	HMODULE GetModuleHandle(const wchar_t* moduleName) {
		LoadLibraryW(moduleName);

		auto MappedModules = GetMappedModules();
		for (auto Module : MappedModules) {
			if (moduleName == nullptr) {
				return (HMODULE)Module->DllBase;
			}

			if (Module->BaseDllName.Buffer && Module->BaseDllName.Length) {
				if (!wcscmp(Module->BaseDllName.Buffer, moduleName)) {
					return (HMODULE)Module->DllBase;
				}
			}
		}

		return 0;
	}

	uintptr_t FindRawAddress(PIMAGE_NT_HEADERS ntHeader, uintptr_t va) {
		// Since sections contains both a raw address and virtual address field,
		// we can use it to get the raw address from a virtual address.
		auto section = IMAGE_FIRST_SECTION(ntHeader);
		for (int i = 0; i < ntHeader->FileHeader.NumberOfSections; i++) {
			if (va >= section->VirtualAddress &&
				va <= (section->VirtualAddress + section->Misc.VirtualSize)) {

				uintptr_t offset = va - section->VirtualAddress;
				uintptr_t rawAddress = section->PointerToRawData + offset;

				return rawAddress;
			}
			section++;
		}

		return 0;
	}

	template<class T>
	T FindRawPointer(PIMAGE_NT_HEADERS headers, HMODULE hMod, uintptr_t va) {
		return (T)((uintptr_t)hMod + FindRawAddress(headers, va));
	}

	FARPROC GetProcAddressDisk(HMODULE hMod, const char* procName) {
		PIMAGE_NT_HEADERS ntHeader = RVA2VA(PIMAGE_NT_HEADERS, hMod, ((PIMAGE_DOS_HEADER)hMod)->e_lfanew);
		if (!ntHeader)
			return nullptr;

		PIMAGE_DATA_DIRECTORY dataDirectory = ntHeader->OptionalHeader.DataDirectory;

		DWORD exportsVA = dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

		PIMAGE_EXPORT_DIRECTORY pExports = FindRawPointer<PIMAGE_EXPORT_DIRECTORY>(ntHeader, hMod, exportsVA);

		if (pExports) {
			uint16_t* nameOrdinals = FindRawPointer<uint16_t*>(ntHeader, hMod, pExports->AddressOfNameOrdinals);
			uint32_t* functions = FindRawPointer<uint32_t*>(ntHeader, hMod, pExports->AddressOfFunctions);
			uint32_t* names = FindRawPointer<uint32_t*>(ntHeader, hMod, pExports->AddressOfNames);


			if (nameOrdinals && functions && names) {
				for (uint32_t i = 0; i < pExports->NumberOfFunctions; i++) {
					const char* exportName = FindRawPointer<const char*>(ntHeader, hMod, names[i]);
					if (exportName && !strcmp(exportName, procName)) {
						uint32_t offset = functions[nameOrdinals[i]];
						if (offset)
							return FindRawPointer<FARPROC>(ntHeader, hMod, offset);

					}
				}
			}
		}
		return nullptr;
	}

	FARPROC GetProcAddress(HMODULE moduleHandle, const char* procName) {
		if (moduleHandle) {
			PIMAGE_NT_HEADERS NtHeader = RVA2VA(PIMAGE_NT_HEADERS, moduleHandle, ((PIMAGE_DOS_HEADER)moduleHandle)->e_lfanew);
			if (NtHeader) {
				PIMAGE_DATA_DIRECTORY DataDirectory = NtHeader->OptionalHeader.DataDirectory;
				if (DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
					PIMAGE_EXPORT_DIRECTORY Exports = nullptr;

					Exports = RVA2VA(PIMAGE_EXPORT_DIRECTORY, moduleHandle, DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

					if (Exports) {
						uint16_t* NameOridinals = RVA2VA(uint16_t*, moduleHandle, Exports->AddressOfNameOrdinals);
						uint32_t* Functions = RVA2VA(uint32_t*, moduleHandle, Exports->AddressOfFunctions);
						uint32_t* Names = RVA2VA(uint32_t*, moduleHandle, Exports->AddressOfNames);

						if (NameOridinals && Functions && Names) {
							for (uint32_t i = 0; i < Exports->NumberOfFunctions; i++) {
								const char* ExportName = RVA2VA(const char*, moduleHandle, Names[i]);
								if (ExportName && !strcmp(ExportName, procName)) {
									uint32_t Offset = Functions[RVA2VA(uint16_t, moduleHandle, NameOridinals[i])];
									if (Offset) {
										return (FARPROC)((uint64_t)moduleHandle + Offset);
									}
								}
							}
						}
					}
				}
			}
		}

		return nullptr;
	}

	std::vector<PIMAGE_SECTION_HEADER> GetModuleSections(HMODULE hModule) {
		std::vector<PIMAGE_SECTION_HEADER> Headers;

		PIMAGE_NT_HEADERS NtHeader = RVA2VA(PIMAGE_NT_HEADERS, hModule, ((PIMAGE_DOS_HEADER)hModule)->e_lfanew);
		if (!NtHeader) {
			return Headers;
		}

		PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION(NtHeader);
		for (int i = 0; i < NtHeader->FileHeader.NumberOfSections; i++) {
			Headers.push_back(SectionHeader);
			SectionHeader++;
		}

		return Headers;
	}

	std::vector<PLDR_DATA_TABLE_ENTRY> GetMappedModules() {
		std::vector<PLDR_DATA_TABLE_ENTRY> Modules;

		if (ProcessEnvironmentBlock) {
			PPEB_LDR_DATA Ldr = ProcessEnvironmentBlock->Ldr;
			if (Ldr) {
				PLIST_ENTRY CurrentEntry = Ldr->InLoadOrderModuleList.Flink;
				if (CurrentEntry) {
					while (CurrentEntry != &Ldr->InLoadOrderModuleList && CurrentEntry != nullptr) {
						PLDR_DATA_TABLE_ENTRY Current = CONTAINING_RECORD(CurrentEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
						if (Current) {
							Modules.push_back(Current);
						}

						CurrentEntry = CurrentEntry->Flink;
					}
				}
			}
		}

		return Modules;
	}
}
```

`Client/src/utils/secure/module.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"
#include "../structs.hpp"

namespace Utils::Secure {
#define RVA2VA(type, base, rva) (type)((uint64_t)base + rva)
#define VA2RVA(type, base, va) (type)((uint64_t)va - (uint64_t)base)

#undef GetModuleHandle

	HMODULE GetModuleHandle(const wchar_t* moduleName);
	FARPROC GetProcAddressDisk(HMODULE hMod, const char* procName);
	FARPROC GetProcAddress(HMODULE moduleHandle, const char* procName);

	std::vector<PIMAGE_SECTION_HEADER> GetModuleSections(HMODULE hModule);
	std::vector<PLDR_DATA_TABLE_ENTRY> GetMappedModules();
}
```

`Client/src/utils/secure/pointers.cpp`:

```cpp
#include "pointers.hpp"
#include "utils/math.hpp"
#include "syscall.hpp"

namespace Utils::Secure {
	void* Pointers::EncodePointer(void* Ptr) {
		if (!m_Cookie) {
			ULONG ReturnLength = 0;
			if (GetSyscalls()->NtQueryInformationProcess(GetCurrentProcess(), 0x24, &m_Cookie, 4, &ReturnLength) != 0) {
				return nullptr;
			}

			printf("m_Cookie: %x\n", m_Cookie);
		}

		uint64_t Address = (uint64_t)Ptr;
		Address = Math::__ROL8__(Address, 2);
		Address = Math::__ROL8__(Address, 0x20);
		Address = ~Address;
		for (uint32_t i = 0; i < (m_Cookie & 0x3F); i++) Address = (Address ^ m_Cookie) ^ i;

		return (void*)Address;
	}

	void* Pointers::DecodePointer(void* Ptr) {
		if (!m_Cookie) {
			ULONG ReturnLength = 0;
			if (GetSyscalls()->NtQueryInformationProcess(GetCurrentProcess(), 0x24, &m_Cookie, 4, &ReturnLength) != 0) {
				return nullptr;
			}
		}

		uint64_t Address = (uint64_t)Ptr;
		for (uint32_t i = 0; i < (m_Cookie & 0x3F); i++) Address = (Address ^ m_Cookie) ^ i;
		Address = ~Address;
		Address = Math::__ROL8__(Address, 0x20);
		Address = Math::__ROL8__(Address, 2);

		return (void*)(Address >> 4);
	}

	Pointers* GetPointers() {
		static Pointers Instance;
		return &Instance;
	}
}
```

`Client/src/utils/secure/pointers.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Secure {
	class Pointers {
	public:
		void* EncodePointer(void* Ptr);
		void* DecodePointer(void* Ptr);
	private:
		uint32_t m_Cookie;
	};

	Pointers* GetPointers();
}
```

`Client/src/utils/secure/resolved.cpp`:

```cpp
#include "resolved.hpp"
#include "utils/caller.hpp"
#include "utils/secure/pointers.hpp"
#include "utils/secure/module.hpp"

namespace Utils::Secure {
	bool Resolved::Initialize() {
		// TODO: Integrity check each resolve

		auto Ntdll = Utils::Secure::GetModuleHandle(L"ntdll.dll");
		if (!Ntdll) { return false; }

		auto Iphl = Utils::Secure::GetModuleHandle(L"iphlpapi.dll");
		if (!Iphl) { return false; }

		m_Functions[_RtlFlushSecureMemoryCache] = (uint64_t)Utils::Secure::GetProcAddress(Ntdll, "RtlFlushSecureMemoryCache");

		for (auto& Functions : m_Functions) {
			if (!Functions.second) return false;
			Functions.second = (uint64_t)EncodePtr((void*)Functions.second);
		}

		return true;
	}

	BOOL Resolved::RtlFlushSecureMemoryCache(PVOID MemoryCache, SIZE_T MemoryLength) {
		std::unique_lock<std::mutex> l(m_Mutexs[_RtlFlushSecureMemoryCache]);
		return Utils::Caller::Call<BOOL>((uint64_t)DecodePtr((void*)m_Functions[_RtlFlushSecureMemoryCache]), MemoryCache, MemoryLength);
	}

	Resolved* GetResolved() {
		static Resolved Instance;
		return &Instance;
	}
}
```

`Client/src/utils/secure/resolved.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Secure {
	class Resolved {
	public:
		bool Initialize();

		BOOL RtlFlushSecureMemoryCache(PVOID MemoryCache, SIZE_T MemoryLength = 0);
	private:
		enum eFunctions {
			_RtlFlushSecureMemoryCache,
		};

		std::unordered_map<eFunctions, uint64_t> m_Functions;
		std::unordered_map<eFunctions, std::mutex> m_Mutexs;
	};

	Resolved* GetResolved();
}
```

`Client/src/utils/secure/syscall.cpp`:

```cpp
#include "syscall.hpp"
#include "utils/caller.hpp"
#include "module.hpp"
#include "dynsec/crypto/crypto.hpp"
#include "utils/secure/pointers.hpp"
#include "virtual.hpp"

namespace Utils::Secure {
	void EncryptAllocation(Syscalls::CryptedAllocItem* Address) {
		if (!Address->m_Encrypted) {
			// on the stack for extra poggers - "supa secret key"
			uint8_t key[] = { 0x73, 0x75, 0x70, 0x61, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x20, 0x6B, 0x65, 0x79 };
			Dynsec::Crypto::RC4(key, sizeof(key), Address->m_ShellCode, Address->m_Size);

			// random key each time
			Address->m_XorKey = (uint8_t)(rand() % 255);

			for (uint8_t i = 0; i < Address->m_Size; i++) {
				Address->m_ShellCode[i] ^= Address->m_XorKey;
			}

			Address->m_Encrypted = true;
		}
	}

	void DecryptAllocation(Syscalls::CryptedAllocItem* Address) {
		if (Address->m_Encrypted) {
			// random key each time
			for (uint8_t i = 0; i < Address->m_Size; i++) {
				Address->m_ShellCode[i] ^= Address->m_XorKey;
			}

			// on the stack for extra poggers - "supa secret key"
			uint8_t key[] = { 0x73, 0x75, 0x70, 0x61, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x20, 0x6B, 0x65, 0x79 };
			Dynsec::Crypto::RC4(key, sizeof(key), Address->m_ShellCode, Address->m_Size);

			Address->m_Encrypted = false;
		}
	}

	void SetupAllocation(std::pair<LPVOID, int> lpAddress, const char* SyscallShellcode, uint8_t ShellcodeSize, uint8_t ShellcodeIndexOffset, bool Encoded = true) {
		Syscalls::CryptedAllocItem* Address = nullptr;

		if (Encoded) {
			Address = (Syscalls::CryptedAllocItem*)DecodePtr(lpAddress.first);
		} else Address = (Syscalls::CryptedAllocItem*)lpAddress.first;

		memcpy(&Address->m_ShellCode, SyscallShellcode, ShellcodeSize);
		*(int*)(&Address->m_ShellCode[ShellcodeIndexOffset]) = lpAddress.second;

		Address->m_Size = ShellcodeSize;
		EncryptAllocation(Address);
	}

	bool Syscalls::Initialize() {
		auto start = std::chrono::high_resolution_clock::now();

		// TODO: Syscall shellcode for each windows versions

#ifdef _WIN64
		int BaseWindowsVersion = (int)ProcessEnvironmentBlock->LoaderLock; // Something is wrong with PEB struct, OSMajorVersion isn't 0x118

		const char* SyscallShellcode = nullptr;
		uint8_t ShellcodeIndexOffset = 0;
		uint8_t ShellcodeSize = 0;

		if (BaseWindowsVersion == 10) { // Windows 10
			SyscallShellcode = "\x49\x89\xCA\xB8\x99\x00\x00\x00\x0F\x05\xC3";
			ShellcodeIndexOffset = 4;
			ShellcodeSize = 11;
		} else if (BaseWindowsVersion == 6) { // Windows 7
			SyscallShellcode = "\xB8\x00\x00\x00\x00\x33\xC9\x8D\x54\x24\x04\x64\xFF\x15\xC0\x00\x00\x00\x83\xC4\x04\xC2\x08\x00"; // NOT TESTED
			ShellcodeIndexOffset = 1;
			ShellcodeSize = 24;
		} else {
			printf("No supported windows version found for syscalls\n");
			return false;
		}
#else
		const char* SyscallShellcode = "\xB8\x99\x00\x00\x00\xCD\x2E\xC3";
		uint8_t ShellcodeIndexOffset = 1;
		uint8_t ShellcodeSize = 8;
#endif

		auto CheckAllocation = [this](LPVOID lpAddress) {
			if (!lpAddress) {
				Clean();
				return false;
			}

			return true;
		};

		char name[MAX_PATH];
		if (GetModuleFileNameA(Utils::Secure::GetModuleHandle(L"ntdll.dll"), name, MAX_PATH)) {
			FILE* fp;
			fopen_s(&fp, name, "rb");
			if (fp) {
				fseek(fp, 0, SEEK_END);
				int size = ftell(fp);
				fseek(fp, 0, SEEK_SET);

				m_NtdllDisk = ::VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
				if (m_NtdllDisk) {
					fread(m_NtdllDisk, 1, size, fp);
					fclose(fp);
				}
			}
		}

		m_Functions[_NtAllocateVirtualMemory].second = GetSyscallIndex("NtAllocateVirtualMemory", m_NtdllDisk);
		m_Functions[_NtFreeVirtualMemory].second = GetSyscallIndex("NtFreeVirtualMemory", m_NtdllDisk);
		m_Functions[_NtProtectVirtualMemory].second = GetSyscallIndex("NtProtectVirtualMemory", m_NtdllDisk);
		m_Functions[_NtQueryVirtualMemory].second = GetSyscallIndex("NtQueryVirtualMemory", m_NtdllDisk);
		m_Functions[_NtQuerySystemInformation].second = GetSyscallIndex("NtQuerySystemInformation", m_NtdllDisk);
		m_Functions[_NtQueryInformationProcess].second = GetSyscallIndex("NtQueryInformationProcess", m_NtdllDisk);
		m_Functions[_NtSetInformationProcess].second = GetSyscallIndex("NtSetInformationProcess", m_NtdllDisk);
		m_Functions[_NtCreateThreadEx].second = GetSyscallIndex("NtCreateThreadEx", m_NtdllDisk);
		m_Functions[_NtQueryInformationThread].second = GetSyscallIndex("NtQueryInformationThread", m_NtdllDisk);
		m_Functions[_NtReadVirtualMemory].second = GetSyscallIndex("NtReadVirtualMemory", m_NtdllDisk);
		m_Functions[_NtSetInformationThread].second = GetSyscallIndex("NtSetInformationThread", m_NtdllDisk);

		if (m_NtdllDisk) ::VirtualFree(m_NtdllDisk, 0, MEM_RELEASE);

		// Allocate the syscall invoke memory
		int BlockSize = ShellcodeSize + sizeof(CryptedAllocItem) - 1;
		m_AllocatedPage = (CryptedAllocItem*)::VirtualAlloc(0, BlockSize * m_Functions.size(), MEM_COMMIT, PAGE_EXECUTE_READWRITE);

		m_Functions[_NtQueryInformationProcess].first = &m_AllocatedPage[_NtQueryInformationProcess * BlockSize];
		if (!CheckAllocation(m_Functions[_NtQueryInformationProcess].first)) return false;
		SetupAllocation(m_Functions[_NtQueryInformationProcess], SyscallShellcode, ShellcodeSize, ShellcodeIndexOffset, false);

		// now that the above syscall is resolved, we can use the secure ptrs
		for (auto& Element : m_Functions) {
			Element.second.first = (CryptedAllocItem*)EncodePtr(&m_AllocatedPage[Element.first * BlockSize]);
			if (!CheckAllocation(Element.second.first)) return false;
			SetupAllocation(Element.second, SyscallShellcode, ShellcodeSize, ShellcodeIndexOffset);
		}

		// encode the page pointer
		m_AllocatedPage = (CryptedAllocItem*)EncodePtr(m_AllocatedPage);

		auto elapsed = std::chrono::high_resolution_clock::now() - start;
		long long microseconds = std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
		printf("%i microseconds to initialize syscalls\n", microseconds);
		return true;
	}

	int Syscalls::GetSyscallIndex(const char* pFunction, LPVOID pDisk) {
		FARPROC FunctionAddress = 0;

		if (pDisk) {
			FunctionAddress = Utils::Secure::GetProcAddressDisk((HMODULE)pDisk, pFunction);
		} else FunctionAddress = Utils::Secure::GetProcAddress(Utils::Secure::GetModuleHandle(L"ntdll.dll"), pFunction);

		if (FunctionAddress) {
			uint64_t Address = (uint64_t)FunctionAddress;
#ifdef _WIN64
			int BaseWindowsVersion = (int)ProcessEnvironmentBlock->LoaderLock; // Something is wrong with PEB struct, OSMajorVersion isn't 0x118

			if (BaseWindowsVersion == 10) {
				if (*(uint8_t*)Address == 0x49 || *(uint8_t*)Address == 0x4C) {
					return *(int*)(Address + 4);
				}
			} else if (BaseWindowsVersion == 6) {
				if (*(uint8_t*)Address == 0xB8) {
					return *(int*)(Address + 1);
				}
			}
#else
			if (*(uint8_t*)Address == 0xB8) {
				return *(int*)(Address + 1);
			}
#endif
	}

		return 0;
}

	void Syscalls::Clean() {
		if (m_Functions[_NtFreeVirtualMemory].first) {
			VirtualFree(GetAllocatedPage(), 0, MEM_RELEASE);
		} else {
			::VirtualFree(GetAllocatedPage(), 0, MEM_RELEASE);
		}
	}

	std::vector<uint64_t> Syscalls::GetSyscallAddresses() {
		std::vector<uint64_t> Addresses;

		for (auto Element : m_Functions) {
			Addresses.push_back((uint64_t)Element.second.first);
		}

		return Addresses;
	}

	Syscalls::CryptedAllocItem* Syscalls::GetAllocatedPage() {
		return (Syscalls::CryptedAllocItem*)DecodePtr(m_AllocatedPage);
	}

	NTSTATUS Syscalls::NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtAllocateVirtualMemory]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtAllocateVirtualMemory].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtFreeVirtualMemory]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtFreeVirtualMemory].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, BaseAddress, RegionSize, FreeType);
		EncryptAllocation(Address);

		m_Mutexs[_NtFreeVirtualMemory].unlock();
		return Return;
	}

	NTSTATUS Syscalls::NtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtProtectVirtualMemory]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtProtectVirtualMemory].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, BaseAddress, NumberOfBytesToProtect, NewAccessProtection, OldAccessProtection);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, int MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtQueryVirtualMemory]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtQueryVirtualMemory].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtQuerySystemInformation(int SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtQuerySystemInformation]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtQuerySystemInformation].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtQueryInformationProcess(HANDLE ProcessHandle, int ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength) {
		static bool FirstCall = true;

		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtQueryInformationProcess]);
		CryptedAllocItem* Address = nullptr;

		if (FirstCall) {
			FirstCall = false;
			Address = (CryptedAllocItem*)m_Functions[_NtQueryInformationProcess].first;
		} else {
			Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtQueryInformationProcess].first);
		}

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtSetInformationProcess(HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtSetInformationProcess]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtSetInformationProcess].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtCreateThreadEx(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, PVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, PVOID lpParameter, ULONG Flags, SIZE_T StackZeroBits, SIZE_T SizeOfStackCommit, SIZE_T SizeOfStackReserve, PVOID lpBytesBuffer) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtCreateThreadEx]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtCreateThreadEx].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, lpStartAddress, lpParameter, Flags, StackZeroBits, SizeOfStackCommit, SizeOfStackReserve, lpBytesBuffer);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtQueryInformationThread(HANDLE ThreadHandle, int ProcessInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtQueryInformationThread]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtQueryInformationThread].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ThreadHandle, ProcessInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtReadVirtualMemory]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtReadVirtualMemory].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
		EncryptAllocation(Address);

		return Return;
	}

	NTSTATUS Syscalls::NtSetInformationThread(HANDLE ThreadHandle, int ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength) {
		NTSTATUS Return = 0;

		std::unique_lock<std::mutex> l(m_Mutexs[_NtSetInformationThread]);
		CryptedAllocItem* Address = (CryptedAllocItem*)DecodePtr(m_Functions[_NtSetInformationThread].first);

		DecryptAllocation(Address);
		Return = Utils::Caller::Call<NTSTATUS>((uint64_t)&Address->m_ShellCode, ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
		EncryptAllocation(Address);

		return Return;
	}

	Syscalls* GetSyscalls() {
		static Syscalls Instance;
		return &Instance;
	}
}
```

`Client/src/utils/secure/syscall.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Secure {
	class Syscalls {
	public:
		struct CryptedAllocItem {
			uint8_t m_Size;
			bool m_Encrypted;
			uint8_t m_XorKey;
			uint8_t m_ShellCode[1];
		};

		bool Initialize();
		void Clean();
		std::vector<uint64_t> GetSyscallAddresses();
		CryptedAllocItem* GetAllocatedPage();

		NTSTATUS NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
		NTSTATUS NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType);
		NTSTATUS NtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection);
		NTSTATUS NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, int MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);
		NTSTATUS NtQuerySystemInformation(int SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
		NTSTATUS NtQueryInformationProcess(HANDLE ProcessHandle, int ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
		NTSTATUS NtSetInformationProcess(HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
		NTSTATUS NtCreateThreadEx(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, PVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, PVOID lpParameter, ULONG Flags, SIZE_T StackZeroBits, SIZE_T SizeOfStackCommit, SIZE_T SizeOfStackReserve, PVOID lpBytesBuffer);
		NTSTATUS NtQueryInformationThread(HANDLE ThreadHandle, int ProcessInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
		NTSTATUS NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded);
		NTSTATUS NtSetInformationThread(HANDLE ThreadHandle, int ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
	private:
		enum eFunctions {
			_NtAllocateVirtualMemory,
			_NtFreeVirtualMemory,
			_NtProtectVirtualMemory,
			_NtQueryVirtualMemory,
			_NtQuerySystemInformation,
			_NtQueryInformationProcess,
			_NtSetInformationProcess,
			_NtCreateThreadEx,
			_NtQueryInformationThread,
			_NtReadVirtualMemory,
			_NtSetInformationThread
		};

		LPVOID m_NtdllDisk = nullptr;
		CryptedAllocItem* m_AllocatedPage;
		std::unordered_map<eFunctions, std::pair<CryptedAllocItem*, int>> m_Functions;
		std::unordered_map<eFunctions, std::mutex> m_Mutexs;

		int GetSyscallIndex(const char* pFunction, LPVOID pDisk = nullptr);
	};
	
	Syscalls* GetSyscalls();
}
```

`Client/src/utils/secure/virtual.cpp`:

```cpp
#include "virtual.hpp"
#include "syscall.hpp"
#include "utils/caller.hpp"
#include "utils/structs.hpp"
#include "resolved.hpp"

namespace Utils::Secure {
	LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
		LPVOID Address = lpAddress;
		if (GetSyscalls()->NtAllocateVirtualMemory(GetCurrentProcess(), &Address, 0, &dwSize, flAllocationType, flProtect) >= 0) {
			return Address;
		}

		return nullptr;
	}

	BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType) {
		if (dwFreeType & 0xFFFF3FFC || (dwFreeType & 0x8003) == 0x8000 && dwSize) {
			return FALSE;
		}

		NTSTATUS Status = GetSyscalls()->NtFreeVirtualMemory(GetCurrentProcess(), &lpAddress, &dwSize, dwFreeType);
		if (Status == 0xC0000045) {
			if (!GetResolved()->RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
				return FALSE;
			}

			Status = GetSyscalls()->NtFreeVirtualMemory(GetCurrentProcess(), &lpAddress, &dwSize, dwFreeType);
		}

		if (Status >= 0) {
			return TRUE;
		}

		return FALSE;
	}

	BOOL VirtualProtect(LPVOID lpAddress, ULONG dwSize, DWORD flNewProtect, PDWORD lpflOldProtect) {
		NTSTATUS Status = GetSyscalls()->NtProtectVirtualMemory(GetCurrentProcess(), &lpAddress, &dwSize, flNewProtect, lpflOldProtect);
		if (Status >= 0) {
			return TRUE;
		}

		if (Status == 0xC0000045
			&& GetResolved()->RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
			Status = GetSyscalls()->NtProtectVirtualMemory(GetCurrentProcess(), &lpAddress, &dwSize, flNewProtect, lpflOldProtect);
			if ((Status & 0x80000000) == 0) {
				return TRUE;
			}
		}

		return FALSE;
	}

	HANDLE CreateThread(SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId) {
		// Will not behave exactly like CreateThread, there's actually quite a bit of setup done CreateThread before calling the nt func
		HANDLE hThread = 0;

		CLIENT_ID threadClient;
		PTEB pTeb = 0;

		struct {
			uint64_t size;
			uint64_t unk1;
			uint64_t unk2;
			PCLIENT_ID pNewThreadInfo;
			uint64_t unk4;
			uint64_t unk5;
			uint64_t unk6;
			PTEB* ppTEB;
			uint64_t unk8;
		} threadData;

		threadData.size = 32 * 2 + 8; // from KernelBase.CreateThreadEx. (also size of unkThreadInfo)
		threadData.unk1 = 0x10003;
		threadData.unk2 = 0x10;
		threadData.unk4 = 0;
		threadData.pNewThreadInfo = &threadClient;
		threadData.unk5 = 0x10004;
		threadData.unk6 = 8;
		threadData.unk8 = 0;
		threadData.ppTEB = &pTeb;

		NTSTATUS Status = GetSyscalls()->NtCreateThreadEx(&hThread, 0x1FFFFF, NULL, GetCurrentProcess(), lpStartAddress, lpParameter, FALSE, NULL, NULL, dwStackSize & -(signed __int64)((dwCreationFlags & 0x10000) != 0), &threadData);
		
		if (lpThreadId) {
			*lpThreadId = (DWORD)threadClient.UniqueThread;
		}
		
		if (!(dwCreationFlags & CREATE_SUSPENDED)) {
			ResumeThread(hThread); // TODO: syscall NtResumeThread
		}

		if (Status >= 0) {
			return hThread;
		}

		return (HANDLE)INVALID_HANDLE_VALUE; 
	}

	BOOL ReadProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, ULONG nSize, PULONG lpNumberOfBytesRead) {
		NTSTATUS Status = GetSyscalls()->NtReadVirtualMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
		if ((Status & 0x80000000) == 0) {
			return TRUE;
		}

		return FALSE;
	}

	std::vector<MEMORY_BASIC_INFORMATION> GetMemoryPages() {
		std::vector<MEMORY_BASIC_INFORMATION> Pages;

		NTSTATUS Status = 0;
		uint64_t CurrentScanAddress = 0;
		MEMORY_BASIC_INFORMATION PageInformation = { 0 };
		SIZE_T OutLength = 0;

		while ((Status = GetSyscalls()->NtQueryVirtualMemory(GetCurrentProcess(), (void*)CurrentScanAddress, 0, &PageInformation, sizeof(PageInformation), &OutLength)) == 0) {
			Pages.push_back(PageInformation);
			CurrentScanAddress += PageInformation.RegionSize;
			memset(&PageInformation, 0, sizeof(PageInformation));
		}

		return Pages;
	}
}
```

`Client/src/utils/secure/virtual.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Secure {
	LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
	BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
	BOOL VirtualProtect(LPVOID lpAddress, ULONG dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
	BOOL ReadProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, ULONG nSize, PULONG lpNumberOfBytesRead);
	HANDLE CreateThread(SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

	std::vector<MEMORY_BASIC_INFORMATION> GetMemoryPages();
}
```

`Client/src/utils/structs.hpp`:

```hpp
#pragma once

#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <minwindef.h> 

typedef void* PPS_POST_PROCESS_INIT_ROUTINE;

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} LSA_UNICODE_STRING, * PLSA_UNICODE_STRING, UNICODE_STRING, * PUNICODE_STRING;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE           Reserved1[16];
	PVOID          Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB_LDR_DATA {
	ULONG      Length;
	BOOL       Initialized;
	LPVOID     SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY     InLoadOrderLinks;
	LIST_ENTRY     InMemoryOrderLinks;
	LIST_ENTRY     InInitializationOrderLinks;
	LPVOID         DllBase;
	LPVOID         EntryPoint;
	ULONG          SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
typedef struct _PEB {
	BYTE                         InheritedAddressSpace;
	BYTE                         ReadImageFileExecOptions;
	BYTE                         BeingDebugged;

	BYTE                         _SYSTEM_DEPENDENT_01;
	LPVOID                       Mutant;
	LPVOID                       ImageBaseAddress;

	PPEB_LDR_DATA                Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	LPVOID                       SubSystemData;
	LPVOID                       ProcessHeap;
	LPVOID                       FastPebLock;
	LPVOID                       _SYSTEM_DEPENDENT_02;
	LPVOID                       _SYSTEM_DEPENDENT_03;
	LPVOID                       _SYSTEM_DEPENDENT_04;
	union {
		LPVOID                     KernelCallbackTable;
		LPVOID                     UserSharedInfoPtr;
	};
	DWORD                        SystemReserved;
	DWORD                        _SYSTEM_DEPENDENT_05;
	LPVOID                       _SYSTEM_DEPENDENT_06;
	LPVOID                       TlsExpansionCounter;
	LPVOID                       TlsBitmap;
	DWORD                        TlsBitmapBits[2];
	LPVOID                       ReadOnlySharedMemoryBase;
	LPVOID                       _SYSTEM_DEPENDENT_07;
	LPVOID                       ReadOnlyStaticServerData;
	LPVOID                       AnsiCodePageData;
	LPVOID                       OemCodePageData;
	LPVOID                       UnicodeCaseTableData;
	DWORD                        NumberOfProcessors;
	union {
		DWORD                      NtGlobalFlag;
		LPVOID                     dummy02;
	};
	LARGE_INTEGER                CriticalSectionTimeout;
	LPVOID                       HeapSegmentReserve;
	LPVOID                       HeapSegmentCommit;
	LPVOID                       HeapDeCommitTotalFreeThreshold;
	LPVOID                       HeapDeCommitFreeBlockThreshold;
	DWORD                        NumberOfHeaps;
	DWORD                        MaximumNumberOfHeaps;
	LPVOID                       ProcessHeaps;
	LPVOID                       GdiSharedHandleTable;
	LPVOID                       ProcessStarterHelper;
	LPVOID                       GdiDCAttributeList;
	LPVOID                       LoaderLock;
	DWORD                        OSMajorVersion;
	DWORD                        OSMinorVersion;
	WORD                         OSBuildNumber;
	WORD                         OSCSDVersion;
	DWORD                        OSPlatformId;
	DWORD                        ImageSubsystem;
	DWORD                        ImageSubsystemMajorVersion;
	LPVOID                       ImageSubsystemMinorVersion;
	union {
		LPVOID                     ImageProcessAffinityMask;
		LPVOID                     ActiveProcessAffinityMask;
	};
#ifdef _WIN64
	LPVOID                       GdiHandleBuffer[64];
#else
	LPVOID                       GdiHandleBuffer[32];
#endif  
	LPVOID                       PostProcessInitRoutine;
	LPVOID                       TlsExpansionBitmap;
	DWORD                        TlsExpansionBitmapBits[32];
	LPVOID                       SessionId;
	ULARGE_INTEGER               AppCompatFlags;
	ULARGE_INTEGER               AppCompatFlagsUser;
	LPVOID                       pShimData;
	LPVOID                       AppCompatInfo;
	PUNICODE_STRING              CSDVersion;
	LPVOID                       ActivationContextData;
	LPVOID                       ProcessAssemblyStorageMap;
	LPVOID                       SystemDefaultActivationContextData;
	LPVOID                       SystemAssemblyStorageMap;
	LPVOID                       MinimumStackCommit;
} PEB, * PPEB;

#define PROCESS_INSTRUMENTATION_CALLBACK (PROCESS_INFORMATION_CLASS)0x28

struct PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION {
	ULONG Version;
	ULONG Reserved;
	PVOID Callback;
};

struct _TEB_ACTIVE_FRAME;
struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	ULONG Flags;
	CHAR * FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
	ULONG Flags;
	_TEB_ACTIVE_FRAME* Previous;
	PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;


typedef struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME
{
	_RTL_ACTIVATION_CONTEXT_STACK_FRAME* Previous;
	_ACTIVATION_CONTEXT * ActivationContext;
	ULONG Flags;
} RTL_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_ACTIVATION_CONTEXT_STACK_FRAME;

typedef struct _ACTIVATION_CONTEXT_STACK
{
	PRTL_ACTIVATION_CONTEXT_STACK_FRAME ActiveFrame;
	LIST_ENTRY FrameListCache;
	ULONG Flags;
	ULONG NextCookieSequenceNumber;
	ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;


typedef struct _GDI_TEB_BATCH
{
	ULONG Offset;
	ULONG HDC;
	ULONG Buffer[310];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB
{
	NT_TIB NtTib;
	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB _ProcessEnvironmentBlock;
	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
	ULONG User32Reserved[26];
	ULONG UserReserved[5];
	PVOID WOW32Reserved;
	ULONG CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	VOID * SystemReserved1[54];
	LONG ExceptionCode;
	PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
	UCHAR SpareBytes1[36];
	ULONG TxFsContext;
	GDI_TEB_BATCH GdiTebBatch;
	CLIENT_ID RealClientId;
	PVOID GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	PVOID GdiThreadLocalInfo;
	ULONG Win32ClientInfo[62];
	VOID * glDispatchTable[233];
	ULONG glReserved1[29];
	PVOID glReserved2;
	PVOID glSectionInfo;
	PVOID glSection;
	PVOID glTable;
	PVOID glCurrentRC;
	PVOID glContext;
	ULONG LastStatusValue;
	UNICODE_STRING StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[261];
	PVOID DeallocationStack;
	VOID * TlsSlots[64];
	LIST_ENTRY TlsLinks;
	PVOID Vdm;
	PVOID ReservedForNtRpc;
	VOID * DbgSsReserved[2];
	ULONG HardErrorMode;
	VOID * Instrumentation[9];
	GUID ActivityId;
	PVOID SubProcessTag;
	PVOID EtwLocalData;
	PVOID EtwTraceData;
	PVOID WinSockData;
	ULONG GdiBatchCount;
	UCHAR SpareBool0;
	UCHAR SpareBool1;
	UCHAR SpareBool2;
	UCHAR IdealProcessor;
	ULONG GuaranteedStackBytes;
	PVOID ReservedForPerf;
	PVOID ReservedForOle;
	ULONG WaitingOnLoaderLock;
	PVOID SavedPriorityState;
	ULONG SoftPatchPtr1;
	PVOID ThreadPoolData;
	VOID * * TlsExpansionSlots;
	ULONG ImpersonationLocale;
	ULONG IsImpersonating;
	PVOID NlsCache;
	PVOID pShimData;
	ULONG HeapVirtualAffinity;
	PVOID CurrentTransactionHandle;
	PTEB_ACTIVE_FRAME ActiveFrame;
	PVOID FlsData;
	PVOID PreferredLanguages;
	PVOID UserPrefLanguages;
	PVOID MergedPrefLanguages;
	ULONG MuiImpersonation;
	WORD CrossTebFlags;
	ULONG SpareCrossTebBits : 16;
	WORD SameTebFlags;
	ULONG DbgSafeThunkCall : 1;
	ULONG DbgInDebugPrint : 1;
	ULONG DbgHasFiberData : 1;
	ULONG DbgSkipThreadAttach : 1;
	ULONG DbgWerInShipAssertCode : 1;
	ULONG DbgRanProcessInit : 1;
	ULONG DbgClonedThread : 1;
	ULONG DbgSuppressDebugMsg : 1;
	ULONG SpareSameTebBits : 8;
	PVOID TxnScopeEnterCallback;
	PVOID TxnScopeExitCallback;
	PVOID TxnScopeContext;
	ULONG LockCount;
	ULONG ProcessRundown;
	UINT64 LastSwitchTime;
	UINT64 TotalSwitchOutTime;
	LARGE_INTEGER WaitReasonBitMap;
} TEB, *PTEB;

typedef struct _TLS_ENTRY
{
	LIST_ENTRY TlsEntryLinks;
	IMAGE_TLS_DIRECTORY TlsDirectory;
	_LDR_DATA_TABLE_ENTRY *ModuleEntry;
} TLS_ENTRY, *PTLS_ENTRY;

```

`Client/src/utils/threads/async.cpp`:

```cpp
#include "async.hpp"
#include <future>

namespace Utils::Async {
	void AsyncRoutine::Begin(void* Param, std::function<void(void*)> Callback) {
		AsyncContext* ctx = new AsyncContext();
		ctx->m_Param = Param;
		ctx->m_Callback = Callback;

		auto f = std::async(std::launch::async, [&] {
			return RunAsync(ctx);
		});
	}
}
```

`Client/src/utils/threads/async.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Async {
	struct AsyncContext {
		void* m_Param;
		std::function<void(void*)> m_Callback;
	};

	class AsyncRoutine {
	public:
		// the begin routine to start the thread
		void Begin(void* Param, std::function<void(void*)> Callback);
	protected:
		// RunAsync gets access to the params
		virtual void RunAsync(AsyncContext* Param) = 0;
	};
}
```

`Client/src/utils/threads/thread_pool.cpp`:

```cpp
#include "thread_pool.hpp"
#include "utils/secure/virtual.hpp"
#include "utils/secure/syscall.hpp"

namespace Utils::Threads {
	ThreadContext* ThreadPool::CreateThread(uint32_t Identifier, std::function<void(void*)> ThreadCallback, void* Param) {
		ThreadContext* Context = new ThreadContext();
		Context->m_Identifier = Identifier;
		Context->m_ThreadCallback = ThreadCallback;
		Context->m_ThreadParam = Param;

		Context->m_Handle = Utils::Secure::CreateThread(0, [] (LPVOID lpParam) -> DWORD {
			ThreadContext* LocalContext = (ThreadContext*)lpParam;

			while (LocalContext->m_Running) {
				if (!LocalContext->m_Paused) {
					LocalContext->m_ThreadCallback(LocalContext->m_ThreadParam);
				}
			}

			delete LocalContext;
			return 0;
		}, Context, 0, 0);

		printf("Created thread: %llx\n", Context->m_Handle);

		m_Threads.push_back(Context);

		// ThreadHideFromDebugger
		Utils::Secure::GetSyscalls()->NtSetInformationThread(Context->m_Handle, 17, 0, 0);

		return Context;
	}

	void ThreadPool::PauseThread(uint32_t Identifier) {
		auto Vit = std::find_if(begin(m_Threads), end(m_Threads), [=] (ThreadContext* Context) {
			return Context->m_Identifier == Identifier;
		});

		if (Vit != end(m_Threads)) {
			(*Vit)->m_Paused = false;
		}
	}

	void ThreadPool::ResumeThread(uint32_t Identifier) {
		auto Vit = std::find_if(begin(m_Threads), end(m_Threads), [=] (ThreadContext* Context) {
			return Context->m_Identifier == Identifier;
		});

		if (Vit != end(m_Threads)) {
			(*Vit)->m_Paused = true;
		}
	}

	void ThreadPool::CloseThread(uint32_t Identifier) {
		auto Vit = std::find_if(begin(m_Threads), end(m_Threads), [=] (ThreadContext* Context) {
			return Context->m_Identifier == Identifier;
		});

		if (Vit != end(m_Threads)) {
			(*Vit)->m_Running = false;
		}
	}

	ThreadPool* GetThreadPool() {
		static ThreadPool Instance;
		return &Instance;
	}
}
```

`Client/src/utils/threads/thread_pool.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::Threads {
	struct ThreadContext {
		uint32_t m_Identifier;
		HANDLE m_Handle;
		bool m_Running = true;
		bool m_Paused;
		void* m_ThreadParam;
		std::function<void(void*)> m_ThreadCallback;
	};

	class ThreadPool {
	public:
		ThreadContext* CreateThread(uint32_t Identifier, std::function<void(void*)> ThreadCallback, void* Param = nullptr);
		void PauseThread(uint32_t Identifier);
		void ResumeThread(uint32_t Identifier);
		void CloseThread(uint32_t Identifier);

		std::vector<ThreadContext*> GetThreads() { return m_Threads; }
	private:
		std::vector<ThreadContext*> m_Threads;
	};

	ThreadPool* GetThreadPool();
}
```

`Client/src/utils/utils.cpp`:

```cpp
#include "utils.hpp"
#include <algorithm>
#include "utils/secure/syscall.hpp"
#include "utils/secure/virtual.hpp"
#include "utils/structs.hpp"
#include "utils/secure/module.hpp"
#include "dynsec/crypto/crypto.hpp"
#include <sstream>
#include <iomanip>

namespace Utils {
	std::string CreateRandomString(int length) {
		auto randchar = [] () -> char {
			const char Charset[] =
				"0123456789"
				"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				"abcdefghijklmnopqrstuvwxyz";
			return Charset[rand() % (sizeof(Charset) - 1)];
		};

		std::string str(length, 0);
		std::generate_n(str.begin(), length, randchar);
		return str;
	}

	std::string ConvertBytesToString(uint8_t* data, uint32_t length, bool space) {
		std::stringstream str;
		str.setf(std::ios_base::hex, std::ios::basefield);
		str.setf(std::ios_base::uppercase);
		str.fill('0');

		for (uint32_t i = 0; i < length; ++i) {
			str << std::setw(2) << (unsigned short)data[i];

			if (space && i != length - 1) {
				str << " ";
			}
		}

		return str.str();
	}

	std::vector<uint8_t> ConvertNumberToBytes(uint32_t param) {
		std::vector<uint8_t> arrayOfByte(4);
		for (uint8_t i = 0; i < 4; i++)
			arrayOfByte[3 - i] = (param >> (i * 8));
		return arrayOfByte;
	}

	uint64_t GetThreadEntryPoint(HANDLE hThread) {
		NTSTATUS ntStatus;
		DWORD64 dwThreadStartAddr = 0;
		HANDLE hNewThreadHandle;

		if (DuplicateHandle(GetCurrentProcess(), hThread, GetCurrentProcess(), &hNewThreadHandle, THREAD_QUERY_INFORMATION, FALSE, 0)) {
			ntStatus = Utils::Secure::GetSyscalls()->NtQueryInformationThread(hNewThreadHandle, /*ThreadQuerySetWin32StartAddress*/9, &dwThreadStartAddr, sizeof(DWORD64), NULL);
			CloseHandle(hNewThreadHandle);
			if (ntStatus > 0) return 0;
		}

		return dwThreadStartAddr;
	}

	void ReplaceString(std::string& str, std::string from, std::string to) {
		size_t start_pos = 0;
		while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
			size_t end_pos = start_pos + from.length();
			while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
				str.replace(start_pos, from.length(), to);
				start_pos += to.length(); // ...
			}
			start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
		}
	}
}
```

`Client/src/utils/utils.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils {
	std::string CreateRandomString(int length);
	std::string ConvertBytesToString(uint8_t* data, uint32_t length, bool space = false);
	std::vector<uint8_t> ConvertNumberToBytes(uint32_t param);
	uint64_t GetThreadEntryPoint(HANDLE hThread);
	void ReplaceString(std::string& str, std::string from, std::string to);
}
```

`Client/src/utils/va.cpp`:

```cpp
#include "va.hpp"

namespace Utils::VA {
	char vaStorage[0x200];
	const char* VA(const char* fmt, ...) {
		memset(vaStorage, 0, 0x200);
		va_list ap;
		va_start(ap, fmt);
		vsprintf_s(vaStorage, fmt, ap);
		va_end(ap);
		return vaStorage;
	}

	const wchar_t* VAW(const char* fmt, ...) {
		CHAR Buffer[0x1000];
		CHAR MessageBuffer[0x100];
		static WCHAR Message[0x100];

		va_list pArgList;
		va_start(pArgList, fmt);
		vsprintf_s(Buffer, fmt, pArgList);
		va_end(pArgList);

		sprintf(MessageBuffer, Buffer);
		mbstowcs(Message, MessageBuffer, strlen(MessageBuffer) + 1);

		ZeroMemory(Buffer, sizeof(Buffer));
		ZeroMemory(MessageBuffer, sizeof(MessageBuffer));

		return Message;
	}

	const char* VABuffer(char* buffer, std::size_t size, const char* fmt, ...) {
		memset(buffer, 0, size);
		va_list ap;
		va_start(ap, fmt);
		vsprintf(buffer, fmt, ap);
		va_end(ap);
		return buffer;
	}
}
```

`Client/src/utils/va.hpp`:

```hpp
#pragma once
#include "stdafx.hpp"

namespace Utils::VA {
	const char* VA(const char* fmt, ...);
	const wchar_t* VAW(const char* fmt, ...);
	const char* VABuffer(char* buffer, std::size_t size, const char* fmt, ...);
}
```

`DynSec Wrapper/DynSec Wrapper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <RootNamespace>DynSec_Wrapper</RootNamespace>
    <Platforms>x64;x86</Platforms>
	<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug'">
    <OutputPath>x64/Debug/</OutputPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutputPath>../x64/Debug/</OutputPath>
    <DefineConstants>X64</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutputPath>../x64/Release/</OutputPath>
    <DefineConstants>X64</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <OutputPath>../x86/Release/</OutputPath>
    <DefineConstants>X86</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <OutputPath>../x86/Debug/</OutputPath>
    <DefineConstants>X86</DefineConstants>
  </PropertyGroup>

</Project>

```

`DynSec Wrapper/DynSec.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace DynSec_Wrapper
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct Callbacks
    {

    }
    public class DynSecAntiCheat
    {
        [DllImport("Client.dll", EntryPoint="InitializeClient", CallingConvention = CallingConvention.StdCall)]
        private static extern void _InitializeClient(ref Callbacks callbacks);

        public static void InitializeClient(Callbacks callbacks)
        {
            _InitializeClient(ref callbacks);
        }
    }
}

```

`Dynsec.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.757
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Client", "Client\Client.vcxproj", "{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestingGrounds", "TestingGrounds\TestingGrounds.vcxproj", "{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "DynSec Wrapper", "DynSec Wrapper\DynSec Wrapper.csproj", "{61534F28-E6C8-4FB0-AAB7-342AEFE78032}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "NETTestingGrounds", "NETTestingGrounds\NETTestingGrounds.csproj", "{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Debug|x64.ActiveCfg = Debug|x64
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Debug|x64.Build.0 = Debug|x64
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Debug|x86.ActiveCfg = Debug|Win32
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Debug|x86.Build.0 = Debug|Win32
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Release|Any CPU.ActiveCfg = Release|Win32
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Release|x64.ActiveCfg = Release|x64
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Release|x64.Build.0 = Release|x64
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Release|x86.ActiveCfg = Release|Win32
		{9F3F34E9-9734-4CCB-B2F9-76A81A723D97}.Release|x86.Build.0 = Release|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Debug|x64.ActiveCfg = Debug|x64
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Debug|x64.Build.0 = Debug|x64
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Debug|x86.ActiveCfg = Debug|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Debug|x86.Build.0 = Debug|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Release|Any CPU.ActiveCfg = Release|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Release|x64.ActiveCfg = Release|x64
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Release|x64.Build.0 = Release|x64
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Release|x86.ActiveCfg = Release|Win32
		{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}.Release|x86.Build.0 = Release|Win32
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Debug|Any CPU.ActiveCfg = Debug|x86
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Debug|x64.ActiveCfg = Debug|x64
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Debug|x64.Build.0 = Debug|x64
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Debug|x86.ActiveCfg = Debug|x86
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Debug|x86.Build.0 = Debug|x86
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Release|Any CPU.ActiveCfg = Release|x86
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Release|x64.ActiveCfg = Release|x64
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Release|x64.Build.0 = Release|x64
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Release|x86.ActiveCfg = Release|x86
		{61534F28-E6C8-4FB0-AAB7-342AEFE78032}.Release|x86.Build.0 = Release|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Debug|Any CPU.ActiveCfg = Debug|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Debug|x64.ActiveCfg = Debug|x64
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Debug|x64.Build.0 = Debug|x64
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Debug|x86.ActiveCfg = Debug|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Debug|x86.Build.0 = Debug|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Release|Any CPU.ActiveCfg = Release|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Release|x64.ActiveCfg = Release|x64
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Release|x64.Build.0 = Release|x64
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Release|x86.ActiveCfg = Release|x86
		{2F5563A8-F848-4D40-96C8-F0102BA7D6D5}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BDDC9941-9A48-4A54-B29C-46FA10E550C6}
	EndGlobalSection
EndGlobal

```

`NETTestingGrounds/NETTestingGrounds.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp2.1</TargetFramework>
	<Platforms>x64;x86</Platforms>
	<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug'">
    <OutputPath>x64/Debug/</OutputPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutputPath>../x64/Debug/</OutputPath>
    <DefineConstants>TRACE;X64</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutputPath>../x64/Release/</OutputPath>
    <DefineConstants>TRACE;X64</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <OutputPath>../x86/Release/</OutputPath>
    <DefineConstants>TRACE;X86</DefineConstants>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <OutputPath>../x86/Debug/</OutputPath>
    <DefineConstants>TRACE;X86</DefineConstants>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\DynSec Wrapper\DynSec Wrapper.csproj" />
  </ItemGroup>

</Project>

```

`NETTestingGrounds/Program.cs`:

```cs
using System;
using DynSec_Wrapper;
namespace NETTestingGrounds
{
    class Program
    {
        static void Log(string msg, params object[] param)
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine(msg, param);
            Console.ResetColor();
        }
        static void Main(string[] args)
        {
            Log("Initializing...!");
            DynSecAntiCheat.InitializeClient(new Callbacks());
            Log("DynSec loaded in C# !");

            Console.ReadLine();
        }
    }
}

```

`TestingGrounds/TestingGrounds.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F3DCACA3-6A40-4F5B-A99C-F56A651B8B0D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>TestingGrounds</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\TestingGrounds.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TestingGrounds/TestingGrounds.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\TestingGrounds.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`TestingGrounds/src/TestingGrounds.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <chrono>
#include <iostream>

DWORD WINAPI Thread(LPVOID) {
    printf("thread called\n");
    return 0;
}

int main() {
	// We want it packed this way to match C#
#pragma pack(push, 1)
    struct Callbacks {

    };
#pragma pack(pop)

    printf("loading...\n");
	HMODULE Dynsec = LoadLibraryA("Client.dll");
	printf("loaded\n");
    if (Dynsec) {
        printf("Dynsec client: %llx\n", Dynsec);
        FARPROC Initialize = GetProcAddress(Dynsec, "InitializeClient");
        if (Initialize) {
            printf("InitializeClient: %llx\n", Initialize);
            Callbacks* Data = new Callbacks();
            ((void(__stdcall*)(Callbacks*))Initialize)(Data);

            // temp
            delete Data;
        }
    }

    std::cin.get();
}
```