Project Path: arc_gmh5225_t7-linker_nu8vl6wy

Source Tree:

```txt
arc_gmh5225_t7-linker_nu8vl6wy
├── LICENSE
├── README.md
└── src
    ├── generic
    │   ├── Common.hpp
    │   ├── Core
    │   │   └── Component.hpp
    │   ├── Game
    │   │   └── Structs.hpp
    │   └── Utils
    │       ├── Compression.cpp
    │       ├── Compression.hpp
    │       ├── Cryptography.cpp
    │       ├── Cryptography.hpp
    │       ├── Flags.cpp
    │       ├── Flags.hpp
    │       ├── Hooking.cpp
    │       ├── Hooking.hpp
    │       ├── IO.cpp
    │       ├── IO.hpp
    │       ├── Lock.cpp
    │       ├── Lock.hpp
    │       ├── Memory.cpp
    │       ├── Memory.hpp
    │       ├── NT.cpp
    │       ├── NT.hpp
    │       ├── Queue.hpp
    │       ├── Signal.hpp
    │       ├── String.cpp
    │       ├── String.hpp
    │       ├── Time.cpp
    │       ├── Time.hpp
    │       ├── Utils.cpp
    │       └── Utils.hpp
    └── linker
        ├── Core
        │   ├── Components
        │   │   ├── Command.cpp
        │   │   ├── Command.hpp
        │   │   ├── Console.cpp
        │   │   ├── Console.hpp
        │   │   ├── Core.cpp
        │   │   ├── Core.hpp
        │   │   ├── Linker.cpp
        │   │   ├── Linker.hpp
        │   │   ├── Scheduler.cpp
        │   │   └── Scheduler.hpp
        │   ├── Loader.cpp
        │   ├── Loader.hpp
        │   ├── Syringe.cpp
        │   └── Syringe.hpp
        ├── Game
        │   ├── FastFile.cpp
        │   ├── FastFile.hpp
        │   ├── Game.cpp
        │   ├── Game.hpp
        │   ├── Stream.cpp
        │   ├── Stream.hpp
        │   ├── Zone.cpp
        │   └── Zone.hpp
        ├── Linker.cpp
        ├── Resource.rc
        ├── STDInclude.cpp
        ├── STDInclude.hpp
        └── Utils
            ├── CSV.cpp
            ├── CSV.hpp
            ├── Salsa20.cpp
            └── Salsa20.hpp

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
![license](https://img.shields.io/github/license/momo5502/t7-linker.svg)
[![paypal](https://img.shields.io/badge/PayPal-support-blue.svg?logo=paypal)](https://paypal.me/momo5502)

# T7 Linker

100% accurate and complete Black Ops 2 FastFile linker I wrote ages ago.  
Instead of manually writing/generating serialization code, it hooks the game's FastFile loading code to make it generate a FastFile.

A lot of things are missing to get it to compile. This is only for archiving purposes.  
Requires the dedicated server binary.

```

`src/generic/Common.hpp`:

```hpp
#pragma once

#ifndef RC_INVOKED

// Usefull for debugging
template <size_t S> class Sizer { };
#define BindNum(x, y) Sizer<x> y;
#define XSizeOf(x, y) BindNum(sizeof(x), y)
#define XOffsetOf(x, y, z) BindNum(offsetof(x, y), z)

#define STRINGIZE_(x) #x
#define STRINGIZE(x) STRINGIZE_(x)

#define AssertSize(x, size) static_assert(sizeof(x) == size, STRINGIZE(x) " structure has an invalid size.")
#define AssertOffset(x, y, offset) static_assert(offsetof(x, y) == offset, STRINGIZE(x) "::" STRINGIZE(y) " is not at the right offset.")

#define DATA_PATH "t6r"

#endif

// Resource stuff
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
// Defines below make accessing the resources from the code easier.
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/generic/Core/Component.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Components
{
	class IComponent
	{
	public:
		IComponent() {}
		virtual ~IComponent() {}

#ifdef DEBUG
		virtual Utils::String getName()
		{
			return Utils::String(typeid(*this).name()).replaceAll("class Components::", "");
		}
#endif

		virtual void preDestroy() {}
	};
}

```

`src/generic/Game/Structs.hpp`:

```hpp
#pragma once

#ifdef __cplusplus
#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#define XFILE_BLOCK_SIZE 0x7FC0
#define XFILE_CHUNK_SIZE 0x8000

#define XFILE_MAGIC_RAW 0x3030317576734154
#define XFILE_MAGIC_SIGNED 0x3030313066664154
#define XFILE_MAGIC_UNSIGNED 0x3030317566664154

#define XFILE_IV_MAGIC_IDENTIFIER 0x3137734245454850	// PHEEBs71

namespace Game
{
#pragma warning(push)
#pragma warning(disable: 4324)
#endif

	typedef float vec2_t[2];
	typedef float vec3_t[3];
	typedef float vec4_t[4];

	typedef vec4_t float44[4];

	enum XAssetType
	{
		ASSET_TYPE_XMODELPIECES = 0x0,
		ASSET_TYPE_PHYSPRESET = 0x1,
		ASSET_TYPE_PHYSCONSTRAINTS = 0x2,
		ASSET_TYPE_DESTRUCTIBLEDEF = 0x3,
		ASSET_TYPE_XANIMPARTS = 0x4,
		ASSET_TYPE_XMODEL = 0x5,
		ASSET_TYPE_MATERIAL = 0x6,
		ASSET_TYPE_TECHNIQUE_SET = 0x7,
		ASSET_TYPE_IMAGE = 0x8,
		ASSET_TYPE_SOUND = 0x9,
		ASSET_TYPE_SOUND_PATCH = 0xA,
		ASSET_TYPE_CLIPMAP = 0xB,
		ASSET_TYPE_CLIPMAP_PVS = 0xC,
		ASSET_TYPE_COMWORLD = 0xD,
		ASSET_TYPE_GAMEWORLD_SP = 0xE,
		ASSET_TYPE_GAMEWORLD_MP = 0xF,
		ASSET_TYPE_MAP_ENTS = 0x10,
		ASSET_TYPE_GFXWORLD = 0x11,
		ASSET_TYPE_LIGHT_DEF = 0x12,
		ASSET_TYPE_UI_MAP = 0x13,
		ASSET_TYPE_FONT = 0x14,
		ASSET_TYPE_FONTICON = 0x15,
		ASSET_TYPE_MENULIST = 0x16,
		ASSET_TYPE_MENU = 0x17,
		ASSET_TYPE_LOCALIZE_ENTRY = 0x18,
		ASSET_TYPE_WEAPON = 0x19,
		ASSET_TYPE_WEAPONDEF = 0x1A,
		ASSET_TYPE_WEAPON_VARIANT = 0x1B,
		ASSET_TYPE_WEAPON_FULL = 0x1C,
		ASSET_TYPE_ATTACHMENT = 0x1D,
		ASSET_TYPE_ATTACHMENT_UNIQUE = 0x1E,
		ASSET_TYPE_WEAPON_CAMO = 0x1F,
		ASSET_TYPE_SNDDRIVER_GLOBALS = 0x20,
		ASSET_TYPE_FX = 0x21,
		ASSET_TYPE_IMPACT_FX = 0x22,
		ASSET_TYPE_AITYPE = 0x23,
		ASSET_TYPE_MPTYPE = 0x24,
		ASSET_TYPE_MPBODY = 0x25,
		ASSET_TYPE_MPHEAD = 0x26,
		ASSET_TYPE_CHARACTER = 0x27,
		ASSET_TYPE_XMODELALIAS = 0x28,
		ASSET_TYPE_RAWFILE = 0x29,
		ASSET_TYPE_STRINGTABLE = 0x2A,
		ASSET_TYPE_LEADERBOARD = 0x2B,
		ASSET_TYPE_XGLOBALS = 0x2C,
		ASSET_TYPE_DDL = 0x2D,
		ASSET_TYPE_GLASSES = 0x2E,
		ASSET_TYPE_EMBLEMSET = 0x2F,
		ASSET_TYPE_SCRIPTPARSETREE = 0x30,
		ASSET_TYPE_KEYVALUEPAIRS = 0x31,
		ASSET_TYPE_VEHICLEDEF = 0x32,
		ASSET_TYPE_MEMORYBLOCK = 0x33,
		ASSET_TYPE_ADDON_MAP_ENTS = 0x34,
		ASSET_TYPE_TRACER = 0x35,
		ASSET_TYPE_SKINNEDVERTS = 0x36,
		ASSET_TYPE_QDB = 0x37,
		ASSET_TYPE_SLUG = 0x38,
		ASSET_TYPE_FOOTSTEP_TABLE = 0x39,
		ASSET_TYPE_FOOTSTEPFX_TABLE = 0x3A,
		ASSET_TYPE_ZBARRIER = 0x3B,
		ASSET_TYPE_COUNT = 0x3C,
		ASSET_TYPE_STRING = 0x3C,
		ASSET_TYPE_ASSETLIST = 0x3D,
		ASSET_TYPE_REPORT = 0x3E,
		ASSET_TYPE_DEPEND = 0x3F,
		ASSET_TYPE_FULL_COUNT = 0x40,
		ASSET_TYPE_INVALID = -1,
	};

	enum bdLobbyErrorCode
	{
		BD_NO_ERROR = 0x0,
		BD_TOO_MANY_TASKS = 0x1,
		BD_NOT_CONNECTED = 0x2,
		BD_SEND_FAILED = 0x3,
		BD_HANDLE_TASK_FAILED = 0x4,
		BD_START_TASK_FAILED = 0x5,
		BD_RESULT_EXCEEDS_BUFFER_SIZE = 0x64,
		BD_ACCESS_DENIED = 0x65,
		BD_EXCEPTION_IN_DB = 0x66,
		BD_MALFORMED_TASK_HEADER = 0x67,
		BD_INVALID_ROW = 0x68,
		BD_EMPTY_ARG_LIST = 0x69,
		BD_PARAM_PARSE_ERROR = 0x6A,
		BD_PARAM_MISMATCHED_TYPE = 0x6B,
		BD_SERVICE_NOT_AVAILABLE = 0x6C,
		BD_CONNECTION_RESET = 0x6D,
		BD_INVALID_USER_ID = 0x6E,
		BD_LOBBY_PROTOCOL_VERSION_FAILURE = 0x6F,
		BD_LOBBY_INTERNAL_FAILURE = 0x70,
		BD_LOBBY_PROTOCOL_ERROR = 0x71,
		BD_LOBBY_FAILED_TO_DECODE_UTF8 = 0x72,
		BD_LOBBY_ASCII_EXPECTED = 0x73,
		BD_ASYNCHRONOUS_ERROR = 0xC8,
		BD_STREAMING_COMPLETE = 0xC9,
		BD_MEMBER_NO_PROPOSAL = 0x12C,
		BD_TEAMNAME_ALREADY_EXISTS = 0x12D,
		BD_MAX_TEAM_MEMBERSHIPS_LIMITED = 0x12E,
		BD_MAX_TEAM_OWNERSHIPS_LIMITED = 0x12F,
		BD_NOT_A_TEAM_MEMBER = 0x130,
		BD_INVALID_TEAM_ID = 0x131,
		BD_INVALID_TEAM_NAME = 0x132,
		BD_NOT_A_TEAM_OWNER = 0x133,
		BD_NOT_AN_ADMIN_OR_OWNER = 0x134,
		BD_MEMBER_PROPOSAL_EXISTS = 0x135,
		BD_MEMBER_EXISTS = 0x136,
		BD_TEAM_FULL = 0x137,
		BD_VULGAR_TEAM_NAME = 0x138,
		BD_TEAM_USERID_BANNED = 0x139,
		BD_TEAM_EMPTY = 0x13A,
		BD_INVALID_TEAM_PROFILE_QUERY_ID = 0x13B,
		BD_TEAMNAME_TOO_SHORT = 0x13C,
		BD_UNIQUE_PROFILE_DATA_EXISTS_ALREADY = 0x13D,
		BD_INVALID_LEADERBOARD_ID = 0x190,
		BD_INVALID_STATS_SET = 0x191,
		BD_EMPTY_STATS_SET_IGNORED = 0x193,
		BD_NO_DIRECT_ACCESS_TO_ARBITRATED_LBS = 0x194,
		BD_STATS_WRITE_PERMISSION_DENIED = 0x195,
		BD_STATS_WRITE_TYPE_DATA_TYPE_MISMATCH = 0x196,
		BD_NO_STATS_FOR_USER = 0x197,
		BD_INVALID_ACCESS_TO_UNRANKED_LB = 0x198,
		BD_INVALID_EXTERNAL_TITLE_ID = 0x199,
		BD_DIFFERENT_LEADERBOARD_SCHEMAS = 0x19A,
		BD_TOO_MANY_LEADERBOARDS_REQUESTED = 0x19B,
		BD_ENTITLEMENTS_ERROR = 0x19C,
		BD_ENTITLEMENTS_INVALID_TITLEID = 0x19D,
		BD_ENTITLEMENTS_INVALID_LEADERBOARDID = 0x19E,
		BD_ENTITLEMENTS_INVALID_GET_MODE_FOR_TITLE = 0x19F,
		BD_ENTITLEMENTS_URL_CONNECTION_ERROR = 0x1A0,
		BD_ENTITLEMENTS_CONFIG_ERROR = 0x1A1,
		BD_ENTITLEMENTS_NAMED_PARENT_ERROR = 0x1A2,
		BD_ENTITLEMENTS_NAMED_KEY_ERROR = 0x1A3,
		BD_TOO_MANY_ENTITY_IDS_REQUESTED = 0x1A4,
		BD_INVALID_TITLE_ID = 0x1F4,
		BD_MESSAGING_INVALID_MAIL_ID = 0x258,
		BD_SELF_BLOCK_NOT_ALLOWED = 0x259,
		BD_GLOBAL_MESSAGE_ACCESS_DENIED = 0x25A,
		BD_GLOBAL_MESSAGES_USER_LIMIT_EXCEEDED = 0x25B,
		BD_AUTH_NO_ERROR = 0x2BC,
		BD_AUTH_BAD_REQUEST = 0x2BD,
		BD_AUTH_SERVER_CONFIG_ERROR = 0x2BE,
		BD_AUTH_BAD_TITLE_ID = 0x2BF,
		BD_AUTH_BAD_ACCOUNT = 0x2C0,
		BD_AUTH_ILLEGAL_OPERATION = 0x2C1,
		BD_AUTH_INCORRECT_LICENSE_CODE = 0x2C2,
		BD_AUTH_CREATE_USERNAME_EXISTS = 0x2C3,
		BD_AUTH_CREATE_USERNAME_ILLEGAL = 0x2C4,
		BD_AUTH_CREATE_USERNAME_VULGAR = 0x2C5,
		BD_AUTH_CREATE_MAX_ACC_EXCEEDED = 0x2C6,
		BD_AUTH_MIGRATE_NOT_SUPPORTED = 0x2C7,
		BD_AUTH_TITLE_DISABLED = 0x2C8,
		BD_AUTH_ACCOUNT_EXPIRED = 0x2C9,
		BD_AUTH_ACCOUNT_LOCKED = 0x2CA,
		BD_AUTH_UNKNOWN_ERROR = 0x2CB,
		BD_AUTH_INCORRECT_PASSWORD = 0x2CC,
		BD_AUTH_IP_NOT_IN_ALLOWED_RANGE = 0x2CD,
		BD_AUTH_WII_TOKEN_VERIFICATION_FAILED = 0x2CE,
		BD_AUTH_WII_AUTHENTICATION_FAILED = 0x2CF,
		BD_AUTH_IP_KEY_LIMIT_REACHED = 0x2D0,
		BD_AUTH_INVALID_GSPID = 0x2D1,
		BD_AUTH_INVALID_IP_RANGE_ID = 0x2D2,
		BD_AUTH_3DS_TOKEN_VERIFICATION_FAILED = 0x2D1,
		BD_AUTH_3DS_AUTHENTICATION_FAILED = 0x2D2,
		BD_AUTH_STEAM_APP_ID_MISMATCH = 0x2D3,
		BD_AUTH_ABACCOUNTS_APP_ID_MISMATCH = 0x2D4,
		BD_AUTH_CODO_USERNAME_NOT_SET = 0x2D5,
		BD_AUTH_WIIU_TOKEN_VERIFICATION_FAILED = 0x2D6,
		BD_AUTH_WIIU_AUTHENTICATION_FAILED = 0x2D7,
		BD_AUTH_CODO_USERNAME_NOT_BASE64 = 0x2D8,
		BD_AUTH_CODO_USERNAME_NOT_UTF8 = 0x2D9,
		BD_AUTH_TENCENT_TICKET_EXPIRED = 0x2DA,
		BD_NO_PROFILE_INFO_EXISTS = 0x320,
		BD_FRIENDSHIP_NOT_REQUSTED = 0x384,
		BD_NOT_A_FRIEND = 0x385,
		BD_SELF_FRIENDSHIP_NOT_ALLOWED = 0x387,
		BD_FRIENDSHIP_EXISTS = 0x388,
		BD_PENDING_FRIENDSHIP_EXISTS = 0x389,
		BD_USERID_BANNED = 0x38A,
		BD_FRIENDS_FULL = 0x38C,
		BD_FRIENDS_NO_RICH_PRESENCE = 0x38D,
		BD_RICH_PRESENCE_TOO_LARGE = 0x38E,
		BD_NO_FILE = 0x3E8,
		BD_PERMISSION_DENIED = 0x3E9,
		BD_FILESIZE_LIMIT_EXCEEDED = 0x3EA,
		BD_FILENAME_MAX_LENGTH_EXCEEDED = 0x3EB,
		BD_CHANNEL_DOES_NOT_EXIST = 0x44D,
		BD_CHANNEL_ALREADY_SUBSCRIBED = 0x44E,
		BD_CHANNEL_NOT_SUBSCRIBED = 0x44F,
		BD_CHANNEL_FULL = 0x450,
		BD_CHANNEL_SUBSCRIPTIONS_FULL = 0x451,
		BD_CHANNEL_NO_SELF_WHISPERING = 0x452,
		BD_CHANNEL_ADMIN_REQUIRED = 0x453,
		BD_CHANNEL_TARGET_NOT_SUBSCRIBED = 0x454,
		BD_CHANNEL_REQUIRES_PASSWORD = 0x455,
		BD_CHANNEL_TARGET_IS_SELF = 0x456,
		BD_CHANNEL_PUBLIC_BAN_NOT_ALLOWED = 0x457,
		BD_CHANNEL_USER_BANNED = 0x458,
		BD_CHANNEL_PUBLIC_PASSWORD_NOT_ALLOWED = 0x459,
		BD_CHANNEL_PUBLIC_KICK_NOT_ALLOWED = 0x45A,
		BD_EVENT_DESC_TRUNCATED = 0x4B0,
		BD_CONTENT_UNLOCK_UNKNOWN_ERROR = 0x514,
		BD_UNLOCK_KEY_INVALID = 0x515,
		BD_UNLOCK_KEY_ALREADY_USED_UP = 0x516,
		BD_SHARED_UNLOCK_LIMIT_REACHED = 0x517,
		BD_DIFFERENT_HARDWARE_ID = 0x518,
		BD_INVALID_CONTENT_OWNER = 0x519,
		BD_CONTENT_UNLOCK_INVALID_USER = 0x51A,
		BD_KEY_ARCHIVE_INVALID_WRITE_TYPE = 0x5DC,
		BD_KEY_ARCHIVE_EXCEEDED_MAX_IDS_PER_REQUEST = 0x5DD,
		BD_BANDWIDTH_TEST_TRY_AGAIN = 0x712,
		BD_BANDWIDTH_TEST_STILL_IN_PROGRESS = 0x713,
		BD_BANDWIDTH_TEST_NOT_PROGRESS = 0x714,
		BD_BANDWIDTH_TEST_SOCKET_ERROR = 0x715,
		BD_INVALID_SESSION_NONCE = 0x76D,
		BD_ARBITRATION_FAILURE = 0x76F,
		BD_ARBITRATION_USER_NOT_REGISTERED = 0x771,
		BD_ARBITRATION_NOT_CONFIGURED = 0x772,
		BD_CONTENTSTREAMING_FILE_NOT_AVAILABLE = 0x7D0,
		BD_CONTENTSTREAMING_STORAGE_SPACE_EXCEEDED = 0x7D1,
		BD_CONTENTSTREAMING_NUM_FILES_EXCEEDED = 0x7D2,
		BD_CONTENTSTREAMING_UPLOAD_BANDWIDTH_EXCEEDED = 0x7D3,
		BD_CONTENTSTREAMING_FILENAME_MAX_LENGTH_EXCEEDED = 0x7D4,
		BD_CONTENTSTREAMING_MAX_THUMB_DATA_SIZE_EXCEEDED = 0x7D5,
		BD_CONTENTSTREAMING_DOWNLOAD_BANDWIDTH_EXCEEDED = 0x7D6,
		BD_CONTENTSTREAMING_NOT_ENOUGH_DOWNLOAD_BUFFER_SPACE = 0x7D7,
		BD_CONTENTSTREAMING_SERVER_NOT_CONFIGURED = 0x7D8,
		BD_CONTENTSTREAMING_INVALID_APPLE_RECEIPT = 0x7DA,
		BD_CONTENTSTREAMING_APPLE_STORE_NOT_AVAILABLE = 0x7DB,
		BD_CONTENTSTREAMING_APPLE_RECEIPT_FILENAME_MISMATCH = 0x7DC,
		BD_CONTENTSTREAMING_HTTP_ERROR = 0x7E4,
		BD_CONTENTSTREAMING_FAILED_TO_START_HTTP = 0x7E5,
		BD_CONTENTSTREAMING_LOCALE_INVALID = 0x7E6,
		BD_CONTENTSTREAMING_LOCALE_MISSING = 0x7E7,
		BD_VOTERANK_ERROR_EMPTY_RATING_SUBMISSION = 0x7EE,
		BD_VOTERANK_ERROR_MAX_VOTES_EXCEEDED = 0x7EF,
		BD_VOTERANK_ERROR_INVALID_RATING = 0x7F0,
		BD_MAX_NUM_TAGS_EXCEEDED = 0x82A,
		BD_TAGGED_COLLECTION_DOES_NOT_EXIST = 0x82B,
		BD_EMPTY_TAG_ARRAY = 0x82C,
		BD_INVALID_QUERY_ID = 0x834,
		BD_NO_ENTRY_TO_UPDATE = 0x835,
		BD_SESSION_INVITE_EXISTS = 0x836,
		BD_INVALID_SESSION_ID = 0x837,
		BD_ATTACHMENT_TOO_LARGE = 0x838,
		BD_INVALID_GROUP_ID = 0xAF0,
		BD_UCD_SERVICE_ERROR = 0xC80,
		BD_UCD_SERVICE_DISABLED = 0xC81,
		BD_UCD_UNINTIALIZED_ERROR = 0xC82,
		BD_UCD_ACCOUNT_ALREADY_REGISTERED = 0xC83,
		BD_UCD_ACCOUNT_NOT_REGISTERED = 0xC84,
		BD_UCD_AUTH_ATTEMPT_FAILED = 0xC85,
		BD_UCD_ACCOUNT_LINKING_ERROR = 0xC86,
		BD_UCD_ENCRYPTION_ERROR = 0xC87,
		BD_UCD_ACCOUNT_DATA_INVALID = 0xC88,
		BD_UCD_ACCOUNT_DATA_INVALID_FIRSTNAME = 0xC89,
		BD_UCD_ACCOUNT_DATA_INVALID_LASTNAME = 0xC8A,
		BD_UCD_ACCOUNT_DATA_INVALID_DOB = 0xC8B,
		BD_UCD_ACCOUNT_DATA_INVALID_EMAIL = 0xC8C,
		BD_UCD_ACCOUNT_DATA_INVALID_COUNTRY = 0xC8D,
		BD_UCD_ACCOUNT_DATA_INVALID_POSTCODE = 0xC8E,
		BD_YOUTUBE_SERVICE_ERROR = 0xCE5,
		BD_YOUTUBE_SERVICE_COMMUNICATION_ERROR = 0xCE6,
		BD_YOUTUBE_USER_DENIED_AUTHORIZATION = 0xCE7,
		BD_YOUTUBE_AUTH_MAX_TIME_EXCEEDED = 0xCE8,
		BD_YOUTUBE_USER_UNAUTHORIZED = 0xCE9,
		BD_YOUTUBE_UPLOAD_MAX_TIME_EXCEEDED = 0xCEA,
		BD_YOUTUBE_DUPLICATE_UPLOAD = 0xCEB,
		BD_YOUTUBE_FAILED_UPLOAD = 0xCEC,
		BD_YOUTUBE_ACCOUNT_ALREADY_REGISTERED = 0xCED,
		BD_YOUTUBE_ACCOUNT_NOT_REGISTERED = 0xCEE,
		BD_YOUTUBE_CONTENT_SERVER_ERROR = 0xCEF,
		BD_YOUTUBE_UPLOAD_DOES_NOT_EXIST = 0xCF0,
		BD_YOUTUBE_NO_LINKED_ACCOUNT = 0xCF1,
		BD_YOUTUBE_DEVELOPER_TAGS_INVALID = 0xCF2,
		BD_FACEBOOK_LITE_AUTH_ATTEMPT_FAILED = 0xD49,
		BD_FACEBOOK_LITE_AUTH_TOKEN_INVALID = 0xD4A,
		BD_FACEBOOK_LITE_PHOTO_DOES_NOT_EXIST = 0xD4B,
		BD_FACEBOOK_LITE_PHOTO_INVALID = 0xD4C,
		BD_FACEBOOK_LITE_PHOTO_ALBUM_FULL = 0xD4D,
		BD_FACEBOOK_LITE_UNAVAILABLE = 0xD4E,
		BD_FACEBOOK_LITE_ERROR = 0xD4F,
		BD_FACEBOOK_LITE_TIMED_OUT = 0xD50,
		BD_FACEBOOK_LITE_DISABLED_FOR_USER = 0xD51,
		BD_FACEBOOK_LITE_ACCOUNT_AMBIGUOUS = 0xD52,
		BD_FACEBOOK_LITE_MAXIMUM_ACCOUNTS_REACHED = 0xD53,
		BD_FACEBOOK_LITE_LOGIN_APPROVALS_ENABLED = 0xD54,
		BD_TWITTER_AUTH_ATTEMPT_FAILED = 0xDAD,
		BD_TWITTER_AUTH_TOKEN_INVALID = 0xDAE,
		BD_TWITTER_UPDATE_LIMIT_REACHED = 0xDAF,
		BD_TWITTER_UNAVAILABLE = 0xDB0,
		BD_TWITTER_ERROR = 0xDB1,
		BD_TWITTER_TIMED_OUT = 0xDB2,
		BD_TWITTER_DISABLED_FOR_USER = 0xDB3,
		BD_TWITTER_ACCOUNT_AMBIGUOUS = 0xDB4,
		BD_TWITTER_MAXIMUM_ACCOUNTS_REACHED = 0xDB5,
		BD_FACEBOOK_AUTH_ATTEMPT_FAILED = 0xE11,
		BD_FACEBOOK_AUTH_TOKEN_INVALID = 0xE12,
		BD_FACEBOOK_PHOTO_DOES_NOT_EXIST = 0xE13,
		BD_FACEBOOK_PHOTO_INVALID = 0xE14,
		BD_FACEBOOK_PHOTO_ALBUM_FULL = 0xE15,
		BD_FACEBOOK_UNAVAILABLE = 0xE16,
		BD_FACEBOOK_ERROR = 0xE17,
		BD_FACEBOOK_TIMED_OUT = 0xE18,
		BD_FACEBOOK_DISABLED_FOR_USER = 0xE19,
		BD_FACEBOOK_ACCOUNT_AMBIGUOUS = 0xE1A,
		BD_FACEBOOK_MAXIMUM_ACCOUNTS_REACHED = 0xE1B,
		BD_FACEBOOK_INVALID_NUM_PICTURES_REQUESTED = 0xE1C,
		BD_FACEBOOK_VIDEO_DOES_NOT_EXIST = 0xE1D,
		BD_FACEBOOK_ACCOUNT_ALREADY_REGISTERED = 0xE1E,
		BD_APNS_INVALID_PAYLOAD = 0xE74,
		BD_MAX_CONSOLEID_LENGTH_EXCEEDED = 0xEE1,
		BD_MAX_WHITELIST_LENGTH_EXCEEDED = 0xEE2,
		BD_USERGROUP_NAME_ALREADY_EXISTS = 0x1770,
		BD_INVALID_USERGROUP_ID = 0x1771,
		BD_USER_ALREADY_IN_USERGROUP = 0x1772,
		BD_USER_NOT_IN_USERGROUP = 0x1773,
		BD_INVALID_USERGROUP_MEMBER_TYPE = 0x1774,
		BD_TOO_MANY_MEMBERS_REQUESTED = 0x1775,
		BD_USERGROUP_NAME_TOO_SHORT = 0x1776,
		BD_RICH_PRESENCE_DATA_TOO_LARGE = 0x1A90,
		BD_RICH_PRESENCE_TOO_MANY_USERS = 0x1A91,
		BD_SUBSCRIPTION_TOO_MANY_USERS = 0x1B58,
		BD_SUBSCRIPTION_TICKET_PARSE_ERROR = 0x1B59,
		BD_CODO_ID_INVALID_DATA = 0x1BBC,
		BD_INVALID_MESSAGE_FORMAT = 0x1BBD,
		BD_TLOG_TOO_MANY_MESSAGES = 0x1BBE,
		BD_MARKETPLACE_ERROR = 0x1F40,
		BD_MARKETPLACE_RESOURCE_NOT_FOUND = 0x1F41,
		BD_MARKETPLACE_INVALID_PARAMETER = 0x1F43,
		BD_MARKETPLACE_RESOURCE_CONFLICT = 0x1F44,
		BD_MARKETPLACE_STORAGE_ERROR = 0x1F45,
		BD_MARKETPLACE_INTEGRITY_ERROR = 0x1F46,
		BD_MARKETPLACE_INSUFFICIENT_FUNDS_ERROR = 0x1F47,
		BD_MARKETPLACE_MMP_SERVICE_ERROR = 0x1F48,
		BD_MARKETPLACE_PRECONDITION_REQUIRED = 0x1F49,
		BD_MARKETPLACE_ITEM_MULTIPLE_PURCHASE_ERROR = 0x1F4A,
		BD_MARKETPLACE_MISSING_REQUIRED_ENTITLEMENT = 0x1F4B,
		BD_MARKETPLACE_VALIDATION_ERROR = 0x1F4C,
		BD_LEAGUE_INVALID_TEAM_SIZE = 0x1FA4,
		BD_LEAGUE_INVALID_TEAM = 0x1FA5,
		BD_LEAGUE_INVALID_SUBDIVISION = 0x1FA6,
		BD_LEAGUE_INVALID_LEAGUE = 0x1FA7,
		BD_LEAGUE_TOO_MANY_RESULTS_REQUESTED = 0x1FA8,
		BD_LEAGUE_METADATA_TOO_LARGE = 0x1FA9,
		BD_LEAGUE_TEAM_ICON_TOO_LARGE = 0x1FAA,
		BD_LEAGUE_TEAM_NAME_TOO_LONG = 0x1FAB,
		BD_LEAGUE_ARRAY_SIZE_MISMATCH = 0x1FAC,
		BD_LEAGUE_SUBDIVISION_MISMATCH = 0x2008,
		BD_LEAGUE_INVALID_WRITE_TYPE = 0x2009,
		BD_LEAGUE_INVALID_STATS_DATA = 0x200A,
		BD_LEAGUE_SUBDIVISION_UNRANKED = 0x200B,
		BD_LEAGUE_CROSS_TEAM_STATS_WRITE_PREVENTED = 0x200C,
		BD_LEAGUE_INVALID_STATS_SEASON = 0x200D,
		BD_COMMERCE_ERROR = 0x206C,
		BD_COMMERCE_RESOURCE_NOT_FOUND = 0x206D,
		BD_COMMERCE_STORAGE_INVALID_PARAMETER = 0x206E,
		BD_COMMERCE_APPLICATION_INVALID_PARAMETER = 0x206F,
		BD_COMMERCE_RESOURCE_CONFLICT = 0x2070,
		BD_COMMERCE_STORAGE_ERROR = 0x2071,
		BD_COMMERCE_INTEGRITY_ERROR = 0x2072,
		BD_COMMERCE_MMP_SERVICE_ERROR = 0x2073,
		BD_COMMERCE_PERMISSION_DENIED = 0x2074,
		BD_COMMERCE_INSUFFICIENT_FUNDS_ERROR = 0x2075,
		BD_COMMERCE_UNKNOWN_CURRENCY = 0x2076,
		BD_COMMERCE_INVALID_RECEIPT = 0x2077,
		BD_COMMERCE_RECEIPT_USED = 0x2078,
		BD_COMMERCE_TRANSACTION_ALREADY_APPLIED = 0x2079,
		BD_COMMERCE_INVALID_CURRENCY_TYPE = 0x207A,
		BD_GMSG_INVALID_CATEGORY_ID = 0x27D8,
		BD_GMSG_CATEGORY_MEMBERSHIPS_LIMIT = 0x27D9,
		BD_GMSG_NONMEMBER_POST_DISALLOWED = 0x27DA,
		BD_GMSG_CATEGORY_DISALLOWS_CLIENT_TYPE = 0x27DB,
		BD_GMSG_PAYLOAD_TOO_BIG = 0x27DC,
		BD_GMSG_MEMBER_POST_DISALLOWED = 0x27DD,
		BD_GMSG_OVERLOADED = 0x27DE,
		BD_GMSG_USER_PERCATEGORY_POST_RATE_EXCEEDED = 0x27DF,
		BD_GMSG_USER_GLOBAL_POST_RATE_EXCEEDED = 0x27E0,
		BD_GMSG_GROUP_POST_RATE_EXCEEDED = 0x27E1,
		BD_MAX_ERROR_CODE = 0x27E2,
	};

	struct DObjAnimMat
	{
		vec4_t quat;
		vec3_t trans;
		float transWeight;
	};

	struct XSurfaceVertexInfo
	{
		__int16 vertCount[4];
		unsigned __int16 *vertsBlend;
		float *tensionData;
	};

	union GfxColor
	{
		unsigned int packed;
		char array[4];
	};

	union PackedTexCoords
	{
		unsigned int packed;
		struct TexCoords
		{
			unsigned short texX;
			unsigned short texY;
		};
	};

	union PackedUnitVec
	{
		unsigned int packed;
		char array[4];
	};

	struct GfxPackedVertex
	{
		vec3_t xyz;
		float binormalSign;
		GfxColor color;
		PackedTexCoords texCoord;
		PackedUnitVec normal;
		PackedUnitVec tangent;
	};

	struct XSurfaceCollisionAabb
	{
		unsigned __int16 mins[3];
		unsigned __int16 maxs[3];
	};

	struct XSurfaceCollisionNode
	{
		XSurfaceCollisionAabb aabb;
		unsigned __int16 childBeginIndex;
		unsigned __int16 childCount;
	};

	struct XSurfaceCollisionLeaf
	{
		unsigned __int16 triangleBeginIndex;
	};

	struct XSurfaceCollisionTree
	{
		vec3_t trans;
		vec3_t scale;
		unsigned int nodeCount;
		XSurfaceCollisionNode *nodes;
		unsigned int leafCount;
		XSurfaceCollisionLeaf *leafs;
	};

	struct XRigidVertList
	{
		unsigned __int16 boneOffset;
		unsigned __int16 vertCount;
		unsigned __int16 triOffset;
		unsigned __int16 triCount;
		XSurfaceCollisionTree *collisionTree;
	};

	struct __declspec(align(16)) XSurface
	{
		char tileMode;
		char vertListCount;
		unsigned __int16 flags;
		unsigned __int16 vertCount;
		unsigned __int16 triCount;
		unsigned __int16 baseVertIndex;
		unsigned __int16 *triIndices;
		XSurfaceVertexInfo vertInfo;
		GfxPackedVertex *verts0;
		ID3D11Buffer *vb0;
		XRigidVertList *vertList;
		ID3D11Buffer *indexBuffer;
		int partBits[5];
	};

	struct GfxDrawSurfFields
	{
		__int64 _bf0;
	};

	union GfxDrawSurf
	{
		GfxDrawSurfFields fields;
		unsigned __int64 packed;
	};

	struct MaterialInfo
	{
		const char *name;
		unsigned int gameFlags;
		char pad;
		char sortKey;
		char textureAtlasRowCount;
		char textureAtlasColumnCount;
		GfxDrawSurf drawSurf;
		unsigned int surfaceTypeBits;
		unsigned int layeredSurfaceTypes;
		unsigned __int16 hashIndex;
		int surfaceFlags;
		int contents;
	};

	struct MaterialStreamRouting
	{
		char source;
		char dest;
	};

	struct MaterialVertexStreamRouting
	{
		MaterialStreamRouting data[16];
		ID3D11InputLayout *decl[20];
	};

	struct MaterialVertexDeclaration
	{
		char streamCount;
		bool hasOptionalSource;
		bool isLoaded;
		MaterialVertexStreamRouting routing;
	};

	struct GfxVertexShaderLoadDef
	{
		char *program;
		unsigned int programSize;
	};

	struct MaterialVertexShaderProgram
	{
		ID3D11VertexShader *vs;
		GfxVertexShaderLoadDef loadDef;
	};

	struct MaterialVertexShader
	{
		const char *name;
		MaterialVertexShaderProgram prog;
	};

	struct GfxPixelShaderLoadDef
	{
		char *program;
		unsigned int programSize;
	};

	struct MaterialPixelShaderProgram
	{
		ID3D11PixelShader *ps;
		GfxPixelShaderLoadDef loadDef;
	};

	struct MaterialPixelShader
	{
		const char *name;
		MaterialPixelShaderProgram prog;
	};

	union MaterialArgumentLocation
	{
		unsigned __int16 offset;
		char samplerIndex;
	};

	struct MaterialArgumentCodeConst
	{
		unsigned __int16 index;
		char firstRow;
		char rowCount;
	};

	union MaterialArgumentDef
	{
		const float *literalConst;
		MaterialArgumentCodeConst codeConst;
		unsigned int codeSampler;
		unsigned int nameHash;
	};

	struct MaterialShaderArgument
	{
		unsigned __int16 type;
		MaterialArgumentLocation location;
		unsigned __int16 size;
		unsigned __int16 buffer;
		MaterialArgumentDef u;
	};

	struct MaterialPass
	{
		MaterialVertexDeclaration *vertexDecl;
		MaterialVertexShader *vertexShader;
		MaterialPixelShader *pixelShader;
		char perPrimArgCount;
		char perObjArgCount;
		char stableArgCount;
		char customSamplerFlags;
		char precompiledIndex;
		char materialType;
		MaterialShaderArgument *args;
	};

	struct MaterialTechnique
	{
		const char *name;
		unsigned __int16 flags;
		unsigned __int16 passCount;
		MaterialPass passArray[1];
	};

	struct MaterialTechniqueSet
	{
		const char *name;
		char worldVertFormat;
		MaterialTechnique *techniques[36];
	};

	struct GfxImageLoadDef
	{
		char levelCount;
		char flags;
		int format;
		int resourceSize;
		char data[1];
	};

	union GfxTexture
	{
		ID3D11ShaderResourceView *basemap;
		GfxImageLoadDef *loadDef;
	};

	struct Picmip
	{
		char platform[2];
	};

	struct CardMemory
	{
		int platform[2];
	};

	struct GfxStreamedPartInfo
	{
		unsigned int levelCountAndSize;
		unsigned int hash;
		unsigned __int16 width;
		unsigned __int16 height;
		unsigned int offset;
		union
		{
			int size;
			int ipakIndex;
		};
		union
		{
			int adjacentLeft;
			int adjacentRight;
			int compressed;
			int valid;
		};
	};

	struct GfxImage
	{
		GfxTexture texture;
		char mapType;
		char semantic;
		char category;
		bool delayLoadPixels;
		Picmip picmip;
		bool noPicmip;
		char track;
		CardMemory cardMemory;
		unsigned __int16 width;
		unsigned __int16 height;
		unsigned __int16 depth;
		char levelCount;
		char streaming;
		unsigned int baseSize;
		char *pixels;
		GfxStreamedPartInfo streamedParts[1];
		char streamedPartCount;
		unsigned int loadedSize;
		char skippedMipLevels;
		const char *name;
		unsigned int hash;
	};

	struct MaterialTextureDef
	{
		unsigned int nameHash;
		char nameStart;
		char nameEnd;
		char samplerState;
		char semantic;
		char isMatureContent;
		char pad[3];
		GfxImage *image;
	};

	struct MaterialConstantDef
	{
		unsigned int nameHash;
		char name[12];
		vec4_t literal;
	};

	struct GfxStateBits
	{
		unsigned int loadBits[2];
		ID3D11BlendState *blendState;
		ID3D11DepthStencilState *depthStencilState;
		ID3D11RasterizerState *rasterizerState;
	};

	struct Material
	{
		MaterialInfo info;
		char stateBitsEntry[36];
		char textureCount;
		char constantCount;
		char stateBitsCount;
		char stateFlags;
		char cameraRegion;
		char probeMipBits;
		MaterialTechniqueSet *techniqueSet;
		MaterialTextureDef *textureTable;
		MaterialConstantDef *constantTable;
		GfxStateBits *stateBitsTable;
		Material *thermalMaterial;
	};

	struct XModelLodInfo
	{
		float dist;
		unsigned __int16 numsurfs;
		unsigned __int16 surfIndex;
		int partBits[5];
	};

	struct XModelCollTri_s
	{
		vec4_t plane;
		vec4_t svec;
		vec4_t tvec;
	};

	struct XModelCollSurf_s
	{
		XModelCollTri_s *collTris;
		int numCollTris;
		vec3_t mins;
		vec3_t maxs;
		int boneIdx;
		int contents;
		int surfFlags;
	};

	struct XBoneInfo
	{
		vec3_t bounds[2];
		vec3_t offset;
		float radiusSquared;
		char collmap;
	};

	struct PhysPreset
	{
		const char *name;
		int flags;
		float mass;
		float bounce;
		float friction;
		float bulletForceScale;
		float explosiveForceScale;
		const char *sndAliasPrefix;
		float piecesSpreadFraction;
		float piecesUpwardVelocity;
		int canFloat;
		float gravityScale;
		vec3_t centerOfMassOffset;
		vec3_t buoyancyBoxMin;
		vec3_t buoyancyBoxMax;
	};

	struct cplane_s
	{
		vec3_t normal;
		float dist;
		char type;
		char signbits;
		char pad[2];
	};

	struct cbrushside_t
	{
		cplane_s *plane;
		int cflags;
		int sflags;
	};

	struct BrushWrapper
	{
		vec3_t mins;
		int contents;
		vec3_t maxs;
		unsigned int numsides;
		cbrushside_t *sides;
		int axial_cflags[2][3];
		int axial_sflags[2][3];
		unsigned int numverts;
		vec3_t *verts;
		cplane_s *planes;
	};

	struct PhysGeomInfo
	{
		BrushWrapper *brush;
		int type;
		vec3_t orientation[3];
		vec3_t offset;
		vec3_t halfLengths;
	};

	struct PhysGeomList
	{
		unsigned int count;
		PhysGeomInfo *geoms;
		int contents;
	};

	struct Collmap
	{
		PhysGeomList *geomList;
	};

	enum ConstraintType
	{
		CONSTRAINT_NONE = 0x0,
		CONSTRAINT_POINT = 0x1,
		CONSTRAINT_DISTANCE = 0x2,
		CONSTRAINT_HINGE = 0x3,
		CONSTRAINT_JOINT = 0x4,
		CONSTRAINT_ACTUATOR = 0x5,
		CONSTRAINT_FAKE_SHAKE = 0x6,
		CONSTRAINT_LAUNCH = 0x7,
		CONSTRAINT_ROPE = 0x8,
		CONSTRAINT_LIGHT = 0x9,
		NUM_CONSTRAINT_TYPES = 0xA,
	};

	enum AttachPointType
	{
		ATTACH_POINT_WORLD = 0x0,
		ATTACH_POINT_DYNENT = 0x1,
		ATTACH_POINT_ENT = 0x2,
		ATTACH_POINT_BONE = 0x3,
	};

	struct PhysConstraint
	{
		unsigned __int16 targetname;
		ConstraintType type;
		AttachPointType attach_point_type1;
		int target_index1;
		unsigned __int16 target_ent1;
		const char *target_bone1;
		AttachPointType attach_point_type2;
		int target_index2;
		unsigned __int16 target_ent2;
		const char *target_bone2;
		vec3_t offset;
		vec3_t pos;
		vec3_t pos2;
		vec3_t dir;
		int flags;
		int timeout;
		int min_health;
		int max_health;
		float distance;
		float damp;
		float power;
		vec3_t scale;
		float spin_scale;
		float minAngle;
		float maxAngle;
		Material *material;
		int constraintHandle;
		int rope_index;
		int centity_num[4];
	};

	struct PhysConstraints
	{
		const char *name;
		unsigned int count;
		PhysConstraint data[16];
	};

	struct XModel
	{
		const char *name;
		char numBones;
		char numRootBones;
		char numsurfs;
		char lodRampType;
		unsigned __int16 *boneNames;
		char *parentList;
		__int16 *quats;
		float *trans;
		char *partClassification;
		DObjAnimMat *baseMat;
		XSurface *surfs;
		Material **materialHandles;
		XModelLodInfo lodInfo[4];
		XModelCollSurf_s *collSurfs;
		int numCollSurfs;
		int contents;
		XBoneInfo *boneInfo;
		float radius;
		vec3_t mins;
		vec3_t maxs;
		__int16 numLods;
		__int16 collLod;
		float *himipInvSqRadii;
		int memUsage;
		int flags;
		bool bad;
		PhysPreset *physPreset;
		char numCollmaps;
		Collmap *collmaps;
		PhysConstraints *physConstraints;
		vec3_t lightingOriginOffset;
		float lightingOriginRange;
	};

	struct XModelPiece
	{
		XModel *model;
		vec3_t offset;
	};

	struct XModelPieces
	{
		const char *name;
		int numpieces;
		XModelPiece *pieces;
	};

	struct FxSpawnDefLooping
	{
		int intervalMsec;
		int count;
	};

	struct FxIntRange
	{
		int base;
		int amplitude;
	};

	struct FxSpawnDefOneShot
	{
		FxIntRange count;
	};

	union FxSpawnDef
	{
		FxSpawnDefLooping looping;
		FxSpawnDefOneShot oneShot;
	};

	struct FxFloatRange
	{
		float base;
		float amplitude;
	};

	struct FxElemAtlas
	{
		char behavior;
		char index;
		char fps;
		char loopCount;
		char colIndexBits;
		char rowIndexBits;
		unsigned __int16 entryCountAndIndexRange;
	};

	struct FxElemVec3Range
	{
		vec3_t base;
		vec3_t amplitude;
	};

	struct FxElemVelStateInFrame
	{
		FxElemVec3Range velocity;
		FxElemVec3Range totalDelta;
	};

	const struct FxElemVelStateSample
	{
		FxElemVelStateInFrame local;
		FxElemVelStateInFrame world;
	};

	struct FxElemVisualState
	{
		char color[4];
		float rotationDelta;
		float rotationTotal;
		float size[2];
		float scale;
	};

	const struct FxElemVisStateSample
	{
		FxElemVisualState base;
		FxElemVisualState amplitude;
	};

	struct FxElemMarkVisuals
	{
		Material *materials[2];
	};

	struct FxEffectDef;

	union FxEffectDefRef
	{
		FxEffectDef *handle;
		const char *name;
	};

	struct GfxLightImage
	{
		GfxImage *image;
		char samplerState;
	};

	struct GfxLightDef
	{
		const char *name;
		GfxLightImage attenuation;
		int lmapLookupStart;
	};

	union FxElemVisuals
	{
		const void *anonymous;
		Material *material;
		XModel *model;
		FxEffectDefRef effectDef;
		const char *soundName;
		GfxLightDef *lightDef;
	};

	union FxElemDefVisuals
	{
		FxElemMarkVisuals *markArray;
		FxElemVisuals *array;
		FxElemVisuals instance;
	};

	struct FxTrailVertex
	{
		vec2_t pos;
		vec2_t normal;
		float texCoord;
	};

	struct FxTrailDef
	{
		int scrollTimeMsec;
		int repeatDist;
		int splitDist;
		int vertCount;
		FxTrailVertex *verts;
		int indCount;
		unsigned __int16 *inds;
	};

	struct FxSpotLightDef
	{
		float fovInnerFraction;
		float startRadius;
		float endRadius;
	};

	union FxElemExtendedDefPtr
	{
		FxTrailDef *localTrailDef;
		FxTrailDef *trailDef;
		FxSpotLightDef *localSpotLightDef;
		FxSpotLightDef *spotLightDef;
		void *unknownDef;
	};

	struct FxBillboardTrim
	{
		float topWidth;
		float bottomWidth;
	};

	union FxElemDefUnion
	{
		FxBillboardTrim billboard;
		FxIntRange cloudDensityRange;
	};

	struct FxElemSpawnSound
	{
		const char *spawnSound;
	};

	const struct FxElemDef
	{
		int flags;
		FxSpawnDef spawn;
		FxFloatRange spawnRange;
		FxFloatRange fadeInRange;
		FxFloatRange fadeOutRange;
		float spawnFrustumCullRadius;
		FxIntRange spawnDelayMsec;
		FxIntRange lifeSpanMsec;
		FxFloatRange spawnOrigin[3];
		FxFloatRange spawnOffsetRadius;
		FxFloatRange spawnOffsetHeight;
		FxFloatRange spawnAngles[3];
		FxFloatRange angularVelocity[3];
		FxFloatRange initialRotation;
		unsigned int rotationAxis;
		FxFloatRange gravity;
		FxFloatRange reflectionFactor;
		FxElemAtlas atlas;
		float windInfluence;
		char elemType;
		char visualCount;
		char velIntervalCount;
		char visStateIntervalCount;
		FxElemVelStateSample *velSamples;
		FxElemVisStateSample *visSamples;
		FxElemDefVisuals visuals;
		vec3_t collMins;
		vec3_t collMaxs;
		FxEffectDefRef effectOnImpact;
		FxEffectDefRef effectOnDeath;
		FxEffectDefRef effectEmitted;
		FxFloatRange emitDist;
		FxFloatRange emitDistVariance;
		FxEffectDefRef effectAttached;
		FxElemExtendedDefPtr extended;
		char sortOrder;
		char lightingFrac;
		char unused[2];
		unsigned __int16 alphaFadeTimeMsec;
		unsigned __int16 maxWindStrength;
		unsigned __int16 spawnIntervalAtMaxWind;
		unsigned __int16 lifespanAtMaxWind;
		FxElemDefUnion u;
		FxElemSpawnSound spawnSound;
		vec2_t billboardPivot;
	};

	const struct FxEffectDef
	{
		const char *name;
		unsigned __int16 flags;
		char efPriority;
		__int16 elemDefCountLooping;
		__int16 elemDefCountOneShot;
		__int16 elemDefCountEmission;
		int totalSize;
		int msecLoopingLife;
		int msecNonLoopingLife;
		FxElemDef *elemDefs;
		vec3_t boundingBoxDim;
		vec3_t boundingBoxCentre;
		float occlusionQueryDepthBias;
		int occlusionQueryFadeIn;
		int occlusionQueryFadeOut;
		FxFloatRange occlusionQueryScaleRange;
	};

	struct DestructibleStage
	{
		unsigned __int16 showBone;
		float breakHealth;
		float maxTime;
		unsigned int flags;
		FxEffectDef *breakEffect;
		const char *breakSound;
		const char *breakNotify;
		const char *loopSound;
		XModel *spawnModel[3];
		PhysPreset *physPreset;
	};

	struct DestructiblePiece
	{
		DestructibleStage stages[5];
		char parentPiece;
		float parentDamagePercent;
		float bulletDamageScale;
		float explosiveDamageScale;
		float meleeDamageScale;
		float impactDamageScale;
		float entityDamageTransfer;
		PhysConstraints *physConstraints;
		int health;
		const char *damageSound;
		FxEffectDef *burnEffect;
		const char *burnSound;
		unsigned __int16 enableLabel;
		int hideBones[5];
	};

	struct DestructibleDef
	{
		const char *name;
		XModel *model;
		XModel *pristineModel;
		int numPieces;
		DestructiblePiece *pieces;
		int clientOnly;
	};

	union XAnimIndices
	{
		char *_1;
		unsigned __int16 *_2;
		void *data;
	};

	struct XAnimNotifyInfo
	{
		unsigned __int16 name;
		float time;
	};

	union XAnimDynamicFrames
	{
		char(*_1)[3];
		unsigned __int16(*_2)[3];
	};

	union XAnimDynamicIndices
	{
		char _1[1];
		unsigned __int16 _2[1];
	};

	struct XAnimPartTransFrames
	{
		vec3_t mins;
		vec3_t size;
		XAnimDynamicFrames frames;
		XAnimDynamicIndices indices;
	};

	union XAnimPartTransData
	{
		XAnimPartTransFrames frames;
		vec3_t frame0;
	};

	struct XAnimPartTrans
	{
		unsigned __int16 size;
		char smallTrans;
		XAnimPartTransData u;
	};

	struct XAnimDeltaPartQuatDataFrames2
	{
		__int16(*frames)[2];
		XAnimDynamicIndices indices;
	};

	union XAnimDeltaPartQuatData2
	{
		XAnimDeltaPartQuatDataFrames2 frames;
		__int16 frame0[2];
	};

	struct XAnimDeltaPartQuat2
	{
		unsigned __int16 size;
		XAnimDeltaPartQuatData2 u;
	};

	struct XAnimDeltaPartQuatDataFrames
	{
		__int16(*frames)[4];
		XAnimDynamicIndices indices;
	};

	union XAnimDeltaPartQuatData
	{
		XAnimDeltaPartQuatDataFrames frames;
		__int16 frame0[4];
	};

	struct XAnimDeltaPartQuat
	{
		unsigned __int16 size;
		XAnimDeltaPartQuatData u;
	};

	struct XAnimDeltaPart
	{
		XAnimPartTrans *trans;
		XAnimDeltaPartQuat2 *quat2;
		XAnimDeltaPartQuat *quat;
	};

	struct XAnimParts
	{
		const char *name;
		unsigned __int16 dataByteCount;
		unsigned __int16 dataShortCount;
		unsigned __int16 dataIntCount;
		unsigned __int16 randomDataByteCount;
		unsigned __int16 randomDataIntCount;
		unsigned __int16 numframes;
		bool bLoop;
		bool bDelta;
		bool bDelta3D;
		bool bLeftHandGripIK;
		unsigned int streamedFileSize;
		char boneCount[10];
		char notifyCount;
		char assetType;
		bool isDefault;
		unsigned int randomDataShortCount;
		unsigned int indexCount;
		float framerate;
		float frequency;
		float primedLength;
		float loopEntryTime;
		unsigned __int16 *names;
		char *dataByte;
		__int16 *dataShort;
		int *dataInt;
		__int16 *randomDataShort;
		char *randomDataByte;
		int *randomDataInt;
		XAnimIndices indices;
		XAnimNotifyInfo *notify;
		XAnimDeltaPart *deltaPart;
	};

	struct XAnimParent
	{
		unsigned __int16 flags;
		unsigned __int16 children;
	};

	struct XAnimEntry
	{
		unsigned __int16 bCreated;
		unsigned __int16 numAnims;
		unsigned __int16 firstParamIxPlusOne;
		unsigned __int16 paramCount;
		unsigned __int16 parent;

		union
		{
			XAnimParts *parts;
			XAnimParent animParent;
		};
	};

	struct XAnimParam
	{
		char strName[16];
		float fValue;
	};

	struct XAnim_s
	{
		const char *debugName;
		unsigned int size;
		unsigned int paramSize;
		XAnimParam *params;
		const char **debugAnimNames;
		bool *wasLoggedIfMissing;
		XAnimEntry entries[1];
	};

	struct XAnimTree_s
	{
		XAnim_s *anims;
		unsigned __int16 children;
		__int16 inst;
	};

	struct SndAlias
	{
		const char *name;
		unsigned int id;
		const char *subtitle;
		const char *secondaryname;
		unsigned int assetId;
		const char *assetFileName;
		unsigned int flags0;
		unsigned int flags1;
		unsigned int duck;
		unsigned int contextType;
		unsigned int contextValue;
		unsigned int stopOnPlay;
		unsigned int futzPatch;
		unsigned __int16 fluxTime;
		unsigned __int16 startDelay;
		unsigned __int16 reverbSend;
		unsigned __int16 centerSend;
		unsigned __int16 volMin;
		unsigned __int16 volMax;
		unsigned __int16 pitchMin;
		unsigned __int16 pitchMax;
		unsigned __int16 distMin;
		unsigned __int16 distMax;
		unsigned __int16 distReverbMax;
		unsigned __int16 envelopMin;
		unsigned __int16 envelopMax;
		unsigned __int16 envelopPercentage;
		__int16 fadeIn;
		__int16 fadeOut;
		__int16 dopplerScale;
		char minPriorityThreshold;
		char maxPriorityThreshold;
		char probability;
		char occlusionLevel;
		char minPriority;
		char maxPriority;
		char pan;
		char limitCount;
		char entityLimitCount;
		char duckGroup;
	};

	struct SndAliasList
	{
		const char *name;
		unsigned int id;
		SndAlias *head;
		int count;
		int sequence;
	};

	struct SndIndexEntry
	{
		unsigned __int16 value;
		unsigned __int16 next;
	};

	struct SndRadverb
	{
		char name[32];
		unsigned int id;
		float smoothing;
		float earlyTime;
		float lateTime;
		float earlyGain;
		float lateGain;
		float returnGain;
		float earlyLpf;
		float lateLpf;
		float inputLpf;
		float dampLpf;
		float wallReflect;
		float dryGain;
		float earlySize;
		float lateSize;
		float diffusion;
		float returnHighpass;
	};

	struct SndDuck
	{
		char name[32];
		unsigned int id;
		float fadeIn;
		float fadeOut;
		float startDelay;
		float distance;
		float length;
		unsigned int fadeInCurve;
		unsigned int fadeOutCurve;
		float *attenuation;
		float *filter;
		int updateWhilePaused;
	};

	struct SndAssetBankHeader
	{
		unsigned int magic;
		unsigned int version;
		unsigned int entrySize;
		unsigned int checksumSize;
		unsigned int dependencySize;
		unsigned int entryCount;
		unsigned int dependencyCount;
		unsigned int pad32;
		__int64 fileSize;
		__int64 entryOffset;
		__int64 checksumOffset;
		char checksumChecksum[16];
		char dependencies[512];
		char padding[1464];
	};

#pragma pack(push, 1)
	struct SndRuntimeAssetBank
	{
		const char *zone;
		const char *language;
		int fileHandle;
		SndAssetBankHeader header;
		unsigned int entryOffset;
		char linkTimeChecksum[16];
		char filename[256];
		bool indicesLoaded;
		bool indicesAllocated;
	};
#pragma pack(pop)

	struct SndAssetBankEntry
	{
		unsigned int id;
		unsigned int size;
		unsigned int offset;
		unsigned int frameCount;
		char frameRateIndex;
		char channelCount;
		char looping;
		char format;
	};

	struct SndLoadedAssets
	{
		const char *zone;
		const char *language;
		unsigned int loadedCount;
		unsigned int entryCount;
		SndAssetBankEntry *entries;
		unsigned int dataSize;
		char *data;
	};

	struct SndDialogScriptIdLookup
	{
		unsigned int scriptId;
		unsigned int aliasId;
	};

	enum SndBankState
	{
		SND_BANK_STATE_NEW = 0x0,
		SND_BANK_STATE_STREAM_HEADER = 0x1,
		SND_BANK_STATE_STREAM_TOC = 0x2,
		SND_BANK_STATE_LOADED_HEADER = 0x3,
		SND_BANK_STATE_LOADED_TOC = 0x4,
		SND_BANK_STATE_LOADED_ASSET_WAIT = 0x5,
		SND_BANK_STATE_LOADED_ASSETS = 0x6,
		SND_BANK_STATE_READY_TO_USE = 0x7,
		SND_BANK_STATE_ERROR = 0x8,
	};

	struct SndBank
	{
		const char *name;
		unsigned int aliasCount;
		SndAliasList *alias;
		SndIndexEntry *aliasIndex;
		unsigned int radverbCount;
		SndRadverb *radverbs;
		unsigned int duckCount;
		SndDuck *ducks;
		SndRuntimeAssetBank streamAssetBank;
		SndRuntimeAssetBank loadAssetBank;
		SndLoadedAssets loadedAssets;
		unsigned int scriptIdLookupCount;
		SndDialogScriptIdLookup *scriptIdLookups;
		SndBankState state;
		int streamRequestId;
		bool pendingIo;
		bool ioError;
		bool runtimeAssetLoad;
	};

	struct SndPatch
	{
		char *name;
		unsigned int elementCount;
		unsigned int *elements;
	};

	struct ClipMaterial
	{
		const char *name;
		int surfaceFlags;
		int contentFlags;
	};

	struct cLeafBrushNodeLeaf_t
	{
		unsigned __int16 *brushes;
	};

	struct cLeafBrushNodeChildren_t
	{
		float dist;
		float range;
		unsigned __int16 childOffset[2];
	};

	union cLeafBrushNodeData_t
	{
		cLeafBrushNodeLeaf_t leaf;
		cLeafBrushNodeChildren_t children;
	};

	struct cLeafBrushNode_s
	{
		char axis;
		__int16 leafBrushCount;
		int contents;
		cLeafBrushNodeData_t data;
	};

	struct __declspec(align(8)) cbrush_t
	{
		vec3_t mins;
		int contents;
		vec3_t maxs;
		unsigned int numsides;
		cbrushside_t *sides;
		int axial_cflags[2][3];
		int axial_sflags[2][3];
		unsigned int numverts;
		vec3_t *verts;
	};

	struct Bounds
	{
		vec3_t midPoint;
		vec3_t halfSize;
	};

	struct ClipInfo
	{
		int planeCount;
		cplane_s *planes;
		unsigned int numMaterials;
		ClipMaterial *materials;
		unsigned int numBrushSides;
		cbrushside_t *brushsides;
		unsigned int leafbrushNodesCount;
		cLeafBrushNode_s *leafbrushNodes;
		unsigned int numLeafBrushes;
		unsigned __int16 *leafbrushes;
		unsigned int numBrushVerts;
		vec3_t *brushVerts;
		unsigned int nuinds;
		unsigned __int16 *uinds;
		unsigned __int16 numBrushes;
		cbrush_t *brushes;
		Bounds *brushBounds;
		int *brushContents;
	};

	struct cStaticModelWritable
	{
		unsigned __int16 nextModelInWorldSector;
	};

	struct cStaticModel_s
	{
		cStaticModelWritable writable;
		XModel *xmodel;
		int contents;
		vec3_t origin;
		vec3_t invScaledAxis[3];
		vec3_t absmin;
		vec3_t absmax;
	};

	struct cNode_t
	{
		cplane_s *plane;
		__int16 children[2];
	};

	struct cLeaf_s
	{
		unsigned __int16 firstCollAabbIndex;
		unsigned __int16 collAabbCount;
		int brushContents;
		int terrainContents;
		vec3_t mins;
		vec3_t maxs;
		int leafBrushNode;
		__int16 cluster;
	};

	const struct CollisionPartition
	{
		char triCount;
		int firstTri;
		int nuinds;
		int fuind;
	};

	union CollisionAabbTreeIndex
	{
		int firstChildIndex;
		int partitionIndex;
	};

	struct CollisionAabbTree
	{
		vec3_t origin;
		unsigned __int16 materialIndex;
		unsigned __int16 childCount;
		vec3_t halfSize;
		CollisionAabbTreeIndex u;
	};

	struct cmodel_t
	{
		vec3_t mins;
		vec3_t maxs;
		float radius;
		ClipInfo *info;
		cLeaf_s leaf;
	};

	struct TriggerModel
	{
		int contents;
		unsigned __int16 hullCount;
		unsigned __int16 firstHull;
	};

	struct TriggerHull
	{
		Bounds bounds;
		int contents;
		unsigned __int16 slabCount;
		unsigned __int16 firstSlab;
	};

	struct TriggerSlab
	{
		vec3_t dir;
		float midPoint;
		float halfSize;
	};

	struct MapTriggers
	{
		unsigned int count;
		TriggerModel *models;
		unsigned int hullCount;
		TriggerHull *hulls;
		unsigned int slabCount;
		TriggerSlab *slabs;
	};

	struct MapEnts
	{
		const char *name;
		char *entityString;
		int numEntityChars;
		MapTriggers trigger;
	};

	enum DynEntityType
	{
		DYNENT_TYPE_INVALID = 0x0,
		DYNENT_TYPE_CLUTTER = 0x1,
		DYNENT_TYPE_DESTRUCT = 0x2,
		DYNENT_TYPE_COUNT = 0x3,
	};

	struct GfxPlacement
	{
		vec4_t quat;
		vec3_t origin;
	};

	struct DynEntityDef
	{
		DynEntityType type;
		GfxPlacement pose;
		XModel *xModel;
		XModel *destroyedxModel;
		unsigned __int16 brushModel;
		unsigned __int16 physicsBrushModel;
		FxEffectDef *destroyFx;
		unsigned int destroySound;
		XModelPieces *destroyPieces;
		PhysPreset *physPreset;
		__int16 physConstraints[4];
		int health;
		int flags;
		int contents;
		unsigned __int16 targetname;
		unsigned __int16 target;
	};

	struct DynEntityPose
	{
		GfxPlacement pose;
		float radius;
	};

	struct DynEntityClient
	{
		int physObjId;
		unsigned __int16 flags;
		unsigned __int16 lightingHandle;
		int health;
		unsigned __int16 burnTime;
		unsigned __int16 fadeTime;
		int physicsStartTime;
	};

	struct DynEntityServer
	{
		unsigned __int16 flags;
		int health;
	};

	struct DynEntityColl
	{
		unsigned __int16 sector;
		unsigned __int16 nextEntInSector;
		vec3_t linkMins;
		vec3_t linkMaxs;
		int contents;
	};

	struct par_t
	{
		vec3_t p;
		vec3_t p0;
		vec3_t p_prev;
		int flags;
	};

	enum rope_constraint_e
	{
		ROPE_PAIR_CONSTRAINT = 0x0,
		ROPE_WORLD_CONSTRAINT = 0x1,
		ROPE_DENTITY_CONSTRAINT = 0x2,
		ROPE_CENTITY_CONSTRAINT = 0x3,
	};

	struct constraint_t
	{
		vec3_t p;
		rope_constraint_e type;
		int entity_index;
		int bone_name_hash;
		char pi1;
		char pi2;
	};

	struct rope_frame_verts_t
	{
		int num_verts;
		vec3_t v[50];
	};

	struct rope_client_verts_t
	{
		rope_frame_verts_t frame_verts[2];
		unsigned int frame_index;
	};

	struct rope_t
	{
		par_t m_particles[25];
		constraint_t m_constraints[30];
		int m_entity_anchors[3];
		int m_num_particles;
		int m_num_constraints;
		int m_num_entity_anchors;
		int m_num_draw_verts;
		rope_client_verts_t m_client_verts;
		vec3_t m_min;
		vec3_t m_max;
		vec3_t m_start;
		vec3_t m_end;
		int m_in_use;
		int m_visible;
		int m_dist_constraint;
		int m_flags;
		Material *m_material;
		float m_seglen;
		float m_length;
		float m_width;
		float m_scale;
		float m_force_scale;
		int m_health;
		int m_frame;
		int m_stable_count;
		int m_static_rope;
		unsigned __int16 m_lightingHandle;
	};

	struct clipMap_t
	{
		const char *name;
		int isInUse;
		ClipInfo info;
		ClipInfo *pInfo;
		unsigned int numStaticModels;
		cStaticModel_s *staticModelList;
		unsigned int numNodes;
		cNode_t *nodes;
		unsigned int numLeafs;
		cLeaf_s *leafs;
		unsigned int vertCount;
		vec3_t *verts;
		int triCount;
		unsigned __int16 *triIndices;
		char *triEdgeIsWalkable;
		int partitionCount;
		CollisionPartition *partitions;
		int aabbTreeCount;
		CollisionAabbTree *aabbTrees;
		unsigned int numSubModels;
		cmodel_t *cmodels;
		int numClusters;
		int clusterBytes;
		char *visibility;
		int vised;
		MapEnts *mapEnts;
		cbrush_t *box_brush;
		cmodel_t box_model;
		unsigned __int16 originalDynEntCount;
		unsigned __int16 dynEntCount[4];
		DynEntityDef *dynEntDefList[2];
		DynEntityPose *dynEntPoseList[2];
		DynEntityClient *dynEntClientList[2];
		DynEntityServer *dynEntServerList[2];
		DynEntityColl *dynEntCollList[4];
		int num_constraints;
		PhysConstraint *constraints;
		int max_ropes;
		rope_t *ropes;
		unsigned int checksum;
	};

	struct ComPrimaryLight
	{
		char type;
		char canUseShadowMap;
		char exponent;
		char priority;
		__int16 cullDist;
		char useCookie;
		char shadowmapVolume;
		vec3_t color;
		vec3_t dir;
		vec3_t origin;
		float radius;
		float cosHalfFovOuter;
		float cosHalfFovInner;
		float cosHalfFovExpanded;
		float rotationLimit;
		float translationLimit;
		float mipDistance;
		float dAttenuation;
		float roundness;
		vec4_t diffuseColor;
		vec4_t falloff;
		vec4_t angle;
		vec4_t aAbB;
		vec4_t cookieControl0;
		vec4_t cookieControl1;
		vec4_t cookieControl2;
		const char *defName;
	};

	struct ComWorld
	{
		const char *name;
		int isInUse;
		unsigned int primaryLightCount;
		ComPrimaryLight *primaryLights;
	};

	struct cmd_function_s
	{
		cmd_function_s *next;
		const char *name;
		const char *autoCompleteDir;
		const char *autoCompleteExt;
		void(__cdecl *function)();
	};

	enum nodeType
	{
		NODE_BADNODE = 0x0,
		NODE_PATHNODE = 0x1,
		NODE_COVER_STAND = 0x2,
		NODE_COVER_CROUCH = 0x3,
		NODE_COVER_CROUCH_WINDOW = 0x4,
		NODE_COVER_PRONE = 0x5,
		NODE_COVER_RIGHT = 0x6,
		NODE_COVER_LEFT = 0x7,
		NODE_COVER_PILLAR = 0x8,
		NODE_AMBUSH = 0x9,
		NODE_EXPOSED = 0xA,
		NODE_CONCEALMENT_STAND = 0xB,
		NODE_CONCEALMENT_CROUCH = 0xC,
		NODE_CONCEALMENT_PRONE = 0xD,
		NODE_REACQUIRE = 0xE,
		NODE_BALCONY = 0xF,
		NODE_SCRIPTED = 0x10,
		NODE_NEGOTIATION_BEGIN = 0x11,
		NODE_NEGOTIATION_END = 0x12,
		NODE_TURRET = 0x13,
		NODE_GUARD = 0x14,
		NODE_NUMTYPES = 0x15,
		NODE_DONTLINK = 0x15,
	};

	struct pathlink_s
	{
		float fDist;
		unsigned __int16 nodeNum;
		char disconnectCount;
		char negotiationLink;
		char flags;
		char ubBadPlaceCount[5];
	};

	struct pathnode_constant_t
	{
		nodeType type;
		int spawnflags;
		unsigned __int16 targetname;
		unsigned __int16 script_linkName;
		unsigned __int16 script_noteworthy;
		unsigned __int16 target;
		unsigned __int16 animscript;
		int animscriptfunc;
		vec3_t vOrigin;
		float fAngle;
		vec2_t forward;
		float fRadius;
		float minUseDistSq;
		__int16 wOverlapNode[2];
		unsigned __int16 totalLinkCount;
		pathlink_s *Links;
	};

	struct SentientHandle
	{
		unsigned __int16 number;
		unsigned __int16 infoIndex;
	};

	struct pathnode_dynamic_t
	{
		SentientHandle pOwner;
		int iFreeTime;
		int iValidTime[3];
		int dangerousNodeTime[3];
		int inPlayerLOSTime;
		__int16 wLinkCount;
		__int16 wOverlapCount;
		__int16 turretEntNumber;
		__int16 userCount;
		bool hasBadPlaceLink;
	};

	struct pathnode_t;

	struct pathnode_transient_t
	{
		int iSearchFrame;
		pathnode_t *pNextOpen;
		pathnode_t *pPrevOpen;
		pathnode_t *pParent;
		float fCost;
		float fHeuristic;
		union
		{
			float nodeCost;
			int linkIndex;
		};
	};

	struct pathnode_t
	{
		pathnode_constant_t constant;
		pathnode_dynamic_t dynamic;
		pathnode_transient_t transient;
	};

	struct pathbasenode_t
	{
		vec3_t vOrigin;
		unsigned int type;
	};

	struct pathnode_tree_nodes_t
	{
		int nodeCount;
		unsigned __int16 *nodes;
	};

	struct pathnode_tree_t;

	union pathnode_tree_info_t
	{
		pathnode_tree_t *child[2];
		pathnode_tree_nodes_t s;
	};

	struct pathnode_tree_t
	{
		int axis;
		float dist;
		pathnode_tree_info_t u;
	};

	typedef pathnode_tree_t *pathnode_tree_ptr;

	struct PathData
	{
		unsigned int nodeCount;
		unsigned int originalNodeCount;
		pathnode_t *nodes;
		pathbasenode_t *basenodes;
		int visBytes;
		char *pathVis;
		int smoothBytes;
		char *smoothCache;
		int nodeTreeCount;
		pathnode_tree_t *nodeTree;
	};

	struct GameWorldSp
	{
		const char *name;
		PathData path;
	};

	struct GameWorldMp
	{
		const char *name;
		PathData path;
	};

	struct GfxStreamingAabbTree
	{
		vec4_t mins;
		vec4_t maxs;
		float maxStreamingDistance;
		unsigned __int16 firstItem;
		unsigned __int16 itemCount;
		unsigned __int16 firstChild;
		unsigned __int16 childCount;
		unsigned __int16 smodelCount;
		unsigned __int16 surfaceCount;
	};

	struct GfxWorldStreamInfo
	{
		int aabbTreeCount;
		GfxStreamingAabbTree *aabbTrees;
		int leafRefCount;
		int *leafRefs;
	};

	struct GfxWorldSun
	{
		unsigned int control;
		vec3_t angles;
		vec4_t ambientColor;
		vec4_t sunCd;
		vec4_t sunCs;
		vec4_t skyColor;
		float exposure;
	};

	struct GfxWorldFog
	{
		float baseDist;
		float halfDist;
		float baseHeight;
		float halfHeight;
		float sunFogPitch;
		float sunFogYaw;
		float sunFogInner;
		float sunFogOuter;
		vec3_t fogColor;
		float fogOpacity;
		vec3_t sunFogColor;
		float sunFogOpacity;
	};

	struct SunLightParseParams
	{
		char name[64];
		GfxWorldSun initWorldSun[1];
		float fogTransitionTime;
		GfxWorldFog initWorldFog[1];
	};

	struct __declspec(align(16)) GfxLight
	{
		char type;
		char canUseShadowMap;
		char shadowmapVolume;
		__int16 cullDist;
		vec3_t color;
		vec3_t dir;
		vec3_t origin;
		float radius;
		float cosHalfFovOuter;
		float cosHalfFovInner;
		int exponent;
		unsigned int spotShadowIndex;
		float dAttenuation;
		float roundness;
		vec3_t angles;
		float spotShadowHiDistance;
		vec4_t diffuseColor;
		vec4_t shadowColor;
		vec4_t falloff;
		vec4_t aAbB;
		vec4_t cookieControl0;
		vec4_t cookieControl1;
		vec4_t cookieControl2;
		__declspec(align(16)) float44 viewMatrix;
		float44 projMatrix;
		GfxLightDef *def;
	};

	struct GfxLightCorona
	{
		vec3_t origin;
		float radius;
		vec3_t color;
		float intensity;
	};

	struct GfxShadowMapVolume
	{
		unsigned int control;
		unsigned int padding1;
		unsigned int padding2;
		unsigned int padding3;
	};

	struct GfxVolumePlane
	{
		vec4_t plane;
	};

	struct GfxExposureVolume
	{
		unsigned int control;
		float exposure;
		float luminanceIncreaseScale;
		float luminanceDecreaseScale;
		float featherRange;
		float featherAdjust;
	};

	struct GfxWorldFogVolume
	{
		vec3_t mins;
		unsigned int control;
		vec3_t maxs;
		float fogTransitionTime;
		unsigned int controlEx;
		GfxWorldFog volumeWorldFog[1];
	};

	struct GfxWorldFogModifierVolume
	{
		unsigned int control;
		unsigned __int16 minX;
		unsigned __int16 minY;
		unsigned __int16 minZ;
		unsigned __int16 maxX;
		unsigned __int16 maxY;
		unsigned __int16 maxZ;
		unsigned int controlEx;
		float transitionTime;
		float depthScale;
		float heightScale;
		vec4_t colorAdjust;
	};

	struct GfxLutVolume
	{
		vec3_t mins;
		unsigned int control;
		vec3_t maxs;
		float lutTransitionTime;
		unsigned int lutIndex;
	};

	struct GfxSkyDynamicIntensity
	{
		float angle0;
		float angle1;
		float factor0;
		float factor1;
	};

	struct GfxWorldDpvsPlanes
	{
		int cellCount;
		cplane_s *planes;
		unsigned __int16 *nodes;
		unsigned int *sceneEntCellBits;
	};

	struct GfxAabbTree
	{
		vec3_t mins;
		vec3_t maxs;
		unsigned __int16 childCount;
		unsigned __int16 surfaceCount;
		unsigned __int16 startSurfIndex;
		unsigned __int16 smodelIndexCount;
		unsigned __int16 *smodelIndexes;
		int childrenOffset;
	};

	struct GfxPortal;

	struct GfxPortalWritable
	{
		bool isQueued;
		bool isAncestor;
		char recursionDepth;
		char hullPointCount;
		vec2_t *hullPoints;
		GfxPortal *queuedParent;
	};

	struct DpvsPlane
	{
		vec4_t coeffs;
		char side[3];
		char pad;
	};

	struct GfxCell;

	struct GfxPortal
	{
		GfxPortalWritable writable;
		DpvsPlane plane;
		GfxCell *cell;
		vec3_t *vertices;
		char vertexCount;
		vec3_t hullAxis[2];
		vec3_t bounds[2];
	};

	struct GfxCell
	{
		vec3_t mins;
		vec3_t maxs;
		int aabbTreeCount;
		GfxAabbTree *aabbTree;
		int portalCount;
		GfxPortal *portals;
		char reflectionProbeCount;
		char *reflectionProbes;
	};

	struct GfxLightingSH
	{
		vec4_t V0;
		vec4_t V1;
		vec4_t V2;
	};

	struct GfxReflectionProbeVolumeData
	{
		vec4_t volumePlanes[6];
	};

	struct GfxReflectionProbe
	{
		vec3_t origin;
		GfxLightingSH lightingSH;
		GfxImage *reflectionImage;
		GfxReflectionProbeVolumeData *probeVolumes;
		unsigned int probeVolumeCount;
		float mipLodBias;
	};

	struct GfxLightmapArray
	{
		GfxImage *primary;
		GfxImage *secondary;
	};

	struct GfxWorldVertexData0
	{
		char *data;
		ID3D11Buffer *vb;
	};

	struct GfxWorldVertexData1
	{
		char *data;
		ID3D11Buffer *vb;
	};

	struct GfxWorldDraw
	{
		unsigned int reflectionProbeCount;
		GfxReflectionProbe *reflectionProbes;
		GfxTexture *reflectionProbeTextures;
		int lightmapCount;
		GfxLightmapArray *lightmaps;
		GfxTexture *lightmapPrimaryTextures;
		GfxTexture *lightmapSecondaryTextures;
		unsigned int vertexCount;
		unsigned int vertexDataSize0;
		GfxWorldVertexData0 vd0;
		unsigned int vertexDataSize1;
		GfxWorldVertexData1 vd1;
		int indexCount;
		unsigned __int16 *indices;
		ID3D11Buffer *indexBuffer;
	};

	struct GfxLightGridEntry
	{
		unsigned __int16 colorsIndex;
		char primaryLightIndex;
		char visibility;
	};

	struct GfxCompressedLightGridColors
	{
		char rgb[56][3];
	};

	struct GfxCompressedLightGridCoeffs
	{
		unsigned __int16 coeffs[9][3];
	};

	struct GfxSkyGridVolume
	{
		vec3_t mins;
		vec3_t maxs;
		vec3_t lightingOrigin;
		unsigned __int16 colorsIndex;
		char primaryLightIndex;
		char visibility;
	};

	struct GfxLightGrid
	{
		unsigned int sunPrimaryLightIndex;
		unsigned __int16 mins[3];
		unsigned __int16 maxs[3];
		float offset;
		unsigned int rowAxis;
		unsigned int colAxis;
		unsigned __int16 *rowDataStart;
		unsigned int rawRowDataSize;
		char *rawRowData;
		unsigned int entryCount;
		GfxLightGridEntry *entries;
		unsigned int colorCount;
		GfxCompressedLightGridColors *colors;
		unsigned int coeffCount;
		GfxCompressedLightGridCoeffs *coeffs;
		unsigned int skyGridVolumeCount;
		GfxSkyGridVolume *skyGridVolumes;
	};

	struct GfxBrushModelWritable
	{
		vec3_t mins;
		float padding1;
		vec3_t maxs;
		float padding2;
	};

	struct GfxBrushModel
	{
		GfxBrushModelWritable writable;
		vec3_t bounds[2];
		unsigned int surfaceCount;
		unsigned int startSurfIndex;
	};

	struct MaterialMemory
	{
		Material *material;
		int memory;
	};

	struct sunflare_t
	{
		bool hasValidData;
		Material *spriteMaterial;
		Material *flareMaterial;
		float spriteSize;
		float flareMinSize;
		float flareMinDot;
		float flareMaxSize;
		float flareMaxDot;
		float flareMaxAlpha;
		int flareFadeInTime;
		int flareFadeOutTime;
		float blindMinDot;
		float blindMaxDot;
		float blindMaxDarken;
		int blindFadeInTime;
		int blindFadeOutTime;
		float glareMinDot;
		float glareMaxDot;
		float glareMaxLighten;
		int glareFadeInTime;
		int glareFadeOutTime;
		vec3_t sunFxPosition;
	};

	struct $D5CE1A3EB2B8FD372BC3B42B9754BDC5
	{
		char state;
		char lod;
		unsigned __int16 surfId;
	};

	union XModelDrawInfo
	{
		$D5CE1A3EB2B8FD372BC3B42B9754BDC5 _s0;
		unsigned int packed;
	};

	struct GfxSceneDynModel
	{
		XModelDrawInfo info;
		unsigned __int16 dynEntId;
		char primaryLightIndex;
		char reflectionProbeIndex;
	};

	struct BModelDrawInfo
	{
		unsigned __int16 surfId;
	};

	struct GfxSceneDynBrush
	{
		BModelDrawInfo info;
		unsigned __int16 dynEntId;
	};

	union _m128
	{
		float m128_f32[4];
		unsigned __int64 m128_u64[2];
		char m128_i8[16];
		__int16 m128_i16[8];
		int m128_i32[4];
		__int64 m128_i64[2];
		char m128_u8[16];
		unsigned __int16 m128_u16[8];
		unsigned int m128_u32[4];
	};

	struct vector3
	{
		_m128 x;
		_m128 y;
		_m128 z;
	};

	struct vector4
	{
		vector3 baseclass_0;
		_m128 w;
	};

	union $AE792E9EE4F902DF462622579837C52B
	{
		vector4 mat;
		float disk_mat[16];
	};

	struct SSkinShaders
	{
		char *pixelShaderAlign;
		char *pixelShader;
		char *vertexShader;
		int pixelShaderSize;
		int vertexShaderSize;
	};

	struct half
	{
		unsigned __int16 v;
	};

	struct $EE6D73BC9350C8DA9C34B6E333CC6326
	{
		half x;
		half y;
		half z;
		half w;
	};

	union $2A25B0377388A949989EDF0EF7E0081A
	{
		$EE6D73BC9350C8DA9C34B6E333CC6326 _s0;
		unsigned __int64 v;
	};

	struct half4
	{
		$2A25B0377388A949989EDF0EF7E0081A ___u0;
	};

	struct $E448320BCEA46AD67EC23F7C01651314
	{
		half x;
		half y;
	};

	union $0C92BD51F6FA95F95AEACD505AFB5208
	{
		$E448320BCEA46AD67EC23F7C01651314 _s0;
		unsigned int v;
	};

	struct half2
	{
		$0C92BD51F6FA95F95AEACD505AFB5208 ___u0;
	};

	struct SSkinVert
	{
		half4 pos_bone;
		PackedUnitVec normal;
		half2 uv;
	};

	struct SSkinModel
	{
		int numVerts;
		int numTris;
		SSkinVert *verts;
		unsigned __int16 *tris;
	};

	struct SSkinAnim
	{
		int bones;
		int width;
		int frames;
		float *data;
	};

	struct SSkinInstance
	{
		$AE792E9EE4F902DF462622579837C52B ___u0;
		SSkinShaders *shaders;
		SSkinModel *model;
		SSkinAnim *anim;
		SSkinVert *instVerts;
		float frame;
		int pad1;
		int pad2;
		int pad3;
	};

	struct GfxShadowGeometry
	{
		unsigned __int16 surfaceCount;
		unsigned __int16 smodelCount;
		unsigned __int16 *sortedSurfIndex;
		unsigned __int16 *smodelIndex;
	};

	struct GfxLightRegionAxis
	{
		vec3_t dir;
		float midPoint;
		float halfSize;
	};

	struct GfxLightRegionHull
	{
		float kdopMidPoint[9];
		float kdopHalfSize[9];
		unsigned int axisCount;
		GfxLightRegionAxis *axis;
	};

	struct GfxLightRegion
	{
		unsigned int hullCount;
		GfxLightRegionHull *hulls;
	};

	struct GfxStaticModelInst
	{
		vec3_t mins;
		vec3_t maxs;
		vec3_t lightingOrigin;
	};

	struct srfTriangles_t
	{
		vec3_t mins;
		int vertexDataOffset0;
		vec3_t maxs;
		int vertexDataOffset1;
		int firstVertex;
		float himipRadiusInvSq;
		unsigned __int16 vertexCount;
		unsigned __int16 triCount;
		int baseIndex;
	};

	struct GfxSurface
	{
		srfTriangles_t tris;
		Material *material;
		char lightmapIndex;
		char reflectionProbeIndex;
		char primaryLightIndex;
		char flags;
		vec3_t bounds[2];
	};

	struct GfxPackedPlacement
	{
		vec3_t origin;
		vec3_t axis[3];
		float scale;
	};

	struct GfxLightingSHQuantized
	{
		unsigned __int16 V0[4];
		unsigned __int16 V1[4];
		unsigned __int16 V2[4];
	};

	struct GfxStaticModelLmapVertexInfo
	{
		unsigned int *lmapVertexColors;
		ID3D11Buffer *lmapVertexColorsVB;
		unsigned __int16 numLmapVertexColors;
	};

	struct GfxStaticModelDrawInst
	{
		float cullDist;
		GfxPackedPlacement placement;
		XModel *model;
		int flags;
		float invScaleSq;
		unsigned __int16 lightingHandle;
		unsigned __int16 colorsIndex;
		GfxLightingSHQuantized lightingSH;
		char primaryLightIndex;
		char visibility;
		char reflectionProbeIndex;
		unsigned int smid;
		GfxStaticModelLmapVertexInfo lmapVertexInfo[4];
	};

	struct GfxWorldDpvsStatic
	{
		unsigned int smodelCount;
		unsigned int staticSurfaceCount;
		unsigned int litSurfsBegin;
		unsigned int litSurfsEnd;
		unsigned int litTransSurfsBegin;
		unsigned int litTransSurfsEnd;
		unsigned int emissiveOpaqueSurfsBegin;
		unsigned int emissiveOpaqueSurfsEnd;
		unsigned int emissiveTransSurfsBegin;
		unsigned int emissiveTransSurfsEnd;
		unsigned int smodelVisDataCount;
		unsigned int surfaceVisDataCount;
		char *smodelVisData[3];
		char *surfaceVisData[3];
		char *smodelVisDataCameraSaved;
		char *surfaceVisDataCameraSaved;
		unsigned __int16 *sortedSurfIndex;
		GfxStaticModelInst *smodelInsts;
		GfxSurface *surfaces;
		GfxStaticModelDrawInst *smodelDrawInsts;
		GfxDrawSurf *surfaceMaterials;
		char *surfaceCastsSunShadow;
		char *surfaceCastsShadow;
		char *smodelCastsShadow;
		volatile int usageCount;
	};

	struct GfxWorldDpvsDynamic
	{
		unsigned int dynEntClientWordCount[2];
		unsigned int dynEntClientCount[2];
		unsigned int *dynEntCellBits[2];
		char *dynEntVisData[2][3];
		volatile int usageCount;
	};

	struct GfxWaterBuffer
	{
		unsigned int bufferSize;
		vec4_t *buffer;
	};

	struct Occluder
	{
		unsigned int flags;
		char name[16];
		vec3_t points[4];
	};

	struct GfxOutdoorBounds
	{
		vec3_t bounds[2];
	};

	struct GfxHeroLight
	{
		char type;
		char unused[3];
		vec3_t color;
		vec3_t dir;
		vec3_t origin;
		float radius;
		float cosHalfFovOuter;
		float cosHalfFovInner;
		int exponent;
	};

	struct GfxHeroLightTree
	{
		vec3_t mins;
		vec3_t maxs;
		int leftNode;
		int rightNode;
	};

	struct GfxWorld
	{
		const char *name;
		const char *baseName;
		int planeCount;
		int nodeCount;
		int surfaceCount;
		GfxWorldStreamInfo streamInfo;
		const char *skyBoxModel;
		SunLightParseParams sunParse;
		GfxLight *sunLight;
		unsigned int sunPrimaryLightIndex;
		unsigned int primaryLightCount;
		unsigned int coronaCount;
		GfxLightCorona *coronas;
		unsigned int shadowMapVolumeCount;
		GfxShadowMapVolume *shadowMapVolumes;
		unsigned int shadowMapVolumePlaneCount;
		GfxVolumePlane *shadowMapVolumePlanes;
		unsigned int exposureVolumeCount;
		GfxExposureVolume *exposureVolumes;
		unsigned int exposureVolumePlaneCount;
		GfxVolumePlane *exposureVolumePlanes;
		unsigned int worldFogVolumeCount;
		GfxWorldFogVolume *worldFogVolumes;
		unsigned int worldFogVolumePlaneCount;
		GfxVolumePlane *worldFogVolumePlanes;
		unsigned int worldFogModifierVolumeCount;
		GfxWorldFogModifierVolume *worldFogModifierVolumes;
		unsigned int worldFogModifierVolumePlaneCount;
		GfxVolumePlane *worldFogModifierVolumePlanes;
		unsigned int lutVolumeCount;
		GfxLutVolume *lutVolumes;
		unsigned int lutVolumePlaneCount;
		GfxVolumePlane *lutVolumePlanes;
		GfxSkyDynamicIntensity skyDynIntensity;
		GfxWorldDpvsPlanes dpvsPlanes;
		int cellBitsCount;
		GfxCell *cells;
		GfxWorldDraw draw;
		GfxLightGrid lightGrid;
		int modelCount;
		GfxBrushModel *models;
		vec3_t mins;
		vec3_t maxs;
		unsigned int checksum;
		int materialMemoryCount;
		MaterialMemory *materialMemory;
		sunflare_t sun;
		vec4_t outdoorLookupMatrix[4];
		GfxImage *outdoorImage;
		unsigned int *cellCasterBits;
		GfxSceneDynModel *sceneDynModel;
		GfxSceneDynBrush *sceneDynBrush;
		unsigned int *primaryLightEntityShadowVis;
		unsigned int *primaryLightDynEntShadowVis[2];
		unsigned int numSiegeSkinInsts;
		SSkinInstance *siegeSkinInsts;
		GfxShadowGeometry *shadowGeom;
		GfxLightRegion *lightRegion;
		GfxWorldDpvsStatic dpvs;
		GfxWorldDpvsDynamic dpvsDyn;
		float waterDirection;
		GfxWaterBuffer waterBuffers[2];
		Material *waterMaterial;
		Material *coronaMaterial;
		Material *ropeMaterial;
		Material *lutMaterial;
		unsigned int numOccluders;
		Occluder *occluders;
		unsigned int numOutdoorBounds;
		GfxOutdoorBounds *outdoorBounds;
		unsigned int heroLightCount;
		unsigned int heroLightTreeCount;
		GfxHeroLight *heroLights;
		GfxHeroLightTree *heroLightTree;
		unsigned int lightingFlags;
		int lightingQuality;
	};

	struct Glyph
	{
		unsigned __int16 letter;
		char x0;
		char y0;
		char dx;
		char pixelWidth;
		char pixelHeight;
		float s0;
		float t0;
		float s1;
		float t1;
	};

	struct KerningPairs
	{
		unsigned __int16 wFirst;
		unsigned __int16 wSecond;
		int iKernAmount;
	};

	struct Font_s
	{
		const char *fontName;
		int pixelHeight;
		int isScalingAllowed;
		int glyphCount;
		int kerningPairsCount;
		Material *material;
		Material *glowMaterial;
		Glyph *glyphs;
		KerningPairs *kerningPairs;
	};

	struct FontIconName
	{
		const char *string;
		int hash;
	};

	struct FontIconEntry
	{
		FontIconName fontIconName;
		Material *fontIconMaterialHandle;
		int fontIconSize;
		float xScale;
		float yScale;
	};

	struct FontIconAlias
	{
		int aliasHash;
		int buttonHash;
	};

	struct FontIcon
	{
		const char *name;
		int numEntries;
		int numAliasEntries;
		FontIconEntry *fontIconEntry;
		FontIconAlias *fontIconAlias;
	};

	struct rectDef_s
	{
		float x;
		float y;
		float w;
		float h;
		int horzAlign;
		int vertAlign;
	};

	struct windowDef_t
	{
		const char *name;
		rectDef_s rect;
		rectDef_s rectClient;
		const char *group;
		char style;
		char border;
		char modal;
		char frameSides;
		float frameTexSize;
		float frameSize;
		int ownerDraw;
		int ownerDrawFlags;
		float borderSize;
		int staticFlags;
		int dynamicFlags[1];
		int nextTime;
		vec4_t foreColor;
		vec4_t backColor;
		vec4_t borderColor;
		vec4_t outlineColor;
		float rotation;
		Material *background;
	};

	struct ScriptCondition
	{
		bool fireOnTrue;
		int constructID;
		int blockID;
		ScriptCondition *next;
	};

	enum expDataType
	{
		VAL_INT = 0x0,
		VAL_FLOAT = 0x1,
		VAL_STRING = 0x2,
		VAL_ADDRESS = 0x3,
		VAL_DVAR = 0x4,
	};

	enum dvarType_t
	{
		DVAR_TYPE_INVALID = 0x0,
		DVAR_TYPE_BOOL = 0x1,
		DVAR_TYPE_FLOAT = 0x2,
		DVAR_TYPE_FLOAT_2 = 0x3,
		DVAR_TYPE_FLOAT_3 = 0x4,
		DVAR_TYPE_FLOAT_4 = 0x5,
		DVAR_TYPE_INT = 0x6,
		DVAR_TYPE_ENUM = 0x7,
		DVAR_TYPE_STRING = 0x8,
		DVAR_TYPE_COLOR = 0x9,
		DVAR_TYPE_INT64 = 0xA,
		DVAR_TYPE_LINEAR_COLOR_RGB = 0xB,
		DVAR_TYPE_COLOR_XYZ = 0xC,
		DVAR_TYPE_COUNT = 0xD,
	};

	union DvarValue
	{
		bool enabled;
		int integer;
		unsigned int unsignedInt;
		__int64 integer64;
		unsigned __int64 unsignedInt64;
		float value;
		vec4_t vector;
		const char *string;
		char color[4];
	};

	union DvarLimits
	{
		union
		{
			struct
			{
				int stringCount;
				const char * * strings;
			} enumeration;

			struct
			{
				int min;
				int max;
			} integer;

			struct
			{
				__int64 min;
				__int64 max;
			} integer64;

			struct
			{
				float min;
				float max;
			} value;

			struct
			{
				float min;
				float max;
			} vector;
		};
	};

	struct dvar_t
	{
		const char *name;
		const char *description;
		int hash;
		unsigned int flags;
		dvarType_t type;
		bool modified;
		DvarValue current;
		DvarValue latched;
		DvarValue reset;
		DvarLimits domain;
		dvar_t *hashNext;
	};

	union operandInternalDataUnion
	{
		int intVal;
		float floatVal;
		const char *string;
		dvar_t *dvar;
	};

	struct Operand
	{
		expDataType dataType;
		operandInternalDataUnion internals;
	};

	union expressionRpnDataUnion
	{
		Operand constant;
		void *cmd;
		int cmdIdx;
	};

	struct expressionRpn
	{
		int type;
		expressionRpnDataUnion data;
	};

	struct ExpressionStatement
	{
		char *filename;
		int line;
		int numRpn;
		expressionRpn *rpn;
	};

	struct GenericEventScript
	{
		ScriptCondition *prerequisites;
		ExpressionStatement condition;
		int type;
		bool fireOnTrue;
		const char *action;
		int blockID;
		int constructID;
		GenericEventScript *next;
	};

	struct GenericEventHandler
	{
		const char *name;
		GenericEventScript *eventScript;
		GenericEventHandler *next;
	};

	struct ItemKeyHandler
	{
		int key;
		GenericEventScript *keyScript;
		ItemKeyHandler *next;
	};

	struct textExp_s
	{
		ExpressionStatement textExp;
	};

	struct columnInfo_s
	{
		int elementStyle;
		int maxChars;
		rectDef_s rect;
	};

	struct MenuCell
	{
		int type;
		int maxChars;
		char *stringValue;
	};

	struct MenuRow
	{
		MenuCell *cells;
		char *eventName;
		char *onFocusEventName;
		bool disableArg;
		int status;
		int name;
	};

	struct listBoxDef_s
	{
		int mousePos;
		int cursorPos[1];
		int startPos[1];
		int endPos[1];
		int drawPadding;
		float elementWidth;
		float elementHeight;
		int numColumns;
		float special;
		columnInfo_s columnInfo[16];
		int notselectable;
		int noScrollBars;
		int usePaging;
		vec4_t selectBorder;
		vec4_t disableColor;
		vec4_t focusColor;
		vec4_t elementHighlightColor;
		vec4_t elementBackgroundColor;
		Material *selectIcon;
		Material *backgroundItemListbox;
		Material *highlightTexture;
		int noBlinkingHighlight;
		MenuRow *rows;
		int maxRows;
		int rowCount;
	};

	struct multiDef_s
	{
		const char *dvarList[32];
		const char *dvarStr[32];
		float dvarValue[32];
		int count;
		int actionOnEnterPressOnly;
		int strDef;
	};

	struct profileMultiDef_s
	{
		const char *profileVarList[32];
		const char *profileVarStr[32];
		float profileVarValue[32];
		int count;
		int actionOnEnterPressOnly;
		int strDef;
	};

	struct editFieldDef_s
	{
		int cursorPos[1];
		float minVal;
		float maxVal;
		float defVal;
		float range;
		int maxChars;
		int maxCharsGotoNext;
		int maxPaintChars;
		int paintOffset;
	};

	struct enumDvarDef_s
	{
		const char *enumDvarName;
	};

	union focusDefData_t
	{
		listBoxDef_s *listBox;
		multiDef_s *multi;
		profileMultiDef_s *profileMulti;
		editFieldDef_s *editField;
		enumDvarDef_s *enumDvar;
		void *data;
	};

	struct focusItemDef_s
	{
		const char *mouseEnterText;
		const char *mouseExitText;
		const char *mouseEnter;
		const char *mouseExit;
		ItemKeyHandler *onKey;
		focusDefData_t focusTypeData;
	};

	struct gameMsgDef_s
	{
		int gameMsgWindowIndex;
		int gameMsgWindowMode;
	};

	union textDefData_t
	{
		focusItemDef_s *focusItemDef;
		gameMsgDef_s *gameMsgDef;
		void *data;
	};

	struct textDef_s
	{
		rectDef_s textRect[1];
		int alignment;
		int fontEnum;
		int itemFlags;
		int textAlignMode;
		float textalignx;
		float textaligny;
		float textscale;
		float textpadding;
		int textStyle;
		vec4_t fontColor;
		vec4_t glowColor;
		vec4_t shadowColor;
		float fontBlur;
		float glowSize;
		float shadowSize;
		vec2_t shadowOffset;
		const char *text;
		textExp_s *textExpData;
		textDefData_t textTypeData;
	};

	struct imageDef_s
	{
		ExpressionStatement materialExp;
	};

	struct ownerDrawDef_s
	{
		ExpressionStatement dataExp;
	};

	union itemDefData_t
	{
		textDef_s *textDef;
		imageDef_s *imageDef;
		focusItemDef_s *blankButtonDef;
		ownerDrawDef_s *ownerDrawDef;
		void *data;
	};

	struct rectData_s
	{
		ExpressionStatement rectXExp;
		ExpressionStatement rectYExp;
		ExpressionStatement rectWExp;
		ExpressionStatement rectHExp;
	};

	struct animParamsDef_t
	{
		const char *name;
		rectDef_s rectClient;
		float borderSize;
		vec4_t foreColor;
		vec4_t backColor;
		vec4_t borderColor;
		vec4_t outlineColor;
		float textScale;
		float rotation;
		GenericEventHandler *onEvent;
	};

	struct UIAnimInfo
	{
		int animStateCount;
		animParamsDef_t **animStates;
		animParamsDef_t currentAnimState;
		animParamsDef_t nextAnimState;
		int animating;
		int animStartTime;
		int animDuration;
	};

	struct menuDef_t;

	struct itemDef_s
	{
		windowDef_t window;
		int type;
		int dataType;
		int imageTrack;
		const char *dvar;
		const char *profileVar;
		const char *dvarTest;
		const char *enableDvar;
		int dvarFlags;
		itemDefData_t typeData;
		menuDef_t *parent;
		rectData_s *rectExpData;
		ExpressionStatement visibleExp;
		unsigned __int64 showBits;
		unsigned __int64 hideBits;
		ExpressionStatement forecolorAExp;
		int ui3dWindowId;
		GenericEventHandler *onEvent;
		UIAnimInfo *animInfo;
	};

	struct menuDef_t
	{
		windowDef_t window;
		const char *font;
		int fullScreen;
		int ui3dWindowId;
		int itemCount;
		int fontIndex;
		int cursorItem[1];
		int fadeCycle;
		int priority;
		float fadeClamp;
		float fadeAmount;
		float fadeInAmount;
		float blurRadius;
		int openSlideSpeed;
		int closeSlideSpeed;
		int openSlideDirection;
		int closeSlideDirection;
		rectDef_s initialRectInfo;
		int openFadingTime;
		int closeFadingTime;
		int fadeTimeCounter;
		int slideTimeCounter;
		GenericEventHandler *onEvent;
		ItemKeyHandler *onKey;
		ExpressionStatement visibleExp;
		unsigned __int64 showBits;
		unsigned __int64 hideBits;
		const char *allowedBinding;
		const char *soundName;
		int imageTrack;
		int control;
		vec4_t focusColor;
		vec4_t disableColor;
		ExpressionStatement rectXExp;
		ExpressionStatement rectYExp;
		itemDef_s **items;
	};

	struct MenuList
	{
		const char *name;
		int menuCount;
		menuDef_t **menus;
	};

	struct CStringEdPackage
	{
		int m_bEndMarkerFound_ParseOnly;
		std::string m_strCurrentEntryRef_ParseOnly;
		std::string m_strCurrentEntryEnglish_ParseOnly;
		std::string m_strCurrentFileRef_ParseOnly;
		std::map<std::string, std::string> m_StringEntries;
	};

	struct LocalizeEntry
	{
		const char *value;
		const char *name;
	};

	enum weapType_t
	{
		WEAPTYPE_BULLET = 0x0,
		WEAPTYPE_GRENADE = 0x1,
		WEAPTYPE_PROJECTILE = 0x2,
		WEAPTYPE_BINOCULARS = 0x3,
		WEAPTYPE_GAS = 0x4,
		WEAPTYPE_BOMB = 0x5,
		WEAPTYPE_MINE = 0x6,
		WEAPTYPE_MELEE = 0x7,
		WEAPTYPE_RIOTSHIELD = 0x8,
		WEAPTYPE_NUM = 0x9,
	};

	enum weapClass_t
	{
		WEAPCLASS_RIFLE = 0x0,
		WEAPCLASS_MG = 0x1,
		WEAPCLASS_SMG = 0x2,
		WEAPCLASS_SPREAD = 0x3,
		WEAPCLASS_PISTOL = 0x4,
		WEAPCLASS_GRENADE = 0x5,
		WEAPCLASS_ROCKETLAUNCHER = 0x6,
		WEAPCLASS_TURRET = 0x7,
		WEAPCLASS_NON_PLAYER = 0x8,
		WEAPCLASS_GAS = 0x9,
		WEAPCLASS_ITEM = 0xA,
		WEAPCLASS_MELEE = 0xB,
		WEAPCLASS_KILLSTREAK_ALT_STORED_WEAPON = 0xC,
		WEAPCLASS_PISTOL_SPREAD = 0xD,
		WEAPCLASS_NUM = 0xE,
	};

	enum PenetrateType
	{
		PENETRATE_TYPE_NONE = 0x0,
		PENETRATE_TYPE_SMALL = 0x1,
		PENETRATE_TYPE_MEDIUM = 0x2,
		PENETRATE_TYPE_LARGE = 0x3,
		PENETRATE_TYPE_COUNT = 0x4,
	};

	enum ImpactType
	{
		IMPACT_TYPE_NONE = 0x0,
		IMPACT_TYPE_BULLET_SMALL = 0x1,
		IMPACT_TYPE_BULLET_LARGE = 0x2,
		IMPACT_TYPE_BULLET_AP = 0x3,
		IMPACT_TYPE_BULLET_XTREME = 0x4,
		IMPACT_TYPE_SHOTGUN = 0x5,
		IMPACT_TYPE_GRENADE_BOUNCE = 0x6,
		IMPACT_TYPE_GRENADE_EXPLODE = 0x7,
		IMPACT_TYPE_RIFLE_GRENADE = 0x8,
		IMPACT_TYPE_ROCKET_EXPLODE = 0x9,
		IMPACT_TYPE_ROCKET_EXPLODE_XTREME = 0xA,
		IMPACT_TYPE_PROJECTILE_DUD = 0xB,
		IMPACT_TYPE_MORTAR_SHELL = 0xC,
		IMPACT_TYPE_TANK_SHELL = 0xD,
		IMPACT_TYPE_BOLT = 0xE,
		IMPACT_TYPE_BLADE = 0xF,
		IMPACT_TYPE_COUNT = 0x10,
	};

	enum weapInventoryType_t
	{
		WEAPINVENTORY_PRIMARY = 0x0,
		WEAPINVENTORY_OFFHAND = 0x1,
		WEAPINVENTORY_ITEM = 0x2,
		WEAPINVENTORY_ALTMODE = 0x3,
		WEAPINVENTORY_MELEE = 0x4,
		WEAPINVENTORY_DWLEFTHAND = 0x5,
		WEAPINVENTORYCOUNT = 0x6,
	};

	enum weapFireType_t
	{
		WEAPON_FIRETYPE_FULLAUTO = 0x0,
		WEAPON_FIRETYPE_SINGLESHOT = 0x1,
		WEAPON_FIRETYPE_BURSTFIRE2 = 0x2,
		WEAPON_FIRETYPE_BURSTFIRE3 = 0x3,
		WEAPON_FIRETYPE_BURSTFIRE4 = 0x4,
		WEAPON_FIRETYPE_BURSTFIRE5 = 0x5,
		WEAPON_FIRETYPE_STACKED = 0x6,
		WEAPON_FIRETYPE_MINIGUN = 0x7,
		WEAPON_FIRETYPE_CHARGESHOT = 0x8,
		WEAPON_FIRETYPE_JETGUN = 0x9,
		WEAPON_FIRETYPECOUNT = 0xA,
	};

	enum weapClipType_t
	{
		WEAPON_CLIPTYPE_BOTTOM = 0x0,
		WEAPON_CLIPTYPE_TOP = 0x1,
		WEAPON_CLIPTYPE_LEFT = 0x2,
		WEAPON_CLIPTYPE_DP28 = 0x3,
		WEAPON_CLIPTYPE_PTRS = 0x4,
		WEAPON_CLIPTYPE_LMG = 0x5,
		WEAPON_CLIPTYPECOUNT = 0x6,
	};

	enum barrelType_t
	{
		BARREL_TYPE_SINGLE = 0x0,
		BARREL_TYPE_DUAL = 0x1,
		BARREL_TYPE_DUAL_ALTERNATE = 0x2,
		BARREL_TYPE_QUAD = 0x3,
		BARREL_TYPE_QUAD_ALTERNATE = 0x4,
		BARREL_TYPE_QUAD_DOUBLE_ALTERNATE = 0x5,
		BARREL_TYPE_COUNT = 0x6,
	};

	enum OffhandClass
	{
		OFFHAND_CLASS_NONE = 0x0,
		OFFHAND_CLASS_FRAG_GRENADE = 0x1,
		OFFHAND_CLASS_SMOKE_GRENADE = 0x2,
		OFFHAND_CLASS_FLASH_GRENADE = 0x3,
		OFFHAND_CLASS_GEAR = 0x4,
		OFFHAND_CLASS_SUPPLYDROP_MARKER = 0x5,
		OFFHAND_CLASS_COUNT = 0x6,
	};

	enum OffhandSlot
	{
		OFFHAND_SLOT_NONE = 0x0,
		OFFHAND_SLOT_LETHAL_GRENADE = 0x1,
		OFFHAND_SLOT_TACTICAL_GRENADE = 0x2,
		OFFHAND_SLOT_EQUIPMENT = 0x3,
		OFFHAND_SLOT_SPECIFIC_USE = 0x4,
		OFFHAND_SLOT_COUNT = 0x5,
	};

	enum weapStance_t
	{
		WEAPSTANCE_STAND = 0x0,
		WEAPSTANCE_DUCK = 0x1,
		WEAPSTANCE_PRONE = 0x2,
		WEAPSTANCE_NUM = 0x3,
	};

	enum activeReticleType_t
	{
		VEH_ACTIVE_RETICLE_NONE = 0x0,
		VEH_ACTIVE_RETICLE_PIP_ON_A_STICK = 0x1,
		VEH_ACTIVE_RETICLE_BOUNCING_DIAMOND = 0x2,
		VEH_ACTIVE_RETICLE_MISSILE_LOCK = 0x3,
		VEH_ACTIVE_RETICLE_COUNT = 0x4,
	};

	enum weaponIconRatioType_t
	{
		WEAPON_ICON_RATIO_1TO1 = 0x0,
		WEAPON_ICON_RATIO_2TO1 = 0x1,
		WEAPON_ICON_RATIO_4TO1 = 0x2,
		WEAPON_ICON_RATIO_COUNT = 0x3,
	};

	enum ammoCounterClipType_t
	{
		AMMO_COUNTER_CLIP_NONE = 0x0,
		AMMO_COUNTER_CLIP_MAGAZINE = 0x1,
		AMMO_COUNTER_CLIP_SHORTMAGAZINE = 0x2,
		AMMO_COUNTER_CLIP_SHOTGUN = 0x3,
		AMMO_COUNTER_CLIP_ROCKET = 0x4,
		AMMO_COUNTER_CLIP_BELTFED = 0x5,
		AMMO_COUNTER_CLIP_ALTWEAPON = 0x6,
		AMMO_COUNTER_CLIP_COUNT = 0x7,
	};

	enum weapOverlayReticle_t
	{
		WEAPOVERLAYRETICLE_NONE = 0x0,
		WEAPOVERLAYRETICLE_CROSSHAIR = 0x1,
		WEAPOVERLAYRETICLE_NUM = 0x2,
	};

	enum WeapOverlayInteface_t
	{
		WEAPOVERLAYINTERFACE_NONE = 0x0,
		WEAPOVERLAYINTERFACE_JAVELIN = 0x1,
		WEAPOVERLAYINTERFACE_TURRETSCOPE = 0x2,
		WEAPOVERLAYINTERFACECOUNT = 0x3,
	};

	enum weapProjExposion_t
	{
		WEAPPROJEXP_GRENADE = 0x0,
		WEAPPROJEXP_ROCKET = 0x1,
		WEAPPROJEXP_FLASHBANG = 0x2,
		WEAPPROJEXP_NONE = 0x3,
		WEAPPROJEXP_DUD = 0x4,
		WEAPPROJEXP_SMOKE = 0x5,
		WEAPPROJEXP_HEAVY = 0x6,
		WEAPPROJEXP_FIRE = 0x7,
		WEAPPROJEXP_NAPALMBLOB = 0x8,
		WEAPPROJEXP_BOLT = 0x9,
		WEAPPROJEXP_SHRAPNELSPAN = 0xA,
		WEAPPROJEXP_NUM = 0xB,
	};

	enum WeapStickinessType
	{
		WEAPSTICKINESS_NONE = 0x0,
		WEAPSTICKINESS_ALL = 0x1,
		WEAPSTICKINESS_ALL_NO_SENTIENTS = 0x2,
		WEAPSTICKINESS_GROUND = 0x3,
		WEAPSTICKINESS_GROUND_WITH_YAW = 0x4,
		WEAPSTICKINESS_FLESH = 0x5,
		WEAPSTICKINESS_COUNT = 0x6,
	};

	enum WeapRotateType
	{
		WEAPROTATE_GRENADE_ROTATE = 0x0,
		WEAPROTATE_BLADE_ROTATE = 0x1,
		WEAPROTATE_CYLINDER_ROTATE = 0x2,
		WEAPROTATE_COUNT = 0x3,
	};

	enum guidedMissileType_t
	{
		MISSILE_GUIDANCE_NONE = 0x0,
		MISSILE_GUIDANCE_SIDEWINDER = 0x1,
		MISSILE_GUIDANCE_HELLFIRE = 0x2,
		MISSILE_GUIDANCE_JAVELIN = 0x3,
		MISSILE_GUIDANCE_BALLISTIC = 0x4,
		MISSILE_GUIDANCE_WIREGUIDED = 0x5,
		MISSILE_GUIDANCE_TVGUIDED = 0x6,
		MISSILE_GUIDANCE_DRONE = 0x7,
		MISSILE_GUIDANCE_HEATSEEKING = 0x8,
		MISSILE_GUIDANCE_COUNT = 0x9,
	};

	enum tracerType_t
	{
		TRACERTYPE_LASER = 0x0,
		TRACERTYPE_SMOKE = 0x1,
		TRACERTYPE_NUM = 0x2,
	};

	struct TracerDef
	{
		const char *name;
		tracerType_t type;
		Material *material;
		unsigned int drawInterval;
		float speed;
		float beamLength;
		float beamWidth;
		float screwRadius;
		float screwDist;
		float fadeTime;
		float fadeScale;
		float texRepeatRate;
		vec4_t colors[5];
	};

	struct flameTable
	{
		float flameVar_streamChunkGravityStart;
		float flameVar_streamChunkGravityEnd;
		float flameVar_streamChunkMaxSize;
		float flameVar_streamChunkStartSize;
		float flameVar_streamChunkEndSize;
		float flameVar_streamChunkStartSizeRand;
		float flameVar_streamChunkEndSizeRand;
		float flameVar_streamChunkDistScalar;
		float flameVar_streamChunkDistSwayScale;
		float flameVar_streamChunkDistSwayVelMax;
		float flameVar_streamChunkSpeed;
		float flameVar_streamChunkDecel;
		float flameVar_streamChunkVelocityAddScale;
		float flameVar_streamChunkDuration;
		float flameVar_streamChunkDurationScaleMaxVel;
		float flameVar_streamChunkDurationVelScalar;
		float flameVar_streamChunkSizeSpeedScale;
		float flameVar_streamChunkSizeAgeScale;
		float flameVar_streamChunkSpawnFireIntervalStart;
		float flameVar_streamChunkSpawnFireIntervalEnd;
		float flameVar_streamChunkSpawnFireMinLifeFrac;
		float flameVar_streamChunkSpawnFireMaxLifeFrac;
		float flameVar_streamChunkFireMinLifeFrac;
		float flameVar_streamChunkFireMinLifeFracStart;
		float flameVar_streamChunkFireMinLifeFracEnd;
		float flameVar_streamChunkDripsMinLifeFrac;
		float flameVar_streamChunkDripsMinLifeFracStart;
		float flameVar_streamChunkDripsMinLifeFracEnd;
		float flameVar_streamChunkRotationRange;
		float flameVar_streamSizeRandSinWave;
		float flameVar_streamSizeRandCosWave;
		float flameVar_streamDripsChunkInterval;
		float flameVar_streamDripsChunkMinFrac;
		float flameVar_streamDripsChunkRandFrac;
		float flameVar_streamSmokeChunkInterval;
		float flameVar_streamSmokeChunkMinFrac;
		float flameVar_streamSmokeChunkRandFrac;
		float flameVar_streamChunkCullDistSizeFrac;
		float flameVar_streamChunkCullMinLife;
		float flameVar_streamChunkCullMaxLife;
		float flameVar_streamFuelSizeStart;
		float flameVar_streamFuelSizeEnd;
		float flameVar_streamFuelLength;
		float flameVar_streamFuelNumSegments;
		float flameVar_streamFuelAnimLoopTime;
		float flameVar_streamFlameSizeStart;
		float flameVar_streamFlameSizeEnd;
		float flameVar_streamFlameLength;
		float flameVar_streamFlameNumSegments;
		float flameVar_streamFlameAnimLoopTime;
		float flameVar_streamPrimaryLightRadius;
		float flameVar_streamPrimaryLightRadiusFlutter;
		float flameVar_streamPrimaryLightR;
		float flameVar_streamPrimaryLightG;
		float flameVar_streamPrimaryLightB;
		float flameVar_streamPrimaryLightFlutterR;
		float flameVar_streamPrimaryLightFlutterG;
		float flameVar_streamPrimaryLightFlutterB;
		float flameVar_fireLife;
		float flameVar_fireLifeRand;
		float flameVar_fireSpeedScale;
		float flameVar_fireSpeedScaleRand;
		float flameVar_fireVelocityAddZ;
		float flameVar_fireVelocityAddZRand;
		float flameVar_fireVelocityAddSideways;
		float flameVar_fireGravity;
		float flameVar_fireGravityEnd;
		float flameVar_fireMaxRotVel;
		float flameVar_fireFriction;
		float flameVar_fireEndSizeAdd;
		float flameVar_fireStartSizeScale;
		float flameVar_fireEndSizeScale;
		float flameVar_fireBrightness;
		float flameVar_dripsLife;
		float flameVar_dripsLifeRand;
		float flameVar_dripsSpeedScale;
		float flameVar_dripsSpeedScaleRand;
		float flameVar_dripsVelocityAddZ;
		float flameVar_dripsVelocityAddZRand;
		float flameVar_dripsVelocityAddSideways;
		float flameVar_dripsGravity;
		float flameVar_dripsGravityEnd;
		float flameVar_dripsMaxRotVel;
		float flameVar_dripsFriction;
		float flameVar_dripsEndSizeAdd;
		float flameVar_dripsStartSizeScale;
		float flameVar_dripsEndSizeScale;
		float flameVar_dripsBrightness;
		float flameVar_smokeLife;
		float flameVar_smokeLifeRand;
		float flameVar_smokeSpeedScale;
		float flameVar_smokeVelocityAddZ;
		float flameVar_smokeGravity;
		float flameVar_smokeGravityEnd;
		float flameVar_smokeMaxRotation;
		float flameVar_smokeMaxRotVel;
		float flameVar_smokeFriction;
		float flameVar_smokeEndSizeAdd;
		float flameVar_smokeStartSizeAdd;
		float flameVar_smokeOriginSizeOfsZScale;
		float flameVar_smokeOriginOfsZ;
		float flameVar_smokeFadein;
		float flameVar_smokeFadeout;
		float flameVar_smokeMaxAlpha;
		float flameVar_smokeBrightness;
		float flameVar_smokeOriginOffset;
		float flameVar_collisionSpeedScale;
		float flameVar_collisionVolumeScale;
		const char *name;
		Material *fire;
		Material *smoke;
		Material *heat;
		Material *drips;
		Material *streamFuel;
		Material *streamFuel2;
		Material *streamFlame;
		Material *streamFlame2;
		const char *flameOffLoopSound;
		const char *flameIgniteSound;
		const char *flameOnLoopSound;
		const char *flameCooldownSound;
	};

	struct WeaponCamoSet
	{
		GfxImage *solidCamoImage;
		GfxImage *patternCamoImage;
		vec2_t patternOffset;
		float patternScale;
	};

	struct WeaponCamoMaterial
	{
		unsigned __int16 replaceFlags;
		unsigned __int16 numBaseMaterials;
		Material **baseMaterials;
		Material **camoMaterials;
		float shaderConsts[8];
	};

	struct WeaponCamoMaterialSet
	{
		unsigned int numMaterials;
		WeaponCamoMaterial *materials;
	};

	struct WeaponCamo
	{
		const char *name;
		GfxImage *solidBaseImage;
		GfxImage *patternBaseImage;
		WeaponCamoSet *camoSets;
		unsigned int numCamoSets;
		WeaponCamoMaterialSet *camoMaterials;
		unsigned int numCamoMaterials;
	};

	struct WeaponDef
	{
		const char *szOverlayName;
		XModel **gunXModel;
		XModel *handXModel;
		const char *szModeName;
		unsigned __int16 *notetrackSoundMapKeys;
		unsigned __int16 *notetrackSoundMapValues;
		int playerAnimType;
		weapType_t weapType;
		weapClass_t weapClass;
		PenetrateType penetrateType;
		ImpactType impactType;
		weapInventoryType_t inventoryType;
		weapFireType_t fireType;
		weapClipType_t clipType;
		barrelType_t barrelType;
		int itemIndex;
		const char *parentWeaponName;
		int iJamFireTime;
		int overheatWeapon;
		float overheatRate;
		float cooldownRate;
		float overheatEndVal;
		bool coolWhileFiring;
		bool fuelTankWeapon;
		int iTankLifeTime;
		OffhandClass offhandClass;
		OffhandSlot offhandSlot;
		weapStance_t stance;
		FxEffectDef *viewFlashEffect;
		FxEffectDef *worldFlashEffect;
		FxEffectDef *barrelCooldownEffect;
		int barrelCooldownMinCount;
		vec3_t vViewFlashOffset;
		vec3_t vWorldFlashOffset;
		const char *pickupSound;
		const char *pickupSoundPlayer;
		const char *ammoPickupSound;
		const char *ammoPickupSoundPlayer;
		const char *projectileSound;
		const char *pullbackSound;
		const char *pullbackSoundPlayer;
		const char *fireSound;
		const char *fireSoundPlayer;
		const char *fireLoopSound;
		const char *fireLoopSoundPlayer;
		const char *fireLoopEndSound;
		const char *fireLoopEndSoundPlayer;
		const char *fireStartSound;
		const char *fireStopSound;
		const char *fireKillcamSound;
		const char *fireStartSoundPlayer;
		const char *fireStopSoundPlayer;
		const char *fireKillcamSoundPlayer;
		const char *fireLastSound;
		const char *fireLastSoundPlayer;
		const char *emptyFireSound;
		const char *emptyFireSoundPlayer;
		const char *crackSound;
		const char *whizbySound;
		const char *meleeSwipeSound;
		const char *meleeSwipeSoundPlayer;
		const char *meleeHitSound;
		const char *meleeMissSound;
		const char *rechamberSound;
		const char *rechamberSoundPlayer;
		const char *reloadSound;
		const char *reloadSoundPlayer;
		const char *reloadEmptySound;
		const char *reloadEmptySoundPlayer;
		const char *reloadStartSound;
		const char *reloadStartSoundPlayer;
		const char *reloadEndSound;
		const char *reloadEndSoundPlayer;
		const char *rotateLoopSound;
		const char *rotateLoopSoundPlayer;
		const char *rotateStopSound;
		const char *rotateStopSoundPlayer;
		const char *deploySound;
		const char *deploySoundPlayer;
		const char *finishDeploySound;
		const char *finishDeploySoundPlayer;
		const char *breakdownSound;
		const char *breakdownSoundPlayer;
		const char *finishBreakdownSound;
		const char *finishBreakdownSoundPlayer;
		const char *detonateSound;
		const char *detonateSoundPlayer;
		const char *nightVisionWearSound;
		const char *nightVisionWearSoundPlayer;
		const char *nightVisionRemoveSound;
		const char *nightVisionRemoveSoundPlayer;
		const char *altSwitchSound;
		const char *altSwitchSoundPlayer;
		const char *raiseSound;
		const char *raiseSoundPlayer;
		const char *firstRaiseSound;
		const char *firstRaiseSoundPlayer;
		const char *adsRaiseSoundPlayer;
		const char *adsLowerSoundPlayer;
		const char *putawaySound;
		const char *putawaySoundPlayer;
		const char *overheatSound;
		const char *overheatSoundPlayer;
		const char *adsZoomSound;
		const char *shellCasing;
		const char *shellCasingPlayer;
		const char **bounceSound;
		const char *standMountedWeapdef;
		const char *crouchMountedWeapdef;
		const char *proneMountedWeapdef;
		int standMountedIndex;
		int crouchMountedIndex;
		int proneMountedIndex;
		FxEffectDef *viewShellEjectEffect;
		FxEffectDef *worldShellEjectEffect;
		FxEffectDef *viewLastShotEjectEffect;
		FxEffectDef *worldLastShotEjectEffect;
		vec3_t vViewShellEjectOffset;
		vec3_t vWorldShellEjectOffset;
		vec3_t vViewShellEjectRotation;
		vec3_t vWorldShellEjectRotation;
		Material *reticleCenter;
		Material *reticleSide;
		int iReticleCenterSize;
		int iReticleSideSize;
		int iReticleMinOfs;
		activeReticleType_t activeReticleType;
		vec3_t vStandMove;
		vec3_t vStandRot;
		vec3_t vDuckedOfs;
		vec3_t vDuckedMove;
		vec3_t vDuckedSprintOfs;
		vec3_t vDuckedSprintRot;
		vec2_t vDuckedSprintBob;
		float fDuckedSprintCycleScale;
		vec3_t vSprintOfs;
		vec3_t vSprintRot;
		vec2_t vSprintBob;
		float fSprintCycleScale;
		vec3_t vLowReadyOfs;
		vec3_t vLowReadyRot;
		vec3_t vRideOfs;
		vec3_t vRideRot;
		vec3_t vDtpOfs;
		vec3_t vDtpRot;
		vec2_t vDtpBob;
		float fDtpCycleScale;
		vec3_t vMantleOfs;
		vec3_t vMantleRot;
		vec3_t vSlideOfs;
		vec3_t vSlideRot;
		vec3_t vDuckedRot;
		vec3_t vProneOfs;
		vec3_t vProneMove;
		vec3_t vProneRot;
		vec3_t vStrafeMove;
		vec3_t vStrafeRot;
		float fPosMoveRate;
		float fPosProneMoveRate;
		float fStandMoveMinSpeed;
		float fDuckedMoveMinSpeed;
		float fProneMoveMinSpeed;
		float fPosRotRate;
		float fPosProneRotRate;
		float fStandRotMinSpeed;
		float fDuckedRotMinSpeed;
		float fProneRotMinSpeed;
		XModel **worldModel;
		XModel *worldClipModel;
		XModel *rocketModel;
		XModel *mountedModel;
		XModel *additionalMeleeModel;
		Material *fireTypeIcon;
		Material *hudIcon;
		weaponIconRatioType_t hudIconRatio;
		Material *indicatorIcon;
		weaponIconRatioType_t indicatorIconRatio;
		Material *ammoCounterIcon;
		weaponIconRatioType_t ammoCounterIconRatio;
		ammoCounterClipType_t ammoCounterClip;
		int iStartAmmo;
		int iMaxAmmo;
		int shotCount;
		const char *szSharedAmmoCapName;
		int iSharedAmmoCapIndex;
		int iSharedAmmoCap;
		bool unlimitedAmmo;
		bool ammoCountClipRelative;
		int damage[6];
		float damageRange[6];
		int minPlayerDamage;
		float damageDuration;
		float damageInterval;
		int playerDamage;
		int iMeleeDamage;
		int iDamageType;
		unsigned __int16 explosionTag;
		int iFireDelay;
		int iMeleeDelay;
		int meleeChargeDelay;
		int iDetonateDelay;
		int iSpinUpTime;
		int iSpinDownTime;
		float spinRate;
		const char *spinLoopSound;
		const char *spinLoopSoundPlayer;
		const char *startSpinSound;
		const char *startSpinSoundPlayer;
		const char *stopSpinSound;
		const char *stopSpinSoundPlayer;
		bool applySpinPitch;
		int iFireTime;
		int iLastFireTime;
		int iRechamberTime;
		int iRechamberBoltTime;
		int iHoldFireTime;
		int iDetonateTime;
		int iMeleeTime;
		int iBurstDelayTime;
		int meleeChargeTime;
		int iReloadTimeRight;
		int iReloadTimeLeft;
		int reloadShowRocketTime;
		int iReloadEmptyTimeLeft;
		int iReloadAddTime;
		int iReloadEmptyAddTime;
		int iReloadQuickAddTime;
		int iReloadQuickEmptyAddTime;
		int iReloadStartTime;
		int iReloadStartAddTime;
		int iReloadEndTime;
		int iDropTime;
		int iRaiseTime;
		int iAltDropTime;
		int quickDropTime;
		int quickRaiseTime;
		int iFirstRaiseTime;
		int iEmptyRaiseTime;
		int iEmptyDropTime;
		int sprintInTime;
		int sprintLoopTime;
		int sprintOutTime;
		int lowReadyInTime;
		int lowReadyLoopTime;
		int lowReadyOutTime;
		int contFireInTime;
		int contFireLoopTime;
		int contFireOutTime;
		int dtpInTime;
		int dtpLoopTime;
		int dtpOutTime;
		int crawlInTime;
		int crawlForwardTime;
		int crawlBackTime;
		int crawlRightTime;
		int crawlLeftTime;
		int crawlOutFireTime;
		int crawlOutTime;
		int slideInTime;
		int deployTime;
		int breakdownTime;
		int iFlourishTime;
		int nightVisionWearTime;
		int nightVisionWearTimeFadeOutEnd;
		int nightVisionWearTimePowerUp;
		int nightVisionRemoveTime;
		int nightVisionRemoveTimePowerDown;
		int nightVisionRemoveTimeFadeInStart;
		int fuseTime;
		int aiFuseTime;
		int lockOnRadius;
		int lockOnSpeed;
		bool requireLockonToFire;
		bool noAdsWhenMagEmpty;
		bool avoidDropCleanup;
		unsigned int stackFire;
		float stackFireSpread;
		float stackFireAccuracyDecay;
		const char *stackSound;
		float autoAimRange;
		float aimAssistRange;
		bool mountableWeapon;
		float aimPadding;
		float enemyCrosshairRange;
		bool crosshairColorChange;
		float moveSpeedScale;
		float adsMoveSpeedScale;
		float sprintDurationScale;
		weapOverlayReticle_t overlayReticle;
		WeapOverlayInteface_t overlayInterface;
		float overlayWidth;
		float overlayHeight;
		float fAdsBobFactor;
		float fAdsViewBobMult;
		bool bHoldBreathToSteady;
		float fHipSpreadStandMin;
		float fHipSpreadDuckedMin;
		float fHipSpreadProneMin;
		float hipSpreadStandMax;
		float hipSpreadDuckedMax;
		float hipSpreadProneMax;
		float fHipSpreadDecayRate;
		float fHipSpreadFireAdd;
		float fHipSpreadTurnAdd;
		float fHipSpreadMoveAdd;
		float fHipSpreadDuckedDecay;
		float fHipSpreadProneDecay;
		float fHipReticleSidePos;
		float fAdsIdleAmount;
		float fHipIdleAmount;
		float adsIdleSpeed;
		float hipIdleSpeed;
		float fIdleCrouchFactor;
		float fIdleProneFactor;
		float fGunMaxPitch;
		float fGunMaxYaw;
		float swayMaxAngle;
		float swayLerpSpeed;
		float swayPitchScale;
		float swayYawScale;
		float swayHorizScale;
		float swayVertScale;
		float swayShellShockScale;
		float adsSwayMaxAngle;
		float adsSwayLerpSpeed;
		float adsSwayPitchScale;
		float adsSwayYawScale;
		bool sharedAmmo;
		bool bRifleBullet;
		bool armorPiercing;
		bool bAirburstWeapon;
		bool bBoltAction;
		bool bUseAltTagFlash;
		bool bUseAntiLagRewind;
		bool bIsCarriedKillstreakWeapon;
		bool aimDownSight;
		bool bRechamberWhileAds;
		bool bReloadWhileAds;
		float adsViewErrorMin;
		float adsViewErrorMax;
		bool bCookOffHold;
		bool bClipOnly;
		bool bCanUseInVehicle;
		bool bNoDropsOrRaises;
		bool adsFireOnly;
		bool cancelAutoHolsterWhenEmpty;
		bool suppressAmmoReserveDisplay;
		bool laserSight;
		bool laserSightDuringNightvision;
		bool bHideThirdPerson;
		bool bHasBayonet;
		bool bDualWield;
		bool bExplodeOnGround;
		bool bThrowBack;
		bool bRetrievable;
		bool bDieOnRespawn;
		bool bNoThirdPersonDropsOrRaises;
		bool bContinuousFire;
		bool bNoPing;
		bool bForceBounce;
		bool bUseDroppedModelAsStowed;
		bool bNoQuickDropWhenEmpty;
		bool bKeepCrosshairWhenADS;
		bool bUseOnlyAltWeaoponHideTagsInAltMode;
		bool bAltWeaponAdsOnly;
		bool bAltWeaponDisableSwitching;
		Material *killIcon;
		weaponIconRatioType_t killIconRatio;
		bool flipKillIcon;
		bool bNoPartialReload;
		bool bSegmentedReload;
		bool bNoADSAutoReload;
		int iReloadAmmoAdd;
		int iReloadStartAdd;
		const char *szSpawnedGrenadeWeaponName;
		const char *szDualWieldWeaponName;
		unsigned int dualWieldWeaponIndex;
		int iDropAmmoMin;
		int iDropAmmoMax;
		int iDropClipAmmoMin;
		int iDropClipAmmoMax;
		int iShotsBeforeRechamber;
		bool blocksProne;
		bool bShowIndicator;
		int isRollingGrenade;
		int useBallisticPrediction;
		int isValuable;
		int isTacticalInsertion;
		bool isReviveWeapon;
		bool bUseRigidBodyOnVehicle;
		int iExplosionRadius;
		int iExplosionRadiusMin;
		int iIndicatorRadius;
		int iExplosionInnerDamage;
		int iExplosionOuterDamage;
		float damageConeAngle;
		int iProjectileSpeed;
		int iProjectileSpeedUp;
		int iProjectileSpeedRelativeUp;
		int iProjectileSpeedForward;
		float fProjectileTakeParentVelocity;
		int iProjectileActivateDist;
		float projLifetime;
		float timeToAccelerate;
		float projectileCurvature;
		XModel *projectileModel;
		weapProjExposion_t projExplosion;
		FxEffectDef *projExplosionEffect;
		bool projExplosionEffectForceNormalUp;
		FxEffectDef *projExplosionEffect2;
		bool projExplosionEffect2ForceNormalUp;
		FxEffectDef *projExplosionEffect3;
		bool projExplosionEffect3ForceNormalUp;
		FxEffectDef *projExplosionEffect4;
		bool projExplosionEffect4ForceNormalUp;
		FxEffectDef *projExplosionEffect5;
		bool projExplosionEffect5ForceNormalUp;
		FxEffectDef *projDudEffect;
		const char *projExplosionSound;
		const char *projDudSound;
		const char *mortarShellSound;
		const char *tankShellSound;
		bool bProjImpactExplode;
		bool bProjSentientImpactExplode;
		bool bProjExplodeWhenStationary;
		bool bBulletImpactExplode;
		WeapStickinessType stickiness;
		WeapRotateType rotateType;
		bool plantable;
		bool hasDetonator;
		bool timedDetonation;
		bool bNoCrumpleMissile;
		bool rotate;
		bool bKeepRolling;
		bool holdButtonToThrow;
		bool offhandHoldIsCancelable;
		bool freezeMovementWhenFiring;
		float lowAmmoWarningThreshold;
		bool bDisallowAtMatchStart;
		float meleeChargeRange;
		bool bUseAsMelee;
		bool isCameraSensor;
		bool isAcousticSensor;
		bool isLaserSensor;
		bool isHoldUseGrenade;
		float *parallelBounce;
		float *perpendicularBounce;
		FxEffectDef *projTrailEffect;
		vec3_t vProjectileColor;
		guidedMissileType_t guidedMissileType;
		float maxSteeringAccel;
		int projIgnitionDelay;
		FxEffectDef *projIgnitionEffect;
		const char *projIgnitionSound;
		float fAdsAimPitch;
		float fAdsCrosshairInFrac;
		float fAdsCrosshairOutFrac;
		int adsGunKickReducedKickBullets;
		float adsGunKickReducedKickPercent;
		float fAdsGunKickPitchMin;
		float fAdsGunKickPitchMax;
		float fAdsGunKickYawMin;
		float fAdsGunKickYawMax;
		float fAdsGunKickAccel;
		float fAdsGunKickSpeedMax;
		float fAdsGunKickSpeedDecay;
		float fAdsGunKickStaticDecay;
		float fAdsViewKickPitchMin;
		float fAdsViewKickPitchMax;
		float fAdsViewKickMinMagnitude;
		float fAdsViewKickYawMin;
		float fAdsViewKickYawMax;
		float fAdsRecoilReductionRate;
		float fAdsRecoilReductionLimit;
		float fAdsRecoilReturnRate;
		float fAdsViewScatterMin;
		float fAdsViewScatterMax;
		float fAdsSpread;
		int hipGunKickReducedKickBullets;
		float hipGunKickReducedKickPercent;
		float fHipGunKickPitchMin;
		float fHipGunKickPitchMax;
		float fHipGunKickYawMin;
		float fHipGunKickYawMax;
		float fHipGunKickAccel;
		float fHipGunKickSpeedMax;
		float fHipGunKickSpeedDecay;
		float fHipGunKickStaticDecay;
		float fHipViewKickPitchMin;
		float fHipViewKickPitchMax;
		float fHipViewKickMinMagnitude;
		float fHipViewKickYawMin;
		float fHipViewKickYawMax;
		float fHipViewScatterMin;
		float fHipViewScatterMax;
		float fAdsViewKickCenterDuckedScale;
		float fAdsViewKickCenterProneScale;
		float fAntiQuickScopeTime;
		float fAntiQuickScopeScale;
		float fAntiQuickScopeSpreadMultiplier;
		float fAntiQuickScopeSpreadMax;
		float fAntiQuickScopeSwayFactor;
		float fightDist;
		float maxDist;
		const char *accuracyGraphName[2];
		vec2_t *accuracyGraphKnots[2];
		vec2_t *originalAccuracyGraphKnots[2];
		int accuracyGraphKnotCount[2];
		int originalAccuracyGraphKnotCount[2];
		int iPositionReloadTransTime;
		float leftArc;
		float rightArc;
		float topArc;
		float bottomArc;
		float accuracy;
		float aiSpread;
		float playerSpread;
		float minTurnSpeed[2];
		float maxTurnSpeed[2];
		float pitchConvergenceTime;
		float yawConvergenceTime;
		float suppressTime;
		float maxRange;
		float fAnimHorRotateInc;
		float fPlayerPositionDist;
		const char *szUseHintString;
		const char *dropHintString;
		int iUseHintStringIndex;
		int dropHintStringIndex;
		float horizViewJitter;
		float vertViewJitter;
		float cameraShakeScale;
		int cameraShakeDuration;
		int cameraShakeRadius;
		float explosionCameraShakeScale;
		int explosionCameraShakeDuration;
		int explosionCameraShakeRadius;
		const char *szScript;
		float destabilizationRateTime;
		float destabilizationCurvatureMax;
		int destabilizeDistance;
		float *locationDamageMultipliers;
		const char *fireRumble;
		const char *meleeImpactRumble;
		const char *reloadRumble;
		const char *explosionRumble;
		TracerDef *tracerType;
		TracerDef *enemyTracerType;
		float adsDofStart;
		float adsDofEnd;
		float hipDofStart;
		float hipDofEnd;
		float scanSpeed;
		float scanAccel;
		int scanPauseTime;
		const char *flameTableFirstPerson;
		const char *flameTableThirdPerson;
		flameTable *flameTableFirstPersonPtr;
		flameTable *flameTableThirdPersonPtr;
		FxEffectDef *tagFx_preparationEffect;
		FxEffectDef *tagFlash_preparationEffect;
		bool doGibbing;
		float maxGibDistance;
		float altScopeADSTransInTime;
		float altScopeADSTransOutTime;
		int iIntroFireTime;
		int iIntroFireLength;
		FxEffectDef *meleeSwipeEffect;
		FxEffectDef *meleeImpactEffect;
		FxEffectDef *meleeImpactNoBloodEffect;
		const char *throwBackType;
		WeaponCamo *weaponCamo;
		float customFloat0;
		float customFloat1;
		float customFloat2;
		int customBool0;
		int customBool1;
		int customBool2;
	};

	enum eAttachment
	{
		ATTACHMENT_NONE = 0x0,
		ATTACHMENT_ACOG = 0x1,
		ATTACHMENT_DUALCLIP = 0x2,
		ATTACHMENT_DUALOPTIC = 0x3,
		ATTACHMENT_DW = 0x4,
		ATTACHMENT_EXTBARREL = 0x5,
		ATTACHMENT_EXTCLIP = 0x6,
		ATTACHMENT_EXTRAMAGS = 0x7,
		ATTACHMENT_FASTADS = 0x8,
		ATTACHMENT_FASTRELOAD = 0x9,
		ATTACHMENT_FMJ = 0xA,
		ATTACHMENT_GL = 0xB,
		ATTACHMENT_GRIP = 0xC,
		ATTACHMENT_HOLO = 0xD,
		ATTACHMENT_IR = 0xE,
		ATTACHMENT_IRONSIGHTS = 0xF,
		ATTACHMENT_LONGBREATH = 0x10,
		ATTACHMENT_MK = 0x11,
		ATTACHMENT_MMS = 0x12,
		ATTACHMENT_RANGEFINDER = 0x13,
		ATTACHMENT_REFLEX = 0x14,
		ATTACHMENT_RF = 0x15,
		ATTACHMENT_SELECTFIRE = 0x16,
		ATTACHMENT_SILENCER = 0x17,
		ATTACHMENT_STACKFIRE = 0x18,
		ATTACHMENT_STALKER = 0x19,
		ATTACHMENT_STEADYAIM = 0x1A,
		ATTACHMENT_SWAYREDUC = 0x1B,
		ATTACHMENT_TACKNIFE = 0x1C,
		ATTACHMENT_VZOOM = 0x1D,
		ATTACHMENT_TYPE_COUNT = 0x1E,
		ATTACHMENT_INVALID = 0x1E,
	};

	enum eAttachmentPoint
	{
		ATTACHMENT_POINT_NONE = 0x0,
		ATTACHMENT_POINT_TOP = 0x1,
		ATTACHMENT_POINT_FIRST = 0x1,
		ATTACHMENT_POINT_BOTTOM = 0x2,
		ATTACHMENT_POINT_TRIGGER = 0x3,
		ATTACHMENT_POINT_MUZZLE = 0x4,
		ATTACHMENT_POINT_GUNPERK = 0x5,
		ATTACHMENT_POINT_COUNT = 0x6,
		ATTACHMENT_POINT_INVALID = 0x6,
	};

	struct WeaponAttachment
	{
		const char *szInternalName;
		const char *szDisplayName;
		eAttachment attachmentType;
		eAttachmentPoint attachmentPoint;
		PenetrateType penetrateType;
		weapFireType_t fireType;
		int firstRaisePriority;
		float fHipIdleAmount;
		bool bAltWeaponAdsOnly;
		bool bAltWeaponDisableSwitching;
		float altScopeADSTransInTime;
		float altScopeADSTransOutTime;
		bool bSilenced;
		bool bDualMag;
		bool laserSight;
		bool bInfraRed;
		bool bUseAsMelee;
		bool bDualWield;
		bool sharedAmmo;
		float fDamageRangeScale;
		float fAdsZoomFov1;
		float fAdsZoomFov2;
		float fAdsZoomFov3;
		float fAdsZoomInFrac;
		float fAdsZoomOutFrac;
		float fAdsTransInTimeScale;
		float fAdsTransOutTimeScale;
		float fAdsRecoilReductionRate;
		float fAdsRecoilReductionLimit;
		float fAdsViewKickCenterSpeedScale;
		float fAdsIdleAmountScale;
		bool swayOverride;
		float swayMaxAngle;
		float swayLerpSpeed;
		float swayPitchScale;
		float swayYawScale;
		float swayHorizScale;
		float swayVertScale;
		bool adsSwayOverride;
		float adsSwayMaxAngle;
		float adsSwayLerpSpeed;
		float adsSwayPitchScale;
		float adsSwayYawScale;
		float fAdsSwayHorizScale;
		float fAdsSwayVertScale;
		float adsMoveSpeedScale;
		float fHipSpreadMinScale;
		float fHipSpreadMaxScale;
		float strafeRotR;
		float standMoveF;
		vec3_t vStandRot;
		float fFireTimeScale;
		float fReloadTimeScale;
		float fReloadEmptyTimeScale;
		float fReloadAddTimeScale;
		float fReloadQuickTimeScale;
		float fReloadQuickEmptyTimeScale;
		float fReloadQuickAddTimeScale;
		bool mmsWeapon;
		bool mmsInScope;
		float mmsFOV;
		float mmsAspect;
		float mmsMaxDist;
		float clipSizeScale;
		int iClipSize;
		unsigned int stackFire;
		float stackFireSpread;
		float stackFireAccuracyDecay;
		unsigned int perks[2];
		float customFloat0;
		float customFloat1;
		float customFloat2;
		int customBool0;
		int customBool1;
		int customBool2;
	};

	struct WeaponAttachmentUnique
	{
		const char *szInternalName;
		eAttachment attachmentType;
		int siblingLink;
		int childLink;
		int combinedAttachmentTypeMask;
		const char *szAltWeaponName;
		unsigned int altWeaponIndex;
		const char *szDualWieldWeaponName;
		unsigned int dualWieldWeaponIndex;
		unsigned __int16 *hideTags;
		XModel *viewModel;
		XModel *viewModelAdditional;
		XModel *viewModelADS;
		XModel *worldModel;
		XModel *worldModelAdditional;
		const char *viewModelTag;
		const char *worldModelTag;
		vec3_t viewModelOffsets;
		vec3_t worldModelOffsets;
		vec3_t viewModelRotations;
		vec3_t worldModelRotations;
		vec3_t viewModelAddOffsets;
		vec3_t worldModelAddOffsets;
		vec3_t viewModelAddRotations;
		vec3_t worldModelAddRotations;
		WeaponCamo *weaponCamo;
		bool disableBaseWeaponAttachment;
		bool disableBaseWeaponClip;
		bool overrideBaseWeaponAttachmentOffsets;
		vec3_t viewModelOffsetBaseAttachment;
		vec3_t worldModelOffsetBaseAttachment;
		Material *overlayMaterial;
		Material *overlayMaterialLowRes;
		weapOverlayReticle_t overlayReticle;
		int iFirstRaiseTime;
		int iAltRaiseTime;
		int iAltDropTime;
		int iReloadAmmoAdd;
		int iReloadStartAdd;
		bool bSegmentedReload;
		const char **szXAnims;
		int animationOverrides[3];
		float *locationDamageMultipliers;
		int soundOverrides;
		const char *fireSound;
		const char *fireSoundPlayer;
		const char *fireLoopSound;
		const char *fireLoopSoundPlayer;
		const char *fireLoopEndSound;
		const char *fireLoopEndSoundPlayer;
		const char *fireStartSound;
		const char *fireStopSound;
		const char *fireStartSoundPlayer;
		const char *fireStopSoundPlayer;
		const char *fireLastSound;
		const char *fireLastSoundPlayer;
		const char *fireKillcamSound;
		const char *fireKillcamSoundPlayer;
		int effectOverrides;
		FxEffectDef *viewFlashEffect;
		FxEffectDef *worldFlashEffect;
		TracerDef *tracerType;
		TracerDef *enemyTracerType;
		float adsDofStart;
		float adsDofEnd;
		int iAmmoIndex;
		int iClipIndex;
		bool bOverrideLeftHandIK;
		bool bOverrideLeftHandProneIK;
		vec3_t ikLeftHandOffset;
		vec3_t ikLeftHandRotation;
		vec3_t ikLeftHandProneOffset;
		vec3_t ikLeftHandProneRotation;
		float customFloat0;
		float customFloat1;
		float customFloat2;
		int customBool0;
		int customBool1;
		int customBool2;
	};

	struct WeaponVariantDef
	{
		const char *szInternalName;
		int iVariantCount;
		WeaponDef *weapDef;
		const char *szDisplayName;
		const char *szAltWeaponName;
		const char *szAttachmentUnique;
		WeaponAttachment **attachments;
		WeaponAttachmentUnique **attachmentUniques;
		const char **szXAnims;
		unsigned __int16 *hideTags;
		XModel **attachViewModel;
		XModel **attachWorldModel;
		const char **attachViewModelTag;
		const char **attachWorldModelTag;
		float attachViewModelOffsets[24];
		float attachWorldModelOffsets[24];
		float attachViewModelRotations[24];
		float attachWorldModelRotations[24];
		vec3_t stowedModelOffsets;
		vec3_t stowedModelRotations;
		unsigned int altWeaponIndex;
		int iAttachments;
		bool bIgnoreAttachments;
		int iClipSize;
		int iReloadTime;
		int iReloadEmptyTime;
		int iReloadQuickTime;
		int iReloadQuickEmptyTime;
		int iAdsTransInTime;
		int iAdsTransOutTime;
		int iAltRaiseTime;
		const char *szAmmoDisplayName;
		const char *szAmmoName;
		int iAmmoIndex;
		const char *szClipName;
		int iClipIndex;
		float fAimAssistRangeAds;
		float fAdsSwayHorizScale;
		float fAdsSwayVertScale;
		float fAdsViewKickCenterSpeed;
		float fHipViewKickCenterSpeed;
		float fAdsZoomFov1;
		float fAdsZoomFov2;
		float fAdsZoomFov3;
		float fAdsZoomInFrac;
		float fAdsZoomOutFrac;
		float fOverlayAlphaScale;
		float fOOPosAnimLength[2];
		bool bSilenced;
		bool bDualMag;
		bool bInfraRed;
		bool bTVGuided;
		unsigned int perks[2];
		bool bAntiQuickScope;
		Material *overlayMaterial;
		Material *overlayMaterialLowRes;
		Material *dpadIcon;
		weaponIconRatioType_t dpadIconRatio;
		bool noAmmoOnDpadIcon;
		bool mmsWeapon;
		bool mmsInScope;
		float mmsFOV;
		float mmsAspect;
		float mmsMaxDist;
		vec3_t ikLeftHandIdlePos;
		vec3_t ikLeftHandOffset;
		vec3_t ikLeftHandRotation;
		bool bUsingLeftHandProneIK;
		vec3_t ikLeftHandProneOffset;
		vec3_t ikLeftHandProneRotation;
		vec3_t ikLeftHandUiViewerOffset;
		vec3_t ikLeftHandUiViewerRotation;
	};

	struct cspField_t
	{
		const char *szName;
		int iOffset;
		int iFieldType;
	};

	struct WeaponFullDef
	{
		WeaponVariantDef weapVariantDef;
		WeaponDef weapDef;
		WeaponAttachment *attachments[63];
		WeaponAttachmentUnique *attachmentUniques[95];
		XModel *gunXModel[16];
		const char *szXAnims[88];
		unsigned __int16 hideTags[32];
		unsigned __int16 notetrackSoundMapKeys[20];
		unsigned __int16 notetrackSoundMapValues[20];
		XModel *worldModel[16];
		XModel *attachViewModel[8];
		XModel *attachWorldModel[8];
		const char *attachViewModelTag[8];
		const char *attachWorldModelTag[8];
		float parallelBounce[32];
		float perpendicularBounce[32];
		float locationDamageMultipliers[21];
		char weaponCamo[64];
	};

	enum SndMenuCategory
	{
		SND_CATEGORY_SFX = 0x0,
		SND_CATEGORY_MUSIC = 0x1,
		SND_CATEGORY_VOICE = 0x2,
		SND_CATEGORY_UI = 0x3,
		SND_CATEGORY_CINEMATIC = 0x4,
		SND_CATEGORY_COUNT = 0x5,
	};

	struct SndVolumeGroup
	{
		char name[32];
		char parentName[32];
		unsigned int id;
		int parentIndex;
		SndMenuCategory category;
		unsigned __int16 attenuationSp;
		unsigned __int16 attenuationMp;
	};

	struct SndCurve
	{
		char name[32];
		unsigned int id;
		vec2_t points[8];
	};

	struct SndPan
	{
		char name[32];
		unsigned int id;
		float front;
		float back;
		float center;
		float lfe;
		float left;
		float right;
	};

	struct SndDuckGroup
	{
		char name[32];
		unsigned int id;
	};

	struct SndContext
	{
		unsigned int type;
		unsigned int values[8];
	};

	struct SndMaster
	{
		char name[32];
		unsigned int id;
		int lowE;
		float lowG;
		float lowF;
		float lowQ;
		int peak1E;
		float peak1G;
		float peak1F;
		float peak1Q;
		int peak2E;
		float peak2G;
		float peak2F;
		float peak2Q;
		int hiE;
		float hiG;
		float hiF;
		float hiQ;
		float eqG;
		int compE;
		float compPG;
		float compMG;
		float compT;
		float compR;
		float compTA;
		float compTR;
		int limitE;
		float limitPG;
		float limitMG;
		float limitT;
		float limitR;
		float limitTA;
		float limitTR;
		float busReverbG;
		float busFxG;
		float busVoiceG;
		float busPfutzG;
		float busHdrfxG;
		float busUiG;
		float busMusicG;
		float busMovieG;
		float busVcsG;
		int busReverbE;
		int busFxE;
		int busVoiceE;
		int busPfutzE;
		int busHdrfxE;
		int busUiE;
		int busMusicE;
		int busMovieE;
		int hdrfxCompE;
		int voiceEqE;
		int voiceCompE;
	};

	struct SndSidechainDuck
	{
		char name[32];
		unsigned int id;
		float g;
		float f;
		float q;
		float ta;
		float tr;
		float tf;
	};

	struct SndFutz
	{
		char name[32];
		unsigned int id;
		float bpfF;
		float bpfQ;
		float lsG;
		float lsF;
		float lsQ;
		float dist;
		float preG;
		float postG;
		float th;
		float tg;
		float clippre;
		float clippost;
		float blend;
		unsigned int startAliasId;
		unsigned int stopAliasId;
		unsigned int loopAliasId;
	};

	struct SndDriverGlobals
	{
		const char *name;
		unsigned int groupCount;
		SndVolumeGroup *groups;
		unsigned int curveCount;
		SndCurve *curves;
		unsigned int panCount;
		SndPan *pans;
		unsigned int duckGroupCount;
		SndDuckGroup *duckGroups;
		unsigned int contextCount;
		SndContext *contexts;
		unsigned int masterCount;
		SndMaster *masters;
		unsigned int voiceDuckCount;
		SndSidechainDuck *voiceDucks;
		unsigned int futzCount;
		SndFutz *futzes;
	};

	struct FxImpactEntry
	{
		FxEffectDef *nonflesh[32];
		FxEffectDef *flesh[4];
	};

	struct FxImpactTable
	{
		const char *name;
		FxImpactEntry *table;
	};

	struct RawFile
	{
		const char *name;
		int len;
		const char *buffer;
	};

	struct StringTableCell
	{
		const char *string;
		int hash;
	};

	struct StringTable
	{
		const char *name;
		int columnCount;
		int rowCount;
		StringTableCell *values;
		__int16 *cellIndex;
	};

	enum LbColType
	{
		LBCOL_TYPE_NUMBER = 0x0,
		LBCOL_TYPE_TIME = 0x1,
		LBCOL_TYPE_LEVELXP = 0x2,
		LBCOL_TYPE_PRESTIGE = 0x3,
		LBCOL_TYPE_BIGNUMBER = 0x4,
		LBCOL_TYPE_PERCENT = 0x5,
		LBCOL_TYPE_TIME_FULL = 0x6,
		LBCOL_TYPE_COUNT = 0x7,
	};

	enum LbAggType
	{
		LBAGG_TYPE_MIN = 0x0,
		LBAGG_TYPE_MAX = 0x1,
		LBAGG_TYPE_ADD = 0x2,
		LBAGG_TYPE_REPLACE = 0x3,
		LBAGG_TYPE_COUNT = 0x4,
	};

	struct LbColumnDef
	{
		const char *name;
		int colId;
		int dwColIndex;
		bool hidden;
		const char *statName;
		LbColType type;
		int precision;
		LbAggType agg;
		const char *localization;
		int uiCalColX;
		int uiCalColY;
	};

	enum LbUpdateType
	{
		LBUPDATE_TYPE_NORMAL = 0x0,
		LBUPDATE_TYPE_RANK = 0x1,
		LBUPDATE_TYPE_COMBINE = 0x2,
		LBUPDATE_TYPE_COUNT = 0x3,
	};

	struct LeaderboardDef
	{
		const char *name;
		unsigned int id;
		int columnCount;
		int dwColumnCount;
		int xpColId;
		int prestigeColId;
		LbColumnDef *columns;
		LbUpdateType updateType;
		int trackTypes;
	};

	struct gump_info_t
	{
		char *name;
		int size;
	};

	struct overlay_info_t
	{
		char *name;
		int size;
	};

	struct XGlobals
	{
		const char *name;
		int xanimStreamBufferSize;
		int cinematicMaxWidth;
		int cinematicMaxHeight;
		int extracamResolution;
		vec4_t screenClearColor;
		int bigestGumpSize;
		int gumpsCount;
		gump_info_t gumps[32];
		int bigestOverlaySize;
		int overlayCount;
		overlay_info_t overlays[32];
	};

	struct ddlMemberDef_t
	{
		const char *name;
		int size;
		int offset;
		int type;
		int externalIndex;
		unsigned int rangeLimit;
		unsigned int serverDelta;
		unsigned int clientDelta;
		int arraySize;
		int enumIndex;
		int permission;
	};

	struct ddlHash_t
	{
		int hash;
		int index;
	};

	struct ddlStructDef_t
	{
		const char *name;
		int size;
		int memberCount;
		ddlMemberDef_t *members;
		ddlHash_t *hashTable;
	};

	struct ddlEnumDef_t
	{
		const char *name;
		int memberCount;
		const char **members;
		ddlHash_t *hashTable;
	};

	struct ddlDef_t
	{
		int version;
		int size;
		ddlStructDef_t *structList;
		int structCount;
		ddlEnumDef_t *enumList;
		int enumCount;
		ddlDef_t *next;
	};

	struct ddlRoot_t
	{
		const char *name;
		ddlDef_t *ddlDef;
	};

	struct GlassDef
	{
		const char *name;
		int maxHealth;
		float thickness;
		float minShardSize;
		float maxShardSize;
		float shardLifeProbablility;
		int maxShards;
		Material *pristineMaterial;
		Material *crackedMaterial;
		Material *shardMaterial;
		const char *crackSound;
		const char *shatterShound;
		const char *autoShatterShound;
		FxEffectDef *crackEffect;
		FxEffectDef *shatterEffect;
	};

	struct Glass
	{
		unsigned int numCellIndices;
		unsigned __int16 cellIndices[6];
		GlassDef *glassDef;
		unsigned int index;
		unsigned int brushModel;
		vec3_t origin;
		vec3_t angles;
		vec3_t absmin;
		vec3_t absmax;
		bool isPlanar;
		char numOutlineVerts;
		char binormalSign;
		vec2_t *outline;
		vec3_t outlineAxis[3];
		vec3_t outlineOrigin;
		float uvScale;
		float thickness;
	};

	struct Glasses
	{
		const char *name;
		unsigned int numGlasses;
		Glass *glasses;
		char *workMemory;
		unsigned int workMemorySize;
		unsigned int smallAllocatorBlocks;
		unsigned int maxGroups;
		unsigned int maxShards;
		unsigned int maxPhysics;
		unsigned int shardMemorySize;
		unsigned int maxFreeCmd;
		unsigned int numSlots;
		unsigned int numVerts;
		unsigned int numIndices;
	};

	struct EmblemLayer
	{
		int cost;
		int unlockLevel;
		int unlockPLevel;
	};

	struct EmblemCategory
	{
		const char *name;
		const char *description;
	};

	struct EmblemIconType
	{
		const char *name;
		const char *description;
	};

	struct EmblemBGCategory
	{
		const char *name;
		const char *description;
	};

	struct EmblemIcon
	{
		GfxImage *image;
		const char *description;
		float outlineSize;
		int cost;
		int unlockLevel;
		int unlockPLevel;
		int unclassifyAt;
		int sortKey;
		unsigned __int16 iconType;
		unsigned __int16 category;
	};

	struct EmblemBackground
	{
		Material *material;
		const char *description;
		int cost;
		int unlockLevel;
		int unlockPLevel;
		int unclassifyAt;
		int sortKey;
		unsigned __int16 bgCategory;
		int mtxIndex;
	};

	struct EmblemSet
	{
		int colorCount;
		int layerCount;
		EmblemLayer layers[32];
		int categoryCount;
		EmblemCategory categories[16];
		int iconTypeCount;
		EmblemIconType iconTypes[16];
		int bgCategoryCount;
		EmblemBGCategory bgCategories[16];
		int iconCount;
		EmblemIcon icons[1024];
		int backgroundCount;
		EmblemBackground backgrounds[550];
		int backgroundLookupCount;
		__int16 backgroundLookup[550];
	};

	struct ScriptParseTree
	{
		const char *name;
		int len;
		char *buffer;
	};

	struct KeyValuePair
	{
		int keyHash;
		int namespaceHash;
		const char *value;
	};

	struct KeyValuePairs
	{
		const char *name;
		int numVariables;
		KeyValuePair *keyValuePairs;
	};

	struct view_limits_t
	{
		float horizSpanLeft;
		float horizSpanRight;
		float vertSpanUp;
		float vertSpanDown;
		float horizResistLeft;
		float horizResistRight;
		float vertResistUp;
		float vertResistDown;
	};

	enum DevEventType
	{
		EVENT_ACTIVATE = 0x0,
		EVENT_DEACTIVATE = 0x1,
		EVENT_ACCEPT = 0x2,
		EVENT_UPDATE = 0x3,
		EVENT_DRAW = 0x4,
		EVENT_SAVE = 0x5,
	};

	enum errorParm_t
	{
		ERR_FATAL = 0x0,
		ERR_DROP = 0x1,
		ERR_FROM_STARTUP = 0x2,
		ERR_SERVERDISCONNECT = 0x3,
		ERR_DISCONNECT = 0x4,
		ERR_SCRIPT = 0x5,
		ERR_SCRIPT_DROP = 0x6,
		ERR_LOCALIZATION = 0x7,
	};

	enum LocalClientNum_t
	{
		INVALID_LOCAL_CLIENT = 0xFFFFFFFF,
		LOCAL_CLIENT_FIRST = 0x0,
		LOCAL_CLIENT_0 = 0x0,
		ONLY_LOCAL_CLIENT = 0x0,
		LOCAL_CLIENT_COUNT = 0x1,
	};

	enum ControllerIndex_t
	{
		INVALID_CONTROLLER_PORT = 0xFFFFFFFF,
		CONTROLLER_INDEX_FIRST = 0x0,
		CONTROLLER_INDEX_0 = 0x0,
		CONTROLLER_INDEX_COUNT = 0x1,
	};

	struct DevGraph
	{
		vec2_t *knots;
		int *knotCount;
		int knotCountMax;
		int selectedKnot;
		void(__cdecl *eventCallback)(DevGraph *, DevEventType, LocalClientNum_t);
		void(__cdecl *textCallback)(DevGraph *, const float, const float, char *, const int);
		void *data;
		bool disableEditingEndPoints;
	};

	struct GraphFloat
	{
		char name[64];
		vec2_t knots[32];
		int knotCount;
		float scale;
		DevGraph devguiGraph;
	};

	enum TractionType
	{
		TRACTION_TYPE_FRONT = 0x0,
		TRACTION_TYPE_BACK = 0x1,
		TRACTION_TYPE_ALL_WD = 0x2,
		NUM_TRACTION_TYPES = 0x3,
	};

	struct VehicleParameter
	{
		float m_speed_max;
		float m_accel_max;
		float m_reverse_scale;
		float m_steer_angle_max;
		float m_steer_angle_speed_scale;
		float m_steer_speed;
		float m_wheel_radius;
		float m_susp_spring_k;
		float m_susp_damp_k;
		float m_susp_adj;
		float m_susp_hard_limit;
		float m_susp_min_height;
		float m_tire_fric_fwd;
		float m_tire_fric_side;
		float m_tire_fric_brake;
		float m_tire_fric_hand_brake;
		float m_body_mass;
		float m_roll_stability;
		float m_pitch_stability;
		float m_pitch_roll_resistance;
		float m_yaw_resistance;
		float m_upright_strength;
		float m_tilt_fakey;
		float m_peel_out_max_speed;
		float m_tire_damp_coast;
		float m_tire_damp_brake;
		float m_tire_damp_hand;
		float m_auto_hand_brake_min_speed;
		TractionType m_traction_type;
		const char *m_name;
		vec3_t m_bbox_min;
		vec3_t m_bbox_max;
		vec3_t m_mass_center_offset;
		vec3_t m_buoyancybox_min;
		vec3_t m_buoyancybox_max;
		float m_water_speed_max;
		float m_water_accel_max;
		float m_water_turn_accel;
		float m_water_turn_speed_max;
		float m_water_ebrake_power;
		vec3_t m_boat_motor_offset;
		float m_boat_speed_rise;
		float m_boat_speed_tilt;
		float m_boat_side_fric_scale;
		float m_boat_forward_fric_scale;
		float m_boat_vertical_fric_scale;
		float m_jump_force;
		float m_tire_fric_side_max;
		bool m_drive_on_walls;
		float m_linear_drag_scale;
		float m_angular_drag_scale;
	};

	struct VehicleDriveBySound
	{
		int apex;
		const char *name;
		unsigned int alias;
	};

	struct VehicleEngineSound
	{
		const char *name;
		unsigned int alias;
		float params[5];
	};

	struct VehicleGearData
	{
		float minRPM;
		float maxRPM;
		float ratio;
	};

	struct VehicleEngine
	{
		float idleRpms;
		float maxRpms;
		float maxTorque;
		float brakingCoeff;
		vec4_t loadFadeParams;
		float loadScale;
		float loadSmoothing;
		float throttleLag;
		float pitchScale;
		VehicleEngineSound onload[5];
		VehicleEngineSound offload[5];
		int numGears;
		int loopLastGear;
		VehicleGearData gears[10];
	};

	struct VehicleAntenna
	{
		float springK;
		float damp;
		float length;
		float gravity;
	};

	const struct VehicleDef
	{
		const char *name;
		__int16 type;
		int remoteControl;
		int bulletDamage;
		int armorPiercingDamage;
		int grenadeDamage;
		int projectileDamage;
		int projectileSplashDamage;
		int heavyExplosiveDamage;
		__int16 cameraMode;
		int autoRecenterOnAccel;
		int thirdPersonDriver;
		int thirdPersonUseVehicleRoll;
		int thirdPersonCameraPitchVehicleRelative;
		int thirdPersonCameraHeightWorldRelative;
		float thirdPersonCameraRange;
		float thirdPersonCameraMinPitchClamp;
		float thirdPersonCameraMaxPitchClamp;
		float thirdPersonCameraHeight[2];
		float thirdPersonCameraPitch[2];
		int cameraAlwaysAutoCenter;
		float cameraAutoCenterLerpRate;
		float cameraAutoCenterMaxLerpRate;
		float thirdPersonCameraSpringDistance;
		float thirdPersonCameraSpringTime;
		float thirdPersonCameraHandbrakeTurnRateInc;
		float cameraFOV;
		float cameraRollFraction;
		vec3_t tagPlayerOffset;
		int killcamCollision;
		float killcamDist;
		float killcamZDist;
		float killcamMinDist;
		float killcamZTargetOffset;
		float killcamFOV;
		float killcamNearBlur;
		float killcamNearBlurStart;
		float killcamNearBlurEnd;
		float killcamFarBlur;
		float killcamFarBlurStart;
		float killcamFarBlurEnd;
		int isDrivable;
		int numberOfSeats;
		int numberOfGunners;
		int seatSwitchOrder[11];
		int driverControlledGunPos;
		float entryPointRadius[5];
		float texScrollScale;
		float wheelRotRate;
		float extraWheelRotScale;
		int wheelChildTakesSteerYaw;
		float maxSpeed;
		float maxSpeedVertical;
		float accel;
		float accelVertical;
		float rotRate;
		float rotAccel;
		float maxBodyPitch;
		float maxBodyRoll;
		float collisionDamage;
		float collisionSpeed;
		float suspensionTravel;
		float heliCollisionScalar;
		float viewPitchOffset;
		float viewInfluence;
		float tiltFromAcceleration[2];
		float tiltFromDeceleration[2];
		float tiltFromVelocity[2];
		float tiltSpeed[2];
		const char *turretWeapon;
		view_limits_t turretViewLimits;
		float turretRotRate;
		int turretClampPlayerView;
		int turretLockTurretToPlayerView;
		const char *gunnerWeapon[4];
		unsigned __int16 gunnerWeaponIndex[4];
		float gunnerRotRate;
		vec2_t gunnerRestAngles[4];
		view_limits_t passengerViewLimits[6];
		const char *sndNames[2];
		unsigned int sndIndices[2];
		const char *sndMaterialNames[3];
		float skidSpeedMin;
		float skidSpeedMax;
		const char *futzName;
		float futzBlend;
		int animType;
		const char *animSet;
		int scriptedAnimationEntry;
		float mantleAngles[4];
		unsigned __int16 extraWheelTags[4];
		unsigned __int16 driverHideTag;
		XModel *attachmentModels[4];
		unsigned __int16 attachmentTags[4];
		XModel *deathAttachmentModels[4];
		unsigned __int16 deathAttachmentTags[4];
		float tracerOffset[2];
		XModel *model;
		XModel *viewModel;
		XModel *deathModel;
		XModel *enemyModel;
		float modelSwapDelay;
		FxEffectDef *exhaustFx;
		int oneExhaust;
		FxEffectDef *treadFx[32];
		FxEffectDef *deathFx;
		unsigned __int16 deathFxTag;
		const char *deathFxSound;
		FxEffectDef *lightFx[4];
		unsigned __int16 lightFxTag[4];
		FxEffectDef *friendlyLightFx;
		unsigned __int16 friendlyLightFxTag;
		FxEffectDef *enemyLightFx;
		unsigned __int16 enemyLightFxTag;
		float radiusDamageMin;
		float radiusDamageMax;
		float radiusDamageRadius;
		const char *shootShock;
		const char *shootRumble;
		float deathQuakeScale;
		float deathQuakeDuration;
		float deathQuakeRadius;
		const char *rumbleType;
		float rumbleScale;
		float rumbleDuration;
		float rumbleRadius;
		float rumbleBaseTime;
		float rumbleAdditionalTime;
		int healthDefault;
		int healthMin;
		int healthMax;
		int eTeam;
		int boostAccelMultiplier;
		float boostDuration;
		float boostSpeedIncrease;
		int addToCompass;
		int addToCompassEnemy;
		const char *compassIcon;
		Material *compassIconMaterial;
		const char *gasButtonName;
		int gasButton;
		const char *reverseBrakeButtonName;
		int reverseBrakeButton;
		const char *handBrakeButtonName;
		int handBrakeButton;
		const char *attackButtonName;
		int attackButton;
		const char *attackSecondaryButtonName;
		int attackSecondaryButton;
		const char *boostButtonName;
		int boostButton;
		const char *moveUpButtonName;
		int moveUpButton;
		const char *moveDownButtonName;
		int moveDownButton;
		const char *switchSeatButtonName;
		int switchSeatButton;
		const char *steerGraphName;
		GraphFloat *steerGraph;
		const char *accelGraphName;
		GraphFloat *accelGraph;
		int isNitrous;
		int isFourWheelSteering;
		int useCollmap;
		float radius;
		float minHeight;
		float maxHeight;
		float max_fric_tilt_angle;
		float max_fric_tilt;
		int noDirectionalDamage;
		int fakeBodyStabilizer;
		float vehHelicopterBoundsRadius;
		float vehHelicopterDecelerationFwd;
		float vehHelicopterDecelerationSide;
		float vehHelicopterDecelerationUp;
		float vehHelicopterTiltFromControllerAxes;
		float vehHelicopterTiltFromFwdAndYaw;
		float vehHelicopterTiltFromFwdAndYaw_VelAtMaxTilt;
		float vehHelicopterTiltMomentum;
		int vehHelicopterQuadRotor;
		int vehHelicopterAccelTwardsView;
		float maxRotorArmMovementAngle;
		float maxRotorArmRotationAngle;
		int vehHelicopterMaintainHeight;
		int vehHelicopterMaintainMaxHeight;
		float vehHelicopterMaintainHeightLimit;
		float vehHelicopterMaintainHeightAccel;
		float vehHelicopterMaintainHeightMinimum;
		float vehHelicopterMaintainHeightMaximum;
		float vehHelicopterMaintainCeilingMinimum;
		int joltVehicle;
		int joltVehicleDriver;
		float joltMaxTime;
		float joltTime;
		float joltWaves;
		float joltIntensity;
		VehicleParameter nitrousVehParams;
		float driveBySoundRadius[2];
		VehicleDriveBySound driveBySounds[40];
		int doFootSteps;
		int isSentient;
		VehicleEngine engine;
		VehicleAntenna antenna[2];
		char *csvInclude;
		float customFloat0;
		float customFloat1;
		float customFloat2;
		int customBool0;
		int customBool1;
		int customBool2;
	};

	struct MemoryBlock
	{
		const char *name;
		bool mainMem;
		bool videoMem;
		bool streamMem;
		unsigned int size;
		unsigned int alignment;
		char *data;
	};

	struct AddonMapEnts
	{
		const char *name;
		char *entityString;
		int numEntityChars;
		MapTriggers trigger;
		ClipInfo *info;
		unsigned int numSubModels;
		cmodel_t *cmodels;
		GfxBrushModel *models;
	};

	struct SkinnedVertsDef
	{
		const char *name;
		unsigned int maxSkinnedVerts;
	};

	struct Qdb
	{
		const char *name;
		int len;
		char *buffer;
	};

	struct Slug
	{
		const char *name;
		int len;
		char *buffer;
	};

	struct FootstepTableDef
	{
		const char *name;
		unsigned int sndAliasTable[32][7];
	};

	struct FootstepFXTableDef
	{
		const char *name;
		FxEffectDef *footstepFX[32];
	};

	struct ZBarrierBoard
	{
		XModel *pBoardModel;
		XModel *pAlternateBoardModel;
		XModel *pUpgradedBoardModel;
		const char *pTearAnim;
		const char *pBoardAnim;
		FxEffectDef *repairEffect1;
		FxEffectDef *repairEffect2;
		vec3_t repairEffect1Offset;
		vec3_t repairEffect2Offset;
		unsigned int boardRepairSound;
		unsigned int boardRepairHoverSound;
		unsigned int pauseAndRepeatRepSound;
		float minPause;
		float maxPause;
		unsigned __int16 zombieBoardTearStateName;
		unsigned __int16 zombieBoardTearSubStateName;
		unsigned int numRepsToPullProBoard;
	};

	struct ZBarrierDef
	{
		const char *name;
		unsigned int generalRepairSound1;
		unsigned int generalRepairSound2;
		unsigned int upgradedGeneralRepairSound1;
		unsigned int upgradedGeneralRepairSound2;
		unsigned int delayBetweenRepSounds;
		float delayBetweenRepSoundsDuration;
		unsigned int earthquakeOnRepair;
		float earthquakeMinScale;
		float earthquakeMaxScale;
		float earthquakeMinDuration;
		float earthquakeMaxDuration;
		float earthquakeRadius;
		int numBoardsInBarrier;
		unsigned int autoHideOpenPieces;
		unsigned int taunts;
		unsigned int reachThroughAttacks;
		unsigned __int16 zombieTauntAnimState;
		unsigned __int16 zombieReachThroughAnimState;
		int numAttackSlots;
		float attackSpotHorzOffset;
		ZBarrierBoard boards[6];
	};

	union XAssetHeader
	{
		void *data;
		XModelPieces *xmodelPieces;
		PhysPreset *physPreset;
		PhysConstraints *physConstraints;
		DestructibleDef *destructibleDef;
		XAnimParts *parts;
		XModel *model;
		Material *material;
		MaterialPixelShader *pixelShader;
		MaterialVertexShader *vertexShader;
		MaterialTechniqueSet *techniqueSet;
		GfxImage *image;
		SndBank *sound;
		SndPatch *soundPatch;
		clipMap_t *clipMap;
		ComWorld *comWorld;
		GameWorldSp *gameWorldSp;
		GameWorldMp *gameWorldMp;
		MapEnts *mapEnts;
		GfxWorld *gfxWorld;
		GfxLightDef *lightDef;
		Font_s *font;
		FontIcon *fontIcon;
		MenuList *menuList;
		menuDef_t *menu;
		LocalizeEntry *localize;
		WeaponVariantDef *weapon;
		WeaponAttachment *attachment;
		WeaponAttachmentUnique *attachmentUnique;
		WeaponCamo *weaponCamo;
		SndDriverGlobals *sndDriverGlobals;
		FxEffectDef *fx;
		FxImpactTable *impactFx;
		RawFile *rawfile;
		StringTable *stringTable;
		LeaderboardDef *leaderboardDef;
		XGlobals *xGlobals;
		ddlRoot_t *ddlRoot;
		Glasses *glasses;
		//TextureList *textureList;
		void *textureList;
		EmblemSet *emblemSet;
		ScriptParseTree *scriptParseTree;
		KeyValuePairs *keyValuePairs;
		VehicleDef *vehicleDef;
		MemoryBlock *memoryBlock;
		AddonMapEnts *addonMapEnts;
		TracerDef *tracerDef;
		SkinnedVertsDef *skinnedVertsDef;
		Qdb *qdb;
		Slug *slug;
		FootstepTableDef *footstepTableDef;
		FootstepFXTableDef *footstepFXTableDef;
		ZBarrierDef *zbarrierDef;
	};

	struct XAsset
	{
		XAssetType type;
		XAssetHeader header;
	};

	struct ScriptStringList
	{
		int count;
		const char **strings;
	};

	struct XAssetList
	{
		ScriptStringList stringList;
		int dependCount;
		const char **depends;
		int assetCount;
		XAsset *assets;
	};

	struct XAssetEntry
	{
		XAsset asset;
		char zoneIndex;
		bool inuse;
		unsigned __int16 nextHash;
		unsigned __int16 nextOverride;
		unsigned __int16 usageFrame;
	};

	union XAssetEntryPoolEntry
	{
		XAssetEntry entry;
		XAssetEntryPoolEntry *next;
	};

	enum DB_ZONE_LOADTYPES
	{
		DB_ZONE_PRE_GFX = 0x00000001,
		DB_ZONE_PATCH = 0x00000002,
		DB_ZONE_PATCH_LOC = 0x00000004,
		DB_ZONE_CODE = 0x00000008,
		DB_ZONE_CODE_LOC = 0x00000010,
		DB_ZONE_CODE_RES = 0x00000020,
		DB_ZONE_DEV = 0x00000040,
		DB_ZONE_COMMON = 0x00000080,
		DB_ZONE_COMMON_PATCH = 0x00000100,
		DB_ZONE_COMMON_LOC = 0x00000200,
		DB_ZONE_LOAD = 0x00000400,
		DB_ZONE_SHARED_PATCH = 0x00000800,
		DB_ZONE_SHARED = 0x00001000,
		DB_ZONE_SHARED_LOC = 0x00002000,
		DB_ZONE_LEVEL_PATCH = 0x00004000,
		DB_ZONE_LEVEL = 0x00008000,
		DB_ZONE_LEVEL_LOC = 0x00010000,
		DB_ZONE_LEVELOVERLAY_PATCH = 0x00020000,
		DB_ZONE_LEVELOVERLAY = 0x00040000,
		DB_ZONE_LEVELOVERLAY_LOC = 0x00080000,
		DB_ZONE_WEAPONS = 0x00100000,
		DB_ZONE_GUMP = 0x00200000,
		DB_ZONE_LOW_MARKER = 0x00400000,
		DB_ZONE_CUSTOM_TYPE = 0x00800000, // Custom type
		DB_ZONE_MYCHANGES = 0x01000000,
		DB_ZONE_FRONTEND = 0x02000000,
		DB_ZONE_FRONTEND_LOC = 0x04000000,
		DB_ZONE_PATCH_UI = 0x08000000,
		DB_ZONE_PATCH_UI_LOC = 0x10000000,
		DB_ZONE_FFOTD = 0x20000000,
		DB_ZONE_HIGH_MARKER = 0x40000000,
		DB_FLAG_STRICTFREE = 0x80000000,
	};

	struct XZoneInfo
	{
		const char *name;
		int allocFlags;
		int freeFlags;
	};

	struct XZoneInfoInternal
	{
		char name[64];
		int flags;
	};

	enum XZoneState
	{
		XZONE_UNLOADING = 0xFFFFFFFF,
		XZONE_EMPTY = 0x0,
		XZONE_LOADING = 0x1,
		XZONE_LOADED = 0x2,
		XZONE_COMPLETE = 0x3,
	};

	struct XZoneName
	{
		char name[64];
		int flags;
		int fileSize;
		XZoneState state;
	};

	enum XFILE_BLOCK_TYPES
	{
		XFILE_BLOCK_TEMP = 0x0,
		XFILE_BLOCK_RUNTIME_VIRTUAL = 0x1,
		XFILE_BLOCK_RUNTIME_PHYSICAL = 0x2,
		XFILE_BLOCK_DELAY_VIRTUAL = 0x3,
		XFILE_BLOCK_DELAY_PHYSICAL = 0x4,
		XFILE_BLOCK_VIRTUAL = 0x5,
		XFILE_BLOCK_PHYSICAL = 0x6,
		XFILE_BLOCK_STREAMER_RESERVE = 0x7,
		MAX_XFILE_COUNT = 0x8,

		XFILE_BLOCK_INVALID = -1
	};

	struct XBlock
	{
		char *data;
		unsigned int size;
	};

	struct XZone
	{
		unsigned __int16 index;
		int flags;
		XBlock blocks[MAX_XFILE_COUNT];
	};

	struct __declspec(align(128)) DB_LOAD_STREAM
	{
		char decompressedData[32768];
		char checksum[32];
		char *compressedData;
		int compressedDataAvail;
		int decompressedDataAvail;
		int decompressedDataOffset;
		bool busy;
	};

	struct DBDecompressCmd_t
	{
		int which;
		DB_LOAD_STREAM *stream;
		char *ioBuffer;
		char iv[8];
	};

	struct __declspec(align(128)) DB_LoadData
	{
		int f;
		const char *filename;
		XBlock *blocks;
		int flags;
		void(__cdecl *interrupt)();
		int allocType;
		unsigned __int64 readOffset;
		unsigned __int64 endOffset;
		char *ioBuffer;
		int ioBufferOffset;
		char *compressData;
		int tail;
		int head;
		DBDecompressCmd_t cmd[4];
		__declspec(align(128)) DB_LOAD_STREAM stream[4];
		int next_buffer;
		int locks[4];
		bool loadPending[4];
		bool abort;
		int requiredVersion;
		int lastError;
		int startTime;
	};

	struct XFile
	{
		unsigned int size;
		unsigned int externalSize;
		unsigned int blockSize[MAX_XFILE_COUNT];
	};

	enum Q_DATA_TYPE
	{
		Q_DATA_TYPE_INT = 0x0,
		Q_DATA_TYPE_FLOAT = 0x1,
		Q_DATA_TYPE_BLOB = 0x2,
		Q_DATA_TYPE_STRING = 0x3,
		Q_DATA_TYPE_ISTRING = 0x4,
	};

	struct Q_COLUMN
	{
		Q_DATA_TYPE column_type;
		char *column_name;
	};

	struct Q_TABLE
	{
		char *name;
		unsigned int column_count;
		unsigned int primary_key_column;
		Q_COLUMN *column;
		unsigned int row_count;
		void *data;
	};

	struct Q_DB
	{
		char *name;
		unsigned int table_count;
		Q_TABLE *tables;
	};

	struct Q_DB_HEADER
	{
		char magic_version[8];
		unsigned int fixup_count;
		unsigned int fixup_offset;
		unsigned int string_count;
		void *strings;
		unsigned int num_db;
		Q_DB *db;
	};

	enum consoleChannel_e
	{
		CON_CHANNEL_DONT_FILTER = 0x0,
		CON_CHANNEL_ERROR = 0x1,
		CON_CHANNEL_GAMENOTIFY = 0x2,
		CON_CHANNEL_BOLDGAME = 0x3,
		CON_CHANNEL_OBJNOTIFY = 0x4,
		CON_CHANNEL_SUBTITLE = 0x5,
		CON_CHANNEL_OBITUARY = 0x6,
		CON_CHANNEL_COOPINFO = 0x7,
		CON_CHANNEL_LOGFILEONLY = 0x8,
		CON_CHANNEL_CONSOLEONLY = 0x9,
		CON_CHANNEL_SYSTEM = 0xA,
		CON_CHANNEL_NETWORK = 0xB,
		CON_CHANNEL_TASK = 0xC,
		CON_CHANNEL_GFX = 0xD,
		CON_CHANNEL_SOUND = 0xE,
		CON_CHANNEL_FILES = 0xF,
		CON_CHANNEL_UI = 0x10,
		CON_CHANNEL_AI = 0x11,
		CON_CHANNEL_ANIM = 0x12,
		CON_CHANNEL_PHYS = 0x13,
		CON_CHANNEL_FX = 0x14,
		CON_CHANNEL_SCRIPT = 0x15,
		CON_CHANNEL_TL = 0x16,
		CON_CHANNEL_PERFORMANCE = 0x17,
		CON_CHANNEL_DEVGUI = 0x18,
		CON_CHANNEL_CLIENT = 0x19,
		CON_CHANNEL_SERVER = 0x1A,
		CON_CHANNEL_PLAYERWEAP = 0x1B,
		CON_CHANNEL_LIVE = 0x1C,
		CON_CHANNEL_FROMSCRIPT = 0x1D,
		CON_CHANNEL_SPAWNSYSTEM = 0x1E,
		CON_CHANNEL_LEADERBOARDS = 0x1F,
		CON_CHANNEL_DDL = 0x20,
		CON_CHANNEL_SPU = 0x21,
		CON_CHANNEL_GAMERPROFILE = 0x22,
		CON_CHANNEL_PRESENCE = 0x23,
		CON_CHANNEL_RUMBLE = 0x24,
		CON_CHANNEL_UNLOCKABLES = 0x25,
		CON_CHANNEL_VOICE = 0x26,
		CON_CHANNEL_HTTP = 0x27,
		CON_CHANNEL_GFWL = 0x28,
		CON_CHANNEL_IPAK = 0x29,
		CON_CHANNEL_WEBM = 0x2A,
		CON_CHANNEL_PROBER = 0x2B,
		CON_CHANNEL_MIPSTER = 0x2C,
		CON_CHANNEL_STEAM = 0x2D,
		CON_CHANNEL_SOCIAL = 0x2E,
		CON_CHANNEL_DCACHE = 0x2F,
		CON_CHANNEL_RSTREAM = 0x30,
		CON_CHANNEL_SCHEDULER = 0x31,
		CON_CHANNEL_MATCHRECORD = 0x32,
		CON_CHANNEL_MIGRATE = 0x33,
		CON_BUILTIN_CHANNEL_COUNT = 0x34,
		CON_FIRST_DEBUG_CHANNEL = 0x2E,
	};

	struct IPakSection
	{
		unsigned int type;
		unsigned int offset;
		unsigned int size;
		unsigned int itemCount;
	};

	struct IPakLoadedPackfile
	{
		char name[64];
		IPakSection data;
		IPakSection index;
		int fh;
		int refCount;
	};

	struct IPakHeader
	{
		unsigned int magic;
		unsigned int version;
		unsigned int size;
		unsigned int sectionCount;
	};

	struct IPakIndexEntry
	{
		unsigned int checksum;
		unsigned int fileID;
		unsigned int offset;
		unsigned int size;
	};

	struct IPakWorkData
	{
		IPakLoadedPackfile *pak;
		int indexReadOffset;
		int activeBuffer;
		unsigned int currentEntry;
		unsigned __int16 imageParts[4816];
		IPakIndexEntry indexBuffer[2][4096];
		int indexBufferOffset[2];
		int indexBufferState[2];
	};

	struct IPakDataChunkHeader
	{
		char offset[3];
		char numCommands;
		unsigned int commands[31]; // commands are top 24 bits are blocksize, bottom 8 are encrypted or not
	};

	struct GfxImageFileHeader
	{
		char tag[3];
		char version;
		char format;
		char flags;
		__int16 dimensions[3];
		float gamma;
		char maxGlossForMip[16];
		int fileSizeForPicmip[8];
	};

	struct WinConData
	{
		HWND hWnd;
		HWND hwndBuffer;
		HWND codLogo;
		HFONT hfBufferFont;
		HWND hwndInputLine;
		char errorString[512];
		char consoleText[512];
		char returnedText[512];
		int windowWidth;
		int windowHeight;
		int(__stdcall *SysInputLineWndProc)(HWND, unsigned int, unsigned int, int);
	};

	enum fsMode_t
	{
		FS_READ = 0x0,
		FS_WRITE = 0x1,
		FS_APPEND = 0x2,
		FS_APPEND_SYNC = 0x3,
	};

	enum FsListBehavior_e
	{
		FS_LIST_PURE_ONLY = 0x0,
		FS_LIST_ALL = 0x1,
	};

	enum scriptInstance_t
	{
		SCRIPTINSTANCE_SERVER = 0x0,
		SCRIPTINSTANCE_CLIENT = 0x1,
		SCRIPT_INSTANCE_MAX = 0x2,
	};

	enum bdNATType : unsigned char
	{
		BD_NAT_UNKNOWN = 0x0,
		BD_NAT_OPEN = 0x1,
		BD_NAT_MODERATE = 0x2,
		BD_NAT_STRICT = 0x3,
	};

#pragma pack(push, 1)
	struct bdAuthTicket
	{
		unsigned int m_magicNumber;
		char m_type;
		unsigned int m_titleID;
		unsigned int m_timeIssued;
		unsigned int m_timeExpires;
		unsigned __int64 m_licenseID;
		unsigned __int64 m_userID;
		char m_username[64];
		char m_sessionKey[24];
		char m_usingHashMagicNumber[3];
		char m_hash[4];
	};
#pragma pack(pop)

	union netip_t
	{
		char ip[4];
		unsigned int inaddr;
	};

	enum netadrtype_t
	{
		NA_BOT = 0x0,
		NA_BAD = 0x1,
		NA_LOOPBACK = 0x2,
		NA_BROADCAST = 0x3,
		NA_IP = 0x4,
	};

	enum netsrc_t
	{
		NS_NULL = 0xFFFFFFFF,
		NS_CLIENT1 = 0x0,
		NS_CLIENT2 = 0x1,
		NS_CLIENT3 = 0x2,
		NS_CLIENT4 = 0x3,
		NS_SERVER = 0x4,
		NS_MAXCLIENTS = 0x4,
		NS_PACKET = 0x5,
	};

	struct netadr_t
	{
		netip_t addr;
		unsigned __int16 port;
		netadrtype_t type;
		netsrc_t localNetID;
		unsigned __int16 serverID;
	};

	struct msg_t
	{
		int overflowed;
		int readOnly;
		char *data;
		char *splitData;
		int maxsize;
		int cursize;
		int splitSize;
		int readcount;
		int bit;
		int lastEntityRef;
		int flush;
		netsrc_t targetLocalNetID;
	};

	// Copied from Quake
	// not all are equal to COD's

	enum keyNum_t
	{
		K_NONE = 0x0,
		K_FIRSTGAMEPADBUTTON_RANGE_1 = 0x1,
		K_BUTTON_A = 0x1,
		K_BUTTON_B = 0x2,
		K_BUTTON_X = 0x3,
		K_BUTTON_Y = 0x4,
		K_BUTTON_LSHLDR = 0x5,
		K_BUTTON_RSHLDR = 0x6,
		K_LASTGAMEPADBUTTON_RANGE_1 = 0x6,
		K_BS = 0x8,
		K_TAB = 0x9,
		K_NL = 0xA,
		K_ENTER = 0xD,
		K_FIRSTGAMEPADBUTTON_RANGE_2 = 0xE,
		K_BUTTON_START = 0xE,
		K_BUTTON_BACK = 0xF,
		K_BUTTON_LSTICK = 0x10,
		K_BUTTON_RSTICK = 0x11,
		K_BUTTON_LTRIG = 0x12,
		K_BUTTON_RTRIG = 0x13,
		K_DPAD_UP = 0x14,
		K_FIRSTDPAD = 0x14,
		K_DPAD_DOWN = 0x15,
		K_DPAD_LEFT = 0x16,
		K_DPAD_RIGHT = 0x17,
		K_BUTTON_RTRIG_PUSH = 0x18,
		K_BUTTON_LTRIG_PUSH = 0x19,
		K_BUTTON_LSTICK_ALTIMAGE2 = 0x10,
		K_BUTTON_RSTICK_ALTIMAGE2 = 0x11,
		K_BUTTON_LSTICK_ALTIMAGE = 0xBC,
		K_NUNCHUK_RIGHT = 0xBC,
		K_BUTTON_RSTICK_ALTIMAGE = 0xBD,
		K_WIIUMOTE_RIGHT = 0xBD,
		K_LASTDPAD = 0x17,
		K_DPAD_LEFTRIGHT = 0x18,
		K_DPAD_UPDOWN = 0x19,
		K_LASTGAMEPADBUTTON_RANGE_2 = 0x19,
		K_CODPOINTS = 0x1A,
		K_ESCAPE = 0x1B,
		K_FIRSTGAMEPADBUTTON_RANGE_3 = 0x1C,
		K_APAD_UP = 0x1C,
		K_FIRSTAPAD = 0x1C,
		K_APAD_DOWN = 0x1D,
		K_APAD_LEFT = 0x1E,
		K_APAD_RIGHT = 0x1F,
		K_LASTAPAD = 0x1F,
		K_LASTGAMEPADBUTTON_RANGE_3 = 0x1F,
		K_SPACE = 0x20,
		K_BACKSPACE = 0x7F,
		K_ASCII_FIRST = 0x80,
		K_ASCII_181 = 0x80,
		K_ASCII_191 = 0x81,
		K_ASCII_223 = 0x82,
		K_ASCII_224 = 0x83,
		K_ASCII_225 = 0x84,
		K_ASCII_228 = 0x85,
		K_ASCII_229 = 0x86,
		K_ASCII_230 = 0x87,
		K_ASCII_231 = 0x88,
		K_ASCII_232 = 0x89,
		K_ASCII_233 = 0x8A,
		K_ASCII_236 = 0x8B,
		K_ASCII_241 = 0x8C,
		K_ASCII_242 = 0x8D,
		K_ASCII_243 = 0x8E,
		K_ASCII_246 = 0x8F,
		K_ASCII_248 = 0x90,
		K_ASCII_249 = 0x91,
		K_ASCII_250 = 0x92,
		K_ASCII_252 = 0x93,
		K_END_ASCII_CHARS = 0x94,
		K_COMMAND = 0x96,
		K_CAPSLOCK = 0x97,
		K_POWER = 0x98,
		K_PAUSE = 0x99,
		K_UPARROW = 0x9A,
		K_DOWNARROW = 0x9B,
		K_LEFTARROW = 0x9C,
		K_RIGHTARROW = 0x9D,
		K_ALT = 0x9E,
		K_CTRL = 0x9F,
		K_SHIFT = 0xA0,
		K_INS = 0xA1,
		K_DEL = 0xA2,
		K_PGDN = 0xA3,
		K_PGUP = 0xA4,
		K_HOME = 0xA5,
		K_END = 0xA6,
		K_F1 = 0xA7,
		K_F2 = 0xA8,
		K_F3 = 0xA9,
		K_F4 = 0xAA,
		K_F5 = 0xAB,
		K_F6 = 0xAC,
		K_F7 = 0xAD,
		K_F8 = 0xAE,
		K_F9 = 0xAF,
		K_F10 = 0xB0,
		K_F11 = 0xB1,
		K_F12 = 0xB2,
		K_F13 = 0xB3,
		K_F14 = 0xB4,
		K_F15 = 0xB5,
		K_KP_HOME = 0xB6,
		K_KP_UPARROW = 0xB7,
		K_KP_PGUP = 0xB8,
		K_KP_LEFTARROW = 0xB9,
		K_KP_5 = 0xBA,
		K_KP_RIGHTARROW = 0xBB,
		K_KP_END = 0xBC,
		K_KP_DOWNARROW = 0xBD,
		K_KP_PGDN = 0xBE,
		K_KP_ENTER = 0xBF,
		K_KP_INS = 0xC0,
		K_KP_DEL = 0xC1,
		K_KP_SLASH = 0xC2,
		K_KP_MINUS = 0xC3,
		K_KP_PLUS = 0xC4,
		K_KP_NUMLOCK = 0xC5,
		K_KP_STAR = 0xC6,
		K_KP_EQUALS = 0xC7,
		K_MOUSE1 = 0xC8,
		K_MOUSE2 = 0xC9,
		K_MOUSE3 = 0xCA,
		K_MOUSE4 = 0xCB,
		K_MOUSE5 = 0xCC,
		K_MWHEELDOWN = 0xCD,
		K_MWHEELUP = 0xCE,
		K_AUX1 = 0xCF,
		K_AUX2 = 0xD0,
		K_AUX3 = 0xD1,
		K_AUX4 = 0xD2,
		K_AUX5 = 0xD3,
		K_AUX6 = 0xD4,
		K_AUX7 = 0xD5,
		K_AUX8 = 0xD6,
		K_AUX9 = 0xD7,
		K_AUX10 = 0xD8,
		K_AUX11 = 0xD9,
		K_AUX12 = 0xDA,
		K_AUX13 = 0xDB,
		K_AUX14 = 0xDC,
		K_AUX15 = 0xDD,
		K_AUX16 = 0xDE,
		K_LAST_KEY = 0xDF,
	};

	// The menu code needs to get both key and char events, but
	// to avoid duplicating the paths, the char events are just
	// distinguished by or'ing in K_CHAR_FLAG (ugly)
#define	K_CHAR_FLAG		1024

	struct gentity_t;

	struct trajectory_t
	{
		char trType;
		int trTime;
		int trDuration;
		vec3_t trBase;
		vec3_t trDelta;
	};

	struct LerpEntityStateTurret
	{
		vec3_t gunAngles;
		int ownerNum;
		float heatVal;
		int overheating;
		float pivotOffset;
		int flags;
	};

	struct LerpEntityStateLoopFx
	{
		float cullDist;
		int period;
	};

	union LerpEntityStateActor_index
	{
		int actorNum;
		int corpseNum;
	};

	struct LerpEntityStateActor_proneInfo
	{
		__int16 fBodyPitch;
	};

	struct LerpEntityStateActor
	{
		LerpEntityStateActor_index index;
		int species;
		int team;
		int enemy;
		int freeCameraLockOnAllowed;
		LerpEntityStateActor_proneInfo proneInfo;
		unsigned __int16 aiType;
	};

	struct LerpEntityStatePrimaryLight
	{
		char colorAndExp[4];
		float intensity;
		float radius;
		float cosHalfFovOuter;
		float cosHalfFovInner;
		unsigned int mixerIndex;
	};

	union Weapon
	{
		unsigned int weaponData;
	};

	struct LerpEntityStatePlayer
	{
		float leanf;
		int movementDir;
		int moveType;
		Weapon primaryWeapon;
		Weapon stowedWeapon;
		Weapon offhandWeapon;
		Weapon meleeWeapon;
		char meleeWeaponCamo;
		char meleeWeaponModel;
		char vehicleType;
		char vehicleAnimBoneIndex;
		char vehicleSeat;
		char stowedWeaponCamo;
		char weaponHeat;
		char proneLegsAngle;
	};

	struct LerpEntityStateVehicleGunnerAngles
	{
		__int16 pitch;
		__int16 yaw;
	};

	struct LerpEntityStateVehicleRotorArm
	{
		__int16 pitch;
		__int16 roll;
	};

	union $DDE6850FA3B86A9C87C6DBFCDF4AD649
	{
		LerpEntityStateVehicleGunnerAngles gunnerAngles[4];
		LerpEntityStateVehicleRotorArm rotors[4];
	};

	union $ABF14481B6CB3C635AAEF83DF0F35947
	{
		__int16 throttle;
		__int16 bodyPitch;
	};

	struct LerpEntityStateVehicle
	{
		float steerYaw;
		float bodyRoll;
		$DDE6850FA3B86A9C87C6DBFCDF4AD649 ___u2;
		$ABF14481B6CB3C635AAEF83DF0F35947 ___u3;
		__int16 gunPitch;
		__int16 gunYaw;
		char targetRotorSpeed;
	};

	struct LerpEntityStateMissile
	{
		int launchTime;
		int parentClientNum;
		int fuseTime;
		int forcedDud;
		float autoDetonateTime;
	};

	struct LerpEntityStateScriptMover
	{
		char attachTagIndex[4];
		int attachedTagIndex;
		__int16 attachModelIndex[4];
		__int16 animScriptedAnim;
		__int16 attachedEntNum;
		int attachedEntTime;
		__int16 exploderIndex;
		unsigned __int16 scale;
		char flags;
		unsigned __int16 aiType;
	};

	struct LerpEntityStateBulletHit
	{
		vec3_t start;
	};

	struct LerpEntityStateEarthquake
	{
		float scale;
		float radius;
		int duration;
	};

	struct LerpEntityStateCustomExplode
	{
		int startTime;
		int effectIndex;
	};

	struct LerpEntityStateExplosion
	{
		float innerRadius;
		float magnitude;
		float innerDamage;
		int dummy;
		float outerDamage;
	};

	struct LerpEntityStateExplosionJolt
	{
		float innerRadius;
		vec3_t impulse;
	};

	struct LerpEntityStateJetThrust
	{
		vec3_t thrustDir;
		int dummy;
		float dotLimit;
	};

	struct LerpEntityStatePhysicsJitter
	{
		float innerRadius;
		float minDisplacement;
		float maxDisplacement;
	};

	struct LerpEntityStateDestructibleHit
	{
		unsigned int modelState[3];
	};

	struct LerpEntityStateCreateDynEnt
	{
		int model;
		int fxId;
		int mature;
	};

	struct LerpEntityStateStreamerHint
	{
		float factor;
	};

	struct LerpEntityStateZBarrierPiece
	{
		char flags;
		char animTime;
	};

	struct LerpEntityStateZBarrier
	{
		unsigned int barrierTypeIndex;
		LerpEntityStateZBarrierPiece pieces[6];
	};

	struct LerpEntityStateAnonymous
	{
		int data[9];
	};

	union LerpEntityStateTypeUnion
	{
		LerpEntityStateTurret turret;
		LerpEntityStateLoopFx loopFx;
		LerpEntityStateActor actor;
		LerpEntityStatePrimaryLight primaryLight;
		LerpEntityStatePlayer player;
		LerpEntityStateVehicle vehicle;
		LerpEntityStateMissile missile;
		LerpEntityStateScriptMover scriptMover;
		LerpEntityStateBulletHit bulletHit;
		LerpEntityStateEarthquake earthquake;
		LerpEntityStateCustomExplode customExplode;
		LerpEntityStateExplosion explosion;
		LerpEntityStateExplosionJolt explosionJolt;
		LerpEntityStateJetThrust jetThrust;
		LerpEntityStatePhysicsJitter physicsJitter;
		LerpEntityStateDestructibleHit destructibleHit;
		LerpEntityStateCreateDynEnt createDynEnt;
		LerpEntityStateStreamerHint streamerHint;
		LerpEntityStateZBarrier zbarrier;
		LerpEntityStateAnonymous anonymous;
	};

	union LerpEntityState_faction
	{
		char iHeadIconTeam;
		__int16 teamAndOwnerIndex;
	};

	struct LerpEntityState
	{
		int eFlags;
		int eFlags2;
		trajectory_t pos;
		trajectory_t apos;
		LerpEntityStateTypeUnion u;
		__int16 useCount;
		LerpEntityState_faction faction;
		unsigned int clientFields;
	};

	struct renderOptions_s
	{
		unsigned int s;
	};

	struct actorAnimState_t
	{
		__int16 state;
		char subState;
		float fLeanAmount;
		float fAimUpDown;
		float fAimLeftRight;
	};

	struct playerAnimState_t
	{
		int legsAnim;
		int torsoAnim;
		float fTorsoPitch;
		float fWaistPitch;
	};

	struct vehicleState_t
	{
		__int16 flags;
		char vehicleDefIndex;
		char treeId;
		__int16 animId;
		__int16 attachModelIndex[2];
		char attachTagIndex[2];
	};

	struct hardlineHint_t
	{
		char team;
		char perk;
		char hint;
	};

	struct scriptMoverState_t
	{
		char fov;
		char treeId;
		__int16 animId;
	};

	struct fxLightingState_t
	{
		float primaryLightFraction;
		int lightingOriginOffset;
	};

	union entityState_s_un2
	{
		actorAnimState_t animState;
		playerAnimState_t anim;
		vehicleState_t vehicleState;
		hardlineHint_t hardline;
		scriptMoverState_t moverState;
		fxLightingState_t fx;
	};

	union entityState_s_un3
	{
		int hintString;
		int vehicleXModel;
		unsigned int secondBcAlias;
		unsigned int soundTag;
	};

	struct clientLinkInfo_t
	{
		__int16 parentEnt;
		char tagIndex;
		char flags;
	};

	union entityState_s_index
	{
		__int16 brushmodel;
		__int16 xmodel;
		__int16 primaryLight;
		unsigned __int16 bone;
	};

	union entityState_s_un1
	{
		char scale;
		char eventParm2;
		char helicopterStage;
		char destructibleid;
		char zombieShrinkOn;
	};

	struct entityState_s
	{
		int number;
		LerpEntityState lerp;
		int time2;
		unsigned int loopSoundId;
		int solid;
		renderOptions_s renderOptions;
		entityState_s_un2 un2;
		entityState_s_un3 un3;
		unsigned int partBits[5];
		clientLinkInfo_t clientLinkInfo;
		int clientMask[1];
		char events[4];
		unsigned int eventParms[4];
		unsigned int eventParm;
		__int16 eType;
		__int16 groundEntityNum;
		entityState_s_index index;
		__int16 otherEntityNum;
		__int16 attackerEntityNum;
		__int16 enemyModel;
		Weapon weapon;
		Weapon lastStandPrevWeapon;
		unsigned __int16 targetname;
		__int16 loopSoundFade;
		__int16 eventSequence;
		char surfType;
		char clientNum;
		char iHeadIcon;
		char weaponModel;
		entityState_s_un1 un1;
	};

	struct EntHandle
	{
		unsigned __int16 number;
		unsigned __int16 infoIndex;
	};

	struct entityShared_t
	{
		char linked;
		char bmodel;
		char svFlags;
		char inuse;
		int broadcastTime;
		vec3_t mins;
		vec3_t maxs;
		int contents;
		vec3_t absmin;
		vec3_t absmax;
		vec3_t currentOrigin;
		vec3_t currentAngles;
		EntHandle ownerNum;
		int eventTime;
	};

	struct PlayerVehicleState
	{
		vec3_t origin;
		vec3_t angles;
		vec3_t velocity;
		vec3_t angVelocity;
		vec2_t tilt;
		vec2_t tiltVelocity;
		float targetHeightDelta;
		float lastGroundHeight;
		int entity;
		int flags;
		bool fullPhysics;
	};

	enum ClientNum_t
	{
		INVALID_CLIENT_INDEX = 0xFFFFFFFF,
		CLIENT_INDEX_FIRST = 0x0,
		CLIENT_INDEX_0 = 0x0,
		CLIENT_INDEX_1 = 0x1,
		CLIENT_INDEX_2 = 0x2,
		CLIENT_INDEX_3 = 0x3,
		CLIENT_INDEX_4 = 0x4,
		CLIENT_INDEX_5 = 0x5,
		CLIENT_INDEX_6 = 0x6,
		CLIENT_INDEX_7 = 0x7,
		CLIENT_INDEX_8 = 0x8,
		CLIENT_INDEX_9 = 0x9,
		CLIENT_INDEX_10 = 0xA,
		CLIENT_INDEX_11 = 0xB,
		CLIENT_INDEX_12 = 0xC,
		CLIENT_INDEX_13 = 0xD,
		CLIENT_INDEX_14 = 0xE,
		CLIENT_INDEX_15 = 0xF,
		CLIENT_INDEX_16 = 0x10,
		CLIENT_INDEX_17 = 0x11,
		CLIENT_INDEX_18 = 0x12,
		CLIENT_INDEX_19 = 0x13,
		CLIENT_INDEX_20 = 0x14,
		CLIENT_INDEX_21 = 0x15,
		CLIENT_INDEX_22 = 0x16,
		CLIENT_INDEX_23 = 0x17,
		CLIENT_INDEX_24 = 0x18,
		CLIENT_INDEX_25 = 0x19,
		CLIENT_INDEX_26 = 0x1A,
		CLIENT_INDEX_27 = 0x1B,
		CLIENT_INDEX_28 = 0x1C,
		CLIENT_INDEX_29 = 0x1D,
		CLIENT_INDEX_30 = 0x1E,
		CLIENT_INDEX_31 = 0x1F,
		CLIENT_INDEX_COUNT = 0x12,
	};

	enum OffhandSecondaryClass
	{
		PLAYER_OFFHAND_SECONDARY_SMOKE = 0x0,
		PLAYER_OFFHAND_SECONDARY_FLASH = 0x1,
		PLAYER_OFFHAND_SECONDARIES_TOTAL = 0x2,
	};

	enum OffhandPrimaryClass
	{
		PLAYER_OFFHAND_PRIMARY_FRAG = 0x0,
		PLAYER_OFFHAND_PRIMARY_GEAR = 0x1,
		PLAYER_OFFHAND_PRIMARIES_TOTAL = 0x2,
	};

	struct PlayerHeldWeapon
	{
		Weapon weapon;
		renderOptions_s options;
		float heatPercent;
		int fuelTankTime;
		int adsZoomSelect;
		bool overHeating;
		bool needsRechamber;
		bool heldBefore;
		bool quickReload;
		bool blockWeaponPickup;
		char model;
	};

	struct AmmoPool
	{
		int count;
	};

	struct AmmoClip
	{
		int count;
	};

	enum ViewLockTypes
	{
		PLAYERVIEWLOCK_NONE = 0x0,
		PLAYERVIEWLOCK_FULL = 0x1,
		PLAYERVIEWLOCK_WEAPONJITTER = 0x2,
		PLAYERVIEWLOCKCOUNT = 0x3,
	};

	enum locSel_t
	{
		LOC_SEL_NONE = 0x0,
		LOC_SEL_ARTILLERY = 0x1,
		LOC_SEL_AIRSTRIKE = 0x2,
		LOC_SEL_MORTAR = 0x3,
		LOC_SEL_NAPALM = 0x4,
		LOC_SEL_COMLINK = 0x5,
	};

	struct SprintState
	{
		int sprintButtonUpRequired;
		int sprintDelay;
		int lastSprintStart;
		int lastSprintEnd;
		int sprintStartMaxLength;
		int sprintDuration;
		int sprintCooldown;
	};

	struct MantleState
	{
		float yaw;
		int timer;
		int transIndex;
		int flags;
	};

	enum ActionSlotType
	{
		ACTIONSLOTTYPE_DONOTHING = 0x0,
		ACTIONSLOTTYPE_SPECIFYWEAPON = 0x1,
		ACTIONSLOTTYPE_ALTWEAPONTOGGLE = 0x2,
		ACTIONSLOTTYPE_NIGHTVISION = 0x3,
		ACTIONSLOTTYPECOUNT = 0x4,
	};

	struct ActionSlotParam_SpecifyWeapon
	{
		Weapon weapon;
	};

	struct ActionSlotParam
	{
		ActionSlotParam_SpecifyWeapon specifyWeapon;
	};

	enum objectiveState_t
	{
		OBJST_EMPTY = 0x0,
		OBJST_ACTIVE = 0x1,
		OBJST_INVISIBLE = 0x2,
		OBJST_NUMSTATES = 0x3,
	};

	struct objective_t
	{
		objectiveState_t state;
		vec3_t origin;
		__int16 entNum;
		vec2_t size;
		int icon;
		__int16 ownerNum;
		unsigned __int16 name;
		__int16 teamMask;
		char progress;
		int clientUseMask[1];
		char gamemodeFlags;
		char flags;
		char teamNum;
	};

	struct $C96EA5EC2ACBB9C0BF22693F316ACC67
	{
		char r;
		char g;
		char b;
		char a;
	};

	union hudelem_color_t
	{
		$C96EA5EC2ACBB9C0BF22693F316ACC67 _s0;
		int rgba;
	};

	struct hudelem_s
	{
		float x;
		float y;
		float z;
		float fontScale;
		float fromFontScale;
		int fontScaleStartTime;
		hudelem_color_t color;
		hudelem_color_t fromColor;
		int fadeStartTime;
		int scaleStartTime;
		float fromX;
		float fromY;
		int moveStartTime;
		int time;
		int duration;
		float value;
		float sort;
		hudelem_color_t glowColor;
		int fxBirthTime;
		unsigned int flags;
		__int16 targetEntNum;
		__int16 fontScaleTime;
		__int16 fadeTime;
		__int16 label;
		__int16 width;
		__int16 height;
		__int16 fromWidth;
		__int16 fromHeight;
		__int16 scaleTime;
		__int16 moveTime;
		__int16 text;
		unsigned __int16 fxLetterTime;
		unsigned __int16 fxDecayStartTime;
		unsigned __int16 fxDecayDuration;
		unsigned __int16 fxRedactDecayStartTime;
		unsigned __int16 fxRedactDecayDuration;
		char type;
		char font;
		char alignOrg;
		char alignScreen;
		char materialIndex;
		char offscreenMaterialIdx;
		char fromAlignOrg;
		char fromAlignScreen;
		char soundID;
		char ui3dWindow;
	};

	struct playerState_s_hud
	{
		hudelem_s current[31];
		hudelem_s archival[31];
	};

	struct playerState_s
	{
		int commandTime;
		int pm_type;
		int bobCycle;
		int pm_flags;
		__int64 weapFlags;
		int otherFlags;
		int pm_time;
		unsigned int loopSoundId;
		int loopSoundFade;
		vec3_t origin;
		vec3_t velocity;
		int remoteEyesEnt;
		int remoteEyesTagname;
		int remoteControlEnt;
		int weaponTime;
		int weaponDelay;
		int weaponTimeLeft;
		int weaponDelayLeft;
		int weaponIdleTime;
		int grenadeTimeLeft;
		int throwBackGrenadeOwner;
		int throwBackGrenadeTimeLeft;
		int weaponRestrictKickTime;
		bool mountAvailable;
		bool bRunLeftGun;
		bool bCarryingTurret;
		vec3_t mountPos;
		float mountDir;
		bool bThirdPerson;
		int foliageSoundTime;
		int gravity;
		float leanf;
		int speed;
		vec3_t delta_angles;
		int groundEntityNum;
		int moverEntityNum;
		int moverTimestamp;
		int groundType;
		vec3_t vLadderVec;
		int jumpTime;
		float jumpOriginZ;
		int slideTime;
		int moveType;
		int legsTimer;
		int torsoTimer;
		__int16 legsAnim;
		__int16 torsoAnim;
		int legsAnimDuration;
		int torsoAnimDuration;
		int damageTimer;
		int damageDuration;
		int dmgDirection;
		int dmgType;
		int corpseIndex;
		int movementDir;
		int eFlags;
		int eFlags2;
		PlayerVehicleState vehicleState;
		__int16 predictableEventSequence;
		__int16 predictableEventSequenceOld;
		int predictableEvents[4];
		unsigned int predictableEventParms[4];
		__int16 unpredictableEventSequence;
		__int16 unpredictableEventSequenceOld;
		int unpredictableEvents[4];
		unsigned int unpredictableEventParms[4];
		ClientNum_t clientNum;
		Weapon offHandWeapon;
		OffhandSecondaryClass offhandSecondary;
		OffhandPrimaryClass offhandPrimary;
		renderOptions_s renderOptions;
		int momentum;
		Weapon weapon;
		Weapon lastStandPrevWeapon;
		Weapon lastWeaponAltModeSwitch;
		Weapon stowedWeapon;
		char unusedCompatibilityPadding;
		Weapon meleeWeapon;
		int weaponstate;
		int weaponstateLeft;
		unsigned int weaponShotCount;
		unsigned int weaponShotCountLeft;
		float fWeaponPosFrac;
		int adsDelayTime;
		int spreadOverride;
		int spreadOverrideState;
		float weaponSpinLerp;
		int viewmodelIndex;
		vec3_t viewangles;
		int viewHeightTarget;
		float viewHeightCurrent;
		int viewHeightLerpTime;
		int viewHeightLerpTarget;
		int viewHeightLerpDown;
		vec2_t viewAngleClampBase;
		vec2_t viewAngleClampRange;
		int damageEvent;
		int damageYaw;
		int damagePitch;
		int damageCount;
		int stats[4];
		PlayerHeldWeapon heldWeapons[15];
		AmmoPool ammoNotInClip[15];
		AmmoClip ammoInClip[15];
		float proneDirection;
		float proneDirectionPitch;
		float proneTorsoPitch;
		ViewLockTypes viewlocked;
		__int16 viewlocked_entNum;
		int vehiclePos;
		int vehicleType;
		int vehicleAnimBoneIndex;
		int linkFlags;
		vec3_t linkAngles;
		int cursorHint;
		int cursorHintString;
		int cursorHintEntIndex;
		int cursorHintWeapon;
		int iCompassPlayerInfo;
		unsigned int spyplaneTypeEnabled;
		unsigned int satelliteTypeEnabled;
		int locationSelectionInfo;
		locSel_t locationSelectionType;
		SprintState sprintState;
		int lastDtpEnd;
		float fTorsoPitch;
		float fWaistPitch;
		float holdBreathScale;
		int holdBreathTimer;
		int chargeShotTimer;
		unsigned int chargeShotLevel;
		unsigned int shotsFiredFromChamber;
		float quickScopeScale;
		int quickScopeTimer;
		unsigned int clientFields;
		unsigned int clientFields2;
		unsigned int clientFields3;
		unsigned int entityStateClientFields;
		float moveSpeedScaleMultiplier;
		MantleState mantleState;
		int vehicleAnimStage;
		int vehicleEntryPoint;
		unsigned int scriptedAnim;
		int scriptedAnimTime;
		int meleeChargeEnt;
		int meleeChargeDist;
		int meleeChargeTime;
		int weapLockFlags;
		int weapLockedEntnum;
		unsigned int airburstMarkDistance;
		unsigned int perks[2];
		ActionSlotType actionSlotType[4];
		ActionSlotParam actionSlotParam[4];
		Weapon inventoryWeapon;
		__int16 wiiumoteAimX;
		__int16 wiiumoteAimY;
		char wiiuControllerType;
		char vehicleDefIndex;
		int entityEventSequence;
		int weapAnim;
		int weapAnimLeft;
		float aimSpreadScale;
		int shellshockIndex;
		int shellshockTime;
		int shellshockDuration;
		float dofNearStart;
		float dofNearEnd;
		float dofFarStart;
		float dofFarEnd;
		float dofNearBlur;
		float dofFarBlur;
		float dofViewmodelStart;
		float dofViewmodelEnd;
		int waterlevel;
		int smokeColorIndex;
		int hudElemLastAssignedSoundID;
		int adsZoomSelect;
		int adsZoomLatchTime;
		bool adsZoomLatchState;
		int adsPrevZoomSelect;
		int adsPrevZoomSelectTime;
		int artilleryInboundIconLocation;
		float visionSetLerpRatio;
		int poisoned;
		int binoculars;
		int scriptCursorHintString;
		objective_t objective[32];
		int deltaTime;
		int killCamEntity;
		int killCamTargetEntity;
		int introShotsFired;
		playerState_s_hud hud;
	};

	enum sessionState_t
	{
		SESS_STATE_PLAYING = 0x0,
		SESS_STATE_DEAD = 0x1,
		SESS_STATE_SPECTATOR = 0x2,
		SESS_STATE_INTERMISSION = 0x3,
	};

	enum clientConnected_t
	{
		CON_DISCONNECTED = 0x0,
		CON_CONNECTING = 0x1,
		CON_CONNECTED = 0x2,
	};

	template <size_t bits>
	struct bitarray
	{
		int array[bits / 32];
	};

	union $60971AFD306BE716C67F4ED6B7576D56
	{
		float rollmove;
		__int16 damageKick[2];
	};

#pragma pack(push, 1)
	struct usercmd_s
	{
		int serverTime;
		bitarray<64> button_bits;
		int angles[3];
		Weapon weapon;
		Weapon offHandWeapon;
		Weapon lastWeaponAltModeSwitch;
		char forwardmove;
		char rightmove;
		char upmove;
		char pitchmove;
		char yawmove;
		__int16 gunPitch;
		__int16 gunYaw;
		__int16 wiiumoteAimX;
		__int16 wiiumoteAimY;
		char wiiuControllerType;
		unsigned __int16 meleeChargeEnt;
		char meleeChargeDist;
		$60971AFD306BE716C67F4ED6B7576D56 ___u18;
		char selectedLocation[2];
		char selectedYaw;
		unsigned __int16 airburstMarkDistance;
		unsigned __int16 lastInput;
	};
#pragma pack(pop)

	struct playerTeamState_t
	{
		int location;
	};

	enum team_t
	{
		TEAM_FREE = 0x0,
		TEAM_BAD = 0x0,
		TEAM_ALLIES = 0x1,
		TEAM_AXIS = 0x2,
		TEAM_THREE = 0x3,
		TEAM_FOUR = 0x4,
		TEAM_FIVE = 0x5,
		TEAM_SIX = 0x6,
		TEAM_SEVEN = 0x7,
		TEAM_EIGHT = 0x8,
		TEAM_NUM_PLAYING_TEAMS = 0x9,
		TEAM_SPECTATOR = 0x9,
		TEAM_NUM_TEAMS = 0xA,
		TEAM_LOCALPLAYERS = 0xB,
		TEAM_FIRST_PLAYING_TEAM = 0x1,
		TEAM_LAST_PLAYING_TEAM = 0x8,
	};

	enum ffa_team_t
	{
		TEAM_FFA_NONE = 0x0,
		TEAM_FFA_AXIS = 0x1,
		TEAM_FFA_ALLIES = 0x2,
		TEAM_FFA_THREE = 0x3,
	};

	union $137F9095F7597C63EB19E8F61F5887B0
	{
		int prestige;
		int lastDaysPlayed;
	};

	struct netUInt64
	{
		unsigned int low;
		unsigned int high;
	};

	union $BA4CE55F498CD55FA8AE89CF1967B938
	{
		unsigned __int64 xuid;
		netUInt64 xuid64;
	};

	union $5A03B06D77C49A0599F537661E2DFCE9
	{
		unsigned __int64 leagueTeamID;
		netUInt64 leagueTeamID64;
	};

	union $C87BBC0E10708D6368CF77B7E7A71262
	{
		unsigned __int64 leagueSubdivisionID;
		netUInt64 leagueSubdivisionID64;
	};

	enum VehicleAnimState
	{
		VEHICLEANIMSTATE_IDLE = 0x0,
		VEHICLEANIMSTATE_ENTRY = 0x1,
		VEHICLEANIMSTATE_CHANGEPOS = 0x2,
		VEHICLEANIMSTATE_EXIT = 0x3,
		VEHICLEANIMSTATECOUNT = 0x4,
	};

	struct score_s
	{
		int ping;
		int status_icon;
		int place;
		int score;
		int kills;
		int assists;
		int deaths;
		int wagerWinnings;
		int scoreboardColumns[5];
		int downs;
		int revives;
		int headshots;
		int scoreMultiplier;
		int currentStreak;
	};

	struct clientState_s
	{
		ClientNum_t clientIndex;
		team_t team;
		ffa_team_t ffaTeam;
		int modelindex;
		int riotShieldNext;
		int attachModelIndex[6];
		int attachTagIndex[6];
		char name[32];
		float maxSprintTimeMultiplier;
		int rank;
		$137F9095F7597C63EB19E8F61F5887B0 ___u10;
		int lastDamageTime;
		int lastStandStartTime;
		int turnedHumanTime;
		int beingRevived;
		$BA4CE55F498CD55FA8AE89CF1967B938 ___u15;
		$5A03B06D77C49A0599F537661E2DFCE9 ___u16;
		int leagueDivisionID;
		$C87BBC0E10708D6368CF77B7E7A71262 ___u18;
		int leagueSubdivisionRank;
		unsigned int perks[2];
		int voiceConnectivityBits;
		char clanAbbrev[8];
		int attachedVehEntNum;
		int attachedVehSeat;
		int needsRevive;
		int clanAbbrevEV;
		VehicleAnimState vehAnimState;
		score_s score;
		int clientUIVisibilityFlags;
		int offhandWeaponVisible;
	};

	struct clientSession_t
	{
		sessionState_t sessionState;
		ClientNum_t forceSpectatorClient;
		int killCamEntity;
		int killCamTargetEntity;
		int archiveTime;
		unsigned __int16 scriptPersId;
		clientConnected_t connected;
		usercmd_s cmd;
		usercmd_s oldcmd;
		int localClient;
		int predictItemPickup;
		char newnetname[32];
		int maxHealth;
		int enterTime;
		playerTeamState_t teamState;
		int voteCount;
		int teamVoteCount;
		float moveSpeedScaleMultiplier;
		int viewmodelIndex;
		int noSpectate;
		int teamInfo;
		clientState_s cs;
		int psOffsetTime;
		int scoreboardColumnCache[26];
	};

	struct viewClamp
	{
		vec2_t start;
		vec2_t current;
		vec2_t goal;
	};

	struct viewClampState
	{
		viewClamp min;
		viewClamp max;
		float accelTime;
		float decelTime;
		float totalTime;
		float startTime;
	};

	struct gclient_t
	{
		playerState_s ps;
		playerState_s lastPlayerPS;
		clientSession_t sess;
		ClientNum_t spectatorClient;
		int flags;
		int lastCmdTime;
		bitarray<64> button_bits;
		bitarray<64> oldbutton_bits;
		bitarray<64> latched_button_bits;
		bitarray<64> button_bitsSinceLastFrame;
		float fGunPitch;
		float fGunYaw;
		int damage_blood;
		vec3_t damage_from;
		int damage_fromWorld;
		int inactivityTime;
		int inactivityWarning;
		int lastVoiceTime;
		int outWaterTime;
		int switchSeatTime;
		float currentAimSpreadScale;
		int dropWeaponTime;
		EntHandle pLookatEnt;
		vec4_t prevLinkedInvQuat;
		bool prevLinkAnglesSet;
		bool link_doCollision;
		bool link_useTagAnglesForViewAngles;
		bool link_useBaseAnglesForViewClamp;
		float linkAnglesFrac;
		viewClampState link_viewClamp;
		EntHandle useHoldEntity;
		int useHoldTime;
		int useButtonDone;
		int iLastCompassPlayerInfoEnt;
		int compassPingTime;
		int damageTime;
		float v_dmg_roll;
		float v_dmg_pitch;
		vec3_t swayViewAngles;
		vec3_t swayOffset;
		vec3_t swayAngles;
		vec3_t baseAngles;
		vec3_t baseOrigin;
		vec3_t recoilAngles;
		float fLastIdleFactor;
		int weaponIdleTime;
		vec3_t recoilSpeed;
		int previousRecoilTime;
		float previousRecoilRatio;
		int lastServerTime;
		int lastSpawnTime;
		Weapon lastWeapon;
		bool previouslyFiring;
		bool previouslyUsingNightVision;
		bool previouslyDTP;
		bool previouslyBeganWeaponRaise;
		bool previouslySprinting;
		unsigned int hasSpyplane;
		unsigned int hasSatellite;
		int revive;
		int reviveTime;
		int disallowVehicleUsage;
		unsigned __int16 attachShieldTagName;
		int lastStand;
		int lastStandTime;
	};

	struct ActorFlags
	{
		unsigned int allBits;
	};

	struct sentient_t
	{
		gentity_t *ent;
		team_t eTeam;
		EntHandle scriptOwner;
		int iThreatBias;
		int iThreatBiasGroupIndex;
		bool bIgnoreMe;
		bool bIgnoreAll;
		bool bIgnoreForFriendlyFire;
		bool originChanged;
		vec3_t oldOrigin;
		float maxVisibleDist;
		float surprisedByMeDistSq;
		int iEnemyNotifyTime;
		int attackerCount;
		EntHandle lastAttacker;
		EntHandle syncedMeleeEnt;
		EntHandle targetEnt;
		EntHandle scriptTargetEnt;
		unsigned __int16 scriptTargetTag;
		float entityTargetThreat;
		int meleeAttackerSpot[4];
		float attackerAccuracy;
		bool ignoreRandomBulletDamage;
		bool turretInvulnerability;
		pathnode_t *pClaimedNode;
		pathnode_t *pPrevClaimedNode;
		pathnode_t *pNearestNode;
		char bNearestNodeValid;
		char bNearestNodeBad;
		vec3_t vNearestNodeCheckPos;
		bool inuse;
		int banNodeTime;
		bool bInMeleeCharge;
	};

	enum AISpecies
	{
		AI_SPECIES_DOG = 0x0,
		AI_SPECIES_BIGDOG = 0x1,
		AI_SPECIES_ZOMBIE = 0x2,
		AI_SPECIES_ZOMBIE_DOG = 0x3,
		MAX_AI_SPECIES = 0x4,
		AI_SPECIES_ALL = 0x4,
	};

	enum ai_state_t
	{
		AIS_INVALID = 0x0,
		AIS_KEEPCURRENT = 0x0,
		AIS_EXPOSED = 0x1,
		AIS_TURRET = 0x2,
		AIS_GRENADE_RESPONSE = 0x3,
		AIS_BADPLACE_FLEE = 0x4,
		AIS_COVERARRIVAL = 0x5,
		AIS_DEATH = 0x6,
		AIS_DEFAULT = 0x1,
		AIS_SETABLE_FIRST = 0x1,
		AIS_SETABLE_LAST = 0x6,
		AIS_PAIN = 0x7,
		AIS_REACT = 0x8,
		AIS_SCRIPTEDANIM = 0x9,
		AIS_CUSTOMANIM = 0xA,
		AIS_NEGOTIATION = 0xB,
		AIS_PUSHABLE_FIRST = 0x7,
		AIS_PUSHABLE_LAST = 0xB,
		AIS_COUNT = 0xC,
	};

	enum ai_substate_t
	{
		STATE_EXPOSED_COMBAT = 0x64,
		STATE_EXPOSED_NONCOMBAT = 0x65,
		STATE_EXPOSED_REACQUIRE_MOVE = 0x66,
		STATE_EXPOSED_REACQUIRE_DONE = 0x67,
		STATE_EXPOSED_FLASHBANGED = 0x68,
		STATE_EXPOSED_REACTION = 0x69,
		STATE_DEATH_PRECLEANUP = 0xC8,
		STATE_DEATH_POSTCLEANUP = 0xC9,
		STATE_GRENADE_FLEE = 0x12C,
		STATE_GRENADE_TAKECOVER = 0x12D,
		STATE_GRENADE_COWER = 0x12E,
		STATE_GRENADE_COMBAT = 0x12F,
		STATE_GRENADE_COVERATTACK = 0x130,
		STATE_GRENADE_ACQUIRE = 0x131,
		STATE_GRENADE_THROWBACK = 0x132,
	};

	enum ai_state_transition_t
	{
		AIS_TRANSITION_CANONICAL = 0xFFFFFFFF,
		AIS_TRANSITION_NONE = 0x0,
		AIS_TRANSITION_SET = 0x1,
		AIS_TRANSITION_PUSH = 0x2,
		AIS_TRANSITION_POP = 0x3,
	};

	struct ai_transition_cmd_t
	{
		ai_state_transition_t eTransition;
		ai_state_t eState;
	};

	struct actorState_s
	{
		int actorIndex;
		int entityNum;
		int modelindex;
		int attachModelIndex[6];
		int attachTagIndex[6];
		unsigned int attachIgnoreCollision;
		char name[32];
		int animScriptedAnim;
	};

	struct ActorState
	{
		ai_state_t eState[6];
		ai_substate_t eSubState[6];
		unsigned int stateLevel;
		int iStateTime;
		int preThinkTime;
		ai_transition_cmd_t StateTransitions[13];
		unsigned int transitionCount;
		ai_state_t eSimulatedState[6];
		unsigned int simulatedStateLevel;
		actorState_s as;
	};

	struct ActorShoot
	{
		float accuracy;
		float playerSightAccuracy;
		unsigned int missCount;
		unsigned int hitCount;
		float debugLastAccuracy;
		int lastShotTime;
		bool lastCanShootEnemyResult;
		int lastCanShootEnemyTime;
		int bPerfectAim;
		int bIgnoreLocationalDamage;
		float debugWeaponAccuracy;
	};

	struct ActorOrientation
	{
		float fDesiredBodyYaw;
		float fLookPitch;
		float fLookYaw;
		vec3_t vLookForward;
		vec3_t vLookRight;
		vec3_t vLookUp;
		float yawVeloc;
		int allowPitchAngle;
		float turnRate;
		int bNotifyTurnDone;
		float maxFaceEnemyDistSq;
		char relativeDir;
		char prevRelativeDir;
		bool faceMotion;
		bool gunBlockedByWall;
		int dontTurnTime;
		bool lockScriptOrient;
		bool fixedLinkYawOnly;
	};

	enum ai_orient_mode_t
	{
		AI_ORIENT_INVALID = 0x0,
		AI_ORIENT_DONT_CHANGE = 0x1,
		AI_ORIENT_TO_MOTION = 0x2,
		AI_ORIENT_TO_ENEMY = 0x3,
		AI_ORIENT_TO_ENEMY_OR_MOTION = 0x4,
		AI_ORIENT_TO_ENEMY_OR_MOTION_SIDESTEP = 0x5,
		AI_ORIENT_TO_GOAL = 0x6,
		AI_ORIENT_COUNT = 0x7,
	};

	struct ai_orient_t
	{
		ai_orient_mode_t eMode;
		float fDesiredLookPitch;
		float fDesiredLookYaw;
		float fDesiredBodyYaw;
	};

	struct ActorPainDeath
	{
		int iPainTime;
		bool allowPain;
		bool blockingPain;
		bool allowDeath;
		bool delayedDeath;
		int iDamageTaken;
		int iDamageYaw;
		vec3_t damageDir;
		unsigned __int16 damageHitLoc;
		unsigned __int16 damageWeapon;
		unsigned __int16 damageMod;
		int deathContents;
		int bDropWeapon;
		bool forceRagdollImmediate;
		int minPainDamage;
		bool dieQuietly;
	};

	struct ActorProne
	{
		unsigned __int16 animProneLow;
		unsigned __int16 animProneLevel;
		unsigned __int16 animProneHigh;
		int bProneOK;
		float fInvProneAnimLowPitch;
		float fInvProneAnimHighPitch;
		float fProneLastDiff;
		char feetDirection;
	};

	union $A899A4A44C693354E5CF33C9EDFF92AE
	{
		float fTorsoPitch;
		float fBodyPitch;
	};

	union $8F7A1F2A0E788339D3BE9A175DA5EAEF
	{
		float fWaistPitch;
		float fBodyRoll;
	};

	struct actor_prone_info_s
	{
		bool bCorpseOrientation;
		bool orientPitch;
		bool prone;
		int iProneTime;
		int iProneTrans;
		float fBodyHeight;
		$A899A4A44C693354E5CF33C9EDFF92AE ___u6;
		$8F7A1F2A0E788339D3BE9A175DA5EAEF ___u7;
	};

	struct ActorCachedInfo
	{
		int time;
		vec3_t pos;
		vec3_t dir;
	};

	struct ActorLookAtInfo
	{
		vec3_t vLookAtPos;
		float fLookAtTurnAngle;
		float fLookAtTurnSpeed;
		float fLookAtTurnAccel;
		float fLookAtAnimYawLimit;
		float fLookAtYawLimit;
		unsigned __int16 animLookAtStraight;
		unsigned __int16 animLookAtLeft;
		unsigned __int16 animLookAtRight;
		bool bDoLookAt;
		bool bLookAtSetup;
		int iLookAtBlendEndTime;
		float fLookAtAnimBlendRate;
		float fLookAtLimitBlendRate;
	};

	struct ActorCoverArrivalInfo
	{
		int arrivalNotifyRequested;
		int animscriptOverrideRunTo;
		vec3_t animscriptOverrideRunToPos;
		vec2_t offsetIncrement;
		int offsetAdjustCount;
		float arrivalYaw;
		EntHandle scriptedArrivalEnt;
	};

	struct ActorNodeSelect
	{
		int numCoverNodesInGoal;
		int iPotentialCoverNodeCount;
		bool keepNodeDuringScriptedAnim;
		unsigned __int16 potentialCoverNode[10];
		unsigned __int16 potentialAmbushNode[32];
		int iPotentialAmbushNodeCount;
		int nextFindBestCoverTime;
		int coverSearchInterval;
		bool requestDifferentCover;
		bool keepClaimedNode;
		bool keepClaimedNodeIfValid;
		pathnode_t *pPotentialReacquireNode[10];
		int iPotentialReacquireNodeCount;
		pathnode_t *pPotentialCoverNode[32];
		bool doDangerReact;
		int dangerReactGoalTime;
		int dangerReactDuration;
	};

	struct ActorSight
	{
		float fovDot;
		float fMaxSightDistSqrd;
		int ignoreCloseFoliage;
		bool lastEnemySightPosValid;
		vec3_t lastEnemySightPos;
		vec3_t anglesToLikelyEnemyPath;
		int faceLikelyEnemyPathNeedCheckTime;
		int faceLikelyEnemyPathNeedRecalculateTime;
		pathnode_t *faceLikelyEnemyPathNode;
		int iTraceCount;
		unsigned __int16 vis_blockers[72];
		float fovDotBusy;
		int latency;
		float upAimLimit;
		float downAimLimit;
		float rightAimLimit;
		float leftAimLimit;
	};

	struct ActorString
	{
		unsigned __int16 properName;
		unsigned __int16 weaponName;
		unsigned __int16 primaryWeaponName;
		unsigned __int16 secondaryWeaponName;
		unsigned __int16 sideArmName;
		unsigned __int16 anim_pose;
		unsigned __int16 scriptState;
		unsigned __int16 lastScriptState;
		unsigned __int16 stateChangeReason;
		int iUseHintString;
	};

	struct ActorAnimSets
	{
		unsigned __int16 aimLow;
		unsigned __int16 aimLevel;
		unsigned __int16 aimHigh;
		unsigned __int16 shootLow;
		unsigned __int16 shootLevel;
		unsigned __int16 shootHigh;
	};

	enum ai_stance_e
	{
		STANCE_BAD = 0x0,
		STANCE_STAND = 0x1,
		STANCE_CROUCH = 0x2,
		STANCE_PRONE = 0x4,
		STANCE_ANY = 0x7,
	};

	struct scr_animscript_t
	{
		int func;
		int endFunc;
		unsigned __int16 name;
	};

	enum ai_traverse_mode_t
	{
		AI_TRAVERSE_INVALID = 0x0,
		AI_TRAVERSE_GRAVITY = 0x1,
		AI_TRAVERSE_NOGRAVITY = 0x2,
		AI_TRAVERSE_NOCLIP = 0x3,
		AI_TRAVERSE_COUNT = 0x4,
	};

	enum ai_animmode_t
	{
		AI_ANIM_UNKNOWN = 0x0,
		AI_ANIM_MOVE_CODE = 0x1,
		AI_ANIM_USE_POS_DELTAS = 0x2,
		AI_ANIM_USE_ANGLE_DELTAS = 0x3,
		AI_ANIM_USE_BOTH_DELTAS = 0x4,
		AI_ANIM_USE_BOTH_DELTAS_NOCLIP = 0x5,
		AI_ANIM_USE_BOTH_DELTAS_NOGRAVITY = 0x6,
		AI_ANIM_USE_BOTH_DELTAS_ZONLY_PHYSICS = 0x7,
		AI_ANIM_NOPHYSICS = 0x8,
		AI_ANIM_POINT_RELATIVE = 0x9,
	};

	struct ActorAnimation
	{
		ai_stance_e eAllowedStances;
		unsigned __int16 AnimScriptHandle;
		scr_animscript_t *pAnimScriptFunc;
		scr_animscript_t *pPrevAnimScriptFunc;
		scr_animscript_t AnimScriptSpecific;
		ai_traverse_mode_t eTraverseMode;
		char moveMode;
		bool useCombatScriptAtCover;
		bool prevAnimScriptTerminated;
		bool safeToChangeScript;
		bool bUseGoalWeight;
		ai_animmode_t eAnimMode;
		ai_animmode_t eScriptSetAnimMode;
		float fAnimTranslationScale;
	};

	struct pathpoint_t
	{
		vec3_t vOrigPoint;
		vec2_t fDir2D;
		float fOrigLength;
		int iNodeNum;
	};

	struct path_t
	{
		pathpoint_t pts[32];
		__int16 wPathLen;
		__int16 wOrigPathLen;
		__int16 wDodgeCount;
		__int16 wNegotiationStartNode;
		__int16 lookaheadNextNode;
		__int16 pathChangeNotifyNode;
		__int16 wDodgeEntity;
		vec3_t vFinalGoal;
		vec3_t vStartPos;
		vec3_t lookaheadDir;
		vec3_t lookaheadPos;
		float fLookaheadDist;
		float fLookaheadAmount;
		float fLookaheadDistToNextNode;
		int minLookAheadNodes;
		int flags;
		int iPathTime;
		int iPathClearedTime;
		team_t eTeam;
		float fCurrLength;
		vec3_t vCurrPoint;
		int iPathEndTime;
		float pathEndAnimDistSq;
		bool pathEndAnimNotified;
		bool lookaheadHitsStairs;
		bool useChokePoints;
		vec2_t pathChangeTracePos;
		int randomPercent;
		int owner;
		float physRadius;
		float physHeight;
	};

	struct path_trim_t
	{
		int iIndex;
		int iDelta;
	};

	enum ai_badplace_t
	{
		AI_BADPLACE_NONE = 0x0,
		AI_BADPLACE_NORMAL = 0x1,
		AI_BADPLACE_REALLYBAD = 0x2,
	};

	struct actor_t;

	struct ActorNavigation
	{
		float fWalkDist;
		float fWalkDistFacingMotion;
		float badPlaceAwareness;
		path_t Path;
		path_trim_t TrimInfo;
		int iFollowMin;
		int iFollowMax;
		float fInterval;
		int pathWaitTime;
		int iTeamMoveWaitTime;
		int iTeamMoveDodgeTime;
		int stoppedWaitStartTime;
		EntHandle stoppedWaitEnt;
		actor_t *pPileUpActor;
		gentity_t *pPileUpEnt;
		int bDontAvoidPlayer;
		float sideMove;
		bool noDodgeMove;
		int mayMoveTime;
		float nodeOffsetDist;
		vec3_t nodeOffsetPos;
		vec2_t prevMoveDir;
		float leanAmount;
		EntHandle pCloseEnt;
		ai_badplace_t aiBadPlace;
		bool isInBadPlace;
		char badplaceRecheckPathLen;
	};

	enum AlertLevel
	{
		AI_ALERTNESS_ASLEEP = 0x0,
		AI_ALERTNESS_NONCOMBAT = 0x1,
		AI_ALERTNESS_ALERT = 0x2,
		AI_ALERTNESS_COMBAT = 0x3,
		NUM_ALERT_LEVELS = 0x4,
	};

	enum CombatMode
	{
		AI_COMBAT_COVER = 0x0,
		AI_COMBAT_NO_COVER = 0x1,
		AI_COMBAT_COVER_ONLY = 0x2,
		AI_COMBAT_AMBUSH = 0x3,
		AI_COMBAT_AMBUSH_NODES_ONLY = 0x4,
		AI_COMBAT_EXPOSED_NODES_ONLY = 0x5,
		AI_COMBAT_ANY_EXPOSED_NODES_ONLY = 0x6,
		NUM_COMBAT_MODES = 0x7,
	};

	struct ActorCombat
	{
		int exposedStartTime;
		int exposedDuration;
		bool provideCoveringFire;
		scr_animscript_t *pAttackScriptFunc;
		float pathEnemyLookahead;
		float pathEnemyFightDist;
		float meleeAttackDist;
		bool useEnemyGoal;
		bool useMeleeAttackSpot;
		vec3_t goodShootPos;
		int goodShootPosValid;
		float engageMinDist;
		float engageMinFalloffDist;
		float engageMaxDist;
		float engageMaxFalloffDist;
		bool noGrenadeReturnThrow;
		AlertLevel alertLevel;
		CombatMode combatMode;
		int exposedResumeTime;
		int stopPathTime;
		int ambushStartTime;
		bool doingAmbush;
		bool currentAmbushNodeInvalid;
		bool allAmbushNodesFailed;
		bool noAttackerAccuracyMod;
		bool canFlank;
		bool isWounded;
		bool damageShield;
		float frontShieldAngleCos;
	};

	struct ActorReact
	{
		int iReactTime;
		int nextAllowedReactTime;
		bool allowReact;
		vec3_t reactOrigin;
		int lastHitTime;
		float newEnemyReactionDistSq;
		vec3_t newEnemyReactionPos;
		bool newEnemyReaction;
	};

	struct potential_threat_t
	{
		bool isEnabled;
		vec2_t direction;
	};

	struct ActorSecondaryTarget
	{
		EntHandle entity;
		vec2_t dirToEnt;
		float distToEnt;
		pathnode_t *node;
	};

	struct ActorThreat
	{
		int hasThreateningEnemy;
		int bPacifist;
		int iPacifistWait;
		potential_threat_t potentialThreat;
		int threatUpdateTime;
		SentientHandle pFavoriteEnemy;
		int bDrawOnCompass;
		int bActivateCrosshair;
		float highlyAwareRadius;
		bool ignoreExplosionEvents;
		int numSecondaryTarget;
		ActorSecondaryTarget secondaryTargets[2];
		bool allEnemiesInSimilarDir;
		int goodEnemyOnly;
		float footstepDetectDistSq;
		float footstepDetectDistWalkSq;
		float footstepDetectDistSprintSq;
	};

	struct ActorGrenade
	{
		float grenadeAwareness;
		EntHandle pGrenade;
		unsigned __int16 GrenadeTossMethod;
		int bGrenadeTossValid;
		int bGrenadeTargetValid;
		int iGrenadeAmmo;
		vec3_t vGrenadeTossPos;
		vec3_t vGrenadeTargetPos;
		vec3_t vGrenadeTossVel;
		EntHandle throwBackGrenadeKilledOriginalOwner;
		int bThrowbackGrenades;
		EntHandle pGrenadeFlee;
		int flashBanged;
		float flashBangedStrength;
		int flashBangImmunity;
		int grenadeExistTime;
		Weapon GrenadeWeapon;
		bool grenadeTossWithBounce;
		vec3_t pickupPos;
	};

	struct ActorTurret
	{
		gentity_t *pTurret;
		unsigned __int16 turretAnim;
		char turretAnimSet;
	};

	struct actor_goal_s
	{
		vec3_t pos;
		vec3_t ang;
		float radius;
		float height;
		pathnode_t *node;
		gentity_t *volume;
	};

	enum aiGoalSources
	{
		AI_GOAL_SRC_SCRIPT_GOAL = 0x0,
		AI_GOAL_SRC_SCRIPT_ENTITY_GOAL = 0x1,
		AI_GOAL_SRC_ENEMY = 0x2,
	};

	struct ActorGoal
	{
		actor_goal_s codeGoal;
		aiGoalSources codeGoalSrc;
		actor_goal_s scriptGoal;
		EntHandle scriptGoalEnt;
		bool goalPosChanged;
		bool commitToFixedNode;
		bool ignoreForFixedNodeSafeCheck;
		bool fixedNode;
		float fixedNodeSafeRadius;
		float fixedNodeSafeVolumeRadiusSq;
		EntHandle fixedNodeSafeVolume;
		int moveHistoryIndex;
		bool moveHistoryConsistent;
		vec2_t moveHistory[10];
	};

	struct ActorSuppression
	{
		int ignoreSuppression;
		int suppressionWait;
		int suppressionDuration;
		int suppressionStartTime;
		float suppressionMeter;
	};

	enum DelayedWeapDropState
	{
		ACTOR_WEAP_DROP_NONE = 0x0,
		ACTOR_WEAP_DROP_GRAB_INITIAL_VALUE = 0x1,
		ACTOR_WEAP_DROP_FINISH = 0x2,
	};

	struct ActorDelayedWeaponDrop
	{
		vec3_t matrix[4];
		int time;
		unsigned __int16 tagName;
		DelayedWeapDropState state;
		int weaponIndex;
	};

	struct vis_cache_t
	{
		bool bVisible;
		int iLastUpdateTime;
		int iLastVisTime;
	};

	struct sentient_info_t
	{
		vis_cache_t VisCache;
		int iLastAttackMeTime;
		int lastKnownPosTime;
		int attackTime;
		bool surprised;
		vec3_t vLastKnownPos;
		pathnode_t *pLastKnownNode;
		int iPathTestTime;
		bool bPathTestResult;
	};

	struct ai_suppression_t
	{
		int iTime;
		sentient_t *pSuppressor;
		vec3_t clipPlane;
		int movementOnly;
	};

	enum aiphys_t
	{
		AIPHYS_BAD = 0x0,
		AIPHYS_NORMAL_ABSOLUTE = 0x1,
		AIPHYS_NORMAL_RELATIVE = 0x2,
		AIPHYS_NOCLIP = 0x3,
		AIPHYS_NOGRAVITY = 0x4,
		AIPHYS_ZONLY_PHYSICS_RELATIVE = 0x5,
		AIPHYS_ZONLY_PHYSICS_ABSOLUTE = 0x6,
	};

	struct visitor_base_t;

	struct visitor_base_tVtbl
	{
		void *(__thiscall *__vecDelDtor)(visitor_base_t *_this, unsigned int);
	};

	struct visitor_base_t
	{
		visitor_base_tVtbl *vfptr;
	};

	union $21C1E9479C665B64954A8451F26470F1
	{
		CollisionAabbTree *tree;
		cbrush_t *brush;
	};

	struct col_prim_t
	{
		int type;
		$21C1E9479C665B64954A8451F26470F1 ___u1;
	};

	struct hybrid_vector
	{
		__m128 vec;
	};

	struct TraceCheckCount
	{
		unsigned __int16 global;
		unsigned __int16 *partitions;
		unsigned __int16 *brushes;
	};

	struct TraceThreadInfo
	{
		TraceCheckCount checkcount;
		cbrush_t *box_brush;
		cmodel_t *box_model;
		PhysGeomList **geoms;
	};

	struct colgeom_visitor_t
	{
		visitor_base_t baseclass_0;
		__declspec(align(16)) hybrid_vector m_mn;
		hybrid_vector m_mx;
		hybrid_vector m_p0;
		hybrid_vector m_p1;
		hybrid_vector m_delta;
		hybrid_vector m_rvec;
		float m_radius;
		int m_mask;
		TraceThreadInfo *m_threadInfo;
	};

	template <size_t count>
	struct __declspec(align(16)) colgeom_visitor_inlined_t
	{
		colgeom_visitor_t baseclass_0;
		int nprims;
		bool overflow;
		col_prim_t prims[count];
	};

	struct phys_vec3
	{
		float x;
		float y;
		float z;
		float w;
	};

	const struct cached_simplex_info
	{
		phys_vec3 m_indices[3];
	};

	struct phys_memory_heap
	{
		char *m_buffer_start;
		char *m_buffer_end;
		char *m_buffer_cur;
		char *m_user_start;
	};

	struct phys_vec2
	{
		float x;
		float y;
	};

	struct __declspec(align(16)) contact_manifold_mesh_point
	{
		phys_vec3 m_p;
		phys_vec2 m_contact_p;
	};

	struct __declspec(align(16)) phys_contact_manifold
	{
		phys_vec3 m_feature_normal;
		phys_vec3 m_feature_hitp;
		phys_vec3 m_feature_hitn;
		float m_feature_distance_eps;
		float m_sin_feautre_angular_eps_sq;
		int m_close_mesh_point_count;
		phys_memory_heap *m_allocator;
		contact_manifold_mesh_point *m_list_mesh_point;
		int m_list_mesh_point_count;
		contact_manifold_mesh_point **m_list_sorted_mesh_point;
		contact_manifold_mesh_point **m_list_contact_point;
		int m_list_contact_point_count;
	};

	struct phys_mat44;
	const struct phys_gjk_geom;

	struct phys_gjk_geomVtbl
	{
		void(__thiscall *support)(phys_gjk_geom *_this, phys_vec3 *, phys_vec3 *, phys_vec3 *);
		void(__thiscall *get_simplex)(phys_gjk_geom *_this, cached_simplex_info *, const int, phys_vec3 *, phys_vec3 *);
		void(__thiscall *set_simplex)(phys_gjk_geom *_this, phys_vec3 *, const int, phys_vec3 *, cached_simplex_info *);
		phys_vec3 *(__thiscall *get_center)(phys_gjk_geom *_this, phys_vec3 *result);
		void(__thiscall *get_feature)(phys_gjk_geom *_this, phys_contact_manifold *);
		const float(__thiscall *get_geom_radius)(phys_gjk_geom *_this);
		void(__thiscall *calc_aabb)(phys_gjk_geom *_this, phys_mat44 *, phys_vec3 *, phys_vec3 *);
		const bool(__thiscall *ray_cast)(phys_gjk_geom *_this, phys_vec3 *, phys_vec3 *, const float, float *, phys_vec3 *);
		bool(__thiscall *is_polyhedron)(phys_gjk_geom *_this);
	};

	const struct phys_gjk_geom
	{
		phys_gjk_geomVtbl *vfptr;
	};

	struct phys_mat44
	{
		phys_vec3 x;
		phys_vec3 y;
		phys_vec3 z;
		phys_vec3 w;
	};

	struct __declspec(align(16)) gjk_base_t
	{
		phys_gjk_geom baseclass_0;
		__declspec(align(16)) phys_vec3 m_aabb_mn_loc;
		phys_vec3 m_aabb_mx_loc;
		unsigned int m_gjk_geom_id;
		phys_mat44 *m_xform_;
		gjk_base_t *m_next_geom;
		unsigned int m_flags;
		int stype;
		int m_contents;
	};

	enum gjccc_create_type_e
	{
		CT_CYLINDER = 0x0,
		CT_COLLMAP = 0x1,
	};

	struct gjccc_create_t
	{
		gjccc_create_type_e type;
		vec3_t *mins;
		vec3_t *maxs;
		PhysGeomList *collmap;
	};

	const struct gjkcc_input_t
	{
		unsigned int gjkcc_id;
		bool is_server_thread;
		colgeom_visitor_inlined_t<300> *proximity_data;
		int proximity_mask;
		int m_ent_num;
		unsigned int m_gjk_query_flags;
		gjk_base_t *m_gjk_cg;
		phys_mat44 *m_mat;
		gjccc_create_t *create_info;
	};

	enum AI_STAIRS_STATE
	{
		AI_STAIRS_NONE = 0x0,
		AI_STAIRS_UP = 0x1,
		AI_STAIRS_DOWN = 0x2,
		NUM_STAIRS_STATES = 0x3,
	};

	struct actor_physics_t
	{
		vec3_t vOrigin;
		vec3_t vVelocity;
		unsigned __int16 groundEntNum;
		int iFootstepTimer;
		int bHasGroundPlane;
		float groundplaneSlope;
		int iSurfaceType;
		vec3_t vWishDelta;
		int bIsAlive;
		int iEntNum;
		aiphys_t ePhysicsType;
		float fGravity;
		int iMsec;
		vec3_t vMins;
		vec3_t vMaxs;
		bool prone;
		int iTraceMask;
		int foliageSoundTime;
		int iNumTouch;
		int iTouchEnts[32];
		int iHitEntnum;
		vec3_t vHitOrigin;
		vec3_t vHitNormal;
		char bStuck;
		char bDeflected;
		gjkcc_input_t *m_gjkcc_input;
		__declspec(align(16)) colgeom_visitor_inlined_t<300> proximity_data;
		bool pathGoingDown;
		AI_STAIRS_STATE stairsState;
		int groundEntityTimestamp;
	};

	struct ActorCoverInfluenceInfo
	{
		pathnode_t *node;
		float weightAdjust;
		int timeAdded;
	};

	struct __declspec(align(16)) actor_t
	{
		ActorFlags flags;
		gentity_t *ent;
		sentient_t *sentient;
		AISpecies species;
		ActorState state;
		ActorShoot shoot;
		ActorOrientation orientation;
		ai_orient_t CodeOrient;
		ai_orient_t ScriptOrient;
		ActorPainDeath painDeath;
		ActorProne prone;
		actor_prone_info_s ProneInfo;
		ActorCachedInfo eyeInfo;
		ActorCachedInfo muzzleInfo;
		ActorLookAtInfo lookAtInfo;
		ActorCoverArrivalInfo arrivalInfo;
		ActorNodeSelect nodeSelect;
		ActorSight sight;
		ActorString string;
		ActorAnimSets animSets;
		ActorAnimation anim;
		ActorNavigation navigation;
		ActorCombat combat;
		ActorReact react;
		ActorThreat threat;
		ActorGrenade grenade;
		ActorTurret turret;
		ActorGoal goal;
		ActorSuppression suppression;
		ActorDelayedWeaponDrop weapDrops[2];
		sentient_info_t sentientInfo[72];
		ai_suppression_t Suppressant[4];
		__declspec(align(16)) actor_physics_t Physics;
		const char *pszDebugInfo;
		ActorCoverInfluenceInfo cover_influencers[8];
	};

	enum TurretRotateState
	{
		TURRET_ROTATE_STOPPED = 0x0,
		TURRET_ROTATE_STOPPING = 0x1,
		TURRET_ROTATE_MOVING = 0x2,
	};

	struct TurretInfo
	{
		bool inuse;
		int state;
		int flags;
		int fireTime;
		EntHandle manualTarget;
		EntHandle target;
		vec3_t targetPos;
		int targetTime;
		vec3_t missOffsetNormalized;
		float arcmin[2];
		float arcmax[2];
		float initialYawmin;
		float initialYawmax;
		float forwardAngleDot;
		float dropPitch;
		float scanningPitch;
		int convergenceTime[2];
		int suppressTime;
		float maxRangeSquared;
		SentientHandle detachSentient;
		int stance;
		int prevStance;
		int fireSndDelay;
		float accuracy;
		vec3_t userOrigin;
		int prevSentTarget;
		float aiSpread;
		float playerSpread;
		team_t eTeam;
		float heatVal;
		bool overheating;
		int fireBarrel;
		float scanSpeed;
		float scanDecelYaw;
		int scanPauseTime;
		vec3_t originError;
		vec3_t anglesError;
		float pitchCap;
		int triggerDown;
		unsigned int fireSnd;
		unsigned int fireSndPlayer;
		unsigned int startFireSnd;
		unsigned int startFireSndPlayer;
		unsigned int loopFireEnd;
		unsigned int loopFireEndPlayer;
		unsigned int rotateLoopSnd;
		unsigned int rotateLoopSndPlayer;
		unsigned int rotateStopSnd;
		unsigned int rotateStopSndPlayer;
		int sndIsFiring;
		vec3_t targetOffset;
		float onTargetAngle;
		TurretRotateState turretRotateState;
		vec3_t previousAngles;
	};

	struct DestructibleBurnData
	{
		int burnTime;
		unsigned int fx;
		int sndId;
	};

	struct DESTRUCTIBLE_PIECE_INFO
	{
		__int16 health;
		int xdollHandle;
		unsigned int fx;
		DestructibleBurnData burnData;
	};

	struct DestructibleState
	{
		LerpEntityStateDestructibleHit state;
		int time;
	};

	struct Destructible
	{
		int entNum;
		DESTRUCTIBLE_PIECE_INFO *pieceArray;
		int oldestBurnTime;
		char destructiblePoseID;
		int pieceCount;
		DestructibleDef *ddef;
		unsigned int flags;
		DestructibleState states[5];
		char bHasBeenHit;
	};

	struct vehicle_spline_node_t
	{
		__int16 nextIdx;
		__int16 prevIdx;
		float length;
		vec3_t dir;
		float t;
	};

	struct vehicle_path_node_t
	{
		__int16 numLinks;
		__int16 firstLinkIndex;
	};

	union $985D68EE007AE70B9BF8699519B57281
	{
		vehicle_spline_node_t splineNode;
		vehicle_path_node_t pathNode;
	};

	struct vehicle_node_t
	{
		unsigned __int16 name;
		unsigned __int16 target;
		unsigned __int16 target2;
		unsigned __int16 script_linkname;
		unsigned __int16 script_noteworthy;
		__int16 index;
		int flags;
		float speed;
		float lookAhead;
		vec3_t origin;
		vec3_t angles;
		float radius;
		float tension;
		$985D68EE007AE70B9BF8699519B57281 ___u13;
	};

	struct vehicle_custom_path_t
	{
		__int16 pathOrder[128];
		__int16 pathLinkIdx[128];
		char inUse;
	};

	enum path_type_e
	{
		PT_OLD_SPLINE = 0x0,
		PT_SPLINE = 0x1,
	};

	struct vehicle_pathpos_t
	{
		__int16 nodeIdx;
		__int16 prevIdx;
		__int16 endOfPath;
		float frac;
		float speed;
		float lookAhead;
		float slide;
		float width;
		float manualTime;
		float widthLookAheadFrac;
		float distanceTraveled;
		vec3_t origin;
		vec3_t angles;
		vec3_t lookPos;
		vec3_t origin_on_spline;
		vec3_t angles_on_spline;
		vec3_t lookPos_on_spline;
		int use_spline_speed;
		vehicle_node_t switchNode[2];
		int flags;
		vehicle_custom_path_t *customPath;
		float customGoalLength;
		vec3_t customGoalDir;
		path_t *aiPath;
		path_type_e path_type;
		__int16 startNodeIdx;
		float t;
		float tot_len;
		float tot_time;
	};

	struct vehicle_physic_t
	{
		vec3_t origin;
		vec3_t prevOrigin;
		vec3_t angles;
		vec3_t prevAngles;
		vec3_t maxAngleVel;
		float yawAccel;
		float yawDecel;
		vec3_t mins;
		vec3_t maxs;
		vec3_t vel;
		vec3_t bodyVel;
		vec3_t rotVel;
		vec3_t accel;
		float maxPitchAngle;
		float maxRollAngle;
		float wheelZVel[6];
		float wheelZPos[6];
		int wheelSurfType[6];
		vec3_t bodyTilt;
		vec3_t worldTilt;
		vec3_t worldTiltVel;
		float heliLockHeight;
		float curveLength;
		int curveID;
		float curveStep;
		float curveTime;
		float timeStep;
	};

	enum VehicleMoveState
	{
		VEH_MOVESTATE_STOP = 0x0,
		VEH_MOVESTATE_MOVE = 0x1,
		VEH_MOVESTATE_HOVER = 0x2,
		VEH_MOVESTATE_PLANE_ONCURVE = 0x3,
		VEH_MOVESTATE_PLANE_FREE = 0x4,
	};

	enum VehicleTurretState
	{
		VEH_TURRET_STOPPED = 0x0,
		VEH_TURRET_STOPPING = 0x1,
		VEH_TURRET_MOVING = 0x2,
	};

	struct VehicleTurret
	{
		int fireTime;
		int fireBarrel;
		float barrelOffset;
		int flags;
		float heatVal;
		float turretOnTargetRange;
		int overheating;
		int weaponShotCount;
		VehicleTurretState turretState;
	};

	struct VehicleJitter
	{
		int jitterPeriodMin;
		int jitterPeriodMax;
		int jitterEndTime;
		vec3_t jitterOffsetRange;
		vec3_t jitterDeltaAccel;
		vec3_t jitterAccel;
		vec3_t jitterPos;
	};

	struct VehicleHover
	{
		float hoverRadius;
		float hoverSpeed;
		float hoverAccel;
		vec3_t hoverGoalPos;
		int useHoverAccelForAngles;
	};

	struct VehicleTarget
	{
		int valid;
		int hasTargetYaw;
		int targetEnt;
		int lookAtEnt;
		vec3_t targetOrigin;
		vec3_t targetOffset;
		float targetYaw;
	};

	struct VehicleGunnerTags
	{
		int turret;
		int barrel;
		int flash;
		int flash2;
	};

	struct VehicleTags
	{
		int player;
		int popout;
		int body;
		int turret;
		int turret_base;
		int barrel;
		int flash[4];
		VehicleGunnerTags gunnerTags[4];
		int wheel[6];
		int seats[11];
		int entryPoints[5];
	};

	struct VehicleSeat
	{
		int _occupantEntNum;
	};

	template <typename T>
	struct phys_link_list_base
	{
		T *m_next_link;
	};

	struct rigid_body;

	struct __declspec(align(16)) pulse_sum_node
	{
		phys_link_list_base<pulse_sum_node> baseclass_0;
		__declspec(align(16)) phys_mat44 m_world_inv_inertia;
		phys_vec3 t_vel;
		phys_vec3 a_vel;
		float m_inv_mass;
		rigid_body *m_rb;
	};

	struct rigid_body_constraint
	{
		rigid_body *b1;
		rigid_body *b2;
		rigid_body_constraint *m_next;
	};

	struct pulse_sum_cache
	{
		float m_pulse_sum;
	};

	struct __declspec(align(8)) rigid_body_constraint_point
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b1_r_loc;
		phys_vec3 m_b2_r_loc;
		pulse_sum_cache m_ps_cache_list[3];
		float m_stress;
		float m_spring_k;
		float m_damp_k;
		bool m_spring_enabled;
	};

	struct __declspec(align(16)) rigid_body_constraint_hinge
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b1_r_loc;
		phys_vec3 m_b2_r_loc;
		phys_vec3 m_b1_axis_loc;
		phys_vec3 m_b2_axis_loc;
		phys_vec3 m_b1_a1_loc;
		phys_vec3 m_b1_a2_loc;
		phys_vec3 m_b1_ref_loc;
		phys_vec3 m_b2_ref_min_loc;
		phys_vec3 m_b2_ref_max_loc;
		float m_damp_k;
		unsigned int m_flags;
		pulse_sum_cache m_ps_cache[8];
	};

	struct __declspec(align(16)) rigid_body_constraint_distance
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b1_r_loc;
		phys_vec3 m_b2_r_loc;
		float m_min_distance;
		float m_max_distance;
		float m_next_max_distance;
		float m_max_distance_vel;
		float m_damp_coef;
		unsigned int m_flags;
		pulse_sum_cache m_ps_cache_list[3];
	};

	struct __declspec(align(8)) ragdoll_joint_limit_info
	{
		phys_vec3 m_b1_ud_loc;
		float m_b1_ud_limit_co_;
		float m_b1_ud_limit_si_;
		float m_b1_ud_active_limit_co_;
	};

	struct __declspec(align(16)) rigid_body_constraint_ragdoll
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b1_r_loc;
		phys_vec3 m_b2_r_loc;
		unsigned int m_flags;
		pulse_sum_cache m_ps_cache_list[10];
		__declspec(align(8)) phys_vec3 m_b1_axis_loc;
		phys_vec3 m_b2_axis_loc;
		phys_vec3 m_b1_a1_loc;
		phys_vec3 m_b1_a2_loc;
		phys_vec3 m_b1_ref_loc;
		phys_vec3 m_b2_ref_min_loc;
		phys_vec3 m_b2_ref_max_loc;
		ragdoll_joint_limit_info m_joint_limits[2];
		int m_joint_limits_count;
		float m_damp_k;
	};

	struct __declspec(align(16)) pulse_sum_normal
	{
		phys_link_list_base<pulse_sum_normal> baseclass_0;
		__declspec(align(16)) phys_vec3 m_ud;
		phys_vec3 m_b1_r;
		phys_vec3 m_b2_r;
		phys_vec3 m_b1_ap;
		phys_vec3 m_b2_ap;
		float m_pulse_sum_min;
		float m_pulse_sum_max;
		float m_pulse_sum;
		float m_right_side;
		float m_big_dirt;
		float m_cfm;
		float m_denom;
		float m_pulse_limit_ratio;
		unsigned int m_flags;
		pulse_sum_normal *m_pulse_parent;
		pulse_sum_node *m_b1;
		pulse_sum_node *m_b2;
		pulse_sum_cache *m_pulse_sum_cache;
	};

	struct rigid_body_constraint_wheel
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b2_hitp_loc;
		phys_vec3 m_b2_hitn_loc;
		phys_vec3 m_b1_wheel_center_loc;
		phys_vec3 m_b1_suspension_dir_loc;
		phys_vec3 m_b1_wheel_axis_loc;
		float m_wheel_radius;
		float m_fwd_fric_k;
		float m_side_fric_k;
		float m_side_fric_max;
		float m_suspension_stiffness_k;
		float m_suspension_damp_k;
		float m_hard_limit_dist;
		float m_roll_stability_factor;
		float m_pitch_stability_factor;
		float m_turning_radius_ratio_max_speed;
		float m_turning_radius_ratio_accel;
		float m_desired_speed_k;
		float m_acceleration_factor_k;
		float m_braking_factor_k;
		float m_wheel_vel;
		float m_wheel_fwd;
		float m_wheel_pos;
		float m_wheel_displaced_center_dist;
		float m_wheel_normal_force;
		unsigned int m_wheel_state;
		unsigned int m_wheel_flags;
		pulse_sum_cache m_ps_cache_list[4];
		pulse_sum_normal *m_ps_suspension;
		pulse_sum_normal *m_ps_side_fric;
		pulse_sum_normal *m_ps_fwd_fric;
	};

	struct __declspec(align(16)) rigid_body_constraint_angular_actuator
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_mat44 m_target_mat;
		phys_mat44 m_next_target_mat;
		phys_vec3 m_a_vel;
		float m_power;
		float m_power_scale;
		bool m_enabled;
		pulse_sum_cache m_ps_cache_list[3];
	};

	struct __declspec(align(16)) rigid_body_constraint_upright
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_vec3 m_b1_forward_axis_loc;
		phys_vec3 m_b1_right_axis_loc;
		phys_vec3 m_b1_up_axis_loc;
		phys_vec3 m_b1_lean_axis_loc;
		phys_vec3 m_b2_up_axis_loc;
		phys_vec3 m_last_t_vel;
		phys_vec3 m_last_a_vel;
		float m_avg_side_force;
		float m_avg_normal_force;
		float m_lean_angle_calc_delta_t;
		float m_lean_angle;
		float m_lean_angle_multiplier;
		float m_max_lean_angle;
		float m_moving_average_total_time;
		bool m_enabled;
		pulse_sum_cache m_ps_cache_list[1];
	};

	struct rigid_body_constraint_custom_orientation
	{
		rigid_body_constraint baseclass_0;
		pulse_sum_cache m_ps_cache_list[5];
		bool m_active;
		bool m_no_orientation_correction;
		float m_torque_resistance_pitch_roll;
		float m_torque_resistance_yaw;
		float m_torque_resistance_yaw_max_collision_speed;
		float m_upright_strength;
	};

	struct user_rigid_body;

	struct __declspec(align(8)) rigid_body_constraint_custom_path
	{
		rigid_body_constraint baseclass_0;
		__declspec(align(8)) phys_mat44 m_path_mat;
		phys_vec3 b1_r_loc;
		user_rigid_body *m_urb;
		int m_timestamp;
		float m_spring_scale;
		pulse_sum_cache m_list_psc[4];
	};

	struct contact_point_info_pulse_sum_cache_info
	{
		pulse_sum_cache m_ps_cache_list[3];
	};

	struct __declspec(align(8)) broad_phase_base
	{
		phys_vec3 m_trace_aabb_min_whace;
		phys_vec3 m_trace_aabb_max_whace;
		phys_vec3 m_trace_translation;
		unsigned int m_flags;
		broad_phase_base *m_list_bpb_next;
		broad_phase_base *m_list_bpb_cluster_next;
		void *m_sap_node;
		void *m_user_data;
		unsigned int m_env_collision_flags;
		unsigned int m_my_collision_type_flags;
	};

	struct rigid_body;

	struct __declspec(align(8)) broad_phase_info
	{
		broad_phase_base baseclass_0;
		rigid_body *m_rb;
		phys_mat44 *m_rb_to_world_xform;
		phys_mat44 *m_cg_to_world_xform;
		phys_mat44 *m_cg_to_rb_xform;
		phys_gjk_geom *m_gjk_geom;
		unsigned int m_gjk_geom_id;
		int m_surface_type;
	};

	struct phys_gjk_geom_id_pair_key
	{
		unsigned int m_id1;
		unsigned int m_id2;
	};

	struct phys_gjk_cache_info
	{
		phys_vec3 m_support_dir;
		cached_simplex_info m_support_a;
		cached_simplex_info m_support_b;
		int m_support_count;
		phys_gjk_geom_id_pair_key m_key;
		unsigned int m_flags;
	};

	struct phys_collision_pair
	{
		phys_link_list_base<phys_collision_pair> baseclass_0;
		broad_phase_info *m_bpi1;
		broad_phase_info *m_bpi2;
		float m_hit_time;
		phys_gjk_cache_info *m_gjk_ci;
	};

	struct rigid_body_constraint_contact;

	struct __declspec(align(16)) contact_point_info
	{
		phys_vec3 m_normal;
		float m_fric_coef;
		float m_bounce_coef;
		float m_max_restitution_vel;
		int m_flags;
		int m_point_pair_count;
		phys_vec3 *m_list_b1_r_loc;
		phys_vec3 *m_list_b2_r_loc;
		contact_point_info_pulse_sum_cache_info *m_list_pulse_sum_cache_info;
		contact_point_info *m_next_link;
		const void *m_rb2_entity;
		float m_translation_lambda;
		phys_collision_pair *m_pcp;
		rigid_body_constraint_contact *m_rbc_contact;
	};

	template <typename T>
	struct phys_simple_link_list
	{
		T *m_first;
	};

	template <typename T>
	struct phys_inplace_avl_tree_node
	{
		T *m_left;
		T *m_right;
		int m_balance;
	};

	struct rigid_body_pair_key
	{
		rigid_body *m_b1;
		rigid_body *m_b2;
	};

	struct rigid_body_constraint_contact
	{
		rigid_body_constraint baseclass_0;
		phys_simple_link_list<contact_point_info> m_list_contact_point_info_buffer_1;
		phys_simple_link_list<contact_point_info> m_list_contact_point_info_buffer_2;
		unsigned int m_solver_priority;
		phys_inplace_avl_tree_node<rigid_body_constraint_contact> m_avl_tree_node;
		rigid_body_pair_key m_avl_key;
	};

	struct rb_inplace_partition_node
	{
		rigid_body_constraint_point *m_rbc_point_first;
		rigid_body_constraint_hinge *m_rbc_hinge_first;
		rigid_body_constraint_distance *m_rbc_dist_first;
		rigid_body_constraint_ragdoll *m_rbc_ragdoll_first;
		rigid_body_constraint_wheel *m_rbc_wheel_first;
		rigid_body_constraint_angular_actuator *m_rbc_angular_actuator_first;
		rigid_body_constraint_upright *m_rbc_upright_first;
		rigid_body_constraint_custom_orientation *m_rbc_custom_orientation_first;
		rigid_body_constraint_custom_path *m_rbc_custom_path_first;
		rigid_body_constraint_contact *m_rbc_contact_first;
		rigid_body *m_partition_head;
		rigid_body *m_partition_tail;
		rigid_body *m_next_node;
		int m_partition_size;
	};

	struct rigid_body
	{
		phys_vec3 m_last_position;
		phys_vec3 m_moved_vec;
		float m_smallest_lambda;
		__declspec(align(16)) phys_mat44 m_mat;
		phys_vec3 m_inv_inertia;
		phys_vec3 m_gravity_acc_vec;
		phys_vec3 m_t_vel;
		phys_vec3 m_a_vel;
		phys_vec3 m_last_t_vel;
		phys_vec3 m_last_a_vel;
		phys_vec3 m_force_sum;
		phys_vec3 m_torque_sum;
		float m_inv_mass;
		float m_max_avel;
		float m_max_delta_t;
		unsigned int m_flags;
		unsigned int m_tick;
		pulse_sum_node *m_node;
		int m_constraint_count;
		int m_contact_count;
		int m_stable_min_contact_count;
		float m_stable_energy_time;
		float m_largest_vel_sq;
		float m_t_drag_coef;
		float m_a_drag_coef;
		void *m_userdata;
		rb_inplace_partition_node m_partition_node;
	};

	struct user_rigid_body
	{
		rigid_body baseclass_0;
		phys_mat44 *m_dictator;
		__declspec(align(16)) phys_mat44 m_dictator_mat;
	};

	struct gjk_geom_list_t
	{
		gjk_base_t *m_first_geom;
		int m_geom_count;
	};

	enum PhysicsOwnerType
	{
		PHYS_OWNER_DYNENT = 0x0,
		PHYS_OWNER_ENTITY = 0x1,
		PHYS_OWNER_GLASS = 0x2,
		PHYS_OWNER_PARTICLE = 0x3,
		PHYS_OWNER_RAGDOLL = 0x4,
		PHYS_OWNER_XDOLL = 0x5,
		PHYS_OWNER_COUNT = 0x6,
	};

	struct hitinfo_t
	{
		int hittime;
		vec3_t hitp;
		vec3_t hitn;
		int stype;
		int entnum;
		float intensity;
	};

	struct NitrousVehicle;

	struct PhysObjUserData
	{
		rigid_body *body;
		NitrousVehicle *vehicle;
		gjk_geom_list_t m_gjk_geom_list;
		PhysObjUserData *m_next_link;
		__declspec(align(16)) phys_mat44 cg2rb;
		phys_mat44 m2w;
		broad_phase_base *m_bpb;
		vec3_t tvel;
		vec3_t avel;
		float friction;
		float bounce;
		int id;
		int underwater;
		int buoyancy;
		int timeBuoyant;
		int timeRipple;
		unsigned __int16 trDuration;
		unsigned __int16 refcount;
		float m_time_since_last_event;
		float m_time_since_last_reeval;
		int m_flags;
		float mass;
		vec3_t buoyancyBoxMin;
		vec3_t buoyancyBoxMax;
		vec3_t centerOfMassOffset;
		int owner;
		PhysicsOwnerType owner_type;
		hitinfo_t hitinfo;
	};

	struct VehicleStun
	{
		bool m_changed_this_frame;
		float m_stun_time;
		float m_last_throttle;
		float m_throttle_stun_time;
		float m_last_brake;
		float m_brake_stun_time;
	};

	struct __declspec(align(16)) NitrousVehicleController
	{
		enum VehicleHorseControlState
		{
			LEFT_STICK_STEERS_HORSE_AND_CAMERA = 0x0,
			LEFT_STICK_STEERS_HORSE_RIGHT_STICK_CAMERA = 0x1,
			RIGHT_STICK_STEERS_HORSE_AND_CAMERA = 0x2,
		};

		phys_vec3 m_script_goal_position;
		float m_script_goal_radius;
		float m_script_goal_speed;
		float m_drive_path_speed;
		float m_horse_target_speed;
		VehicleHorseControlState m_horse_control_state;
		float m_stopped_time;
		float m_stuck_time;
		__declspec(align(8)) phys_vec3 m_stuck_position;
		usercmd_s m_cmd;
		vec3_t m_cmd_viewangles;
		bool m_cmd_valid;
		bool m_stop_at_goal;
		float m_jump_held_time;
		vec2_t m_jump_input;
		VehicleStun m_stun;
	};

	struct minspec_mutex
	{
		volatile unsigned int m_token;
	};

	enum WheelEffectState
	{
		WHEEL_STATE_ROLLING = 0x0,
		WHEEL_STATE_AIRBORN = 0x1,
		WHEEL_STATE_SKIDDING = 0x2,
		WHEEL_STATE_MAX = 0x3,
	};

	struct WheelState
	{
		WheelEffectState m_state;
		WheelEffectState m_last_state;
		float m_state_time;
		float m_rate;
	};

	struct /*__declspec(align(8))*/ NitrousVehicle
	{
		PhysObjUserData *m_phys_user_data;
		WheelState m_wheel_state[4];
		__declspec(align(16)) phys_mat44 m_wheel_orig_relpo[6];
		int m_wheel_damage[6];
		int m_wheel_surf_types[6];
		float m_wheel_yaw[6];
		float m_steer_factor;
		float m_steer_scale;
		VehicleParameter *m_parameter;
		float m_throttle;
		float m_brake;
		float m_hand_brake;
		float m_script_brake;
		int m_boost_start_time;
		float m_boost_time_pool;
		float m_forward_vel;
		phys_vec3 m_ground_vel;
		float m_hand_brake_friction_time;
		gentity_t *m_owner;
		int m_entnum;
		VehicleDef *m_vehicle_def;
		XModel *m_xmodel;
		rigid_body_constraint_custom_orientation *m_orientation_constraint;
		rigid_body_constraint_custom_path *m_vpc;
		int m_flags;
		int m_notify_flags;
		int m_server_notify_flags;
		vec3_t m_collision_hitp;
		vec3_t m_collision_hitn;
		float m_collision_intensity;
		int m_collision_stype;
		int m_collision_entnum;
		__declspec(align(8)) phys_mat44 m_mat;
		NitrousVehicleController mVehicleController;
		float m_fake_rpm;
		int m_num_colliding_wheels;
		float m_current_side_fric_scale;
		float m_current_fwd_fric_scale;
		float m_stuck_time;
		int m_lastNetworkTime;
		int m_lastErrorReductionTime;
		vec3_t m_networkErrorOrigin;
		vec3_t m_networkErrorAngles;
		int m_trackDistAccumLeftInches;
		int m_trackDistAccumRightInches;
		int m_sfx_state_flags;
		float m_speed_scale;
		float m_drivepath_scale;
		int m_throttle_held_down;
		bool m_throttle_time_started;
		vec3_t m_last_origin;
		vec3_t m_last_angles;
		minspec_mutex m_mutex;
		int id;
		int refcount;
		rigid_body_constraint_wheel *m_wheels[6];
		float m_desired_speed_factor;
		float m_acceleration_factor;
		float m_power_braking_factor;
		float m_braking_factor;
		float m_coasting_factor;
		float m_reference_wheel_radius;
		float m_steer_current_angle;
		float m_steer_max_angle;
		float m_steer_speed;
		phys_vec3 m_steer_front_pt_loc;
		float m_steer_front_back_length;
		float m_min_turning_radius;
		unsigned int m_state_flags;
	};

	enum TraceHitType
	{
		TRACE_HITTYPE_NONE = 0x0,
		TRACE_HITTYPE_ENTITY = 0x1,
		TRACE_HITTYPE_DYNENT_MODEL = 0x2,
		TRACE_HITTYPE_DYNENT_BRUSH = 0x3,
		TRACE_HITTYPE_GLASS = 0x4,
	};

	struct __declspec(align(16)) vehicle_cache_t
	{
		vec3_t lastOrigin;
		vec3_t lastAngles;
		int hit_indices[6];
		int hit_sflags[6];
		vec3_t hit_normals[6];
		float hit_fractions[6];
		TraceHitType hit_type[6];
		unsigned __int16 hit_id[6];
		colgeom_visitor_inlined_t<300> proximity_data;
		int wheel_mask;
	};

	struct __declspec(align(16)) vehicle_t
	{
		vehicle_pathpos_t pathPos;
		int pathOffsetFlags;
		vec3_t pathOffsetTransform[4];
		vec3_t pathFixedOffset;
		vec3_t pathVariableOffset;
		vec3_t pathVariableOffsetTargetPrev;
		vec3_t pathVariableOffsetTarget;
		float pathVariableOffsetRate;
		float pathVariableOffsetTime;
		vehicle_physic_t phys;
		int entNum;
		__int16 defIndex;
		int flags;
		team_t team;
		VehicleMoveState moveState;
		VehicleTurret turret;
		float turretRotScale;
		VehicleJitter jitter;
		VehicleHover hover;
		VehicleTurret gunnerTurrets[4];
		VehicleJitter gunnerJitter[4];
		float minigunRotationSpeed;
		unsigned __int16 lookAtText0;
		unsigned __int16 lookAtText1;
		int manualMode;
		float manualSpeed;
		float manualAccel;
		float manualDecel;
		float speed;
		float maxSpeedOverride;
		float maxDragSpeed;
		float turningAbility;
		int hasTarget;
		int hasTargetYaw;
		int hasGoalYaw;
		int stopAtGoal;
		int stopping;
		int targetEnt;
		EntHandle lookAtEnt;
		vec3_t targetOrigin;
		vec3_t targetOffset;
		float targetYaw;
		vec3_t goalPosition;
		float goalYaw;
		float prevGoalYaw;
		float yawOverShoot;
		int yawSlowDown;
		float pathTransitionTime;
		float maxPathTransitionTime;
		vec3_t pathTransitionOffset;
		vec3_t pathTransitionAngleOffset;
		int hasDefaultPitch;
		float defaultPitch;
		float hasGoalRoll;
		float goalRoll;
		float goalRollTime;
		float currentRollTime;
		int numRolls;
		VehicleTarget gunnerTargets[4];
		float nearGoalNotifyDist;
		vec2_t joltDir;
		float joltTime;
		float joltWave;
		float joltSpeed;
		float joltDecel;
		VehicleTags boneIndex;
		int turretHitNum;
		VehicleSeat seats[11];
		float modelSwapDelay;
		int oneExhaust;
		float deathQuakeScale;
		float deathQuakeDuration;
		float deathQuakeRadius;
		int secTurretAiControlled;
		int addToCompass;
		NitrousVehicle *nitrousVehicle;
		vehicle_cache_t vehicle_cache;
		float heliHeightLockOffset;
		float lastViewOffset;
		int driveBySoundIndex[2];
		float driveBySoundDelay[2];
		float driveBySoundTimeout[2];
		sentient_t *sentient;
		ActorSight sight;
		ActorThreat threat;
		sentient_info_t sentientInfo[72];
	};

	struct flame_timed_damage_t
	{
		gentity_t *attacker;
		int damage;
		float damageDuration;
		float damageInterval;
		int start_timestamp;
		int end_timestamp;
		int lastupdate_timestamp;
	};

	struct item_ent_t
	{
		int ammoCount;
		int clipAmmoCount;
		Weapon weapon;
	};

	struct trigger_ent_t
	{
		int threshold;
		int accumulate;
		int timestamp;
		int singleUserEntIndex;
		char perk;
		bool requireLookAt;
		bool ignoreTeam;
		bool excludeTeam;
		int exposureIndex;
		float exposureLerpToLighter;
		float exposureLerpToDarker;
		vec3_t exposureFeather;
	};

	struct mover_positions_t
	{
		float decelTime;
		float speed;
		float midTime;
		vec3_t pos1;
		vec3_t pos2;
		vec3_t pos3;
	};

	struct mover_slidedata_t
	{
		vec3_t mins;
		vec3_t maxs;
		vec3_t velocity;
	};

	union $538A64D31793DA7494E85D8CCF3A9F54
	{
		mover_positions_t pos;
		mover_slidedata_t slide;
	};

	struct mover_ent_t
	{
		$538A64D31793DA7494E85D8CCF3A9F54 ___u0;
		mover_positions_t angle;
	};

	struct corpse_ent_t
	{
		int deathAnimStartTime;
	};

	enum MissileStage
	{
		MISSILESTAGE_SOFTLAUNCH = 0x0,
		MISSILESTAGE_ASCENT = 0x1,
		MISSILESTAGE_DESCENT = 0x2,
	};

	enum MissileFlightMode
	{
		MISSILEFLIGHTMODE_TOP = 0x0,
		MISSILEFLIGHTMODE_DIRECT = 0x1,
	};

	struct $F77C35275B1C89CAB0A36141425CBDF2
	{
		vec3_t curvature;
		vec3_t targetOffset;
		MissileStage stage;
		MissileFlightMode flightMode;
	};

	struct $72842387414CD44A01249CD18A7BDEE4
	{
		int effectIndex;
	};

	union $30E2FE9AC2D5CA9B1DD39A5DED8EFC2C
	{
		$F77C35275B1C89CAB0A36141425CBDF2 missile;
		$72842387414CD44A01249CD18A7BDEE4 grenade;
	};

	struct missile_ent_t
	{
		int timestamp;
		float time;
		int timeOfBirth;
		float travelDist;
		vec3_t surfaceNormal;
		team_t team;
		char flags;
		int antilagTimeOffset;
		int timeAlive;
		float airburstActivationDistance;
		$30E2FE9AC2D5CA9B1DD39A5DED8EFC2C grenade;
		int forcedDud;
		float grenadeWobbleCycle;
		float grenadeCurve;
		int destructibleBounceCount;
	};

	struct blend_ent_t
	{
		vec3_t pos;
		vec3_t vel;
		vec4_t viewQuat;
		bool changed;
		float posAccelTime;
		float posDecelTime;
		float angleAccelTime;
		float angleDecelTime;
		float startTime;
		float posTotalTime;
		float angleTotalTime;
	};

	struct animscripted_t
	{
		vec3_t axis[4];
		vec3_t originError;
		vec3_t originErrorReduction;
		vec3_t anglesError;
		vec3_t anglesErrorReduction;
		unsigned __int16 anim;
		unsigned __int16 root;
		char bStarted;
		char mode;
		int startTime;
		int lerpTime;
		float fHeightOfs;
		float fEndPitch;
		float fEndRoll;
		float fOrientLerp;
	};

	struct actor_ent_t
	{
		int spawnTime;
		animscripted_t *scripted;
	};

	struct spawner_ent_t
	{
		int team;
		int timestamp;
	};

	struct zbarrier_piece_t
	{
		char state;
		char scalar;
		char nextState;
		int startTime;
	};

	struct zbarrier_ent_t
	{
		zbarrier_piece_t pieces[6];
	};

	union $4BE5A40934689114AA8300BA957D5844
	{
		item_ent_t item[2];
		trigger_ent_t trigger;
		mover_ent_t mover;
		corpse_ent_t corpse;
		missile_ent_t missile;
		blend_ent_t blend;
		actor_ent_t actorInfo;
		spawner_ent_t spawner;
		zbarrier_ent_t zbarrier;
	};

	struct gentity_t_snd_wait
	{
		unsigned __int16 notifyString;
		unsigned int index;
		char stoppable;
		int basetime;
		int duration;
	};

	struct tagInfo_t
	{
		gentity_t *parent;
		gentity_t *next;
		unsigned __int16 name;
		bool blendToParent;
		bool blendOnlyYaw;
		bool collisionPhysics;
		int index;
		vec3_t axis[4];
		vec3_t parentInvAxis[4];
	};

	struct gentity_t
	{
		entityState_s s;
		entityShared_t r;
		gclient_t *client;
		actor_t *actor;
		sentient_t *sentient;
		TurretInfo *pTurretInfo;
		Destructible *destructible;
		vehicle_t *vehicle;
		unsigned __int16 model;
		char physicsObject;
		char takedamage;
		char active;
		char nopickup;
		char handler;
		char team;
		char avoidHandle;
		unsigned __int16 classname;
		unsigned __int16 target;
		unsigned __int16 targetname;
		unsigned __int16 script_noteworthy;
		unsigned int attachIgnoreCollision;
		int spawnflags;
		int flags;
		int eventTime;
		int freeAfterEvent;
		int unlinkAfterEvent;
		int clipmask;
		int processedFrame;
		EntHandle parent;
		int nextthink;
		int health;
		int maxHealth;
		int damage;
		flame_timed_damage_t flame_timed_damage[4];
		int last_timed_radius_damage;
		int count;
		$4BE5A40934689114AA8300BA957D5844 ___u36;
		EntHandle missileTargetEnt;
		gentity_t_snd_wait snd_wait;
		tagInfo_t *tagInfo;
		gentity_t *tagChildren;
		unsigned __int16 attachModelNames[19];
		unsigned __int16 attachTagNames[19];
		XAnimTree_s *pAnimTree;
		unsigned __int16 disconnectedLinks;
		int iDisconnectTime;
		int useCount;
		int physObjId;
		gentity_t *nextFree;
		int birthTime;
		int ikPlayerclipTerrainTime;
		int ikDisableTerrainMappingTime;
	};

	struct __declspec(align(128)) cg_t
	{
		int clientNum;
		// ...
	};

    struct ReliableCommands
    {
        int sequence;
        int acknowledge;
        char *commands[128];
        int commandBufferNext;
        char commandBuffer[16384];
    };
    struct netProfilePacket_t
    {
        int iTime;
        int iSize;
        int bFragment;
    };
    struct netProfileStream_t
    {
        netProfilePacket_t packets[60];
        int iCurrPacket;
        int iBytesPerSecond;
        int iLastBPSCalcTime;
        int iCountedPackets;
        int iCountedFragments;
        int iFragmentPercentage;
        int iLargestPacket;
        int iSmallestPacket;
    };
    struct netProfileInfo_t
    {
        netProfileStream_t send;
        netProfileStream_t recieve;
    };
    struct netchan_t
    {
        int outgoingSequence;
        Game::netsrc_t sock;
        int dropped;
        int incomingSequence;
        Game::netadr_t remoteAddress;
        int qport;
        int fragmentSequence;
        int fragmentLength;
        char *fragmentBuffer;
        int fragmentBufferSize;
        int unsentFragments;
        int unsentOnLoan;
        int unsentFragmentStart;
        int unsentLength;
        char *unsentBuffer;
        int unsentBufferSize;
        int reliable_fragments;
        char fragment_send_count[128];
        unsigned int fragment_ack[4];
        int lowest_send_count;
        netProfileInfo_t prof;
    };
    struct clientConnection_t
    {
        int qport;
        ClientNum_t clientNum;
        int lastPacketSentTime;
        int lastPacketTime;
        Game::netadr_t serverAddress;
        int connectTime;
        int connectPacketCount;
        char serverMessage[256];
        int challenge;
        int checksumFeed;
        ReliableCommands reliableCommands;
        int serverMessageSequence;
        int serverCommandSequence;
        int lastExecutedServerCommand;
        char serverCommands[128][1024];
        bool isServerRestarting;
        bool areTexturesLoaded;
        bool waitForMovie;
        bool hostCompromised;
        netchan_t netchan;
        char netchanOutgoingBuffer[2048];
        char netchanIncomingBuffer[65536];
        netProfileInfo_t OOBProf;
        __int64 statPacketsToSend;
        int statPacketSendTime[41];
    };

    struct bdSecurityID
    {
        char ab[8];
    };
    struct XNADDR
    {
        char addrBuff[37];
    };
    struct bdSecurityKey
    {
        char ab[16];
    };
    struct XSESSION_INFO
    {
        bdSecurityID sessionID;
        XNADDR hostAddress;
        bdSecurityKey keyExchangeKey;
    };

	union $54FFFBD4E33C1C3B3F8B53E0A896B6CC
	{
		char ip[4];
		unsigned int inaddr;
	};

	struct PartyInfo
	{
		int flags;
		XSESSION_INFO info;
		netadr_t serverAddr;
		int occupiedPublicSlots;
		int occupiedPrivateSlots;
		int numPublicSlots;
		int numPrivateSlots;
		float skill;
		int geo1;
		int geo2;
		int geo3;
		int geo4;
		int ping;
		int avgPing;
		unsigned __int64 xuid;
		int upload;
	};

	enum ProberMode
	{
		PROBER_UNDEFINED = 0x0,
		PROBER_SEARCH = 0x1,
		PROBER_MERGE = 0x2,
		PROBER_INVITE = 0x3,
		PROBER_NEWLOBBY = 0x4,
		PROBER_CLIENT = 0x5,
	};

	enum ProberState
	{
		STATE_IDLE = 0x0,
		STATE_WAITING_FOR_HOSTS = 0x1,
		STATE_QOS_IN_PROGRESS = 0x2,
		STATE_QOS_COMPLETE = 0x3,
		STATE_ASSOCIATING = 0x4,
		STATE_HANDSHAKING = 0x5,
		STATE_HOST_FAILED = 0x6,
		STATE_NO_HOSTS = 0x7,
		STATE_SEARCH_EXHAUSTED = 0x8,
		STATE_CLIENT_ASSOCIATING = 0x9,
		STATE_CLIENT_HANDSHAKING = 0xA,
		STATE_CLIENT_CONNECTED = 0xB,
		STATE_CLIENT_FAILED = 0xC,
		STATE_HOST_ACCEPT = 0xD,
		STATE_CLIENTS_AGREE = 0xE,
		STATE_ALL_IN = 0xF,
		STATE_ERROR = 0x10,
	};

	struct SessionStaticData
	{
		char *sessionName;
		bool registerUsersWithVoice;
		bool isDedicated;
	};

	struct ClientInfo
	{
		bool registered;
		bool voiceRegistered;
		unsigned __int64 xuid;
		int natType;
		netadr_t addr;
		int voiceConnectivityBits;
		int lastConnectivityTestTime[1];
		bool friends;
		int flags;
		bool muted;
		int performanceValue;
		bool privateSlot;
	};

	struct RegisteredUser
	{
		bool active;
		unsigned __int64 xuid;
		bool privateSlot;
		int performanceValue;
	};

	struct SessionDynamicData
	{
		bool sessionHandle;
		XSESSION_INFO sessionInfo;
		bool keysGenerated;
		bool sessionStartCalled;
		unsigned __int64 sessionNonce;
		int privateSlots;
		int publicSlots;
		int flags;
		bool qosListenEnabled;
		ClientInfo users[19];
		ControllerIndex_t sessionCreateController;
		int sessionDeleteTime;
		int actualPublicSlots;
		int voiceConnectivityBits;
		RegisteredUser internalRegisteredUsers[19];
	};

	struct SessionData
	{
		SessionStaticData staticData;
		SessionDynamicData dyn;
	};

	struct MigrateMemberData
	{
		ClientNum_t nominee;
		int nomineeUpload;
		int nomineeNAT;
		bool nomineeOnLSP;
		bool heardFrom;
		int lastHeardFrom;
		int lastSentTo;
		bool inSameGeographicalRegion;
	};

	struct MigrateData
	{
		int indexBits;
		int startTime;
		MigrateMemberData memberData[18];
	};

	enum connstate_t
	{
		CA_DISCONNECTED = 0x0,
		CA_CINEMATIC = 0x1,
		CA_UICINEMATIC = 0x2,
		CA_LOGO = 0x3,
		CA_CONNECTING = 0x4,
		CA_CHALLENGING = 0x5,
		CA_CONNECTED = 0x6,
		CA_SENDINGSTATS = 0x7,
		CA_LOADING = 0x8,
		CA_PRIMED = 0x9,
		CA_ACTIVE = 0xA,
	};

	struct PartySceNpId
	{
		char handle[20];
		char opt[8];
		char reserved[8];
	};

	struct liveAddr
	{
		XNADDR xnaddr;
	};

	struct platformNetAdr
	{
		netadr_t netAddr;
		liveAddr liveaddr;
	};

	union $4CC444478A5CF1CA3E666352329DBEA9
	{
		int rank;
		int rankPosition;
	};

	union $6F592E3A475AB50E77AAA300354707EA
	{
		int prestige;
		int divisionID;
		int daysLastPlayed;
	};

	struct PartyMemberTeam
	{
		int team;
		int switchTeam;
		int switchTeamTime;
		int lastTeam;
	};

	struct PartyMember
	{
		char status;
		int ackedMembers;
		int lastPacketTime;
		int lastHeartbeatTime;
		int lastPartyStateAck;
		int lastDemoHeartBeatTime;
		unsigned int challenge;
		int subpartyIndex;
		connstate_t reportedConnState;
		bool invited;
		bool headsetPresent;
		bool inLivePartyVoice;
		bool inLivePartyTalking;
		bool finishedLoadingDemo;
		bool isReady;
		bool isGuest;
		bool isSplitscreenClient;
		int natType;
		unsigned __int64 player;
		char gamertag[32];
		ControllerIndex_t localControllerIndex;
		int playerEmblem;
		PartySceNpId npid;
		char clanAbbrev[5];
		bool clanAbbrev_IsEliteValidated;
		int codPoints;
		unsigned int affinityBits;
		platformNetAdr platformAddr;
		int availableMapPackFlags;
		bdSecurityID privatePartyId;
		$4CC444478A5CF1CA3E666352329DBEA9 ___u30;
		$6F592E3A475AB50E77AAA300354707EA ___u31;
		int deaths;
		float skillRating;
		float skillVariance;
		PartyMemberTeam teamInfo;
		int score;
		int vetoedMap;
		int downloadPercent;
		bool readyForPlayback;
		int maximumPing;
		int specialFlags;
		int clanTagFeature;
		int voiceConnectivityBits;
		unsigned __int64 leagueTeamID;
		int leagueMemberCount;
		int searchStartUTC;
		int uploadBandwidth;
		char probation;
		char recentPlaylistEntries[3];
		unsigned int serverchallenge;
		int serverChallengeDeadline;
	};

	struct PartyMemberProfile
	{
		int updateTime;
		int sendTime;
		int ackTime;
		int acked;
		char DDL[1024];
	};

	enum PartyLeagueState
	{
		LEAGUE_WAITING_FOR_STATS = 0x0,
		LEAGUE_FORMING_TEAMS = 0x1,
		LEAGUE_CANNOT_FORM_TEAMS = 0x2,
		LEAGUE_SENDING_OUTCOMES = 0x3,
		LEAGUE_READY_TO_GO = 0x4,
	};

	enum LeagueDataState
	{
		LEAGUE_DATA_REQUESTING_BASE = 0x0,
		LEAGUE_DATA_BASE_RECEIVED = 0x1,
		LEAGUE_DATA_SENDING_OUTCOMES = 0x2,
		LEAGUE_DATA_OUTCOMES_ACKED = 0x3,
	};

	struct LeagueStats
	{
		int rankPoints;
		int rank;
		float floats[3];
		int ints[8];
	};

	struct LeagueOutcomes
	{
		LeagueStats base;
		LeagueStats winner;
		LeagueStats loser;
	};

	struct PartyMemberLeagueData
	{
		LeagueDataState state;
		int stateChangeTime;
		int stateUpdateTime;
		unsigned __int64 teamID;
		unsigned __int64 subdivisionID;
		int divisionID;
		int memberCount;
		char teamName[32];
		LeagueOutcomes outcomes;
	};

	struct PartyLeagueTeamData
	{
		unsigned __int64 teamID;
		bool valid;
		char name[32];
	};

	struct SubpartyMember
	{
		int memberIndex;
		char *gamertag;
		int lastTeam;
		unsigned int affinityBits;
	};

	struct SubpartyInfo
	{
		SubpartyMember members[18];
		bool links[18];
		int count;
		float skill;
		int skillRanking;
		int searchStartUTC;
		int score;
		int team;
	};

	struct lobbyBanSlot_t
	{
		unsigned __int64 bannedXuid;
		int banTime;
	};

	struct PartyHostDetails
	{
		netadr_t addr;
		XSESSION_INFO sessionInfo;
		unsigned __int64 xuid;
		int lastPacketTime;
		int lastPacketSentTime;
		int numPrivateSlots;
		int numPublicSlots;
		ClientNum_t hostNum;
		bool accepted;
		unsigned int challenge;
		bool isDedicated;
	};

	struct PartyHostData
	{
		int partyStateChangeTime;
		int stateSequenceNumber;
		int expectedPlayers;
		int vetoPassTime;
		int uiState;
		int uiEvent;
		int uiEventTime;
		int sessionSendTime;
		int lastValidLeagueTime;
		char votePossible;
		bool preloadingMap;
		bool firstLobby;
		bool migrateAfterRound;
		bool stopAfterRound;
		bool readyToStart;
		bool initialAckComplete;
	};

	enum MergeDedicatedState
	{
		MERGE_DEDICATED_COMPLETE = 0x0,
		MERGE_DEDICATED_NOT_REQUESTED = 0x1,
		MERGE_DEDICATED_REQUESTED = 0x2,
		MERGE_DEDICATED_IN_PROGRESS = 0x3,
	};

	struct partyMergeData_t
	{
		int timeSinceLastJoin;
		int lastSessionSearch;
		MergeDedicatedState dedicatedState;
	};

	struct PartyStatePacket_s
	{
		int sequenceNumber;
		int totalSize;
		int size;
		int offset;
	};

	struct PartyData_s
	{
		SessionData *session;
		SessionData *presenceSession;
		MigrateData migrateData;
		PartyMember partyMembers[19];
		PartyMemberProfile partyProfiles[19];
		PartyLeagueState leagueState;
		PartyMemberLeagueData memberLeagueData[19];
		PartyLeagueTeamData leagueTeamData[9];
		SubpartyInfo subparties[19];
		int subpartyCount;
		lobbyBanSlot_t lobbyBans[16];
		int partyJoinTime;
		PartyHostDetails currentHost;
		PartyHostDetails potentialHost;
		PartyHostData hostData;
		__declspec(align(8)) partyMergeData_t mergeData;
		float qosPercent;
		int qosSuccesses;
		int qosTotal;
		int localPlayerFlags[1];
		int lastMemberUpdateTime[1];
		int memberUpdateInterval[1];
		int areWeHost;
		int joiningAnotherParty;
		int inParty;
		int party_systemActive;
		int veto;
		bool enteringStartReadyState;
		bool ready;
		int wagerTime;
		int allowedTeams;
		bool teamBased;
		unsigned __int64 demoFileId;
		int demoFileSize;
		bool demoIsUserFile;
		bool finishedLoadingDemo;
		bool retryDemoDownload;
		unsigned __int64 demoAuthorXUID;
		int partyId;
		int nextSessionSearchTime;
		int mapPackSearchFlags;
		int mapPackFlags;
		unsigned __int64 leagueTeamID;
		char leagueTeamName[32];
		int lastPartyStateTime;
		int gameStartTime;
		int interEndTime;
		int partyTimer;
		int restartMatchmakingTimer;
		int goResumeTime;
		int hostTimeouts;
		char lobbyFlags;
		PartyData_s *partyToNotify;
		bool registeredWithArbitration;
		bool rejoining;
		char stateMsgBuf[7200];
		PartyStatePacket_s partyStatePackets[6];
		char lastEntries[8];
		int currentEntry;
		int lastQosEntry;
		bool qosDataReady;
		int lobbyBeginTime;
		bool stateParsed;
		int soundEvents;
		int hostChangelist;
		int partyStartTimeMs;
		int nextChallengeSend;
		unsigned int serverChallenge;
	};

	enum searchSessionMode_t
	{
		SEARCH_SESSION_MODE_INVALID = 0x0,
		SEARCH_SESSION_MODE_PUBLIC = 0x1,
		SEARCH_SESSION_MODE_LEAGUE = 0x2,
		SEARCH_SESSION_MODE_LOBBY_MERGE = 0x3,
		SEARCH_SESSION_MODE_DEDICATED_SERVER = 0x4,
		SEARCH_SESSION_MODE_COUNT = 0x5,
	};

	struct PartyProber
	{
		PartyInfo hosts[50];
		int hostCount;
		ProberMode mode;
		ProberState state;
		ControllerIndex_t controllerIndex;
		int partyId;
		PartyData_s *partyToNotify;
		searchSessionMode_t searchMode;
		int minPlayers;
		int requiredFlags;
		int searchStartUTC;
		netadr_t masterAddr;
		int echoChallenge;
		PartyInfo echoHost;
		int echoHostNum;
		int clientDisagreeTime[18];
		int clientAgreeTime[18];
		int clientPacketTime;
		int clientWaitStart;
		int hostIndex;
		netadr_t hostAddr;
		unsigned int hostChallenge;
		int hostNum;
		int nextSearchTime;
		int packetStartTime;
		int packetRecvTime;
		int packetSendTime;
		int retryCount;
		char errorMessage[256];
	};

#pragma pack(push, 1)

	enum XFilePlatform
	{
		// These seem to have the same version as XBOX360
		PLATFORM_PS3,
		PLATFORM_WIIU,

		PLATFORM_XBOX360 = 0x92, // 0x92000000 if taking care of endianness
		PLATFORM_PC = 0x93,

		PLATFORM_CUSTOM = 0x1337,
	};

	struct XFileHeaderRaw
	{
		uint64_t magic;
		XFilePlatform platform;
	};

	struct XFileHeaderUnsigned
	{
		XFileHeaderRaw r;
		uint64_t identifier;
		uint32_t empty; // Seems to be always 0. Padding?
		char name[32];
	};

	struct XFileHeaderSigned
	{
		XFileHeaderUnsigned u;
		uint8_t signature[0x100];
	};

	struct XFileBlock
	{
		DWORD size;
		uint8_t data[1];
	};

	struct XFileSigned
	{
		XFileHeaderSigned header;
		XFileBlock block;
	};

	struct ZoneHeader
	{
		XFile xFile;
		XAssetList assetList;
	};

#pragma pack(pop)

// #pragma pack(push, 1)
    struct PredictedVehicleDef
    {
        bool fullPhysics;
        vec3_t origin;
        vec3_t angles;
        vec3_t tVel;
        vec3_t aVel;
        int serverTime;
    };
// #pragma pack(pop)

    struct clientHeader_t
    {
        int state;
        int sendAsActive;
        int deltaMessage;
        int rateDelayed;
        int hasAckedBaselineData;
        int hugeSnapshotSent;
        netchan_t netchan;
        vec3_t predictedOrigin;
        int predictedOriginServerTime;
        int migrationState;
        PredictedVehicleDef predictedVehicle;
    };

    struct svscmd_info_t
    {
        char *cmd;
        int time;
        int type;
    };

    struct clientSnapshot_t
    {
        playerState_s ps;
        int entityCount;
        int clientCount;
        int actorCount;
        int matchStateIndex;
        int firstEntityIndex;
        int firstClientIndex;
        int firstActorIndex;
        int messageSent;
        int messageAcked;
        int messageSize;
        int serverTime;
        int physicsTime;
        int timeDelta;
        int baselineSnap;
    };

    struct client_t
    {
        void $() { sizeof(*this); }
        clientHeader_t header;
        const char *dropReason;
        char userinfo[1024];
        char reliableCommandBuffer[16384];
        int reliableCommandBufferNext;
        svscmd_info_t reliableCommandInfo[128];
        int reliableSequence;
        int reliableAcknowledge;
        int reliableSent;
        int messageAcknowledge;
        int gamestateMessageNum;
        usercmd_s lastUsercmd;
        int lastClientCommand;
        char lastClientCommandString[1024];
        gentity_t *gentity;                     
        char name[32];
        char clanAbbrev[5];
        int clanAbbrev_IsEliteValidated;
        unsigned __int64 xuid;
        unsigned __int64 teamid;
        unsigned int doubleXPGroupMask;
        unsigned int availableMappackFlags;
        int nextReliableTime;
        int nextReliableCount;
        char reservedSlot;
        int lastPacketTime;
        int lastConnectTime;
        int nextSnapshotTime;
        int lastSnapshotTime;
        int timeoutCount;
        clientSnapshot_t frames[16];
        int ping;
        int pingMin;
        int pingMax;
        int unackCount;
        int rate;
        int pureAuthentic;
        int packetUploadCount;
        __declspec(align(128)) char netchanOutgoingBuffer[65536];
        char netchanIncomingBuffer[2048];
        int guid;
        unsigned __int16 scriptId;
        bool bIsSplitscreenClient;
        bool bIsSecondScreenClient;
        int bIsTestClient;
        int serverId;
        int natType;
        char stats[50176];
        char purchasedItems[32];
        int unlockedAttachments[64];
        char bonusCardsActive[10];
        char modifiedStatBytes[6272];
        int statsSentIndex;
        int statsModified;
        __int64 statPacketsReceived;
        int statsValidated;
        bool liveAuthorized;
        int liveAuthFlags;
        char liveAuthFailCount;
        int liveAuthTimestamp;
        unsigned __int64 liveUserID;
        bool tempPacketDebugging;
        int snapshotHistoryTime;
        int snapshotHistoryFrames;
        int messageHistorySize;
        int demoPacketCount;
        int demoPacketSizes[8];
        int demoPacketIsFragment[8];
        int demoReliableCmdSize;
        char demoReliableCmdItemChars[16];
        int demoReliableCmdItemSize[16];
        int demoReliableCmdCount;
        unsigned int lastHashedXP;
        int lastSmallDeltaTime;
        int lastSnapSentTime;
    };

    struct color
    {
        std::uint8_t r;
        std::uint8_t g;
        std::uint8_t b;
        std::uint8_t a;
    };

    struct persistentStats
    {
        char statsBuffer[50176];
        bool isChecksumValid;
        bool statsWriteNeeded;
        bool statsValidatedWithDDL;
        bool statsFetched;
        bool disableUpload;
    };

    enum ddlReturnCodes_e
    {
        DDL_RC_SUCCESS = 0x0,
        DDL_RC_ERROR = 0xFFFFFFFF,
        DDL_RC_BUFFER_IO_ERROR = 0xFFFFFFFE,
        DDL_RC_STATE_INVALID = 0xFFFFFFFD,
        DDL_RC_MEMBER_NULL = 0xFFFFFFFC,
        DDL_RC_MEMBER_INVALID = 0xFFFFFFFB,
        DDL_RC_OFFSET_INVALID = 0xFFFFFFFA,
        DDL_RC_TRUNCATED = 0xFFFFFFF9,
    };

    enum statsLocation
    {
        STATS_LOCATION_NORMAL = 0x0,
        STATS_LOCATION_FORCE_NORMAL = 0x1,
        STATS_LOCATION_BACKUP = 0x2,
        STATS_LOCATION_STABLE = 0x3,
        STATS_LOCATION_OTHERPLAYER = 0x4,
        STATS_LOCATION_COUNT = 0x5,
    };

    struct ddlState_t
    {
        int absoluteOffset;
        int arrayIndex;
        ddlMemberDef_t *member;
        ddlDef_t *ddl;
        ddlReturnCodes_e returnCode;
    };

    typedef struct _gscFunction
    {
        DWORD crc32;                            // 0x00 - CRC32 of function bytecode
        DWORD start;                            // 0x04 - A relative pointer to the GSC bytecode start of this function
        WORD name;                              // 0x08 - A relative pointer to the name of this function
        BYTE numOfParameters;                   // 0x0A -
        BYTE flag;                              // 0x0B -
        /*
        Possible flag values (not sure if all of them):

        - If flag & 1, function loaded (I think?)
        */
    } gscFunction;

    typedef struct _COD9_GSC
    {
        BYTE identifier[8];                     // 0x00 - It's the same always
        BYTE unknown1[4];                       // 0x08 - I think it's some kind of checksum
        DWORD includeStructs;                   // 0x0C - A relative pointer to an array of includeStruct structs, amount = numOfIncludes
        DWORD usinganimtreeStructs;             // 0x10 - A relative pointer to an array of usinganimtreeStruct structs, amount = numOfUsinganimtree
        DWORD codeSectionStart;                 // 0x14 - A relative pointer to where the GSC bytecode starts (gscFunctions)
        DWORD gscStrings;                       // 0x18 - A relative pointer to an array of gscString structs, amount = numOfStrings
        DWORD gscFunctions;                     // 0x1C - A relative pointer to an array of gscFunction structs, amount = numOfFunctions
        DWORD externalFunctions;                // 0x20 - A relative pointer to an array of externalFunction structs, amount = numOfExternalFunctions
        DWORD gscRelocations;                   // 0x24 - A relative pointer to an array of gscRelocation structs, amount = numOfRelocations
        DWORD size;                             // 0x28 -
        DWORD codeSectionSize;                  // 0x2C - Size of the executable bytecode
        WORD name;                              // 0x30 - A relative pointer to the name of this gsc (with full path and extension, null terminated)
        WORD numOfStrings;                      // 0x32 - IMPORTANT: Includes everything except #include strings, #using_animtree strings and function name strings
        WORD numOfFunctions;                    // 0x34 - Number of functions in this script file
        WORD numOfExternalFunctions;            // 0x36 - Number of functions imported
        WORD numOfRelocations;                  // 0x38 - Number of patches in the GSC code/file
        BYTE unknown4[2];                       // 0x3A - ?
        BYTE numOfIncludes;                     // 0x3C - Number of included source files
        BYTE numOfUsinganimtree;                // 0x3D - Number of included animation trees
        BYTE _padding[2];                       // 0x3E - Struct padding
    } COD9_GSC; // size: 64 bytes

    enum hitLocation_t
    {
        HITLOC_NONE = 0x0,
        HITLOC_HELMET = 0x1,
        HITLOC_HEAD = 0x2,
        HITLOC_NECK = 0x3,
        HITLOC_TORSO_UPR = 0x4,
        HITLOC_TORSO_MID = 0x5,
        HITLOC_TORSO_LWR = 0x6,
        HITLOC_R_ARM_UPR = 0x7,
        HITLOC_L_ARM_UPR = 0x8,
        HITLOC_R_ARM_LWR = 0x9,
        HITLOC_L_ARM_LWR = 0xA,
        HITLOC_R_HAND = 0xB,
        HITLOC_L_HAND = 0xC,
        HITLOC_R_LEG_UPR = 0xD,
        HITLOC_L_LEG_UPR = 0xE,
        HITLOC_R_LEG_LWR = 0xF,
        HITLOC_L_LEG_LWR = 0x10,
        HITLOC_R_FOOT = 0x11,
        HITLOC_L_FOOT = 0x12,
        HITLOC_GUN = 0x13,
        HITLOC_SHIELD = 0x14,
        HITLOC_NUM = 0x15,
    };

    enum meansOfDeath_t
    {
        MOD_UNKNOWN = 0x0,
        MOD_PISTOL_BULLET = 0x1,
        MOD_RIFLE_BULLET = 0x2,
        MOD_GRENADE = 0x3,
        MOD_GRENADE_SPLASH = 0x4,
        MOD_PROJECTILE = 0x5,
        MOD_PROJECTILE_SPLASH = 0x6,
        MOD_MELEE = 0x7,
        MOD_BAYONET = 0x8,
        MOD_HEAD_SHOT = 0x9,
        MOD_CRUSH = 0xA,
        MOD_TELEFRAG = 0xB,
        MOD_FALLING = 0xC,
        MOD_SUICIDE = 0xD,
        MOD_TRIGGER_HURT = 0xE,
        MOD_EXPLOSIVE = 0xF,
        MOD_IMPACT = 0x10,
        MOD_BURNED = 0x11,
        MOD_HIT_BY_OBJECT = 0x12,
        MOD_DROWN = 0x13,
        MOD_GAS = 0x14,
        MOD_NUM = 0x15,
    };

    struct BuiltinFunctionDef
    {
        const char *actionString;
        unsigned int constId;
        int min_args;
        int max_args;
        void(__cdecl *actionFunc)();
        Game::scriptInstance_t type;
    };

    enum class ClassNum : std::uint16_t
    {
        entity,
        hudelem,
        pathnode,
        vehicle,
        dynent,

        max,
    };

    struct scr_entref_t
    {
        unsigned __int16 entnum;
        ClassNum classnum;
        LocalClientNum_t client;
    };

    struct BuiltinMethodDef
    {
        const char *actionString;
        unsigned int constId;
        int min_args;
        int max_args;
        void(__cdecl *actionFunc)(scr_entref_t);
        int type;
    };

    struct VariableStackBuffer
    {
        char *pos;
        char *creationPos;
        int waitTime;
        unsigned __int16 size;
        unsigned __int16 bufLen;
        unsigned __int16 localId;
        char buf[1];
    };

    union VariableUnion
    {
        int intValue;
        unsigned int uintValue;
        float floatValue;
        unsigned int stringValue;
        const float *vectorValue;
        char *codePosValue;
        unsigned int pointerValue;
        VariableStackBuffer *stackValue;
        unsigned int entityOffset;
    };

    struct VariableValue
    {
        int type;
        VariableUnion u;
    };

    struct gscProfileInfo_t
    {
        unsigned int inclusive_time;
        unsigned int exclusive_time;
        unsigned int hit_count;
    };

    struct SCR_PROFILER_DATA
    {
        gscProfileInfo_t *profileInfo[8];
        int profileInfoCount;
    };

    struct function_stack_t
    {
        char *pos;
        VariableValue *top;
        unsigned int localId;
        unsigned int localVarCount;
        VariableValue *startTop;
        // SCR_PROFILER_DATA profileData;
    };

    struct function_frame_t
    {
        function_stack_t fs;
        char *creationPos;
    };

    struct scrVmPub_t
    {
        unsigned int *localVars;
        VariableValue *maxstack;
        int function_count;
        function_frame_t *function_frame;
        VariableValue *top;
        bool debugCode;
        bool abort_on_error;
        bool terminal_error;
        bool block_execution;
        unsigned int inparamcount;
        unsigned int outparamcount;
        unsigned int breakpointOutparamcount;
        bool showError;
        function_frame_t function_frame_start[32];
        VariableValue stack[2048];
        void(__cdecl *notifyListeners[1])(unsigned int, unsigned int);
    };

    enum fieldtype_t
    {
        F_INT = 0x0,
        F_SHORT = 0x1,
        F_BYTE = 0x2,
        F_FLOAT = 0x3,
        F_LSTRING = 0x4,
        F_STRING = 0x5,
        F_VECTOR = 0x6,
        F_ENTITY = 0x7,
        F_ENTHANDLE = 0x8,
        F_ACTOR = 0x9,
        F_SENTIENT = 0xA,
        F_SENTIENTHANDLE = 0xB,
        F_CLIENT = 0xC,
        F_PATHNODE = 0xD,
        F_ACTORGROUP = 0xE,
        F_VECTORHACK = 0xF,
        F_OBJECT = 0x10,
        F_XMODEL_INDEX = 0x11,
        F_XMODEL = 0x12,
        F_BITFLAG = 0x13,
        F_FX = 0x14,
    };

    struct GfxSkinCacheEntry
    {
        unsigned int frameCount;
        int skinnedCachedOffset;
        unsigned __int16 numSkinnedVerts;
        unsigned __int16 ageCount;
    };

    struct clientControllers_t
    {
        vec3_t angles[6];
        vec3_t tag_origin_angles;
        vec3_t tag_origin_offset;
    };

    struct CEntPlayerInfo
    {
        clientControllers_t *control;
        char tag[6];
        float waterHeight;
        int nextWaterHeightCheck;
        int nextRippleTime;
    };

    struct CEntTurretAngles
    {
        float pitch;
        float yaw;
        float barrelPitch;
    };

    union $8881F8B9B9745D8A0D51B30E12AE0899
    {
        CEntTurretAngles angles;
        vec3_t viewAngles;
    };

    struct CEntTurretInfo
    {
        $8881F8B9B9745D8A0D51B30E12AE0899 ___u0;
        bool playerUsing;
        float minigunRotation;
        float minigunRotationSpeed;
        char tag_aim;
        char tag_aim_animated;
        char tag_flash;
        char tag_spin;
        char tag_turret;
        char tag_barrel;
        float barrelPitch;
        float pivotOffset;
        float firingOffset;
        char tag_aim_pivot;
        char tag_weapon;
    };

    struct CEntVehicleDefGround
    {
        float wheelHeight[6];
        float nitrousWheelRotation[6];
        __int16 nitrousWheelYaw[6];
        char tag_extra_tank_wheels[4];
    };

    struct CEntVehicleRotor
    {
        float rotation;
        float speed;
        char tag;
        char orientation;
        char armTag;
        float armRotation;
    };

    struct CEntVehicleDefAir
    {
        CEntVehicleRotor rotor[4];
    };

    union $DDFE80AE35AB3F66A64EFC458D0A39ED
    {
        CEntVehicleDefGround ground;
        CEntVehicleDefAir air;
    };

    struct CEntVehicleDef
    {
        float barrelRecoil;
        __int16 pitch;
        __int16 roll;
        __int16 barrelYaw;
        __int16 barrelPitch;
        __int16 steerYaw;
        __int16 steerPitch;
        __int16 gunnerPitch[4];
        __int16 gunnerYaw[4];
        __int16 minigunRotation;
        __int16 antennaPitch[2];
        __int16 antennaRoll[2];
        char wheelBoneIndex[6];
        char tag_body;
        char tag_turret;
        char tag_barrel;
        char tag_barrel_recoil;
        char tag_gunner_turret[4];
        char tag_gunner_barrel[4];
        char tag_player;
        char tag_minigun_spin;
        char tag_antennas[2];
        $DDFE80AE35AB3F66A64EFC458D0A39ED ___u22;
    };

    struct CEntFx
    {
        int triggerTime;
        unsigned int effect;
    };

    union $B5C6484BFC4A9A509FCDCE318554591E
    {
        float height;
        float yaw;
    };

    struct CEntActorInfo
    {
        int proneType;
        float pitch;
        float roll;
        char headBone;
        $B5C6484BFC4A9A509FCDCE318554591E ___u4;
        float waterHeight;
        int nextWaterHeightCheck;
        int nextRippleTime;
        float lookAtBlend;
        char lookAtFlags;
    };

    struct CEntGeneral
    {
        int contents;
        bool linked;
        vec3_t mins;
        vec3_t maxs;
    };

    union $6DCAC28DCBF7B63C461B9EFCE53C6FF6
    {
        CEntPlayerInfo player;
        CEntTurretInfo turret;
        CEntVehicleDef vehicle;
        CEntFx fx;
        CEntActorInfo actor;
        CEntGeneral general;
    };

    struct ShaderConstantSet
    {
        vec4_t value[7];
        char constantSource[7];
        char used;
    };

    struct cpose_t
    {
        unsigned __int16 lightingHandle;
        char eType;
        char eTypeUnion;
        char localClientNum;
        char isRagdoll;
        int ragdollHandle;
        int physObjId;
        int physUserBody;
        int killcamRagdollHandle;
        int physUserBodyProneFeet;
        char destructiblePose;
        int startBurnTime;
        float wetness;
        int cullIn;
        vec3_t origin;
        vec3_t angles;
        vec3_t absmin;
        vec3_t absmax;
        GfxSkinCacheEntry skinCacheEntry;
        $6DCAC28DCBF7B63C461B9EFCE53C6FF6 ___u19;
        ShaderConstantSet constantSet;
    };

    struct $4E48DA81AE6944637E6E45560C08B001
    {
        unsigned __int32 relativeAnglesSet : 1;
        unsigned __int32 identityLinkto : 1;
    };

    union $D4F728D1B967197453543DD7D1CB7091
    {
        unsigned int packed_bits;
        $4E48DA81AE6944637E6E45560C08B001 __s1;
    };

    struct cLinkInfo_s
    {
        vec3_t axis[4];
        int linkEnt;
        int linkTag;
        vec3_t relativeAngles;
        $D4F728D1B967197453543DD7D1CB7091 ___u4;
    };

    struct cgVehicleWheelEffect
    {
        int surfaceType;
        int lastSurfaceType;
    };

    enum VehicleEngineState
    {
        VEH_ENGINE_STATE_IDLE = 0x0,
        VEH_ENGINE_STATE_IN_GEAR = 0x1,
        VEH_ENGINE_STATE_SHIFT_UP = 0x2,
        VEH_ENGINE_STATE_SHIFT_DOWN = 0x3,
    };

    struct Engine
    {
        float throttle;
        float load;
        int currentGear;
        float rpms;
        float targetDownShiftRPM;
        float inAirTime;
        bool onGround;
        VehicleEngineState state;
    };

    struct cgVehicle_t
    {
        int lastGunnerFire[4];
        int wheelSurfType[6];
        int fireTime;
        int flags;
        float materialTime;
        float materialTime2;
        vehicle_cache_t *vehicle_cache;
        cgVehicleWheelEffect wheelEffects[3];
        unsigned int notes[2];
        int driveBySoundIndex[2];
        float driveBySoundDelay[2];
        float driveBySoundTimeout[2];
        float prevTurretPitch;
        float prevTurretYaw;
        float prevGunnerPitch[4];
        float prevGunnerYaw[4];
        float prevAngularVelocity[5];
        Engine engine;
        float minigunRotationSpeed;
        vec3_t gunSoundOrigins[5];
        char wasFiring;
        vec3_t antennaPos[2];
        vec3_t antennaVel[2];
        vec3_t antennaParentBoneWorldAxis[2][3];
        vec3_t antennaRelativePos[2];
        vec3_t poseAxis[4];
    };

    struct cached_client_tag_t
    {
        int time;
        vec3_t lastLocalTagOrigin;
        bool visible;
        int predictedTime;
        vec3_t predictedPosition;
        vec3_t predictedAngles;
    };

    struct ClientTagCache
    {
        cached_client_tag_t aim_head_tag;
        cached_client_tag_t aim_highest_tag;
        cached_client_tag_t tag_flash;
    };

    struct AimTargetCache
    {
        int lastUpdateTime;
        float targetHeight;
    };

    struct cgScriptMover_s
    {
        float decelTime;
        float aDecelTime;
        float speed;
        float aSpeed;
        float midTime;
        float aMidTime;
        vec3_t pos1;
        vec3_t pos2;
        vec3_t pos3;
        vec3_t apos1;
        vec3_t apos2;
        vec3_t apos3;
    };

    struct canimscripted_t
    {
        vec3_t axis[4];
        unsigned __int16 anim;
        char bStarted;
    };

    struct centity_t;
    struct _cgZBarrierPiece_t
    {
        centity_t *pPiece;
        XModel *curXModel;
        void(__cdecl *pStateLogic)(LocalClientNum_t, cg_t *, centity_t *, ZBarrierDef *, _cgZBarrierPiece_t *, LerpEntityStateZBarrierPiece *, unsigned int);
        int timeVal;
        int intVal;
        char state;
        char prevState;
        char subState;
        char nextSubState;
        char curAnim;
        bool flagsChanged;
    };

    struct cgZBarrier_s
    {
        bool forceUpdateForDemoJump;
        _cgZBarrierPiece_t pieces[6];
    };

    union $E5F00115C9C447EB243E515D96FCD8A7
    {
        WeaponDef *weapDef;
        WeaponAttachmentUnique *attachment;
    };

    struct WeaponDobjInfo
    {
        enum Slot
        {
            HELD = 0x0,
            STOWED = 0x1,
            MELEE = 0x2,
        };
        struct ModelMask
        {
            WeaponDobjInfo::Slot slot;
            bool weapon;
            $E5F00115C9C447EB243E515D96FCD8A7 ___u2;
            unsigned int dobjModelMask;
        };

        char numModelMasks;
        WeaponDobjInfo::Slot addingSlot;
        __int16 lastAddedModel;
        WeaponDobjInfo::ModelMask modelMasks[8];
    };

    struct DroppedWeaponDobjInfo
    {
        int entnum;
        WeaponDobjInfo weaponDobjInfo;
    };

    struct $2C268F07489A8B2B324034942807AD28
    {
        unsigned __int32 applyLeftHandIK : 1;
        unsigned __int32 nextValid : 1;
        unsigned __int32 bMuzzleFlash : 1;
        unsigned __int32 bMuzzleFlashLeft : 1;
        unsigned __int32 bMuzzleFlashLastShot : 1;
        unsigned __int32 bShellEject : 1;
        unsigned __int32 bShellEjectLeft : 1;
        unsigned __int32 bTrailMade : 1;
        unsigned __int32 isBurning : 1;
        unsigned __int32 skipBloodImpacts : 1;
        unsigned __int32 heroBloodImpact : 1;
        unsigned __int32 scriptThreaded : 1;
        unsigned __int32 clientRumbleLoop : 1;
        unsigned __int32 didOverheatFx : 1;
        unsigned __int32 leftFootstep : 1;
        unsigned __int32 rightFootstep : 1;
        unsigned __int32 leftRearFootstep : 1;
        unsigned __int32 rightRearFootstep : 1;
        unsigned __int32 bIsTrigger : 1;
        unsigned __int32 bIsTriggerRadius : 1;
        unsigned __int32 bIsTriggerBox : 1;
        unsigned __int32 bIsOneShot : 1;
        unsigned __int32 bIsPlaneOnRadar : 1;
        unsigned __int32 bFloatLonger : 1;
        unsigned __int32 bForceBuoyancy : 1;
        unsigned __int32 bIgnoreRagdoll : 1;
        unsigned __int32 bClientFlagsNeedProcessing : 1;
        unsigned __int32 bUpdatedSinceReset : 1;
        unsigned __int32 bUpdateToggle : 1;
        unsigned __int32 bZombieEyeGlowHasBeenTurnedOn : 1;
        unsigned __int32 bFakeEntityMoving : 1;
        unsigned __int32 bFakeEntityTurning : 1;
        unsigned __int32 bFakeEntityRemoved : 1;
        unsigned __int32 originAnglesError : 1;
        unsigned __int32 partOfZBarrier : 1;
        unsigned __int32 linkRelativeAngles : 1;
        unsigned __int32 sndTurretWasFiring : 1;
        unsigned __int32 clientMainThreaded : 1;
        unsigned __int32 renderInThirdPersonSpectate : 1;
        unsigned __int32 overrideLightingOrigin : 1;
        unsigned __int32 forceNotSimple : 1;
    };

    union $11702CD5E47195B9D77913842C0F63DA
    {
        unsigned int packed_bits[2];
        $2C268F07489A8B2B324034942807AD28 __s1;
    };

    struct centity_t
    {
        cpose_t pose;
        LerpEntityState prevState;
        entityState_s nextState;
        __int16 previousEventSequence;
        int miscTime;
        int lastMuzzleFlash;
        int numShotsFiredLast;
        unsigned __int16 attachModelNames[2];
        unsigned __int16 attachTagNames[2];
        XAnimTree_s *tree;
        Destructible *destructible;
        NitrousVehicle *nitrousVeh;
        cLinkInfo_s *linkInfo;
        cgVehicle_t *vehicle;
        ClientTagCache *clientTagCache;
        AimTargetCache *aimTargetInfo;
        cgScriptMover_s *cScriptMover;
        canimscripted_t *scripted;
        cgZBarrier_s *zbarrier;
        DroppedWeaponDobjInfo *droppedWeaponDobjInfo;
        int nextSlideFX;
        unsigned __int16 flagIndex;
        unsigned __int16 flagState;
        Material *compassMaterial;
        int lastTrailTime;
        unsigned int fxTrailHandle;
        unsigned int fxProjExplosion;
        unsigned int fxHeartbeat;
        unsigned int fxLaserSight;
        vec3_t oldLinkOrigin;
        vec3_t originError;
        vec3_t anglesError;
        char tracerDrawRateCounter;
        centity_t *updateDelayedNext;
        unsigned __int16 classname;
        unsigned int stepSound;
        char footstepSurfaceOverride;
        char deployedRiotshieldHits[8];
        $11702CD5E47195B9D77913842C0F63DA ___u38;
    };

    struct cent_field_s
    {
        const char *name;
        unsigned int constId;
        int ofs;
        int size[1];
        fieldtype_t type;
        void(__cdecl *setter)(centity_t *, cent_field_s *);
        void(__cdecl *getter)(centity_t *, cent_field_s *);
    };

    union $48F18C9B5E91F84575999A8D859164D3
    {
        void(__cdecl *floatCallbackFunc)(LocalClientNum_t, unsigned int, float, float, bool, bool, const char *, bool);
        void(__cdecl *uintCallbackFunc)(LocalClientNum_t, unsigned int, unsigned int, unsigned int, bool, bool, const char *, bool);
    };

    struct clientFieldCodeCallback_s
    {
        unsigned __int32 bHasCodeCallback : 1;
        unsigned __int32 bCodeCallbackIsFloatVal : 1;
        $48F18C9B5E91F84575999A8D859164D3 ___u2;
    };

    struct clientField_s
    {
        int scriptCallbackFunc;
        clientFieldCodeCallback_s codeCallbackFunc;
        unsigned __int16 nameHash;
        unsigned int fieldOffset;
        unsigned int fieldType;
        float floatMin;
        float floatMax;
        unsigned int accessMask;
        int bSplitscreenHostOnly;
        int bCallbacksFor0WhenNew;
        char bitOffset;
        unsigned int numBits;
        unsigned int version;
    };

    struct ent_field_t
    {
        const char *name;
        int ofs;
        int size[1];
        fieldtype_t type;
        void(__cdecl *callback)(gentity_t *, int);
    };

    struct client_fields_s
    {
        typedef gclient_t* Ptr;

        const char *name;
        unsigned int constId;
        int ofs;
        int size[1];
        fieldtype_t type;
        unsigned int whichbits;
        void(__cdecl *setter)(gclient_t *, client_fields_s *);
        void(__cdecl *getter)(gclient_t *, client_fields_s *);
    };

    struct actor_fields_s
    {
        typedef actor_t* Ptr;

        const char *name;
        unsigned int constId;
        int ofs;
        int size[1];
        fieldtype_t type;
        void(__cdecl *setter)(actor_t *, actor_fields_s *);
        void(__cdecl *getter)(actor_t *, actor_fields_s *);
    };

    struct game_hudelem_s
    {
        hudelem_s elem;
        ClientNum_t clientNum;
        int team;
        int archived;
    };

    struct game_hudelem_field_t
    {
        typedef game_hudelem_s* Ptr;

        const char *name;
        unsigned int constId;
        int ofs;
        int size;
        fieldtype_t type;
        int mask;
        int shift;
        void(__cdecl *setter)(game_hudelem_s *, int);
        void(__cdecl *getter)(game_hudelem_s *, int);
    };


#ifdef __cplusplus
}
#pragma warning(pop)
#endif

```

`src/generic/Utils/Compression.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Compression
	{
		std::string ZLib::Compress(std::string data)
		{
			Utils::Memory::Allocator allocator;
			unsigned long length = uint32_t(data.size() * 2);
			if (!length) length = 2;

			// Make sure the buffer is large enough
			if (length < 100) length *= 10;

			char* buffer = allocator.allocateArray<char>(length);
			if (compress2(reinterpret_cast<Bytef*>(buffer), &length, reinterpret_cast<Bytef*>(const_cast<char*>(data.data())), uint32_t(data.size()), Z_BEST_COMPRESSION) != Z_OK)
			{
				return "";
			}

			data.clear();
			data.append(buffer, length);

			return data;
		}

		std::string ZLib::Decompress(std::string data)
		{
			z_stream stream;
			ZeroMemory(&stream, sizeof(stream));
			std::string buffer;

			if (inflateInit(&stream) != Z_OK)
			{
				return "";
			}

			int ret;
			Utils::Memory::Allocator allocator;

			uint8_t* dest = allocator.allocateArray<uint8_t>(CHUNK);
			const char* dataPtr = data.data();

			do
			{
				stream.avail_in = uint32_t(std::min(size_t(CHUNK), data.size() - (dataPtr - data.data())));
				stream.next_in = reinterpret_cast<const uint8_t*>(dataPtr);
				dataPtr += stream.avail_in;

				do
				{
					stream.avail_out = CHUNK;
					stream.next_out = dest;

					ret = inflate(&stream, Z_NO_FLUSH);
					if (ret != Z_OK && ret != Z_STREAM_END)
					{
						inflateEnd(&stream);
						return "";
					}

					buffer.append(reinterpret_cast<const char*>(dest), CHUNK - stream.avail_out);

				} while (stream.avail_out == 0);

			} while (ret != Z_STREAM_END);

			inflateEnd(&stream);
			return buffer;
		}
	}
}

```

`src/generic/Utils/Compression.hpp`:

```hpp
#pragma once

#define CHUNK 16384
#define DEFLATE_ZLIB false
#define DEFLATE_ZSTD true

namespace Utils
{
	namespace Compression
	{
		class ZLib
		{
		public:
			static std::string Compress(std::string data);
			static std::string Decompress(std::string data);
		};
	};
}

```

`src/generic/Utils/Cryptography.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Cryptography
	{
		StaticInitializer _([]()
		{
			// crypt_mp_init("l");
            

			register_prng(&sprng_desc);

			register_hash(&sha1_desc);
			register_hash(&sha256_desc);
			register_hash(&sha512_desc);
			register_hash(&md5_desc);
			register_hash(&tiger_desc);

			register_cipher(&aes_desc);
			register_cipher(&des3_desc);
		});

		std::string GetRandomBytes(size_t size)
		{
			Utils::Memory::Allocator allocator;
			char* data = allocator.allocateArray<char>(size);

			GetRandomBytes(data, size);

			return std::string(data, size);
		}

		void GetRandomBytes(void* data, size_t size)
		{
			static std::random_device rd;
			static std::mt19937_64 gen(rd());
			static std::uniform_int_distribution<unsigned long> dis;

			char* dataPtr = reinterpret_cast<char*>(data);
			while (size > 0)
			{
				unsigned long num = dis(gen);
				size_t len = std::min(size, sizeof(unsigned long));

				std::memmove(dataPtr, &num, len);

				dataPtr += len;
				size -= len;
			}
		}

		AES::AES()
		{
			this->cipher = find_cipher("aes");
		}

		DES3::DES3()
		{
			this->cipher = find_cipher("3des");
		}

		SHA1::SHA1()
		{
			this->hash = find_hash("sha1");
		}

		std::string SHA1::compute(const uint8_t* inData, size_t length)
		{
			std::string result;
			result.resize(sha1_desc.hashsize);

			hash_state state;
			sha1_init(&state);
			sha1_process(&state, inData,static_cast<unsigned long>(length));
			sha1_done(&state, reinterpret_cast<uint8_t*>(const_cast<char*>(result.data())));

			return result;
		}

		SHA256::SHA256()
		{
			this->hash = find_hash("sha256");
		}

		std::string SHA256::compute(const uint8_t* inData, size_t length)
		{
			std::string result;
			result.resize(sha256_desc.hashsize);

			hash_state state;
			sha256_init(&state);
			sha256_process(&state, inData, static_cast<unsigned long>(length));
			sha256_done(&state, reinterpret_cast<uint8_t*>(const_cast<char*>(result.data())));

			return result;
		}

		SHA512::SHA512()
		{
			this->hash = find_hash("sha512");
		}

		std::string SHA512::compute(const uint8_t* inData, size_t length)
		{
			std::string result;
			result.resize(sha512_desc.hashsize);

			hash_state state;
			sha512_init(&state);
			sha512_process(&state, inData, static_cast<unsigned long>(length));
			sha512_done(&state, reinterpret_cast<uint8_t*>(const_cast<char*>(result.data())));

			return result;
		}

		MD5::MD5()
		{
			this->hash = find_hash("md5");
		}

		std::string MD5::compute(const uint8_t* inData, size_t length)
		{
			std::string result;
			result.resize(md5_desc.hashsize);

			hash_state state;
			md5_init(&state);
			md5_process(&state, inData, static_cast<unsigned long>(length));
			md5_done(&state, reinterpret_cast<uint8_t*>(const_cast<char*>(result.data())));

			return result;
		}

		Tiger::Tiger()
		{
			this->hash = find_hash("tiger");
		}

		std::string Tiger::compute(const uint8_t* inData, size_t length)
		{
			std::string result;
			result.resize(tiger_desc.hashsize);

			hash_state state;
			tiger_init(&state);
			tiger_process(&state, inData, static_cast<unsigned long>(length));
			tiger_done(&state, reinterpret_cast<uint8_t*>(const_cast<char*>(result.data())));

			return result;
		}

		ECC::Key ECC::GenerateKey(int /*bits*/)
		{
			ECC::Key key;
			// ecc_make_key(nullptr, find_prng("sprng"), bits / 8, key.getKeyPtr());
			return key;
		}

		std::string ECC::SignMessage(Key key, std::string message)
		{
			if (!key.isValid()) return "";

			uint8_t buffer[512];
			DWORD length = sizeof(buffer);

			ecc_sign_hash(reinterpret_cast<const uint8_t*>(message.data()), ULONG(message.size()), buffer, &length, nullptr, find_prng("sprng"), key.getKeyPtr());

			return std::string(reinterpret_cast<char*>(buffer), length);
		}

		bool ECC::VerifyMessage(Key key, std::string message, std::string signature)
		{
			if (!key.isValid()) return false;

			int result = 0;
			return (ecc_verify_hash(reinterpret_cast<const uint8_t*>(signature.data()), ULONG(signature.size()), reinterpret_cast<const uint8_t*>(message.data()), ULONG(message.size()), &result, key.getKeyPtr()) == CRYPT_OK && result != 0);
		}

		RSA::Key RSA::GenerateKey(int bits)
		{
			RSA::Key key;
			rsa_make_key(nullptr, find_prng("sprng"), bits / 8, 65537, key.getKeyPtr());
			return key;
		}

		std::string RSA::SignMessage(RSA::Key key, std::string message)
		{
			if (!key.isValid()) return "";

			uint8_t buffer[512];
			DWORD length = sizeof(buffer);
			rsa_sign_hash(reinterpret_cast<const uint8_t*>(message.data()), ULONG(message.size()), buffer, &length, NULL, find_prng("sprng"), find_hash("sha1"), 0, key.getKeyPtr());

			return std::string(reinterpret_cast<char*>(buffer), length);
		}

		bool RSA::VerifyMessage(Key key, std::string message, std::string signature)
		{
			if (!key.isValid()) return false;

			int result = 0;
			return (rsa_verify_hash(reinterpret_cast<const uint8_t*>(signature.data()), ULONG(signature.size()), reinterpret_cast<const uint8_t*>(message.data()), ULONG(message.size()), find_hash("sha1"), 0, &result, key.getKeyPtr()) == CRYPT_OK && result != 0);
		}
	}
}

```

`src/generic/Utils/Cryptography.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#define HOOK_JUMP true
#define HOOK_CALL false

namespace Utils
{
	namespace Cryptography
	{
		std::string GetRandomBytes(size_t size);
		void GetRandomBytes(void* data, size_t size);

		template<typename T> T Random()
		{
			T data;
			GetRandomBytes(&data, sizeof(data));
			return data;
		}

		class IEncryption
		{
		public:
			virtual ~IEncryption() {};
			virtual bool encrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) = 0;
			virtual bool decrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) = 0;

			virtual std::string encryptString(std::string data, uint8_t* iv, uint8_t* key)
			{
				if (!iv || !key) return std::string();

				if (!this->encrypt(reinterpret_cast<const uint8_t*>(data.data()), data.size(), iv, key, reinterpret_cast<uint8_t*>(const_cast<char*>(data.data()))))
				{
					data.clear();
				}

				return data;
			}

			virtual bool encryptData(const void* inData, size_t length, const void* iv, const void* key, const void* outData)
			{
				return this->encrypt(reinterpret_cast<const uint8_t*>(inData), length, reinterpret_cast<uint8_t*>(const_cast<void*>(iv)), reinterpret_cast<uint8_t*>(const_cast<void*>(key)), reinterpret_cast<uint8_t*>(const_cast<void*>(outData)));
			}

			virtual std::string decryptString(std::string data, const void* iv, uint8_t* key)
			{
				if (!this->decrypt(reinterpret_cast<const uint8_t*>(data.data()), data.size(),reinterpret_cast<uint8_t*>(const_cast<void*>(iv)), key, reinterpret_cast<uint8_t*>(const_cast<char*>(data.data()))))
				{
					data.clear();
				}

				return data;
			}

			virtual bool decryptData(const void* inData, size_t length, const void* iv, const void* key, const void* outData)
			{
				return this->decrypt(reinterpret_cast<const uint8_t*>(inData), length, reinterpret_cast<uint8_t*>(const_cast<void*>(iv)), reinterpret_cast<uint8_t*>(const_cast<void*>(key)), reinterpret_cast<uint8_t*>(const_cast<void*>(outData)));
			}
		};

		class IHash
		{
		public:
			virtual ~IHash() {};
			virtual std::string compute(const uint8_t* inData, size_t length) = 0;

			virtual std::string computeData(const void* inData, size_t length)
			{
				return this->compute(reinterpret_cast<const uint8_t*>(inData), length);
			}

			virtual std::string computeString(std::string data/*, bool hex = false*/)
			{
				// TODO: Implement hex
				return this->compute(reinterpret_cast<const uint8_t*>(data.data()), data.size());
			}
		};

		class IEmbeddableHash : public IHash
		{
		public:
			virtual int getHash()
			{
				assert(this->hash != -1);
				return this->hash;
			}

		protected:
			int hash;
		};

		template<int keyLength> class CBC : public IEncryption
		{
		public:
			bool encrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) override
			{
				if (!inData || !length || !iv || !key || !outData) return false;
				assert(this->cipher != -1);

				symmetric_CBC cbc;
				cbc_start(this->cipher, iv, key, this->getKeyLength(), 0, &cbc);
				bool result = cbc_encrypt(inData, outData, static_cast<unsigned long>(length), &cbc) == CRYPT_OK;
				cbc_done(&cbc);

				return result;
			}

			bool decrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) override
			{
				if (!inData || !length || !iv || !key || !outData) return false;
				assert(this->cipher != -1);

				symmetric_CBC cbc;
				cbc_start(this->cipher, iv, key, this->getKeyLength(), 0, &cbc);
				bool result = cbc_decrypt(inData, outData, static_cast<unsigned long>(length), &cbc) == CRYPT_OK;
				cbc_done(&cbc);

				return result;
			}

		protected:
			int cipher = -1;

		private:
			int getKeyLength() { return keyLength; }
		};

		class AES : public CBC<16>
		{
		public:
			AES();
		};

		class DES3 : public CBC<24>
		{
		public:
			DES3();
		};

		class SHA1 : public IEmbeddableHash
		{
		public:
			SHA1();
			virtual std::string compute(const uint8_t* inData, size_t length) override;
		};

		class SHA256 : public IEmbeddableHash
		{
		public:
			SHA256();
			virtual std::string compute(const uint8_t* inData, size_t length) override;
		};

		class SHA512 : public IEmbeddableHash
		{
		public:
			SHA512();
			virtual std::string compute(const uint8_t* inData, size_t length) override;
		};

		class MD5 : public IEmbeddableHash
		{
		public:
			MD5();
			virtual std::string compute(const uint8_t* inData, size_t length) override;
		};

		class Tiger : public IEmbeddableHash
		{
		public:
			Tiger();
			virtual std::string compute(const uint8_t* inData, size_t length) override;
		};

		template<typename Hash> class HMac
		{
			static_assert(std::is_base_of<IEmbeddableHash, Hash>::value, "Hash must be embeddable");

		public:
			HMac()
			{
				this->hash.reset(new Hash);
			}

			std::string compute(std::string key, std::string data)
			{
				unsigned long outLen = 20;
				std::basic_string<uint8_t> buffer;
				buffer.resize(24);

				hmac_state state;
				hmac_init(&state, this->hash->getHash(), reinterpret_cast<const uint8_t*>(key.data()), static_cast<unsigned long>(key.size()));
				hmac_process(&state, reinterpret_cast<const uint8_t*>(data.data()), static_cast<unsigned long>(data.size()));
				hmac_done(&state, const_cast<uint8_t*>(buffer.data()), &outLen);

				return std::string(reinterpret_cast<const char*>(buffer.data()), outLen);
			}

		private:
			std::unique_ptr<IEmbeddableHash> hash;
		};

		class ECC
		{
		public:
			class Key
			{
			public:
				Key() : keyStorage(new ecc_key)
				{
					ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
				};
				Key(ecc_key* key) : Key() { if (key) std::memmove(this->getKeyPtr(), key, sizeof(*key)); };
				Key(ecc_key key) : Key(&key) {};
				~Key()
				{
					if (this->keyStorage.use_count() <= 1)
					{
						this->free();
					}
				};

				bool isValid()
				{
					return (!Utils::Memory::IsSet(this->getKeyPtr(), 0, sizeof(*this->getKeyPtr())));
				}

				ecc_key* getKeyPtr()
				{
					return this->keyStorage.get();
				}

				std::string getPublicKey()
				{
					uint8_t buffer[512] = { 0 };
					DWORD length = sizeof(buffer);

					if (ecc_ansi_x963_export(this->getKeyPtr(), buffer, &length) == CRYPT_OK)
					{
						return std::string(reinterpret_cast<char*>(buffer), length);
					}

					return "";
				}

				void set(std::string pubKeyBuffer)
				{
					this->free();

					if (ecc_ansi_x963_import(reinterpret_cast<const uint8_t*>(pubKeyBuffer.data()), ULONG(pubKeyBuffer.size()), this->getKeyPtr()) != CRYPT_OK)
					{
						ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
					}
				}

				void deserialize(std::string key)
				{
					this->free();

					/*if (ecc_import(reinterpret_cast<const uint8_t*>(key.data()), ULONG(key.size()), this->getKeyPtr()) != CRYPT_OK)
					{
						ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
					}*/
				}

				std::string serialize(int type = PK_PRIVATE)
				{
					uint8_t buffer[4096] = { 0 };
					DWORD length = sizeof(buffer);

					if (ecc_export(buffer, &length, type, this->getKeyPtr()) == CRYPT_OK)
					{
						return std::string(reinterpret_cast<char*>(buffer), length);
					}

					return "";
				}

				void free()
				{
					if (this->isValid())
					{
						ecc_free(this->getKeyPtr());
					}

					ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
				}

				bool operator==(Key& key)
				{
					return (this->isValid() && key.isValid() && this->serialize(PK_PUBLIC) == key.serialize(PK_PUBLIC));
				}

			private:
				std::shared_ptr<ecc_key> keyStorage;
			};

			static Key GenerateKey(int bits);
			static std::string SignMessage(Key key, std::string message);
			static bool VerifyMessage(Key key, std::string message, std::string signature);
		};

		class RSA
		{
		public:
			class Key
			{
			public:
				Key() : keyStorage(new rsa_key)
				{
					ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
				};
				Key(rsa_key* key) : Key() { if (key) std::memmove(this->getKeyPtr(), key, sizeof(*key)); };
				Key(rsa_key key) : Key(&key) {};
				~Key()
				{
					if (this->keyStorage.use_count() <= 1)
					{
						this->free();
					}
				};

				rsa_key* getKeyPtr()
				{
					return this->keyStorage.get();
				}

				bool isValid()
				{
					return (!Utils::Memory::IsSet(this->getKeyPtr(), 0, sizeof(*this->getKeyPtr())));
				}

				void free()
				{
					if (this->isValid())
					{
						rsa_free(this->getKeyPtr());
					}

					ZeroMemory(this->getKeyPtr(), sizeof(*this->getKeyPtr()));
				}

			private:
				std::shared_ptr<rsa_key> keyStorage;
			};

			static Key GenerateKey(int bits);
			static std::string SignMessage(Key key, std::string message);
			static bool VerifyMessage(Key key, std::string message, std::string signature);
		};
	}
}

```

`src/generic/Utils/Flags.cpp`:

```cpp
#include "STDInclude.hpp"

#ifdef _WIN32

namespace Utils
{
	namespace Flags
	{
        std::string GetFlagValue(const std::string& flag, const std::string& defaultValue)
        {
            auto strings = Utils::String::split(GetCommandLineA(), ' ');

            for (auto idx = 0u; idx < strings.size(); idx++)
            {
                if (idx != strings.size() - 1 && (strings[idx] == ("+" + flag) || strings[idx] == ("-" + flag)))
                {
                    return strings[idx + 1];
                }

                if (idx != strings.size() - 2 && (strings[idx] == "+set" || strings[idx] == "-set") && strings[idx + 1] == flag)
                {
                    return strings[idx + 2];
                }
            }

            return defaultValue;
        }

		bool Has(std::string flag)
		{
			static std::optional<std::vector<std::string>> flags;

			if (!flags.has_value())
			{
				int numArgs;
				LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &numArgs);

				std::vector<std::string> enabledFlags;

				if (argv)
				{
					for (int i = 0; i < numArgs; ++i)
					{
						std::wstring wFlag(argv[i]);
						if (wFlag[0] == L'-')
						{
							enabledFlags.push_back(std::string(++wFlag.begin(), wFlag.end()));
						}
					}

					LocalFree(argv);
				}

				flags.emplace(enabledFlags);
			}

			return std::find(flags->begin(), flags->end(), flag) != flags->end();
		}
	}
}

#endif

```

`src/generic/Utils/Flags.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#ifdef _WIN32

namespace Utils
{
	namespace Flags
	{
        std::string GetFlagValue(const std::string& flag, const std::string& defaultValue = "");
		bool Has(std::string flag);
	}
}

#endif

```

`src/generic/Utils/Hooking.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Utils/Hooking.hpp"

namespace Utils
{
	std::map<void*, void*> Hook::Interceptor::IReturn;
	std::map<void*, void(*)()> Hook::Interceptor::ICallbacks;

	void Hook::Signature::process()
	{
		if (this->signatures.empty()) return;

		char* _start = reinterpret_cast<char*>(this->start);

		unsigned int sigCount = this->signatures.size();
		Hook::Signature::Container* containers = this->signatures.data();

		for (size_t i = 0; i < this->length; ++i)
		{
			char* address = _start + i;

			for (unsigned int k = 0; k < sigCount; ++k)
			{
				Hook::Signature::Container* container = &containers[k];

				unsigned int j;
				for (j = 0; j < container->mask.size(); ++j)
				{
					if (container->mask[j] != '?' &&container->signature[j] != address[j])
					{
						break;
					}
				}

				if (j == container->mask.size())
				{
					container->callback(reinterpret_cast<unsigned char*>(address));
				}
			}
		}
	}

	void Hook::Signature::add(Hook::Signature::Container container)
	{
		Hook::Signature::signatures.push_back(container);
	}

	bool Hook::IAT::Replace(Utils::NT::Module module, std::string targetModule, std::string process, void* stub)
	{
		if (!module.isValid()) return false;

		void** ptr = module.getIATEntry(targetModule, process);
		if (!ptr) return false;

		DWORD protect;
		VirtualProtect(ptr, sizeof(*ptr), PAGE_EXECUTE_READWRITE, &protect);

		*ptr = stub;

		VirtualProtect(ptr, sizeof(*ptr), protect, &protect);
		return true;
	}

	Hook::Detour::Initializer::Initializer()
	{
		MH_Initialize();
	}

	Hook::Detour::Initializer::~Initializer()
	{
		MH_Uninitialize();
	}

	Hook::Detour::Detour(bool _keep) : target(nullptr), original(nullptr), keep(_keep)
	{
		static Hook::Detour::Initializer _;
	}

	Hook::Detour::~Detour()
	{
		if (!this->keep)
		{
			this->remove();
		}
	}

	void Hook::Detour::create(void* _target, void* function)
	{
		this->remove();

		this->target = _target;
		MH_CreateHook(this->target, function, &this->original);

		this->enable();
	}

	void Hook::Detour::remove()
	{
		if (this->target)
		{
			MH_RemoveHook(this->target);
			this->target = nullptr;
		}
	}

	void Hook::Detour::enable()
	{
		if (this->target)
		{
			MH_EnableHook(this->target);
		}
	}

	void Hook::Detour::disable()
	{
		if (this->target)
		{
			MH_DisableHook(this->target);
		}
	}

	void Hook::Interceptor::Install(void* place, void* stub)
	{
		return Hook::Interceptor::Install(place, static_cast<void(*)()>(stub));
	}

	void Hook::Interceptor::Install(void* place, void(*stub)())
	{
		return Hook::Interceptor::Install(reinterpret_cast<void**>(place), stub);
	}

	void Hook::Interceptor::Install(void** place, void(*stub)())
	{
		Hook::Interceptor::IReturn[place] = *place;
		Hook::Interceptor::ICallbacks[place] = stub;
		*place = Hook::Interceptor::InterceptionStub;
	}

	__declspec(naked) void Hook::Interceptor::InterceptionStub()
	{
		__asm
		{
			sub esp, 4h                             // Reserve space on the stack for the return address
			pushad                                  // Store registers

			lea eax, [esp + 20h]                    // Load initial stack pointer
			push eax                                // Push it onto the stack

			call Hook::Interceptor::RunCallback     // Run the callback based on the given stack pointer
			call Hook::Interceptor::PopReturn       // Get the initial return address according to the stack pointer

			add esp, 4h                             // Clear the stack

			mov [esp + 20h], eax                    // Store the return address at the reserved space
			popad                                   // Restore the registers

			retn                                    // Return (jump to our return address)
		}
	}

	void Hook::Interceptor::RunCallback(void* place)
	{
		auto iCallback = Hook::Interceptor::ICallbacks.find(place);
		if (iCallback != Hook::Interceptor::ICallbacks.end())
		{
			iCallback->second();
			Hook::Interceptor::ICallbacks.erase(iCallback);
		}
	}

	void* Hook::Interceptor::PopReturn(void* _place)
	{
		void* retVal = nullptr;

		auto iReturn = Hook::Interceptor::IReturn.find(_place);
		if (iReturn != Hook::Interceptor::IReturn.end())
		{
			retVal = iReturn->second;
			Hook::Interceptor::IReturn.erase(iReturn);
		}

		return retVal;
	}

	Hook::~Hook()
	{
		if (this->initialized)
		{
			this->uninstall();
		}
	}

	Hook* Hook::initialize(size_t _place, void(*_stub)(...), bool _useJump)
	{
		return this->initialize(_place, reinterpret_cast<void*>(_stub), _useJump);
	}

	Hook* Hook::initialize(size_t _place, void* _stub, bool _useJump)
	{
		return this->initialize(reinterpret_cast<void*>(_place), _stub, _useJump);
	}

	Hook* Hook::initialize(void* _place, void* _stub, bool _useJump)
	{
		if (this->initialized) return this;
		this->initialized = true;

		this->useJump = _useJump;
		this->place = _place;
		this->stub = _stub;

		this->original = static_cast<char*>(this->place) + 5 + *reinterpret_cast<DWORD*>((static_cast<char*>(this->place) + 1));

		return this;
	}

	Hook* Hook::install(bool unprotect, bool keepUnprotected)
	{
		std::lock_guard<std::mutex> _(this->stateMutex);

		if (!this->initialized || this->installed)
		{
			return this;
		}

		this->installed = true;

		if (unprotect) VirtualProtect(this->place, sizeof(this->buffer), PAGE_EXECUTE_READWRITE, &this->protection);
		std::memcpy(this->buffer, this->place, sizeof(this->buffer));

		char* code = static_cast<char*>(this->place);

		*code = static_cast<char>(this->useJump ? 0xE9 : 0xE8);

		*reinterpret_cast<size_t*>(code + 1) = reinterpret_cast<size_t>(this->stub) - (reinterpret_cast<size_t>(this->place) + 5);

		if (unprotect && !keepUnprotected) VirtualProtect(this->place, sizeof(this->buffer), this->protection, &this->protection);

		FlushInstructionCache(GetCurrentProcess(), this->place, sizeof(this->buffer));

		return this;
	}

	void Hook::quick()
	{
		if (Hook::installed)
		{
			Hook::installed = false;
		}
	}

	Hook* Hook::uninstall(bool unprotect)
	{
		std::lock_guard<std::mutex> _(this->stateMutex);

		if (!this->initialized || !this->installed)
		{
			return this;
		}

		this->installed = false;

		if (unprotect) VirtualProtect(this->place, sizeof(this->buffer), PAGE_EXECUTE_READWRITE, &this->protection);

		std::memcpy(this->place, this->buffer, sizeof(this->buffer));

		if (unprotect) VirtualProtect(this->place, sizeof(this->buffer), this->protection, &this->protection);

		FlushInstructionCache(GetCurrentProcess(), this->place, sizeof(this->buffer));

		return this;
	}

	void* Hook::getAddress()
	{
		return this->place;
	}

	void Hook::Nop(void* place, size_t length)
	{
		DWORD oldProtect;
		VirtualProtect(place, length, PAGE_EXECUTE_READWRITE, &oldProtect);

		memset(place, 0x90, length);

		VirtualProtect(place, length, oldProtect, &oldProtect);
		FlushInstructionCache(GetCurrentProcess(), place, length);
	}

	void Hook::Nop(size_t place, size_t length)
	{
		Hook::Nop(reinterpret_cast<void*>(place), length);
	}

	void Hook::SetString(void* place, const char* string, size_t length)
	{
		DWORD oldProtect;
		VirtualProtect(place, length + 1, PAGE_EXECUTE_READWRITE, &oldProtect);

		std::memmove(place, string, length);

		VirtualProtect(place, length + 1, oldProtect, &oldProtect);
	}

	void Hook::SetString(size_t place, const char* string, size_t length)
	{
		Hook::SetString(reinterpret_cast<void*>(place), string, length);
	}

	void Hook::SetString(void* place, const char* string)
	{
		Hook::SetString(place, string, strlen(static_cast<char*>(place)));
	}

	void Hook::SetString(size_t place, const char* string)
	{
		Hook::SetString(reinterpret_cast<void*>(place), string);
	}

	void Hook::RedirectJump(void* place, void* stub)
	{
		char* operandPtr = static_cast<char*>(place) + 2;
		int newOperand = reinterpret_cast<int>(stub) - (reinterpret_cast<int>(place) + 6);
		Utils::Hook::Set<int>(operandPtr, newOperand);
	}

	void Hook::RedirectJump(size_t place, void* stub)
	{
		Hook::RedirectJump(reinterpret_cast<void*>(place), stub);
	}
}

```

`src/generic/Utils/Hooking.hpp`:

```hpp
#pragma once

#include <MinHook.h>

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#define HOOK_JUMP true
#define HOOK_CALL false

namespace Utils
{
	class Hook
	{
	public:
		class Signature
		{
		public:
			class Container
			{
			public:
				const char* signature;
				std::string mask;
				std::function<void(unsigned char*)> callback;
			};

			Signature(void* _start, size_t _length) : start(_start), length(_length) {}
			Signature(size_t _start, size_t _length) : Signature(reinterpret_cast<void*>(_start), _length) {}
			Signature() : Signature(0x400000, 0x800000) {}

			void process();
			void add(Container container);

		private:
			void* start;
			size_t length;
			std::vector<Container> signatures;
		};

		class Interceptor
		{
		public:
			static void Install(void* place, void* stub);
			static void Install(void* place, void(*stub)());
			static void Install(void** place, void(*stub)());

		private:
			static std::map<void*, void*> IReturn;
			static std::map<void*, void(*)()> ICallbacks;

			static void InterceptionStub();
			static void RunCallback(void* place);
			static void* PopReturn(void* place);
		};

		class IAT
		{
		public:
			static bool Replace(Utils::NT::Module module, std::string targetModule, std::string process, void* stub);
		};

		class Detour
		{
		public:
			Detour(bool keep = false);
			~Detour();

            template <typename T> static T* Static_C(const std::uintptr_t& address, const T& dest)
            {
                Detour hook(true);
                hook.create(LPVOID(address), LPVOID(dest));

                return reinterpret_cast<T*>(hook.get<T*>());
            }
			template <typename T> static std::function<T> Static(const std::uintptr_t& address, const T& dest)
			{
				Detour hook(true);
				hook.create(LPVOID(address), LPVOID(dest));

				return std::function<T>(reinterpret_cast<T*>(hook.get<T*>()));
			}

			void create(void* target, void* function);
			void remove();

			void enable();
			void disable();

			template<typename T>
			T get()
			{
				return reinterpret_cast<T>(this->original);
			}

			template<typename T, typename... Args>
			T invoke(Args... args)
			{
				return reinterpret_cast<T(__cdecl*)(Args...)>(this->original)(args...);
			}

			template<typename T, typename... Args>
			T invokePascal(Args... args)
			{
				return reinterpret_cast<T(__stdcall*)(Args...)>(this->original)(args...);
			}

			template<typename T, typename... Args>
			T invokeThis(void* thisPtr, Args... args)
			{
				return reinterpret_cast<T(__thiscall*)(Args...)>(this->original)(thisPtr, args...);
			}

		private:
			bool keep;
			void* target;
			void* original;

			class Initializer
			{
			public:
				Initializer();
				~Initializer();
			};
		};

		Hook() : initialized(false), installed(false), place(nullptr), stub(nullptr), original(nullptr), useJump(false), protection(0) { ZeroMemory(this->buffer, sizeof(this->buffer)); }

		Hook(void* place, void* stub, bool useJump = true) : Hook() { this->initialize(place, stub, useJump); }
		Hook(void* place, void(*stub)(), bool useJump = true) : Hook(place, reinterpret_cast<void*>(stub), useJump) {}

		Hook(size_t place, void* stub, bool useJump = true) : Hook(reinterpret_cast<void*>(place), stub, useJump) {}
		Hook(size_t place, size_t stub, bool useJump = true) : Hook(reinterpret_cast<void*>(place), reinterpret_cast<void*>(stub), useJump) {}
		Hook(size_t place, void(*stub)(), bool useJump = true) : Hook(reinterpret_cast<void*>(place), reinterpret_cast<void*>(stub), useJump) {}

		~Hook();

		Hook* initialize(void* place, void* stub, bool useJump = true);
		Hook* initialize(size_t place, void* stub, bool useJump = true);
		Hook* initialize(size_t place, void(*stub)(...), bool useJump = true); // For lambdas
		Hook* install(bool unprotect = true, bool keepUnprotected = false);
		Hook* uninstall(bool unprotect = true);

		void* getAddress();
		void quick();

		template <typename T> static std::function<T> Call(size_t function)
		{
			return std::function<T>(reinterpret_cast<T*>(function));
		}

		template <typename T> static std::function<T> Call(FARPROC function)
		{
			return Hook::Call<T>(reinterpret_cast<size_t>(function));
		}

		template <typename T> static std::function<T> Call(void* function)
		{
			return Hook::Call<T>(reinterpret_cast<size_t>(function));
		}

		static void SetString(void* place, const char* string, size_t length);
		static void SetString(size_t place, const char* string, size_t length);

		static void SetString(void* place, const char* string);
		static void SetString(size_t place, const char* string);

		static void Nop(void* place, size_t length);
		static void Nop(size_t place, size_t length);

		static void RedirectJump(void* place, void* stub);
		static void RedirectJump(size_t place, void* stub);

		template <typename T> static void Set(void* place, T value)
		{
			DWORD oldProtect;
			VirtualProtect(place, sizeof(T), PAGE_EXECUTE_READWRITE, &oldProtect);

			*static_cast<T*>(place) = value;

			VirtualProtect(place, sizeof(T), oldProtect, &oldProtect);
			FlushInstructionCache(GetCurrentProcess(), place, sizeof(T));
		}

		template <typename T> static void Set(size_t place, T value)
		{
			return Hook::Set<T>(reinterpret_cast<void*>(place), value);
		}

		template <typename T> static void Xor(void* place, T value)
		{
			DWORD oldProtect;
			VirtualProtect(place, sizeof(T), PAGE_EXECUTE_READWRITE, &oldProtect);

			*static_cast<T*>(place) ^= value;

			VirtualProtect(place, sizeof(T), oldProtect, &oldProtect);
			FlushInstructionCache(GetCurrentProcess(), place, sizeof(T));
		}

		template <typename T> static void Xor(size_t place, T value)
		{
			return Hook::Xor<T>(reinterpret_cast<void*>(place), value);
		}

		template <typename T> static void Or(void* place, T value)
		{
			DWORD oldProtect;
			VirtualProtect(place, sizeof(T), PAGE_EXECUTE_READWRITE, &oldProtect);

			*static_cast<T*>(place) |= value;

			VirtualProtect(place, sizeof(T), oldProtect, &oldProtect);
			FlushInstructionCache(GetCurrentProcess(), place, sizeof(T));
		}

		template <typename T> static void Or(size_t place, T value)
		{
			return Hook::Or<T>(reinterpret_cast<void*>(place), value);
		}

		template <typename T> static void And(void* place, T value)
		{
			DWORD oldProtect;
			VirtualProtect(place, sizeof(T), PAGE_EXECUTE_READWRITE, &oldProtect);

			*static_cast<T*>(place) &= value;

			VirtualProtect(place, sizeof(T), oldProtect, &oldProtect);
			FlushInstructionCache(GetCurrentProcess(), place, sizeof(T));
		}

		template <typename T> static void And(size_t place, T value)
		{
			return Hook::And<T>(reinterpret_cast<void*>(place), value);
		}

		template <typename T> static T Get(void* place)
		{
			return *static_cast<T*>(place);
		}

		template <typename T> static T Get(size_t place)
		{
			return Hook::Get<T>(reinterpret_cast<void*>(place));
		}

	private:
		bool initialized;
		bool installed;

		void* place;
		void* stub;
		void* original;
		char buffer[5];
		bool useJump;

		DWORD protection;

		std::mutex stateMutex;
	};
}

```

`src/generic/Utils/IO.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace IO
	{
		File::File(std::string file) : path(file) {}

		Result<uint64_t> File::size()
		{
			Result<uint64_t> result;
			result.result = false;

			std::ifstream stream(this->path);
			if (stream.good())
			{
				result.result = true;
				stream.seekg(0, std::ios::end);
				result.data = stream.tellg();
			}

			return result;
		}

		Result<std::string> File::read()
		{
			Result<std::string> result;
			result.result = false;

			std::ifstream stream(this->path, std::ios::binary);
			if (stream.is_open() && stream.good())
			{
				stream.seekg(0, std::ios::end);
				std::streamsize size = stream.tellg();
				stream.seekg(0, std::ios::beg);

				if (size > -1)
				{
					result.result = true;
					result.data.resize(static_cast<uint32_t>(size));
					stream.read(const_cast<char*>(result.data.data()), size);
					stream.close();
				}
			}

			return result;
		}

		bool File::write(std::string data, bool append)
		{
			this->createDir();

			std::ofstream stream(this->path, std::ios::binary | std::ofstream::out | (append ? std::ofstream::app : std::ofstream::out));
			if (!stream.is_open()) return false;

			stream.write(data.data(), data.size());
			stream.close();
			return true;
		}

		bool File::exists()
		{
			return std::ifstream(this->path).good();
		}

		bool File::remove()
		{
			return ::remove(this->path.data()) == 0;
		}

		bool File::createDir()
		{
			std::string dir = this->path;

			auto pos = dir.find_last_of("/\\");
			if (pos != std::string::npos)
			{
				dir = dir.substr(0, pos);

				return Directory(dir).create();
			}

			return true;
		}

		std::string File::getName(bool withExtension)
		{
			std::string _path = this->path;
			auto pos = _path.find_last_of("/\\");
			if (pos != std::string::npos) _path = _path.substr(pos + 1);

			if (!withExtension)
			{
				pos = _path.find_last_of(".");
				if (pos != std::string::npos) _path = _path.substr(0, pos);
			}

			return _path;
		}

		Directory::Directory(std::string dir) : path(dir) {}

		bool Directory::exists()
		{
			return std::experimental::filesystem::is_directory(this->path);
		}

		bool Directory::create()
		{
			return std::experimental::filesystem::create_directories(this->path);
		}

		bool Directory::empty()
		{
			return std::experimental::filesystem::is_empty(this->path);
		}

		Result<std::vector<std::string>> Directory::files()
		{
			Result<std::vector<std::string>> result;
			result.result = this->exists();

			if (result.result)
			{
				for (auto& file : std::experimental::filesystem::directory_iterator(this->path))
				{
					result.data.push_back(file.path().generic_string());
				}
			}

			return result;
		}
	}
}

```

`src/generic/Utils/IO.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	namespace IO
	{
		template<typename T>
		class Result
		{
		public:
			bool result;
			T data;
		};

		class File
		{
		public:
			File(std::string file);

			Result<uint64_t> size();
			Result<std::string> read();
			bool write(std::string data, bool append = false);
			bool exists();
			bool remove();

			std::string getName(bool withExtension = true);

		private:
			bool createDir();

			std::string path;
		};

		class Directory
		{
		public:
			Directory(std::string dir);

			bool exists();
			bool create();
			bool empty();
			Result<std::vector<std::string>> files();

		private:
			std::string path;
		};
	}
}

```

`src/generic/Utils/Lock.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	Lock::~Lock()
	{
		this->notifyAll();
		std::this_thread::yield();
	}

	void Lock::wait()
	{
		std::unique_lock<std::mutex> lock(this->mutex);
		this->notified = false;

		while (!this->notified)
		{
			this->conditionVar.wait(lock);
		}
	}

	void Lock::waitFor(std::chrono::nanoseconds nsecs)
	{
		std::unique_lock<std::mutex> lock(this->mutex);
		this->notified = false;

		auto start = std::chrono::high_resolution_clock::now();
		while (!this->notified && (start + nsecs) < std::chrono::high_resolution_clock::now())
		{
			this->conditionVar.wait_for(lock, nsecs - (std::chrono::high_resolution_clock::now() - start));
		}
	}

	void Lock::notifyOne()
	{
		std::this_thread::yield();
		std::lock_guard<std::mutex> _(this->mutex);

		this->notified = true;
		this->conditionVar.notify_one();
	}

	void Lock::notifyAll()
	{
		std::this_thread::yield();
		std::lock_guard<std::mutex> _(this->mutex);

		this->notified = true;
		this->conditionVar.notify_all();
	}
}

```

`src/generic/Utils/Lock.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class Lock
	{
	public:
		~Lock();

		void wait();
		void waitFor(std::chrono::nanoseconds nsecs);

		void notifyOne();
		void notifyAll();

	private:
		std::mutex mutex;
		std::atomic<bool> notified;
		std::condition_variable conditionVar;
	};
}

```

`src/generic/Utils/Memory.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	Utils::Memory::Allocator Memory::MemAllocator;

#ifdef _WIN32
	void* Memory::AllocateAlign(size_t length, size_t alignment)
	{
		void* data = _aligned_malloc(length, alignment);
		assert(data != nullptr);
		if (data) ZeroMemory(data, length);
		return data;
	}
#endif

	void* Memory::Allocate(size_t length)
	{
		void* data = calloc(length, 1);
		assert(data != nullptr);
		return data;
	}

	char* Memory::DuplicateString(std::string string)
	{
		char* newString = Memory::AllocateArray<char>(string.size() + 1);
		std::memmove(newString, string.data(), string.size());
		return newString;
	}

	void Memory::Free(void* data)
	{
		if (data)
		{
			free(data);
		}
	}

	void Memory::Free(const void* data)
	{
		Memory::Free(const_cast<void*>(data));
	}

#ifdef _WIN32
	void Memory::FreeAlign(void* data)
	{
		if (data)
		{
			_aligned_free(data);
		}
	}

	void Memory::FreeAlign(const void* data)
	{
		Memory::FreeAlign(const_cast<void*>(data));
	}
#endif

	// Complementary function for memset, which checks if memory is filled with a char
	bool Memory::IsSet(void* mem, char chr, size_t length)
	{
		char* memArr = reinterpret_cast<char*>(mem);

		for (size_t i = 0; i < length; ++i)
		{
			if (memArr[i] != chr)
			{
				return false;
			}
		}

		return true;
	}

#ifdef _WIN32
	bool Memory::IsBadReadPtr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = { nullptr };
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			DWORD mask = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			bool b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	bool Memory::IsBadCodePtr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = { nullptr };
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			DWORD mask = (PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			bool b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}
	
#endif

	Utils::Memory::Allocator* Memory::GetAllocator()
	{
		return &Memory::MemAllocator;
	}
}

```

`src/generic/Utils/Memory.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class Memory
	{
	public:
		class Allocator
		{
		public:
			using FreeCallback = std::function<void(void*)>;

			Allocator()
			{
				this->pool.clear();
				this->refMemory.clear();
			}
			~Allocator()
			{
				this->clear();
			}

			void clear()
			{
				std::lock_guard<std::mutex> _(this->mutex);

				for (auto i = this->refMemory.begin(); i != this->refMemory.end(); ++i)
				{
					if (i->first && i->second)
					{
						i->second(i->first);
					}
				}

				this->refMemory.clear();

				for (auto& data : this->pool)
				{
					Memory::Free(data);
				}

				this->pool.clear();
			}

			void free(void* data)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				auto i = this->refMemory.find(data);
				if (i != this->refMemory.end())
				{
					i->second(i->first);
					this->refMemory.erase(i);
				}

				auto j = std::find(this->pool.begin(), this->pool.end(), data);
				if (j != this->pool.end())
				{
					Memory::Free(data);
					this->pool.erase(j);
				}
			}

			void free(const void* data)
			{
				this->free(const_cast<void*>(data));
			}

			void reference(void* memory, FreeCallback callback)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				this->refMemory[memory] = callback;
			}

			void* allocate(size_t length)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				void* data = Memory::Allocate(length);
				this->pool.push_back(data);
				return data;
			}
			template <typename T> inline T* allocate()
			{
				return this->allocateArray<T>(1);
			}
			template <typename T> inline T* allocateArray(size_t count = 1)
			{
				return static_cast<T*>(this->allocate(count * sizeof(T)));
			}

			bool empty()
			{
				return (this->pool.empty() && this->refMemory.empty());
			}

			char* duplicateString(std::string string)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				char* data = Memory::DuplicateString(string);
				this->pool.push_back(data);
				return data;
			}

			bool isPointerMapped(void* ptr)
			{
				return this->ptrMap.find(ptr) != this->ptrMap.end();
			}

			template <typename T> T* getPointer(void* oldPtr)
			{
				if (this->isPointerMapped(oldPtr))
				{
					return reinterpret_cast<T*>(this->ptrMap[oldPtr]);
				}

				return nullptr;
			}

			void mapPointer(void* oldPtr, void* newPtr)
			{
				this->ptrMap[oldPtr] = newPtr;
			}

		private:
			std::mutex mutex;
			std::vector<void*> pool;
			std::unordered_map<void*, void*> ptrMap;
			std::unordered_map<void*, FreeCallback> refMemory;
		};

#ifdef _WIN32
		static void* AllocateAlign(size_t length, size_t alignment);
#endif

		static void* Allocate(size_t length);
		template <typename T> static inline T* Allocate()
		{
			return AllocateArray<T>(1);
		}
		template <typename T> static inline T* AllocateArray(size_t count = 1)
		{
			return static_cast<T*>(Allocate(count * sizeof(T)));
		}

		static char* DuplicateString(std::string string);

		static void Free(void* data);
		static void Free(const void* data);

#ifdef _WIN32
		static void FreeAlign(void* data);
		static void FreeAlign(const void* data);
#endif

		static bool IsSet(void* mem, char chr, size_t length);

#ifdef _WIN32
		static bool IsBadReadPtr(const void* ptr);
		static bool IsBadCodePtr(const void* ptr);
#endif

		static Utils::Memory::Allocator* GetAllocator();

	private:
		static Utils::Memory::Allocator MemAllocator;
	};
}

```

`src/generic/Utils/NT.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace NT
	{
		Module Module::Load(std::string module)
		{
			return Module(module, true);
		}

		Module Module::GetByAddress(void* address)
		{
			HMODULE module = nullptr;
			GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<LPCSTR>(address), &module);
			return Module(module);
		}

		void Module::AddLoadPath(std::string path)
		{
			char outBuffer[MAX_PATH] = { 0 };
			if (_fullpath(outBuffer, path.data(), sizeof(outBuffer)))
			{
				path = outBuffer;
				AddDllDirectory(std::wstring(path.begin(), path.end()).data());
				SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS | LOAD_LIBRARY_SEARCH_USER_DIRS);
			}
		}

		Module::Module()
		{
			this->module = GetModuleHandleA(nullptr);
		}

		Module::Module(std::string name, bool load)
		{
			if (load) this->module = LoadLibraryA(name.data());
			else this->module = GetModuleHandleA(name.data());
		}

		Module::Module(HMODULE handle)
		{
			this->module = handle;
		}

		bool Module::operator==(const Module &obj) const
		{
			return this->module == obj.module;
		}

		PIMAGE_NT_HEADERS Module::getNTHeaders()
		{
			if (!this->isValid()) return nullptr;
			return reinterpret_cast<PIMAGE_NT_HEADERS>(this->getPtr() + this->getDOSHeader()->e_lfanew);
		}

		PIMAGE_DOS_HEADER Module::getDOSHeader()
		{
			return reinterpret_cast<PIMAGE_DOS_HEADER>(this->getPtr());
		}

		PIMAGE_OPTIONAL_HEADER Module::getOptionalHeader()
		{
			if (!this->isValid()) return nullptr;
			return &this->getNTHeaders()->OptionalHeader;
		}

		std::vector<PIMAGE_SECTION_HEADER> Module::getSectionHeaders()
		{
			std::vector<PIMAGE_SECTION_HEADER> headers;

			auto ntheaders = this->getNTHeaders();
			auto section = IMAGE_FIRST_SECTION(ntheaders);

			for (uint16_t i = 0; i < ntheaders->FileHeader.NumberOfSections; ++i, ++section)
			{
				if (section) headers.push_back(section);
				else OutputDebugStringA("There was an invalid section :O");
			}

			return headers;
		}

		std::uint8_t* Module::getPtr()
		{
			return reinterpret_cast<std::uint8_t*>(this->module);
		}

		void Module::unprotect()
		{
			if (!this->isValid()) return;

			DWORD protection;
			VirtualProtect(this->getPtr(), this->getOptionalHeader()->SizeOfImage, PAGE_EXECUTE_READWRITE, &protection);
		}

		size_t Module::getRelativeEntryPoint()
		{
			if (!this->isValid()) return 0;
			return this->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
		}

		void* Module::getEntryPoint()
		{
			if (!this->isValid()) return nullptr;
			return this->getPtr() + this->getRelativeEntryPoint();
		}

		bool Module::isValid()
		{
			return this->module != nullptr && this->getDOSHeader()->e_magic == IMAGE_DOS_SIGNATURE;
		}

		std::string Module::getName()
		{
			if (!this->isValid()) return "";

			std::string path = this->getPath();
			auto pos = path.find_last_of("/\\");
			if (pos == std::string::npos) return path;

			return path.substr(pos + 1);
		}

		std::string Module::getFolder()
		{
			if (!this->isValid()) return "";

			std::string path = this->getPath();
			auto pos = path.find_last_of("/\\");
			if (pos == std::string::npos) return ".\\";

			return path.substr(0, pos + 1);
		}

		std::string Module::getPath()
		{
			if (!this->isValid()) return "";

			char name[MAX_PATH] = { 0 };
			GetModuleFileNameA(this->module, name, sizeof name);

			return name;
		}

		void Module::free()
		{
			if (this->isValid())
			{
				FreeLibrary(this->module);
				this->module = nullptr;
			}
		}

		HMODULE Module::getHandle()
		{
			return this->module;
		}

		size_t Module::getCodeSize()
		{
			if (this->isValid())
			{
				auto headers = this->getSectionHeaders();
				for (auto& header : headers)
				{
					if (LPSTR(header->Name) == ".text"s)
					{
						return header->SizeOfRawData;
					}
				}
			}

			return 0;
		}

		void* Module::getCodeStart()
		{
			if (this->isValid())
			{
				auto headers = this->getSectionHeaders();
				for (auto& header : headers)
				{
					if (LPSTR(header->Name) == ".text"s)
					{
						return this->getPtr() + header->VirtualAddress;
					}
				}
			}

			return nullptr;
		}

		void** Module::getIATEntry(std::string moduleName, std::string procName)
		{
			if (!this->isValid()) return nullptr;

			Module otherModule(moduleName);
			if (!otherModule.isValid()) return nullptr;

			void* targetFunction = otherModule.getProc<void*>(procName);
			if (!targetFunction) return nullptr;

			auto* header = this->getOptionalHeader();
			if (!header) return nullptr;

			auto* importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(this->getPtr() + header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

			while (importDescriptor->Name)
			{
				if (!_stricmp(reinterpret_cast<char*>(this->getPtr() + importDescriptor->Name), moduleName.data()))
				{
					auto* originalThunkData = reinterpret_cast<PIMAGE_THUNK_DATA>(importDescriptor->OriginalFirstThunk + this->getPtr());
					auto* thunkData = reinterpret_cast<PIMAGE_THUNK_DATA>(importDescriptor->FirstThunk + this->getPtr());

					while(originalThunkData->u1.AddressOfData)
					{
						LPSTR name = nullptr;

						if (IMAGE_SNAP_BY_ORDINAL(originalThunkData->u1.Ordinal))
						{
							name = MAKEINTRESOURCEA(IMAGE_ORDINAL(originalThunkData->u1.Ordinal));
						}
						else
						{
							name = PIMAGE_IMPORT_BY_NAME(this->getPtr() + originalThunkData->u1.ForwarderString)->Name;
						}

						if (GetProcAddress(otherModule.module, name) == targetFunction)
						{
							return reinterpret_cast<void**>(&thunkData->u1.Function);
						}

						++originalThunkData;
						++thunkData;
					}

					break;
				}

				++importDescriptor;
			}

			return nullptr;
		}

#ifdef _DELAY_IMP_VER
		bool Module::delayImport()
		{
			return SUCCEEDED(__HrLoadAllImportsForDll(this->getName().data()));
		}
#endif

		void RaiseHardException()
		{
			int data = false;
			Utils::NT::Module ntdll("ntdll.dll");
			ntdll.invokePascal<NTSTATUS>("RtlAdjustPrivilege", 19, true, false, &data);
			ntdll.invokePascal<NTSTATUS>("NtRaiseHardError", 0xC000007B, 0, nullptr, nullptr, 6, &data);
		}
	}
}

```

`src/generic/Utils/NT.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

typedef PVOID *PPVOID;

namespace Utils
{
	namespace NT
	{
		class Module
		{
		public:
			static Module Load(std::string module);
			static Module GetByAddress(void* address);
			static void AddLoadPath(std::string path);

			Module();
			Module(std::string name, bool load = false);
			Module(HMODULE handle);

			Module(const Module& a) : module(a.module) {}

			bool operator!=(const Module &obj) const { return !(*this == obj); };
			bool operator==(const Module &obj) const;

			void unprotect();
			void* getEntryPoint();
			size_t getRelativeEntryPoint();

			bool isValid();
			std::string getName();
			std::string getPath();
			std::string getFolder();
			std::uint8_t* getPtr();
			void free();

			HMODULE getHandle();

			template <typename T>
			T getProc(std::string process)
			{
				if (!this->isValid()) nullptr;
				return reinterpret_cast<T>(GetProcAddress(this->module, process.data()));
			}

			template <typename T>
			std::function<T> get(std::string process)
			{
				if (!this->isValid()) std::function<T>();
				return reinterpret_cast<T*>(this->getProc<void*>(process));
			}

			template<typename T, typename... Args>
			T invoke(std::string process, Args... args)
			{
				auto method = this->get<T(__cdecl)(Args...)>(process);
				if (method) return method(args...);
				return T();
			}

			template<typename T, typename... Args>
			T invokePascal(std::string process, Args... args)
			{
				auto method = this->get<T(__stdcall)(Args...)>(process);
				if (method) return method(args...);
				return T();
			}

			template<typename T, typename... Args>
			T invokeThis(std::string process, void* thisPtr, Args... args)
			{
				auto method = this->get<T(__thiscall)(void*,Args...)>(thisPtr, process);
				if (method) return method(args...);
				return T();
			}

			std::vector<PIMAGE_SECTION_HEADER> getSectionHeaders();

			PIMAGE_NT_HEADERS getNTHeaders();
			PIMAGE_DOS_HEADER getDOSHeader();
			PIMAGE_OPTIONAL_HEADER getOptionalHeader();

			size_t getCodeSize();
			void* getCodeStart();

			void** getIATEntry(std::string moduleName, std::string procName);

#ifdef _DELAY_IMP_VER
			bool delayImport();
#endif

		private:
			HMODULE module;
		};

		void RaiseHardException();
	}
}

```

`src/generic/Utils/Queue.hpp`:

```hpp
#pragma once

namespace Utils
{
	template<typename T>
	class Queue
	{
	public:
		bool empty()
		{
			//std::lock_guard<std::mutex> _(mutex);
			return this->queue.empty();
		}

		T front()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.front();
		}
		
		void pop()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.pop();
		}

		void push(T obj)
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.push(obj);
		}

		size_t size()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.size();
		}

	private:
		std::mutex mutex;
		std::queue<T> queue;
	};
}

```

`src/generic/Utils/Signal.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	template <typename T> using Slot = std::function<T>;
	template <typename T>
	class Signal
	{
	public:
		Signal()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			this->slots.clear();
		}

		Signal(Signal& obj) : Signal()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);
			std::lock_guard<std::recursive_mutex> __(obj.mutex);

			Utils::Merge(&this->slots, obj.getSlots());
		}

		void connect(Slot<T> slot)
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			if (slot)
			{
				this->slots.push_back(slot);
			}
		}

		void clear()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			this->slots.clear();
		}

		std::vector<Slot<T>>& getSlots()
		{
			return this->slots;
		}

		template <class ...Args>
		void operator()(Args&&... args) const
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			std::vector<Slot<T>> copiedSlots;
			Utils::Merge(&copiedSlots, this->slots);

			for (auto& slot : copiedSlots)
			{
				if (slot)
				{
					slot(std::forward<Args>(args)...);
				}
			}
		}

	private:
		mutable std::recursive_mutex mutex;
		std::vector<Slot<T>> slots;
	};
}
```

`src/generic/Utils/String.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	const char *String::VA(const char *fmt, ...)
	{
		static
#ifndef VA_DONT_USE_THREAD_STORAGE
			thread_local
#endif
			String::VAProvider<8, 256> provider;

		va_list ap;
		va_start(ap, fmt);

		const char* result = provider.get(fmt, ap);

		va_end(ap);
		return result;
	}

	std::string String::DumpHex(std::string data, std::string separator)
	{
		std::string result;

		for (unsigned int i = 0; i < data.size(); ++i)
		{
			if (i > 0)
			{
				result.append(separator);
			}

			result.append(Utils::String::VA("%02X", data[i] & 0xFF));
		}

		return result;
	}

	String String::toLower()
	{
		String out(*this);
		std::transform(out.begin(), out.end(), out.begin(), ::tolower);
		return out;
	}

	String String::toUpper()
	{
		String out(*this);
		std::transform(out.begin(), out.end(), out.begin(), ::toupper);
		return out;
	}

	bool String::endsWith(Utils::String otherString)
	{
		if (otherString.size() > this->size()) return false;
		return std::equal(otherString.begin(), otherString.end(), this->begin() + (this->size() - otherString.size()));
	}

	bool String::startsWith(Utils::String otherString)
	{
        if (this->empty() || otherString.empty()) return false;
		return std::equal(otherString.begin(), otherString.end(), this->begin());
	}

	String String::replaceAll(std::string find, std::string replace)
	{
		size_t pos = 0;
		String string(*this);
		while ((pos = string.find(find, pos)) != std::string::npos)
		{
			string = string.replace(pos, find.size(), replace);
			pos += replace.length();
		}

		return string;
	}

    std::vector < String > String::split(const String& rawInput, const std::vector < char >& delims)
    {
        std::vector < Utils::String > strings;

        auto findFirstDelim = [](const std::string& input, const std::vector < char >& delims) -> std::pair < char, std::size_t>
        {
            auto firstDelim = 0;
            auto firstDelimIndex = static_cast<std::size_t>(-1);
            auto index = 0u;

            for (auto& delim : delims)
            {
                if ((index = input.find(delim)) != std::string::npos)
                {
                    if (firstDelimIndex == -1 || index < firstDelimIndex)
                    {
                        firstDelim = delim;
                        firstDelimIndex = index;
                    }
                }
            }

            return { firstDelim, firstDelimIndex };
        };

        std::string input = rawInput;

        while (!input.empty())
        {
            auto splitDelim = findFirstDelim(input, delims);
            if (splitDelim.first != 0)
            {
                strings.push_back(input.substr(0, splitDelim.second));
                input = input.substr(splitDelim.second + 1);
            }
            else
            {
                break;
            }
        }

        strings.push_back(input);
        return strings;
    }
}

```

`src/generic/Utils/String.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class String : public std::string
	{
	public:
		template <size_t Buffers, size_t MinBufferSize>
		class VAProvider
		{
		public:
			static_assert(Buffers != 0 && MinBufferSize != 0, "Buffers and MinBufferSize mustn't be 0");

			VAProvider() : currentBuffer(0) {}
			~VAProvider() {}

			char* get(const char* format, va_list ap)
			{
				++this->currentBuffer %= ARRAYSIZE(this->stringPool);
				auto entry = &this->stringPool[this->currentBuffer];

				if (!entry->size || !entry->buffer)
				{
					throw std::runtime_error("String pool not initialized");
				}

				while (true)
				{
					#ifdef _WIN32
					int res = vsnprintf_s(entry->buffer, entry->size, _TRUNCATE, format, ap);
					#else
					int res = vsnprintf(entry->buffer, entry->size, format, ap);
					#endif
					
					if (res > 0) break; // Success
					if (res == 0)
					{
						entry->buffer[0] = 0;
						break; // Error
					}

					entry->doubleSize();
				}

				return entry->buffer;
			}

		private:
			class Entry
			{
			public:
				Entry(size_t _size = MinBufferSize) : size(_size), buffer(nullptr)
				{
					if (this->size < MinBufferSize) this->size = MinBufferSize;
					this->allocate();
				}

				~Entry()
				{
					if (this->buffer) Utils::Memory::GetAllocator()->free(this->buffer);
					this->size = 0;
					this->buffer = nullptr;
				}

				void allocate()
				{
					if (this->buffer) Utils::Memory::GetAllocator()->free(this->buffer);
					this->buffer = Utils::Memory::GetAllocator()->allocateArray<char>(this->size + 1);
				}

				void doubleSize()
				{
					this->size *= 2;
					this->allocate();
				}

				size_t size;
				char* buffer;
			};

			size_t currentBuffer;
			Entry stringPool[Buffers];
		};

		static const char *VA(const char *fmt, ...);
		static std::string DumpHex(std::string data, std::string separator);
        static std::vector<String> split(const String& rawInput, const std::vector<char>& delims);
        static std::vector<String> split(const String& rawInput, const char& delim) { return split(rawInput, std::vector<char>{ delim }); }

//----------------------------------------------------------------------------------------

		String() : std::string() {}
		String(std::string data) : std::string(data) {}
		String(const char* data, size_t len) : std::string(data, len) {}
		String(const char* data) : std::string(data) {}

		String toLower();
		String toUpper();

		bool startsWith(Utils::String otherString);
		bool endsWith(Utils::String otherString);
		String replaceAll(std::string find, std::string replace);

        std::vector<String> split(const std::vector<char>& delims) { return String::split(*this, delims); }
        std::vector<String> split(const char& delim) { return String::split(*this, std::vector<char>{ delim }); }
	};
}

```

`src/generic/Utils/Time.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Time
	{
		void Interval::update()
		{
			this->lastPoint = std::chrono::high_resolution_clock::now();
		}

		void Interval::zero()
		{
			this->lastPoint = std::chrono::high_resolution_clock::time_point();
		}

		bool Interval::elapsed(std::chrono::nanoseconds nsecs)
		{
			return ((std::chrono::high_resolution_clock::now() - this->lastPoint) >= nsecs);
		}
	}
}

```

`src/generic/Utils/Time.hpp`:

```hpp
#pragma once

namespace Utils
{
	namespace Time
	{
		class Interval
		{
		protected:
			std::chrono::high_resolution_clock::time_point lastPoint;

		public:
			Interval() : lastPoint(std::chrono::high_resolution_clock::now()) {}

			void update();
			void zero();
			bool elapsed(std::chrono::nanoseconds nsecs);
		};
	}
}

```

`src/generic/Utils/Utils.cpp`:

```cpp
#include "STDInclude.hpp"

namespace std
{
    std::wstring to_wstring(const std::string& string)
    {
        return std::wstring(string.begin(), string.end());
    }
    std::string to_string(const std::wstring& string)
    {
        return std::string(string.begin(), string.end());
    }
}

namespace Utils
{
#ifdef _WINDOWS
	void SetEnvironment()
	{
		wchar_t exeName[512];
		GetModuleFileName(GetModuleHandle(nullptr), exeName, sizeof(exeName) / 2);

		wchar_t* exeBaseName = wcsrchr(exeName, L'\\');
		exeBaseName[0] = L'\0';

		SetCurrentDirectory(exeName);
	}

	std::string LoadResource(int resId)
	{
		std::string result;

		HRSRC res = FindResource(GetModuleHandleA(nullptr), MAKEINTRESOURCE(resId), RT_RCDATA);
		if (!res) return "";

		HGLOBAL handle = LoadResource(nullptr, res);
		if (!handle) return "";

		return std::string(LPSTR(LockResource(handle)), SizeofResource(nullptr, res));
	}
#endif
}

```

`src/generic/Utils/Utils.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace std
{
    std::wstring to_wstring(const std::string& string);
    std::string to_string(const std::wstring& string);
}

namespace Utils
{
	class StaticInitializer
	{
	public:
		StaticInitializer(std::function<void()> init, std::function<void()> _uninit = std::function<void()>())
		{
			if (init) init();
			this->uninit = _uninit;
		}

		~StaticInitializer()
		{
			if (this->uninit) this->uninit();
		}

	private:
		std::function<void()> uninit;
	};

	class Buffer : public std::string
	{
	public:
		Buffer() : std::string() {}
		Buffer(std::string data) : Buffer()
		{
			this->append(data);
		}

		template <typename T> void write(T data)
		{
			this->append(reinterpret_cast<char*>(&data), sizeof (T));
		}

		template <typename T> T read()
		{
			T data;
			if (!this->read(&data)) throw std::runtime_error("Buffer overflow");
			return data;
		}

		template <typename T> bool read(T* data)
		{
			if (this->size() < sizeof(T)) return false;

			std::memmove(data, this->data(), sizeof(T));
			this->erase(this->begin(), this->begin() + sizeof(T));

			return true;
		}
	};

	template <typename T> inline void Merge(std::vector<T>* target, T* source, size_t length)
	{
		if (source)
		{
			target->reserve(target->size() + length);
			for (size_t i = 0; i < length; ++i)
			{
				target->push_back(source[i]);
			}
		}
	}

	template <typename T> inline void Merge(std::vector<T>* target, std::vector<T> source)
	{
		target->reserve(target->size() + source.size());
		for (auto &entry : source)
		{
			target->push_back(entry);
		}
	}

#ifdef _WINDOWS
	void SetEnvironment();
	std::string LoadResource(int resId);
#endif
}

```

`src/linker/Core/Components/Command.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Game.hpp"
#include "Core/Components/Command.hpp"
#include "Core/Components/Console.hpp"

namespace Components
{
	std::map<std::string, Utils::Slot<void(Command::Params)>> Command::Handlers;

	Command::Params::Params() {}

	const char* Command::Params::get(size_t index)
	{
		if (index >= this->size()) return "";

		return Game::Cmd_Argv(index);
	}

	size_t Command::Params::size()
	{
		return Game::Cmd_Argc();
	}

	std::string Command::Params::join(size_t startIndex)
	{
		std::string result;

		for (size_t i = startIndex; i < this->size(); ++i)
		{
			if (i > startIndex) result.append(" ");
			result.append(this->get(i));
		}

		return result;
	}

	void Command::Callback()
	{
		Command::Params params;

		auto handler = Command::Handlers.find(Utils::String(params.get(0)).toLower());
		if (handler != Command::Handlers.end())
		{
			handler->second(params);
		}
	}

	void Command::Execute(std::string command, bool sync)
	{
		if (sync)
		{
			return Game::Cmd_ExecuteSingleCommand(Game::ONLY_LOCAL_CLIENT, Game::CONTROLLER_INDEX_FIRST, command.data(), false);
		}
		else
		{
			return Game::Cbuf_AddText(Game::ONLY_LOCAL_CLIENT, command.data());
		}
	}

	void Command::Add(Utils::String command, Utils::Slot<void(Command::Params)> handler)
	{
		Command::Handlers[command.toLower()] = handler;

		Game::cmd_function_s* newCmd = Utils::Memory::GetAllocator()->allocate<Game::cmd_function_s>();
		newCmd->name = Utils::Memory::GetAllocator()->duplicateString(command);
		newCmd->function = Command::Callback;
		newCmd->next = Game::cmd_functions;
		Game::cmd_functions = newCmd;
	}

	Command::Command()
	{
		// Add the quit command
		Game::cmd_function_s* comQuitVar = reinterpret_cast<Game::cmd_function_s*>(0x1E4B034);
		comQuitVar->name = "quit";
		comQuitVar->function = (void(*)())0x6C5F30;
		comQuitVar->next = Game::cmd_functions;
		Game::cmd_functions = comQuitVar;
	}

	Command::~Command()
	{
		Command::Handlers.clear();
	}
}

```

`src/linker/Core/Components/Command.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Core/Component.hpp"

namespace Components
{
	class Command : public IComponent
	{
	public:
		Command();
		~Command();

		class Params
		{
		public:
			Params();
			~Params() {};
			const char* get(size_t index);
			size_t size();

			std::string join(size_t startIndex);
			const char* operator[](size_t index) { return this->get(index); }
		};

		static void Add(Utils::String command, Utils::Slot<void(Params)> handler);
		static void Execute(std::string command, bool sync = false);

	private:
		static std::map<std::string, Utils::Slot<void(Params)>> Handlers;

		static void Callback();
	};
}

```

`src/linker/Core/Components/Console.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Game.hpp"

#include "Core/Components/Command.hpp"
#include "Core/Components/Console.hpp"

namespace Components
{
	std::recursive_mutex Console::Mutex;

	void Console::Print(const char* message, ...)
	{
		std::lock_guard<std::recursive_mutex> _(Console::Mutex);

		static char buffer[32768];

		va_list va;
		va_start(va, message);
		_vsnprintf_s(buffer, sizeof(buffer), message, va);
		va_end(va);

		Console::LogText(buffer);
	}

	void Console::Info(const char* message, ...)
	{
		std::lock_guard<std::recursive_mutex> _(Console::Mutex);

		static char buffer[32768];

		va_list va;
		va_start(va, message);
		_vsnprintf_s(buffer, sizeof(buffer), message, va);
		va_end(va);

		auto color = Console::GetColor();
		Console::SetColor(11);

		Console::LogText(buffer);

		Console::SetColor(color);
	}

	void Console::Error(const char* message, ...)
	{
		std::lock_guard<std::recursive_mutex> _(Console::Mutex);

		static char buffer[32768];

		va_list va;
		va_start(va, message);
		_vsnprintf_s(buffer, sizeof(buffer), message, va);
		va_end(va);

		auto color = Console::GetColor();
		Console::SetColor(12);

		Console::LogError(buffer);

		Console::SetColor(color);
	}

	void Console::LogText(const char* text)
	{
		std::lock_guard<std::recursive_mutex> _(Console::Mutex);

		fwrite(text, 1, strlen(text), stdout);
		fflush(stdout);
	}

	void Console::LogError(const char* text)
	{
		std::lock_guard<std::recursive_mutex> _(Console::Mutex);

		fwrite(text, 1, strlen(text), stderr);
		fflush(stderr);
	}

	BOOL WINAPI Console::Handler(DWORD /*type*/)
	{
		Command::Execute("quit");
		while (true) std::this_thread::sleep_for(10ms);
		//return TRUE;
	}

	HANDLE Console::GetConsoleHandle()
	{
		return GetStdHandle(STD_OUTPUT_HANDLE);
	}

	WORD Console::GetColor()
	{
		CONSOLE_SCREEN_BUFFER_INFO info;
		if (!GetConsoleScreenBufferInfo(Console::GetConsoleHandle(), &info)) return 0;
		return info.wAttributes;
	}

	void Console::SetColor(WORD color)
	{
		SetConsoleTextAttribute(Console::GetConsoleHandle(), color);
	}

	Console::Console()
	{
		// Block Sys_ShowConsole
		Utils::Hook::Set<BYTE>(0x7A4E00, 0xC3);

		Utils::Hook(0x7A4FE0, Console::LogText, HOOK_JUMP).install()->quick(); // Conbuf_AppendTextInMainThread
		Utils::Hook(0x79F6F0, Console::LogText, HOOK_JUMP).install()->quick(); // Sys_Print
		Utils::Hook(0x79F550, Console::Error, HOOK_JUMP).install()->quick();   // Sys_Error

		SetConsoleCtrlHandler(Console::Handler, TRUE);
	}
}

```

`src/linker/Core/Components/Console.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Core/Component.hpp"

namespace Components
{
	class Console : public IComponent
	{
	public:
		Console();

		static void Info(const char* message, ...);
		static void Print(const char* message, ...);
		static void Error(const char* message, ...);

	private:
		static std::recursive_mutex Mutex;

		static void LogText(const char* text);
		static void LogError(const char* text);

		static BOOL WINAPI Handler(DWORD type);

		static WORD GetColor();
		static void SetColor(WORD color);
		static HANDLE GetConsoleHandle();
	};
}

```

`src/linker/Core/Components/Core.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Zone.hpp"

#include "Core/Components/Core.hpp"
#include "Core/Components/Command.hpp"
#include "Core/Components/Console.hpp"
#include "Core/Components/Scheduler.hpp"

#define ZONE_PATH "zone/pluto"

namespace Components
{
	Game::FastFile Core::BuildZone(std::string zoneName)
	{
		Utils::Memory::Allocator allocator;

		Utils::IO::File zoneSource("zone_source/" + zoneName + ".csv");
		auto data = zoneSource.read();
		if (!data.result)
		{
			Console::Error("No source found for zone '%s'\n", zoneName.data());
			return Game::FastFile();
		}

		Utils::CSV csv(data.data);
		Game::Zone zone;

		for (unsigned int i = 0; i < csv.getRowCount(); ++i)
		{
			auto& row = csv.getRow(i);

			if (row.getColumnCount() >= 2)
			{
				auto assetTypeName = row.getColumn(0);
				auto assetName = row.getColumn(1);
				auto newAssetName = row.getColumnCount() > 2 ? row.getColumn(2) : assetName;

				auto assetType = Game::ASSET_TYPE_INVALID;
				for (int j = 0; j < Game::ASSET_TYPE_FULL_COUNT; ++j)
				{
					if (assetTypeName == Game::g_assetNames[j])
					{
						assetType = Game::XAssetType(j);
						break;
					}
				}

				if (assetType == Game::ASSET_TYPE_INVALID)
				{
					Console::Error("Invalid asset type '%s'\n", assetTypeName.data());
					return Game::FastFile();
				}

				auto assetHeader = Game::DB_FindXAssetHeader(assetType, assetName.data(), true, -1);

				if (newAssetName != assetName)
				{
					Game::XAsset asset;
					asset.type = assetType;
					asset.header = assetHeader;

					auto oldName = Game::DB_GetXAssetName(&asset);
					Game::DB_SetXAssetName(&asset, allocator.duplicateString(newAssetName));

					allocator.reference(assetHeader.data, [assetType, oldName](void* header)
					{
						Game::XAsset asset;
						asset.type = assetType;
						asset.header.data = header;

						Game::DB_SetXAssetName(&asset, oldName);
					});
				}

				zone.addAsset(assetType, assetHeader);
			}
		}

		return zone.build();
	}

	void Core::Initialize()
	{
		if (!Game::Sys_IsDatabaseReady())
		{
			Scheduler::Once(Core::Initialize);
			return;
		}

		Game::Com_AddStartupCommands();

		// Quit the linker after all commands are executed
		Scheduler::OnDelay([]() { Command::Execute("quit"); }, 1s, true);
	}

	Core::Core()
	{
		const char* zonepath = "default";
		Utils::Hook::Set(0x5549DB, zonepath); // DB_TryLoadXFileInternal
		Utils::Hook::Set(0x55446A, zonepath); // DB_BuildOSPath_FromSource

		// Fix startup routine
		Utils::Hook::Nop(0x692FD2, 5); // LiveSteam_Init
		Utils::Hook::Nop(0x6C338B, 5); // Com_ClientPacketEvent
		Utils::Hook::Nop(0x6C68BE, 5); // Com_GametypeSettings_Init
		Utils::Hook::Nop(0x6C68DF, 5); // Live_Init
		Utils::Hook::Nop(0x6C6912, 5); // Content_Init
		Utils::Hook::Nop(0x6C6D6A, 5); // NET_Init
		Utils::Hook::Nop(0x6C6DCE, 5); // SV_InitServerThread
		Utils::Hook::Nop(0x6F5A8B, 5); // LiveSteam_Server_Init
		Utils::Hook::Nop(0x7A119C, 5); // Live_Base_Init
		Utils::Hook::Nop(0x7A1062, 5); // DedicatedInit
		Utils::Hook::Nop(0x6F4B0E, 5); // SV_StatSign_Init
		Utils::Hook::Nop(0x6C4FD1, 5); // LiveSteam_Frame

		// Block DW connection 
		Utils::Hook::Set<BYTE>(0x564990, 0xC3);        // dwNetPump
		Utils::Hook::Set<BYTE>(0x693CA0, 0xC3);        // Live_Base_Pump
		Utils::Hook::Set<BYTE>(0x693BB0, 0xC3);        // Live_Base_PumpForController
		Utils::Hook::Set<DWORD>(0x692B70, 0x90C301B0); // Live_Base_AuthorizeLicenseWithDW

		// Ignore overridden assets
		Utils::Hook::Nop(0x553EBA, 5);

		// Block command registration
		Utils::Hook::Set<BYTE>(0x6B94F0, 0xC3);
		Utils::Hook::Set<BYTE>(0x6B9600, 0xC3);

		Utils::Hook::Set<BYTE>(0x7A0870, 0xC3); // Remove command line check
		Utils::Hook::Set<BYTE>(0x6C4DDF, 0xEB); // No Hitch warnings
		Utils::Hook::Set<BYTE>(0x5587CB, 0xEB); // Ignore redundant assets
		Utils::Hook::Set<BYTE>(0x70A75D, 0xEB); // Ignore missing language files
		Utils::Hook::Set<BYTE>(0x6C6FD6, 0xEB); // Don't execute startup commands here

		// Block asset loading
		Utils::Hook::Nop(0x53C0BF, 5);          // block loading of sounds
		Utils::Hook::Nop(0x8C76A0, 5);          // block loading of sounds
		Utils::Hook::Nop(0x55741C, 5);          // block loading of sounds
		Utils::Hook::Nop(0x53ECC1, 5);          // block loading of vertex shaders to preserve loadDef struct
		Utils::Hook::Nop(0x53ED41, 5);          // block loading of pixel shaders to preserve loadDef struct
		Utils::Hook::Nop(0x53F29E, 5);          // block loading of state bits to preserve loadDef struct
		Utils::Hook::Set<BYTE>(0x55A840, 0xC3); // block loading of FXs to preserve the name
		Utils::Hook::Set<BYTE>(0xA3BC00, 0xC3); // block loading of vertex declarations to preserve loadDef struct
		Utils::Hook::Set<BYTE>(0xA32DDB, 0);    // Set r_loadForRenderer = 0 - Block DX allocations

		Utils::Hook::Set<const char*>(0x75F82B, "data"); // fs_basegame

		// Allocate more memory
		Utils::Hook::Set<DWORD>(0x792BE6, 0x28000000);
		Utils::Hook::Set<DWORD>(0x792C00, 0x28000000);

		Game::ReallocateAssetPool(Game::ASSET_TYPE_FONT, 32);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_XANIMPARTS, 10400);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_WEAPON, 512);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_IMAGE, 10496);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_MATERIAL, 9472);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_FX, 1200);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_WEAPON_CAMO, 256);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_XMODEL, 2800);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_SNDDRIVER_GLOBALS, 5);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_RAWFILE, 2048);
		//Game::ReallocateAssetPool(ASSET_TYPE_DDL, 48);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_STRINGTABLE, 192);
		Game::ReallocateAssetPool(Game::ASSET_TYPE_LEADERBOARD, 256);

		Scheduler::Once(Core::Initialize);

		Command::Add("build", [](Command::Params params)
		{
			if (params.size() < 2) return;

			std::string zoneName = params[1];
			Game::FastFile fastFile = Core::BuildZone(zoneName);
			if (!fastFile.isValid()) return;
			
			Utils::IO::File file(ZONE_PATH "/decrypted/" + zoneName + ".ff");
			file.write(fastFile);

			Console::Info("FastFile '%s' written\n", file.getName().data());
		});

		Command::Add("encrypt", [](Command::Params params)
		{
			if (params.size() < 2) return;

			std::string zoneName = params[1];
			Utils::IO::File fastFile(ZONE_PATH "/decrypted/" + zoneName + ".ff");
			if (!fastFile.exists())
			{
				Console::Error("FastFile '%s' doesn't exist\n", zoneName.data());
				return;
			}

			Game::FastFile ff(fastFile);
			if (!ff.isValid())
			{
				Console::Error("FastFile '%s' is invalid\n", zoneName.data());
				return;
			}

			Utils::IO::File file(ZONE_PATH "/encrypted/" + zoneName + ".ff");
			file.write(ff.encrypt(zoneName));

			Console::Info("FastFile '%s' written\n", file.getName().data());
		});

		Command::Add("decrypt", [](Command::Params params)
		{
			if (params.size() < 2) return;

			std::string zoneName = params[1];
			Utils::IO::File fastFile(ZONE_PATH "/encrypted/" + zoneName + ".ff");
			if (!fastFile.exists())
			{
				Console::Error("FastFile '%s' doesn't exist\n", zoneName.data());
				return;
			}

			Game::FastFile ff(fastFile);
			if (!ff.isValid())
			{
				Console::Error("FastFile '%s' is invalid\n", zoneName.data());
				return;
			}

			Utils::IO::File file(ZONE_PATH "/decrypted/" + zoneName + ".ff");
			file.write(ff.decrypt());

			Console::Info("FastFile '%s' written\n", file.getName().data());
		});

		Command::Add("decompress", [](Command::Params params)
		{
			if (params.size() < 2) return;

			std::string zoneName = params[1];
			Utils::IO::File fastFile(ZONE_PATH "/encrypted/" + zoneName + ".ff");
			if (!fastFile.exists())
			{
				fastFile = Utils::IO::File(ZONE_PATH "/decrypted/" + zoneName + ".ff");
				if (!fastFile.exists())
				{
					Console::Error("FastFile '%s' doesn't exist\n", zoneName.data());
					return;
				}
			}

			Game::FastFile ff(fastFile);
			if (!ff.isValid())
			{
				Console::Error("FastFile '%s' is invalid\n", zoneName.data());
				return;
			}

			Utils::IO::File file(ZONE_PATH "/decompressed/" + zoneName + ".zone");
			file.write(ff.decompress());

			Console::Info("Zone '%s' written\n", file.getName().data());
		});

		Command::Add("compress", [](Command::Params params)
		{
			if (params.size() < 2) return;

			std::string zoneName = params[1];
			auto data = Utils::IO::File(ZONE_PATH "/decompressed/" + zoneName + ".zone").read();
			if (!data.result)
			{
				Console::Error("Zone '%s' doesn't exist\n", zoneName.data());
				return;
			}

			Game::FastFile ff = Game::FastFile::Compress(data.data);
			Utils::IO::File file(ZONE_PATH "/decrypted/" + zoneName + ".zone");
			file.write(ff);

			Console::Info("FastFile '%s' written\n", file.getName().data());
		});
	}
}

```

`src/linker/Core/Components/Core.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Core/Component.hpp"

namespace Components
{
	class Core : public IComponent
	{
	public:
		Core();

	private:
		static void Initialize();

		static Game::FastFile BuildZone(std::string name);
	};
}

```

`src/linker/Core/Components/Linker.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Game.hpp"

#include "Core/Components/Linker.hpp"

namespace Components
{
	std::recursive_mutex Linker::Mutex;

	std::map<void*, void*> Linker::BranchMap;
	std::map<void*, std::pair<DWORD, DWORD>> Linker::AllocationMap;

	std::map<Game::XAssetType, std::pair<size_t, size_t>> Linker::AssetLoaders;
	std::map<Game::XAssetType, std::function<void(Game::XAsset*)>> Linker::AssetMarkers;

	std::map<void*, DWORD> Linker::AssetStorage;

	Utils::Hook Linker::OffsetToPointerHook;

	Game::Zone* Linker::CurrentZone = nullptr;
	Game::Stream* Linker::CurrentStream = nullptr;

	bool Linker::IsWriting()
	{
		return Linker::CurrentStream;
	}

	bool Linker::IsMarking()
	{
		return Linker::CurrentZone;
	}

	void Linker::SetStream(Game::Stream* stream)
	{
		Linker::LinkerLock _;
		Linker::CurrentStream = stream;
	}

	void Linker::SetZone(Game::Zone* zone)
	{
		Linker::LinkerLock _;
		Linker::CurrentZone = zone;
	}

	void Linker::DelayMarkAsset(Game::XAsset* asset)
	{
		Linker::LinkerLock _;
		if (Linker::IsMarking())
		{
			auto handler = Linker::AssetMarkers.find(asset->type);
			if (handler != Linker::AssetMarkers.end())
			{
				handler->second(asset);
			}
		}
	}

	void Linker::SaveAsset(Game::XAsset* asset)
	{
		Linker::LinkerLock _;

		auto handler = Linker::AssetLoaders.find(asset->type);
		if (handler != Linker::AssetLoaders.end())
		{
			*reinterpret_cast<Game::XAssetHeader*>(handler->second.second) = asset->header;
			Utils::Hook::Call<void(bool)>(handler->second.first)(true);
		}
	}

	std::function < bool(bool atStreamStart, void* pointer, size_t size) > Linker::Load_Stream;
	bool Linker::Load_StreamHook(bool atStreamStart, void* pointer, size_t size)
	{
		if (Linker::IsWriting() && Linker::CurrentZone)
		{
			if (!atStreamStart && size == 4 && _ReturnAddress() != PVOID(0x5450A4)) // Is either an offset, or an alias, or a structure that has 4 bytes and not the texture loaddef shit
			{
				int assetIndex = Linker::CurrentZone->getAssetIndex(*reinterpret_cast<void**>(pointer));
				if (assetIndex != -1)
				{
					Game::Stream::Offset offset;
					offset.stream = Game::XFILE_BLOCK_VIRTUAL;
					offset.value = (Linker::CurrentStream->getIndexStart() + (assetIndex * sizeof(Game::XAsset)) + /*offsetof(Game::XAsset, header)*/ 4);

					void* ptr = Linker::CurrentStream->findPointer(pointer);
					*PDWORD(ptr) = offset.getPackedValue();
				}
			}
			else if (atStreamStart)
			{
				Linker::CurrentStream->storePointer(pointer, size);
				Linker::CurrentStream->write(pointer, size);
			}

			return true;
		}
		else
		{
			return Load_Stream(atStreamStart, pointer, size);
		}
	}

	std::function<void(const char **)> Linker::Load_XStringCustom;
	void Linker::Load_XStringCustomHook(const char **str)
	{
		if (Linker::IsWriting())
		{
			Linker::CurrentStream->writeString(*str);
		}
		else
		{
			return Linker::Load_XStringCustom(str);
		}
	}

	std::function<void(unsigned __int16 *)> Linker::Load_ScriptStringCustom;
	void Linker::Load_ScriptStringCustomHook(unsigned __int16 *var)
	{
		if (Linker::IsWriting() && Linker::CurrentZone)
		{
			auto scriptString = Linker::CurrentZone->mapScriptString(*var);
			void* ptr = Linker::CurrentStream->findPointer(var);
			*PWORD(ptr) = scriptString;
		}
		else
		{
			return Linker::Load_ScriptStringCustom(var);
		}
	}

	void Linker::Image_ReleaseHook(Game::GfxImage *image)
	{
		Utils::Memory::GetAllocator()->free(image->texture.loadDef);
	}

	void Linker::Load_TextureHook(Game::GfxImageLoadDef **remoteLoadDef, Game::GfxImage* image)
	{
		if (!Linker::IsWriting())
		{
			auto loadDef = reinterpret_cast<Game::GfxImageLoadDef*>(Utils::Memory::GetAllocator()->allocate(12 + (*remoteLoadDef)->resourceSize));
			std::memcpy(loadDef, *remoteLoadDef, 12 + (*remoteLoadDef)->resourceSize);
			*remoteLoadDef = loadDef;
			image->texture.loadDef = loadDef;
		}
		else
		{
			void* ptr = Linker::CurrentStream->findPointer(remoteLoadDef);
			*PINT(ptr) = -1;
		}
	}

	std::function < void(int) > Linker::DB_PushStreamPos;
	void Linker::DB_PushStreamPosHook(int stream)
	{
		if (Linker::IsWriting())
		{
			Linker::CurrentStream->pushBlock(stream);
		}
		else
		{
			return Linker::DB_PushStreamPos(stream);
		}
	}

	std::function < void() > Linker::DB_PopStreamPos;
	void Linker::DB_PopStreamPosHook()
	{
		if (Linker::IsWriting())
		{
			Linker::CurrentStream->popBlock();
		}
		else
		{
			return Linker::DB_PopStreamPos();
		}
	}

	std::function < char*(int) > Linker::DB_AllocStreamPos;
	char* Linker::DB_AllocStreamPosHook(int alignment)
	{
		if (Linker::IsWriting())
		{
			Linker::CurrentStream->align(alignment);
			return nullptr;
		}
		else
		{
			return Linker::DB_AllocStreamPos(alignment);
		}
	}

	void* Linker::DB_GetXAssetFunc;
	__declspec(naked) void Linker::DB_GetXAsset(Game::XAssetType /*type*/, Game::XAssetHeader /*header*/)
	{
		__asm
		{
			mov edi, [esp + 4h]
			push[esp + 8h]
			call Linker::DB_GetXAssetFunc
			add esp, 4h
			retn
		}
	}

	__declspec(naked) void Linker::DB_GetXAssetStub()
	{
		__asm
		{
			push[esp + 4h]
			push edi
			call Linker::DB_GetXAssetHook
			add esp, 8h
			retn
		}
	}

	void Linker::DB_GetXAssetHook(Game::XAssetType type, Game::XAssetHeader header)
	{
		if (Linker::IsMarking())
		{
			Linker::CurrentZone->markAsset({ type,header });
		}
		else
		{
			return Linker::DB_GetXAsset(type, header);
		}
	}

	std::function<void(unsigned __int16 *var)> Linker::Mark_ScriptStringCustom;
	void Linker::Mark_ScriptStringCustomHook(unsigned __int16 *var)
	{
		if (Linker::IsMarking())
		{
			if (var && *var)
			{
				Linker::CurrentZone->markScriptString(*var);
			}
		}
		else
		{
			return Linker::Mark_ScriptStringCustom(var);
		}
	}

	bool Linker::IsOffsetToPointerBranch(unsigned char* address)
	{
		if (::Utils::Memory::IsBadCodePtr(address)) return false;

		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 32);
		ud_set_pc(&ud, uint64_t(address));
		ud_set_input_buffer(&ud, (unsigned char*)address, INT32_MAX);

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Ipush) return false;

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Icall) return false;

		auto operand = ud_insn_opr(&ud, 0);
		if (operand->type != UD_OP_JIMM || operand->size != 32) return false;

		DWORD offset = operand->lval.udword;

		void* tFunction = PCHAR(ud_insn_off(&ud) + ud_insn_len(&ud) + offset);
		return tFunction == PVOID(0x55AF00); // DB_ConvertOffsetToPointer
	}

	void Linker::MapOffsetToPointerBranches(unsigned char* address)
	{
		if (::Utils::Memory::IsBadCodePtr(address)) return;

		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 32);
		ud_set_pc(&ud, uint64_t(address));
		ud_set_input_buffer(&ud, address, INT32_MAX);

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Icmp) return;

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Ijnz) return;

		auto operand = ud_insn_opr(&ud, 0);
		if (operand->type != UD_OP_JIMM || operand->size != 8) return;

		DWORD offset = operand->lval.ubyte;
		unsigned char* writeBranch = PUCHAR(ud_insn_off(&ud) + ud_insn_len(&ud));
		unsigned char* offsetBranch = writeBranch + offset;

		if (!Linker::IsOffsetToPointerBranch(offsetBranch)) return;

		Linker::BranchMap[offsetBranch] = writeBranch;
	}

	void* Linker::GetComplementaryBranch(char* branch)
	{
		auto branches = Linker::BranchMap.find(branch - 6);
		if (branches != Linker::BranchMap.end())
		{
			return branches->second;
		}

		MessageBoxA(0, "Unable to locate complementary branch", "ERROR", MB_ICONERROR);
		return branch + 3;
	}

	bool Linker::CheckOffsetToPointerConversion(void** pointer)
	{
		void* ptr = Linker::CurrentStream->findPointer(pointer);
		if (Linker::CurrentStream->hasPointer(*pointer))
		{
			*PINT(ptr) = Linker::CurrentStream->safeGetPointer(*pointer);
			return true;
		}
		else
		{
			*PINT(ptr) = -1;
			return false;
		}
	}

	__declspec(naked) void Linker::OffsetToPointerStub()
	{
		__asm
		{
			pushad
			push [esp + 24h]
			call Linker::CheckOffsetToPointerConversion
			add esp, 4h

			test al, al
			jz returnComplementaryBranch

			popad
			retn

		returnComplementaryBranch:
			push [esp + 20h]
			call Linker::GetComplementaryBranch
			add esp, 4h

			mov [esp + 24h], eax
			popad
			add esp, 4h
			retn
		}
	}

	void Linker::MapStreamAllocation(unsigned char* address)
	{
		unsigned char* callOperation = address; //address + 2 + (*address == 0x68 ? 3 : 0);
		unsigned long functionOffset = *PDWORD(callOperation + 1);
		unsigned char* function = callOperation + functionOffset + 5;
		unsigned char* target = callOperation + 11;

		if (function != PUCHAR(0x55ABD0)) return;

		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 32);
		ud_set_pc(&ud, uint64_t(target));
		ud_set_input_buffer(&ud, target, INT32_MAX);
		ud_disassemble(&ud);

		Linker::AllocationMap[target] = { *PDWORD(target), ud_insn_len(&ud) };
	}

	void Linker::EnablePatches()
	{
		Linker::LinkerLock _;

		for (auto& entry : Linker::AllocationMap)
		{
			Utils::Hook::Nop(entry.first, entry.second.second);
		}

		for (auto& entry : Linker::AssetStorage)
		{
			Utils::Hook::Nop(entry.first, 5);
		}

		// Block DB_ConvertOffsetToAlias
		Utils::Hook::Set<BYTE>(0x55AEA0, 0xC3);

		// Block Assert_MyHandler
		Utils::Hook::Set<DWORD>(0x745150, 0xC301B0);

		// Block loading texture loaddefs as aliases
		Utils::Hook::Set<BYTE>(0x5450CD, 0xEB);
		Utils::Hook::Set<BYTE>(0x545101, 0xEB);

		Linker::OffsetToPointerHook.install();
	}

	void Linker::DisablePatches()
	{
		Linker::LinkerLock _;

		Linker::OffsetToPointerHook.uninstall();

		// Restore DB_ConvertOffsetToAlias
		Utils::Hook::Set<BYTE>(0x55AEA0, 0x55);

		// Restore Assert_MyHandler
		Utils::Hook::Set<DWORD>(0x745150, 0x51EC8B55);

		// Restore loading texture loaddefs as aliases
		Utils::Hook::Set<BYTE>(0x5450CD, 0x74);
		Utils::Hook::Set<BYTE>(0x545101, 0x75);

		for (auto& entry : Linker::AssetStorage)
		{
			Utils::Hook::Set<DWORD>(entry.first, 0xEB);
			Utils::Hook::Set<DWORD>(PCHAR(entry.first) + 1, entry.second);
		}

		for (auto& entry : Linker::AllocationMap)
		{
			Utils::Hook::Set<DWORD>(entry.first, entry.second.first);
		}
	}

	void Linker::BuildAssetLoader(int type, unsigned char* branch)
	{
		unsigned char* operation = branch + 11;
		if (*operation != 0xE9)
		{
			operation += 2;
			if (*operation != 0xE9) return;
		}

		unsigned char* loader = operation + 5 + *PDWORD(operation + 1);

		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 32);
		ud_set_pc(&ud, uint64_t(loader));
		ud_set_input_buffer(&ud, loader, INT32_MAX);

		// This might be potentially dangerous as we skip jumps and rely on
		// continuous operations in memory neglecting alignments and such.
		uint64_t target = 0;
		while (true)
		{
			ud_disassemble(&ud);
			if (ud_insn_mnemonic(&ud) != UD_Ijmp) continue;

			auto operand = ud_insn_opr(&ud, 0);
			if (operand->type != UD_OP_JIMM || operand->size != 8) continue;

			target = ud_insn_off(&ud) + ud_insn_len(&ud) + operand->lval.sbyte;
			break;
		}

		ud_set_pc(&ud, target);
		ud_set_input_buffer(&ud, PUCHAR(target), INT32_MAX);

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Ipush) return;

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Icall) return;

		auto operand = ud_insn_opr(&ud, 0);
		if (operand->type != UD_OP_JIMM || operand->size != 32) return;

		target = ud_insn_off(&ud) + ud_insn_len(&ud) + operand->lval.sdword;
		DWORD var = *PDWORD(target + 4);

		Linker::AssetLoaders[Game::XAssetType(type)] = { target, var };

		// Just patch the asset storage functions if we're already there
		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Imov) return;

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Ipush) return;

		ud_disassemble(&ud);
		if (ud_insn_mnemonic(&ud) != UD_Icall) return;

		auto pointer = PCHAR(ud_insn_off(&ud));
		Linker::AssetStorage[pointer] = *PDWORD(pointer + 1);
	}

	void Linker::BuildAssetLoaders()
	{
		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 32);
		ud_set_pc(&ud, uint64_t(Game::Load_XAssetHeader));
		ud_set_input_buffer(&ud, PUCHAR(Game::Load_XAssetHeader), INT32_MAX);

		while (true)
		{
			ud_disassemble(&ud);
			if (ud_insn_mnemonic(&ud) == UD_Iret || ud_insn_mnemonic(&ud) == UD_Ijmp) break;
			if (ud_insn_mnemonic(&ud) != UD_Icmp) continue;

			auto operand = ud_insn_opr(&ud, 1);
			if (operand->type != UD_OP_IMM || operand->size != 8) continue;

			int assetType = operand->lval.ubyte;

			ud_disassemble(&ud);
			if (ud_insn_mnemonic(&ud) == UD_Iret || ud_insn_mnemonic(&ud) == UD_Ijmp) break;

			if (assetType == Game::ASSET_TYPE_CLIPMAP || assetType == Game::ASSET_TYPE_CLIPMAP_PVS)
			{
				if (ud_insn_mnemonic(&ud) != UD_Ijz) continue;

				operand = ud_insn_opr(&ud, 0);
				if (operand->type != UD_OP_JIMM || operand->size != 32) continue;

				Linker::BuildAssetLoader(assetType, PUCHAR(ud_insn_off(&ud) + ud_insn_len(&ud) + operand->lval.sdword));
				continue;
			}

			if (ud_insn_mnemonic(&ud) != UD_Ijnz) continue;

			operand = ud_insn_opr(&ud, 0);
			if (operand->type != UD_OP_JIMM || operand->size != 8) continue;

			uint64_t loadBranch = ud_insn_off(&ud) + ud_insn_len(&ud);
			uint64_t continueBranch = loadBranch + operand->lval.sbyte;

			Linker::BuildAssetLoader(assetType, PUCHAR(loadBranch));

			ud_set_pc(&ud, continueBranch);
			ud_set_input_buffer(&ud, PUCHAR(continueBranch), INT32_MAX);
		}
	}

	Linker::Linker()
	{
		Linker::BranchMap.clear();
		Linker::AllocationMap.clear();

		Utils::NT::Module proc;
		Utils::Hook::Signature signature(proc.getCodeStart(), proc.getCodeSize());
		signature.add({ "\x83?\xFF\x75", "x?xx", Linker::MapOffsetToPointerBranches }); // Matches cmp eax, -1; jnz ...
		//signature.add({ "\x6A?\xE8", "x?x", Linker::MapStreamAllocation }); // Matches push ...; call ...
		//signature.add({ "\x68????\xE8", "x????x", Linker::MapStreamAllocation }); // Matches push ...; call ...
		signature.add({ "\xE8", "x", Linker::MapStreamAllocation });
		signature.process();

		// Various hooks required to write data properly
		Utils::Hook::Detour xAssetHook(true);
		xAssetHook.create(LPVOID(0x554330), Linker::DB_GetXAssetStub);
		Linker::DB_GetXAssetFunc = xAssetHook.get<void*>();

		Linker::Mark_ScriptStringCustom = Utils::Hook::Detour::Static(0x55AFB0, Linker::Mark_ScriptStringCustomHook);

		Linker::Load_Stream = Utils::Hook::Detour::Static(0x55AD00, Linker::Load_StreamHook);
		Linker::Load_XStringCustom = Utils::Hook::Detour::Static(0x55AF30, Linker::Load_XStringCustomHook);
		Linker::Load_ScriptStringCustom = Utils::Hook::Detour::Static(0x55AF90, Linker::Load_ScriptStringCustomHook);
		Linker::DB_PushStreamPos = Utils::Hook::Detour::Static(0x55AA50, Linker::DB_PushStreamPosHook);
		Linker::DB_PopStreamPos = Utils::Hook::Detour::Static(0x55AB30, Linker::DB_PopStreamPosHook);
		Linker::DB_AllocStreamPos = Utils::Hook::Detour::Static(0x55ABD0, Linker::DB_AllocStreamPosHook);

		Utils::Hook(0xA730A0, Linker::Image_ReleaseHook, HOOK_JUMP).install()->quick();
		Utils::Hook(0x545122, Linker::Load_TextureHook, HOOK_CALL).install()->quick();

		Linker::OffsetToPointerHook.initialize(0x55AF00, Linker::OffsetToPointerStub);

		Linker::BuildAssetLoaders();

		Linker::AssetMarkers[Game::ASSET_TYPE_ATTACHMENT_UNIQUE] = [](Game::XAsset* asset)
		{
			if (asset->header.attachmentUnique->szAltWeaponName && asset->header.attachmentUnique->szAltWeaponName[0])
			{
				Game::XAsset newAsset;
				newAsset.type = Game::ASSET_TYPE_WEAPON;
				newAsset.header = Game::DB_FindXAssetHeader(newAsset.type, asset->header.attachmentUnique->szAltWeaponName, true, -1);
				Linker::CurrentZone->delayMarkAsset(newAsset);
			}
		};

		Linker::AssetMarkers[Game::ASSET_TYPE_FX] = [](Game::XAsset* asset)
		{
			auto fx = asset->header.fx;
			if (fx->elemDefs)
			{
				for (int i = 0; i < fx->elemDefCountLooping + fx->elemDefCountOneShot + fx->elemDefCountEmission; ++i)
				{
					auto elemDef = &fx->elemDefs[i];

					static auto markFxRef = [] (Game::FxEffectDefRef ref)
					{
						if (!ref.name || !ref.name[0]) return;

						Game::XAsset newAsset;
						newAsset.type = Game::ASSET_TYPE_FX;
						newAsset.header = Game::DB_FindXAssetHeader(newAsset.type, ref.name, true, -1);
						Linker::CurrentZone->delayMarkAsset(newAsset);
					};

					static auto markFxVisuals = [](Game::FxElemVisuals* visuals, int type)
					{
						if (type == 12)
						{
							markFxRef(visuals->effectDef);
						}
						else if (type == 10)
						{
// 							Game::XAsset newAsset;
// 							newAsset.type = Game::ASSET_TYPE_SOUND;
// 							newAsset.header = Game::DB_FindXAssetHeader(newAsset.type, visuals->soundName, true, -1);
// 							Linker::CurrentZone->delayMarkAsset(newAsset);
						}
					};

					markFxRef(elemDef->effectOnImpact);
					markFxRef(elemDef->effectOnDeath);
					markFxRef(elemDef->effectEmitted);
					markFxRef(elemDef->effectAttached);

					if (elemDef->elemType != 11)
					{
						if (elemDef->visualCount > 1)
						{
							for (char j = 0; j < elemDef->visualCount; ++j)
							{
								markFxVisuals(&elemDef->visuals.array[j], elemDef->elemType);
							}
						}
						else
						{
							markFxVisuals(&elemDef->visuals.instance, elemDef->elemType);
						}
					}
				}
			}
		};

		Linker::AssetMarkers[Game::ASSET_TYPE_WEAPON] = [](Game::XAsset* asset)
		{
			if (asset->header.weapon->szXAnims)
			{
				for (int i = 0; i < 88; ++i)
				{
					auto anim = asset->header.weapon->szXAnims[i];
					if (anim && *anim)
					{
						Game::XAsset newAsset;
						newAsset.type = Game::ASSET_TYPE_XANIMPARTS;
						newAsset.header = Game::DB_FindXAssetHeader(newAsset.type, anim, true, -1);
						Linker::CurrentZone->delayMarkAsset(newAsset);
					}
				}
			}

			//asset->header.weapon->weapDef->parentWeaponName = "\0";
		};
	}
}

```

`src/linker/Core/Components/Linker.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/Zone.hpp"

#include "Core/Component.hpp"

namespace Components
{
	class Linker : public IComponent
	{
	public:
		class LinkerLock
		{
		public:
			LinkerLock() : lock(Linker::Mutex) {}

		private:
			std::lock_guard<std::recursive_mutex> lock;
		};

		Linker();

		static void EnablePatches();
		static void DisablePatches();

		static void SetStream(Game::Stream* stream);
		static void SetZone(Game::Zone* zone);

		static void SaveAsset(Game::XAsset* asset);
		static void DelayMarkAsset(Game::XAsset* asset);

	private:
		static std::recursive_mutex Mutex;

		static std::map<void*, void*> BranchMap;
		static std::map<void*, std::pair<DWORD, DWORD>>  AllocationMap;

		static std::map<Game::XAssetType, std::function<void(Game::XAsset*)>> AssetMarkers;

		static std::map<Game::XAssetType, std::pair<size_t, size_t>> AssetLoaders;
		static std::map<void*, DWORD> AssetStorage;

		static Utils::Hook OffsetToPointerHook;

		static Game::Stream* CurrentStream;
		static Game::Zone* CurrentZone;

		static bool IsWriting();
		static bool IsMarking();

		static std::function<bool(bool, void*, size_t)> Load_Stream;
		static bool Load_StreamHook(bool atStreamStart, void * pointer, size_t size);

		static std::function<void(const char **)> Load_XStringCustom;
		static void Load_XStringCustomHook(const char **str);

		static std::function<void(unsigned __int16 *)> Load_ScriptStringCustom;
		static void Load_ScriptStringCustomHook(unsigned __int16 *var);

		static void Image_ReleaseHook(Game::GfxImage *image);
		static void Load_TextureHook(Game::GfxImageLoadDef **remoteLoadDef, Game::GfxImage *image);

		static std::function<void(int)> DB_PushStreamPos;
		static void DB_PushStreamPosHook(int stream);

		static std::function<void()> DB_PopStreamPos;
		static void DB_PopStreamPosHook();

		static std::function<char*(int)> DB_AllocStreamPos;
		static char * DB_AllocStreamPosHook(int alignment);

		static void* DB_GetXAssetFunc;
		static void DB_GetXAsset(Game::XAssetType type, Game::XAssetHeader header);
		static void DB_GetXAssetHook(Game::XAssetType type, Game::XAssetHeader header);
		static void DB_GetXAssetStub();

		static std::function<void(unsigned __int16 *var)> Mark_ScriptStringCustom;
		static void Mark_ScriptStringCustomHook(unsigned __int16 *var);

		static void MapOffsetToPointerBranches(unsigned char* address);
		static bool IsOffsetToPointerBranch(unsigned char* address);

		static void MapStreamAllocation(unsigned char* address);

		static void* GetComplementaryBranch(char* branch);
		static bool CheckOffsetToPointerConversion(void** pointer);
		static void OffsetToPointerStub();

		static void BuildAssetLoader(int type, unsigned char* branch);
		static void BuildAssetLoaders();
	};
}

```

`src/linker/Core/Components/Scheduler.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Game.hpp"
#include "Core/Components/Scheduler.hpp"

namespace Components
{
	std::mutex Scheduler::Mutex;
	Utils::Signal<void()> Scheduler::OnceSignal;
	Utils::Signal<void()> Scheduler::FrameSignal;
	std::vector<Scheduler::DelayedSlot> Scheduler::DelayedSlots;

	void Scheduler::Once(Utils::Slot<void()> slot)
	{
		Scheduler::OnceSignal.connect(slot);
	}

	void Scheduler::OnFrame(Utils::Slot<void()> slot)
	{
		Scheduler::FrameSignal.connect(slot);
	}

	void Scheduler::OnDelay(Utils::Slot<void()> callback, std::chrono::nanoseconds delay, bool deleteOnExecute /*= false*/)
	{
		std::lock_guard<std::mutex> _(Scheduler::Mutex);

		Scheduler::DelayedSlot slot;
		slot.callback = callback;
		slot.delay = delay;
		slot.deleteSlot = deleteOnExecute;

		Scheduler::DelayedSlots.push_back(slot);
	}

	void Scheduler::Frame()
	{
		Scheduler::DelaySignal();
		Scheduler::FrameSignal();

		Utils::Signal<void()> copy(Scheduler::OnceSignal);
		Scheduler::OnceSignal.clear();
		copy();
	}

	void Scheduler::DelaySignal()
	{
		Utils::Signal<void()> signal;
		{
			std::lock_guard<std::mutex> _(Scheduler::Mutex);
			for (auto i = Scheduler::DelayedSlots.begin(); i != Scheduler::DelayedSlots.end();)
			{
				if (i->interval.elapsed(i->delay))
				{
					signal.connect(i->callback);
					i->interval.update();

					if (i->deleteSlot) i = Scheduler::DelayedSlots.erase(i);
					else ++i;

					continue;
				}

				++i;
			}
		}

		signal();
	}

	Scheduler::Scheduler()
	{
		Utils::Hook(0x693E10, Scheduler::Frame, HOOK_CALL).install()->quick();
	}

	Scheduler::~Scheduler()
	{
		Scheduler::OnceSignal.clear();
		Scheduler::FrameSignal.clear();
	}
}

```

`src/linker/Core/Components/Scheduler.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Core/Component.hpp"

namespace Components
{
	class Scheduler : public IComponent
	{
	public:
		Scheduler();
		~Scheduler();

		static void Once(Utils::Slot<void()> slot);
		static void OnFrame(Utils::Slot<void()> slot);
		static void OnDelay(Utils::Slot<void()> callback, std::chrono::nanoseconds delay, bool deleteOnExecute = false);

	private:
		class DelayedSlot
		{
		public:
			std::chrono::nanoseconds delay;
			Utils::Time::Interval interval;
			Utils::Slot<void()> callback;
			bool deleteSlot;
		};

		static std::mutex Mutex;
		static Utils::Signal<void()> OnceSignal;
		static Utils::Signal<void()> FrameSignal;
		static std::vector<DelayedSlot> DelayedSlots;

		static void DelaySignal();

		static void Frame();
	};
}

```

`src/linker/Core/Loader.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Core/Loader.hpp"

namespace Loader
{
	bool PreDestroyed = false;
	bool Uninitializing = false;
	std::vector<std::unique_ptr<Components::IComponent>> LoadedComponents;

	void Initialize()
	{
		Loader::PreDestroyed = false;
		Utils::Memory::GetAllocator()->clear();

		using namespace Components;

		Loader::Register<Core>();
		Loader::Register<Linker>();
		Loader::Register<Command>();
		Loader::Register<Console>();
		Loader::Register<Scheduler>();
	}

	void Uninitialize()
	{
		Loader::Uninitializing = true;
		Loader::PreDestroy();

		std::reverse(Loader::LoadedComponents.begin(), Loader::LoadedComponents.end());
		Loader::LoadedComponents.clear();

		Utils::Memory::GetAllocator()->clear();
	}

	bool IsUninitializing()
	{
		return Loader::Uninitializing;
	}

	void PreDestroy()
	{
		if (!Loader::PreDestroyed)
		{
			Loader::PreDestroyed = true;

			for (auto& component : Loader::LoadedComponents)
			{
				component->preDestroy();
			}
		}
	}
}

```

`src/linker/Core/Loader.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/Zone.hpp"

#include "Core/Component.hpp"

#include "Core/Components/Core.hpp"
#include "Core/Components/Linker.hpp"
#include "Core/Components/Command.hpp"
#include "Core/Components/Console.hpp"
#include "Core/Components/Scheduler.hpp"

namespace Loader
{
	extern std::vector<std::unique_ptr<Components::IComponent>> LoadedComponents;

	void Initialize();
	void Uninitialize();

	bool IsUninitializing();

	void PreDestroy();

	template <typename T> void Register()
	{
		static_assert(std::is_base_of<Components::IComponent, T>::value, "Component must inherit from Components::IComponent");

		auto component = std::make_unique<T>();

#ifdef DEBUG
		//Components::Console::Log("Registering component %s\n", component->getName().data());
#endif

		Loader::LoadedComponents.push_back(std::move(component));
	}

	template <typename T>
	T* GetInstance()
	{
		for (auto& component : Loader::LoadedComponents)
		{
			if (typeid(*(component.get())) == typeid(T))
			{
				return reinterpret_cast<T*>(component.get());
			}
		}

		return nullptr;
	}
}

```

`src/linker/Core/Syringe.cpp`:

```cpp
#include "STDInclude.hpp"

#include <winnt.h>
#include "Core/Syringe.hpp"

namespace Core
{
	Syringe::Syringe(const std::string& _data) : data(_data) {}

	void Syringe::loadSection(Utils::NT::Module target, Utils::NT::Module source, IMAGE_SECTION_HEADER* section)
	{
		void* targetPtr = target.getPtr() + section->VirtualAddress;
		const void* sourcePtr = source.getPtr() + section->PointerToRawData;

		if (PBYTE(targetPtr) >= (target.getPtr() + BINARY_PAYLOAD_SIZE))
		{
			MessageBoxA(nullptr, "Section exceeds the binary payload size, please increase it!", nullptr, MB_ICONERROR);
			TerminateProcess(GetCurrentProcess(), 1);
		}

		if (section->SizeOfRawData > 0)
		{
			DWORD sizeOfData = std::min(section->SizeOfRawData, section->Misc.VirtualSize);
			std::memmove(targetPtr, sourcePtr, sizeOfData);

			DWORD oldProtect;
			VirtualProtect(targetPtr, sizeOfData, PAGE_EXECUTE_READWRITE, &oldProtect);
		}
	}

	void Syringe::loadSections(Utils::NT::Module target, Utils::NT::Module source)
	{
		for (auto& section : source.getSectionHeaders())
		{
			this->loadSection(target, source, section);
		}
	}

	void Syringe::loadImports(Utils::NT::Module target, Utils::NT::Module source)
	{
		IMAGE_DATA_DIRECTORY* importDirectory = &source.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

		auto descriptor = PIMAGE_IMPORT_DESCRIPTOR(target.getPtr() + importDirectory->VirtualAddress);

		while (descriptor->Name)
		{
			std::string name = LPSTR(target.getPtr() + descriptor->Name);

			auto nameTableEntry = reinterpret_cast<uintptr_t*>(target.getPtr() + descriptor->OriginalFirstThunk);
			auto addressTableEntry = reinterpret_cast<uintptr_t*>(target.getPtr() + descriptor->FirstThunk);

			// GameShield (Payne) uses FirstThunk for original name addresses
			if (!descriptor->OriginalFirstThunk)
			{
				nameTableEntry = reinterpret_cast<uintptr_t*>(target.getPtr() + descriptor->FirstThunk);
			}

			while (*nameTableEntry)
			{
				FARPROC function = nullptr;
				std::string functionName;

				// is this an ordinal-only import?
				if (IMAGE_SNAP_BY_ORDINAL(*nameTableEntry))
				{
					Utils::NT::Module module = Utils::NT::Module::Load(name);
					if (module.isValid())
					{
						function = GetProcAddress(Utils::NT::Module::Load(name).getHandle(), MAKEINTRESOURCEA(IMAGE_ORDINAL(*nameTableEntry)));
					}

					functionName = Utils::String::VA("#%d", IMAGE_ORDINAL(*nameTableEntry));
				}
				else
				{
					auto import = PIMAGE_IMPORT_BY_NAME(target.getPtr() + *nameTableEntry);
					functionName = import->Name;

					if (this->importResolver) function = this->importResolver(name, functionName);
					if (!function)
					{
						Utils::NT::Module module = Utils::NT::Module::Load(name);
						if (module.isValid())
						{
							function = GetProcAddress(Utils::NT::Module::Load(name).getHandle(), functionName.data());
						}
					}
				}

				if (!function)
				{
					MessageBoxA(nullptr, Utils::String::VA("Unable to load import '%s' from module '%s'", functionName.data(), name.data()), nullptr, MB_ICONERROR);
					TerminateProcess(GetCurrentProcess(), 1);
				}

				*addressTableEntry = reinterpret_cast<uintptr_t>(function);

				nameTableEntry++;
				addressTableEntry++;
			}

			descriptor++;
		}
	}

	Syringe::Callback Syringe::inject(Utils::NT::Module module)
	{
		if (!module.isValid()) return nullptr;

		Utils::NT::Module source(HMODULE(this->data.data()));
		if (!source.isValid()) return nullptr;

		this->loadSections(module, source);
		this->loadImports(module, source);

		if (source.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
		{
			const IMAGE_TLS_DIRECTORY* targetTls = reinterpret_cast<PIMAGE_TLS_DIRECTORY>(module.getPtr() + module.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
			const IMAGE_TLS_DIRECTORY* sourceTls = reinterpret_cast<PIMAGE_TLS_DIRECTORY>(module.getPtr() + source.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

			*reinterpret_cast<DWORD*>(sourceTls->AddressOfIndex) = 0;

			DWORD oldProtect;
			VirtualProtect(PVOID(targetTls->StartAddressOfRawData), sourceTls->EndAddressOfRawData - sourceTls->StartAddressOfRawData, PAGE_READWRITE, &oldProtect);

			LPVOID tlsBase = *reinterpret_cast<LPVOID*>(__readfsdword(0x2C));
			std::memmove(tlsBase, PVOID(sourceTls->StartAddressOfRawData), sourceTls->EndAddressOfRawData - sourceTls->StartAddressOfRawData);
			std::memmove(PVOID(targetTls->StartAddressOfRawData), PVOID(sourceTls->StartAddressOfRawData), sourceTls->EndAddressOfRawData - sourceTls->StartAddressOfRawData);
		}

		// copy over the offset to the new imports directory
		DWORD oldProtect;
		VirtualProtect(module.getNTHeaders(), 0x1000, PAGE_EXECUTE_READWRITE, &oldProtect);

		module.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] = source.getOptionalHeader()->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
		std::memmove(module.getNTHeaders(), source.getNTHeaders(), sizeof(IMAGE_NT_HEADERS) + (source.getNTHeaders()->FileHeader.NumberOfSections * (sizeof(IMAGE_SECTION_HEADER))));

		return Syringe::Callback(module.getPtr() + source.getRelativeEntryPoint());
	}

	void Syringe::setResolver(Syringe::Resolver resolver)
	{
		this->importResolver = resolver;
	}
}

```

`src/linker/Core/Syringe.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Core
{
	class Syringe
	{
	public:
		typedef void(*Callback)();
		typedef std::function<FARPROC(Utils::String, Utils::String)> Resolver;

		Syringe(const std::string& data);

		Callback inject(Utils::NT::Module module);

		void setResolver(Resolver resolver);

	private:
		std::string data;
		Resolver importResolver;

		void loadSection(Utils::NT::Module target, Utils::NT::Module source, IMAGE_SECTION_HEADER* section);
		void loadSections(Utils::NT::Module target, Utils::NT::Module source);
		void loadImports(Utils::NT::Module target, Utils::NT::Module source);
	};
}
```

`src/linker/Game/FastFile.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/FastFile.hpp"

#include "Core/Components/Console.hpp"

namespace Game
{
	uint8_t FastFile::Key[32]
	{
		0x64, 0x1D, 0x8A, 0x2F,
		0xE3, 0x1D, 0x3A, 0xA6,
		0x36, 0x22, 0xBB, 0xC9,
		0xCE, 0x85, 0x87, 0x22,
		0x9D, 0x42, 0xB0, 0xF8,
		0xED, 0x9B, 0x92, 0x41,
		0x30, 0xBF, 0x88, 0xB6,
		0x5E, 0xDC, 0x50, 0xBE
	};

	FastFile::FastFile() { }
	FastFile::FastFile(std::string&& _buffer) : buffer(_buffer) { }
	FastFile::FastFile(const std::string& _buffer) : buffer(_buffer) { }

	FastFile::FastFile(Utils::IO::File file)
	{
		auto result = file.read();

		if (result.result)
		{
			this->buffer = result.data;
		}
		else
		{
			Components::Console::Error("Invalid FastFile path\n");
			this->buffer = std::string();
		}
	}

	const Game::XFileHeaderSigned* FastFile::getHeader()
	{
		if (this->buffer.empty()) return nullptr;
		return reinterpret_cast<const Game::XFileHeaderSigned*>(this->buffer.data());
	}

	size_t FastFile::getHeaderSize()
	{
		if (!this->isValid()) return 0;
		if (this->isSigned()) return sizeof(Game::XFileHeaderSigned);
		if (this->isUnsigned()) return sizeof(Game::XFileHeaderUnsigned);
		return sizeof(Game::XFileHeaderRaw);
	}

	bool FastFile::isValid()
	{
		auto header = this->getHeader();
		if (!header) return false;

		return (header->u.r.magic == XFILE_MAGIC_RAW || header->u.r.magic == XFILE_MAGIC_UNSIGNED || header->u.r.magic == XFILE_MAGIC_SIGNED) &&
			header->u.r.platform == Game::PLATFORM_PC;
	}

	bool FastFile::isEncrypted()
	{
		return this->isValid() && this->getHeader()->u.r.magic != XFILE_MAGIC_RAW;
	}

	bool FastFile::isSigned()
	{
		return this->isValid() && this->getHeader()->u.r.magic == XFILE_MAGIC_SIGNED;
	}

	bool FastFile::isUnsigned()
	{
		return this->isValid() && this->getHeader()->u.r.magic == XFILE_MAGIC_UNSIGNED;
	}

	FastFile FastFile::encrypt(std::string name)
	{
		if (!this->isValid()) return FastFile();
		if (this->isEncrypted()) return this->decrypt().encrypt(name); // Rename the FastFile

		auto headerSize = this->getHeaderSize();
		if (this->buffer.size() <= headerSize)
		{
			Components::Console::Error("Unable to sign FastFile. Buffer is invalid\n");
			return FastFile();
		}

		Game::XFileHeaderSigned header;
		ZeroMemory(&header, sizeof(header));
		header.u.r = this->getHeader()->u.r;
		header.u.r.magic = XFILE_MAGIC_SIGNED;
		header.u.identifier = XFILE_IV_MAGIC_IDENTIFIER;
		strncpy(header.u.name, name.data(), sizeof(header.u.name));

		std::string result;
		result.append(PCHAR(&header), sizeof(header));

		// As far as I remember, the game uses the IV table to generate the signature in the end.
		Utils::Memory::Allocator allocator;
		auto ivTable = allocator.allocateArray<uint8_t>(16000);

		BYTE ivPtr[8];
		DWORD ivCounter[4] = { 0, 0, 0, 0 };

		FastFile::SetupIVCounter(ivCounter);
		FastFile::FillIVTable(header.u.name, ivTable, 16000);

		Game::XFileBlock* currentBlock = reinterpret_cast<Game::XFileBlock*>(&this->buffer[headerSize]);

		Utils::Cryptography::SHA1 sha1;
		Utils::Cryptography::SALSA20 salsa20;

		for (int i = 0;; i++)
		{
			if (!currentBlock->size) break;

			FastFile::FillIV((i % 4), ivPtr, ivTable, ivCounter);

			std::string hash = sha1.computeData(currentBlock->data, currentBlock->size);
			salsa20.encrypt(currentBlock->data, currentBlock->size, ivPtr, FastFile::Key, currentBlock->data);

			result.append(PCHAR(&currentBlock->size), 4);
			result.append(PCHAR(currentBlock->data), currentBlock->size);

			FastFile::GenerateIV((i % 4), INT(hash.data()), ivTable, &ivCounter[0]);
			currentBlock = reinterpret_cast<Game::XFileBlock*>(PCHAR(currentBlock) + currentBlock->size + 4);
		}

		int size = DWORD(this->buffer.data() + this->buffer.size()) - DWORD(currentBlock) + 4;
		for (int i = 0; i < size; i++)
		{
			result.push_back(0);
		}

		return FastFile(result);
	}

	FastFile FastFile::decrypt()
	{
		if (!this->isValid()) return FastFile();
		if (!this->isEncrypted()) return *this;

		auto headerSize = this->getHeaderSize();
		if (this->buffer.size() <= headerSize)
		{
			Components::Console::Error("Unable to sign FastFile. Buffer is invalid\n");
			return FastFile();
		}

		Game::XFileHeaderRaw header;
		ZeroMemory(&header, sizeof(header));
		header = this->getHeader()->u.r;
		header.magic = XFILE_MAGIC_RAW;

		std::string result;
		result.append(PCHAR(&header), sizeof(header));

		Utils::Memory::Allocator allocator;
		auto ivTable = allocator.allocateArray<uint8_t>(16000);

		BYTE ivPtr[8];
		DWORD ivCounter[4] = { 0, 0, 0, 0 };

		FastFile::SetupIVCounter(ivCounter);
		FastFile::FillIVTable(this->getName().data(), ivTable, 16000);

		Game::XFileBlock* currentBlock = reinterpret_cast<Game::XFileBlock*>(&this->buffer[headerSize]);

		Utils::Cryptography::SHA1 sha1;
		Utils::Cryptography::SALSA20 salsa20;

		for (int i = 0;; i++)
		{
			if (!currentBlock->size) break;

			FastFile::FillIV((i % 4), ivPtr, ivTable, ivCounter);

			salsa20.decrypt(currentBlock->data, currentBlock->size, ivPtr, FastFile::Key, currentBlock->data);
			std::string hash = sha1.computeData(currentBlock->data, currentBlock->size);

			result.append(PCHAR(&currentBlock->size), 4);
			result.append(PCHAR(currentBlock->data), currentBlock->size);

			FastFile::GenerateIV((i % 4), INT(hash.data()), ivTable, &ivCounter[0]);
			currentBlock = reinterpret_cast<Game::XFileBlock*>(PCHAR(currentBlock) + currentBlock->size + 4);
		}

		int size = DWORD(this->buffer.data() + this->buffer.size()) - DWORD(currentBlock) + 4;
		for (int i = 0; i < size; i++)
		{
			result.push_back(0);
		}

		return FastFile(result);
	}

	FastFile FastFile::sign()
	{
		if (!this->isValid()) return FastFile();
		if (this->isSigned()) return *this;
		if (!this->isEncrypted())
		{
			Components::Console::Error("Unable to sign FastFile. It needs to be encrypted first\n");
			return FastFile();
		}

		auto headerSize = this->getHeaderSize();
		if (this->buffer.size() <= headerSize)
		{
			Components::Console::Error("Unable to sign FastFile. Buffer is invalid\n");
			return FastFile();
		}

		return this->decrypt().encrypt(this->getName());
	}

	FastFile FastFile::unsign()
	{
		if (!this->isValid()) return FastFile();
		if (this->isUnsigned()) return *this;
		if (!this->isEncrypted())
		{
			Components::Console::Error("Unable to unsign FastFile. It needs to be encrypted first\n");
			return FastFile();
		}

		auto headerSize = this->getHeaderSize();
		if (this->buffer.size() <= headerSize)
		{
			Components::Console::Error("Unable to unsign FastFile. Buffer is invalid\n");
			return FastFile();
		}

		std::string result;
		result.append(PCHAR(&this->getHeader()->u), sizeof(Game::XFileHeaderUnsigned));
		result.append(&this->buffer[headerSize], this->buffer.size() - headerSize);

		return FastFile(result);
	}

	FastFile FastFile::Compress(const std::string& zone)
	{
		Game::XFileHeaderRaw header;
		header.magic = XFILE_MAGIC_RAW;
		header.platform = Game::PLATFORM_PC;

		std::string buffer;
		buffer.reserve(zone.size());
		buffer.append(PCHAR(&header), sizeof(header));

		Utils::Memory::Allocator allocator;
		const size_t blockLimit = XFILE_CHUNK_SIZE + 1;
		uint8_t* blockBuffer = allocator.allocateArray<uint8_t>(blockLimit);

		uint8_t* stream = PUCHAR(zone.data());
		uint8_t* end = stream + zone.size();

		while (true)
		{
			z_stream strm = { 0 };
			int size = std::min(XFILE_BLOCK_SIZE, end - stream);
			int initialSize = size;

			// Dynamically store blocks, while constantly decreasing the block size.
			// The game has a 2-in-1-block system to store over sized blocks in 2 steps.
			// This is potentially unsafe, if the buffer exceeds the size of 2 blocks (doubt that's possible though).
			// Storing blocks this way breaks these potential vulnerabilities.
			while (true)
			{
				deflateInit2_(&strm, Z_BEST_COMPRESSION, Z_DEFLATED, -15, 1, Z_DEFAULT_STRATEGY, "1.2.3", sizeof(z_stream));

				strm.next_out = blockBuffer;
				strm.next_in = stream;
				strm.avail_out = XFILE_CHUNK_SIZE;
				strm.avail_in = size;

				int result = deflate(&strm, Z_FINISH);

				deflateEnd(&strm);

				if (result == Z_STREAM_END) break; // Success
				else if (result == Z_OK) // Overflow, write smaller block
				{
					size /= 2;
					if (size < 8)
					{
						Components::Console::Error("Unable to compress zone block. Minimum size reached!\n");
						return FastFile();
					}
				}
				else
				{
					Components::Console::Error("Unable to compress zone block. Error code %X\n", result);
					return FastFile();
				}
			}

			buffer.append(PCHAR(&strm.total_out), 4);
			buffer.append(PCHAR(blockBuffer), strm.total_out);

			stream += size;

			if (size != XFILE_BLOCK_SIZE && size == initialSize) break;
		}

		while (buffer.size() % 16) buffer.push_back(0);
		for (int i = 0; i < 80; ++i) buffer.push_back(0);

		return FastFile(buffer);
	}

	std::string FastFile::decompress()
	{
		if (!this->isValid()) return std::string();
		if (this->isEncrypted()) return this->decrypt().decompress();

		auto headerSize = this->getHeaderSize();
		if (this->buffer.size() <= headerSize)
		{
			Components::Console::Error("Unable to decompress zone. Buffer is invalid\n");
			return std::string();
		}

		uint8_t* stream = PUCHAR(&this->buffer[headerSize]);

		Utils::Memory::Allocator allocator;
		const size_t blockLimit = XFILE_CHUNK_SIZE + 1;
		uint8_t* blockBuffer = allocator.allocateArray<uint8_t>(blockLimit);

		std::string zone;

		while (true)
		{
			size_t blockLength = *PDWORD(stream);
			stream += 4;

			if (PCHAR(stream + blockLength) > PCHAR(this->buffer.data() + this->buffer.size()))
			{
				Components::Console::Error("Unable to decompress zone. Block exceeds buffer\n");
				return std::string();
			}

			if (!blockLength) break;

			z_stream strm = { 0 };
			inflateInit2_(&strm, -15, "1.2.3", sizeof(z_stream));

			strm.avail_in = blockLength;
			strm.next_in = stream;
			strm.avail_out = blockLimit;
			strm.next_out = blockBuffer;
			int result = inflate(&strm, Z_FULL_FLUSH);

			inflateEnd(&strm);
			stream += blockLength;

			if (result != Z_STREAM_END)
			{
				Components::Console::Error("Unable to decompress zone block. Error code %X\n", result);
				return std::string();
			}

			if (zone.empty())
			{
				auto zoneHeader = reinterpret_cast<Game::ZoneHeader*>(blockBuffer);
				zone.reserve(zoneHeader->xFile.size + XFILE_BLOCK_SIZE);
			}

			zone.append(PCHAR(blockBuffer), strm.total_out);
		}

		return zone;
	}

	FastFile::operator std::string()
	{
		return this->getBuffer();
	}

	std::string& FastFile::getBuffer()
	{
		return this->buffer;
	}

	std::string FastFile::getName()
	{
		if (!this->isValid()) return std::string();
		if (!this->isEncrypted()) return std::string();

		char name[sizeof(Game::XFileHeaderUnsigned::name) + 1] = { 0 };
		strncpy(name, this->getHeader()->u.name, sizeof(Game::XFileHeaderUnsigned::name));

		return name;
	}

	void FastFile::SetupIVCounter(DWORD* ivCounterPtr)
	{
		for (int i = 0; i < 4; i++)
		{
			ivCounterPtr[i] = 1;
		}
	}

	void FastFile::FillIV(int a1, BYTE* ivPtr, BYTE* ivTable, DWORD* ivCounterPtr)
	{
		int v1 = ((a1 + 4 * (ivCounterPtr[a1] - 1)) % 800 * 20);

		for (int i = 0; i < 8; ++i)
		{
			ivPtr[i] = ivTable[v1 + i];
		}
	}

	void FastFile::FillIVTable(const char* name, unsigned char* ivTable, size_t ivTableLength)
	{
		size_t nameLength = strlen(name);

		for (size_t i = 0; i < ivTableLength; i++)
		{
			ivTable[i] = name[i / 4 % nameLength];
		}
	}

	// TODO: Refactor that
	void FastFile::GenerateIV(int a1, int a2, BYTE* ivTable, DWORD* ivCounterPtr)
	{
		int v2 = 4;
		signed int v3 = 0;
		int v4;
		int v5;
		int v6;
		int v7;
		int v8;

		do
		{
			v4 = (a1 + v2 * ivCounterPtr[a1]) % 800 * 5;
			*(&ivTable[4 * v4 + 0] + v3) ^= *(BYTE*)(a2 + v3 + 0);
			v5 = (a1 + v2 * ivCounterPtr[a1]) % 800 * 5;
			*(&ivTable[4 * v5 + 1] + v3) ^= *(BYTE*)(a2 + v3 + 1);
			v6 = (a1 + v2 * ivCounterPtr[a1]) % 800 * 5;
			*(&ivTable[4 * v6 + 2] + v3) ^= *(BYTE*)(a2 + v3 + 2);
			v7 = (a1 + v2 * ivCounterPtr[a1]) % 800 * 5;
			*(&ivTable[4 * v7 + 3] + v3) ^= *(BYTE*)(a2 + v3 + 3);
			v8 = (a1 + v2 * ivCounterPtr[a1]) % 800 * 5;
			*(&ivTable[4 * v8 + 4] + v3) ^= *(BYTE*)(a2 + v3 + 4);
			v3 += 5;
		} while (v3 < 20);

		++ivCounterPtr[a1];
	}
}

```

`src/linker/Game/FastFile.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/Game.hpp"

namespace Game
{
	class FastFile
	{
	public:
		FastFile();
		FastFile(const std::string& buffer);
		FastFile(std::string&& buffer);
		FastFile(Utils::IO::File file);

		FastFile encrypt(std::string name);
		FastFile decrypt();

		FastFile sign();
		FastFile unsign();

		static FastFile Compress(const std::string& zone);
		std::string decompress();

		bool isValid();

		bool isEncrypted();
		bool isSigned();
		bool isUnsigned();

		std::string& getBuffer();

		std::string getName();

		operator std::string();

	private:
		std::string buffer;

		const Game::XFileHeaderSigned* getHeader();
		size_t getHeaderSize();

		static uint8_t Key[32];

		static void SetupIVCounter(DWORD* ivCounterPtr);
		static void FillIV(int a1, BYTE* ivPtr, BYTE* ivTable, DWORD* ivCounterPtr);
		static void FillIVTable(const char* name, unsigned char* ivTable, size_t ivTableLength);
		static void GenerateIV(int a1, int a2, BYTE* ivTable, DWORD* ivCounterPtr);
	};
}

```

`src/linker/Game/Game.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game.hpp"

namespace Game
{
	Cbuf_AddText_t Cbuf_AddText = Cbuf_AddText_t(0x6B85A0);

	Cmd_ExecuteSingleCommand_t Cmd_ExecuteSingleCommand = Cmd_ExecuteSingleCommand_t(0x6B9ED0);
	Cmd_Argc_t Cmd_Argc = Cmd_Argc_t(0x42E3F0);
	Cmd_Argv_t Cmd_Argv = Cmd_Argv_t(0x42E470);

	Com_AddStartupCommands_t Com_AddStartupCommands = Com_AddStartupCommands_t(0x6C2B10);
	Com_HashKey_t Com_HashKey = Com_HashKey_t(0x772290);

	DB_FindXAssetHeader_t DB_FindXAssetHeader = DB_FindXAssetHeader_t(0x559810);
	DB_GetXAssetTypeName_t DB_GetXAssetTypeName = DB_GetXAssetTypeName_t(0x538B40);
	DB_GetXAssetTypeSize_t DB_GetXAssetTypeSize = DB_GetXAssetTypeSize_t(0x538B00);
	DB_GetXAssetName_t DB_GetXAssetName = DB_GetXAssetName_t(0x538A70);
	DB_SetXAssetName_t DB_SetXAssetName = DB_SetXAssetName_t(0x538AB0);

	Load_XAssetHeader_t Load_XAssetHeader = Load_XAssetHeader_t(0x550B10);

	Mark_XAsset_t Mark_XAsset = Mark_XAsset_t(0x54CDD0);

	SL_ConvertToString_t SL_ConvertToString = SL_ConvertToString_t(0x846680);

	Sys_IsDatabaseReady_t Sys_IsDatabaseReady = Sys_IsDatabaseReady_t(0x6E5E00);

	void** DB_XAssetPool = reinterpret_cast<void**>(0xDB7790);
	unsigned int* g_poolSize = reinterpret_cast<unsigned int*>(0xDB73D0);

	XAsset*& varXAsset = *reinterpret_cast<XAsset**>(0x137B9A0);
	XAssetHeader*& varXAssetHeader = *reinterpret_cast<XAssetHeader**>(0x137BAD8);

	cmd_function_s*& cmd_functions = *reinterpret_cast<cmd_function_s**>(0x1D8C514);

	const char** g_assetNames = reinterpret_cast<const char**>(0xDB6D00);

	void* ReallocateAssetPool(Game::XAssetType type, unsigned int newSize)
	{
		int elSize = DB_GetXAssetTypeSize(type);
		void* poolEntry = Utils::Memory::GetAllocator()->allocate(newSize * elSize);
		DB_XAssetPool[type] = poolEntry;
		g_poolSize[type] = newSize;
		return poolEntry;
	}
}

```

`src/linker/Game/Game.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/Structs.hpp"

namespace Game
{
	typedef void(*Cbuf_AddText_t)(LocalClientNum_t localClientNum, const char *text);
	extern Cbuf_AddText_t Cbuf_AddText;

	typedef int(__cdecl * Cmd_Argc_t)();
	extern Cmd_Argc_t Cmd_Argc;

	typedef const char *(__cdecl * Cmd_Argv_t)(int argIndex);
	extern Cmd_Argv_t Cmd_Argv;

	typedef void(__cdecl * Cmd_ExecuteSingleCommand_t)(LocalClientNum_t localClientNum, ControllerIndex_t controllerIndex, const char *text, bool fromRemoteConsole);
	extern Cmd_ExecuteSingleCommand_t Cmd_ExecuteSingleCommand;

	typedef void(*Com_AddStartupCommands_t)();
	extern Com_AddStartupCommands_t Com_AddStartupCommands;

	typedef int(*Com_HashKey_t)(const char* string, int maxlen);
	extern Com_HashKey_t Com_HashKey;

	typedef XAssetHeader(*DB_FindXAssetHeader_t)(XAssetType type, const char *name, bool errorIfMissing, int waitTime);
	extern DB_FindXAssetHeader_t DB_FindXAssetHeader;

	typedef const char *(*DB_GetXAssetTypeName_t)(int type);
	extern DB_GetXAssetTypeName_t DB_GetXAssetTypeName;

	typedef int(*DB_GetXAssetTypeSize_t)(int type);
	extern DB_GetXAssetTypeSize_t DB_GetXAssetTypeSize;

	typedef const char *(*DB_GetXAssetName_t)(XAsset *asset);
	extern DB_GetXAssetName_t DB_GetXAssetName;

	typedef void(*DB_SetXAssetName_t)(XAsset *asset, const char *name);
	extern DB_SetXAssetName_t DB_SetXAssetName;

	typedef void(*Load_XAssetHeader_t)(bool atStreamStart);
	extern Load_XAssetHeader_t Load_XAssetHeader;

	typedef void(*Mark_XAsset_t)();
	extern Mark_XAsset_t Mark_XAsset;

	typedef const char *(*SL_ConvertToString_t)(unsigned int stringValue);
	extern SL_ConvertToString_t SL_ConvertToString;

	typedef bool(*Sys_IsDatabaseReady_t)();
	extern Sys_IsDatabaseReady_t Sys_IsDatabaseReady;

	extern void** DB_XAssetPool;
	extern unsigned int* g_poolSize;

	extern XAsset*& varXAsset;
	extern XAssetHeader*& varXAssetHeader;

	extern cmd_function_s*& cmd_functions;

	extern const char** g_assetNames;

	void* ReallocateAssetPool(Game::XAssetType type, unsigned int newSize);
}

```

`src/linker/Game/Stream.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Zone.hpp"

#include "Core/Components/Console.hpp"

namespace Game
{
	Stream::Stream(size_t size)
	{
		this->buffer.reserve(size);
		ZeroMemory(&this->blockSizes, sizeof(this->blockSizes));
	}

	void Stream::writeString(const std::string& string)
	{
		this->write(string.data(), string.size());
		this->writeRVal(0ui8);
	}

	void Stream::write(const void* data, size_t length)
	{
		auto block = this->getBlock();
		if (block == -1 || block == 0 || block == 5 || block == 6)
		{
			this->buffer.append(PCHAR(data), length);
		}

		this->increaseBlockSize(length);
	}

	std::string& Stream::getBuffer()
	{
		return this->buffer;
	}

	void Stream::pushBlock(int block)
	{
		this->blockStack.push_back(block);
	}

	void Stream::popBlock()
	{
		this->blockStack.pop_back();
	}

	void Stream::align(int subBinaryPower)
	{
		int block = Stream::getBlock();
		if (block == -1) return;

		this->blockSizes[block] = ~subBinaryPower & (this->blockSizes[block] + subBinaryPower);
	}

	int Stream::getBlockSize(int block)
	{
		if (block < 0 || block >= ARRAYSIZE(this->blockSizes)) return 0;
		return this->blockSizes[block];
	}

	int Stream::getBlock()
	{
		if (!this->blockStack.empty())
		{
			int block = this->blockStack.back();
			if (block >= 0 && block < ARRAYSIZE(this->blockSizes))
			{
				return block;
			}
		}
		return -1;
	}

	void Stream::increaseBlockSize(size_t size)
	{
		int block = Stream::getBlock();
		if (block == -1) return;

		this->blockSizes[block] += size;
	}

	void* Stream::findBasePointer(const void* pointer)
	{
		auto sourcePointer = PCHAR(pointer);

		for (auto& entry : this->pointerMap)
		{
			auto targetPointer = PCHAR(entry.first);
			if (sourcePointer >= targetPointer && sourcePointer < (targetPointer + entry.second.length))
			{
				return targetPointer;
			}
		}

		return nullptr;
	}

	void* Stream::findPointer(const void* pointer)
	{
		auto basePointer = this->findBasePointer(pointer);
		if (!basePointer) return nullptr;

		size_t offset = PCHAR(pointer) - PCHAR(basePointer);

		return PCHAR(this->pointerMap[basePointer].pointer) + offset;
	}

	void Stream::storePointer(const void* pointer, size_t length)
	{
		Pointer mappedPointer;
		mappedPointer.block = this->getBlock();
		mappedPointer.blockSize = this->getBlockSize(mappedPointer.block);
		mappedPointer.length = length;
		mappedPointer.pointer = this->buffer.data() + this->buffer.size();

		this->pointerMap[pointer] = mappedPointer;
	}

	void Stream::setIndexStart(int start)
	{
		this->indexStart = start;
	}

	int Stream::getIndexStart()
	{
		return this->indexStart;
	}

	bool Stream::hasPointer(const void* pointer)
	{
		return this->findBasePointer(pointer) != nullptr;
	}

	uint32_t Stream::safeGetPointer(const void* pointer)
	{
		void* basePointer = this->findBasePointer(pointer);
		if (!basePointer) return NULL;

		size_t offset = PCHAR(pointer) - PCHAR(basePointer);
		auto& mappedPointer = this->pointerMap[basePointer];

		Stream::Offset gameOffset;
		gameOffset.stream = Game::XFILE_BLOCK_TYPES(mappedPointer.block);
		gameOffset.value = mappedPointer.blockSize + offset;

		return gameOffset.getPackedValue();
	}
}

```

`src/linker/Game/Stream.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/FastFile.hpp"

namespace Game
{
	class Stream
	{
	public:
		// This represents packed offset in streams:
		// - lowest 29 bits store the value/offset
		// - highest 3 bits store the stream
		//
		// T6 only uses 8 streams instead of 16 (former CODs).
		// So only 3 bits are needed to store the stream (instead of 4).
		// log2(8) = 3
#pragma warning(push)
#pragma warning(disable: 4201)
		class Offset
		{
		public:
			union
			{
				struct
				{
					uint32_t value : 29;
					XFILE_BLOCK_TYPES stream : 3;
				};
				uint32_t packed;
			};

			Offset() : packed(0) {};
			Offset(XFILE_BLOCK_TYPES _stream, uint32_t _value) : value(_value), stream(_stream) {};

			// The game needs it to be incremented
			uint32_t getPackedValue() { return this->packed + 1; };
		};
#pragma warning(pop)

		Stream(size_t size);

		template<typename T>
		void writeArray(T*& obj, size_t size = 1)
		{
			this->write(obj, sizeof(T) * size);
		}

		template<typename T>
		void write(T& obj)
		{
			this->write(&obj, sizeof(T));
		}

		template<typename T>
		void writeRVal(T obj)
		{
			this->write(&obj, sizeof(T));
		}

		void writeString(const std::string& string);

		void pushBlock(int block);
		void popBlock();

		void write(const void* data, size_t length);
		std::string& getBuffer();

		int getBlockSize(int block);
		int getBlock();

		void align(int subBinaryPower);

		template<typename T>
		static void ResetPointer(T*& pointer)
		{
			pointer = reinterpret_cast<T*>(-1);
		}

		void* findBasePointer(const void* pointer);
		void* findPointer(const void* pointer);
		void storePointer(const void* pointer, size_t length);

		void setIndexStart(int start);
		int getIndexStart();

		bool hasPointer(const void* pointer);
		uint32_t safeGetPointer(const void* pointer);

	private:
		class Pointer
		{
		public:
			int block;
			int blockSize;
			void* pointer;
			size_t length;
		};

		int indexStart;

		std::string buffer;
		std::vector<int> blockStack;
		unsigned int blockSizes[Game::MAX_XFILE_COUNT];

		std::map<const void*, Pointer> pointerMap;

		void increaseBlockSize(size_t size);
	};
}

```

`src/linker/Game/Zone.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/Zone.hpp"

#include "Core/Components/Linker.hpp"
#include "Core/Components/Console.hpp"

namespace Game
{
	void Zone::addAsset(Game::XAsset asset)
	{
		Components::Linker::SetZone(this);

		this->markedAssets.clear();

		Game::varXAsset = &asset;
		Game::Mark_XAsset();

		while (!this->delayMarkedAssets.empty())
		{
			auto delayedAssets = this->delayMarkedAssets;
			this->delayMarkedAssets.clear();

			for (auto& delayedAsset : delayedAssets)
			{
				Game::varXAsset = &delayedAsset;
				Game::Mark_XAsset();
			}
		}

		std::reverse(this->markedAssets.begin(), this->markedAssets.end());
		Utils::Merge(&this->assets, this->markedAssets);
		this->markedAssets.clear();

		Components::Linker::SetZone(nullptr);
	}

	void Zone::addAsset(Game::XAssetType type, Game::XAssetHeader header)
	{
		this->addAsset(Game::XAsset{ type, header });
	}

	void Zone::markAsset(Game::XAsset asset)
	{
		std::string name = Game::DB_GetXAssetName(&asset);
		for (auto& entry : this->assets)
		{
			if (entry.type == asset.type &&
				Game::DB_GetXAssetName(&entry) == name)
			{
				return;
			}
		}

		bool alreadyMarked = false;
		for (auto i = this->markedAssets.begin(); i != this->markedAssets.end(); ++i)
		{
			if (i->type == asset.type &&
				Game::DB_GetXAssetName(&*i) == name)
			{
				this->markedAssets.erase(i);
				alreadyMarked = true;
				break;
			}
		}

		this->markedAssets.push_back(asset);

		if (!alreadyMarked)
		{
			Components::Linker::DelayMarkAsset(&asset);
		}
	}

	void Zone::markAsset(Game::XAssetType type, Game::XAssetHeader header)
	{
		this->markAsset(Game::XAsset{ type, header });
	}

	void Zone::delayMarkAsset(Game::XAsset asset)
	{
		this->delayMarkedAssets.push_back(asset);
	}

	void Zone::delayMarkAsset(Game::XAssetType type, Game::XAssetHeader header)
	{
		this->delayMarkAsset(Game::XAsset{ type, header });
	}

	unsigned short Zone::mapScriptString(unsigned short scriptString)
	{
		return 0xFFFF & this->scriptStringMap[scriptString];
	}

	void Zone::markScriptString(unsigned short scriptString)
	{
		if (this->scriptStringMap.find(scriptString) == this->scriptStringMap.end())
		{
			this->scriptStrings.push_back(Game::SL_ConvertToString(scriptString));
			this->scriptStringMap[scriptString] = this->scriptStrings.size();
		}
	}

	void Zone::addDependency(const std::string& zone)
	{
		if (std::find(this->dependencies.begin(), this->dependencies.end(), zone) == this->dependencies.end())
		{
			this->dependencies.push_back(zone);
		}
	}

	int Zone::getAssetIndex(void* pointer)
	{
		for (unsigned int i = 0; i < this->assets.size(); ++i)
		{
			if (this->assets[i].header.data == pointer)
			{
				return i;
			}
		}

		return -1;
	}

	size_t Zone::getAssetCount()
	{
		return this->assets.size();
	}

	void Zone::writeHeader(Stream& stream)
	{
		Game::ZoneHeader header;
		ZeroMemory(&header, sizeof(header));

		header.assetList.assetCount = this->assets.size();
		Stream::ResetPointer(header.assetList.assets);

		if (!this->dependencies.empty())
		{
			header.assetList.dependCount = this->dependencies.size();
			Stream::ResetPointer(header.assetList.depends);
		}

		if (!this->scriptStrings.empty())
		{
			header.assetList.stringList.count = this->scriptStrings.size() + 1; // 'nullptr' scriptstring included
			Stream::ResetPointer(header.assetList.stringList.strings);
		}

		stream.write(header);
	}

	void Zone::fixupHeader(Stream& stream)
	{
		auto& buffer = stream.getBuffer();

		XFile* header = reinterpret_cast<XFile*>(PCHAR(buffer.data()));
		header->size = buffer.size() - sizeof(XFile);
		header->externalSize = 0; // External data (e.g. images)

		for (int i = 0; i < MAX_XFILE_COUNT; i++)
		{
			header->blockSize[i] = stream.getBlockSize(i);
		}
	}

	void Zone::writeScriptStrings(Stream& stream)
	{
		if (this->scriptStrings.empty()) return;

		stream.align(3);
		stream.writeRVal(0ul); // 'nullptr' scriptstring

		for (unsigned int i = 0; i < this->scriptStrings.size(); ++i)
		{
			stream.writeRVal(-1l);
		}

		for (auto& string : this->scriptStrings)
		{
			stream.writeString(string);
		}
	}

	void Zone::writeDependencies(Stream& stream)
	{
		if (this->dependencies.empty()) return;

		stream.align(3);

		for (unsigned int i = 0; i < this->dependencies.size(); ++i)
		{
			stream.writeRVal(-1l);
		}

		for (auto& dependency : this->dependencies)
		{
			stream.writeString(dependency);
		}
	}

	void Zone::writeAssets(Stream& stream)
	{
		if (this->assets.empty()) return;

		stream.align(3);
		stream.setIndexStart(stream.getBlockSize(Game::XFILE_BLOCK_VIRTUAL));

		for (auto& asset : this->assets)
		{
			Game::XAsset entry;
			entry.type = asset.type;
			Stream::ResetPointer(entry.header.data);

			stream.write(entry);
		}

		stream.pushBlock(Game::XFILE_BLOCK_TEMP);

		for (auto& asset : this->assets)
		{
			Components::Linker::SaveAsset(&asset);
		}

		stream.popBlock();
	}

	FastFile Zone::build()
	{
		Stream stream(0xC800000);
		Components::Linker::LinkerLock _;
		Components::Linker::SetZone(this);
		Components::Linker::SetStream(&stream);
		Components::Linker::EnablePatches();

// 		auto test = this->assets;
// 		this->assets.clear();
// 		for (unsigned int i = 0; i < std::min(3u, test.size()); ++i)
// 		{
// 			this->assets.push_back(test[i]);
// 		}

		this->writeHeader(stream);

		stream.pushBlock(Game::XFILE_BLOCK_VIRTUAL);

		this->writeScriptStrings(stream);
		this->writeDependencies(stream);
		this->writeAssets(stream);
		this->fixupHeader(stream);

		stream.popBlock();

		Components::Linker::DisablePatches();
		Components::Linker::SetStream(nullptr);
		Components::Linker::SetZone(nullptr);

		return FastFile::Compress(stream.getBuffer());
	}
}

```

`src/linker/Game/Zone.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#include "Game/Stream.hpp"
#include "Game/FastFile.hpp"

static_assert(sizeof(long) == 4);

namespace Game
{
	class Zone
	{
	public:
		void addAsset(Game::XAsset asset);
		void addAsset(Game::XAssetType type, Game::XAssetHeader header);

		void markAsset(Game::XAsset asset);
		void markAsset(Game::XAssetType type, Game::XAssetHeader header);

		void delayMarkAsset(Game::XAsset asset);
		void delayMarkAsset(Game::XAssetType type, Game::XAssetHeader header);

		void markScriptString(unsigned short scriptString);
		unsigned short mapScriptString(unsigned short scriptString);

		void addDependency(const std::string& zone);

		size_t getAssetCount();
		int getAssetIndex(void* pointer);

		FastFile build();

	private:
		Utils::Memory::Allocator allocator;

		std::vector<Game::XAsset> delayMarkedAssets;
		std::vector<Game::XAsset> markedAssets;
		std::vector<Game::XAsset> assets;
		std::vector<std::string> dependencies;
		std::vector<std::string> scriptStrings;
		std::map<unsigned short, unsigned int> scriptStringMap;

		void writeHeader(Stream& stream);
		void fixupHeader(Stream& stream);

		void writeScriptStrings(Stream& stream);
		void writeDependencies(Stream& stream);
		void writeAssets(Stream& stream);
	};
}

```

`src/linker/Linker.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Core/Syringe.hpp"
#include "Core/Loader.hpp"

namespace Main
{
	void Initialize()
	{
		srand(uint32_t(time(nullptr)));

		Utils::SetEnvironment();

		Utils::NT::Module self;
		Utils::IO::File selfFile(self.getName());
		Utils::IO::File debugFile("__" + selfFile.getName(false));
		debugFile.remove();
	}

	void Uninitialize()
	{
		Loader::Uninitialize();
		//google::protobuf::ShutdownProtobufLibrary();
	}

	void InitializePostInject()
	{
		Loader::Initialize();
		atexit(Loader::Uninitialize);
	}

	VOID WINAPI ExitProcessStub(UINT uExitCode)
	{
		exit(uExitCode);
	}

	FARPROC ImportResolver(Utils::String module, Utils::String process)
	{
		Utils::NT::Module self;

		if (module.toLower() == "steam_api.dll") return FARPROC(0x1);
		if (module.toLower() == "binkw32.dll") return FARPROC(0x1);
		if (module.toLower() == "kernel32.dll" && process == "ExitProcess")
		{
			return FARPROC(Main::ExitProcessStub);
		}

		return nullptr;
	}

	Core::Syringe::Callback InjectModule()
	{
		Utils::NT::Module self;

		auto data = Utils::LoadResource(DEDI_BINARY);
		data = Utils::Compression::ZLib::Decompress(data);

		Core::Syringe loader(data);
		loader.setResolver(Main::ImportResolver);

		Core::Syringe::Callback entryPoint = loader.inject(self);
		if (!entryPoint) MessageBoxA(nullptr, "Unable to initialize the linker", "Error", MB_ICONERROR);

		return entryPoint;
	}
}

void main()
{
	Main::Initialize();
	Core::Syringe::Callback entryPoint = Main::InjectModule();
	Main::InitializePostInject();
	if (entryPoint) entryPoint();
}

```

`src/linker/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#include "STDInclude.hpp"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
// FILEVERSION VERSION_RC
// PRODUCTVERSION VERSION_RC
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Plutonium"
#ifdef _DEBUG
            VALUE "FileDescription", "FastFile Linker (DEBUG)"
#else
            VALUE "FileDescription", "FastFile Linker"
#endif
//            VALUE "FileVersion", SHORTVERSION 
            VALUE "InternalName", "linker"
            VALUE "LegalCopyright", "Copyright 2017 T6r. All rights reserved."
            VALUE "OriginalFilename", "linker.dll"
            VALUE "ProductName", "linker"
//            VALUE "ProductVersion", SHORTVERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

DEDI_BINARY RCDATA "Resource/bin.dat"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/linker/STDInclude.cpp`:

```cpp
#include "STDInclude.hpp"

#pragma comment(linker,"\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

#pragma comment(linker, "/merge:.data=.cld")
#pragma comment(linker, "/merge:.rdata=.clr")
#pragma comment(linker, "/merge:.cl=.zdata")
#pragma comment(linker, "/merge:.text=.zdata")
#pragma comment(linker, "/section:.zdata,re")
#pragma comment(linker, "/base:0x400000")

// Do necessary assertions here
// Some compilers treat them differently which causes a size mismatch

// WinAPI types
AssertSize(DWORD, 4);
AssertSize(WORD, 2);
AssertSize(BYTE, 1);

// 128 bit integers (only x64)
//AssertSize(__int128, 16);
//AssertSize(unsigned __int128, 16);

// 64 bit integers
AssertSize(__int64, 8);
AssertSize(unsigned __int64, 8);
AssertSize(long long, 8);
AssertSize(unsigned long long, 8);
AssertSize(int64_t, 8);
AssertSize(uint64_t, 8);
AssertSize(std::int64_t, 8);
AssertSize(std::uint64_t, 8);

// 64 bit double precision floating point numbers
AssertSize(double, 8);

// 32 bit integers
AssertSize(__int32, 4);
AssertSize(unsigned __int32, 4);
AssertSize(int, 4);
AssertSize(unsigned int, 4);
AssertSize(long, 4);
AssertSize(unsigned long, 4);
AssertSize(int32_t, 4);
AssertSize(uint32_t, 4);
AssertSize(std::int32_t, 4);
AssertSize(std::uint32_t, 4);

// 32 bit single precision floating point numbers
AssertSize(float, 4);

// 16 bit integers
AssertSize(__int16, 2);
AssertSize(unsigned __int16, 2);
AssertSize(short, 2);
AssertSize(unsigned short, 2);
AssertSize(int16_t, 2);
AssertSize(uint16_t, 2);
AssertSize(std::int16_t, 2);
AssertSize(std::uint16_t, 2);

// 8 bit integers
AssertSize(bool, 1);
AssertSize(__int8, 1);
AssertSize(unsigned __int8, 1);
AssertSize(char, 1);
AssertSize(unsigned char, 1);
AssertSize(int8_t, 1);
AssertSize(uint8_t, 1);
AssertSize(std::int8_t, 1);
AssertSize(std::uint8_t, 1);

// Ensure pointers are 4 bytes in size (32-bit)
// ReSharper disable CppRedundantBooleanExpressionArgument
//static_assert(sizeof(intptr_t) == 4 && sizeof(void*) == 4 && sizeof(size_t) == 4, "This doesn't seem to be a 32-bit environment!");
// ReSharper restore CppRedundantBooleanExpressionArgument

#if !defined(_M_IX86)
#error "Invalid processor architecture!"
#endif

extern "C"
{
    // Disable telemetry data logging
	void __cdecl __vcrt_initialize_telemetry_provider() {}
	void __cdecl __telemetry_main_invoke_trigger() {}
	void __cdecl __telemetry_main_return_trigger() {}
	void __cdecl __vcrt_uninitialize_telemetry_provider() {}
	
	// Enable 'High Performance Graphics'
    __declspec(dllexport) DWORD NvOptimusEnablement = 1;
	__declspec(dllexport) DWORD AmdPowerXpressRequestHighPerformance = 1;
};

#pragma region tls
__declspec(thread) char tls1[0x4000];
#pragma endregion

#pragma bss_seg(".cdummy")
char dummy_seg[BINARY_PAYLOAD_SIZE];

char stub_seg[0x100000];

#pragma data_seg(".zdata")
char zdata[200] = { 1 };

```

`src/linker/STDInclude.hpp`:

```hpp
#pragma once

#define STD_INCLUDED

// Version number
#include "version.h"

#ifndef RC_INVOKED

#define _HAS_CXX17 1
#define VC_EXTRALEAN
#ifndef NOMINMAX
#define NOMINMAX
#endif

#define _CRT_SECURE_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN

// Requires Visual Leak Detector plugin: http://vld.codeplex.com/
#define VLD_FORCE_ENABLE
//#include <vld.h>

#include <windows.h>
#include <assert.h>
#include <intrin.h>
#include <Shellapi.h>
#include <winternl.h>
#include <VersionHelpers.h>

#include <WinSock2.h>
#include <ws2tcpip.h>

#include <wincrypt.h>

#include <d3d11.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "Shell32.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "Crypt32.lib")

// Delay import
#include <delayimp.h>
#pragma comment(lib, "delayimp.lib")

#pragma warning(push)
#pragma warning(disable: 4091)
#pragma warning(disable: 4244)
#include <dbghelp.h>

#include <map>
#include <mutex>
#include <fstream>
#include <thread>
#include <unordered_map>
#include <queue>
#include <random>
#include <atomic>
#include <regex>

// Experimental C++17 features
#include <filesystem>
#include <optional>

#pragma warning(pop)

// Submodules
// Ignore the warnings, it's not our code!
#pragma warning(push)
#pragma warning(disable: 4100)
#pragma warning(disable: 4146)
#pragma warning(disable: 4389)
#pragma warning(disable: 4996)
#pragma warning(disable: 6001)
#pragma warning(disable: 6031)
#pragma warning(disable: 6255)
#pragma warning(disable: 6258)
#pragma warning(disable: 6386)
#pragma warning(disable: 6387)

#include <zlib.h>
#include <udis86.h>
#include <tomcrypt.h>
#include <ecrypt-sync.h>

#pragma warning(pop)

// Enable additional literals
using namespace std::literals;

#include "Utils/IO.hpp"
#include "Utils/NT.hpp"
#include "Utils/Lock.hpp"
#include "Utils/Time.hpp"
#include "Utils/Flags.hpp"
#include "Utils/Queue.hpp"
#include "Utils/Utils.hpp"
#include "Utils/Signal.hpp"
#include "Utils/Memory.hpp"
#include "Utils/String.hpp"
#include "Utils/Hooking.hpp"
#include "Utils/Compression.hpp"
#include "Utils/Cryptography.hpp"
#include "Utils/Salsa20.hpp"
#include "Utils/CSV.hpp"

#endif

#include <Common.hpp>

#define BINARY_PAYLOAD_SIZE 0x60000000
#define DEDI_BINARY         300

```

`src/linker/Utils/CSV.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	CSV::Row::Row(std::string row)
	{
		std::regex rowRegex("(((\\\\,)|[^,])*)(,|$)");

		for (std::sregex_iterator i(row.begin(), row.end(), rowRegex); i != std::sregex_iterator(); ++i)
		{
			std::smatch match = *i;
			Utils::String col(match[1].str());
			this->data.push_back(col.replaceAll("\\,", ","));
		}

		this->data.pop_back();
	}

	size_t CSV::Row::getColumnCount()
	{
		return this->data.size();
	}

	std::string CSV::Row::getColumn(int col)
	{
		return this->data[col];
	}

	CSV::CSV(std::string data)
	{
		std::regex lineRegex("(.*)((\\r?\\n)|$)");

		for (std::sregex_iterator i(data.begin(), data.end(), lineRegex); i != std::sregex_iterator(); ++i)
		{
			std::smatch match = *i;
			auto line = match[1].str();
			if (!line.empty() && line[0] != '#')
			{
				this->rows.push_back(Row(line));
			}
		}
	}

	size_t CSV::getRowCount()
	{
		return this->rows.size();
	}

	CSV::Row& CSV::getRow(int row)
	{
		return this->rows[row];
	}

	std::string CSV::getElement(int row, int col)
	{
		return this->getRow(row).getColumn(col);
	}
}

```

`src/linker/Utils/CSV.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class CSV
	{
	public:
		class Row
		{
		public:
			Row(std::string row);

			size_t getColumnCount();
			std::string getColumn(int col);

		private:
			std::vector<std::string> data;
		};

		CSV(std::string data);

		size_t getRowCount();
		Row& getRow(int row);
		std::string getElement(int row, int col);

	private:
		std::vector<Row> rows;
	};
}

```

`src/linker/Utils/Salsa20.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Cryptography
	{
		bool SALSA20::encrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData)
		{
			ECRYPT_ctx x;
			ECRYPT_keysetup(&x, key, 32 * 8, 0);
			ECRYPT_ivsetup(&x, iv);
			ECRYPT_encrypt_bytes(&x, inData, outData, length);

			return true;
		}

		bool SALSA20::decrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData)
		{
			ECRYPT_ctx x;
			ECRYPT_keysetup(&x, key, 32 * 8, 0);
			ECRYPT_ivsetup(&x, iv);
			ECRYPT_decrypt_bytes(&x, inData, outData, length);

			return true;
		}
	}
}

```

`src/linker/Utils/Salsa20.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

#define HOOK_JUMP true
#define HOOK_CALL false

namespace Utils
{
	namespace Cryptography
	{
		class SALSA20 : public IEncryption
		{
		public:
			virtual bool encrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) override;
			virtual bool decrypt(const uint8_t* inData, size_t length, uint8_t* iv, uint8_t* key, uint8_t* outData) override;
		};
	}
}

```