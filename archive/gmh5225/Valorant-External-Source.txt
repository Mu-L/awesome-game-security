Project Path: arc_gmh5225_Valorant-External-Source_jhf8ss0c

Source Tree:

```txt
arc_gmh5225_Valorant-External-Source_jhf8ss0c
├── New Text Document.txt
├── README.md
├── VALORANT.vcxproj
├── VALORANT.vcxproj.filters
├── VALORANT.vcxproj.user
├── Valorant.sln
├── anti.hpp
├── antidebug.hpp
├── blow.cpp
├── blow.h
├── cheat.hpp
├── check.h
├── driver.h
├── driver.sys
├── globals.hpp
├── imguipp.cpp
├── imguipp.h
├── lazy.hpp
├── main.cpp
├── main.h
├── menu.hpp
├── obs.opf
├── obs.opf.bak
├── obsidium64.h
├── obsidium64.lib
├── print.hpp
├── renderer.hpp
├── skcrypt.hpp
├── ss.h
├── stdafx.h
├── vectors.hpp
└── xor.h

```

`New Text Document.txt`:

```txt
obs1663642083
```

`README.md`:

```md
# Valorant-External-Source

The valorant source half the p2c community is using &lt;3 boss

```

`VALORANT.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="blow.cpp" />
    <ClCompile Include="imguipp.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Mapper\Kdmapper\intel_driver.cpp" />
    <ClCompile Include="Mapper\Kdmapper\kdmapper.cpp" />
    <ClCompile Include="Mapper\Kdmapper\portable_executable.cpp" />
    <ClCompile Include="Mapper\Kdmapper\service.cpp" />
    <ClCompile Include="Mapper\Kdmapper\utils.cpp" />
    <ClCompile Include="render\imgui.cpp" />
    <ClCompile Include="render\imgui_demo.cpp" />
    <ClCompile Include="render\imgui_draw.cpp" />
    <ClCompile Include="render\imgui_impl_dx9.cpp" />
    <ClCompile Include="render\imgui_impl_win32.cpp" />
    <ClCompile Include="render\imgui_widgets.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="anti.hpp" />
    <ClInclude Include="blow.h" />
    <ClInclude Include="check.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="cheat.hpp" />
    <ClInclude Include="globals.hpp" />
    <ClInclude Include="imguipp.h" />
    <ClInclude Include="KeyAuth\auth.hpp" />
    <ClInclude Include="lazy.hpp" />
    <ClInclude Include="main.h" />
    <ClInclude Include="Mapper\Kdmapper\intel_driver.hpp" />
    <ClInclude Include="Mapper\Kdmapper\intel_driver_resource.hpp" />
    <ClInclude Include="Mapper\Kdmapper\kdmapper.hpp" />
    <ClInclude Include="Mapper\Kdmapper\nt.hpp" />
    <ClInclude Include="Mapper\Kdmapper\portable_executable.hpp" />
    <ClInclude Include="Mapper\Kdmapper\service.hpp" />
    <ClInclude Include="Mapper\Kdmapper\utils.hpp" />
    <ClInclude Include="menu.hpp" />
    <ClInclude Include="obsidium64.h" />
    <ClInclude Include="print.hpp" />
    <ClInclude Include="renderer.hpp" />
    <ClInclude Include="render\imconfig.h" />
    <ClInclude Include="render\imgui.h" />
    <ClInclude Include="render\imgui_impl_dx9.h" />
    <ClInclude Include="render\imgui_impl_win32.h" />
    <ClInclude Include="render\imgui_internal.h" />
    <ClInclude Include="render\imstb_rectpack.h" />
    <ClInclude Include="render\imstb_textedit.h" />
    <ClInclude Include="render\imstb_truetype.h" />
    <ClInclude Include="skcrypt.hpp" />
    <ClInclude Include="ss.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="vectors.hpp" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="KeyAuth\libcurl.lib" />
    <Library Include="KeyAuth\library_x64.lib" />
    <Library Include="obsidium64.lib" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{403ccf71-c4d3-4b5f-abb1-2b3c2ccc8c45}</ProjectGuid>
    <RootNamespace>Userland</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Valorant</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)KeyAuth;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)KeyAuth;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalOptions>/ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VALORANT.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="render\imgui.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="render\imgui_demo.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="render\imgui_draw.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="render\imgui_impl_dx9.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="render\imgui_impl_win32.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="render\imgui_widgets.cpp">
      <Filter>ImGui</Filter>
    </ClCompile>
    <ClCompile Include="blow.cpp">
      <Filter>Header Files\decryption</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Mapper\Kdmapper\intel_driver.cpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClCompile>
    <ClCompile Include="Mapper\Kdmapper\kdmapper.cpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClCompile>
    <ClCompile Include="Mapper\Kdmapper\portable_executable.cpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClCompile>
    <ClCompile Include="Mapper\Kdmapper\service.cpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClCompile>
    <ClCompile Include="Mapper\Kdmapper\utils.cpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClCompile>
    <ClCompile Include="imguipp.cpp">
      <Filter>ImGui\custom</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{2b53feae-fdd5-4bdd-81ee-56c31543d513}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Driver">
      <UniqueIdentifier>{faf091c5-0258-4872-9cf7-554d3efe896c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Game">
      <UniqueIdentifier>{a0faba54-debc-4e90-8549-96042002ed75}</UniqueIdentifier>
    </Filter>
    <Filter Include="ImGui">
      <UniqueIdentifier>{8d7be149-07cf-43f8-9cdc-6bfd1738a84f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\decryption">
      <UniqueIdentifier>{db710f93-f240-4697-be83-4d117dbe76d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Game\other">
      <UniqueIdentifier>{d19a6bb7-4987-4a8c-95d3-bd8b6e55f86d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Driver\Mapper">
      <UniqueIdentifier>{f02c0e5d-f319-4597-9974-e9a661886781}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Driver\Mapper\Kdmapper">
      <UniqueIdentifier>{e9786998-e8f0-4a9c-81f0-eb938c8fd617}</UniqueIdentifier>
    </Filter>
    <Filter Include="ImGui\custom">
      <UniqueIdentifier>{bab9e03c-defc-47be-b269-84fe977da0d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Game\other\obsidium">
      <UniqueIdentifier>{0a3efc42-104f-4194-8bea-f875e1726c00}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Game\other\anti">
      <UniqueIdentifier>{9042ad8a-662e-4cb0-9fea-f6ddfbd65fb2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Game\other\anti\auth">
      <UniqueIdentifier>{d802c2e2-f3bf-4faf-969b-831b8c594bd2}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="render\imconfig.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imgui.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imgui_impl_dx9.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imgui_impl_win32.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imgui_internal.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imstb_rectpack.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imstb_textedit.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="render\imstb_truetype.h">
      <Filter>ImGui</Filter>
    </ClInclude>
    <ClInclude Include="blow.h">
      <Filter>Header Files\decryption</Filter>
    </ClInclude>
    <ClInclude Include="check.h">
      <Filter>Header Files\Driver</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files\Driver</Filter>
    </ClInclude>
    <ClInclude Include="ss.h">
      <Filter>Header Files\Driver</Filter>
    </ClInclude>
    <ClInclude Include="cheat.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="xor.h">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="globals.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="vectors.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="menu.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="renderer.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="skcrypt.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="print.hpp">
      <Filter>Header Files\Game</Filter>
    </ClInclude>
    <ClInclude Include="KeyAuth\auth.hpp">
      <Filter>Header Files\Game\other\anti\auth</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\intel_driver.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\intel_driver_resource.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\kdmapper.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\nt.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\portable_executable.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\service.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="Mapper\Kdmapper\utils.hpp">
      <Filter>Header Files\Driver\Mapper\Kdmapper</Filter>
    </ClInclude>
    <ClInclude Include="imguipp.h">
      <Filter>ImGui\custom</Filter>
    </ClInclude>
    <ClInclude Include="obsidium64.h">
      <Filter>Header Files\Game\other\obsidium</Filter>
    </ClInclude>
    <ClInclude Include="anti.hpp">
      <Filter>Header Files\Game\other\anti</Filter>
    </ClInclude>
    <ClInclude Include="lazy.hpp">
      <Filter>Header Files\Game\other\anti</Filter>
    </ClInclude>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="KeyAuth\libcurl.lib">
      <Filter>Header Files\Game\other\anti\auth</Filter>
    </Library>
    <Library Include="KeyAuth\library_x64.lib">
      <Filter>Header Files\Game\other\anti\auth</Filter>
    </Library>
    <Library Include="obsidium64.lib">
      <Filter>Header Files\Game\other\obsidium</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`VALORANT.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Valorant.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32616.157
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Valorant", "VALORANT.vcxproj", "{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Debug|x64.ActiveCfg = Debug|x64
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Debug|x64.Build.0 = Debug|x64
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Debug|x86.ActiveCfg = Debug|Win32
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Debug|x86.Build.0 = Debug|Win32
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Release|x64.ActiveCfg = Release|x64
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Release|x64.Build.0 = Release|x64
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Release|x86.ActiveCfg = Release|Win32
		{403CCF71-C4D3-4B5F-ABB1-2B3C2CCC8C45}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A5136B2D-81F5-4FC8-AD91-8D37E4BB0F4E}
	EndGlobalSection
EndGlobal

```

`anti.hpp`:

```hpp
#include "globals.hpp"
#include "lazy.hpp"
#include <tlhelp32.h>

#include <iostream>
#include <tlhelp32.h>
#include <fstream>
#include <filesystem>

//self modifying shit
#include <random>
#include <ctime>
#include <thread>
#include <tchar.h>

typedef NTSTATUS(NTAPI* pdef_NtRaiseHardError)(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask OPTIONAL, PULONG_PTR Parameters, ULONG ResponseOption, PULONG Response);
typedef NTSTATUS(NTAPI* pdef_RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);

void BSOD() {
	/*
	BOOLEAN bEnabled;
	ULONG uResp;
	LPVOID lpFuncAddress = GetProcAddress(LoadLibraryA(skCrypt("ntdll.dll")), skCrypt("RtlAdjustPrivilege"));
	LPVOID lpFuncAddress2 = GetProcAddress(GetModuleHandleA(skCrypt("ntdll.dll")), skCrypt("NtRaiseHardError"));
	pdef_RtlAdjustPrivilege NtCall = (pdef_RtlAdjustPrivilege)lpFuncAddress;
	pdef_NtRaiseHardError NtCall2 = (pdef_NtRaiseHardError)lpFuncAddress2;
	NTSTATUS NtRet = NtCall(19, TRUE, FALSE, &bEnabled);
	NtCall2(STATUS_FLOAT_MULTIPLE_FAULTS, 0, 0, 0, 6, &uResp);

	*((unsigned int*)0) = 0xDEAD;
	*/
}

void driverdetect() {
	const TCHAR* devices[] = {
_T("\\\\.\\NiGgEr"),
_T("\\\\.\\KsDumper")
	};

	WORD iLength = sizeof(devices) / sizeof(devices[0]);
	for (int i = 0; i < iLength; i++)
	{
		HANDLE hFile = CreateFile(devices[i], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		TCHAR msg[256] = _T("");
		if (hFile != INVALID_HANDLE_VALUE) {
			BSOD();
			*((unsigned int*)0) = 0xDEAD;
		}
	}
}

bool HasRemoteDebugger() {
	BOOL remotelyDebugged = FALSE;
	LI_FN(CheckRemoteDebuggerPresent).safe_cached()(LI_FN(GetCurrentProcess).safe_cached()(), &remotelyDebugged);
	return remotelyDebugged;
}
```

`antidebug.hpp`:

```hpp
#include "globals.hpp"
#include "lazy.hpp"
#include <tlhelp32.h>

#include <iostream>
#include <tlhelp32.h>
#include <fstream>
#include <filesystem>

//self modifying shit
#include <random>
#include <ctime>
#include <thread>
#include <tchar.h>

//shittiest anti-debug known to man and mankind - synz
typedef NTSTATUS(NTAPI* pdef_NtRaiseHardError)(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask OPTIONAL, PULONG_PTR Parameters, ULONG ResponseOption, PULONG Response);
typedef NTSTATUS(NTAPI* pdef_RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);

extern "C" void BsodCPP()
{
	BOOLEAN bEnabled;
	ULONG uResp;
	LPVOID lpFuncAddress = GetProcAddress(LoadLibraryA(skCrypt("ntdll.dll")), skCrypt("RtlAdjustPrivilege"));
	LPVOID lpFuncAddress2 = GetProcAddress(GetModuleHandleA(skCrypt("ntdll.dll")), skCrypt("NtRaiseHardError"));
	pdef_RtlAdjustPrivilege NtCall = (pdef_RtlAdjustPrivilege)lpFuncAddress;
	pdef_NtRaiseHardError NtCall2 = (pdef_NtRaiseHardError)lpFuncAddress2;
	NTSTATUS NtRet = NtCall(19, TRUE, FALSE, &bEnabled);
	NtCall2(STATUS_FLOAT_MULTIPLE_FAULTS, 0, 0, 0, 6, &uResp);

	*((unsigned int*)0) = 0xDEAD;
}

void DeadScreen()
{
	BOOLEAN bEnabled;
	ULONG uResp;
	LPVOID lpFuncAddress = GetProcAddress(LoadLibraryA(skCrypt("ntdll.dll")), skCrypt("RtlAdjustPrivilege"));
	LPVOID lpFuncAddress2 = GetProcAddress(GetModuleHandleA(skCrypt("ntdll.dll")), skCrypt("NtRaiseHardError"));
	pdef_RtlAdjustPrivilege NtCall = (pdef_RtlAdjustPrivilege)lpFuncAddress;
	pdef_NtRaiseHardError NtCall2 = (pdef_NtRaiseHardError)lpFuncAddress2;
	NTSTATUS NtRet = NtCall(19, TRUE, FALSE, &bEnabled);
	NtCall2(STATUS_FLOAT_MULTIPLE_FAULTS, 0, 0, 0, 6, &uResp);

	*((unsigned int*)0) = 0xDEAD;
}

void driverdetect()
{
	const TCHAR* devices[] = {
_T("\\\\.\\NiGgEr"),
_T("\\\\.\\KsDumper")
	};

	WORD iLength = sizeof(devices) / sizeof(devices[0]);
	for (int i = 0; i < iLength; i++)
	{
		HANDLE hFile = CreateFile(devices[i], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		TCHAR msg[256] = _T("");
		if (hFile != INVALID_HANDLE_VALUE) {
			DeadScreen();
			*((unsigned int*)0) = 0xDEAD;
		}
	}
}

inline bool HasRemoteDebugger() {
	BOOL remotelyDebugged = FALSE;
	LI_FN(CheckRemoteDebuggerPresent).safe_cached()(LI_FN(GetCurrentProcess).safe_cached()(), &remotelyDebugged);
	return remotelyDebugged;
}
```

`blow.cpp`:

```cpp
#include "blow.h"

BLOWFISH::BLOWFISH(std::string hexKey)
{
	IvSet = false;
	if (hexKey.length() % 2 != 0)
		throw 2;

	bytee* key = new bytee[hexKey.length() / 2];//

	for (int i = 0; i < hexKey.length() / 2; i++)
	{
		key[i] = hex2dec(hexKey[i * 2]) * 16 + hex2dec(hexKey[i * 2 + 1]);
	}

	SetupKey(key, hexKey.length() / 2);
}

int BLOWFISH::hex2dec(char hex)
{
	if ('a' <= hex && hex <= 'f')
		return 10 + (hex - 'a');
	if ('A' <= hex && hex <= 'F')
		return 10 + (hex - 'A');
	return hex - '0';
}

BLOWFISH::BLOWFISH(bytee* cipherKey, int keyLength)
{
	IvSet = false;
	SetupKey(cipherKey, keyLength);
}

bytee* BLOWFISH::Encrypt_ECB(bytee* data, int length, int* newlength)
{
	return Crypt_ECB(data, length, newlength, &BLOWFISH::Encrypt_Block, false);
}

bytee* BLOWFISH::Decrypt_ECB(bytee* data, int length, int* newlength)
{
	return Crypt_ECB(data, length, newlength, &BLOWFISH::Decrypt_Block, true);
}

bytee* BLOWFISH::Encrypt_CBC(bytee* data, int length, int* newlength)
{
	return Crypt_CBC(data, length, newlength, &BLOWFISH::Encrypt_Block, false);
}

bytee* BLOWFISH::Decrypt_CBC(bytee* data, int length, int* newlength)
{
	return Crypt_CBC(data, length, newlength, &BLOWFISH::Decrypt_Block, true);
}

std::string BLOWFISH::Encrypt_CBC(std::string data)
{
	bytee* binaryData = new bytee[data.length()];
	for (int i = 0; i < data.length(); i++)
		binaryData[i] = data[i];
	int newlen = 0;
	bytee* result = Encrypt_CBC(binaryData, data.length(), &newlen);
	std::string encoded = "";
	for (int i = 0; i < newlen; i++)
		encoded += byteToHex(result[i]);
	delete[] result;
	delete[] binaryData;
	return encoded;
}

std::string BLOWFISH::Decrypt_CBC(std::string data)
{
	if (data.length() % 2 != 0)
		throw 2;

	bytee* binaryData = new bytee[data.length() / 2];//

	for (int i = 0; i < data.length() / 2; i++)
	{
		binaryData[i] = hex2dec(data[i * 2]) * 16 + hex2dec(data[i * 2 + 1]);
	}
	int len = 0;
	bytee* cryptresult = Decrypt_CBC(binaryData, data.length() / 2, &len);
	std::string result = "";
	for (int i = 0; i < len; i++)
		result += cryptresult[i];
	delete[] cryptresult;
	return result;
}

std::string BLOWFISH::byteToHex(unsigned char x)
{
	char hex[17] = "0123456789ABCDEF";
	std::string result = "";
	result += hex[x / 16];
	result += hex[x % 16];
	return result;
}

bytee* BLOWFISH::padData(bytee* data, int length, int* paddedLength, bool decrypt, bool IvSpace = false)
{
	int offset = 0;
	int dataoffset = 0;
	if (decrypt)
	{
		if (length % 8 != 0) throw 8;
		*paddedLength = length;
	}
	else
	{
		//if IvSpace, leave a blank block at the front
		*paddedLength = 8 + (length % 8 == 0 ? length : length + 8 - (length % 8)) + (IvSpace ? 8 : 0); //pad the data to a multiple of 8 plus one block
		if (IvSpace)
			offset = 8;
	}

	//fill the new array with the data
	bytee* pData = new bytee[*paddedLength];
	for (int i = 0; i < length; i++)
		pData[offset + i] = data[i + dataoffset];

	//add the padding character to the end
	for (int i = length + offset; i < *paddedLength; i++)
		pData[i] = (pData[length - 1 + offset] ^ 0xCC); //fill the padding with a character that is different from the last character in the plaintext, so we can CheatCache the end later

	return pData;
}

int BLOWFISH::findPaddingEnd(bytee* data, int length)
{
	int i = length;
	while (data[i - 1] == data[length - 1]) //CheatCache the first character from the back that isnt the same as the last character
	{
		i--;
	}
	return i; //retun the length without the padding
}

bytee* BLOWFISH::Crypt_ECB(bytee* data, int length, int* newlength, void (BLOWFISH::* CryptBlock)(bytee*, int), bool decrypt)
{
	bytee* pData;
	pData = padData(data, length, newlength, decrypt); //this loads the IV from the front of the ciphertext

	for (int i = 0; i < *newlength; i += 8) //run the encryption
	{
		(this->*CryptBlock)(pData, i);
	}

	if (decrypt) //if we are decrypting, we have to CheatCache where the data ends.
	{
		*newlength = findPaddingEnd(pData, *newlength);
	}
	return pData;
}

bytee* BLOWFISH::Crypt_CBC(bytee* data, int length, int* newlength, void (BLOWFISH::* CryptBlock)(bytee*, int), bool decrypt)
{
	bytee* pData;
	if (!decrypt && !IvSet)
		SetRandomIV();
	IvSet = false; // don't re-use an IV
	pData = padData(data, length, newlength, decrypt, true);

	if (!decrypt)
	{
		//padData leaves an 8 bytee block at the beggining so we can save the IV
		for (int i = 0; i < 8; i++)
			pData[i] = IV[i];
	}
	else
	{
		for (int i = 0; i < 8; i++)
			IV[i] = pData[i];
	}
	bytee nextIV[8];
	for (int i = 8; i < *newlength; i += 8) //run the encryption
	{
		if (!decrypt)
		{
			for (int k = 0; k < 8; k++)
				pData[k + i] ^= pData[k + i - 8]; //the previous block contains the initialization vector
		}
		else
		{
			for (int k = 0; k < 8; k++)
				nextIV[k] = pData[k + i];
		}
		(this->*CryptBlock)(pData, i);

		if (decrypt)
		{
			for (int k = 0; k < 8; k++)
			{
				pData[i + k] ^= IV[k];
				IV[k] = nextIV[k];
			}
		}
	}

	if (decrypt) //if we are decrypting, we have to CheatCache where the data ends, and remove the IV
	{
		*newlength = findPaddingEnd(pData, *newlength) - 8;
		bytee* noIV = new bytee[*newlength];
		for (int i = 0; i < *newlength; i++)
			noIV[i] = pData[i + 8];
		delete[] pData;
		pData = noIV;
	}
	return pData;
}

void BLOWFISH::SetRandomIV()
{
#ifdef _WIN32
	//WIN32 CSPRNG thanks to: http://www.tomhandal.com/DevBlog/2010/03/17/cryptographically-random-bytees-in-microsoft-windows/
	HCRYPTPROV hCryptCtx = NULL;
	CryptAcquireContext(&hCryptCtx, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
	CryptGenRandom(hCryptCtx, 8, IV);
	CryptReleaseContext(hCryptCtx, 0);
#else
	std::ifstream devRand("/dev/urandom", std::ios::in | std::ios::binary);
	if (!devRand.read((char*)&IV, 8))
	{
		throw 1;
	}
#endif
	IvSet = true;
}

void BLOWFISH::SetIV(bytee* newIV)
{
	IvSet = true;
	for (int i = 0; i < 8; i++)
		IV[i] = newIV[i];
}

bytee* BLOWFISH::GetIV()
{
	bytee* returnIV = new bytee[8];
	for (int i = 0; i < 8; i++)
		returnIV[i] = IV[i];
	return returnIV;
}

void BLOWFISH::Encrypt_Block(bytee* block, int offset)
{
	setblock(block, offset);
	encipher();
	getblock(block, offset);
}

void BLOWFISH::Decrypt_Block(bytee* block, int offset)
{
	setblock(block, offset);
	decipher();
	getblock(block, offset);
}

void BLOWFISH::setblock(bytee* block, int offset)
{
	//TODO: CHECK ENDIANNESS
	xr_par = 0; xl_par = 0;
	for (int i = 0; i < 4; i++)
	{
		xl_par = (xl_par << 8) + block[offset + i];
		xr_par = (xr_par << 8) + block[4 + offset + i];
	}
}

void BLOWFISH::getblock(bytee* block, int offset)
{
	//TODO: CHECK ENDIANNESS
	unsigned int xl = xl_par;
	unsigned int xr = xr_par;
	for (int i = 3; i >= 0; i--)
	{
		block[i + offset] = xl % 256;
		block[i + 4 + offset] = xr % 256;
		xr = xr >> 8;
		xl = xl >> 8;
	}
}

void BLOWFISH::SetupKey(bytee* cipherKey, int length)
{
	if (length > 56)
	{
		throw 56;
	}

	bytee* key = new bytee[length]; //

	for (int i = 0; i < length; i++)
		key[i] = cipherKey[i];

	int j = 0;
	unsigned int d;
	for (int i = 0; i < 18; i++)
	{
		d = (((key[j % length] * 256 + key[(j + 1) % length]) * 256 + key[(j + 2) % length]) * 256 + key[(j + 3) % length]);
		p[i] ^= d;
		j = (j + 4) % length;
	}

	xl_par = 0;
	xr_par = 0;

	for (int i = 0; i < 18; i += 2)
	{
		encipher();
		p[i] = xl_par;
		p[i + 1] = xr_par;
	}

	for (int i = 0; i < 256; i += 2)
	{
		encipher();
		s0[i] = xl_par;
		s0[i + 1] = xr_par;
	}

	for (int i = 0; i < 256; i += 2)
	{
		encipher();
		s1[i] = xl_par;
		s1[i + 1] = xr_par;
	}

	for (int i = 0; i < 256; i += 2)
	{
		encipher();
		s2[i] = xl_par;
		s2[i + 1] = xr_par;
	}

	for (int i = 0; i < 256; i += 2)
	{
		encipher();
		s3[i] = xl_par;
		s3[i + 1] = xr_par;
	}

}

void BLOWFISH::encipher()
{
	xl_par ^= p[0];
	for (int i = 0; i < ROUNDS; i += 2)
	{
		xr_par = round(xr_par, xl_par, i + 1);
		xl_par = round(xl_par, xr_par, i + 2);
	}
	xr_par ^= p[ROUNDS + 1];

	unsigned int swap = xl_par;
	xl_par = xr_par;
	xr_par = swap;
}

void BLOWFISH::decipher()
{
	xl_par ^= p[ROUNDS + 1];
	for (int i = ROUNDS; i > 0; i -= 2)
	{
		xr_par = round(xr_par, xl_par, i);
		xl_par = round(xl_par, xr_par, i - 1);
	}
	xr_par ^= p[0];

	unsigned int swap = xl_par;
	xl_par = xr_par;
	xr_par = swap;
}

unsigned int BLOWFISH::round(unsigned int a, unsigned int b, unsigned int n)
{
	//TODO: CHECK ENDIANNESS
	unsigned int x1 = (s0[(b >> 24) % 256] + s1[(b >> 16) % 256]) ^ s2[(b >> 8) % 256];
	unsigned int x2 = x1 + s3[b % 256];
	unsigned int x3 = x2 ^ p[n];
	return x3 ^ a;
}

unsigned int BLOWFISH::s0[] = {
				0xd1310ba6,0x98dfb5fd,0x211d72db,0xd01adfb8,0xb8e1afed,0x6a267e96,
				0xba7c9046,0xf12c7f91,0x24a19948,0xa7916cf8,0x18014fe2,0x958eb416,
				0x636920d8,0x91574e61,0xb458fea4,0xe3933d7e,0x1d95748f,0x928eb658,
				0x918bc5f8,0x92154aee,0x9b54a41d,0xd25a59b6,0x9c305f31,0x2a4f6014,
				0x5fd1b024,0x286085f0,0xda417918,0xb8da78ef,0x9e79dcb0,0x603a180e,
				0x6c9e0e8b,0xb01e8a3e,0xd71577c2,0xbd314b28,0x98a4ffda,0x65605c60,
				0xf65525e3,0xba55bc94,0x67489862,0x63e81440,0x65ca396a,0x2bbb10b6,
				0xb4cc5c34,0x2141e8ce,0xb15486af,0x9c72e994,0xa7ee1412,0x636fbc2a,
				0x2ba9c55d,0x941831f6,0xde5c3e16,0x9b87931e,0xbfd6ba34,0x6c24cf5c,
				0x9a325382,0x28958678,0x4b8e3898,0x6b4cc9af,0xd4bfe81b,0x66282194,
				0x61d809cc,0xfb21a992,0x487cfd60,0x6dec8032,0x118455fd,0xf98575b2,
				0xdc262302,0xfb651b88,0x23893e82,0xd396fdc6,0x1f6d6114,0x93e34231,
				0x2e0b4482,0xb4842004,0x69c8f04a,0x9e1f9b5e,0x21c66842,0xf6e96c9a,
				0x670c9c62,0xccd388f0,0x6a51a0d2,0xd8542f68,0x960fa728,0xcc5133a4,
				0x6eef0b6c,0x237a3be4,0xba3bf050,0x9efb2a98,0xb1f1651d,0x49af0176,
				0x66ca593e,0x92430e88,0x9cee8611,0x456f9fb4,0x9d84a5c4,0x4b8b5ebe,
				0xf06f75d8,0x95c12074,0x401a449f,0x66c16bb6,0x4ed3bb62,0x463f7706,
				0x2bfedf72,0x429b023d,0x47d0d724,0xd00a1248,0xdb0fead4,0x49f1c09b,
				0x175372c1,0x90991b7b,0x25d479d8,0xf6e8def8,0xf3fe501a,0xb6794c3b,
				0x976ce0bd,0x14c006ba,0xd1a94fb6,0x409f60c4,0x6e5c9ec2,0x296a2464,
				0x68fb6faf,0x4e6c53b6,0x2339b2eb,0x4b52ec6f,0x6db4511f,0x9a70952c,
				0xdc814544,0xbf5ebd01,0xbee3d004,0xde334afd,0x6604f808,0x292e4cc4,
				0xd0cba858,0x45c8740f,0xd20b5f31,0xb9d3fbdb,0x6579c0bd,0x2a60320a,
				0xd6a100c6,0x402c7271,0x6794f5fe,0xfb1fa3cc,0x9ea5e9f8,0xda7222f8,
				0x4c7516df,0xfd616b16,0x2f501ec8,0xbd0552bc,0x423db5fa,0xfd238760,
				0x63317b48,0x4e00df82,0x9e5c57cc,0xda6f8ca0,0x2a87562e,0xdf1769db,
				0x5f42a8f6,0x287e11c4,0xbc6732c6,0x9c4f5574,0x695b27b0,0xccca58c8,
				0xf111a35d,0xb8f011a0,0x20fa3d98,0xfd2183b8,0x4ab4b56c,0x2ee1d35b,
				0x9a53e471,0xb6f84566,0xd28e49bc,0x4bfb9790,0xf1ee4fda,0xb4cb7e34,
				0x62fb1342,0xdee4c6e8,0x1120cada,0x46774c02,0xd07e9efe,0x2bf11fb4,
				0x95dbda4d,0xbe909198,0xfbbd8e72,0x6b935fa0,0xd08ed1d0,0xbb4725e0,
				0x9e3c5b2f,0x9e7594b8,0x9116e2fb,0x4f122b64,0x9888b812,0x900df01c,
				0x4fa5fea0,0x688b431c,0xd1c11192,0xa7a8c1ad,0x24f4f218,0xbe0e1778,
				0xfa752dfe,0x9b021fa2,0xf5a0cc0f,0xb56f74e8,0x28fdf3d6,0xde89e291,
				0xb4a84fe0,0xfd13e0b8,0x9cc43b82,0xd2ada8d1,0x265fa266,0x90957706,
				0x93cc7314,0x211a1478,0xf6ad2066,0x97b5fa86,0xd75442f6,0xfb9d35cf,
				0xfbcdaf0c,0x9a7e89a0,0xd6411bd4,0xbe1e7e41,0x10250e2d,0x2071a75e,
				0x226800cc,0x67b8e0af,0x2464369b,0xf009b91e,0x6563911d,0x69dfa6bb,
				0x98c14381,0xd95a537f,0x2075fba2,0x12e5b9c6,0x93260376,0x6295cfa1,
				0x21c81968,0x4e734a42,0xa7472dca,0x9b14a94a,0x2b510052,0x9a532916,
				0xd60f573f,0xbc9bc6e4,0x2b60a476,0x91e67400,0x18ba6fb6,0x671be91f,
				0x4f96ec6b,0x2a0ee916,0xb6636522,0xf7b9f9b6,0x1134052e,0x5f855664,
				0x63b025fd,0xb99f8fa2,0x18ba4791,0x6e85076a };

unsigned int BLOWFISH::s1[] = {
				0x4b7a70e1,0xb5a72944,0xdb75092e,0xd4192624,0xbd6ea6b0,0x49a7df7d,
				0x9cee60b8,0x9fedb266,0xb4bb8c72,0x699a1711,0x6664526c,0xd2b19ee2,
				0x293602a6,0x95094c21,0xb0591340,0xe3183a3e,0x4f54989a,0x6b429d66,
				0x6b8fe4d6,0x99f73fd6,0xb1d29c08,0x11e830f6,0x4d2d38e6,0xf0255dc2,
				0x4cee2086,0x9470eb26,0x6382e9c6,0x121ecc5e,0x19686a7f,0x4ebaeb41,
				0x4c971814,0x6b6a70a2,0x687f3584,0x62a0e286,0xb79c5306,0xba500738,
				0x4e07841c,0x9fdeae5c,0x9e7d44ec,0x67164fb8,0xb03ada38,0xf0500c0d,
				0xf01c1f04,0x1200a711,0xbe0cf51a,0x4cb574b2,0x25837a58,0xdc0921bd,
				0xd19113f1,0x9ca92116,0x94324774,0x22f54702,0x4ae5e582,0x47c2dadc,
				0xd8b57634,0x9af3eea8,0xb9446146,0x1fd0030e,0xb4c8c73e,0xb4751e42,
				0x4f38cd91,0x4bea0e2f,0x4280cca2,0x283ea732,0x4e548a78,0x4f6db908,
				0x6e320d04,0xf60a04bf,0x2cb81290,0x24977c71,0x6679b072,0xbcaf89af,
				0xde9a771f,0xd9930810,0xa78bae12,0xdccf34fe,0x6512721f,0x2e6b7124,
				0x601aeee6,0x9f84cd88,0x9a584718,0x9408da18,0xbc9f9bcc,0xf94b7d8c,
				0xb47aec3a,0xdb851dfa,0x63094366,0xd464c3d2,0x111c1848,0x4215d908,
				0xee433a78,0x24c2ba16,0x22a14d44,0x2a65c452,0x60940002,0x233ae4ee,
				0x91d1189e,0x20314e56,0x91fd77d6,0x6f11199b,0x1435564f,0xd7a3c76b,
				0x4c11183b,0x6924a501,0x4f8fe6ed,0x97f1fbfa,0x9ebbc4fc,0x2e153c6e,
				0x96e34570,0xfae96fb2,0x960e5e0a,0x6a3e2bc4,0x971fe71c,0x4e3d06fa,
				0x2965dcb1,0x99e71d0f,0x903e89d6,0x6266c826,0x2e4cc978,0x9c10a76a,
				0xd6150eba,0x94e2ea78,0xb5b43c54,0x2e0a2de3,0x4ff74ea8,0x461d2a7d,
				0x2939260f,0x29c27960,0x6223a708,0xf71312b6,0xfbadfe6e,0xffd31f66,
				0xf3bc4596,0xb67bc884,0xb17f37d2,0x118c1128,0xd332eeef,0xbe6c5bb6,
				0x65582186,0x68bc9802,0xfecea50f,0xdb2f953b,0x2aef7dad,0x6b6e2f84,
				0x2521b628,0x29076170,0xb4ee4776,0x619f1510,0x23cca830,0xfb61bd96,
				0x1334fe1e,0xba0363cf,0xb5735c90,0x4c70a231,0x5f9e9e0b,0xdbbbde14,
				0xfecc86bc,0x60622ca8,0x9cbc5cbc,0xb2f3846e,0x648b1eaf,0x29bdf0ca,
				0xb02369b1,0x655fdc50,0x40685a32,0x4c2bc4b4,0x419ee9d6,0xd021b8f8,
				0x9b540b11,0x975fa091,0x95f7997e,0x623d7da8,0xf837889a,0x97e32d78,
				0x21ed935f,0x26681282,0x1e358821,0xd7e61fd6,0x96dedfa2,0x9858ba91,
				0x67f584a6,0x2b227264,0x9b83c311,0x2fd24696,0xeea70aeb,0x632e3054,
				0x9fd948e4,0x6dbc3128,0x68eb4fef,0x44c611ea,0xfe28ed62,0xfe7c3c74,
				0x6d4a14d1,0xf864b7e4,0x42105d14,0x203e13e0,0x45eee2b6,0xa7bbbcea,
				0xdb6c4f16,0xffdb4fd0,0xd742e342,0x116fdcb6,0x654f3b1d,0x41cd2106,
				0xd81e799e,0x96854dc8,0xe34b476a,0x4d816250,0xdf62a14f,0x6b8d2646,
				0xb48883a0,0xd1c7b6a4,0x9f1524c4,0x69cb7492,0x47848a0b,0x6692b286,
				0x195ccf00,0xbd19489d,0x2462b174,0x23820e00,0x68428d2a,0x1c55f5ea,
				0x2dade33e,0x233f7062,0x4372f092,0x9d937e42,0xd65fec4f,0x6c223bdb,
				0x9cde3751,0xdbee7460,0x40854fa8,0xde77326e,0xb6078084,0x29f8509e,
				0xf8efd856,0x61d99736,0xb969a7bb,0x5f0c06c2,0x6a04bcb4,0x900bcadc,
				0x9e447a2e,0xd3453484,0xfee56706,0x1e1e9ec1,0xdb73dbd4,0x205588cd,
				0x675fda71,0xf3674340,0x5fc43466,0x913e38d8,0x4d28f89e,0xf16d1120,
				0x253e21e8,0x9fb03d4a,0xf6e394fb,0xdb83adf7 };

unsigned int BLOWFISH::s2[] = {
				0xf935fa68,0x948140f8,0xf64c261c,0x94692934,0x411520f8,0x9602d4f8,
				0xbce36b2e,0xd4a20068,0xd4082472,0x4320e36a,0x43b7d4b8,0x600061af,
				0x2e39f62e,0x97244546,0x24214f74,0xbf8b8840,0x4d95b41d,0x96b591af,
				0x90e3eed4,0x66a02e36,0xbfbc09ec,0x13bd9786,0x9ffd6ee0,0x41cb8504,
				0x96eb27b4,0x65fd3942,0xda2547e6,0xccca0a9a,0x28507826,0x630429e3,
				0x1a2c86da,0xf9b66dfb,0x68dc1462,0xd7486900,0x680ec0a4,0x27a18dee,
				0x4f311ea2,0xf887ad8c,0xb58ce006,0x9ae3d6b6,0xbfde1e7c,0xd3375fec,
				0xde78a391,0x406b2a42,0x20fe9e36,0xd9f385b1,0xfe39d7bc,0x4b124e8b,
				0x2dc9faf8,0x4b6d1856,0x26a36632,0xfae397b2,0x4a6efa74,0xee5b4332,
				0x6841e7f8,0xda7820fb,0xfb0af54e,0xd8fea798,0x454056fd,0xba489528,
				0x65533a3a,0x20838d88,0xfe6ba9b8,0xd096954b,0x65a867bc,0xb1159a58,
				0xdca92964,0x99e1da74,0xb62a4a56,0x4f3125f1,0x6ee37e1c,0x9029317c,
				0xfdf8e802,0x14272f70,0x90cc155c,0x15282ce4,0x95c11548,0xe3c66d22,
				0x48c1133f,0xd70f86dc,0x17f9c9ee,0x41041f0f,0x404779a4,0x6d886e18,
				0x425f51eb,0x5f9bc0d2,0x4fbcc18f,0x41113564,0x257b7834,0x602a9c60,
				0xd118e8a4,0x2f636c1b,0x1e12b4c2,0x12e1329e,0xbf664fd2,0xdad18116,
				0x6b2395e0,0x433e92e2,0x4b240b62,0xfebeb922,0x95b2a20e,0xf6ba0d91,
				0xde720c8c,0x2da2f728,0xd0127846,0x95b794fd,0x647d0862,0xf7ccf5f0,
				0x6449a36f,0x977d48fa,0xd39dfd28,0xf33e8d1e,0x1a476342,0x992e1174,
				0x4a6f6ebc,0xe3f8fd38,0xb812dc60,0xb1ebeef8,0x991be14c,0xdb6e6b0d,
				0xd67b5510,0x6d672c38,0x2765d43b,0xdcd0e804,0xf1290dc8,0xdc0011a4,
				0xb5390f92,0x690fed0b,0x667b911b,0xdedb7d9c,0xb091cf0b,0xd9155ea4,
				0xcc132f88,0x615bad24,0x9b9479bf,0x963bd6eb,0x47392eb4,0xdc115971,
				0x9026e298,0xe32e312d,0x6842ada8,0xd66a2a7b,0x22754ccc,0x982ef11c,
				0x6a124238,0xb79251e8,0x16a1cce6,0x4bfb6350,0x2a6b1018,0x21caedfa,
				0x4d25bee8,0x4fe1c3c1,0x44421651,0x1a121386,0xd90cec6e,0x5fbcea2a,
				0x64af674e,0xda86a85f,0xbebfe988,0x64e4c3fe,0x9dbc8058,0xf0f7c086,
				0x60787bf8,0x6003604d,0xd1fd8346,0xf6381fb0,0x9745ae04,0xd736b4cc,
				0x93426a74,0xf01ebc72,0xb0804188,0x4c005e5f,0x97a057be,0xbde8ae24,
				0x65464291,0xbf582e62,0x4e58e38f,0x4feefda2,0xe374ef38,0x9789bdc2,
				0x6366f9c4,0xd8a78e74,0xb4754f56,0x46b4d9b1,0x9aeb2662,0x9b1eef84,
				0x946a0e71,0x915f95e2,0x466e598e,0x20b45770,0x9c5f5592,0xd902de4c,
				0xb90bfde2,0xcc8205d0,0x21a86248,0x9574a99e,0xb77f19b6,0xf0a9dc01,
				0x662d09a2,0xd4324634,0xf85a1f02,0x19f0be8c,0x4a99a026,0x2d6efe10,
				0x2bc93d1d,0x1ba5a4df,0xb1864f0f,0x2868f161,0xdcb7da84,0x673906fe,
				0xb1e2ce9b,0x4b4d7f52,0x60115e02,0xb70683fa,0xb002b5c4,0x1de6d028,
				0x9af88c28,0x973f8642,0xd3604c06,0x61a806b6,0xf0177a28,0xd0f586e0,
				0x106058bb,0x40dc7d62,0x21e69ed8,0x2338ea64,0x63c2ee94,0xd2c21634,
				0xcccbee56,0x90bcb6de,0xfbb47da2,0xde591d76,0x6f05e401,0x4b7c0188,
				0x49720a3d,0x9c927c24,0x96e3725f,0x924d9db1,0x2fd15cc4,0xd39eb8b4,
				0xf5f45578,0x18b4a5b6,0xd83d7cd4,0x4dad0b44,0x2e50ef5e,0xb161e6f8,
				0xb28514d1,0x6c51133c,0x6f5fc7e8,0x66e14ec4,0x462bcb4e,0xeec6c838,
				0xd79a3234,0x92638212,0x670efa8e,0x406000e0 };

unsigned int BLOWFISH::s3[] = {
				0x4a39ce38,0xd3faf5cf,0xccc27738,0x6f5f2d1b,0x6cb0679e,0x4fa33742,
				0xd3822740,0x99bc9cce,0x5f118e9d,0xbf0f7316,0xd62d1c7e,0xd700c47b,
				0xb78c1b6b,0x21a19046,0xb26eb1be,0x6a366eb4,0x6748bc2f,0xbc946e71,
				0xd6a376d2,0x6549c2c8,0x630118ee,0x468eee7d,0x5f730a1d,0x4cd04dc6,
				0x2939ccdb,0xb9ba4650,0xbc9526e8,0xbe5ee304,0xb1fa5ff0,0x6a25f19a,
				0x63ef8ce2,0x9a86ee22,0xd089c2b8,0x43242ef6,0xb51e03bb,0x9c4fd0a4,
				0x93c061ba,0x9be96a4d,0x9fe51550,0xba645bd6,0x2826a2f1,0xb73a3ae2,
				0x4ba99586,0x115562e1,0xd72fefd4,0xf752f7da,0x4f046f61,0x97fa0a51,
				0x90e4a916,0x97b08602,0x9b09e6ad,0x4a7ee594,0xf990f5fa,0x9e34d798,
				0x2cf0b7d1,0x122b8b52,0x965ffd3a,0x117da67d,0xd1cf3ed6,0x9c7d2d28,
				0x2f94f5cf,0xbd4fb89b,0x6ad6b472,0x6a88f54c,0xf029fd72,0xf019a5e6,
				0x47b0fdfd,0xfd93fa9b,0xf8d3c48d,0x283b57cc,0xf85f6621,0x99132e28,
				0x985f0192,0xfd756056,0xf7960e44,0xf3d35e8c,0x25056ee4,0x98e36dba,
				0x13a16126,0x1564f0bd,0xd3eb9e16,0x4c9057a2,0x97271aec,0xb93a072a,
				0x2a7f6d9b,0x2e6321f6,0xf59c66fb,0x26dcf311,0x9533d928,0xb155fdf6,
				0x13563482,0x9bca3ccc,0x28517712,0xd20ad9f8,0xcccc5168,0xdcad925f,
				0x4de81752,0x4830dc8e,0x4795f862,0x9320f992,0xfa7a90c2,0xfa7e7bce,
				0x6121ce64,0x974fbe32,0xb8b6e37e,0xd3293d46,0x48de5361,0x6413e680,
				0xb2ae0810,0xee6db224,0x69852dfd,0x19072166,0xa79a460a,0x6445c0ee,
				0x686cdecf,0x2c20c8ae,0x6ccef7ee,0x2b588d40,0xdcd2017f,0x6cc4e3cc,
				0xeea26a7e,0x4a591146,0x4e350a44,0xbcb4cee6,0x92efdea8,0xfa6484cc,
				0x9d6612ae,0xbf3c6e38,0xd29be464,0x642f5d9e,0xbec2771b,0xf64e6370,
				0x940e0d8d,0xf75b1358,0xf8721672,0xbf5375fd,0x4040cb08,0x4eb4e2cc,
				0x44d2466a,0x1115af84,0xf1b00428,0x95983a1d,0x16b89fb4,0xde6ea048,
				0x6f3f3b82,0x4520bc82,0x111a1d4b,0x277227f8,0x611560b2,0xf7933fdc,
				0xcc3a792b,0x444525bd,0xb08839e2,0x61ce794b,0x2f32c9b8,0xb01fbfd1,
				0xf01cc87e,0xbcc7d1f6,0xdf0111c4,0xb1e8bbc8,0x2a908741,0xd44fbd9a,
				0xd0dadecb,0x5f0ada38,0x1339c32a,0xd6913668,0x9df9317c,0xf0b12b4f,
				0xf79e59b8,0x43f5cc3a,0x4f5f1911,0x27d9459c,0xbf97222c,0x25e6b42a,
				0x1f91b472,0x9b941526,0xfae59362,0xdeb69ceb,0xd2a86451,0x22bbb8d2,
				0xb6c1075e,0xf3056a0c,0x20d25066,0xdb03a442,0xf0ec6e0e,0x2698da7b,
				0x4c98a0be,0x4278e964,0x9f1f9532,0xf0d392df,0xd3a0342b,0x99714f1e,
				0x2b0a7442,0x4ba3348c,0x5fbe7120,0xd37632d8,0xdf359f8d,0x9b9924fe,
				0xf60b6e38,0x1fe3f11d,0xf54cda54,0x2edad892,0xde6279cf,0xee3e7e6f,
				0x2618b166,0xfd2c1d06,0x948fd2c6,0xf6fb2291,0xf523f358,0xb6327624,
				0x93a83532,0x66cccd02,0xbcf08162,0x6a75ecc6,0x6e163698,0x98d273cc,
				0xde966292,0x91b949d0,0x4c50901b,0x91c65614,0xf6c6c7bd,0x427a140a,
				0x45e1d006,0xd34f7b9a,0xd9bb53fd,0x62a80f00,0xcc25bfe2,0x45bee2f6,
				0x91126906,0xb2040222,0xb6cbcf7c,0xee769c2b,0x63113ec0,0x2640e3d4,
				0x48fdcd60,0x2547adf0,0xba38209c,0xf746ce76,0x97afa1c6,0x20756060,
				0x95cbfe4e,0x9ae88ee8,0x9bbaf9b0,0x4cf9bb7e,0x2948c25c,0x12fb8a8c,
				0x11c36ae4,0xd6ebe1f1,0x90d4f861,0xb65cdea0,0x4f09252d,0xd208e69f,
				0xb74e6132,0xde77e25b,0x678fdfe4,0x4fd372e6 };

unsigned int BLOWFISH::p[] = {
				0x243f6a88,0x95a308d4,0x23198a2e,0x13707344,0xb4093822,0x299f31d0,
				0x182efa98,0xb44e6c81,0x452821e6,0x48d01378,0xbe5466cf,0x44e90c6c,
				0xd0fd29b8,0xd97c50ee,0x4f845fb6,0xb5470918,0x92165fd1,0x9979fb1b,

				//240 Aeeitional hex digits of PI for increased rounds versions
				//Starting at ((256 * 4 + 18) * 8)th hex digit of PI
				0xb83fdb02, 0x2002397a, 0x6ec6fb5b, 0x11cfd4ee, 0x4cbf5ed2, 0xe33fe582,
				0x4ee3e824, 0x2d152af0, 0xf718c970, 0x69bd9820, 0x2e3a9d62, 0xf7a529ba,
				0x99e1248d, 0x4bf88656, 0x5f114d0e, 0xbc4cee16, 0x134d8a31, 0x20e47882,
				0xf9ae8fbd, 0xf3bcdc1f, 0x6da51e52, 0x6db2bae2, 0x11f86e7a, 0x6d9c68a1,
				0x2708b4d1, 0x293cbc0c, 0xb03c86f8, 0xb8ad2c2f, 0x10424eeb, 0xdfdb452d,
				0x99cc71b4, 0x5f9c7f92, 0x9f0622bc, 0x6d8a08b2, 0x934d2132, 0x6884ca82,
				0xf3bbcbe3, 0x97864ffa, 0x2cbc6e3d, 0xde535ad2, 0x4f0fd608, 0xd6b8e14f,
				0x6eb4388e, 0x975014a6, 0x656665f8, 0xb64a43e4, 0xba383d02, 0xb2e41071,
				0x9eb2986f, 0x909e0ca4, 0x2f7a7778, 0x2c126030, 0x95088718, 0xd4e7d1bd,
				0x406511ce, 0x9392fd8a, 0xba36d12b, 0xb4c8c9d0, 0x994fb0b8, 0x24f96818,
				0xf9a53998, 0xb0a178c6, 0x2684a81e, 0x9ae972f6, 0xb8425eb6, 0x9a29d486,
				0x651bd711, 0xbf32c181, 0x5f145506, 0xdc815f3e, 0x48424eda, 0xb796ee36,
				0xb0498f04, 0x667deede, 0x13fd0bc4, 0xd497733d, 0x6316a892, 0x40a88b4c,
				0x9604440a, 0xdeeb893a, 0x9725b82b, 0x1e1ef69d, 0x402a5c8e, 0xf7b84def,
				0x6a31b096, 0xd9ebf88d, 0x612d788e, 0x9e4002ee, 0x97e02af6, 0xd358a1cc,
				0x12e8d7af, 0xdf9fb0e8, 0x990e942a, 0x4a7c1bca, 0xd611a7af, 0x9df796f1,
				0x421cc994, 0x1174a8a8, 0xfd22162c, 0xd111cc91, 0xdbb85f52, 0xb45fe44b,
				0xb4eee3ec, 0xb80dc501, 0x1393ee4f, 0x92523d32, 0xd48e3a1c, 0x224eb65e,
				0x6052c3a4, 0x2109c32f, 0x152ee388, 0xfd9f7ea1, 0x91c62f98, 0x97b55ba0,
				0x250cbca4, 0x4aec6526, 0xdf318384, 0x43a9ce26, 0x9362ad8b, 0x1134140b,
				0x9df5cf82, 0x2e911551, 0x267f0564, 0x4812e3e0, 0x688a52b0, 0xdcc8e944,
				0x115b16a4, 0x93c4eda2, 0x9db4feea, 0xf54bccce, 0x9773e3d2, 0x5f31dcd0,
				0x65c46721, 0x62774f3a, 0x67ca6bc0, 0x467d3a3b, 0x24778426, 0xb7991e9a,
				0xee825c26, 0xe352c8ee, 0xb4fdde1e, 0x94833ae3, 0x61211d04, 0x2732c132,
				0xdcadb248, 0xf606be8c, 0x912a794f, 0x98b4ef31, 0x4a9b4dc6, 0x5f755161,
				0x2116994f, 0x49829cb0, 0x21016574, 0x4343cbeb, 0x61d3d0b4, 0x44f30aef,
				0xb8ae7376, 0x2a3a1c9d, 0xb4b70914, 0xd6bc250c, 0x953b7328, 0x495f948f,
				0xd2a4ed8e, 0x6cf751e4, 0xd320cc76, 0xd9cbb0b4, 0x9ba56262, 0x4e84b03f,
				0xfea8076e, 0x94a07fe6, 0x9039e00c, 0x4611daf8, 0x13731358, 0xb9e671b1,
				0xdfd4ce1c, 0xb25b10ed, 0x4ee35fb2, 0xb44fb480, 0x4634f571, 0x25efd400,
				0xb9f5f5ea, 0x928932df, 0x16041d06, 0x6d31f502, 0x5f39c2e4, 0x2b89d9db,
				0x6bcc0a98, 0xd05bfd6f, 0x2b250622, 0x2e21be0e, 0x60973b04, 0xb45f4a68,
				0xb54fe638, 0xb6ed6616, 0x981a910a, 0x6d92928d, 0xbc6b4698, 0xf73c63ad,
				0x456edf5f, 0x457a8146, 0x61875a64, 0xee30994f, 0x69b5f18a, 0x9c73ee0b,
				0x6e57368f, 0x6c79e3cc, 0x9a595926, 0xbbc49ec6, 0x9fd8b4fb, 0x9016cbdb,
				0x9ccc1e38, 0x6982c712, 0x95c7da7a, 0x68811478, 0xee67fad2, 0xd764d9b4,
				0xd8102950, 0x6cd09da6, 0x2cc1f148, 0x95167d80, 0x1367046d, 0xbf1dfda2,
				0xb2247b24, 0x21301a54, 0x991d99c6, 0x9a4fb7cf, 0x277449a4, 0x19e57492,
				0x45c9a57e, 0x6e7f500a, 0xb9a62a8a, 0x5f242a6b, 0xb1337851, 0x9cda3346,
				0x24874048, 0x4328ba08, 0xfb815f1f, 0x4248896a, 0x9007d85d, 0x1f6e8eea,
				0x9250bdaf, 0xde2ee042, 0x997ee022, 0x6f003612, 0x4ba18f90, 0x26314076,
				0x9824035a, 0x4b57e2d6, 0x9e78aed2, 0xf90dc600
};
```

`blow.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

typedef unsigned char bytee;

class BLOWFISH
{
	//Although there is no successful cryptanalysis of the 16 round version, a higher number of rounds generally means more security.
	//STANDARD: 16
	//MAXIMUM: 256
	//**MUST be an EVEN number**

#define ROUNDS 16

public:
	BLOWFISH(std::string hexKey);
	BLOWFISH(bytee* cipherKey, int keylength);

	//TODO: string encryption functions -> base64
	std::string Encrypt_CBC(std::string data);
	bytee* Encrypt_CBC(bytee* data, int length, int* newlength);
	bytee* Encrypt_ECB(bytee* data, int length, int* newlength);
	void Encrypt_Block(bytee* block, int offset = 0);

	std::string Decrypt_CBC(std::string data);
	bytee* Decrypt_CBC(bytee* data, int length, int* newlength);
	bytee* Decrypt_ECB(bytee* data, int length, int* newlength);
	void Decrypt_Block(bytee* block, int offset = 0);

	void SetRandomIV();
	void SetIV(bytee* newIV);
	bytee* GetIV();
	bool IvSet;

protected:
	void SetupKey(bytee* cipherKey, int length);
	void encipher();
	void decipher();
	unsigned int round(unsigned int a, unsigned int b, unsigned int n);
	void setblock(bytee* block, int offset);
	void getblock(bytee* block, int offset);
	static unsigned int p[];
	static unsigned int s0[];
	static unsigned int s1[];
	static unsigned int s2[];
	static unsigned int s3[];

	unsigned int xl_par;
	unsigned int xr_par;

	bytee IV[8];

	bytee* Crypt_ECB(bytee* data, int length, int* newlength, void (BLOWFISH::* CryptBlock)(bytee*, int offset), bool decrypt);
	bytee* Crypt_CBC(bytee* data, int length, int* newlength, void (BLOWFISH::* CryptBlock)(bytee*, int offset), bool decrypt);
	bytee* padData(bytee* data, int length, int* paddedLength, bool decrypt, bool IvSpace);
	int findPaddingEnd(bytee* data, int length);
	int hex2dec(char hex);
	std::string byteToHex(unsigned char x);
};

//blowfish.h
//This code is in the public domain.
//Created by Taylor Hornby 
//May 8, 2010.
//Ported from my C# blowfish code which was ported from the JavaScript crypto library found here:
//  http://etherhack.co.uk/symmetric/blowfish/blowfish.html
//Complies with the test vectors:  http://www.schneier.com/code/vectors.txt
//Description:
//  Blowfish is a keyed, symmetric block cipher, designed in 1993 by Bruce Schneier and
//  included in a large number of cipher suites and encryption products. Blowfish provides
//  a good encryption rate in software and no effective cryptanalysis of it has been found to date.
//Key Size: 32 to 448 bits
//Block Size: 64 bits
//Rounds: 16 (up to 256 rounds can be used with this class, change the '#define ROUNDS' line)
//More Information: http://www.schneier.com/paper-blowfish-fse.html and http://en.wikipedia.org/wiki/Blowfish_cipher

/*  Cryptography 101 - How to implement properly

This class provides two modes of encryption, CBC and ECB. With ECB, the same data encrypted with the same key will
produce the same result. Patterns will also be visible in the ciphertext. ECB mode should not be used unless it is
specifically needed. CBC mode ensures that no patterns are present in the ciphertext, and that the same data
encrypted with the same key, yeilds a different ciphertext.

Whenever encrypting data, ALWAYS verify the authenticity of the data BEFORE decrypting. To do this, use a HMAC:
token = HMAC(ciphertext, key)
Include this token with the data, and verify it by computing the HMAC again. This ensures that without the key,
an attacker cannot modify the ciphertext. This is especially important with CBC mode, without verification, the
attacker can control the value of the first block of plaintext by modifying the IV.

-   When using CBC mode, always use a random and unique IV. SetRandomIV() will do this for you.
-   Blowfish is only as secure as the encryption key you provide. To create a key from a password,
	run it through a hash algorithm such as SHA-256
*/

/* Usage example
#include <iostream>
#include <string.h>
#include "blowfish.h"
using namespace std;
typedef unsigned char byte;
int main()
{
	BLOWFISH bf("FEDCBA9876543210");
	string asdf = "BlowwFIshhhhhhhhhhh!";
	asdf = bf.Encrypt_CBC(asdf);
	cout << "Encrypted: " << asdf << endl;
	asdf = bf.Decrypt_CBC(asdf);
	cout << "Decrypted: " << asdf;
	return 0;
}
*/
```

`cheat.hpp`:

```hpp
#pragma once
#include "globals.hpp"
#include "menu.hpp"
#include "renderer.hpp"

using namespace VALORANT;

RGBA espcolor;
ImColor ESPColor;

uintptr_t g_base_address;



struct Enemy
{
	uintptr_t for_actor;
	uintptr_t for_mesh;

	uintptr_t actor;
	uintptr_t mesh;
	uintptr_t bone_array;
	uintptr_t root_component;
	uintptr_t damage_handler;

	INT32 bone_count;
	INT32 ammo_count;

	std::string weapon_name;
	std::string agent_name;
	std::string player_name;

	float distance;
	float health;
	float shield;

	bool is_valid;
	bool is_damage_handler_guarded;
	bool is_mesh_guarded;
};

std::vector<Enemy> player_pawns;

bool operator==(const Enemy& a, const Enemy& b) {
	if (a.actor == b.actor) return true;
	return false;
}

boolean in_rect(double centerX, double centerY, double radius, double x, double y) {
	return x >= centerX - radius && x <= centerX + radius &&
		y >= centerY - radius && y <= centerY + radius;
}

auto getuworld(uintptr_t pointer) -> uintptr_t
{
	uintptr_t uworld_addr = read<uintptr_t>(pointer + offsets::uworld_pointer);

	unsigned long long uworld_offset;

	if (uworld_addr > 0x10000000000)
	{
		uworld_offset = uworld_addr - 0x10000000000;
	}
	else {
		uworld_offset = uworld_addr - 0x8000000000;
	}

	return pointer + uworld_offset;
}

DWORD_PTR GetProcessBaseAddress(DWORD processID)
{
	DWORD_PTR   baseAddress = 0;
	HANDLE      processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
	HMODULE* moduleArray;
	LPBYTE      moduleArrayBytes;
	DWORD       bytesRequired;

	if (processHandle)
	{
		if (EnumProcessModules(processHandle, NULL, 0, &bytesRequired))
		{
			if (bytesRequired)
			{
				moduleArrayBytes = (LPBYTE)LocalAlloc(LPTR, bytesRequired);

				if (moduleArrayBytes)
				{
					unsigned int moduleCount;

					moduleCount = bytesRequired / sizeof(HMODULE);
					moduleArray = (HMODULE*)moduleArrayBytes;

					if (EnumProcessModules(processHandle, moduleArray, bytesRequired, &bytesRequired))
					{
						baseAddress = (DWORD_PTR)moduleArray[0];
					}

					LocalFree(moduleArrayBytes);
				}
			}
		}

		CloseHandle(processHandle);
	}

	return baseAddress;
}

void calculate_random_for_constant_aimbot()
{
	while (true)
	{
		settings::aim_constant_offset = 15.f;
		Sleep(200);

		settings::aim_constant_offset = 2.f;
		Sleep(200);

		settings::aim_constant_offset = 8.f;
		Sleep(200);

		settings::aim_constant_offset = 20.f;
		Sleep(200);

		settings::aim_constant_offset = 4.f;
		Sleep(200);

		settings::aim_constant_offset = 12.f;
		Sleep(200);
	}

}

void normalize(fvector& in)
{
	if (in.x > 89.f) in.x -= 360.f;
	else if (in.x < -89.f) in.x += 360.f;

	while (in.y > 180)in.y -= 360;
	while (in.y < -180)in.y += 360;
	in.z = 0;
}

fvector smooth_aim(fvector target, fvector delta_rotation, float smooth)
{
	fvector diff = target - delta_rotation;
	normalize(diff);
	return delta_rotation + diff / smooth;
}

float degree_to_radian(float degree)
{
	return degree * (M_PI / 180);
}

void angle_rotation(const fvector& angles, fvector* forward)
{
	float	sp, sy, cp, cy;

	sy = sin(degree_to_radian(angles.y));
	cy = cos(degree_to_radian(angles.y));

	sp = sin(degree_to_radian(angles.x));
	cp = cos(degree_to_radian(angles.x));

	forward->x = cp * cy;
	forward->y = cp * sy;
	forward->z = -sp;
}

fvector bone_matrix(int index, Enemy _player)
{
	size_t size = sizeof(ftransform);
	ftransform first_bone, comp_to_world;

	first_bone = read<ftransform>(_player.bone_array + (size * index));
	if (_player.is_mesh_guarded)
	{
		comp_to_world = read<ftransform>(virtualaddy + _player.mesh + 0x250);
	}
	else
	{
		comp_to_world = read<ftransform>(_player.mesh + 0x250);
	}

	D3DMATRIX matrix = MatrixMultiplication(first_bone.ToMatrixWithScale(), comp_to_world.ToMatrixWithScale());
	return fvector(matrix._41, matrix._42, matrix._43);
}

fvector W2S(fvector world_location)
{
	fvector ScreenLocation;
	D3DMATRIX tempMatrix = matrix(camera::rotation);
	fvector vAxisX, vAxisY, vAxisZ;

	vAxisX = fvector(tempMatrix.m[0][0], tempMatrix.m[0][1], tempMatrix.m[0][2]);
	vAxisY = fvector(tempMatrix.m[1][0], tempMatrix.m[1][1], tempMatrix.m[1][2]);
	vAxisZ = fvector(tempMatrix.m[2][0], tempMatrix.m[2][1], tempMatrix.m[2][2]);

	fvector vDelta = world_location - camera::location;
	fvector vTransformed = fvector(vDelta.Dot(vAxisY), vDelta.Dot(vAxisZ), vDelta.Dot(vAxisX));

	if (vTransformed.z < .1f)
		vTransformed.z = .1f;

	float ScreenCenterX = center_x;
	float ScreenCenterY = center_y;

	ScreenLocation.x = ScreenCenterX + vTransformed.x * (ScreenCenterX / tanf(camera::fov * (float)m_pi / 360.f)) / vTransformed.z;
	ScreenLocation.y = ScreenCenterY - vTransformed.y * (ScreenCenterX / tanf(camera::fov * (float)m_pi / 360.f)) / vTransformed.z;
	return ScreenLocation;
}

void draw_3d_box(fvector base, fvector top_reach, float wide, ImVec4 col, float thickness)
{
	//calculate bottom rect
	fvector bottom_rect_1 = fvector(base.x + wide, base.y + wide, base.z);
	fvector bottom_rect_2 = fvector(base.x + wide, base.y - wide, base.z);
	fvector bottom_rect_3 = fvector(base.x - wide, base.y + wide, base.z);
	fvector bottom_rect_4 = fvector(base.x - wide, base.y - wide, base.z);

	//calculate top rect
	fvector top_rect_1 = fvector(top_reach.x + wide, top_reach.y + wide, top_reach.z);
	fvector top_rect_2 = fvector(top_reach.x + wide, top_reach.y - wide, top_reach.z);
	fvector top_rect_3 = fvector(top_reach.x - wide, top_reach.y + wide, top_reach.z);
	fvector top_rect_4 = fvector(top_reach.x - wide, top_reach.y - wide, top_reach.z);

	//W2S bottom rect
	bottom_rect_1 = W2S(bottom_rect_1);
	bottom_rect_2 = W2S(bottom_rect_2);
	bottom_rect_3 = W2S(bottom_rect_3);
	bottom_rect_4 = W2S(bottom_rect_4);

	//W2S top rect
	top_rect_1 = W2S(top_rect_1);
	top_rect_2 = W2S(top_rect_2);
	top_rect_3 = W2S(top_rect_3);
	top_rect_4 = W2S(top_rect_4);

	//render bottom rect
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_1.x, bottom_rect_1.y), ImVec2(bottom_rect_2.x, bottom_rect_2.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_2.x, bottom_rect_2.y), ImVec2(bottom_rect_4.x, bottom_rect_4.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_4.x, bottom_rect_4.y), ImVec2(bottom_rect_3.x, bottom_rect_3.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_3.x, bottom_rect_3.y), ImVec2(bottom_rect_1.x, bottom_rect_1.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//render top rect
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(top_rect_1.x, top_rect_1.y), ImVec2(top_rect_2.x, top_rect_2.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(top_rect_2.x, top_rect_2.y), ImVec2(top_rect_4.x, top_rect_4.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(top_rect_4.x, top_rect_4.y), ImVec2(top_rect_3.x, top_rect_3.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(top_rect_3.x, top_rect_3.y), ImVec2(top_rect_1.x, top_rect_1.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//render connection lines
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_1.x, bottom_rect_1.y), ImVec2(top_rect_1.x, top_rect_1.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_2.x, bottom_rect_2.y), ImVec2(top_rect_2.x, top_rect_2.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_3.x, bottom_rect_3.y), ImVec2(top_rect_3.x, top_rect_3.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(bottom_rect_4.x, bottom_rect_4.y), ImVec2(top_rect_4.x, top_rect_4.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
}

void DrawFilledRect3(int x, int y, int w, int h, RGBA* color)
{
	ImGui::GetOverlayDrawList()->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), 0, 0);
}

void DrawCornerBox(int x, int y, int w, int h, int borderPx, RGBA* color)
{
	DrawFilledRect3(x + borderPx, y, w / 3, borderPx, color);
	DrawFilledRect3(x + w - w / 3 + borderPx, y, w / 3, borderPx, color);
	DrawFilledRect3(x, y, borderPx, h / 3, color);
	DrawFilledRect3(x, y + h - h / 3 + borderPx * 2, borderPx, h / 3, color);
	DrawFilledRect3(x + borderPx, y + h + borderPx, w / 3, borderPx, color);
	DrawFilledRect3(x + w - w / 3 + borderPx, y + h + borderPx, w / 3, borderPx, color);
	DrawFilledRect3(x + w + borderPx, y, borderPx, h / 3, color);
	DrawFilledRect3(x + w + borderPx, y + h - h / 3 + borderPx * 2, borderPx, h / 3, color);
}

void DrawCircle(ImVec2 Center, int radius, RGBA* color, float segments, float thickness)
{
	ImGui::GetOverlayDrawList()->AddCircle(Center, radius, ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 153.0, color->B / 51.0, color->A / 255.0)), segments, thickness);
}

void draw_skeleton(Enemy _player, ImVec4 col, float thickness)
{
	fvector bone_head, bone_neck, bone_chest, bone_pelvis, bone_rshoulder, bone_relbow, bone_rhand, bone_rthigh, bone_rknee, bone_rfoot, bone_lshoulder, bone_lelbow, bone_lhand, bone_lthigh, bone_lknee, bone_lfoot;
	bone_head = bone_matrix(8, _player);
	bone_chest = bone_matrix(6, _player);
	bone_pelvis = bone_matrix(3, _player);

	if (_player.bone_count == 103) 
	{
		bone_neck = bone_matrix(9, _player);

		bone_lshoulder = bone_matrix(33, _player);
		bone_lelbow = bone_matrix(30, _player);
		bone_lhand = bone_matrix(32, _player);

		bone_rshoulder = bone_matrix(58, _player);
		bone_relbow = bone_matrix(55, _player);
		bone_rhand = bone_matrix(57, _player);

		bone_lthigh = bone_matrix(63, _player);
		bone_lknee = bone_matrix(65, _player);
		bone_lfoot = bone_matrix(69, _player);

		bone_rthigh = bone_matrix(77, _player);
		bone_rknee = bone_matrix(79, _player);
		bone_rfoot = bone_matrix(83, _player);
	}
	else if (_player.bone_count == 104) 
	{
		bone_neck = bone_matrix(21, _player);

		bone_lshoulder = bone_matrix(23, _player);
		bone_lelbow = bone_matrix(24, _player);
		bone_lhand = bone_matrix(25, _player);

		bone_rshoulder = bone_matrix(49, _player);
		bone_relbow = bone_matrix(50, _player);
		bone_rhand = bone_matrix(51, _player);

		bone_lthigh = bone_matrix(77, _player);
		bone_lknee = bone_matrix(78, _player);
		bone_lfoot = bone_matrix(80, _player);

		bone_rthigh = bone_matrix(84, _player);
		bone_rknee = bone_matrix(85, _player);
		bone_rfoot = bone_matrix(87, _player);
	}
	else if (_player.bone_count == 101) 
	{
		bone_neck = bone_matrix(21, _player);

		bone_lshoulder = bone_matrix(23, _player);
		bone_lelbow = bone_matrix(24, _player);
		bone_lhand = bone_matrix(25, _player);

		bone_rshoulder = bone_matrix(49, _player);
		bone_relbow = bone_matrix(50, _player);
		bone_rhand = bone_matrix(51, _player);

		bone_lthigh = bone_matrix(75, _player);
		bone_lknee = bone_matrix(76, _player);
		bone_lfoot = bone_matrix(78, _player);

		bone_rthigh = bone_matrix(82, _player);
		bone_rknee = bone_matrix(83, _player);
		bone_rfoot = bone_matrix(85, _player);
	}
	else
	{
		return;
	}

	bone_head = W2S(bone_head);
	bone_neck = W2S(bone_neck);
	bone_chest = W2S(bone_chest);
	bone_pelvis = W2S(bone_pelvis);
	bone_lshoulder = W2S(bone_lshoulder);
	bone_lelbow = W2S(bone_lelbow);
	bone_lhand = W2S(bone_lhand);
	bone_rshoulder = W2S(bone_rshoulder);
	bone_relbow = W2S(bone_relbow);
	bone_rhand = W2S(bone_rhand);
	bone_lthigh = W2S(bone_lthigh);
	bone_lknee = W2S(bone_lknee);
	bone_lfoot = W2S(bone_lfoot);
	bone_rthigh = W2S(bone_rthigh);
	bone_rknee = W2S(bone_rknee);
	bone_rfoot = W2S(bone_rfoot);

	ImDrawList* draw = ImGui::GetOverlayDrawList();

	//top stuff
	//draw->AddLine(ImVec2(bone_head.x, bone_head.y), ImVec2(bone_neck.x, bone_neck.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_neck.x, bone_neck.y), ImVec2(bone_chest.x, bone_chest.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_chest.x, bone_chest.y), ImVec2(bone_pelvis.x, bone_pelvis.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//right arm
	draw->AddLine(ImVec2(bone_chest.x, bone_chest.y), ImVec2(bone_rshoulder.x, bone_rshoulder.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_rshoulder.x, bone_rshoulder.y), ImVec2(bone_relbow.x, bone_relbow.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_relbow.x, bone_relbow.y), ImVec2(bone_rhand.x, bone_rhand.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//left arm
	draw->AddLine(ImVec2(bone_chest.x, bone_chest.y), ImVec2(bone_lshoulder.x, bone_lshoulder.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_lshoulder.x, bone_lshoulder.y), ImVec2(bone_lelbow.x, bone_lelbow.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_lelbow.x, bone_lelbow.y), ImVec2(bone_lhand.x, bone_lhand.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//right foot
	draw->AddLine(ImVec2(bone_pelvis.x, bone_pelvis.y), ImVec2(bone_rthigh.x, bone_rthigh.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_rthigh.x, bone_rthigh.y), ImVec2(bone_rknee.x, bone_rknee.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_rknee.x, bone_rknee.y), ImVec2(bone_rfoot.x, bone_rfoot.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);

	//left foot
	draw->AddLine(ImVec2(bone_pelvis.x, bone_pelvis.y), ImVec2(bone_lthigh.x, bone_lthigh.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_lthigh.x, bone_lthigh.y), ImVec2(bone_lknee.x, bone_lknee.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
	draw->AddLine(ImVec2(bone_lknee.x, bone_lknee.y), ImVec2(bone_lfoot.x, bone_lfoot.y), ImGui::GetColorU32({ col.x, col.y, col.z, col.w }), thickness);
}

void draw_health_bar(ImVec2 min, ImVec2 max, float health)
{
	float health_percentage = health;
	health_percentage *= 0.01f;

	float lenght_left_to_right = max.x - min.x;
	lenght_left_to_right *= health_percentage;

	float healthbar_size_y = 5.f;

	float g = health_percentage * 255.f;
	float r = 255.f - g;
	float b = 0.f;

	r /= 255.f;
	g /= 255.f;
	b /= 255.f;

	ImGui::GetOverlayDrawList()->AddRectFilled(ImVec2(min.x, min.y - healthbar_size_y), ImVec2(max.x, max.y), ImGui::GetColorU32({ 0.1f, 0.1f, 0.1f, 1.f }), 0.f, 15);
	ImGui::GetOverlayDrawList()->AddRectFilled(ImVec2(min.x, min.y - healthbar_size_y), ImVec2(min.x + lenght_left_to_right, max.y), ImGui::GetColorU32({ r, g, b, 1.f }), 0.f, 15);
	ImGui::GetOverlayDrawList()->AddRect(ImVec2(min.x, min.y - healthbar_size_y), ImVec2(max.x, max.y), ImGui::GetColorU32({ 0.f, 0.f, 0.f, 1.f }), 0.f, 15, 1.f);
}

std::string get_agent_name_by_id(int id)
{
	switch (id)
	{
	case 15342018:
		return "Default";
	case 14222427:
		return "Astra";
	case 14208983:
		return "Breach";
	case 15336891:
		return "Brimstone";
	case 15323988:
		return "Chamber";
	case 15329442:
		return "Cypher";
	case 15319792:
		return "Fade";
	case 15343659:
		return "Jett";
	case 14214159:
		return "Kay/O";
	case 14219028:
		return "Killjoy";
	case 14224708:
		return "Neon";
	case 15342356:
		return "Omen";
	case 1533054:
		return "Phoenix";
	case 15321953:
		return "Raze";
	case 15341565:
		return "Reyna";
	case 15340716:
		return "Sage";
	case 15330654:
		return "Sova";
	case 14220343:
		return "Viper";
	case 14226556:
		return "Yoru";
	default:
		return std::to_string(id);
	}
}

std::string get_player_name(int id)
{
	return "";
}

std::string get_weapon_name_by_id(int id)
{
	switch (id)
	{
	case 4587590:
		return "Knife";
	case 14228426:
		return "Classic";
	case 14344067:
		return "Shorty";
	case 14317610:
		return "Frenzy";
	case 14331757:
		return "Ghost";
	case 14337438:
		return "Sherif";
	case 14381275:
		return "Stinger";
	case 14372361:
		return "Spectre";
	case 14311125:
		return "Bucky";
	case 14306695:
		return "Judge";
	case 14290828:
		return "Bulldog";
	case 14359098:
		return "Guardian";
	case 931427888:
		return "Phantom";
	case 634223136:
		return "Vandal";
	case 14367103:
		return "Marshal";
	case 14347794:
		return "Operator";
	case 14277173:
		return "Ares";
	case 14273531:
		return "Odin";
	case 14230480:
		return "Jett Ult";
	case 14213014:
		return "Chamber Ult";
	case 14212558:
		return "Chamber Sherif";
	case 14225417:
		return "Neon Ult";
	case 2:
		return "Unknown";
	default:
		return std::to_string(id);
	}
}

void CheatCache()
{
	while (true)
	{
		uintptr_t world = read<uintptr_t>(virtualaddy + 0x60);
		world = check::validate_pointer(world);
		if (!world) continue;

		uintptr_t game_instance = read<uintptr_t>(virtualaddy + world + 0x1A0);
		if (!game_instance) continue;

		uintptr_t persistent_level = read<uintptr_t>(virtualaddy + world + 0x38);
		persistent_level = check::validate_pointer(persistent_level);
		if (!persistent_level) continue;

		uintptr_t local_players = read<uintptr_t>(game_instance + 0x40);
		if (!local_players) continue;

		uintptr_t local_player = read<uintptr_t>(local_players);
		if (!local_player) continue;

		pointer::player_controller = read<uintptr_t>(local_player + 0x38);
		if (check::is_guarded(pointer::player_controller))
		{
			guarded_pointers::guard_controller = virtualaddy;

			pointer::player_controller = check::validate_pointer(pointer::player_controller);
		}
		else guarded_pointers::guard_controller = 0;
		if (!pointer::player_controller) continue;

		uintptr_t local_pawn = read<uintptr_t>(guarded_pointers::guard_controller + pointer::player_controller + 0x460);
		if (check::is_guarded(local_pawn))
		{
			guarded_pointers::guard_local_pawn = virtualaddy;
			local_pawn = check::validate_pointer(local_pawn);
		}
		else guarded_pointers::guard_local_pawn = 0;

		pointer::local_pawn = local_pawn;
		if (!pointer::local_pawn || (pointer::local_pawn != pointer::local_pawn_old))
		{
			if (!player_pawns.empty())
				player_pawns.clear();
			pointer::local_pawn_old = pointer::local_pawn;
			continue;
		}

		pointer::camera_manager = read<uintptr_t>(pointer::player_controller + 0x478);
		if (!pointer::camera_manager)
		{
			pointer::camera_manager = read<uintptr_t>(virtualaddy + pointer::player_controller + 0x478);
			if (!pointer::camera_manager) continue;
		}

		if (check::is_guarded(pointer::camera_manager))
		{
			pointer::camera_manager = check::validate_pointer(pointer::camera_manager);
		} if (!pointer::camera_manager) continue;

		uintptr_t actor_array = read<uintptr_t>(virtualaddy + persistent_level + 0xA0);
		if (!actor_array) continue;

		INT32 actor_count = read<INT32>(virtualaddy + persistent_level + 0xb8);
		if (!actor_count) continue;

		for (int x = 0; x < actor_count; x++)
		{
			bool is_damage_handler_guarded = false;
			bool is_mesh_guarded = false;

			uintptr_t for_actor = 0;
			uintptr_t for_mesh = 0;

			uintptr_t actor = read<uintptr_t>(actor_array + (x * 8));
			if (!actor) continue;
			if (!check::is_valid(actor)) continue;

			if (check::is_guarded(actor))
			{
				for_actor = virtualaddy;
				actor = check::validate_pointer(actor);
				if (!check::is_valid(actor)) continue;
			}

			INT32 unique_id = read<INT32>(for_actor + actor + 0x38);
			if (unique_id != 0x11e0101) {
				continue;
			}

			uintptr_t mesh = read<uintptr_t>(for_actor + actor + 0x430);
			if (!mesh) continue;
			if (!check::is_valid(mesh)) continue;

			if (check::is_guarded(mesh))
			{
				is_mesh_guarded = true;
				for_mesh = virtualaddy;
				mesh = check::validate_pointer(mesh);
				if (!check::is_valid(mesh)) continue;
			}

			int team_color_diff = read<int>(for_actor + actor + 0x698); // team check
			if (team_color_diff != 2) continue;

			uintptr_t root_comp = read<uintptr_t>(for_actor + actor + 0x230);
			if (!root_comp) continue;

			uintptr_t damage_handler = read<uintptr_t>(for_actor + actor + 0x9A8);
			if (!damage_handler) continue;

			float health = 0.f;
			if (check::is_guarded(damage_handler))
			{
				is_damage_handler_guarded = true;
				damage_handler = check::validate_pointer(damage_handler);
				if (!check::is_valid(damage_handler)) continue;
				health = read<float>(virtualaddy + damage_handler + 0x1B0);
			}
			else
			{
				health = read<float>(damage_handler + 0x1B0);
			}

			if (health <= 0) continue;

			uintptr_t bone_array = read<uintptr_t>(for_mesh + mesh + 0x5C0);
			if (!bone_array) continue;

			INT32 bone_count = read<INT32>(for_mesh + mesh + 0x5C8);
			if (!bone_count) continue;

			Enemy Entities
			{
				for_actor, //guarded region ptr
				for_mesh, //guarded region ptr
				actor,
				mesh,
				bone_array,
				root_comp,
				damage_handler,
				bone_count,
				0, //player_ammo count
				"", //weapon name
				"", //agent name
				"", //Enemy name
				0.f, //distance
				health, //health
				0.f, //shleid
				true,
				is_damage_handler_guarded,
				is_mesh_guarded
			};

			if (!player_pawns.empty()) {
				auto found_player = std::find(player_pawns.begin(), player_pawns.end(), Entities);
				if (found_player == player_pawns.end())
				{
					player_pawns.push_back(Entities);
				}
			}
			else
			{
				player_pawns.push_back(Entities);
			}
		}
	}
}

void UpdateCamera()
{
	camera::location = read<fvector>(virtualaddy + pointer::camera_manager + 0x1260);
	camera::rotation = read<fvector>(virtualaddy + pointer::camera_manager + 0x126C);
	camera::fov = read<float>(virtualaddy + pointer::camera_manager + 0x1278);
}

bool bIsDormant(Enemy APawn) {
	bool dormant = read<bool>(APawn.actor + 0x100);
	if (!dormant) { return false; }
	return true;
};

auto bisVisible(Enemy APawn) -> bool {
	float LastRenderTime = read<float>(APawn.for_mesh + APawn.mesh + offsets::last_render_time);
	float LastSubmitTime = read<float>(APawn.for_mesh + APawn.mesh + offsets::last_submit_time);
	bool IsVisible = LastRenderTime + 0.06F >= LastSubmitTime;
	return IsVisible;
};

void Cheat()
{
	UpdateCamera();
	 
	char players_found[256];
	sprintf_s(players_found, "Player Count: %d", player_pawns.size());
	ImGui::GetOverlayDrawList()->AddText(ImVec2(0, 0), ImGui::GetColorU32({ 1.f, 0.f, 0.f, 1.f }), players_found);

	int closest_player = 1337;
	float closest_distance = FLT_MAX;

	for (int x = 0; x < player_pawns.size(); x++)
	{
		Enemy Entity = player_pawns[x];

		float health = 0;

		if (Entity.is_damage_handler_guarded)
			health = read<float>(virtualaddy + Entity.damage_handler + 0x1B0);
		else
			health = read<float>(Entity.damage_handler + 0x1B0);

		if (health <= 0.f || health > 999.f) player_pawns[x].is_valid = false;

		if (!Entity.is_valid) {
			auto erase_player = std::find(player_pawns.begin(), player_pawns.end(), Entity);
			player_pawns.erase(erase_player);
			continue;
		}

		fvector RootBone = bone_matrix(0, Entity);
		fvector RootBoneProjected = W2S(RootBone);

		fvector HeadBone = bone_matrix(8, Entity);
		fvector HeadBoneProjected = W2S(HeadBone);
		ImVec2 HeadBoneProjected2 = ImVec2(HeadBoneProjected.x, HeadBoneProjected.y);

		Vector3 head2 = Vector3(HeadBone.x, HeadBone.y, HeadBone.z);

		Vector3 CameraPosition = read<Vector3>(virtualaddy + pointer::camera_manager + offsets::camera_position);
		auto DistanceModifier = CameraPosition.Distance(head2) * 0.01F;
		auto Distance = CameraPosition.Distance(head2) * 0.001F;

		float BoxHeight = abs(RootBoneProjected.y - HeadBoneProjected.y);
		float BoxWidth = BoxHeight * 0.40;
		float Width = BoxWidth / 10;
		if (Width < 2) Width = 2;
		if (Width > 3) Width = 3;

		int bottom_text_offset = 2;

		auto Inventory = read<intptr_t>(Entity.actor + 0x948);
		intptr_t CurrentEquip = read<intptr_t>(Inventory + 0x238);
		uintptr_t MagazineAmmo = read<uintptr_t>(CurrentEquip + 0xFB0);
		int32_t AuthResourceAmount = read<int32_t>(MagazineAmmo + 0x100);
		int32_t MaxAmmo = read<int32_t>(MagazineAmmo + 0x120);
		std::string DisplayAmmoA = "Ammo: " + std::to_string(AuthResourceAmount) + " / " + std::to_string(MaxAmmo);

		bool IsVisible = bisVisible(Entity);

		if (IsVisible) { ESPColor = RGBCol.green; espcolor = Col.green; }
		else { ESPColor = RGBCol.red; espcolor = Col.red; }

		if (settings::player_dormant_check) if (!bIsDormant(Entity)) continue;

		if (settings::player_box)
		{
			switch (settings::player_box_selection)
			{
			case 0:
				DrawFilledRect3(RootBoneProjected.x - (BoxWidth / 2), HeadBoneProjected.y, BoxWidth, BoxHeight, &Col.glass);
				DrawCornerBox(RootBoneProjected.x - (BoxWidth / 2), HeadBoneProjected.y, BoxWidth, BoxHeight, 1, &espcolor); break;
			case 1: draw_3d_box(RootBone, fvector(HeadBone.x, HeadBone.y, HeadBone.z + 20), 43, ESPColor, 1.f); break;
			case 2: DrawCornerBox(RootBoneProjected.x - (BoxWidth / 2), HeadBoneProjected.y, BoxWidth, BoxHeight, 1, &espcolor); break;
			}
		}

		if (settings::player_distance)
		{
			char distance_text[256];
			ImVec2 text_size = ImGui::CalcTextSize(distance_text);
			sprintf_s(distance_text, skCrypt("[%.fm]"), DistanceModifier);

			DrawPlayerBar(HeadBoneProjected.x - (text_size.x / 2) + 10, HeadBoneProjected.y - 4, &Col.darkgray_, &Col.white_, distance_text);
		}

		if (settings::player_snapline)
		{
			switch (settings::player_snapline_selection)
			{
			case 0: ImGui::GetOverlayDrawList()->AddLine(ImVec2(center_x, center_y), ImVec2(RootBoneProjected.x, RootBoneProjected.y + bottom_text_offset), ImColor(0, 255, 255, 200), 1.f); break;
			case 1: ImGui::GetOverlayDrawList()->AddLine(ImVec2(center_x, GetSystemMetrics(2500)), ImVec2(RootBoneProjected.x, RootBoneProjected.y + bottom_text_offset), ImColor(0, 255, 255, 200), 1.f); break;
			case 2: ImGui::GetOverlayDrawList()->AddLine(ImVec2(center_x, center_y * 2), ImVec2(RootBoneProjected.x, RootBoneProjected.y + bottom_text_offset), ImColor(0, 255, 255, 200), 1.f); break;
			}
		}

		if (settings::player_skeleton)
		{
			DrawCircle(HeadBoneProjected2, 7 / Distance, &Col.red, 1000, 1);
			draw_skeleton(Entity, ImColor(255, 255, 255, 255), 1.f);
		}

		if (settings::player_healthbar)
		{
			float x1 = RootBoneProjected.x - (BoxWidth / 2);
			float x2 = RootBoneProjected.x + (BoxWidth / 2);

			draw_health_bar(ImVec2(x1, HeadBoneProjected.y - 3), ImVec2(x2, HeadBoneProjected.y - 3), health);
		}

		if (settings::player_view_angle)
		{
			
		}

		if (settings::player_ammo)
		{
		}

		if (settings::team_swap)
	    {
		}

		if (settings::player_agent)
		{
		}

		if (settings::player_weapon)
		{
			uintptr_t inventory = read<uintptr_t>(Entity.for_actor + Entity.actor + 0x948);
			uintptr_t current_equip = read<uintptr_t>(inventory + 0x218);
			int weapon_id = read<int>(current_equip + 0x18);
			std::string weapon_name = get_weapon_name_by_id(weapon_id);
			ImVec2 text_size = ImGui::CalcTextSize(weapon_name.c_str());

			ImGui::GetOverlayDrawList()->AddText(ImVec2(RootBoneProjected.x - (text_size.x / 2), RootBoneProjected.y + bottom_text_offset), ImGui::GetColorU32({ 1.f, 1.f, 1.f, 1.f }), weapon_name.c_str());
			bottom_text_offset += 14;
		}
		if (settings::chams)
		{

		}
		auto dx = HeadBoneProjected.x - center_x;
		auto dy = HeadBoneProjected.y - center_y;
		auto dist = sqrtf(dx * dx + dy * dy);
		if (IsVisible && (dist < closest_distance))
		{
			closest_distance = dist;
			closest_player = x;
		}
	}

	if (closest_player != 1337 && settings::aimbot_enable)
	{
		Enemy target = player_pawns[closest_player];

		fvector head = bone_matrix(settings::aimbot_aimbone, target);
		fvector head_screen = W2S(head);

		if (settings::aimbot_draw_target_line && in_rect(center_x, center_y, settings::aimbot_fov, head_screen.x, head_screen.y))
			ImGui::GetOverlayDrawList()->AddLine(ImVec2(center_x, center_y), ImVec2(head_screen.x, head_screen.y), ImGui::GetColorU32({ 1.f, 0.f, 0.f, 1.f }), 1.f);

		if (settings::aimbot_recoil_control)
		{
			if (GetAsyncKeyState(hotkeys::aimkey) && in_rect(center_x, center_y, settings::aimbot_fov, head_screen.x, head_screen.y))
			{
				fvector control_rotation = read<fvector>(guarded_pointers::guard_controller + pointer::player_controller + 0x440);
				fvector camera_rotation = camera::rotation;
				fvector new_aim_rotation;
				fvector recoil;

				recoil.x = camera_rotation.x - control_rotation.x;
				recoil.y = camera_rotation.y - control_rotation.y;
				recoil.z = 0.f;

				fvector vector_pos = head - camera::location;
				float distance = (double)(sqrtf(vector_pos.x * vector_pos.x + vector_pos.y * vector_pos.y + vector_pos.z * vector_pos.z));
				float x, y, z;
				x = -((acosf(vector_pos.z / distance) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510)) - 90.f);
				y = atan2f(vector_pos.y, vector_pos.x) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510);
				z = 0;

				fvector target_rotation = fvector(x, y, z);
				new_aim_rotation.x = target_rotation.x - recoil.x - recoil.x;
				new_aim_rotation.y = target_rotation.y - recoil.y - recoil.y;
				new_aim_rotation.z = 0;

				float smooth = settings::aimbot_smooth;
				if (settings::aimbot_constant)
				{
					smooth += settings::aim_constant_offset;
				}

				if (!bIsDormant(target));

				fvector new_rotation = smooth_aim(new_aim_rotation, control_rotation, smooth);
				if (new_rotation.x < 0)
				{
					new_rotation.x += 360.f;
				}
				if (new_rotation.y < 0)
				{
					new_rotation.y += 360.f;
				}
				new_rotation.z = 0;

				write<fvector>(guarded_pointers::guard_controller + pointer::player_controller + 0x440, new_rotation);
			}
		}
		else
		{
			if (GetAsyncKeyState(hotkeys::aimkey) && in_rect(center_x, center_y, settings::aimbot_fov, head_screen.x, head_screen.y)) //TODO: FIX THE BOUNCE
			{
				fvector camera_rotation = camera::rotation;
				fvector new_aim_rotation;

				fvector vector_pos = head - camera::location;
				float distance = (double)(sqrtf(vector_pos.x * vector_pos.x + vector_pos.y * vector_pos.y + vector_pos.z * vector_pos.z));
				float x, y, z;
				x = -((acosf(vector_pos.z / distance) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510)) - 90.f);
				y = atan2f(vector_pos.y, vector_pos.x) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510);
				z = 0;

				fvector target_rotation = fvector(x, y, z);
				new_aim_rotation.x = target_rotation.x;
				new_aim_rotation.y = target_rotation.y;
				new_aim_rotation.z = 0;

				float smooth = settings::aimbot_smooth;
				if (settings::aimbot_constant)
				{
					smooth += settings::aim_constant_offset;
				}

				if (!bIsDormant(target));

				fvector new_rotation = smooth_aim(new_aim_rotation, camera_rotation, smooth);
				if (new_rotation.x < 0)
				{
					new_rotation.x += 360.f;
				}
				if (new_rotation.y < 0)
				{
					new_rotation.y += 360.f;
				}
				new_rotation.z = 0;

				write<fvector>(guarded_pointers::guard_controller + pointer::player_controller + 0x440, new_rotation);
			}
		}
	}
}

static HWND Window = NULL;
IDirect3D9Ex* p_Object = NULL;
static LPDIRECT3DDEVICE9 D3dDevice = NULL;
static LPDIRECT3DVERTEXBUFFER9 TriBuf = NULL;
HWND hwnd = NULL;
RECT GameRect = { NULL };
D3DPRESENT_PARAMETERS d3dpp;
const MARGINS Margin = { -1 };
MSG Message = { NULL };

void render()
{
	ImGui_ImplDX9_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	Cheat();
	DrawMenu();

	ImGui::EndFrame();
	D3dDevice->SetRenderState(D3DRS_ZENABLE, false);
	D3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, false);
	D3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, false);
	D3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);

	if (D3dDevice->BeginScene() >= 0) {
		ImGui::Render();
		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
		D3dDevice->EndScene();
	}
	HRESULT result = D3dDevice->Present(NULL, NULL, NULL, NULL);

	if (result == D3DERR_DEVICELOST && D3dDevice->TestCooperativeLevel() == D3DERR_DEVICENOTRESET) {
		ImGui_ImplDX9_InvalidateDeviceObjects();
		D3dDevice->Reset(&d3dpp);
		ImGui_ImplDX9_CreateDeviceObjects();
	}
}
bool gay(uintptr_t pointer)
{
	constexpr uintptr_t filter = 0xFFFFFFF000000000;
	uintptr_t result = pointer & filter;
	return result == 0x8000000000 || result == 0x10000000000;
}
bool start_directx()
{
	if (FAILED(Direct3DCreate9Ex(D3D_SDK_VERSION, &p_Object)))
		return false;

	ZeroMemory(&d3dpp, sizeof(d3dpp));
	d3dpp.BackBufferWidth = Width;
	d3dpp.BackBufferHeight = Height;
	d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8;
	d3dpp.MultiSampleQuality = D3DMULTISAMPLE_NONE;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	d3dpp.EnableAutoDepthStencil = TRUE;
	d3dpp.hDeviceWindow = Window;
	d3dpp.Windowed = TRUE;

	p_Object->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &D3dDevice);

	IMGUI_CHECKVERSION();

	ImGui::CreateContext();
	ImGuiStyle& s = ImGui::GetStyle();

	//s.Colors[ImGuiCol_Button] = ImColor(26, 26, 26, 255);
	//s.Colors[ImGuiCol_ButtonActive] = ImColor(26, 26, 26, 255);
	//s.Colors[ImGuiCol_ButtonHovered] = ImColor(26, 26, 26, 255);

	//s.Colors[ImGuiCol_FrameBg] = ImColor(26, 26, 26, 255);
	//s.Colors[ImGuiCol_FrameBgActive] = ImColor(26, 26, 26, 255);
	//s.Colors[ImGuiCol_FrameBgHovered] = ImColor(26, 26, 26, 255);

	//FONTS
	//fonts::standard_font = io.Fonts->AddFontDefault();
	//fonts::intro_font = io.Fonts->AddFontFromFileTTF("adfg.ttf", 300.f);
	//fonts::standard_font = io.Fonts->AddFontDefault();

	ImGui_ImplWin32_Init(Window);
	ImGui_ImplDX9_Init(D3dDevice);

	p_Object->Release();
	return true;
}

void wait_for_window()
{
	while (true)
	{
		HWND foreground_window = GetForegroundWindow();
		HWND target_window = FindWindowA(0, skCrypt("VALORANT  "));

		if (foreground_window == target_window)
			break;

		Sleep(200);
	}
}

void render_loop()
{
	static RECT old_rc;
	ZeroMemory(&Message, sizeof(MSG));

	while (Message.message != WM_QUIT)
	{
		if (PeekMessage(&Message, Window, 0, 0, 0x0001))
		{
			TranslateMessage(&Message);
			DispatchMessage(&Message);
		}

		HWND hwnd_active = GetForegroundWindow();

		if (hwnd_active == hwnd) {
			HWND hwndtest = GetWindow(hwnd_active, 3);
			SetWindowPos(Window, hwndtest, 2, 2, -3, -3, 0x0002 | 0x0001);
		}

		RECT rc;
		POINT xy;

		ZeroMemory(&rc, sizeof(RECT));
		ZeroMemory(&xy, sizeof(POINT));
		GetClientRect(hwnd, &rc);
		ClientToScreen(hwnd, &xy);
		rc.left = xy.x;
		rc.top = xy.y;

		ImGuiIO& io = ImGui::GetIO();
		io.ImeWindowHandle = hwnd;
		io.DeltaTime = 1.0f / 60.0f;

		POINT p;
		GetCursorPos(&p);
		io.MousePos.x = p.x - xy.x;
		io.MousePos.y = p.y - xy.y;

		if (GetAsyncKeyState(VK_LBUTTON)) {
			io.MouseDown[0] = true;
			io.MouseClicked[0] = true;
			io.MouseClickedPos[0].x = io.MousePos.x;
			io.MouseClickedPos[0].x = io.MousePos.y;
		}
		else
			io.MouseDown[0] = false;

		if (rc.left != old_rc.left || rc.right != old_rc.right || rc.top != old_rc.top || rc.bottom != old_rc.bottom)
		{
			old_rc = rc;

			Width = rc.right;
			Height = rc.bottom;

			d3dpp.BackBufferWidth = Width;
			d3dpp.BackBufferHeight = Height;
			SetWindowPos(Window, (HWND)0, xy.x + 2, xy.y + 2, Width - 3, Height - 3, 0x0008);
			D3dDevice->Reset(&d3dpp);
		}

		render();
	}
	ImGui_ImplDX9_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	DestroyWindow(Window);
}

void stop_render()
{
	TriBuf->Release();
	D3dDevice->Release();
	p_Object->Release();

	DestroyWindow(Window);
	UnregisterClassW((_(L"Untitled - Notepad")), NULL);
}

LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	if (ImGui_ImplWin32_WndProcHandler(hWnd, Message, wParam, lParam))
		return true;

	switch (Message)
	{
	case WM_DESTROY:
		stop_render();
		PostQuitMessage(0);
		exit(4);
		break;
	case WM_SIZE:
		if (D3dDevice != NULL && wParam != SIZE_MINIMIZED)
		{
			ImGui_ImplDX9_InvalidateDeviceObjects();
			d3dpp.BackBufferWidth = LOWORD(lParam);
			d3dpp.BackBufferHeight = HIWORD(lParam);
			HRESULT hr = D3dDevice->Reset(&d3dpp);
			if (hr == D3DERR_INVALIDCALL)
				IM_ASSERT(0);
			ImGui_ImplDX9_CreateDeviceObjects();
		}
		break;
	default:
		return DefWindowProc(hWnd, Message, wParam, lParam);
		break;
	}
	return 0;
}

void create_window()
{
	WNDCLASSEX wc;
	ZeroMemory(&wc, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.lpszClassName = (_(L"Untitled - Notepad"));
	wc.lpfnWndProc = WinProc;
	RegisterClassEx(&wc);

	if (hwnd)
	{
		GetClientRect(hwnd, &GameRect);
		POINT xy;
		ClientToScreen(hwnd, &xy);
		GameRect.left = xy.x;
		GameRect.top = xy.y;

		Width = GameRect.right;
		Height = GameRect.bottom;
	}
	else
		exit(2);

	//something is detected here, i will fix it later
	Window = CreateWindowExW(NULL, _(L"Untitled - Notepad"), _(L"Untitled - Notepad"), 0x80000000L | 0x10000000L, 2, 2, Width - 2, Height - 2, 0, 0, 0, 0);

	DwmExtendFrameIntoClientArea(Window, &Margin);
	SetWindowLong(Window, (-20), 0x00000020L | 0x00000080L | 0x00080000);

	ShowWindow(Window, SW_SHOW);
	UpdateWindow(Window);
}

void rndmBone()
{
	for (;;)
	{
		std::vector<int> boneidList{ 8, 21, 6 };

		int index = rand() % boneidList.size();
		int value = boneidList[index];

		if (settings::aimbot_random_aim_bone)
		{
			settings::aimbot_aimbone = value;
			std::cout << value << "\n";
		}

		Sleep(settings::aimbot_random_aim_bone_interval * 1000);
	}
}

void start_cheat()
{

	hwnd = FindWindowA(0, _("VALORANT  "));

	create_window();

	start_directx();

	wait_for_window();

	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)CheatCache, NULL, NULL, NULL);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)rndmBone, NULL, NULL, NULL);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)calculate_random_for_constant_aimbot, NULL, NULL, NULL);

	render_loop();

	stop_render();
}
```

`check.h`:

```h
#pragma once
#include "stdafx.h"

namespace check {

	uintptr_t guard;

	bool zero_check(uintptr_t pointer)
	{
		constexpr uintptr_t filter = 0xFFFF0000FFFFFF00;
		uintptr_t result = pointer & filter;
		return result == 0x0000000000000000;
	}

	bool extras_check(uintptr_t pointer)
	{
		constexpr uintptr_t filter = 0xFFFF000000000000;
		uintptr_t result = pointer & filter;
		return result == 0x0000000000000000;
	}

	bool is_valid(uintptr_t pointer)
	{
		if (!pointer)
			return false;

		if (zero_check(pointer))
			return false;

		if (!extras_check(pointer))
			return false;

		return true;
	}
	
	bool is_guarded_2(uintptr_t pointer)
	{

		if (zero_check(pointer))
		{
			return false;
		}

		constexpr uintptr_t filter = 0xFFFFFFFFFF000000;
		uintptr_t result = pointer & filter;
		return result == 0x0000000000000000;
	}

	bool is_guarded(uintptr_t pointer)
	{
		constexpr uintptr_t filter = 0xFFFFFFFF00000000; //change to soemthing out of win32k or maybe not use data type .text
		uintptr_t result = pointer & filter;
		return result == 0x8000000000 || result == 0x10000000000;
	}

	uint64_t validate_pointer(uint64_t address)
	{
		if (is_guarded(address))
			return guard + (address & 0xFFFFFF);
		else
			return address;
	}
}
```

`driver.h`:

```h
#pragma once
#include "stdafx.h"
#include "xor.h"
#include <Psapi.h>
uintptr_t virtualaddy;
uintptr_t baseaddy;
uintptr_t imageaddy;

#define code_rw CTL_CODE(FILE_DEVICE_UNKNOWN, 0x71, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define code_ba CTL_CODE(FILE_DEVICE_UNKNOWN, 0x72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define code_get_guarded_region CTL_CODE(FILE_DEVICE_UNKNOWN, 0x73, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define code_security 0x85b3e12

typedef struct _rw {
	INT32 security;
	INT32 process_id;
	ULONGLONG address;
	ULONGLONG buffer;
	ULONGLONG size;
	BOOLEAN write;
} rw, * prw;

typedef struct _ba {
	INT32 security;
	INT32 process_id;
	ULONGLONG* address;
} ba, * pba;

typedef struct _ga {
	INT32 security;
	ULONGLONG* address;
} ga, * pga;

namespace mem {
	HANDLE driver_handle;
	INT32 process_id;

	bool find_driver() {
		driver_handle = CreateFileW(_(L"\\\\.\\\msmodule"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		if (!driver_handle || (driver_handle == INVALID_HANDLE_VALUE))
			return false;

		return true;
	}

	void read_physical(PVOID address, PVOID buffer, DWORD size) {
		_rw arguments = { 0 };

		arguments.security = code_security;
		arguments.address = (ULONGLONG)address;
		arguments.buffer = (ULONGLONG)buffer;
		arguments.size = size;
		arguments.process_id = process_id;
		arguments.write = FALSE;

		DeviceIoControl(driver_handle, code_rw, &arguments, sizeof(arguments), nullptr, NULL, NULL, NULL);
	}

	void write_physical(PVOID address, PVOID buffer, DWORD size) {
		_rw arguments = { 0 };

		arguments.security = code_security;
		arguments.address = (ULONGLONG)address;
		arguments.buffer = (ULONGLONG)buffer;
		arguments.size = size;
		arguments.process_id = process_id;
		arguments.write = TRUE;

		DeviceIoControl(driver_handle, code_rw, &arguments, sizeof(arguments), nullptr, NULL, NULL, NULL);
	}

	

	uintptr_t base_address() {
		uintptr_t image_address = { NULL };
		_ba arguments = { NULL };

		arguments.security = code_security;
		arguments.process_id = process_id;
		arguments.address = (ULONGLONG*)&image_address;

		DeviceIoControl(driver_handle, code_ba, &arguments, sizeof(arguments), nullptr, NULL, NULL, NULL);

		return image_address;
	}


	uintptr_t get_guarded_region() {

		uintptr_t guarded_region_address = { NULL };
		_ga arguments = { NULL };

		arguments.security = code_security;
		arguments.address = (ULONGLONG*)&guarded_region_address;

		DeviceIoControl(driver_handle, code_get_guarded_region, &arguments, sizeof(arguments), nullptr, NULL, NULL, NULL);

		return guarded_region_address;
	}

	uintptr_t get_base_address() {

		uintptr_t get_base_address = { NULL };
		_ga arguments = { NULL };

		arguments.security = code_security;
		arguments.address = (ULONGLONG*)&get_base_address;

		DeviceIoControl(driver_handle, code_get_guarded_region, &arguments, sizeof(arguments), nullptr, NULL, NULL, NULL);

		return get_base_address;
	}

	INT32 find_process(LPCTSTR process_name) {
		PROCESSENTRY32 pt;
		HANDLE hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		pt.dwSize = sizeof(PROCESSENTRY32);
		if (Process32First(hsnap, &pt)) {
			do {
				if (!lstrcmpi(pt.szExeFile, process_name)) {
					CloseHandle(hsnap);
					process_id = pt.th32ProcessID;
					return pt.th32ProcessID;
				}
			} while (Process32Next(hsnap, &pt));
		}
		CloseHandle(hsnap);

		return { NULL };
	}
}

template <typename T>
T read(uint64_t address) {
	T buffer{ };
	mem::read_physical((PVOID)address, &buffer, sizeof(T));
	return buffer;
}

template <typename T>
T write(uint64_t address, T buffer) {

	mem::write_physical((PVOID)address, &buffer, sizeof(T));
	return buffer;
}
```

`globals.hpp`:

```hpp
#pragma once
#include "driver.h"
#include "check.h"
#include "blow.h"
#include "ss.h"

#include "vectors.hpp"
#include "skcrypt.hpp"
#include "stdafx.h"
#include "xor.h"

#include <wininet.h>
#include <cstddef>
#include <thread>
#include <vector>
#include <string>

inline uintptr_t g_baseaddress{};

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
typedef          __int64 ll;
typedef unsigned __int64 ull;
typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

namespace VALORANT
{
	namespace settings
	{
		float aim_constant_offset = 0.f;

		bool aimbot_enable = true;
		bool aimbot_constant = true;
		bool aimbot_draw_fov = false;
		bool aimbot_recoil_control = true;
		bool aimbot_random_aim_bone = false;
		bool aimbot_draw_target_line = true;
		bool team_swap = false;
		bool aimbot_360_mode = false;
		float aimbot_fov = 100.f;
		float aimbot_smooth = 20.f;
		int aimbot_aimbone = 8;
		float aimbot_random_aim_bone_interval = 5;

		int aimbot_aimbone_selection = 0;
		int player_snapline_selection = 2;
		int player_box_selection = 2;

		static const char* aimbot_aimbone_items[]{ "Head", "Neck", "Pelvis" };
		static const char* player_snapline_items[]{ "Top", "Middle", "Bottom" };
		static const char* player_box_items[]{ "Filled", "3D Box", "Cornered Box" };

		bool player_box = true;
		bool player_skeleton = true;
		bool player_snapline = false;
		bool player_view_angle = false;
		bool player_distance = false;
		bool player_healthbar = true;
		bool player_agent = true;
		bool player_weapon = false;
		bool player_ammo = false;
		bool player_dormant_check = false;
		bool player_radar = false;
		bool chams = false;
		float fresnel_intensity = 1.f;
	}

	namespace offsets
	{

	}

	namespace guarded_pointers
	{

	}

	namespace pointer
	{
		uintptr_t local_pawn;
		uintptr_t local_pawn_old;
		uintptr_t player_controller;
		uintptr_t camera_manager;
	}

	namespace camera
	{
		fvector location;
		fvector rotation;
		float fov;
	}
	
	template<class T> T __ROL__(T value, int count)
	{
		const uint nbits = sizeof(T) * 8;

		if (count > 0)
		{
			count %= nbits;
			T high = value >> (nbits - count);
			if (T(-1) < 0)
				high &= ~((T(-1) << count));
			value <<= count;
			value |= high;
		}
		else
		{
			count = -count % nbits;
			T low = value << (nbits - count);
			value >>= count;
			value |= low;
		}
		return value;
	}

	inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
	inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
	inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
	inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
	inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
	inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
	inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
	inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

	__forceinline __int64 decrypt_uworld(const uint32_t key, const uintptr_t* state) {

		unsigned __int64 v19; // r11
		unsigned __int64 v20; // r8
		unsigned __int64 v21; // r9
		unsigned int v22; // er10
		unsigned __int64 v23; // rcx
		unsigned __int64 v24; // rdx
		unsigned __int64 v25; // rcx
		int v26; // ebx
		unsigned int v27; // ecx
		__int64 v28; // rax
		unsigned __int64 v29; // r8
		unsigned __int64 v30; // r8
		unsigned __int64 v31; // rcx
		unsigned __int64 v32; // rdx
		unsigned __int64 v33; // rcx

		v19 = 2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))
			% 7;
		v20 = state[v19];
		v21 = (2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
		v22 = (unsigned int)v19 % 7;
		if (!((unsigned int)v19 % 7))
		{
			v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20
				- (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
			v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
			v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
		LABEL_26:
			v26 = 2 * v19;
			goto LABEL_27;
		}
		if (v22 != 1)
			goto LABEL_26;
		v26 = 2 * v19;
		v20 = __ROL8__(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
	LABEL_27:
		v27 = v26 + v21;
		if (v22 == 2)
			v20 = ~(v20 - v27);
		switch (v22)
		{
		case 3u:
			v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
			v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
			break;
		case 4u:
			v29 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
			break;
		case 5u:
			v30 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
			v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
			v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
			break;
		case 6u:
			v20 = ~v20 - (unsigned int)(v21 + v19);
			break;
		}
		return v20 ^ (unsigned int)key;
	}
	inline auto decryptWorld(uintptr_t base_address) -> uintptr_t {
		auto key = read<uintptr_t>(base_address + offsets::uworld_key);
#pragma pack(push, 1)
		struct State
		{
			uint64_t Keys[7];
		};
#pragma pack(pop)
		auto state = read<State>(base_address + offsets::uworld_state);
		auto decrypt = decrypt_uworld(key, (uintptr_t*)&state);
		return read<uintptr_t>(decrypt);
	}
}




```

`imguipp.cpp`:

```cpp
#include "imguipp.h"
namespace imguipp
{

	float getx()
	{
		return ImGui::GetContentRegionAvail().x;
	}

	float gety()
	{
		return ImGui::GetContentRegionAvail().y;
	}

	void button(const char* label, int& currentTab, int newTab, ImVec2 size)
	{
		if (ImGui::Button(label, size))
			currentTab = newTab;
	}

	void line(int newId)
	{
		std::string id = ("imguipp_line_" + std::to_string(newId));
		ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(0, 0, 0, 0));
		{
			ImGui::BeginChild(id.c_str(), ImVec2(ImGui::GetContentRegionAvail().x, 1), false);
			ImGui::Separator();
			ImGui::EndChild();
		}
		ImGui::PopStyleColor();
	}

	void linevertical()
	{
		ImGui::SameLine();
		ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
		ImGui::SameLine();
	}

	void center_text(const char* text, int lineId, bool separator)
	{
		if (text == nullptr)
			return;

		ImGui::Spacing();
		ImGui::SameLine((ImGui::GetContentRegionAvail().x / 2) - (ImGui::CalcTextSize(text).x / 2));
		ImGui::Text(text);
		ImGui::Spacing();

		if (true == separator)
			line(lineId);
	}

	void center_text_ex(const char* text, float width_available, int lineId, bool separator)
	{
		if (text == nullptr)
			return;

		ImGui::Spacing();
		ImGui::SameLine((width_available / 2) - (ImGui::CalcTextSize(text).x / 2));
		ImGui::Text(text);
		ImGui::Spacing();

		if (true == separator)
			line(lineId);
	}

	namespace other
	{
		float get_window_size_x()
		{
			return ImGui::GetWindowSize().x;
		}

		float get_window_size_y()
		{
			return ImGui::GetWindowSize().y;
		}

		ImVec2 get_window_size()
		{
			return ImGui::GetWindowSize();
		}

		char* get_window_name()
		{
			return ImGui::GetCurrentWindow()->Name;
		}

		ImDrawList* get_drawlist()
		{
			return ImGui::GetCurrentWindow()->DrawList;
		}
	}

	ImVec4 to_vec4(float r, float g, float b, float a)
	{
		return ImVec4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
	}
}
```

`imguipp.h`:

```h

#ifndef IMGUIPP_H
#include <../render/imgui.h>
#include <../render/imgui_internal.h>
#include <string>

namespace imguipp
{


	float getx();
	float gety();

	void button(const char* label, int& currentTab, int newTab, ImVec2 size = ImVec2());

	void line(int newId);
	void linevertical();

	void center_text(const char* text, int lineId, bool separator);
	void center_text_ex(const char* text, float width_available, int lineId, bool separator);

	namespace other
	{
		float get_window_size_x();
		float get_window_size_y();

		ImVec2 get_window_size();
		char* get_window_name();
		ImDrawList* get_drawlist();
	}

	ImVec4 to_vec4(float r, float g, float b, float a);

}
#define IMGUIPP_H
#endif
```

`lazy.hpp`:

```hpp
/*
 * Copyright 2018-2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                char c) noexcept
            {
                return static_cast<hash_t::value_type>(
                    (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                    static_cast<unsigned long long>(prime));
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
        {
            return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
        {
            hash_t::value_type value = hash_t::offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_t::single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = hash_t::offset;
            for (; first != last; ++first)
                value = hash_t::single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str) noexcept
        {
            pair<hash_t::value_type, hash_t::value_type> module_and_function{
                hash_t::offset, hash_t::offset
            };

            for (; *str != '.'; ++str)
                module_and_function.first = hash_t::single(module_and_function.first, *str);

            ++str;

            for (; *str; ++str)
                module_and_function.second = hash_t::single(module_and_function.second, *str);

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept
            {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
            {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
            {
                auto& cached = lazy_base<lazy_module<Hash>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(std::forward<Args>(args)...);
#else
                return this->cached()(std::forward<Args>(args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
#endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index)) == Hash)
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!module_hash || hash(name) == module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index)) == function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr));

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i)) == Hash)
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard
```

`main.cpp`:

```cpp
#include "obsidium64.h"

#include "globals.hpp"
#include "cheat.hpp"
#include "print.hpp"
#include "auth.hpp"

#include <TlHelp32.h>
#include <filesystem>
#include <fstream>

#include <iostream> 
#include <Windows.h> // OS function
#include <Psapi.h> 


void SetConsoleSize()
{
	HANDLE hOut;
	SMALL_RECT DisplayArea = { 0, 0, 0, 0 };
	int x = 84;
	int y = 26;
	hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	DisplayArea.Right = x;
	DisplayArea.Bottom = y;

	SetConsoleWindowInfo(hOut, TRUE, &DisplayArea);
}

void rndmTitle()
{

	constexpr int length = 15;
	const auto characters = TEXT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
	TCHAR title[length + 1]{};

	for (int j = 0; j != length; j++)
	{
		title[j] += characters[rand() % 55 + 1];
	}

	SetConsoleTitle(title);

}

#include "Mapper/Kdmapper/kdmapper.hpp"

HANDLE iqvw64e_device_handle;

LONG WINAPI SimplestCrashHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	if (ExceptionInfo && ExceptionInfo->ExceptionRecord)
		std::cout << skCrypt("Driver Error at 0x") << ExceptionInfo->ExceptionRecord->ExceptionAddress << skCrypt(" by 0x") << std::hex << ExceptionInfo->ExceptionRecord->ExceptionCode << std::endl;
	else
		std::cout << skCrypt("Driver Crash") << std::endl;

	if (iqvw64e_device_handle)
		intel_driver::Unload(iqvw64e_device_handle);

	return EXCEPTION_EXECUTE_HANDLER;
}

int load_driver()
{
	SetUnhandledExceptionFilter(SimplestCrashHandler);
	if (intel_driver::IsRunning())
	{
		std::cout << skCrypt("Restart PC!") << std::endl;
		Sleep(500);
	}
	iqvw64e_device_handle = intel_driver::Load();

	NTSTATUS exitCode = 0;
	if (!kdmapper::MapDriver(iqvw64e_device_handle, 0, 0, false, true, 0, 0, 0, &exitCode)) {
		{
			std::cout << skCrypt("Failed to map the driver!") << std::endl;
			intel_driver::Unload(iqvw64e_device_handle);
			Sleep(500);
			exit(0);
		}
	}
	intel_driver::Unload(iqvw64e_device_handle);

	Sleep(500);
}


HWND Entryhwnd;

uintptr_t FindDMAAddy(HANDLE hProc, uintptr_t ptr, std::vector<unsigned int> offsets)
{
	uintptr_t addr = ptr;
	for (unsigned int i = 0; i < offsets.size(); ++i)
	{
		ReadProcessMemory(hProc, (BYTE*)addr, &addr, sizeof(addr), 0);
		addr += offsets[i];
	}
	return addr;
}

int main()
{
	SetConsoleTitleA("Your shitty p2c name");

	CONSOLE_SCREEN_BUFFER_INFO screenBufferInfo;
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	GetConsoleScreenBufferInfo(hConsole, &screenBufferInfo);
	COORD new_screen_buffer_size;
	new_screen_buffer_size.X = screenBufferInfo.srWindow.Right -
		screenBufferInfo.srWindow.Left + 1;
	new_screen_buffer_size.Y = screenBufferInfo.srWindow.Bottom -
		screenBufferInfo.srWindow.Top + 1;
	SetConsoleScreenBufferSize(hConsole, new_screen_buffer_size);


	if (GlobalFindAtomA(skCrypt("DriverAlreadyLoadedx")) == 0)
	{
		load_driver();
		GlobalAddAtomA(skCrypt("DriverAlreadyLoadedx"));
	}

	Sleep(500);

	while (Entryhwnd == NULL)
	{
		std::cout << "[>] Waiting for valorant" << std::endl;;
		Entryhwnd = FindWindowA(0, skCrypt("Valorant  "));
		Sleep(1);
	}

	Beep(300, 300);

	if (mem::find_driver())
	{
		std::cout << ("[>] Driver Loaded\n");
	}
	else Log4(skCrypt("\nDriver Failed... \n"));

	mem::find_process(L"VALORANT-Win64-Shipping.exe");
	virtualaddy = mem::get_guarded_region();

	uintptr_t world = read<uintptr_t>(virtualaddy + 0x60);
	world = check::validate_pointer(world);
	system(skCrypt("cls"));
	std::cout << "[>] Uworld: 0x" << std::hex << world << std::endl;
	std::cout << "[>] Base Address: 0x" << std::hex << mem::base_address() << std::endl;

	start_cheat();
}

```

`menu.hpp`:

```hpp
#pragma once
#include "globals.hpp"
#include "imguipp.h"

using namespace VALORANT;

#define HELPMARKER(str) ImGui::SameLine(); ImGui::TextColored(ImColor(219, 17, 0, 255), "(?)"); if (ImGui::IsItemHovered()) ImGui::SetTooltip(str)

namespace hotkeys
{
	int aimkey = VK_SHIFT;
	int airstuckey;
	int instares;
}

static int keystatus = 0;
static int realkey = 0;

bool GetKey(int key)
{
	realkey = key;
	return true;
}
void ChangeKey(void* blank)
{
	keystatus = 1;
	while (true)
	{
		for (int i = 0; i < 0x87; i++)
		{
			if (GetKeyState(i) & 0x8000)
			{
				hotkeys::aimkey = i;
				keystatus = 0;
				return;
			}
		}
	}
}

static const char* keyNames[] =
{
	skCrypt("Press any key",
	"Left Mouse",
	"Right Mouse",
	"Cancel",
	"Middle Mouse",
	"Mouse 5",
	"Mouse 4",
	"",
	"Backspace",
	"Tab",
	"",
	"",
	"Clear",
	"Enter",
	"",
	"",
	"Shift",
	"Control",
	"Alt",
	"Pause",
	"Caps",
	"",
	"",
	"",
	"",
	"",
	"",
	"Escape",
	"",
	"",
	"",
	"",
	"Space",
	"Page Up",
	"Page Down",
	"End",
	"Home",
	"Left",
	"Up",
	"Right",
	"Down",
	"",
	"",
	"",
	"Print",
	"Insert",
	"Delete",
	"",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"",
	"",
	"",
	"",
	"",
	"Numpad 0",
	"Numpad 1",
	"Numpad 2",
	"Numpad 3",
	"Numpad 4",
	"Numpad 5",
	"Numpad 6",
	"Numpad 7",
	"Numpad 8",
	"Numpad 9",
	"Multiply",
	"Add",
	"",
	"Subtract",
	"Decimal",
	"Divide",
	"F1",
	"F2",
	"F3",
	"F4",
	"F5",
	"F6",
	"F7",
	"F8",
	"F9",
	"F10",
	"F11",
	"F12",)
};

static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}

inline void HotkeyButton(int aimkey, void* changekey, int status)
{
	const char* preview_value = NULL;
	if (aimkey >= 0 && aimkey < IM_ARRAYSIZE(keyNames))
		Items_ArrayGetter(keyNames, aimkey, &preview_value);

	std::string aimkeys;
	if (preview_value == NULL)
		aimkeys = skCrypt("Select Key");
	else
		aimkeys = preview_value;

	if (status == 1)
	{
		aimkeys = skCrypt("Press the Key");
	}
	if (ImGui::Button(aimkeys.c_str(), ImVec2(120, 19)))
	{
		if (status == 0)
		{
			CreateThread(0, 0, (LPTHREAD_START_ROUTINE)changekey, nullptr, 0, nullptr);
		}
	}
}

bool bMenu = true;
static bool Toggledsdsd= true;
static int Tabs = 0;
void DrawMenu()
{
	if (GetAsyncKeyState(VK_INSERT) & 1) bMenu = !bMenu;

	if (settings::aimbot_draw_fov) ImGui::GetOverlayDrawList()->AddCircle(ImVec2(center_x, center_y), settings::aimbot_fov, ImGui::GetColorU32({ 1.f, 1.f, 1.f, 1.f }), 64, 1.f);

	if (bMenu)
	{
		ImGui::SetNextWindowSize(ImVec2(500, 300));
		ImGui::Begin(skCrypt("Your shitty p2c"), &Toggledsdsd, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);


		ImGui::Columns(2);
		ImGui::SetColumnOffset(1, 120);

		ImGui::Spacing();
		if (ImGui::Button("Aimbot", ImVec2(100, 40)))
			Tabs = 0;

		ImGui::Spacing();
		if (ImGui::Button("Visuals", ImVec2(100, 40)))
			Tabs = 1;

		ImGui::Spacing();
		if (ImGui::Button("Extras", ImVec2(100, 40)))
			Tabs = 2;

		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();
		ImGui::Spacing();

		ImGui::SameLine(); // CHEcks

		ImGui::NextColumn();
		{
			if (Tabs == 0)
			{
				HotkeyButton(hotkeys::aimkey, ChangeKey, keystatus); // AIMKEYYY

				ImGui::Checkbox("Aimbot", &settings::aimbot_enable);
				ImGui::Checkbox("Legit Smoothing", &settings::aimbot_constant);
				if (&settings::aimbot_constant)
				{
					ImGui::SliderFloat(" ", &settings::aimbot_smooth, 1.f, 30.f, skCrypt("%.f"));
				}
				ImGui::Checkbox("Draw FOV Circle", &settings::aimbot_draw_fov);
				if (settings::aimbot_draw_fov)
				{
					ImGui::SliderFloat("", &settings::aimbot_fov, 10.f, 1000.f, skCrypt("%.f"));
				}
				ImGui::Checkbox("Draw Aim Line", &settings::aimbot_draw_target_line);

				ImGui::Checkbox("Recoil Control", &settings::aimbot_recoil_control);

				ImGui::Checkbox("Enable 360 Aimbot", &settings::aimbot_360_mode);
				if (settings::aimbot_360_mode) settings::aimbot_fov = 100000000000000000000000000000000000000.f;
				ImGui::EndChild();

				/*ImGui::Checkbox("Target Aim Bone", &settings::aimbot_draw_target_line);
				ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
				ImGui::SetCursorPosX(8);
				ImGui::PushItemWidth(121); ImGui::Combo(skCrypt("##aimbone"), &settings::aimbot_aimbone_selection, settings::aimbot_aimbone_items, sizeof(settings::aimbot_aimbone_items) / sizeof(*settings::aimbot_aimbone_items));
				ImGui::PopStyleVar();

				if (settings::aimbot_aimbone_selection == 0) settings::aimbot_aimbone = 8;
				if (settings::aimbot_aimbone_selection == 1) settings::aimbot_aimbone = 21;
				if (settings::aimbot_aimbone_selection == 2) settings::aimbot_aimbone = 6;*/
			}
			else if (Tabs == 1)
			{
				ImGui::Checkbox("Player Chams", &settings::chams);
				ImGui::Checkbox("Player 2D Box", &settings::player_box);
				ImGui::Checkbox("Player Distance", &settings::player_distance);
				ImGui::Checkbox("Player Snapline", &settings::player_snapline);
				ImGui::Checkbox("Player Skeleton", &settings::player_skeleton);
				ImGui::Checkbox("Player Healthbar", &settings::player_healthbar);

			}
			else if (Tabs == 2)
			{

			}
		}

		ImGui::End();
	}
}
```

`obsidium64.h`:

```h
/*
	Obsidium protection API
	Version 1.7
*/
#ifndef OBSIDIUM_64_H
#define OBSIDIUM_64_H
#include <wtypes.h>		// needed for FILETIME, DWORD, alternatively use windows.h

// define OBSIDIUM_NO_LINK if you intend on dynamically linking to obsidium64.dll
// or if these pragmas don't work for your compiler 
#ifndef OBSIDIUM_NO_LINK
#if defined(__clang__) && !defined(_MSC_VER)
	#pragma link "obsidium64.a"
	#pragma link "obsidiumlib.a"
#else
	#pragma comment(lib, "obsidium64.lib")
#endif
#endif

// #define OBSIDIUM_USE_NAMESPACE in your project to wrap the Obsidium API 
// into a namespace
// Any API calls etc. will need to be prefixed with obsidium::,
// eg. obsidium::obsGetTrialDays() instead of just obsGetTrialDays()
#ifdef __cplusplus
	#ifdef OBSIDIUM_USE_NAMESPACE
		namespace obsidium {
	#endif
	#define OBS_BOOL bool
	extern "C" {
#else
	#include <stdint.h>
	#define OBS_BOOL uint8_t
#endif

unsigned short __declspec(dllimport) obsGetCustomValue();
int __declspec(dllimport) obsGetLicenseStatus();
OBS_BOOL __declspec(dllimport) obsGetLicenseInfo(unsigned long dwInfoNr, char* lpBuffer);
OBS_BOOL __declspec(dllimport) obsGetLicenseInfoW(unsigned long dwInfoNr, wchar_t* lpBuffer);
OBS_BOOL __declspec(dllimport) obsGetLicenseInfoEx(unsigned long dwInfoNr, char* lpBuffer, unsigned long dwBufSize);
OBS_BOOL __declspec(dllimport) obsGetLicenseInfoExW(unsigned long dwInfoNr,	wchar_t* lpBuffer, unsigned long dwBufSize);
OBS_BOOL __declspec(dllimport) obsIsLicensed();
OBS_BOOL __declspec(dllimport) obsGetLicenseHash(unsigned char *hash);
OBS_BOOL __declspec(dllimport) obsGetLicenseExpiration(FILETIME *lpExpiration);
OBS_BOOL __declspec(dllimport) obsGetLicenseCreation(FILETIME *lpDate);
void __declspec(dllimport) obsDisableLicense();
OBS_BOOL __declspec(dllimport) obsSetLicense(const char* lpszLic);
__declspec(dllimport) OBS_BOOL obsSetLicenseW(const wchar_t* lpszLic);
__declspec(dllimport) OBS_BOOL obsSetLicenseShort(const char* lpszInfo, const char* lpszKey, const char* lpszSysId);
__declspec(dllimport) OBS_BOOL obsSetLicenseShortW(const wchar_t* lpszInfo, const wchar_t* lpszKey, const wchar_t* lpszSysId);
__declspec(dllimport) OBS_BOOL obsDeleteLicenseData();
__declspec(dllimport) OBS_BOOL obsStoreLicense(const char* lpszLic);
__declspec(dllimport) OBS_BOOL obsStoreLicenseW(const wchar_t* lpszLic);
__declspec(dllimport) OBS_BOOL obsStoreLicenseShort(const char* lpszInfo, const char* lpszKey, const char* lpszSysId);
__declspec(dllimport) OBS_BOOL obsStoreLicenseShortW(const wchar_t* lpszInfo, const wchar_t* lpszKey, const wchar_t* lpszSysId);
int __declspec(dllimport) obsGetTrialDays();
int __declspec(dllimport) obsGetTrialRuns();
int __declspec(dllimport) obsGetInitialTrialDays();
int __declspec(dllimport) obsGetInitialTrialRuns();
void __declspec(dllimport) obsGetExpirationDate(FILETIME *lpExpiration);
void __declspec(dllimport) obsDeleteTrialData();
OBS_BOOL __declspec(dllimport) obsGetSystemId(char *lpBuffer);
OBS_BOOL __declspec(dllimport) obsIsProtected();
OBS_BOOL __declspec(dllimport) obsSetExternalKey(const unsigned char* lpBuffer, unsigned long dwSize);
const char __declspec(dllimport) *obsSecureString(const char* lpStr);
const wchar_t __declspec(dllimport) *obsSecureStringW(const wchar_t* lpStr);
OBS_BOOL __declspec(dllimport) obsReprotectString();
int __declspec(dllimport) obsGetInstanceCount();
OBS_BOOL __declspec(dllimport) obsIsVm();
int __declspec(dllimport) obsGetTrialCounter(DWORD dwCtrIdx);
int __declspec(dllimport) obsGetInitialTrialCounter(DWORD dwCtrIdx);
OBS_BOOL __declspec(dllimport) obsDecTrialCounter(DWORD dwCtrIdx, short wCount);
OBS_BOOL __declspec(dllimport) obsVerifySignatureData(const void* lpData, 
	unsigned long dwSize, const char* lpszSignature);
OBS_BOOL __declspec(dllimport) obsVerifySignatureFile(const char* lpszFilename, 
	const char* lpszSignature);
OBS_BOOL __declspec(dllimport) obsVerifySignatureFileW(const wchar_t* lpszFilename, 
	const wchar_t* lpszSignature);
void __declspec(dllimport) obsGetProtectionDate(FILETIME *date);
OBS_BOOL __declspec(dllimport) obsUsbGetDeviceId(const char *lpszVolume, char *lpszDeviceId,
	wchar_t *lpszManufacturer, DWORD dwManufacturerSize, wchar_t *lpszProduct, DWORD dwProductSize,
	wchar_t *lpszSerialNumber, DWORD dwSerialNumberSize);
OBS_BOOL __declspec(dllimport) obsUsbGetLicenseDeviceId(char *lpszDeviceId);
typedef void (*obsUsbCallback)(unsigned long event, unsigned long eventInfo, void *param);
void __declspec(dllimport) obsUsbRegisterCallback(obsUsbCallback callback, void *param);
typedef OBS_BOOL (*obsUsbEnumCallback)(const char *lpszDeviceId, const wchar_t *lpszManufacturer,
	const wchar_t *lpszProduct, const wchar_t *lpszSerialNumber, void *param);
OBS_BOOL __declspec(dllimport) obsUsbEnumDevices(obsUsbEnumCallback callback, void *param);
OBS_BOOL __declspec(dllimport) obsGetLicenseSystemId(char *lpBuffer);
OBS_BOOL __declspec(dllimport) obsReloadLicense();
OBS_BOOL __declspec(dllimport) obsUsbReadData(unsigned long dwOffset, unsigned long dwSize, 
	unsigned long dwStorage, void *lpBuffer);
OBS_BOOL __declspec(dllimport) obsUsbWriteData(unsigned long dwOffset, unsigned long dwSize, 
	const void *lpBuffer);
unsigned long __declspec(dllimport) obsUsbExecute(unsigned short wId, unsigned long dwInBufSize, 
	const void *lpInBuf, unsigned long dwOutBufSize, void *lpOutBuf, unsigned long *lpdwBytesWritten);
OBS_BOOL __declspec(dllimport) obsUsbEncrypt(void *lpData, unsigned long dwSize, unsigned long dwMode, 
	const void *lpIV, unsigned long dwReserved);
OBS_BOOL __declspec(dllimport) obsUsbDecrypt(void *lpData, unsigned long dwSize, unsigned long dwMode, 
	const void *lpIV, unsigned long dwReserved);
unsigned long __declspec(dllimport) obsGetActiveLicensingSystem();
int __declspec(dllimport) obsConvertLicenseToBinary(const char *lpszLicense, void *lpOutput, unsigned long *lpOutputSize);
int __declspec(dllimport) obsConvertLicenseToString(const void *lpLicense, unsigned long dwSize, char *lpszOutput, unsigned long *lpOutputSize);
OBS_BOOL __declspec(dllimport) obsNetLicConnect(const char *host, unsigned int port);
void __declspec(dllimport) obsNetLicDisconnect();
typedef void (*obsNetLicCallback)(unsigned long event, unsigned long eventInfo, void *param);
void __declspec(dllimport) obsNetLicRegisterCallback(obsNetLicCallback function, void *param);
OBS_BOOL __declspec(dllimport) obsNetLicGetAppCertName(wchar_t *name);
OBS_BOOL __declspec(dllimport) obsNetLicGetAppCertUserData(wchar_t *userData);
OBS_BOOL __declspec(dllimport) obsNetLicGetAppCertId(wchar_t *name);
int __declspec(dllimport) obsGetLicenseData(void *lpBuffer, unsigned long *lpBufSize);
OBS_BOOL __declspec(dllimport) obsGetTrialEndDate(FILETIME *lpDate);
int __declspec(dllimport) obsGetTrialIdentifier(wchar_t *lpBuffer, unsigned long *lpBufSize);
OBS_BOOL __declspec(dllimport) obsVerifyLicenseShort(const char *lpszInfo, const char *lpszKey, const char *lpszSystemId,
	unsigned short *lpCustomValue, FILETIME *lpExpirationDate, FILETIME *lpCreationDate, unsigned char *lpHash, void *reserved);
OBS_BOOL __declspec(dllimport) obsVerifyLicenseShortW(const wchar_t *lpszInfo, const wchar_t *lpszKey, const wchar_t *lpszSystemId,
	unsigned short *lpCustomValue, FILETIME *lpExpirationDate, FILETIME *lpCreationDate, unsigned char *lpHash, void *reserved);
OBS_BOOL __declspec(dllimport) obsBlacklistLicenses(const unsigned char *lpHashes, unsigned long dwCount);
OBS_BOOL __declspec(dllimport) obsVerifyLicense(const char *lpLicense, char *lpszInfo1, char *lpszInfo2, char *lpszInfo3, char *lpszExtInfo,
	char *lpszSystemId, char *lpszUsbId, FILETIME *lpExpirationDate, FILETIME *lpCreationDate, unsigned char *lpHash, void *reserved);
OBS_BOOL __declspec(dllimport) obsEncDecData(void *lpData, unsigned long dwSize, unsigned long dwOffset, const void* lpKey,
	unsigned long dwKeyBits, unsigned long dwIVLow, unsigned long dwIVHigh);


// getLicenseStatus return values
#define LIC_STATUS_NOTFOUND		0		// no license key found
#define LIC_STATUS_VALID		1		// valid license key present
#define LIC_STATUS_EXPIRED		2		// license key has expired
#define LIC_STATUS_BAD_SYSTEMID	3		// system ID does not match
#define LIC_STATUS_INVALID		4		// invalid or corrupt key
#define LIC_STATUS_BLACKLISTED	5		// license key is blacklisted
#define LIC_STATUS_USB_MISSING  6       // required USB device is missing

// obsGetActiveLicensingSystem return values (lower 16 bits)
#define LIC_SYSTEM_NONE         0		// no licensing system / external system
#define LIC_SYSTEM_SHORT_KEYS   1		// short license keys
#define LIC_SYSTEM_LONG_KEYS    2		// long license keys
#define LIC_SYSTEM_NETWORK      3		// network licensing
#define LIC_SYSTEM_SL_C2        4		// Senselock Clave 2
#define LIC_SYSTEM_SL_EL        5		// Senselock EL
// obsGetActiveLicensingSystem flags (upper 16 bits)
#define LIC_SYSTEM_FLAG_USB     1		// USB licensing is enabled
#define LIC_SYSTEM_FLAG_HW      2		// hardware locking is enabled

// Network licensing callback events
#define OBS_NETLIC_EVENT_CONNECT			0x0001
#define OBS_NETLIC_EVENT_DISCONNECT			0x0002
#define OBS_NETLIC_EVENT_LICENSE_DENIED		0x0003
#define OBS_NETLIC_EVENT_LICENSE_GRANTED	0x0004

// Network licensing callback event info (OBS_NETLIC_EVENT_LICENSE_DENIED)
#define OBS_NETLIC_EVENT_INFO_NONE				0x0000
#define OBS_NETLIC_EVENT_INFO_NO_CERT			0x0001	// server does not have matching app cert
#define OBS_NETLIC_EVENT_INFO_NO_LICENSE		0x0002	// all licenses in use
#define OBS_NETLIC_EVENT_INFO_EXPIRED			0x0003	// license is expired
#define OBS_NETLIC_EVENT_INFO_ALREADY_CONNECTED	0x0004	// client is already connected, multiple connections not allowed
#define OBS_NETLIC_EVENT_INFO_BAD_SERVER_ID		0x0005	// client is locked to a different server ID
#define OBS_NETLIC_EVENT_INFO_NOT_VALID_YET     0x0006	// app cert is not valid yet
#define OBS_NETLIC_EVENT_INFO_SERVER_DISABLED   0x0007	// server is disabled (e.g. due to missing USB device)

// USB licensing callback events
#define OBS_USB_EVENT_UNLICENSED		0x0001
#define OBS_USB_EVENT_LICENSED			0x0002

// USB licensing callback event info
#define OBS_USB_EVENT_INFO_NONE			0x0000

// Senselock storage areas
#define OBS_USB_STORAGE_READ_ONLY				0
#define OBS_USB_STORAGE_READ_WRITE				1

// Senselock encryption modes
#define OBS_USB_ENCDEC_MODE_ECB					0
#define OBS_USB_ENCDEC_MODE_CBC					1

// Senselock EL encryption keys
#define OBS_USB_ENCDEC_USER_KEY_1				12
#define OBS_USB_ENCDEC_USER_KEY_2				13
#define OBS_USB_ENCDEC_USER_KEY_3				14
#define OBS_USB_ENCDEC_USER_KEY_4				15

// pattern marking (always use the macros defined below!)
void obsidium_pattern_marker_a();
void obsidium_pattern_marker_b();
void obsidium_pattern_marker_c();
void obsidium_pattern_marker_d();
void obsidium_pattern_marker_e();
void obsidium_pattern_marker_f();

#define OBSIDIUM_ENC_START obsidium_pattern_marker_a(); obsidium_pattern_marker_c(); obsidium_pattern_marker_b();
#define OBSIDIUM_ENC_END obsidium_pattern_marker_b(); obsidium_pattern_marker_c(); obsidium_pattern_marker_a();
#define OBSIDIUM_LIC_START obsidium_pattern_marker_c(); obsidium_pattern_marker_b(); obsidium_pattern_marker_d();
#define OBSIDIUM_LIC_END obsidium_pattern_marker_d(); obsidium_pattern_marker_b(); obsidium_pattern_marker_c();
#define OBSIDIUM_VM_START obsidium_pattern_marker_e(); obsidium_pattern_marker_a(); obsidium_pattern_marker_f();
#define OBSIDIUM_VM_END obsidium_pattern_marker_f(); obsidium_pattern_marker_a(); obsidium_pattern_marker_e();

#ifdef __cplusplus
	}	// extern "C"
	#ifdef OBSIDIUM_USE_NAMESPACE
		}
	#endif
#endif

#endif

```

`print.hpp`:

```hpp
#pragma once
// Icon Solution for Includes
#include <Windows.h>
#include <iostream>
#include <fcntl.h>
#include <thread>
#include <random>
#include <vector>
#include <string>
#include <io.h>

HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
int num = 5, num2 = 3;

const char* ExoriteTitle()
{

}

const char* SetWhite()
{
	SetConsoleTextAttribute(h, 7);
	return "";
}

const char* SetGreen()
{
	SetConsoleTextAttribute(h, 10);
	return "";
}

const char* SetBlue()
{
	SetConsoleTextAttribute(h, 3);
	return "";
}

const char* SetGold()
{
	SetConsoleTextAttribute(h, 6);
	return "";
}

const char* SetRed()
{
	SetConsoleTextAttribute(h, 4);
	return "";
}

void Log(const char* text)
{
	SetGreen();
	std::cout << skCrypt(">> ");
	SetWhite();
	std::cout << text;
}

void Log2(const char* text)
{
	SetGold();
	std::cout << skCrypt(">> ");
	SetWhite();
	std::cout << text;
}

void Log3(const char* text)
{
	SetBlue();
	std::cout << skCrypt(">> ");
	SetWhite();
	std::cout << text;
}

void Log4(const char* text)
{
	SetRed();
	std::cout << skCrypt(">> ");
	SetWhite();
	std::cout << text;
}

void Opti(const char* text)
{
	SetBlue();
	std::cout << skCrypt(" 1} ");
	SetWhite();
	std::cout << text << std::endl;
}

void Opt2(const char* text)
{
	SetBlue();
	std::cout << skCrypt(" 2} ");
	SetWhite();
	std::cout << text << std::endl;
}

void CountDown()
{
	std::cout << skCrypt("\n");
	while (num > -1)
	{
		SetBlue();
		std::cout << skCrypt("\r>> ");
		SetWhite();
		std::cout << skCrypt("Closing in ");

		SetBlue();
		std::cout << num;
		SetWhite();

		std::cout << skCrypt(" seconds! Please start your game...");
		Sleep(1000);
		num--;
	}
}

void Green(const char* text)
{
	SetGreen();
	std::cout << text << std::endl;
	SetWhite();
}

void Blue(const char* text)
{
	SetBlue();
	std::cout << text << std::endl;
	SetWhite();
}

void system_no_output(std::string command)
{
	command.insert(0, "/C ");

	SHELLEXECUTEINFOA ShExecInfo = { 0 };
	ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	ShExecInfo.hwnd = NULL;
	ShExecInfo.lpVerb = NULL;
	ShExecInfo.lpFile = "cmd.exe";
	ShExecInfo.lpParameters = command.c_str();
	ShExecInfo.lpDirectory = NULL;
	ShExecInfo.nShow = SW_HIDE;
	ShExecInfo.hInstApp = NULL;

	if (ShellExecuteExA(&ShExecInfo) == FALSE)

		WaitForSingleObject(ShExecInfo.hProcess, INFINITE);

	DWORD rv;
	GetExitCodeProcess(ShExecInfo.hProcess, &rv);
	CloseHandle(ShExecInfo.hProcess);
}

std::string tm_to_readable_time(tm ctx)
{
	char buffer[80];

	strftime(buffer, sizeof(buffer), skCrypt("%m/%d/%y"), &ctx);

	return std::string(buffer);
}

static std::time_t string_to_timet(std::string timestamp)
{
	auto cv = strtol(timestamp.c_str(), NULL, 10);

	return (time_t)cv;
}

static std::tm timet_to_tm(time_t timestamp)
{
	std::tm context;

	localtime_s(&context, &timestamp);

	return context;
}
```

`renderer.hpp`:

```hpp
typedef struct
{
	DWORD R;
	DWORD G;
	DWORD B;
	DWORD A;
}RGBA;
class Color
{
public:
	RGBA red = { 255,0,0,255 };
	RGBA Magenta = { 255,0,255,255 };
	RGBA yellow = { 255,255,0,255 };
	RGBA grayblue = { 128,128,255,255 };
	RGBA green = { 0, 255, 0, 255 };
	RGBA darkgreen = { 0,224,128,255 };
	RGBA brown = { 192,96,0,255 };
	RGBA pink = { 255,168,255,255 };
	RGBA DarkYellow = { 216,216,0,255 };
	RGBA SilverWhite = { 236,236,236,255 };
	RGBA purple = { 144,0,255,255 };
	RGBA Navy = { 88,48,224,255 };
	RGBA skyblue = { 0,136,255,255 };
	RGBA graygreen = { 128,160,128,255 };
	RGBA blue = { 0,96,192,255 };
	RGBA orange = { 255,128,0,255 };
	RGBA peachred = { 255,80,128,255 };
	RGBA reds = { 255,128,192,255 };
	RGBA darkgray = { 96,96,96,255 };
	RGBA Navys = { 0,0,128,255 };
	RGBA darkgreens = { 0,128,0,255 };
	RGBA darkblue = { 0,128,128,255 };
	RGBA redbrown = { 128,0,0,255 };
	RGBA purplered = { 128,0,128,255 };
	RGBA greens = { 25,255,25,140 };
	RGBA envy = { 0,255,255,255 };
	RGBA black = { 0,0,0,200 };
	RGBA neger = { 215, 240, 180, 255 };
	RGBA negernot = { 222, 180, 200, 255 };
	RGBA gray = { 128,128,128,255 };
	RGBA white = { 255,255,255,200 };
	RGBA whitelow = { 255,255,255,100 };
	RGBA blues = { 30,144,255,255 };
	RGBA lightblue = { 135,206,250,255 };
	RGBA Scarlet = { 220, 20, 60, 160 };
	RGBA white_ = { 255,255,255,200 };
	RGBA gray_ = { 128,128,128,200 };
	RGBA black_ = { 0,0,0,200 };
	RGBA red_ = { 255,0,0,200 };
	RGBA Magenta_ = { 255,0,255,200 };
	RGBA yellow_ = { 255,255,0,200 };
	RGBA grayblue_ = { 128,128,255,200 };
	RGBA green_ = { 128,224,0,200 };
	RGBA darkgreen_ = { 0,224,128,200 };
	RGBA brown_ = { 192,96,0,200 };
	RGBA pink_ = { 255,168,255,200 };
	RGBA darkyellow_ = { 216,216,0,200 };
	RGBA silverwhite_ = { 236,236,236,200 };
	RGBA purple_ = { 144,0,255,200 };
	RGBA Blue_ = { 88,48,224,200 };
	RGBA skyblue_ = { 0,136,255,200 };
	RGBA graygreen_ = { 128,160,128,200 };
	RGBA blue_ = { 0,96,192,200 };
	RGBA orange_ = { 255,128,0,200 };
	RGBA pinks_ = { 255,80,128,200 };
	RGBA Fuhong_ = { 255,128,192,200 };
	RGBA darkgray_ = { 96,96,96,200 };
	RGBA Navy_ = { 0,0,128,200 };
	RGBA darkgreens_ = { 0,128,0,200 };
	RGBA darkblue_ = { 0,128,128,200 };
	RGBA redbrown_ = { 128,0,0,200 };
	RGBA purplered_ = { 128,0,128,200 };
	RGBA greens_ = { 0,255,0,200 };
	RGBA envy_ = { 0,255,255,200 };

	RGBA glassblack = { 0, 0, 0, 100 };
	RGBA GlassBlue = { 65,105,225,80 };
	RGBA glassyellow = { 255,255,0,160 };
	RGBA glass = { 200,200,200,60 };

	RGBA filled = { 144, 0, 255, 30 };

	RGBA Plum = { 221,160,221,160 };
	RGBA cyan = { 0, 255, 255, 255 };
	RGBA valo = { 255, 70, 85, 255 };

	RGBA VisibleColor = { 255 / 255, 0, 0 };
	RGBA InvisibleColor = { 0, 255 / 255, 0 };

	RGBA rainbow() {

		static float x = 0, y = 0;
		static float r = 0, g = 0, b = 0;

		if (y >= 0.0f && y < 255.0f) {
			r = 255.0f;
			g = 0.0f;
			b = x;
		}
		else if (y >= 255.0f && y < 510.0f) {
			r = 255.0f - x;
			g = 0.0f;
			b = 255.0f;
		}
		else if (y >= 510.0f && y < 765.0f) {
			r = 0.0f;
			g = x;
			b = 255.0f;
		}
		else if (y >= 765.0f && y < 1020.0f) {
			r = 0.0f;
			g = 255.0f;
			b = 255.0f - x;
		}
		else if (y >= 1020.0f && y < 1275.0f) {
			r = x;
			g = 255.0f;
			b = 0.0f;
		}
		else if (y >= 1275.0f && y < 1530.0f) {
			r = 255.0f;
			g = 255.0f - x;
			b = 0.0f;
		}

		float rainbow_speed = 0.25f;

		x += rainbow_speed; //increase this value to switch colors faster
		if (x >= 255.0f)
			x = 0.0f;

		y += rainbow_speed; //increase this value to switch colors faster
		if (y > 1530.0f)
			y = 0.0f;


		return RGBA{ (DWORD)r, (DWORD)g, (DWORD)b, 255 };
	}
};
static Color Col;


class RGBColor
{
public:
	ImColor white{ 255, 255, 255, 255 };
	ImColor cyan{ 0, 255, 255, 255 };
	ImColor red{ 255, 0, 0, 255 };
	ImColor green{ 0, 255, 0, 255 };

	ImColor whitelow{ 255, 255, 255, 100 };
	ImColor redlow{ 255, 0, 0, 100 };
	ImColor valo{ 255, 70, 85, 255 };
};
RGBColor RGBCol;

static auto string_To_UTF8(const std::string& str) -> std::string
{
	int nwLen = ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);

	wchar_t* pwBuf = new wchar_t[nwLen + 1];
	ZeroMemory(pwBuf, nwLen * 2 + 2);

	::MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.length(), pwBuf, nwLen);

	int nLen = ::WideCharToMultiByte(CP_UTF8, 0, pwBuf, -1, NULL, NULL, NULL, NULL);

	char* pBuf = new char[nLen + 1];
	ZeroMemory(pBuf, nLen + 1);

	::WideCharToMultiByte(CP_UTF8, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL);

	std::string retStr(pBuf);

	delete[]pwBuf;
	delete[]pBuf;

	pwBuf = NULL;
	pBuf = NULL;

	return retStr;
}
static auto WStringToUTF8(const wchar_t* lpwcszWString) -> std::string
{
	char* pElementText;
	int iTextLen = ::WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)lpwcszWString, -1, NULL, 0, NULL, NULL);
	pElementText = new char[iTextLen + 1];
	memset((void*)pElementText, 0, (iTextLen + 1) * sizeof(char));
	::WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)lpwcszWString, -1, pElementText, iTextLen, NULL, NULL);
	std::string strReturn(pElementText);
	delete[] pElementText;
	return strReturn;
}
static auto MBytesToWString(const char* lpcszString) -> std::wstring
{
	int len = strlen(lpcszString);
	int unicodeLen = ::MultiByteToWideChar(CP_ACP, 0, lpcszString, -1, NULL, 0);
	wchar_t* pUnicode = new wchar_t[unicodeLen + 1];
	memset(pUnicode, 0, (unicodeLen + 1) * sizeof(wchar_t));
	::MultiByteToWideChar(CP_ACP, 0, lpcszString, -1, (LPWSTR)pUnicode, unicodeLen);
	std::wstring wString = (wchar_t*)pUnicode;
	delete[] pUnicode;
	return wString;
}


static auto DrawLine(int x1, int y1, int x2, int y2, RGBA* color, int thickness) -> void
{
	ImGui::GetOverlayDrawList()->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), thickness);
}
static auto DrawFilledRect(int x, int y, int w, int h, RGBA* color)-> void
{
	ImGui::GetOverlayDrawList()->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), 0, 0);
}
static auto DrawNewText(int x, int y, RGBA* color, const char* str) -> void
{
	ImFont a;
	std::string utf_8_1 = std::string(str);
	std::string utf_8_2 = string_To_UTF8(utf_8_1);
	ImGui::GetOverlayDrawList()->AddText(ImVec2(x, y), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), utf_8_2.c_str());
}

void DrawPlayerBar(int x, int y, RGBA* back_color, RGBA* main_color, const char* pText, ...)
{
	va_list va_alist;
	char buf[1024] = { 0 };
	va_start(va_alist, pText);
	_vsnprintf_s(buf, sizeof(buf), pText, va_alist);
	va_end(va_alist);
	std::string text = WStringToUTF8(MBytesToWString(buf).c_str());

	const ImVec2 text_dimension = ImGui::CalcTextSize(text.c_str());
	const float text_width = text_dimension.x + 5.f;
	const float mid_width = x - (text_width / 2.f);
	//RGBA green_color = { 255,255,255,150 };
	RGBA green_color = { 0, 255, 255, 150 };

	DrawFilledRect(mid_width + 2.f, y - 25.f, text_width + 10.f, text_dimension.y + 5.f, back_color);
	DrawLine(mid_width, y - 25.f, mid_width, (y - 25.f) + text_dimension.y + 5.f, &green_color, 3.f);
	DrawNewText(mid_width + 6.f, (y - 25.f) + 2.f, main_color, text.c_str());
}
```

`skcrypt.hpp`:

```hpp
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`ss.h`:

```h
#pragma once
#include <algorithm>
#include "stdafx.h"
#include "xor.h"

#define XFATAL_CODE(__code) xEpicFail(__FILE__, __LINE__, (__code))
#define XFATAL() XFATAL_CODE(0)

#define XGUARD_CODE(__cond, __code) xGuard((__cond), __FILE__, __LINE__, (__code))
#define XGUARD_WIN(__cond) XGUARD_CODE((__cond), GetLastError())
#define XGUARD(__cond) XGUARD_CODE((__cond), 0)

#define XGUARD_HR(__code) xGuard((__code), __FILE__, __LINE__)

inline void xEpicFail(const char* file, int line, int code)
{
    //printf("EPIC FAIL -> FILE:%s LINE:%d CODE=(int)%d\n", file, line, (int)code);
    //throw std::runtime_error("EPIC FAIL");
}

inline void xGuard(bool cond, const char* file, int line, int code) { if (!cond) { xEpicFail(file, line, code); } }
inline void xGuard(HRESULT code, const char* file, int line) { if FAILED(code) { xEpicFail(file, line, code); } }

//=======================================================================================

inline bool xIsHandleValid(PVOID Handle) { return (Handle != nullptr && Handle != INVALID_HANDLE_VALUE); }

template<typename T, typename Traits>
class TScopedHandle
{
public:
    T Handle;

    inline TScopedHandle() : Handle(nullptr) {}
    inline explicit TScopedHandle(T h) : Handle(h) {}
    inline TScopedHandle(TScopedHandle& other) { Handle = other.Handle; other.Handle = nullptr; }

    inline ~TScopedHandle() { Close(); }
    inline void Close() { Traits::Close(Handle); }
    inline void Dismiss() { Handle = nullptr; }

    inline T& operator*() { return Handle; }
    inline T* operator&() { return &Handle; }

    inline const T& operator*() const { return Handle; }
    inline const T* operator&() const { return &Handle; }

    inline TScopedHandle& operator=(T h) { Close(); Handle = h; return *this; }
    inline TScopedHandle& operator=(TScopedHandle& other) { Close(); Handle = other.Handle; other.Handle = nullptr; return *this; }

    inline operator bool() const { return xIsHandleValid(Handle); }
};

struct HANDLE_traits {
    static void Close(HANDLE& Value) throw() { if (xIsHandleValid(Value)) { CloseHandle(Value); Value = nullptr; } }
};

typedef TScopedHandle<HANDLE, HANDLE_traits> XScopedHandle;

//=======================================================================================

VOID xAdjustPrivilege(LPCWSTR PrivilegeName, BOOL Enable)
{
    TOKEN_PRIVILEGES Privilege;
    ZeroMemory(&Privilege, sizeof(Privilege));
    Privilege.PrivilegeCount = 1;
    Privilege.Privileges[0].Attributes = (Enable ? SE_PRIVILEGE_ENABLED : 0);

    XGUARD_WIN(LookupPrivilegeValueW(nullptr, PrivilegeName, &Privilege.Privileges[0].Luid));

    XScopedHandle Token;
    XGUARD_WIN(OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &Token));

    XGUARD_WIN(AdjustTokenPrivileges(*Token, FALSE, &Privilege, sizeof(Privilege), nullptr, nullptr));
}

DWORD xGetPidByName(LPCWSTR name)
{
    DWORD Pid = 0;

    XScopedHandle Snapshot(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
    XGUARD_WIN(Snapshot);

    PROCESSENTRY32W Entry;
    ZeroMemory(&Entry, sizeof(Entry));
    Entry.dwSize = sizeof(Entry);
    XGUARD_WIN(Process32FirstW(Snapshot.Handle, &Entry));

    do
    {
        if (_wcsicmp(Entry.szExeFile, name) == 0)
        {
            Pid = Entry.th32ProcessID;
            break;
        }
    } while (Process32NextW(Snapshot.Handle, &Entry));

    return Pid;
}

static inline bool xCompareBytes(const uint8_t& a, const uint8_t& b)
{
    return (a == b || b == 0xCC); // use 0xCC (int3) as wildcard
}

PVOID xFindPattern(HANDLE Process, LPVOID ImageBase, const std::vector<uint8_t>& Pattern)
{
    PVOID Result = nullptr;

    uint8_t* Ptr = (uint8_t*)ImageBase;

    MEMORY_BASIC_INFORMATION MemInfo;
    ZeroMemory(&MemInfo, sizeof(MemInfo));

    std::vector<uint8_t> Buffer;
    std::vector<uint8_t>::iterator Iter;

    for (;;)
    {
        auto QuerySize = VirtualQueryEx(Process, Ptr, &MemInfo, sizeof(MemInfo));
        if (QuerySize != sizeof(MemInfo))
        {
            DWORD Err = GetLastError();
            XGUARD_CODE(ERROR_INVALID_PARAMETER == Err, Err);
            break;
        }

        const bool bExecutable = (
            (MemInfo.Protect & PAGE_EXECUTE) != 0 ||
            (MemInfo.Protect & PAGE_EXECUTE_READ) != 0 ||
            (MemInfo.Protect & PAGE_EXECUTE_READWRITE) != 0 ||
            (MemInfo.Protect & PAGE_EXECUTE_WRITECOPY) != 0);

        if (bExecutable && ((MemInfo.Protect & PAGE_GUARD) == 0) && ((MemInfo.Protect & PAGE_NOACCESS) == 0))
        {
            if (Buffer.size() < MemInfo.RegionSize)
            {
                Buffer.resize(MemInfo.RegionSize);
            }

            SIZE_T NumBytes = 0;
            XGUARD_WIN(ReadProcessMemory(Process, MemInfo.BaseAddress, &Buffer[0], MemInfo.RegionSize, &NumBytes));

            auto BufferEnd = Buffer.begin() + MemInfo.RegionSize;
            Iter = Buffer.begin();

            if ((Iter = std::search(Iter, BufferEnd, Pattern.begin(), Pattern.end(), xCompareBytes)) != BufferEnd)
            {
                Result = (uint8_t*)MemInfo.BaseAddress + (Iter - Buffer.begin());
                break;
            }
        }

        Ptr += MemInfo.RegionSize;
    }

    return Result;
}

void xProtectWriteMemory(HANDLE Process, const std::vector<uint8_t>& OrigBytes, const std::vector<uint8_t>& PatchBytes, PVOID Addr, SIZE_T Offset)
{
    //printf("xPatchMemory Addr=%p Offset=%I64u\n", Addr, (UINT64)Offset);

    DWORD Prot = 0;
    XGUARD_WIN(VirtualProtectEx(Process, Addr, OrigBytes.size(), PAGE_EXECUTE_READWRITE, &Prot));

    SIZE_T IoSize = 0;
    XGUARD_WIN(WriteProcessMemory(Process, (PVOID)((UINT64)Addr + (UINT64)Offset), &PatchBytes[0], PatchBytes.size(), &IoSize));

    DWORD Prot2 = 0;
    XGUARD_WIN(VirtualProtectEx(Process, Addr, OrigBytes.size(), Prot, &Prot2));

    //printf("xPatchMemory DONE\n");
}

PVOID xPatchProcess(LPCWSTR ProcName, const std::vector<uint8_t>& OrigBytes, const std::vector<uint8_t>& PatchBytes, PVOID PatchAddr, SIZE_T PatchOffset)
{
    //printf("xPatchProcess Name=\"%S\"\n", ProcName);

    XGUARD(OrigBytes.size());
    XGUARD(PatchBytes.size());

    DWORD ProcId = 0;
    XScopedHandle Process;

    if (ProcName)
    {
        ProcId = xGetPidByName(ProcName);
        XGUARD_WIN(ProcId);

        xAdjustPrivilege((L"SeDebugPrivilege"), TRUE);

        Process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcId);
        XGUARD_WIN(Process);
    }
    else
    {
        ProcId = GetCurrentProcessId();
        Process = GetCurrentProcess();
    }

    PVOID Result = nullptr;

    if (PatchAddr)
    {
        xProtectWriteMemory(*Process, OrigBytes, PatchBytes, PatchAddr, PatchOffset);
        Result = PatchAddr;
    }
    else
    {
        XScopedHandle Snap(CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcId));
        XGUARD_WIN(Snap);

        MODULEENTRY32 Entry;
        ZeroMemory(&Entry, sizeof(Entry));
        Entry.dwSize = sizeof(Entry);
        XGUARD_WIN(Module32First(*Snap, &Entry));

        do
        {
            if (Entry.th32ProcessID == ProcId)
            {
                PVOID Addr = xFindPattern(*Process, Entry.modBaseAddr, OrigBytes);
                if (Addr)
                {
                    xProtectWriteMemory(*Process, OrigBytes, PatchBytes, Addr, PatchOffset);
                    Result = Addr;
                    break;
                }
            }
        } while (Module32Next(*Snap, &Entry));
    }

    return Result;
}

//=======================================================================================

inline uint8_t xParseHex(uint8_t Val)
{
    if (Val >= '0' && Val <= '9') return (Val - '0');
    if (Val >= 'a' && Val <= 'f') return (Val - 'a') + 10;
    if (Val >= 'A' && Val <= 'F') return (Val - 'A') + 10;
    XFATAL();
    return 0;
}

inline uint8_t xParseByte(const char* Str)
{
    uint8_t hi = xParseHex((uint8_t)Str[0]);
    uint8_t lo = xParseHex((uint8_t)Str[1]);
    return ((hi << 4) | lo);
}

std::vector<uint8_t> xParseByteArray(LPCSTR Str)
{
    XGUARD(Str);

    const size_t Len = strlen(Str);
    XGUARD(Len);

    size_t SpaceCount = 0;
    for (size_t i = 0; i < Len; ++i)
    {
        if (Str[i] == ' ') SpaceCount++;
    }

    const size_t NumBytes = (SpaceCount + 1);
    XGUARD(Len == (NumBytes * 2 + SpaceCount));

    std::vector<uint8_t> Vec;
    Vec.resize(NumBytes);

    for (size_t i = 0; i < NumBytes; i++)
    {
        Vec[i] = xParseByte(Str);
        Str += 3;
    }

    return Vec;
}
```

`stdafx.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <vector>

#include <dwmapi.h>
#pragma comment (lib, "dwmapi.lib")

#include "render/imgui.h"
#include "render/imgui_impl_dx9.h"
#include "render/imgui_impl_win32.h"

#include "directx/d3dx9.h"
#pragma comment (lib, "d3d9.lib")

#define M_PI (double)3.1415926535
#define actor_player 4
```

`vectors.hpp`:

```hpp
#pragma once
#include <d3d9.h>
#include <math.h>
#define m_pi 3.1415926535

int center_x = GetSystemMetrics(0) / 2 - 3;
int center_y = GetSystemMetrics(1) / 2 - 3;

float Width, Height = 0.f;

class Vector3 {
public:
	Vector3() : x(0.f), y(0.f), z(0.f) {}
	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}
	~Vector3() {}

	float x;
	float y;
	float z;
	Vector3& operator+=(const Vector3& v) { x += v.x; y += v.y; z += v.z; return *this; }

	inline float Dot(Vector3 v) {
		return x * v.x + y * v.y + z * v.z;
	}

	inline float Distance(Vector3 v) {
		return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
	}

	Vector3 operator+(Vector3 v) {
		return Vector3(x + v.x, y + v.y, z + v.z);
	}

	Vector3 operator*(float factor) {
		return Vector3(x * factor, y * factor, z * factor);
	}

	Vector3 operator-(Vector3 v) {
		return Vector3(x - v.x, y - v.y, z - v.z);
	}

	inline float Length() {
		return sqrtf((x * x) + (y * y) + (z * z));
	}
	inline float Length2D() {
		return sqrtf((x * x) + (y * y));
	}

	Vector3 Clamp()
	{
		Vector3 clamped = { x, y, 0 };
		while (clamped.y < -180.0f)
			clamped.y += 360.0f;
		while (clamped.y > 180.0f)
			clamped.y -= 360.0f;
		while (clamped.x < -180.0f)
			clamped.x += 360.0f;
		while (clamped.x > 180.0f)
			clamped.x -= 360.0f;
		return clamped;
	}
	Vector3 ToRotator()
	{
		Vector3 rotator;
		rotator.x = -(float)atan(z / Length2D()) * (float)(180.0f / 3.14159265358979323846);
		rotator.y = (float)atan(y / x) * (float)(180.0f / 3.14159265358979323846);
		rotator.z = (float)0.f;
		if (x >= 0.f)
			rotator.y += 180.0f;
		return rotator;
	}

};

//ue4 fvector class
class fvector {
public:
	fvector() : x(0.f), y(0.f), z(0.f)
	{

	}

	fvector(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
	{

	}
	~fvector()
	{

	}

	float x;
	float y;
	float z;

	inline float Dot(fvector v) {
		return x * v.x + y * v.y + z * v.z;
	}

	inline fvector& operator-=(const fvector& v) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}

	inline fvector& operator+=(const fvector& v) {
		x += v.x; y += v.y; z += v.z; return *this;
	}

	inline fvector operator/(float v) const {
		return fvector(x / v, y / v, z / v);
	}

	inline float distance(fvector v) {
		return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
	}

	inline float lenght() {
		return sqrt(x * x + y * y + z * z);
	}

	bool operator==(fvector v) {
		return ((x == v.x) && (y == v.y) && (z == v.z));
	}

	fvector operator+(fvector v) {
		return fvector(x + v.x, y + v.y, z + v.z);
	}

	fvector operator-(fvector v) {
		return fvector(x - v.x, y - v.y, z - v.z);
	}

	fvector operator*(float v) {
		return fvector(x * v, y * v, z * v);
	}

	fvector operator/(float v) {
		return fvector(x / v, y / v, z / v);
	}
};

//ue4 fquat class
struct fquat {
	float x;
	float y;
	float z;
	float w;
};

//ue4 ftransform class
struct ftransform {
	fquat rot;
	fvector translation;
	char pad[4];
	fvector scale;
	char pad1[4];
	D3DMATRIX ToMatrixWithScale() {
		D3DMATRIX m;
		m._41 = translation.x;
		m._42 = translation.y;
		m._43 = translation.z;

		float x2 = rot.x + rot.x;
		float y2 = rot.y + rot.y;
		float z2 = rot.z + rot.z;

		float xx2 = rot.x * x2;
		float yy2 = rot.y * y2;
		float zz2 = rot.z * z2;
		m._11 = (1.0f - (yy2 + zz2)) * scale.x;
		m._22 = (1.0f - (xx2 + zz2)) * scale.y;
		m._33 = (1.0f - (xx2 + yy2)) * scale.z;

		float yz2 = rot.y * z2;
		float wx2 = rot.w * x2;
		m._32 = (yz2 - wx2) * scale.z;
		m._23 = (yz2 + wx2) * scale.y;

		float xy2 = rot.x * y2;
		float wz2 = rot.w * z2;
		m._21 = (xy2 - wz2) * scale.y;
		m._12 = (xy2 + wz2) * scale.x;

		float xz2 = rot.x * z2;
		float wy2 = rot.w * y2;
		m._31 = (xz2 + wy2) * scale.z;
		m._13 = (xz2 - wy2) * scale.x;

		m._14 = 0.0f;
		m._24 = 0.0f;
		m._34 = 0.0f;
		m._44 = 1.0f;

		return m;
	}
};

//boring copy pasta math shit

D3DMATRIX matrix(fvector rot, fvector origin = fvector(0, 0, 0)) {
	float radPitch = (rot.x * float(m_pi) / 180.f);
	float radYaw = (rot.y * float(m_pi) / 180.f);
	float radRoll = (rot.z * float(m_pi) / 180.f);

	float SP = sinf(radPitch);
	float CP = cosf(radPitch);
	float SY = sinf(radYaw);
	float CY = cosf(radYaw);
	float SR = sinf(radRoll);
	float CR = cosf(radRoll);

	D3DMATRIX matrix;
	matrix.m[0][0] = CP * CY;
	matrix.m[0][1] = CP * SY;
	matrix.m[0][2] = SP;
	matrix.m[0][3] = 0.f;

	matrix.m[1][0] = SR * SP * CY - CR * SY;
	matrix.m[1][1] = SR * SP * SY + CR * CY;
	matrix.m[1][2] = -SR * CP;
	matrix.m[1][3] = 0.f;

	matrix.m[2][0] = -(CR * SP * CY + SR * SY);
	matrix.m[2][1] = CY * SR - CR * SP * SY;
	matrix.m[2][2] = CR * CP;
	matrix.m[2][3] = 0.f;

	matrix.m[3][0] = origin.x;
	matrix.m[3][1] = origin.y;
	matrix.m[3][2] = origin.z;
	matrix.m[3][3] = 1.f;

	return matrix;
}

D3DMATRIX MatrixMultiplication(D3DMATRIX pM1, D3DMATRIX pM2)
{
	D3DMATRIX pOut;
	pOut._11 = pM1._11 * pM2._11 + pM1._12 * pM2._21 + pM1._13 * pM2._31 + pM1._14 * pM2._41;
	pOut._12 = pM1._11 * pM2._12 + pM1._12 * pM2._22 + pM1._13 * pM2._32 + pM1._14 * pM2._42;
	pOut._13 = pM1._11 * pM2._13 + pM1._12 * pM2._23 + pM1._13 * pM2._33 + pM1._14 * pM2._43;
	pOut._14 = pM1._11 * pM2._14 + pM1._12 * pM2._24 + pM1._13 * pM2._34 + pM1._14 * pM2._44;
	pOut._21 = pM1._21 * pM2._11 + pM1._22 * pM2._21 + pM1._23 * pM2._31 + pM1._24 * pM2._41;
	pOut._22 = pM1._21 * pM2._12 + pM1._22 * pM2._22 + pM1._23 * pM2._32 + pM1._24 * pM2._42;
	pOut._23 = pM1._21 * pM2._13 + pM1._22 * pM2._23 + pM1._23 * pM2._33 + pM1._24 * pM2._43;
	pOut._24 = pM1._21 * pM2._14 + pM1._22 * pM2._24 + pM1._23 * pM2._34 + pM1._24 * pM2._44;
	pOut._31 = pM1._31 * pM2._11 + pM1._32 * pM2._21 + pM1._33 * pM2._31 + pM1._34 * pM2._41;
	pOut._32 = pM1._31 * pM2._12 + pM1._32 * pM2._22 + pM1._33 * pM2._32 + pM1._34 * pM2._42;
	pOut._33 = pM1._31 * pM2._13 + pM1._32 * pM2._23 + pM1._33 * pM2._33 + pM1._34 * pM2._43;
	pOut._34 = pM1._31 * pM2._14 + pM1._32 * pM2._24 + pM1._33 * pM2._34 + pM1._34 * pM2._44;
	pOut._41 = pM1._41 * pM2._11 + pM1._42 * pM2._21 + pM1._43 * pM2._31 + pM1._44 * pM2._41;
	pOut._42 = pM1._41 * pM2._12 + pM1._42 * pM2._22 + pM1._43 * pM2._32 + pM1._44 * pM2._42;
	pOut._43 = pM1._41 * pM2._13 + pM1._42 * pM2._23 + pM1._43 * pM2._33 + pM1._44 * pM2._43;
	pOut._44 = pM1._41 * pM2._14 + pM1._42 * pM2._24 + pM1._43 * pM2._34 + pM1._44 * pM2._44;

	return pOut;
}
```

`xor.h`:

```h
#pragma once
#include <string>
#include <utility>

namespace
{
	constexpr int const_atoi(char c)
	{
		return c - '0';
	}
}

#ifdef _MSC_VER
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

#define _(str) XorStr(str).c_str()

template<typename _string_type, size_t _length>
class _Basic_XorStr
{
	using value_type = typename _string_type::value_type;
	static constexpr auto _length_minus_one = _length - 1;

public:
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length])
		: _Basic_XorStr(str, std::make_index_sequence<_length_minus_one>())
	{

	}

	inline auto c_str() const
	{
		decrypt();

		return data;
	}

	inline auto str() const
	{
		decrypt();

		return _string_type(data, data + _length_minus_one);
	}

	inline operator _string_type() const
	{
		return str();
	}

private:
	template<size_t... indices>
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length], std::index_sequence<indices...>)
		: data{ crypt(str[indices], indices)..., '\0' },
		encrypted(true)
	{

	}

	static constexpr auto XOR_KEY = static_cast<value_type>(
		const_atoi(__TIME__[7]) +
		const_atoi(__TIME__[6]) * 10 +
		const_atoi(__TIME__[4]) * 60 +
		const_atoi(__TIME__[3]) * 600 +
		const_atoi(__TIME__[1]) * 3600 +
		const_atoi(__TIME__[0]) * 36000
		);

	static ALWAYS_INLINE constexpr auto crypt(value_type c, size_t i)
	{
		return static_cast<value_type>(c ^ (XOR_KEY + i));
	}

	inline void decrypt() const
	{
		if (encrypted)
		{
			for (size_t t = 0; t < _length_minus_one; t++)
			{
				data[t] = crypt(data[t], t);
			}
			encrypted = false;
		}
	}

	mutable value_type data[_length];
	mutable bool encrypted;
};

template<size_t _length>
using XorStrA = _Basic_XorStr<std::string, _length>;
template<size_t _length>
using XorStrW = _Basic_XorStr<std::wstring, _length>;
template<size_t _length>
using XorStrU16 = _Basic_XorStr<std::u16string, _length>;
template<size_t _length>
using XorStrU32 = _Basic_XorStr<std::u32string, _length>;

template<typename _string_type, size_t _length, size_t _length2>
inline auto operator==(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	static_assert(_length == _length2, "XorStr== different length");

	return _length == _length2 && lhs.str() == rhs.str();
}

template<typename _string_type, size_t _length>
inline auto operator==(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs.size() == _length && lhs == rhs.str();
}

template<typename _stream_type, typename _string_type, size_t _length>
inline auto& operator<<(_stream_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	lhs << rhs.c_str();

	return lhs;
}

template<typename _string_type, size_t _length, size_t _length2>
inline auto operator+(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	return lhs.str() + rhs.str();
}

template<typename _string_type, size_t _length>
inline auto operator+(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs + rhs.str();
}

template<size_t _length>
constexpr ALWAYS_INLINE auto XorStr(char const (&str)[_length])
{
	return XorStrA<_length>(str);
}

template<size_t _length>
constexpr ALWAYS_INLINE auto XorStr(wchar_t const (&str)[_length])
{
	return XorStrW<_length>(str);
}

template<size_t _length>
constexpr ALWAYS_INLINE auto XorStr(char16_t const (&str)[_length])
{
	return XorStrU16<_length>(str);
}

template<size_t _length>
constexpr ALWAYS_INLINE auto XorStr(char32_t const (&str)[_length])
{
	return XorStrU32<_length>(str);
}
```