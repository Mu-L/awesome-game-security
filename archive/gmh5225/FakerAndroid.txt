Project Path: arc_gmh5225_FakerAndroid_2n6t3jk1

Source Tree:

```txt
arc_gmh5225_FakerAndroid_2n6t3jk1
├── CHINESE.md
├── LICENSE
├── README.md
├── bin
│   ├── FakerAndroid-AS
│   │   ├── build.gradle
│   │   ├── lib
│   │   │   └── dx-23.0.2.jar
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── com
│   │           │       └── fakerandroid
│   │           │           └── as
│   │           │               ├── FakerAndroidProgressIndicator.java
│   │           │               ├── OpenApkFileAction.java
│   │           │               ├── OpenProjectFileChooserDescriptorWithAsyncIcon.java
│   │           │               ├── ProjectPathDialog.form
│   │           │               ├── ProjectPathDialog.java
│   │           │               └── editor
│   │           │                   ├── DatEditor.java
│   │           │                   ├── DatEditorProvider.java
│   │           │                   ├── DatFileSystem.java
│   │           │                   ├── DatFileType.java
│   │           │                   ├── DatViewPanel.form
│   │           │                   ├── DatViewPanel.java
│   │           │                   └── TmpEditor.java
│   │           ├── kotlin
│   │           │   └── org
│   │           │       └── ollide
│   │           │           └── java2smali
│   │           │               ├── Class2DexHelper.kt
│   │           │               ├── Dex2SmaliHelper.kt
│   │           │               ├── DexCompiler.kt
│   │           │               ├── GenerateAction.kt
│   │           │               └── SupportProjectTaskManager.kt
│   │           └── resources
│   │               └── META-INF
│   │                   ├── plugin.xml
│   │                   └── pluginIcon.svg
│   ├── FakerAndroid-cli
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           └── java
│   │               └── com
│   │                   └── fakerandroid
│   │                       └── decoder
│   │                           └── Main.java
│   └── FakerAndroid-gui
│       ├── build.gradle
│       └── src
│           └── main
│               ├── java
│               │   ├── FakerAndroidGui.java
│               │   └── FilechooserController.java
│               └── resources
│                   └── FileChooser.fxml
├── build.gradle
├── controller
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── fakerandroid
│       │               └── decoder
│       │                   ├── api
│       │                   │   ├── AndroidProject.java
│       │                   │   ├── Apk.java
│       │                   │   └── Transfer.java
│       │                   ├── conversation
│       │                   │   └── SupportConversation.java
│       │                   ├── pipeline
│       │                   │   ├── Context.java
│       │                   │   ├── Conversation.java
│       │                   │   ├── Transform.java
│       │                   │   ├── TransformInput.java
│       │                   │   ├── TransformInvocation.java
│       │                   │   ├── TransformManager.java
│       │                   │   └── TransformStream.java
│       │                   └── transforms
│       │                       ├── DexToJar.java
│       │                       ├── DexToSmali.java
│       │                       ├── Il2cppDumper.java
│       │                       ├── Project.java
│       │                       ├── ResourceProcesser.java
│       │                       ├── RuntimeBaseMerge.java
│       │                       └── RuntimeIl2cppMerge.java
│       └── test
│           └── java
│               └── com
│                   └── fakerandroid
│                       └── decoder
│                           ├── TestDistribution.java
│                           └── TestProject.java
├── distribution
│   ├── apktool
│   │   ├── brut.apktool
│   │   │   ├── apktool-cli
│   │   │   │   ├── build.gradle
│   │   │   │   └── src
│   │   │   │       └── main
│   │   │   │           └── java
│   │   │   │               └── brut
│   │   │   │                   └── apktool
│   │   │   │                       └── Main.java
│   │   │   └── apktool-lib
│   │   │       ├── build.gradle
│   │   │       └── src
│   │   │           ├── main
│   │   │           │   ├── java
│   │   │           │   │   ├── android
│   │   │           │   │   │   ├── content
│   │   │           │   │   │   │   └── res
│   │   │           │   │   │   │       └── XmlResourceParser.java
│   │   │           │   │   │   └── util
│   │   │           │   │   │       ├── AttributeSet.java
│   │   │           │   │   │       └── TypedValue.java
│   │   │           │   │   ├── brut
│   │   │           │   │   │   └── androlib
│   │   │           │   │   │       ├── Androlib.java
│   │   │           │   │   │       ├── AndrolibException.java
│   │   │           │   │   │       ├── ApkDecoder.java
│   │   │           │   │   │       ├── ApkOptions.java
│   │   │           │   │   │       ├── ApktoolProperties.java
│   │   │           │   │   │       ├── err
│   │   │           │   │   │       │   ├── AXmlDecodingException.java
│   │   │           │   │   │       │   ├── CantFind9PatchChunkException.java
│   │   │           │   │   │       │   ├── CantFindFrameworkResException.java
│   │   │           │   │   │       │   ├── InFileNotFoundException.java
│   │   │           │   │   │       │   ├── OutDirExistsException.java
│   │   │           │   │   │       │   ├── RawXmlEncounteredException.java
│   │   │           │   │   │       │   └── UndefinedResObjectException.java
│   │   │           │   │   │       ├── meta
│   │   │           │   │   │       │   ├── MetaInfo.java
│   │   │           │   │   │       │   ├── PackageInfo.java
│   │   │           │   │   │       │   ├── StringExConstructor.java
│   │   │           │   │   │       │   ├── StringExRepresent.java
│   │   │           │   │   │       │   ├── UsesFramework.java
│   │   │           │   │   │       │   ├── VersionInfo.java
│   │   │           │   │   │       │   └── YamlStringEscapeUtils.java
│   │   │           │   │   │       ├── mod
│   │   │           │   │   │       │   └── SmaliMod.java
│   │   │           │   │   │       ├── res
│   │   │           │   │   │       │   ├── AndrolibResources.java
│   │   │           │   │   │       │   ├── data
│   │   │           │   │   │       │   │   ├── ResConfigFlags.java
│   │   │           │   │   │       │   │   ├── ResID.java
│   │   │           │   │   │       │   │   ├── ResPackage.java
│   │   │           │   │   │       │   │   ├── ResResSpec.java
│   │   │           │   │   │       │   │   ├── ResResource.java
│   │   │           │   │   │       │   │   ├── ResTable.java
│   │   │           │   │   │       │   │   ├── ResType.java
│   │   │           │   │   │       │   │   ├── ResTypeSpec.java
│   │   │           │   │   │       │   │   ├── ResUnknownFiles.java
│   │   │           │   │   │       │   │   ├── ResValuesFile.java
│   │   │           │   │   │       │   │   ├── UnicodeUtils.kt
│   │   │           │   │   │       │   │   └── value
│   │   │           │   │   │       │   │       ├── ResArrayValue.java
│   │   │           │   │   │       │   │       ├── ResAttr.java
│   │   │           │   │   │       │   │       ├── ResBagValue.java
│   │   │           │   │   │       │   │       ├── ResBoolValue.java
│   │   │           │   │   │       │   │       ├── ResColorValue.java
│   │   │           │   │   │       │   │       ├── ResDimenValue.java
│   │   │           │   │   │       │   │       ├── ResEmptyValue.java
│   │   │           │   │   │       │   │       ├── ResEnumAttr.java
│   │   │           │   │   │       │   │       ├── ResFileValue.java
│   │   │           │   │   │       │   │       ├── ResFlagsAttr.java
│   │   │           │   │   │       │   │       ├── ResFloatValue.java
│   │   │           │   │   │       │   │       ├── ResFractionValue.java
│   │   │           │   │   │       │   │       ├── ResIdValue.java
│   │   │           │   │   │       │   │       ├── ResIntBasedValue.java
│   │   │           │   │   │       │   │       ├── ResIntValue.java
│   │   │           │   │   │       │   │       ├── ResPluralsValue.java
│   │   │           │   │   │       │   │       ├── ResReferenceValue.java
│   │   │           │   │   │       │   │       ├── ResScalarValue.java
│   │   │           │   │   │       │   │       ├── ResStringValue.java
│   │   │           │   │   │       │   │       ├── ResStyleValue.java
│   │   │           │   │   │       │   │       ├── ResValue.java
│   │   │           │   │   │       │   │       └── ResValueFactory.java
│   │   │           │   │   │       │   ├── decoder
│   │   │           │   │   │       │   │   ├── ARSCDecoder.java
│   │   │           │   │   │       │   │   ├── AXmlResourceParser.java
│   │   │           │   │   │       │   │   ├── Res9patchStreamDecoder.java
│   │   │           │   │   │       │   │   ├── ResAttrDecoder.java
│   │   │           │   │   │       │   │   ├── ResFileDecoder.java
│   │   │           │   │   │       │   │   ├── ResRawStreamDecoder.java
│   │   │           │   │   │       │   │   ├── ResStreamDecoder.java
│   │   │           │   │   │       │   │   ├── ResStreamDecoderContainer.java
│   │   │           │   │   │       │   │   ├── StringBlock.java
│   │   │           │   │   │       │   │   └── XmlPullStreamDecoder.java
│   │   │           │   │   │       │   ├── util
│   │   │           │   │   │       │   │   ├── ExtFile.java
│   │   │           │   │   │       │   │   ├── ExtMXSerializer.java
│   │   │           │   │   │       │   │   └── ExtXmlSerializer.java
│   │   │           │   │   │       │   └── xml
│   │   │           │   │   │       │       ├── ResValuesXmlSerializable.java
│   │   │           │   │   │       │       ├── ResXmlEncodable.java
│   │   │           │   │   │       │       ├── ResXmlEncoders.java
│   │   │           │   │   │       │       └── ResXmlPatcher.java
│   │   │           │   │   │       └── src
│   │   │           │   │   │           ├── SmaliBuilder.java
│   │   │           │   │   │           └── SmaliDecoder.java
│   │   │           │   │   ├── com
│   │   │           │   │   │   └── fakerandroid
│   │   │           │   │   │       └── decoder
│   │   │           │   │   │           └── apktool
│   │   │           │   │   │               └── Resources.java
│   │   │           │   │   └── org
│   │   │           │   │       └── xmlpull
│   │   │           │   │           └── renamed
│   │   │           │   │               └── MXSerializer.java
│   │   │           │   └── resources
│   │   │           │       ├── brut
│   │   │           │       │   └── androlib
│   │   │           │       │       └── android-framework.jar
│   │   │           │       └── properties
│   │   │           │           └── apktool.properties
│   │   │           └── test
│   │   │               ├── java
│   │   │               │   └── brut
│   │   │               │       └── androlib
│   │   │               │           ├── BaseTest.java
│   │   │               │           ├── TestUtils.java
│   │   │               │           ├── aapt1
│   │   │               │           │   ├── AndroidOreoNotSparseTest.java
│   │   │               │           │   ├── AndroidOreoSparseTest.java
│   │   │               │           │   ├── BuildAndDecodeJarTest.java
│   │   │               │           │   ├── BuildAndDecodeTest.java
│   │   │               │           │   ├── DebugTagRetainedTest.java
│   │   │               │           │   ├── DefaultBaksmaliVariableTest.java
│   │   │               │           │   ├── EmptyResourcesArscTest.java
│   │   │               │           │   ├── LargeIntsInManifestTest.java
│   │   │               │           │   ├── ProviderAttributeTest.java
│   │   │               │           │   ├── ReferenceVersionCodeTest.java
│   │   │               │           │   ├── SharedLibraryTest.java
│   │   │               │           │   ├── SkipAssetTest.java
│   │   │               │           │   └── UnknownCompressionTest.java
│   │   │               │           ├── aapt2
│   │   │               │           │   ├── BuildAndDecodeTest.java
│   │   │               │           │   ├── DebuggableFalseChangeToTrueTest.java
│   │   │               │           │   ├── DebuggableTrueAddedTest.java
│   │   │               │           │   ├── DebuggableTrueRetainedTest.java
│   │   │               │           │   └── NonStandardPkgIdTest.java
│   │   │               │           ├── androlib
│   │   │               │           │   └── InvalidSdkBoundingTest.java
│   │   │               │           ├── decode
│   │   │               │           │   ├── AndResGuardTest.java
│   │   │               │           │   ├── DecodeArrayTest.java
│   │   │               │           │   ├── DecodeKotlinCoroutinesTest.java
│   │   │               │           │   ├── DecodeKotlinTest.java
│   │   │               │           │   ├── DoubleExtensionUnknownFileTest.java
│   │   │               │           │   ├── DuplicateDexTest.java
│   │   │               │           │   ├── Empty9PatchTest.java
│   │   │               │           │   ├── ExternalEntityTest.java
│   │   │               │           │   ├── ForceManifestDecodeNoResourcesTest.java
│   │   │               │           │   ├── MinifiedArscTest.java
│   │   │               │           │   ├── MissingDiv9PatchTest.java
│   │   │               │           │   ├── MissingVersionManifestTest.java
│   │   │               │           │   ├── OutsideOfDirectoryEntryTest.java
│   │   │               │           │   ├── ParentDirectoryTraversalTest.java
│   │   │               │           │   └── VectorDrawableTest.java
│   │   │               │           ├── encoders
│   │   │               │           │   └── PositionalEnumerationTest.java
│   │   │               │           └── util
│   │   │               │               ├── AaptVersionTest.java
│   │   │               │               └── UnknownDirectoryTraversalTest.java
│   │   │               └── resources
│   │   │                   ├── aapt1
│   │   │                   │   ├── issue1234
│   │   │                   │   │   └── issue1234.apk
│   │   │                   │   ├── issue1235
│   │   │                   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   ├── apktool.yml
│   │   │                   │   │   └── res
│   │   │                   │   │       └── values
│   │   │                   │   │           └── strings.xml
│   │   │                   │   ├── issue1481
│   │   │                   │   │   ├── apktool.yml
│   │   │                   │   │   └── smali
│   │   │                   │   │       └── com
│   │   │                   │   │           └── ibotpeaches
│   │   │                   │   │               └── issue1481
│   │   │                   │   │                   └── BuildConfig.smali
│   │   │                   │   ├── issue1594
│   │   │                   │   │   ├── not_sparse.apk
│   │   │                   │   │   └── sparse.apk
│   │   │                   │   ├── issue1605
│   │   │                   │   │   └── issue1605.apk
│   │   │                   │   ├── issue1730
│   │   │                   │   │   └── issue1730.apk
│   │   │                   │   ├── issue636
│   │   │                   │   │   └── issue636.apk
│   │   │                   │   ├── issue767
│   │   │                   │   │   └── issue767.apk
│   │   │                   │   ├── shared_libraries
│   │   │                   │   │   ├── client.apk
│   │   │                   │   │   └── library.apk
│   │   │                   │   ├── testapp
│   │   │                   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   ├── apktool.yml
│   │   │                   │   │   ├── assets
│   │   │                   │   │   │   ├── 0byte_file.jpg
│   │   │                   │   │   │   ├── txt
│   │   │                   │   │   │   │   └── no-unicode.txt
│   │   │                   │   │   │   └── unicode-txt
│   │   │                   │   │   │       └── ∂-unicode.txt
│   │   │                   │   │   ├── kotlin
│   │   │                   │   │   │   └── kotlin.kotlin_builtins
│   │   │                   │   │   ├── lib
│   │   │                   │   │   │   └── android-support-v13.jar
│   │   │                   │   │   ├── libs
│   │   │                   │   │   │   └── android-support-v13.jar
│   │   │                   │   │   ├── res
│   │   │                   │   │   │   ├── drawable-534dpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-anydpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-hdpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-ldpi
│   │   │                   │   │   │   │   ├── data.jpg
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-mdpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-nodpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-tvdpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-xhdpi
│   │   │                   │   │   │   │   ├── 9patch.9.png
│   │   │                   │   │   │   │   ├── 9patch_htc.r.9.png
│   │   │                   │   │   │   │   ├── 9patch_samsung.9.qmg
│   │   │                   │   │   │   │   ├── btn_zoom_up_normal.9.png
│   │   │                   │   │   │   │   ├── ic_launcher.png
│   │   │                   │   │   │   │   └── ic_launcher_samsung.qmg
│   │   │                   │   │   │   ├── drawable-xxhdpi
│   │   │                   │   │   │   │   ├── ic_launcher.png
│   │   │                   │   │   │   │   ├── ic_notification_overlay.9.png
│   │   │                   │   │   │   │   ├── recents_lower_gradient.9.png
│   │   │                   │   │   │   │   ├── screenshot_panel.9.png
│   │   │                   │   │   │   │   ├── search_bg_transparent.9.png
│   │   │                   │   │   │   │   ├── status_background.9.png
│   │   │                   │   │   │   │   └── textfield_activated_holo_dark.9.png
│   │   │                   │   │   │   ├── drawable-xxhdpi-v4
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── drawable-xxxhdpi
│   │   │                   │   │   │   │   └── ic_launcher.png
│   │   │                   │   │   │   ├── font
│   │   │                   │   │   │   │   ├── lobster.xml
│   │   │                   │   │   │   │   └── lobster_regular.otf
│   │   │                   │   │   │   ├── layout
│   │   │                   │   │   │   │   ├── issue1040.xml
│   │   │                   │   │   │   │   ├── issue1063.xml
│   │   │                   │   │   │   │   ├── issue1130.xml
│   │   │                   │   │   │   │   ├── issue1157.xml
│   │   │                   │   │   │   │   ├── issue1274.xml
│   │   │                   │   │   │   │   └── issue1674.xml
│   │   │                   │   │   │   ├── raw
│   │   │                   │   │   │   │   ├── blank_test.png
│   │   │                   │   │   │   │   ├── no_extension
│   │   │                   │   │   │   │   └── rain.mp3
│   │   │                   │   │   │   ├── values
│   │   │                   │   │   │   │   ├── attrs.xml
│   │   │                   │   │   │   │   ├── ids.xml
│   │   │                   │   │   │   │   ├── integers.xml
│   │   │                   │   │   │   │   ├── public.xml
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-ar-rXB
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-ast
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-ast-rES
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-b+ast+Latn+IT+AREVELA
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-b+en+Latn+419
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-b+en+Latn+US
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-b+en+US+POSIX
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-b+eng+419
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-en
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-en-rUS
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-fr
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-ldrtl
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-lowdr-v26
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc001
│   │   │                   │   │   │   │   ├── anims.xml
│   │   │                   │   │   │   │   ├── arrays.xml
│   │   │                   │   │   │   │   ├── bools.xml
│   │   │                   │   │   │   │   ├── colors.xml
│   │   │                   │   │   │   │   ├── dimens.xml
│   │   │                   │   │   │   │   ├── drawables.xml
│   │   │                   │   │   │   │   ├── ids.xml
│   │   │                   │   │   │   │   ├── integers.xml
│   │   │                   │   │   │   │   ├── layouts.xml
│   │   │                   │   │   │   │   ├── plurals.xml
│   │   │                   │   │   │   │   ├── strings.xml
│   │   │                   │   │   │   │   └── styles.xml
│   │   │                   │   │   │   ├── values-mcc001-mnc00
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc001-mnc1
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc002
│   │   │                   │   │   │   │   ├── arrays.xml
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc003
│   │   │                   │   │   │   │   ├── arrays.xml
│   │   │                   │   │   │   │   ├── bools.xml
│   │   │                   │   │   │   │   ├── integers.xml
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc238-mnc6
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mcc238-mnc870
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-mnc1
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-notround
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-nowidecg-v26
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-round
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-vrheadset-v26
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-watch
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   ├── values-widecg-v26
│   │   │                   │   │   │   │   └── strings.xml
│   │   │                   │   │   │   └── xml
│   │   │                   │   │   │       ├── literals.xml
│   │   │                   │   │   │       ├── references.xml
│   │   │                   │   │   │       └── ww_box_styles_schema.xsd
│   │   │                   │   │   ├── smali
│   │   │                   │   │   │   └── HelloWorld.smali
│   │   │                   │   │   ├── smali_classes2
│   │   │                   │   │   │   └── HelloDualDexSupport.smali
│   │   │                   │   │   ├── smali_classes3
│   │   │                   │   │   │   └── HelloTripleDexSupport.smali
│   │   │                   │   │   └── unknown
│   │   │                   │   │       ├── hidden.file
│   │   │                   │   │       ├── lib_bug603
│   │   │                   │   │       │   └── bug603
│   │   │                   │   │       ├── nonprintable.file
│   │   │                   │   │       ├── stored.file
│   │   │                   │   │       └── unk_folder
│   │   │                   │   │           └── unknown_file
│   │   │                   │   ├── testjar
│   │   │                   │   │   ├── apktool.yml
│   │   │                   │   │   ├── original
│   │   │                   │   │   │   └── META-INF
│   │   │                   │   │   │       └── MANIFEST.MF
│   │   │                   │   │   └── smali
│   │   │                   │   │       └── com
│   │   │                   │   │           └── apktool
│   │   │                   │   │               └── test
│   │   │                   │   │                   └── Test.smali
│   │   │                   │   └── unknown_compression
│   │   │                   │       └── deflated_unknowns.apk
│   │   │                   ├── aapt2
│   │   │                   │   ├── issue2328
│   │   │                   │   │   ├── debuggable-false
│   │   │                   │   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   │   ├── apktool.yml
│   │   │                   │   │   │   └── res
│   │   │                   │   │   │       └── values
│   │   │                   │   │   │           └── strings.xml
│   │   │                   │   │   ├── debuggable-missing
│   │   │                   │   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   │   ├── apktool.yml
│   │   │                   │   │   │   └── res
│   │   │                   │   │   │       └── values
│   │   │                   │   │   │           └── strings.xml
│   │   │                   │   │   └── debuggable-true
│   │   │                   │   │       ├── AndroidManifest.xml
│   │   │                   │   │       ├── apktool.yml
│   │   │                   │   │       └── res
│   │   │                   │   │           └── values
│   │   │                   │   │               └── strings.xml
│   │   │                   │   ├── pkgid8
│   │   │                   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   ├── apktool.yml
│   │   │                   │   │   └── res
│   │   │                   │   │       └── values
│   │   │                   │   │           ├── integers.xml
│   │   │                   │   │           ├── public.xml
│   │   │                   │   │           └── strings.xml
│   │   │                   │   └── testapp
│   │   │                   │       ├── AndroidManifest.xml
│   │   │                   │       ├── apktool.yml
│   │   │                   │       ├── assets
│   │   │                   │       │   └── 0byte_file.jpg
│   │   │                   │       ├── res
│   │   │                   │       │   ├── drawable
│   │   │                   │       │   │   ├── $avd_hide_password__0.xml
│   │   │                   │       │   │   ├── $avd_show_password__0.xml
│   │   │                   │       │   │   ├── $avd_show_password__1.xml
│   │   │                   │       │   │   ├── $avd_show_password__2.xml
│   │   │                   │       │   │   └── avd_show_password.xml
│   │   │                   │       │   ├── drawable-xhdpi
│   │   │                   │       │   │   └── ic_launcher_samsung.qmg
│   │   │                   │       │   ├── navigation
│   │   │                   │       │   │   └── nav_graph.xml
│   │   │                   │       │   ├── values
│   │   │                   │       │   │   ├── attrs.xml
│   │   │                   │       │   │   ├── ids.xml
│   │   │                   │       │   │   └── strings.xml
│   │   │                   │       │   ├── values-es
│   │   │                   │       │   │   └── strings.xml
│   │   │                   │       │   └── xml
│   │   │                   │       │       └── ww_box_styles_schema.xsd
│   │   │                   │       ├── smali
│   │   │                   │       │   └── HelloWorld.smali
│   │   │                   │       ├── smali_classes2
│   │   │                   │       │   └── HelloDualDexSupport.smali
│   │   │                   │       └── smali_classes3
│   │   │                   │           └── HelloTripleDexSupport.smali
│   │   │                   ├── decode
│   │   │                   │   ├── doctype
│   │   │                   │   │   ├── AndroidManifest.xml
│   │   │                   │   │   └── apktool.yml
│   │   │                   │   ├── duplicatedex
│   │   │                   │   │   └── duplicatedex.apk
│   │   │                   │   ├── empty9patch
│   │   │                   │   │   └── empty9patch.apk
│   │   │                   │   ├── issue1157
│   │   │                   │   │   └── issue1157.apk
│   │   │                   │   ├── issue1170
│   │   │                   │   │   └── issue1170.apk
│   │   │                   │   ├── issue1244
│   │   │                   │   │   └── issue1244.apk
│   │   │                   │   ├── issue1264
│   │   │                   │   │   └── issue1264.apk
│   │   │                   │   ├── issue1456
│   │   │                   │   │   └── issue1456.apk
│   │   │                   │   ├── issue1498
│   │   │                   │   │   └── issue1498.apk
│   │   │                   │   ├── issue1522
│   │   │                   │   │   └── pip_dismiss_scrim.9.png
│   │   │                   │   ├── issue1589
│   │   │                   │   │   └── issue1589.apk
│   │   │                   │   ├── issue1680
│   │   │                   │   │   └── issue1680.apk
│   │   │                   │   ├── issue1994
│   │   │                   │   │   └── issue1994.apk
│   │   │                   │   ├── kotlin-coroutines
│   │   │                   │   │   └── test-kotlin-coroutines.apk
│   │   │                   │   └── testkotlin
│   │   │                   │       └── testkotlin.apk
│   │   │                   └── util
│   │   │                       └── traversal
│   │   │                           └── file
│   │   ├── brut.j.common
│   │   │   ├── build.gradle
│   │   │   └── src
│   │   │       ├── main
│   │   │       │   └── java
│   │   │       │       └── brut
│   │   │       │           └── common
│   │   │       │               ├── BrutException.java
│   │   │       │               ├── InvalidUnknownFileException.java
│   │   │       │               ├── RootUnknownFileException.java
│   │   │       │               └── TraversalUnknownFileException.java
│   │   │       └── templates
│   │   │           └── apache2.0-header.txt
│   │   ├── brut.j.dir
│   │   │   ├── build.gradle
│   │   │   └── src
│   │   │       └── main
│   │   │           └── java
│   │   │               └── brut
│   │   │                   └── directory
│   │   │                       ├── AbstractDirectory.java
│   │   │                       ├── DirUtil.java
│   │   │                       ├── Directory.java
│   │   │                       ├── DirectoryException.java
│   │   │                       ├── ExtFile.java
│   │   │                       ├── FileDirectory.java
│   │   │                       ├── PathAlreadyExists.java
│   │   │                       ├── PathNotExist.java
│   │   │                       ├── ZipRODirectory.java
│   │   │                       └── ZipUtils.java
│   │   └── brut.j.util
│   │       ├── build.gradle
│   │       └── src
│   │           └── main
│   │               └── java
│   │                   └── brut
│   │                       └── util
│   │                           ├── AaptManager.java
│   │                           ├── BrutIO.java
│   │                           ├── DataInputDelegate.java
│   │                           ├── Duo.java
│   │                           ├── ExtDataInput.java
│   │                           ├── Jar.java
│   │                           ├── OS.java
│   │                           └── OSDetection.java
│   ├── dex2jar
│   │   ├── build.gradle
│   │   ├── libs
│   │   │   ├── ST4-4.0.8.jar
│   │   │   ├── antlr-3.5.2.jar
│   │   │   ├── antlr-runtime-3.5.2.jar
│   │   │   ├── antlr4-4.5.jar
│   │   │   ├── antlr4-runtime-4.5.jar
│   │   │   ├── asm-debug-all-5.0.3.jar
│   │   │   ├── d2j-base-cmd-2.1-SNAPSHOT.jar
│   │   │   ├── d2j-jasmin-2.1-SNAPSHOT.jar
│   │   │   ├── d2j-smali-2.1-SNAPSHOT.jar
│   │   │   ├── dex-ir-2.1-SNAPSHOT.jar
│   │   │   ├── dex-reader-2.1-SNAPSHOT.jar
│   │   │   ├── dex-reader-api-2.1-SNAPSHOT.jar
│   │   │   ├── dex-tools-2.1-SNAPSHOT.jar
│   │   │   ├── dex-translator-2.1-SNAPSHOT.jar
│   │   │   ├── dex-writer-2.1-SNAPSHOT.jar
│   │   │   ├── dx-27.0.3.jar
│   │   │   ├── open-source-license.txt
│   │   │   └── org.abego.treelayout.core-1.0.1.jar
│   │   └── src
│   │       └── main
│   │           └── java
│   │               └── com
│   │                   └── fakerandroid
│   │                       └── decoder
│   │                           └── dex2jar
│   │                               ├── Dex2jar.java
│   │                               ├── PatchDex2jar.java
│   │                               └── PatchMultiDexFileReader.java
│   ├── il2cpp-dumper
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── com
│   │           │       └── fakerandroid
│   │           │           └── decoder
│   │           │               └── il2cpp
│   │           │                   └── Il2cppBinary.java
│   │           └── resources
│   │               └── prebuilt
│   │                   ├── linux
│   │                   │   └── il2cpp
│   │                   ├── macosx
│   │                   │   └── il2cpp
│   │                   └── windows
│   │                       └── il2cpp.exe
│   ├── project
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── com
│   │           │       └── fakerandroid
│   │           │           └── decoder
│   │           │               └── project
│   │           │                   └── ProjectMerge.java
│   │           └── resources
│   │               └── project
│   │                   ├── app
│   │                   │   └── build.gradle.tmpl
│   │                   ├── build.gradle.tmpl
│   │                   ├── gradle
│   │                   │   └── wrapper
│   │                   │       ├── gradle-wrapper.jar.tmpl
│   │                   │       └── gradle-wrapper.properties.tmpl
│   │                   ├── gradle.properties.tmpl
│   │                   ├── gradlew.bat.tmpl
│   │                   ├── gradlew.tmpl
│   │                   └── settings.gradle.tmpl
│   ├── runtime-base
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── com
│   │           │       └── fakerandroid
│   │           │           └── decoder
│   │           │               └── runtime
│   │           │                   └── base
│   │           │                       └── RuntimeBase.java
│   │           └── resources
│   │               ├── libs
│   │               │   └── java
│   │               │       └── note.txt
│   │               └── template
│   │                   ├── cpp
│   │                   │   ├── CMakeLists.txt.tmpl
│   │                   │   ├── common.h.tmpl
│   │                   │   ├── include
│   │                   │   │   └── faker.h.tmpl
│   │                   │   └── native-lib.cpp.tmpl
│   │                   └── java
│   │                       └── com
│   │                           └── fakerandroid
│   │                               └── boot
│   │                                   ├── FakerActivity.java.tmpl
│   │                                   ├── FakerApp.java.tmpl
│   │                                   ├── JniBridge.java.tmpl
│   │                                   └── Logger.java.tmpl
│   ├── runtime-il2cpp
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── java
│   │           │   └── com
│   │           │       └── fakerandroid
│   │           │           └── decoder
│   │           │               └── rutime
│   │           │                   └── il2cpp
│   │           │                       └── RuntimeIl2cpp.java
│   │           └── resources
│   │               └── il2cpp-template
│   │                   ├── cpp
│   │                   │   ├── CMakeLists.txt.tmpl
│   │                   │   └── native-lib.cpp.tmpl
│   │                   ├── java
│   │                   │   └── com
│   │                   │       └── fakerandroid
│   │                   │           └── boot
│   │                   │               └── FakerActivity.java.tmpl
│   │                   └── scaffolding-cpp
│   │                       ├── MonoString.cpp.tmpl
│   │                       ├── MonoString.h.tmpl
│   │                       ├── il2cpp-appdata.h.tmpl
│   │                       ├── il2cpp-init.cpp.tmpl
│   │                       └── il2cpp-init.h.tmpl
│   └── smali
│       ├── build.gradle
│       ├── settings.gradle
│       └── src
│           └── main
│               └── java
│                   └── com
│                       └── fakerandroid
│                           └── decoder
│                               └── smali
│                                   ├── DexToSmaliException.java
│                                   └── SmaliDecoder.java
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── library
│   ├── build.gradle
│   └── src
│       └── main
│           └── java
│               └── com
│                   └── fakerandroid
│                       └── decoder
│                           ├── exception
│                           │   ├── BinaryException.java
│                           │   ├── DexToSmaliException.java
│                           │   ├── FakerAndroidException.java
│                           │   └── FileException.java
│                           └── util
│                               ├── FileUtils.java
│                               ├── Jar.java
│                               ├── ManifestEditor.java
│                               ├── OS.java
│                               ├── OSDetection.java
│                               ├── PatchUtil.java
│                               ├── TestUtils.java
│                               └── TextUtil.java
└── settings.gradle

```

`CHINESE.md`:

```md
# FakerAndroid
A tool translate apk file to common android project and support so hook and include il2cpp c++ scaffolding when apk is a il2cpp game apk
## 简介
- 优雅地在一个Apk上写代码
- 直接将Apk文件转换为可以进行二次开发的Android项目的工具,支持so hook,对于il2cpp的游戏apk直接生成il2cpp c++脚手架
- 将痛苦的逆向环境，转化为舒服的开发环境，告别汇编，告别二进制，还有啥好说的~~ 
## 特点

- 提供Java层代码覆盖及继承替换的脚手架，实现java与smali混编
- 提供so函数Hook Api
- 对于il2cpp的游戏apk直接生成il2cpp c++脚手架
- Java层标准的对原有Java api的AndroidStudio编码提示
- Smali文件修改后运行或打包时自动回编译（AndroidStudio project 文件树模式下可以直接找到smali文件，支持对smali修改，最小文件数增量编译）
- 对于il2cpp的游戏apk,标准的Jni对原有il2cpp脚本的编码提示
- 无限的可能性和扩展性,能干啥你说了算~
- Dex折叠，对敏感已经存在或后续接入的代码进行隐藏规避静态分析
### 运行环境
- Java(18)
- Il2cpp游戏ApkC++脚手架生成需要.Net环境支持（[MAC和Linux用户需要自己手动安装](https://dotnet.microsoft.com/download/dotnet/5.0)）
### 使用方式
- 下载[FakerAndroid.jar](https://github.com/Efaker/FakerAndroid/releases)(2022/03/30/23:53:00)
- cmd命令行 ```cd <FakerAndroid.jar平级目录>``` 
- cmd命令行 ```java -jar FakerAndroid.jar fk <apkpath>``` (项目生成路径与apk文件平级) 或 ```java -jar FakerAndroid.jar fk <apkpath> -o <outdir>```
- 例：```java -jar FakerAndroid.jar fk D:\apk\test.apk``` 或 ```java -jar FakerAndroid.jar fk D:\apk\test.apk -o D:\test```
### 或者使用方式
- 下载[FakerAndroid-AS.zip](https://github.com/Efaker/FakerAndroid/releases)(2022/03/30/23:53:00)
- AS->File-Settings->Plugin->SettingIcon->InstallPlugin Plugin From Disk->重启AndroidStudio
- AS->File->FakerAndroid->选择目标Apk文件


##### 1、打开项目
- Android studio直接打开工具生成的Android项目(第一次打开项目时间比较长，耐心点进度条没挂就是正常，另外搞台高配的PC哦)
- 保持跟目录build.gradle中依赖固定，请勿配置AndroidGradlePlugin，且项目配置NDk版本为21
- 存在已知缺陷，res下的部分资源文件编译不过，需要手动修复一下，部分Manifest标签无法编译需要手动修复  
（关于Res混淆手动实验了几个，如果遇到了这个问题，可以手动尝试，只要保证res/public.xml中的name对应的资源文件可以正常链路下去然后修复到可编译的程度，程序运行时一般是没有res问题，太完美的解决方案尚未完成）

##### 2、调试运行项目
- 连接测试机机
- Run项目
##### 3、进阶
- 类调用  
  借助javaScaffoding 在主模块（app/src/main/java)编写java代码对smali代码进行调用  
- 类替换      
  在主模块（app/src/main/java）直接编写Java类，类名与要替换的类的smali文件路径对应
- Smali 增量编译  
  你可以使用传统的smali修改方式对smali代码进行修改，且编译方式为最小文件数增量编译，smali文件修改后javascaffoding会同步，比如遇到final或private的java元素无法掉用时可以先修改smali(执行一次编译后javaScaffoding会同步)
- So Hook  
  借助FakeCpp 使用jni对so函数进行hook替换
- il2cpp unity游戏脚本二次开发  
  借助il2cpp Scaffolding 和FakeCpp,使用jni对原il2cpp游戏脚本进行Hook调用
- Dex折叠  
  build.gradle 配置sensitiveOptions用于隐藏敏感的dex代码，以规避静态分析，（Dex缓存原因在app版本号不变的情况使用第一次缓存，配置项调试请卸载后运行）
  
##### 4、正在路上
resources.arsc decode 兼容，目前混淆某些大型 apk Res decoder有问题  
各种不理想情况兼容
##### 5、遇到问题了？兄弟别走肯定能用，而且是你最佳的解决方案，咨询探讨
- [问题反馈](https://github.com/Efaker/FakerAndroid/issues)

##### 6、给个star?免费的           

##### 7、兼容性
1、目前某些大型的apk资做过资源文件混淆的会有问题！  
2、Google play 90% 游戏apk可以一马平川  
3、加固Apk需要先脱壳后才能,暴漏java api  
4、有自校验的Apk,须项目运行起来后自行检查破解  
5、Manifest莫名奇妙的问题，可以先尝试注释掉异常代码，逐步还原试试  
6、[Java OOM issue](https://github.com/Efaker/FakerAndroid/issues/17)  
7、AS打不开，试试Help->Change Memery Settings(搞大点)

## 实例
- 一夜之间来了这么多的star好慌张，全是问怎么用的，请原谅我只会写代码不会写文档啊！！！  
- 因为是il2cpp 游戏apk，里面包含了原游戏安装包和生成的代码项目所以比较大，下载的话得时间稍微长一点，如果github实在下不下来的话，直接QQ我索要
- [实例下载地址](https://github.com/Efaker/FakerAndroid-Demos/releases/tag/BasicDemo1)








        
        
        
        
        
      
                
 









```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Efaker
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# FakerAndroid ([FakerAndroid.jar or FakerAndroid-AS](https://github.com/Efaker/FakerAndroid/releases))

A tool translate a apk file to stantard android project include so hook api and il2cpp c++ scaffolding when apk is a unity il2cpp game.
## Summary
- Write code on a apk file elegantly.
- The Apk file can be directly converted into Android project for secondary development, supporting so hook. For the game of il2cpp, APK directly generates il2cpp C++ scaffolding
- What's more to say about transforming the painful reverse environment into a comfortable development environment, saying goodbye to assembly and binary~ 
## Feature
- Stantard AndroidStudio android project generated
- Original java class usage or cover it by compileable java code
- Hook Api offered for hooking .so method 
- When apk is a il2cpp game il2cpp c++ scaffoding generated
- Back compilation voluntary when there is a modification of smali files(AndroidStudio project file tree model)
- Unlimited possibilities and expansibility. You has the final say
### Environment
- Java(18)
- For Il2cpp Game Apk to generate il2cpp C++ scaffolding .Net environment needed ([Mac&Linux users handle it by yourself](https://dotnet.microsoft.com/download/dotnet/5.0)) 
### Usage 
- Download [FakerAndroid.jar](https://github.com/Efaker/FakerAndroid/releases)(2022/03/30/23:48:00)
- cmd ```cd <FakerAndroid.jar base dir>``` 
- cmd ```java -jar FakerAndroid.jar fk <apkpath>``` (project will be generated in the same dir of the orininal apk) or ```java -jar FakerAndroid.jar fk <apkpath> -o <outdir>```
- Demo```java -jar FakerAndroid.jar fk D:\apk\test.apk``` or ```java -jar FakerAndroid.jar fk D:\apk\test.apk -o D:\test```
### Or Usage 
- Download [FakerAndroid-AS.zip](https://github.com/Efaker/FakerAndroid/releases)(2022/03/30/23:48:00)
- AS->File-Settings->Plugin->SettingIcon->InstallPlugin Plugin From Disk->Restart As
- AS->File->FakerAndroid->Choose your apk file

### Secondary development course
##### 1、Open the project
- By Android studio File->open->```<generated project root>```
- Keep the root dir build.gradle file depends com.android.tools.build:gradle:3.4.0,don't upgrate or modify it
- Set project ndk base version 21 best
- A little modification will be needed by yourself when the res or AndroidManifest.xml can't pass the compiler 
##### 2、Debug or run the project
- With a testing machine conected
- Run 
##### 3、Advanced
- Original java class call  
  With the help of javaScaffoding write your java code to call original class in app moudle(app/src/main/java) 
- Original java class replacement      
  Write java code in moudle app（app/src/main/java）,keep the class name and package name corresponding same as the original class
- Smali increament building  
  When there is a smali files mod,there is a least files builing 
- So Hook  
  With the help of fakeCpp api use jni hook the so method
- Il2cpp unity script development  
  With the help of il2cpp Scaffolding and fakeCpp api,use jni have a modification of il2cpp game script

##### 4、Issues
- [Issues](https://github.com/Efaker/FakerAndroid/issues)

##### 5、Demo
- [DEMO](https://github.com/Efaker/FakerAndroid-Demos/releases/tag/1031)








        
        
        
        
        
      
                
 









```

`bin/FakerAndroid-AS/build.gradle`:

```gradle
buildscript {
    repositories {
//        jcenter()
        mavenCentral()
    }

    dependencies {
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.28.0'
    }
}

plugins {
    id 'org.jetbrains.intellij' version '0.4.18'
//    id 'org.jetbrains.kotlin.jvm' version kotlin_version
    id 'org.sonarqube' version '2.8'
}

apply plugin: 'com.github.ben-manes.versions'
apply plugin: 'org.jetbrains.intellij'
apply plugin: 'java'
apply plugin: 'kotlin'

repositories {
//    jcenter()
    mavenCentral()
}

dependencies {
    compile fileTree(dir: 'lib', include: '*.jar')
    compile 'org.jetbrains.kotlin:kotlin-stdlib-jdk8'
    compile 'org.smali:baksmali:2.4.0'
    implementation 'com.luhuiguo:chinese-utils:1.0'
    implementation project(':controller')
}

intellij {
    version = '2020.1.1'
    downloadSources false
    updateSinceUntilBuild false
    pluginName 'FakerAndroid'
//    sandboxDirectory = project.rootDir.canonicalPath + '/.sandbox'
//    publishPlugin {
//        token = System.getenv("ORG_GRADLE_PROJECT_intellijPublishToken")
//    }
    plugins = ['java']
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = '1.8'
        apiVersion = '1.2'
        languageVersion = '1.2'
    }
}

//sonarqube {
//    properties {
//        property "sonar.projectName", "FakerAndroid-Idea"
//        property "sonar.projectKey", "org.ollide:FakerAndroid-Idea"
//        property "sonar.sources", "src"
//        property "sonar.host.url", "https://sonarcloud.io"
//        property "sonar.organization", "ollide-github"
//        property "sonar.login", SONAR_TOKEN
//    }
//}

version = '1.0.37'

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/FakerAndroidProgressIndicator.java`:

```java
package com.fakerandroid.as;

import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.impl.BackgroundableProcessIndicator;
public class FakerAndroidProgressIndicator extends BackgroundableProcessIndicator {
    public FakerAndroidProgressIndicator(Task.Backgroundable task) {
        super(task);
    }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/OpenApkFileAction.java`:

```java
package com.fakerandroid.as;
import com.intellij.ide.GeneralSettings;
import com.intellij.ide.IdeBundle;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.fileChooser.*;
import com.intellij.openapi.project.DumbAwareAction;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.platform.PlatformProjectOpenProcessor;

import java.awt.*;
import java.io.File;
public class OpenApkFileAction extends DumbAwareAction {
    @Override
    public void actionPerformed(AnActionEvent e) {
        Disposable disposable = Disposer.newDisposable();
        try {
            Project project = e.getProject();
            boolean showFiles = project != null || PlatformProjectOpenProcessor.getInstanceIfItExists() != null;
            OpenProjectFileChooserDescriptorWithAsyncIcon descriptor =
                    showFiles ? new ProjectOrFileChooserDescriptor() : new ProjectOnlyFileChooserDescriptor();
            descriptor.putUserData(PathChooserDialog.PREFER_LAST_OVER_EXPLICIT, showFiles);
            Disposer.register(disposable, descriptor);
            VirtualFile explicitPreferredDirectory = ((project != null) && !project.isDefault()) ? project.getBaseDir() : null;
            if (explicitPreferredDirectory == null) {
                if (StringUtil.isNotEmpty(GeneralSettings.getInstance().getDefaultProjectDirectory())) {
                    explicitPreferredDirectory = VfsUtil.findFileByIoFile(new File(GeneralSettings.getInstance().getDefaultProjectDirectory()), true);
                }
                else {
                    explicitPreferredDirectory = VfsUtil.getUserHomeDir();
                }
            }
            // The chooseFiles method shows a FileChooserDialog and it doesn't return control until
            // a user closes the dialog.
            // Note: this method is invoked from the main thread but chooseFiles uses a nested message
            // loop to avoid the IDE from freeze.
            FileChooser.chooseFiles(descriptor, project, explicitPreferredDirectory, files -> {
                VirtualFile apk = files.get(0);
                if(!apk.getPath().endsWith(".apk")){
                    return;
                }
                ProjectPathDialog projectPathDialog = new ProjectPathDialog(project,true,apk);
                projectPathDialog.showAndGet();
            });
        } finally {
            Disposer.dispose(disposable);
        }
    }

    public OpenApkFileAction() {
    }

    public OpenApkFileAction(String text) {
        super(text);
    }

    private static class ProjectOnlyFileChooserDescriptor extends OpenProjectFileChooserDescriptorWithAsyncIcon {
        public ProjectOnlyFileChooserDescriptor() {
            setTitle(IdeBundle.message("title.open.project"));
        }
    }
    @Override
    public void update(AnActionEvent e) {
    }
    private static class ProjectOrFileChooserDescriptor extends OpenProjectFileChooserDescriptorWithAsyncIcon {
        private final FileChooserDescriptor myStandardDescriptor = FileChooserDescriptorFactory
                .createSingleFileNoJarsDescriptor().withHideIgnored(false);
        public ProjectOrFileChooserDescriptor() {
            setTitle(IdeBundle.message("title.open.file.or.project"));
        }

        @Override
        public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {
            return file.isDirectory() ? super.isFileVisible(file, showHiddenFiles) : myStandardDescriptor.isFileVisible(file, showHiddenFiles);
        }
        @Override
        public boolean isFileSelectable(VirtualFile file) {
            return file.isDirectory() ? super.isFileSelectable(file) : myStandardDescriptor.isFileSelectable(file);
        }
        @Override
        public boolean isChooseMultiple() {
            return false;
        }
    }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/OpenProjectFileChooserDescriptorWithAsyncIcon.java`:

```java
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.fakerandroid.as;

import com.google.common.collect.Maps;
import com.intellij.ide.actions.OpenProjectFileChooserDescriptor;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.util.IconUtil;
import java.util.Map;
import javax.swing.Icon;
/**
 * OpenProjectFileChooserDescriptorWithAsyncIcon is a customized open project file chooser with an
 * icon cache and async icon loading. The icon is chosen by a file type (extension, file, or
 * directory) by {@link IconUtil#getIcon(VirtualFile, int, Project)} then asynchronously be updated
 * to {@link OpenProjectFileChooserDescriptor#getIcon(VirtualFile)}.
 * <p>This class is a workaround solution for the issue b/37099520. Once the issue is addressed in
 * the upstream (IntelliJ open API), this class can be removed.
 */
public class OpenProjectFileChooserDescriptorWithAsyncIcon extends OpenProjectFileChooserDescriptor implements Disposable {

  private final Map<VirtualFile, Icon> myIconCache = Maps.newConcurrentMap();

  public OpenProjectFileChooserDescriptorWithAsyncIcon() {
    super(true);
  }

  @Override
  public void dispose() {
    myIconCache.clear();
  }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/ProjectPathDialog.form`:

```form
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.fakerandroid.as.ProjectPathDialog">
  <grid id="cbd77" binding="contentPane" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="10" left="10" bottom="10" right="10"/>
    <constraints>
      <xy x="2" y="54" width="554" height="137"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <grid id="e3588" layout-manager="GridLayoutManager" row-count="1" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="3" indent="0" use-parent-layout="false">
            <minimum-size width="500" height="-1"/>
          </grid>
        </constraints>
        <properties/>
        <border type="none"/>
        <children>
          <component id="bae99" class="javax.swing.JLabel">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text value="Project Path"/>
            </properties>
          </component>
          <component id="1af57" class="com.intellij.openapi.ui.TextFieldWithBrowseButton" binding="fileFied">
            <constraints>
              <grid row="0" column="1" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
          </component>
        </children>
      </grid>
    </children>
  </grid>
</form>

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/ProjectPathDialog.java`:

```java
package com.fakerandroid.as;

import com.fakerandroid.decoder.api.Transfer;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.intellij.ide.JavaUiBundle;
import com.intellij.ide.impl.ProjectUtil;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.fileChooser.FileChooserDescriptor;
import com.intellij.openapi.fileChooser.FileChooserDescriptorFactory;
import com.intellij.openapi.fileChooser.FileChooserDialog;
import com.intellij.openapi.progress.BackgroundTaskQueue;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.TextBrowseFolderListener;
import com.intellij.openapi.ui.TextFieldWithBrowseButton;
import com.intellij.openapi.ui.ValidationInfo;
import com.intellij.openapi.vfs.VirtualFile;
import com.luhuiguo.chinese.ChineseUtils;
import com.luhuiguo.chinese.pinyin.PinyinFormat;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import javax.swing.*;
import java.io.File;

public class ProjectPathDialog extends DialogWrapper {
    private JPanel contentPane;
    private TextFieldWithBrowseButton fileFied;
    VirtualFile apk;
    Project project;
    protected ProjectPathDialog(@Nullable Project project, boolean canBeParent, VirtualFile apk) {
        super(project, canBeParent);
        this.apk = apk;
        this.project = project;
        init();
        contentPane.setSize(300,100);
        final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();
        descriptor.putUserData(FileChooserDialog.PREFER_LAST_OVER_TO_SELECT, Boolean.TRUE);
        fileFied.addBrowseFolderListener(JavaUiBundle.message("module.paths.output.title"),
                JavaUiBundle.message("module.paths.output.title"), null,
                descriptor);

        File originalFile = new File(apk.getPath());
        File projectFile = new File(originalFile.getParent(), ChineseUtils.toPinyin(originalFile.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
        String outDir = projectFile.getAbsolutePath();
        fileFied.setText(outDir);

    }
    @Override
    protected JComponent createCenterPanel() {
        return contentPane;
    }

    @Override
    protected JComponent createNorthPanel() {
        return contentPane;
    }

    @Override
    public JComponent getContentPanel() {
        return contentPane;
    }

    @Override
    protected @Nullable ValidationInfo doValidate() {
        return null;
    }

    @Override
    protected void dispose() {
        super.dispose();
    }

    @Override
    public void doCancelAction() {
        super.doCancelAction();
    }

    @Override
    protected void doOKAction() {
        super.doOKAction();
                        BackgroundTaskQueue backgroundTaskQueue = new BackgroundTaskQueue(project, "FackerAndroid is decoder running ");//.run();
                FakerAndroidTask smailPackerThread= new FakerAndroidTask(project,apk,"faking a apk file to AndroidStudio project");
                FakerAndroidProgressIndicator backgroundableProcessIndicator = new FakerAndroidProgressIndicator(smailPackerThread);
                backgroundTaskQueue.run(smailPackerThread, ModalityState.NON_MODAL,backgroundableProcessIndicator);
    }

    class FakerAndroidTask extends Task.Backgroundable {
        VirtualFile apk;
        String outDir;
        Project project;
        public FakerAndroidTask(@Nullable Project project, VirtualFile apk,@Nls(capitalization = Nls.Capitalization.Sentence) @NotNull String title) {
            super(project, title);
            this.apk = apk;
            File originalFile = new File(apk.getPath());
            File projectFile = new File(originalFile.getParent(), ChineseUtils.toPinyin(originalFile.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
            outDir = projectFile.getAbsolutePath();
            this.project = project;
        }
        @Override
        public boolean shouldStartInBackground() {
            return false;
        }

        @Override
        public void run(@NotNull ProgressIndicator progressIndicator) {
            //TODO  you need a FakerAndroid.jar for dependency(add the last version of FakerAndroid.jar to the lib folder)
            new Transfer(apk.getPath(), outDir, new TransformInvocation() {
                @Override
                public void callBack(String msg) {
                    progressIndicator.setText2(msg);
                }
            }).translate();
        }
        @Override
        public void onFinished() {
            super.onFinished();
            ProjectUtil.openOrImport(new File(outDir).getPath(),project,false);
            System.out.println("finished~~~");
        }
        @Override
        public void onThrowable(@NotNull Throwable error) {
            super.onThrowable(error);
        }
    }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatEditor.java`:

```java
package com.fakerandroid.as.editor;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorLocation;
import com.intellij.openapi.fileEditor.FileEditorState;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.UserDataHolderBase;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.ui.JBSplitter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import javax.swing.*;
import java.beans.PropertyChangeListener;
public class DatEditor extends UserDataHolderBase implements FileEditor {
  private JBSplitter mySplitter;
  private DatViewPanel myApkViewPanel;
  private VirtualFile myBaseFile;
  public DatEditor(@NotNull Project project, @NotNull VirtualFile baseFile) {
    myBaseFile = baseFile;
    mySplitter = new JBSplitter(true, "android.apk.xxviewer", 0.62f);
    mySplitter.setName("apkViwerContainer");
    mySplitter.setFocusCycleRoot(true);
    mySplitter.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
    mySplitter.setSecondComponent(new JPanel());
    myApkViewPanel = new DatViewPanel();
    mySplitter.setFirstComponent(myApkViewPanel.getContainer());
  }
  @Override
  public @NotNull JComponent getComponent() {
    return mySplitter;
  }

  @Override
  public @Nullable JComponent getPreferredFocusedComponent() {
    return myApkViewPanel.getPreferredFocusedComponent();
  }

  @Override
  public @NotNull String getName() {
    return myBaseFile.getName();
  }

  @Override
  public void setState(@NotNull FileEditorState fileEditorState) {
  }

  @Override
  public boolean isModified() {
    return false;
  }

  @Override
  public boolean isValid() {
    return myBaseFile.isValid();
  }

  @Override
  public void addPropertyChangeListener(@NotNull PropertyChangeListener propertyChangeListener) {
  }

  @Override
  public void removePropertyChangeListener(@NotNull PropertyChangeListener propertyChangeListener) {
  }

  @Override
  public @Nullable FileEditorLocation getCurrentLocation() {
    return null;
  }

  @Override
  public void dispose() {
  }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatEditorProvider.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.fakerandroid.as.editor;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorPolicy;
import com.intellij.openapi.fileEditor.FileEditorProvider;
import com.intellij.openapi.project.DumbAware;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;
public class DatEditorProvider implements FileEditorProvider, DumbAware {
  private static final String ID = "test";

  @Override
  public boolean accept(@NotNull Project project, @NotNull VirtualFile file) {
    System.out.println("ApkEditorProvider------");
    return file.getExtension().equals("dat");
  }

  @NotNull
  @Override
  public FileEditor createEditor(@NotNull Project project, @NotNull VirtualFile file) {
    System.out.println("ApkEditorProvider------ref");
    return new DatEditor(project, file);
  }

  @NotNull
  @Override
  public String getEditorTypeId() {
    return ID;
  }

  @NotNull
  @Override
  public FileEditorPolicy getPolicy() {
    return FileEditorPolicy.PLACE_AFTER_DEFAULT_EDITOR;
  }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatFileSystem.java`:

```java
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.fakerandroid.as.editor;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.openapi.vfs.impl.ArchiveHandler;
import com.intellij.openapi.vfs.newvfs.ArchiveFileSystem;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class DatFileSystem extends ArchiveFileSystem {
  public static final String PROTOCOL = "dat";
  public static DatFileSystem getInstance() {
    return (DatFileSystem) VirtualFileManager.getInstance().getFileSystem(PROTOCOL);
  }

  @Override
  protected @NotNull String extractLocalPath(@NotNull String s) {
    return null;
  }

  @Override
  protected @NotNull String composeRootPath(@NotNull String s) {
    return null;
  }

  @Override
  protected @NotNull ArchiveHandler getHandler(@NotNull VirtualFile virtualFile) {
    return null;
  }

  @Override
  protected @NotNull String extractRootPath(@NotNull String s) {
    return null;
  }

  @Override
  public @Nullable VirtualFile findFileByPathIfCached(@NotNull String s) {
    return null;
  }

  @Override
  public @NotNull String getProtocol() {
    return null;
  }

  @Override
  public @Nullable VirtualFile findFileByPath(@NotNull String s) {
    return null;
  }

  @Override
  public void refresh(boolean b) {
  }

  @Override
  public @Nullable VirtualFile refreshAndFindFileByPath(@NotNull String s) {
    return null;
  }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatFileType.java`:

```java
package com.fakerandroid.as.editor;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import javax.swing.*;

public class DatFileType implements FileType {
    public static final DatFileType INSTANCE = new DatFileType();
    public DatFileType() {
    }
    @Override
    public @NotNull String getName() {
        return "dat";
    }

    @Override
    public @NotNull
    @Nls(capitalization = Nls.Capitalization.Sentence) String getDescription() {
        return "dat";
    }

    @Override
    public @NotNull String getDefaultExtension() {
        return "dat";
    }

    @Override
    public @Nullable Icon getIcon() {
        return null;
    }

    @Override
    public boolean isBinary() {
        return true;
    }

    @Override
    public boolean isReadOnly() {
        return false;
    }

    @Override
    public @Nullable String getCharset(@NotNull VirtualFile virtualFile, byte [] bytes) {
        return null;
    }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatViewPanel.form`:

```form
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.fakerandroid.as.editor.DatViewPanel">
  <grid id="27dc6" binding="jpanel" layout-manager="GridLayoutManager" row-count="1" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="20" y="20" width="500" height="400"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <hspacer id="4659">
        <constraints>
          <grid row="0" column="0" row-span="1" col-span="2" vsize-policy="1" hsize-policy="6" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
        </constraints>
      </hspacer>
    </children>
  </grid>
</form>

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/DatViewPanel.java`:

```java
package com.fakerandroid.as.editor;

import javax.swing.*;
import javax.swing.tree.DefaultTreeModel;

import com.intellij.ui.LoadingNode;
import com.intellij.ui.treeStructure.Tree;
public class DatViewPanel {
    private JPanel jpanel;
    private Tree myTree;
    private DefaultTreeModel myTreeModel;
    private void createUIComponents() {
        // TODO: place custom component creation code here
        myTreeModel = new DefaultTreeModel(new LoadingNode());
        myTree = new Tree(myTreeModel);
    }

    public JComponent getContainer() {
        return jpanel;
    }
    public JComponent getPreferredFocusedComponent() {
        return myTree;
    }
}

```

`bin/FakerAndroid-AS/src/main/java/com/fakerandroid/as/editor/TmpEditor.java`:

```java
package com.fakerandroid.as.editor;

import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.compiled.ClassFileDecompilers;
import org.jetbrains.annotations.NotNull;

public class TmpEditor extends ClassFileDecompilers.Light {
    @Override
    public @NotNull CharSequence getText(@NotNull VirtualFile virtualFile) throws CannotDecompileException {
        return null;
    }

    @Override
    public boolean accepts(@NotNull VirtualFile virtualFile) {
        return false;
    }
}

```

`bin/FakerAndroid-AS/src/main/kotlin/org/ollide/java2smali/Class2DexHelper.kt`:

```kt
package org.ollide.java2smali

import com.android.dx.command.dexer.Main

import java.io.IOException

object Class2DexHelper {

    /**
     * Uses the dx tool from the Android Build Tools (19.0.1) to create
     * a .dex version of a compiled java file (.class)
     *
     * @param inputClassFilePaths full paths to the compiled .class file
     * @param outputDexPath this will be the dex output file's path and name
     * @throws IOException
     */
    @Throws(IOException::class)
    fun dexClassFile(inputClassFilePaths: Array<String>, outputDexPath: String) {
        val arguments = Main.Arguments()
        arguments.outName = outputDexPath
        arguments.strictNameCheck = false
        arguments.fileNames = inputClassFilePaths

        Main.run(arguments)
    }
}

```

`bin/FakerAndroid-AS/src/main/kotlin/org/ollide/java2smali/Dex2SmaliHelper.kt`:

```kt
package org.ollide.java2smali


import org.jf.baksmali.Baksmali
import org.jf.baksmali.BaksmaliOptions
import org.jf.dexlib2.DexFileFactory
import org.jf.dexlib2.Opcodes
import java.io.File
import java.io.IOException

object Dex2SmaliHelper {

    /**
     * Uses baksmali, an disassembler for Android's dex format.
     * Source code and more information: https://github.com/JesusFreke/smali
     *
     * @param dexFilePath
     * @param outputDir
     * @throws IOException
     */
    @Throws(IOException::class)
    fun disassembleDexFile(dexFilePath: String, outputDir: String) {
        val opCodes = Opcodes.getDefault()
        val dexBackedDexFile = DexFileFactory.loadDexFile(dexFilePath, opCodes)

        val options = BaksmaliOptions()
        options.apiLevel = opCodes.api
        Baksmali.disassembleDexFile(dexBackedDexFile, File(outputDir), 6, options)
    }
}

```

`bin/FakerAndroid-AS/src/main/kotlin/org/ollide/java2smali/DexCompiler.kt`:

```kt
package org.ollide.java2smali

import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.module.Module
import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.*
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.openapi.vfs.VirtualFileManager
import com.intellij.psi.PsiClassOwner
import com.intellij.psi.PsiManager
import com.intellij.task.ProjectTaskManager
import com.intellij.util.SmartList
import com.intellij.util.containers.OrderedSet
import com.intellij.util.io.URLUtil
import java.io.File
import java.io.IOException
import java.nio.file.Paths

class DexCompiler(private val vFile: VirtualFile, private val project: Project, private val module: Module) {

    fun run() {
        buildModule {
            onProjectBuildComplete()
        }
    }

    /**
     * To create a dex or smali file from the virtual file, we ne a compiled .class file
     * of the given virtual file to be present.
     *
     * Project structures and builds vary a lot (Android, Java, Kotlin, directory structure),
     * so instead of using the CompileManager, we trigger a general build task.
     */
    private fun buildModule(callback: () -> Unit) {
        val projectTaskManager = ProjectTaskManager.getInstance(project)
        val buildTask = projectTaskManager.createModulesBuildTask(module, true, true, true)

        val supportProjectTaskManager = SupportProjectTaskManager(projectTaskManager)
        supportProjectTaskManager.run(buildTask).onSuccess {
            if (it.hasErrors()) {
                LOG.warn("Module build failed, aborting dex/smali build.")
            } else {
                callback()
            }
        }
    }

    private fun onProjectBuildComplete() {
        val file = PsiManager.getInstance(project).findFile(vFile) as PsiClassOwner

        val fileOutputDirectory = getFileOutputDirectory(file)
        fileOutputDirectory.refresh(false, false)

        val fileName = vFile.nameWithoutExtension
        val dexFilePath = Paths.get(fileOutputDirectory.path, fileName + DEX_EXTENSION).toString()

        // CLASS -> DEX
        val targetFiles = getClassFiles(fileOutputDirectory, fileName)
        compileDexFile(targetFiles, dexFilePath)

        // DEX -> SMALI
        val outputDir = getSourceRootFile().path
        WriteCommandAction.runWriteCommandAction(project) {
            Dex2SmaliHelper.disassembleDexFile(dexFilePath, outputDir)

            // we've created the smali file(s) in our source file's directory
            // refresh directory synchronously and access children to let IDEA detect the file(s)
            val parent = vFile.parent
            parent.refresh(false, false)
            parent.children
        }

        // get a VirtualFile by the IO path
        val smaliPath = vFile.path.substringBeforeLast('.') + SMALI_EXTENSION
        val virtualDexFile = LocalFileSystem.getInstance().findFileByIoFile(File(smaliPath)) ?: return

        // use the VirtualFile to show the smali file in IDEA editor
        val openFileDescriptor = OpenFileDescriptor(project, virtualDexFile)
        openFileDescriptor.navigate(true)
    }

    private fun getClassFiles(fileOutputDirectory: VirtualFile, fileName: String): Array<String> {
        val children = fileOutputDirectory.children ?: arrayOf()
        return children.filter {
            val baseName = it.nameWithoutExtension
            (baseName == fileName || baseName.startsWith("$fileName$")) && it.extension == CLASS
        }.map {
            it.path
        }.toTypedArray()
    }

    private fun getFileOutputDirectory(file: PsiClassOwner): VirtualFile {
        // determine whether this is a production or test file
        val isProduction = module.getModuleScope(false).contains(vFile)

        val pkg = file.packageName.replace('.', File.separatorChar)

        // find the general output directory of the file's module (target, app/build/intermediates/javac/$variant/classes, ...)
        val possibleOutputDirectories = findModuleOutputDirectories(isProduction)
        LOG.debug("Possible output directories: ", possibleOutputDirectories.joinToString(","))

        val virtualFileManager = VirtualFileManager.getInstance().getFileSystem(URLUtil.FILE_PROTOCOL)

        val fileOutputDirectory = possibleOutputDirectories
                .asSequence()
                .map {
                    val classFile = vFile.nameWithoutExtension + CLASS_EXTENSION
                    val path = Paths.get(it, pkg, classFile).toString()
                    virtualFileManager.refreshAndFindFileByPath(path)?.parent
                }
                .firstOrNull { it != null }

        LOG.debug("Found output directory: $fileOutputDirectory")
        return fileOutputDirectory ?: throw IllegalStateException("Output directory not found")
    }

    /**
     * @see <a href="https://github.com/JetBrains/intellij-community/blob/master/java/compiler/openapi/src/com/intellij/openapi/compiler/CompilerPaths.java">intellij-community/CompilerPaths.java</a>
     */
    private fun findModuleOutputDirectories(production: Boolean): OrderedSet<String> {
        val outputPaths: MutableList<String> = mutableListOf()

        val compilerExtension = CompilerModuleExtension.getInstance(module)
        if (production) {
            compilerExtension?.compilerOutputPath?.path?.let { outputPaths.add(it) }
        } else {
            compilerExtension?.compilerOutputPathForTests?.path?.let { outputPaths.add(it) }
        }

        val moduleRootManager = ModuleRootManager.getInstance(module)
        for (handlerFactory in OrderEnumerationHandler.EP_NAME.extensions) {
            if (handlerFactory.isApplicable(module)) {
                val handler = handlerFactory.createHandler(module)
                val outputUrls: List<String> = SmartList()
                handler.addCustomModuleRoots(OrderRootType.CLASSES, moduleRootManager, outputUrls, production, !production)
                for (outputUrl in outputUrls) {
                    outputPaths.add(VirtualFileManager.extractPath(outputUrl).replace('/', File.separatorChar))
                }
            }
        }
        return OrderedSet(outputPaths)
    }

    private fun compileDexFile(compiledPaths: Array<String>, dexFile: String) {
        try {
            Class2DexHelper.dexClassFile(compiledPaths, dexFile)
        } catch (e: IOException) {
            e.printStackTrace()
            return
        }
    }

    private fun getSourceRootFile(): VirtualFile {
        return ProjectRootManager.getInstance(project).fileIndex.getSourceRootForFile(vFile) as VirtualFile
    }

    companion object {

        private val LOG = Logger.getInstance(DexCompiler::class.java)

        const val CLASS_EXTENSION = ".class"
        const val DEX_EXTENSION = ".dex"
        const val SMALI_EXTENSION = ".smali"
        const val CLASS = "class"
    }

}

```

`bin/FakerAndroid-AS/src/main/kotlin/org/ollide/java2smali/GenerateAction.kt`:

```kt
package org.ollide.java2smali

import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.LangDataKeys
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.roots.ProjectRootManager
import com.intellij.openapi.vfs.VirtualFile

class GenerateAction : AnAction() {

    override fun actionPerformed(e: AnActionEvent) {
        LOG.debug("Action performed.")

        val vFile = getVirtualFileFromEvent(e) ?: return
        val project = e.project!!
        val module = ProjectRootManager.getInstance(project).fileIndex.getModuleForFile(vFile)!!

        DexCompiler(vFile, project, module).run()
    }

    override fun update(e: AnActionEvent) {
        var enabled = false

        getVirtualFileFromEvent(e)?.let {
            e.project?.let { project ->
                val m = ProjectRootManager.getInstance(project).fileIndex.getModuleForFile(it)
                val extension = it.fileType.defaultExtension
                enabled = (JAVA == extension || KOTLIN == extension) && m != null
            }
        }
        e.presentation.isEnabled = enabled
    }

    private fun getVirtualFileFromEvent(e: AnActionEvent): VirtualFile? {
        val psiFile = e.getData(LangDataKeys.PSI_FILE) ?: return null
        return psiFile.virtualFile
    }

    companion object {
        private val LOG = Logger.getInstance(GenerateAction::class.java)

        private const val JAVA = "java"
        private const val KOTLIN = "kt"
    }

}

```

`bin/FakerAndroid-AS/src/main/kotlin/org/ollide/java2smali/SupportProjectTaskManager.kt`:

```kt
package org.ollide.java2smali

import com.intellij.openapi.application.ApplicationInfo
import com.intellij.openapi.util.BuildNumber
import com.intellij.task.ProjectTask
import com.intellij.task.ProjectTaskManager
import com.intellij.task.ProjectTaskNotification
import com.intellij.task.ProjectTaskResult
import org.jetbrains.concurrency.AsyncPromise
import org.jetbrains.concurrency.Promise

/**
 * ProjectTaskManager wrapper that checks the IDE's build version
 * to execute the correct run method (Promise-based vs. Notification-based).
 */
class SupportProjectTaskManager(private val taskManager: ProjectTaskManager) {

    @Suppress("Deprecation", "UnstableApiUsage", "MissingRecentApi")
    fun run(projectTask: ProjectTask): Promise<TaskResult> {
        return if (newApiAvailable()) {
            taskManager.run(projectTask).then {
                TaskResult(it.hasErrors())
            }
        } else {
            val promise = AsyncPromise<TaskResult>()
            taskManager.run(projectTask, Notification(promise))
            promise
        }
    }

    @Suppress("Deprecation", "UnstableApiUsage")
    class Notification(private val promise: AsyncPromise<TaskResult>) : ProjectTaskNotification {

        override fun finished(executionResult: ProjectTaskResult) {
            promise.setResult(TaskResult(executionResult.errors > 0))
        }
    }

    class TaskResult(private val errors: Boolean) {
        fun hasErrors(): Boolean {
            return errors
        }
    }

    private fun newApiAvailable(): Boolean {
        return CURRENT_API >= NEW_RUN_API
    }

    companion object {

        /**
         * Minimum version of the promise-based ProjectTaskManager
         */
        private val NEW_RUN_API = BuildNumber("", 193, 4697, 15).withoutProductCode()
        private val CURRENT_API = ApplicationInfo.getInstance().build.withoutProductCode()
    }

}

```

`bin/FakerAndroid-AS/src/main/resources/META-INF/plugin.xml`:

```xml
<idea-plugin>
  <id>com.fakerandroid.as.plugin</id>
  <name>FakerAndroid</name>
  <version>patched</version>
  <vendor email="fakerandrolid@gmail.com" url="https://github.com/Efaker/FakerAndroid">Efaker</vendor>
  <description><![CDATA[
     Base FakerAndroid intellij plugin for androidStudio
      ]]></description>
  <change-notes><![CDATA[
      ]]>
  </change-notes>
  <!-- please see http://confluence.jetbrains.net/display/IDEADEV/Build+Number+Ranges for description -->
  <idea-version since-build="191"/> <!-- IDEA 2019.1 -->
  <depends>com.intellij.modules.java</depends>

  <application-components>
    <!-- Add your application components here -->
  </application-components>

  <project-components>
    <!-- Add your project components here -->
  </project-components>

  <actions>
    <action id="generateSmaliCode" class="org.ollide.java2smali.GenerateAction" text="Compile to Smali"
              description="Creates and shows a smali version of this file">
          <add-to-group group-id="BuildMenu" anchor="after" relative-to-action="Compile"/>
    </action>
    <!-- file  -->
    <action id="fakerandroid-file" class="com.fakerandroid.as.OpenApkFileAction" text="FakerAndroid"
            description="Creates and shows a smali version of this file">
      <add-to-group group-id="FileOpenGroup" anchor="before" relative-to-action="OpenFile"/>
    </action>
    <!-- welcome  -->
    <action id="fakerandroid-welcome" class="com.fakerandroid.as.OpenApkFileAction" text="FakerAndroid"
            description="Creates and shows a smali version of this file" icon="AllIcons.General.ShowInfos">
      <add-to-group group-id="WelcomeScreen.QuickStart" anchor="last"/>
    </action>
  </actions>

  <extensions defaultExtensionNs="com.intellij">
    <fileEditorProvider implementation="com.fakerandroid.as.editor.DatEditorProvider"/>
    <fileType name="dat"
              implementationClass="com.fakerandroid.as.editor.DatFileType"
              fieldName="INSTANCE"
              extensions="dat" />
  </extensions>

</idea-plugin>
```

`bin/FakerAndroid-AS/src/main/resources/META-INF/pluginIcon.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40">
    <defs>
        <linearGradient id="kotlin_file-a" x1="-16.836%" x2="76.219%" y1="91.94%" y2="-1.116%">
            <stop offset="10.75%" stop-color="#C757BC"/>
            <stop offset="21.38%" stop-color="#D0609A"/>
            <stop offset="42.54%" stop-color="#E1725C"/>
            <stop offset="60.48%" stop-color="#EE7E2F"/>
            <stop offset="74.3%" stop-color="#F58613"/>
            <stop offset="82.32%" stop-color="#F88909"/>
        </linearGradient>
    </defs>
    <g fill="none" fill-rule="evenodd">
        <g fill="none" fill-rule="evenodd" transform="translate(20 5)">
            <polygon fill="#9AA7B0" fill-opacity=".8" points="7 1 3 5 7 5"/>
            <path fill="#9AA7B0" fill-opacity=".8" d="M13,8 L8,8 L8,15 L3,15 L3,6 L8,6 L8,1 L13,1 L13,8 Z"/>
            <g transform="translate(9 9)">
                <polygon fill="#0EAEFF" fill-rule="nonzero" points="0 7 3.512 3.488 7 7"/>
                <polygon fill="#0EAEFF" fill-rule="nonzero" points="0 0 3.512 0 0 3.792"/>
                <polygon fill="url(#kotlin_file-a)" fill-rule="nonzero" points="3.512 0 0 3.698 0 7 3.512 3.488 7 0"/>
            </g>
        </g>

        <g fill="none" fill-rule="evenodd" transform="translate(3 5)">
            <polygon fill="#40B6E0" fill-opacity=".7" points="1 16 14 16 14 9 1 9"/>
            <polygon fill="#9AA7B0" fill-opacity=".8" points="7 1 3 5 7 5"/>
            <polygon fill="#9AA7B0" fill-opacity=".8" points="8 1 8 6 3 6 3 8 13 8 13 1"/>
            <path fill="#231F20" fill-opacity=".7" d="M1.39509277,3.58770752 C1.62440186,3.83789062 1.83782861,4 2.28682861,4 C2.81318359,4 3,3.58770752 3,3.29760742 L3,0 L4,0 L4,3.58770752 C4,4.31964111 3.32670898,5 2.45,5 C1.629,5 1.15,4.76264111 0.8,4.31964111 L1.39509277,3.58770752 Z" transform="translate(2 10)"/>
        </g>

        <g>
            <rect x="4" y="23" width="32" height="11" fill-opacity=".7" fill="#C41E3A"/>
            <text xml:space="preserve" text-anchor="start" font-family="Euphoria, sans-serif" font-size="10" id="svg_1" y="32" x="6" opacity="0.8" stroke-width="0" stroke="#000" fill="#231F20">.smali</text>
        </g>
    </g>
</svg>
```

`bin/FakerAndroid-cli/build.gradle`:

```gradle
plugins {
    id 'java'
}
apply plugin: 'com.github.johnrengelman.shadow'
group 'com.faker.android'
version '1.0.33'
repositories {
    google()
    mavenCentral()
}
jar {
    manifest {
        attributes 'Main-Class' : 'com.fakerandroid.decoder.Main'
    }
}
dependencies {
    implementation 'com.luhuiguo:chinese-utils:1.0'
    implementation project(':controller')
    implementation project(':distribution:apktool:brut.apktool:apktool-lib')
    implementation 'commons-cli:commons-cli:1.4'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`bin/FakerAndroid-cli/src/main/java/com/fakerandroid/decoder/Main.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.fakerandroid.decoder;

import brut.androlib.*;
import brut.androlib.err.CantFindFrameworkResException;
import brut.androlib.err.InFileNotFoundException;
import brut.androlib.err.OutDirExistsException;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.util.AaptManager;
import com.fakerandroid.decoder.api.Transfer;
import com.luhuiguo.chinese.ChineseUtils;
import com.luhuiguo.chinese.pinyin.PinyinFormat;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.IOException;
import java.util.logging.*;

public class Main {
    public static void main(String[] args) throws IOException, InterruptedException, BrutException {

        // headless
        System.setProperty("java.awt.headless", "true");

        // set verbosity default
        Verbosity verbosity = Verbosity.NORMAL;

        // cli parser
        CommandLineParser parser = new DefaultParser();
        CommandLine commandLine;

        // load options
        _Options();

        try {
            commandLine = parser.parse(allOptions, args, false);
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            usage();
            System.exit(1);
            return;
        }

        // check for verbose / quiet
        if (commandLine.hasOption("-v") || commandLine.hasOption("--verbose")) {
            verbosity = Verbosity.VERBOSE;
        } else if (commandLine.hasOption("-q") || commandLine.hasOption("--quiet")) {
            verbosity = Verbosity.QUIET;
        }
        setupLogging(verbosity);

        // check for advance mode
        if (commandLine.hasOption("advance") || commandLine.hasOption("advanced")) {
            setAdvanceMode(true);
        }

        boolean cmdFound = false;
        for (String opt : commandLine.getArgs()) {
            if(opt.equalsIgnoreCase("fk")||opt.equalsIgnoreCase("fake")){
                cmdFakeProject(commandLine);
                cmdFound = true;
            }
            if (opt.equalsIgnoreCase("d") || opt.equalsIgnoreCase("decode")) {
                cmdDecode(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("b") || opt.equalsIgnoreCase("build")) {
                cmdBuild(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("if") || opt.equalsIgnoreCase("install-framework")) {
                cmdInstallFramework(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("empty-framework-dir")) {
                cmdEmptyFrameworkDirectory(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("publicize-resources")) {
                cmdPublicizeResources(commandLine);
                cmdFound = true;
            }
        }

        // if no commands ran, run the version / usage check.
        if (!cmdFound) {
            if (commandLine.hasOption("version")) {
                _version();
                System.exit(0);
            } else {
                usage();
            }
        }
    }

    private static void cmdFakeProject(CommandLine cli) {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);
        String outDir = null;
        if(cli.hasOption("o") || cli.hasOption("output")){
            outDir =  cli.getOptionValue("o");
        }
        if(outDir==null){
            File originalFile = new File(apkName);
            File projectFile = new File(originalFile.getParent(), ChineseUtils.toPinyin(originalFile.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
            outDir = projectFile.getAbsolutePath();
        }
        new Transfer(apkName, outDir, new TransformInvocation() {
            @Override
            public void callBack(String msg) {
                Logger.getLogger(Transfer.class.getName()).info(msg);
            }
        }).translate();
    }

    private static void cmdDecode(CommandLine cli) throws AndrolibException {
        ApkDecoder decoder = new ApkDecoder();

        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);
        File outDir;

        // check for options
        if (cli.hasOption("s") || cli.hasOption("no-src")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_NONE);
        }
        if (cli.hasOption("only-main-classes")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES);
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            System.err.println("SmaliDebugging has been removed in 2.1.0 onward. Please see: https://github.com/iBotPeaches/Apktool/issues/1061");
            System.exit(1);
        }
        if (cli.hasOption("b") || cli.hasOption("no-debug-info")) {
            decoder.setBaksmaliDebugMode(false);
        }
        if (cli.hasOption("t") || cli.hasOption("frame-tag")) {
            decoder.setFrameworkTag(cli.getOptionValue("t"));
        }
        if (cli.hasOption("f") || cli.hasOption("force")) {
            decoder.setForceDelete(true);
        }
        if (cli.hasOption("r") || cli.hasOption("no-res")) {
            decoder.setDecodeResources(ApkDecoder.DECODE_RESOURCES_NONE);
        }
        if (cli.hasOption("force-manifest")) {
            decoder.setForceDecodeManifest(ApkDecoder.FORCE_DECODE_MANIFEST_FULL);
        }
        if (cli.hasOption("no-assets")) {
            decoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_NONE);
        }
        if (cli.hasOption("k") || cli.hasOption("keep-broken-res")) {
            decoder.setKeepBrokenResources(true);
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            decoder.setFrameworkDir(cli.getOptionValue("p"));
        }
        if (cli.hasOption("m") || cli.hasOption("match-original")) {
            decoder.setAnalysisMode(true, false);
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            decoder.setApi(Integer.parseInt(cli.getOptionValue("api")));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outDir = new File(cli.getOptionValue("o"));
            decoder.setOutDir(outDir);
        } else {
            // make out folder manually using name of apk
            String outName = apkName;
            outName = outName.endsWith(".apk") ? outName.substring(0,
                    outName.length() - 4).trim() : outName + ".out";

            // make file from path
            outName = new File(outName).getName();
            outDir = new File(outName);
            decoder.setOutDir(outDir);
        }

        decoder.setApkFile(new File(apkName));

        try {
            decoder.decode();
        } catch (OutDirExistsException ex) {
            System.err
                    .println("Destination directory ("
                            + outDir.getAbsolutePath()
                            + ") "
                            + "already exists. Use -f switch if you want to overwrite it.");
            System.exit(1);
        } catch (InFileNotFoundException ex) {
            System.err.println("Input file (" + apkName + ") " + "was not found or was not readable.");
            System.exit(1);
        } catch (CantFindFrameworkResException ex) {
            System.err
                    .println("Can't find framework resources for package of id: "
                            + String.valueOf(ex.getPkgId())
                            + ". You must install proper "
                            + "framework files, see project website for more info.");
            System.exit(1);
        } catch (IOException ex) {
            System.err.println("Could not modify file. Please ensure you have permission.");
            System.exit(1);
        } catch (DirectoryException ex) {
            System.err.println("Could not modify internal dex files. Please ensure you have permission.");
            System.exit(1);
        } finally {
            try {
                decoder.close();
            } catch (IOException ignored) {}
        }
    }

    private static void cmdBuild(CommandLine cli) throws BrutException {
        String[] args = cli.getArgs();
        String appDirName = args.length < 2 ? "." : args[1];
        File outFile;
        ApkOptions apkOptions = new ApkOptions();

        // check for build options
        if (cli.hasOption("f") || cli.hasOption("force-all")) {
            apkOptions.forceBuildAll = true;
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            System.out.println("SmaliDebugging has been removed in 2.1.0 onward. Please see: https://github.com/iBotPeaches/Apktool/issues/1061");
            apkOptions.debugMode = true;
        }
        if (cli.hasOption("v") || cli.hasOption("verbose")) {
            apkOptions.verbose = true;
        }
        if (cli.hasOption("a") || cli.hasOption("aapt")) {
            apkOptions.aaptPath = cli.getOptionValue("a");
        }
        if (cli.hasOption("c") || cli.hasOption("copy-original")) {
            System.err.println("-c/--copy-original has been deprecated. Removal planned for v2.5.0 (#2129)");
            apkOptions.copyOriginalFiles = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("nc") || cli.hasOption("no-crunch")) {
            apkOptions.noCrunch = true;
        }

        // Temporary flag to enable the use of aapt2. This will tranform in time to a use-aapt1 flag, which will be
        // legacy and eventually removed.
        if (cli.hasOption("use-aapt2")) {
            apkOptions.useAapt2 = true;
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            apkOptions.forceApi = Integer.parseInt(cli.getOptionValue("api"));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outFile = new File(cli.getOptionValue("o"));
        } else {
            outFile = null;
        }

        // try and build apk
        try {
            if (cli.hasOption("a") || cli.hasOption("aapt")) {
                apkOptions.aaptVersion = AaptManager.getAaptVersion(cli.getOptionValue("a"));
            }
            new Androlib(apkOptions).build(new File(appDirName), outFile);
        } catch (BrutException ex) {
            System.err.println(ex.getMessage());
            System.exit(1);
        }
    }

    private static void cmdInstallFramework(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        ApkOptions apkOptions = new ApkOptions();
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("t") || cli.hasOption("tag")) {
            apkOptions.frameworkTag = cli.getOptionValue("t");
        }
        new Androlib(apkOptions).installFramework(new File(apkName));
    }

    private static void cmdPublicizeResources(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        new Androlib().publicizeResources(new File(apkName));
    }

    private static void cmdEmptyFrameworkDirectory(CommandLine cli) throws AndrolibException {
        ApkOptions apkOptions = new ApkOptions();

        if (cli.hasOption("f") || cli.hasOption("force")) {
            apkOptions.forceDeleteFramework = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }

        new Androlib(apkOptions).emptyFrameworkDirectory();
    }

    private static void _version() {
        System.out.println(Androlib.getVersion());
    }

    @SuppressWarnings("static-access")
    private static void _Options() {

        // create options
        Option versionOption = Option.builder("version")
                .longOpt("version")
                .desc("prints the version then exits")
                .build();

        Option advanceOption = Option.builder("advance")
                .longOpt("advanced")
                .desc("prints advance information.")
                .build();

        Option noSrcOption = Option.builder("s")
                .longOpt("no-src")
                .desc("Do not decode sources.")
                .build();

        Option onlyMainClassesOption = Option.builder()
                .longOpt("only-main-classes")
                .desc("Only disassemble the main dex classes (classes[0-9]*.dex) in the root.")
                .build();

        Option noResOption = Option.builder("r")
                .longOpt("no-res")
                .desc("Do not decode resources.")
                .build();

        Option forceManOption = Option.builder()
                .longOpt("force-manifest")
                .desc("Decode the APK's compiled manifest, even if decoding of resources is set to \"false\".")
                .build();

        Option noAssetOption = Option.builder()
                .longOpt("no-assets")
                .desc("Do not decode assets.")
                .build();

        Option debugDecOption = Option.builder("d")
                .longOpt("debug")
                .desc("REMOVED (DOES NOT WORK): Decode in debug mode.")
                .build();

        Option analysisOption = Option.builder("m")
                .longOpt("match-original")
                .desc("Keeps files to closest to original as possible. Prevents rebuild.")
                .build();

        Option apiLevelOption = Option.builder("api")
                .longOpt("api-level")
                .desc("The numeric api-level of the file to generate, e.g. 14 for ICS.")
                .hasArg(true)
                .argName("API")
                .build();

        Option debugBuiOption = Option.builder("d")
                .longOpt("debug")
                .desc("Sets android:debuggable to \"true\" in the APK's compiled manifest")
                .build();

        Option noDbgOption = Option.builder("b")
                .longOpt("no-debug-info")
                .desc("don't write out debug info (.local, .param, .line, etc.)")
                .build();

        Option forceDecOption = Option.builder("f")
                .longOpt("force")
                .desc("Force delete destination directory.")
                .build();

        Option frameTagOption = Option.builder("t")
                .longOpt("frame-tag")
                .desc("Uses framework files tagged by <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option frameDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Uses framework files located in <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option frameIfDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Stores framework files into <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option keepResOption = Option.builder("k")
                .longOpt("keep-broken-res")
                .desc("Use if there was an error and some resources were dropped, e.g.\n"
                        + "            \"Invalid config flags detected. Dropping resources\", but you\n"
                        + "            want to decode them anyway, even with errors. You will have to\n"
                        + "            fix them manually before building.")
                .build();

        Option forceBuiOption = Option.builder("f")
                .longOpt("force-all")
                .desc("Skip changes detection and build all files.")
                .build();

        Option aaptOption = Option.builder("a")
                .longOpt("aapt")
                .hasArg(true)
                .argName("loc")
                .desc("Loads aapt from specified location.")
                .build();

        Option aapt2Option = Option.builder()
                .longOpt("use-aapt2")
                .desc("Upgrades apktool to use experimental aapt2 binary.")
                .build();

        Option originalOption = Option.builder("c")
                .longOpt("copy-original")
                .desc("Copies original AndroidManifest.xml and META-INF. See project page for more info.")
                .build();

        Option noCrunchOption = Option.builder("nc")
                .longOpt("no-crunch")
                .desc("Disable crunching of resource files during the build step.")
                .build();

        Option tagOption = Option.builder("t")
                .longOpt("tag")
                .desc("Tag frameworks using <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option outputBuiOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of apk that gets written. Default is dist/name.apk")
                .hasArg(true)
                .argName("dir")
                .build();

        Option outputDecOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of folder that gets written. Default is apk.out")
                .hasArg(true)
                .argName("dir")
                .build();

        Option quietOption = Option.builder("q")
                .longOpt("quiet")
                .build();

        Option verboseOption = Option.builder("v")
                .longOpt("verbose")
                .build();

        // check for advance mode
        if (isAdvanceMode()) {
            DecodeOptions.addOption(noDbgOption);
            DecodeOptions.addOption(keepResOption);
            DecodeOptions.addOption(analysisOption);
            DecodeOptions.addOption(onlyMainClassesOption);
            DecodeOptions.addOption(apiLevelOption);
            DecodeOptions.addOption(noAssetOption);
            DecodeOptions.addOption(forceManOption);

            BuildOptions.addOption(apiLevelOption);
            BuildOptions.addOption(debugBuiOption);
            BuildOptions.addOption(aaptOption);
            BuildOptions.addOption(originalOption);
            BuildOptions.addOption(aapt2Option);
            BuildOptions.addOption(noCrunchOption);
        }

        // add global options
        normalOptions.addOption(versionOption);
        normalOptions.addOption(advanceOption);

        // add basic decode options
        DecodeOptions.addOption(frameTagOption);
        DecodeOptions.addOption(outputDecOption);
        DecodeOptions.addOption(frameDirOption);
        DecodeOptions.addOption(forceDecOption);
        DecodeOptions.addOption(noSrcOption);
        DecodeOptions.addOption(noResOption);

        // add basic build options
        BuildOptions.addOption(outputBuiOption);
        BuildOptions.addOption(frameDirOption);
        BuildOptions.addOption(forceBuiOption);

        // add basic framework options
        frameOptions.addOption(tagOption);
        frameOptions.addOption(frameIfDirOption);

        // add empty framework options
        emptyFrameworkOptions.addOption(forceDecOption);
        emptyFrameworkOptions.addOption(frameIfDirOption);

        // add all, loop existing cats then manually add advance
        for (Object op : normalOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : DecodeOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : BuildOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : frameOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        allOptions.addOption(apiLevelOption);
        allOptions.addOption(analysisOption);
        allOptions.addOption(debugDecOption);
        allOptions.addOption(noDbgOption);
        allOptions.addOption(forceManOption);
        allOptions.addOption(noAssetOption);
        allOptions.addOption(keepResOption);
        allOptions.addOption(debugBuiOption);
        allOptions.addOption(aaptOption);
        allOptions.addOption(originalOption);
        allOptions.addOption(verboseOption);
        allOptions.addOption(quietOption);
        allOptions.addOption(aapt2Option);
        allOptions.addOption(noCrunchOption);
        allOptions.addOption(onlyMainClassesOption);
    }

    private static String verbosityHelp() {
        if (isAdvanceMode()) {
            return "[-q|--quiet OR -v|--verbose] ";
        } else {
            return "";
        }
    }

    private static void usage() {
        _Options();
        HelpFormatter formatter = new HelpFormatter();
        formatter.setWidth(120);

        // print out license info prior to formatter.
        System.out.println(
                "Apktool v" + Androlib.getVersion() + " - a tool for reengineering Android apk files\n" +
                        "with smali v" + ApktoolProperties.get("smaliVersion") +
                        " and baksmali v" + ApktoolProperties.get("baksmaliVersion") + "\n" +
                        "Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>\n" +
                        "Updated by Connor Tumbleson <connor.tumbleson@gmail.com>" );
        if (isAdvanceMode()) {
            System.out.println("Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)\n");
        }else {
            System.out.println("");
        }

        // 4 usage outputs (general, frameworks, decode, build)
        formatter.printHelp("apktool " + verbosityHelp(), normalOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "if|install-framework [options] <framework.apk>", frameOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "d[ecode] [options] <file_apk>", DecodeOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "b[uild] [options] <app_path>", BuildOptions);
        if (isAdvanceMode()) {
            formatter.printHelp("apktool " + verbosityHelp() + "publicize-resources <file_path>", emptyOptions);
            formatter.printHelp("apktool " + verbosityHelp() + "empty-framework-dir [options]", emptyFrameworkOptions);
            System.out.println("");
        } else {
            System.out.println("");
        }

        // print out more information
        System.out.println(
                "For additional info, see: http://ibotpeaches.github.io/Apktool/ \n"
                        + "For smali/baksmali info, see: https://github.com/JesusFreke/smali");
    }

    private static void setupLogging(final Verbosity verbosity) {
        Logger logger = Logger.getLogger("");
        for (Handler handler : logger.getHandlers()) {
            logger.removeHandler(handler);
        }
        LogManager.getLogManager().reset();

        if (verbosity == Verbosity.QUIET) {
            return;
        }

        Handler handler = new Handler(){
            @Override
            public void publish(LogRecord record) {
                if (getFormatter() == null) {
                    setFormatter(new SimpleFormatter());
                }

                try {
                    String message = getFormatter().format(record);
                    if (record.getLevel().intValue() >= Level.WARNING.intValue()) {
                        System.err.write(message.getBytes());
                    } else {
                        if (record.getLevel().intValue() >= Level.INFO.intValue()) {
                            System.out.write(message.getBytes());
                        } else {
                            if (verbosity == Verbosity.VERBOSE) {
                                System.out.write(message.getBytes());
                            }
                        }
                    }
                } catch (Exception exception) {
                    reportError(null, exception, ErrorManager.FORMAT_FAILURE);
                }
            }
            @Override
            public void close() throws SecurityException {}
            @Override
            public void flush(){}
        };

        logger.addHandler(handler);

        if (verbosity == Verbosity.VERBOSE) {
            handler.setLevel(Level.ALL);
            logger.setLevel(Level.ALL);
        } else {
            handler.setFormatter(new Formatter() {
                @Override
                public String format(LogRecord record) {
                    return record.getLevel().toString().charAt(0) + ": "
                            + record.getMessage()
                            + System.getProperty("line.separator");
                }
            });
        }
    }

    private static boolean isAdvanceMode() {
        return advanceMode;
    }

    private static void setAdvanceMode(boolean advanceMode) {
        Main.advanceMode = advanceMode;
    }

    private enum Verbosity {
        NORMAL, VERBOSE, QUIET
    }

    private static boolean advanceMode = false;

    private final static Options normalOptions;
    private final static Options DecodeOptions;
    private final static Options BuildOptions;
    private final static Options frameOptions;
    private final static Options allOptions;
    private final static Options emptyOptions;
    private final static Options emptyFrameworkOptions;

    static {
        //normal and advance usage output
        normalOptions = new Options();
        BuildOptions = new Options();
        DecodeOptions = new Options();
        frameOptions = new Options();
        allOptions = new Options();
        emptyOptions = new Options();
        emptyFrameworkOptions = new Options();
    }
}

```

`bin/FakerAndroid-gui/build.gradle`:

```gradle
dependencies {
    implementation project(':controller')
    implementation 'com.luhuiguo:chinese-utils:1.0'
    implementation(project(':library'))
}

buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }

    dependencies {
    }
}
apply plugin: 'com.github.johnrengelman.shadow'
jar {
    manifest {
        attributes 'Main-Class' : 'FakerAndroidGui'
    }
}

```

`bin/FakerAndroid-gui/src/main/java/FakerAndroidGui.java`:

```java
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class FakerAndroidGui extends Application {

	@Override
	public void start(Stage primaryStage) throws Exception {
//		File file = Jar.getResourceAsFile("/FileChooser.fxml");
//
//		URL uri = file.toURI().toURL();
		Parent root = FXMLLoader.load(getClass().getResource("/FileChooser.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("FakerAndroid GUI");
		primaryStage.setResizable(false);
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	public static void main(String[] args) {
		launch(args);
	}

}

```

`bin/FakerAndroid-gui/src/main/java/FilechooserController.java`:

```java
import com.luhuiguo.chinese.ChineseUtils;
import com.luhuiguo.chinese.pinyin.PinyinFormat;
import com.fakerandroid.decoder.api.Transfer;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.util.TextUtil;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.layout.VBox;
import javafx.stage.*;

import java.io.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FilechooserController {

    @FXML
    private Button btn01;

    @FXML
    private Button btn02;

    @FXML
    private Button btn03;

    @FXML
    private TextArea txa;

    @FXML
    private VBox vbox;

    @FXML
    private TextField apkPathTextField;

    @FXML
    private TextField projectPathTextField;

    Stage stage;
    File outProjectCache;
    File apkDirCache;
    @FXML
    void initialize() {
        assert btn01 != null : "fx:id=\"btn01\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert btn02 != null : "fx:id=\"btn02\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert btn03 != null : "fx:id=\"btn02\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert txa != null : "fx:id=\"txa\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert vbox != null : "fx:id=\"vbox\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert apkPathTextField != null : "fx:id=\"apkPathTextField\" was not injected: check your FXML file 'FileChooser.fxml'.";
        assert projectPathTextField != null : "fx:id=\"projectPathTextField\" was not injected: check your FXML file 'FileChooser.fxml'.";
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                stage = (Stage) btn01.getScene().getWindow();
            }
        });
        apkDirCache = new File(System.getProperty("java.io.tmpdir"),"apkDirCach.tmp");
        outProjectCache = new File(System.getProperty("java.io.tmpdir"),"outProjectCache.tmp");
    }
    File apkFile;
    @FXML
    void btn01OnAction(ActionEvent event) {
        FileChooser fch = new FileChooser();
        fch.setTitle("Select File !!");
//        fch.setInitialDirectory(new File(System.getProperty("user.home")));
        setApkInitialDirectory(fch,apkDirCache);

        fch.getExtensionFilters().addAll(
                new FileChooser.ExtensionFilter("Apk", "*.apk")
        );
        apkFile = fch.showOpenDialog(this.stage);
        if (apkFile != null) {
            this.apkPathTextField.clear();
            this.apkPathTextField.setText(apkFile.getPath());
            cacheApkInitialDirectory(apkDirCache,apkFile);
            File projectDir = new File(apkFile.getParent(), ChineseUtils.toPinyin(apkFile.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
            this.projectPathTextField.setText(projectDir.getAbsolutePath());
        }
    }
    ExecutorService executor = Executors.newCachedThreadPool();
    @FXML
    void btn03OnAction(ActionEvent event) {
        String apkPath = this.apkPathTextField.getText();
        String dirPath = this.projectPathTextField.getText();
        if(TextUtil.isEmpty(apkPath)||TextUtil.isEmpty(dirPath)){
            showPopupMessage("ApkPath or OutDir cant empty",stage);
            return;
        }

        File apkFile = new File(apkPath);
        if(!apkFile.exists()){
            showPopupMessage("Apk !exists !",stage);
            return;
        }
        if(!apkPath.endsWith(".apk")){
            showPopupMessage("invalid file !",stage);
            return;
        }
        File dirFile = new File(dirPath);
        if(!dirFile.getParentFile().exists()){
            showPopupMessage("Dir !exists !",stage);
            return;
        }
        TestTask testTask = new TestTask(txa,apkPath,dirPath,btn03);
        executor.execute(testTask);
    }
    class TestTask extends Thread {
        final TextArea textArea;String apkPath;String outPath;Button triggerButton;
        TestTask(TextArea textArea,String apkPath,String outPath,Button triggerButton) {
            this.textArea =textArea;
            this.apkPath =apkPath;
            this.outPath = outPath;
            this.triggerButton = triggerButton;
        }
        public void run() {
            triggerButton.setDisable(true);
            new Transfer(apkPath, outPath, new TransformInvocation() {
                @Override
                public void callBack(String msg) {
                    textArea.appendText(msg+"\r\n");
                }
            }).translate();
            triggerButton.setDisable(false);
        }
    }
    @FXML
    void btn02OnAction(ActionEvent event) {
        DirectoryChooser fch = new DirectoryChooser();
        fch.setTitle("Select File !!");
        if(apkFile==null||!apkFile.exists()){
            showPopupMessage("Please choose a apk first!",stage);
            return;
        }
        setOutProjectInitialDirectory(fch,outProjectCache);
        File file = fch.showDialog(this.stage);
        if (file != null) {
        if(apkFile!=null&&apkFile.exists()){
            File projectDir = new File(file, ChineseUtils.toPinyin(apkFile.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
            this.projectPathTextField.clear();
            this.projectPathTextField.setText(projectDir.getAbsolutePath());
        }
        cacheOutProjectInitialDirectory(outProjectCache,file);
        }
    }

    @FXML
    void onDragOverApk(DragEvent dragEvent) {
        if (dragEvent.getGestureSource() != dragEvent
                && dragEvent.getDragboard().hasFiles()) {
            dragEvent.acceptTransferModes(TransferMode.COPY_OR_MOVE);
        }
        dragEvent.consume();
    }

    @FXML
    void onDragDroppedApk(DragEvent dragEvent) {
        Dragboard db = dragEvent.getDragboard();
        boolean success = false;
        if (db.hasFiles()) {
            File apkFile = db.getFiles().iterator().next();
            this.apkPathTextField.setText(apkFile.getAbsolutePath());
            //TODO 自动赋值
            this.projectPathTextField.setText(apkFile.getParent());
            success = true;
        }
        dragEvent.setDropCompleted(success);
        dragEvent.consume();
    }

    private void setApkInitialDirectory(FileChooser fileChooser, File cacheFile) {
        if (cacheFile.exists()) {
            try (InputStream inputStream = new FileInputStream(cacheFile)) {
                byte[] bytes = new byte[(int) cacheFile.length()];
                inputStream.read(bytes);
                File directory = new File(new String(bytes));
                if (directory.exists()) {
                    fileChooser.setInitialDirectory(directory);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        } else {
            fileChooser.setInitialDirectory(new File(System.getProperty("user.home")));
        }
    }

    private void cacheApkInitialDirectory(File cacheFile,File file) {
        try (OutputStream outputStream = new FileOutputStream(cacheFile)) {
            byte[] bytes = file.getParent().getBytes();
            outputStream.write(bytes);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void setOutProjectInitialDirectory(DirectoryChooser directoryChooser,File cacheFile) {
        if (cacheFile.exists()) {
            try (InputStream inputStream = new FileInputStream(cacheFile)) {
                byte[] bytes = new byte[(int) cacheFile.length()];
                inputStream.read(bytes);
                File directory = new File(new String(bytes));
                if (directory.exists()) {
                    directoryChooser.setInitialDirectory(directory);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        } else {
            directoryChooser.setInitialDirectory(new File(System.getProperty("user.home")));
        }
    }
    public static void showPopupMessage(final String message, final Stage stage) {
        final Popup popup = createPopup(message);
        popup.setOnShown(new EventHandler<WindowEvent>() {
            @Override
            public void handle(WindowEvent e) {
                popup.setX(stage.getX() + stage.getWidth()/2 - popup.getWidth()/2);
                popup.setY(stage.getY() + stage.getHeight()/2 - popup.getHeight()/2);
            }
        });
        popup.show(stage);
    }
    public static Popup createPopup(final String message) {
        final Popup popup = new Popup();
        popup.setAutoFix(true);
        popup.setAutoHide(true);
        popup.setHideOnEscape(true);
        Label label = new Label(message);
        label.setOnMouseReleased(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent e) {
                popup.hide();
            }
        });
        label.getStyleClass().add("popup");
        popup.getContent().add(label);
        return popup;
    }
    private void cacheOutProjectInitialDirectory(File cacheFile,File file) {
        try (OutputStream outputStream = new FileOutputStream(cacheFile)) {
            byte[] bytes = file.getAbsolutePath().getBytes();
            outputStream.write(bytes);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

`bin/FakerAndroid-gui/src/main/resources/FileChooser.fxml`:

```fxml
<?xml version="1.0" encoding="UTF-8"?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<AnchorPane id="AnchorPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="480.0" prefWidth="690.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2" fx:controller="FilechooserController">
  <children>
    <VBox fx:id="vbox" alignment="CENTER_LEFT" layoutX="20.0" layoutY="20.0" spacing="16.0" onDragOver="#onDragOverApk" onDragDropped="#onDragDroppedApk">
      <children>
        <HBox id="HBox" alignment="CENTER_LEFT" spacing="10.0">
          <children>
            <Label focusTraversable="false" text="Apk Path" prefWidth="60"></Label>
            <TextField id="apkPathTextField" focusTraversable="false" fx:id="apkPathTextField" prefWidth="480" promptText="Drag or select a Apk file"></TextField>
            <Button id="btn" fx:id="btn01" mnemonicParsing="false" onAction="#btn01OnAction" text="Select Apk File" />
          </children>
        </HBox>
        <HBox id="HBox" alignment="CENTER_LEFT" spacing="10.0">
          <children>
            <Label focusTraversable="false" text="Out Dir" prefWidth="60"></Label>
            <TextField id="projectPathTextField" focusTraversable="false" fx:id="projectPathTextField" prefWidth="480" promptText="Select a out dir"></TextField>
            <Button id="btn" fx:id="btn02" mnemonicParsing="false" onAction="#btn02OnAction" text="Select Out Dir " />
          </children>
        </HBox>
        <TextArea fx:id="txa" editable="false" focusTraversable="false" prefHeight="300.0"  prefWidth="660.0" style="-fx-background-color: beige;" wrapText="true" />
        <HBox id="HBox" alignment="BASELINE_RIGHT" spacing="20.0" >
          <children>
            <Button  id="btn" fx:id="btn03" layoutY="130" mnemonicParsing="false" prefHeight="32" prefWidth="120" onAction="#btn03OnAction" text="Generate Project"/>
          </children>
        </HBox>
      </children>
    </VBox>
  </children>
</AnchorPane>

```

`build.gradle`:

```gradle
group 'faker.android'
version '1.0-SNAPSHOT'

allprojects {
    apply plugin: 'java'
    dependencies {
        implementation 'org.slf4j:slf4j-api:1.7.30'
        compileOnly 'org.jetbrains:annotations:20.1.0'
        compileOnly "org.projectlombok:lombok:1.18.4"
        testImplementation 'ch.qos.logback:logback-classic:1.2.3'
        testImplementation 'org.hamcrest:hamcrest-library:2.2'
        testImplementation 'org.mockito:mockito-core:3.5.10'
        testImplementation 'org.assertj:assertj-core:3.17.2'
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
        testImplementation 'org.eclipse.jdt.core.compiler:ecj:4.6.1'
        testCompileOnly 'org.jetbrains:annotations:20.1.0'
    }
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
        google()
    }
}
buildscript {
    ext.kotlin_version = '1.4.32'
    repositories {
        jcenter()
    }
    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
    }
    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:6.0.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
apply plugin: 'kotlin'
repositories {
    mavenCentral()
}
dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
}
compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
```

`controller/build.gradle`:

```gradle
plugins {
    id 'java'
}
group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.luhuiguo:chinese-utils:1.0'
    implementation 'org.dom4j:dom4j:2.1.1'
    implementation 'commons-io:commons-io:2.4'
    implementation(project(':library'))
    implementation(project(':distribution:il2cpp-dumper'))
    implementation(project(':distribution:smali'))
    implementation(project(':distribution:dex2jar'))
    implementation(project(':distribution:runtime-base'))
    implementation(project(':distribution:runtime-il2cpp'))
    implementation(project(':distribution:project'))
    implementation project(':distribution:apktool:brut.apktool:apktool-lib')
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`controller/src/main/java/com/fakerandroid/decoder/api/AndroidProject.java`:

```java
package com.fakerandroid.decoder.api;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class AndroidProject {
    public static final String INTERMEDIATE_DEX_NAMES = "dexes";
    public static final String INTERMEDIATE_MANIFESTINFO = "manifest-info";

    private Map<String,Object> intermediate = new HashMap<>();

    public void addIntermediate(String key,Object o){
        intermediate.put(key,o);
    }
    public Object getIntermediate(String key){
        return  intermediate.get(key);
    }

    public AndroidProject(File project) {
        this.project = project;
    }

    private File project;

    public File getProject(){
        return project;
    }

    public File getProjectBuild(){
        return new File(getProject(),"build.gradle");
    }
    public File getApp(){
        File file = new File(getProject(),"app");
        return file;
    }

    public File getAppBuild(){
        File file = new File(getApp(),"build.gradle");
        return file;
    }

    private File getAppSrc(){
        File file = new File(getApp(),"src");
        return file;
    }
    public File getMain(){
        return new File(getAppSrc(),"main");
    }

    public File getAndroidManifest() {
        File file = new File(getMain(),"AndroidManifest.xml");
        return file;
    }

    public File getSmali(){
        File file = new File(getMain(),"smali");
        return file;
    }
    public File getjniLibs() {
        File file = new File(getMain(),"jniLibs");
        return  file;
    }

    public File getAssets() {
        File file = new File(getMain(),"assets");
        return  file;
    }

    public File getCpp() {
        File file = new File(getMain(),"cpp");
        return  file;
    }
    public File getCppLibs() {
        File file = new File(getCpp(),"libs");
        return  file;
    }
    public File getResources() {
        File file = new File(getMain(),"resources");
        return  file;
    }

    public File getGradle() {
        File file = new File(getProject(),"gradle");
        return  file;
    }
    public File getJava(){
        File file = new File(getMain(),"java");
        return  file;
    }

    public File getLibs(){
        File file = new File(getApp(),"libs");
        return  file;
    }
    public File getJavaScaffoding(){
        File file = new File(getApp(),"javaScaffoding");
        return file;
    }
    public File getRes() {
        File file = new File(getMain(),"res");
        return file;
    }
    public File getYmlFile() {
        File file = new File(getMain(),"apktool.yml");
        return file;
    }

    public static class ManifestInfo {
        private String minSdkVersion;
        private String targetSdkVersion;
        private String pakcageName;

        public String getMinSdkVersion() {
            if(minSdkVersion==null){
                return "23";
            }
            return minSdkVersion;
        }

        public void setMinSdkVersion(String minSdkVersion) {
            this.minSdkVersion = minSdkVersion;
        }

        public String getTargetSdkVersion() {
            if(targetSdkVersion==null){
                return "28";
            }
            return targetSdkVersion;
        }

        public void setTargetSdkVersion(String targetSdkVersion) {
            this.targetSdkVersion = targetSdkVersion;
        }

        public String getPakcageName() {
            return pakcageName;
        }

        public void setPakcageName(String pakcageName) {
            this.pakcageName = pakcageName;
        }

        public String getApplicationName() {
            return applicationName;
        }

        public void setApplicationName(String applicationName) {
            this.applicationName = applicationName;
        }

        public String getVersionCode() {
            return versionCode;
        }

        public void setVersionCode(String versionCode) {
            this.versionCode = versionCode;
        }

        public String getVersionName() {
            return versionName;
        }

        public void setVersionName(String versionName) {
            this.versionName = versionName;
        }

        private String applicationName;
        private String versionCode;
        private String versionName;

        @Override
        public String toString() {
            return "ManifestInfo{" +
                    "minSdkVersion='" + minSdkVersion + '\'' +
                    ", targetSdkVersion='" + targetSdkVersion + '\'' +
                    ", pakcageName='" + pakcageName + '\'' +
                    ", applicationName='" + applicationName + '\'' +
                    ", versionCode='" + versionCode + '\'' +
                    ", versionName='" + versionName + '\'' +
                    '}';
        }
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/api/Apk.java`:

```java
package com.fakerandroid.decoder.api;

import java.io.File;

public class Apk {
    private File apkFile;

    public Apk(File apkFile){
        this.apkFile = apkFile;
    }

    public File getApkFile() {
        return apkFile;
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/api/Transfer.java`:

```java
package com.fakerandroid.decoder.api;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.pipeline.TransformManager;
import com.fakerandroid.decoder.transforms.*;

import java.io.File;

public class Transfer {
    private File in;
    private File out;
    TransformInvocation transformInvocation;
    public Transfer(String inPath,String outPath,TransformInvocation transformInvocation){
        in = new File(inPath);
        out = new File(outPath);
        this.transformInvocation = transformInvocation;
    }
    public void translate(){
        TransformManager transformManager = new TransformManager(transformInvocation);
        Apk apk = new Apk(in);
        AndroidProject androidProject = new AndroidProject(out);
        System.out.println(apk.getApkFile().getAbsolutePath());
        if(!in.exists()){
            transformInvocation.callBack("In file not exist..");
            return;
        }
        if(!in.getAbsolutePath().endsWith(".apk")){
            transformInvocation.callBack("not a apk file..");
        }
        //Decoder
        transformManager.addTransform(new ResourceProcesser(apk,androidProject));
        transformManager.addTransform(new DexToSmali(apk,androidProject));
        transformManager.addTransform(new DexToJar(apk,androidProject));
        transformManager.addTransform(new Il2cppDumper(apk,androidProject));

        //Merge
        transformManager.addTransform(new RuntimeBaseMerge(apk,androidProject));
        transformManager.addTransform(new RuntimeIl2cppMerge(apk,androidProject));

        //fix
        transformManager.addTransform(new Project(apk,androidProject));
        transformManager.action();
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/conversation/SupportConversation.java`:

```java
package com.fakerandroid.decoder.conversation;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Context;
import com.fakerandroid.decoder.pipeline.Conversation;
import com.fakerandroid.decoder.transforms.DexToJar;
import com.fakerandroid.decoder.transforms.DexToSmali;
import com.fakerandroid.decoder.transforms.Il2cppDumper;
import com.fakerandroid.decoder.transforms.ResourceProcesser;

public class SupportConversation extends Conversation {

    public SupportConversation(Context context) {
        super(context);
    }
    @Override
    public void converse() {
        Apk apk = context.getApks().iterator().next();
        AndroidProject androidProject = context.getAndroidProject();

        context.getTransformManager().addTransform(new ResourceProcesser(apk,androidProject));

        context.getTransformManager().addTransform(new DexToJar(apk,androidProject));

        context.getTransformManager().addTransform(new DexToSmali(apk,androidProject));

        context.getTransformManager().addTransform(new Il2cppDumper(apk,androidProject));
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/Context.java`:

```java
package com.fakerandroid.decoder.pipeline;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Apk;

import java.util.List;
import java.util.logging.Logger;

public class Context {

    TransformManager transformManager;

    AndroidProject androidProject;

    List<Apk> apks;

    public List<Apk> getApks() {
        return apks;
    }

    Logger logger = Logger.getLogger(this.getClass().getName());

    public TransformManager getTransformManager() {
        return transformManager;
    }

    public AndroidProject getAndroidProject() {
        return androidProject;
    }

    public Logger getLogger() {
        return logger;
    }

    public Context(TransformManager transformManager, List<Apk> apks, AndroidProject androidProject) {
        this.transformManager = transformManager;
        this.apks = apks;
        this.androidProject = androidProject;
    }

}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/Conversation.java`:

```java
package com.fakerandroid.decoder.pipeline;

public abstract class Conversation {
    public Context context;
    public Conversation(Context context) {
        this.context = context;
    }
    public abstract void converse();
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/Transform.java`:

```java
package com.fakerandroid.decoder.pipeline;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Apk;

import java.io.IOException;

public abstract class Transform {
    protected Apk apk;
    protected AndroidProject androidProject;
    public Transform(Apk apk, AndroidProject androidProject){
        this.apk = apk;
        this.androidProject = androidProject;
    }
    public abstract boolean transform(TransformInvocation transformInvocation) ;
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/TransformInput.java`:

```java
package com.fakerandroid.decoder.pipeline;

public class TransformInput {
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/TransformInvocation.java`:

```java
package com.fakerandroid.decoder.pipeline;

public interface TransformInvocation {

    public void callBack(String msg);
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/TransformManager.java`:

```java
package com.fakerandroid.decoder.pipeline;


import java.util.ArrayList;
import java.util.List;

public class TransformManager {
     TransformInvocation transformInvocation;
     public TransformManager(TransformInvocation transformInvocation){
          this.transformInvocation = transformInvocation;
     }
     private final List<TransformStream> streams = new ArrayList<>();

     private final List<Transform> transforms = new ArrayList<>();

     public void addStream(TransformStream stream) {
          streams.add(stream);
     }

     public List<TransformStream> getStreams() {
          return streams;
     }

     public void addTransform(Transform transform){
          transforms.add(transform);
     }
     public void action() {
        for (Transform transform:transforms){
             if(!transform.transform(transformInvocation)) {
                  transformInvocation.callBack("finish on "+transform.getClass().getName());
                  return;
             }
        }
     }
}

```

`controller/src/main/java/com/fakerandroid/decoder/pipeline/TransformStream.java`:

```java
package com.fakerandroid.decoder.pipeline;

public abstract class TransformStream {
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/DexToJar.java`:

```java
package com.fakerandroid.decoder.transforms;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.dex2jar.Dex2jar;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;

import java.io.File;

public class DexToJar extends Transform {

    public DexToJar(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }

    @Override
    public boolean transform(TransformInvocation transformInvocation) {
        transformInvocation.callBack("Translating dexes to java scaffodding jar....");
        try {
            File javaScaffoding = androidProject.getJavaScaffoding();
            if(javaScaffoding.exists()){
                javaScaffoding.delete();
            }
            javaScaffoding.mkdirs();
            Dex2jar.toJar(apk.getApkFile(),javaScaffoding);
        }catch (Exception e){
            transformInvocation.callBack("Translating dexes to java scaffodding jar happen exception....");
        }
        return true;
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/DexToSmali.java`:

```java
package com.fakerandroid.decoder.transforms;
import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.smali.DexToSmaliException;
import com.fakerandroid.decoder.smali.SmaliDecoder;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;

public class DexToSmali extends Transform {

    public DexToSmali(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }
    @Override
    public boolean transform(TransformInvocation transformInvocation) {
        transformInvocation.callBack("Translating dexes to smali files....");
        List<String> names = (List<String>) androidProject.getIntermediate(AndroidProject.INTERMEDIATE_DEX_NAMES);
        AndroidProject.ManifestInfo s = (AndroidProject.ManifestInfo) androidProject.getIntermediate(AndroidProject.INTERMEDIATE_MANIFESTINFO);
        for (String name:names) {
            try {
                SmaliDecoder.decode(apk.getApkFile(),androidProject.getSmali(),name,true,Integer.valueOf(s.getMinSdkVersion()));
            } catch (DexToSmaliException e) {
                e.printStackTrace();
            }
        }
        return true;
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/Il2cppDumper.java`:

```java
package com.fakerandroid.decoder.transforms;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.il2cpp.Il2cppBinary;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;

public class Il2cppDumper extends Transform  {
    public Il2cppDumper(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }

    @Override
    public boolean transform(TransformInvocation transformInvocation) {
        transformInvocation.callBack("Checking or generating il2cppscafoding...");
        try {
            Il2cppBinary.dumpIl2cpp(apk.getApkFile(),androidProject.getCpp());
        } catch (Exception e) {
            transformInvocation.callBack("exception while excute il2cpp binary");
            e.printStackTrace();
        }
        return true;
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/Project.java`:

```java
package com.fakerandroid.decoder.transforms;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.project.ProjectMerge;
import com.fakerandroid.decoder.util.FileUtils;
import com.fakerandroid.decoder.util.PatchUtil;
import com.fakerandroid.decoder.util.TextUtil;
import java.io.File;
import java.io.IOException;

public class Project extends Transform {
    public Project(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }
    @Override
    public boolean transform(TransformInvocation transformInvocation) {
        transformInvocation.callBack("Android studio project fomarting....");
        try {
            ProjectMerge.copyProject(androidProject.getProject());
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        fixProject(androidProject);
        transformInvocation.callBack("You have faked a android studio project from apk!");
        transformInvocation.callBack("Generated project path:"+androidProject.getProject().getAbsolutePath()+".");
        return true;
    }

    private void fixProject(AndroidProject androidProject){

        AndroidProject.ManifestInfo manifestInfo = (AndroidProject.ManifestInfo) androidProject.getIntermediate(AndroidProject.INTERMEDIATE_MANIFESTINFO);
        File appBuild = androidProject.getAppBuild();
        //pkg
        try {
            FileUtils.autoReplaceStr(appBuild,"{pkg}",manifestInfo.getPakcageName());
        } catch (IOException e) {
            e.printStackTrace();
        }
        //ABI
        String abiStr = "";
        File targetjniLibs = androidProject.getjniLibs();
        File jniLibsARMV7A = new File(targetjniLibs,"armeabi-v7a");
        File armeabi = new File(targetjniLibs,"armeabi");
        if(armeabi.exists()&&!jniLibsARMV7A.exists()){
            armeabi.renameTo(jniLibsARMV7A);
        }
        if(jniLibsARMV7A.exists()){
            if(TextUtil.isEmpty(abiStr)){
                abiStr = "'armeabi-v7a'";
            }else {
                abiStr = abiStr+",'armeabi-v7a'";
            }
        }
        File jniLibsARM64V8A = new File(targetjniLibs,"arm64-v8a");
        if(jniLibsARM64V8A.exists()){
            if(TextUtil.isEmpty(abiStr)){
                abiStr = "'arm64-v8a'";
            }else {
                abiStr = abiStr+",'arm64-v8a'";
            }
        }
        if(!jniLibsARMV7A.exists()&&!jniLibsARM64V8A.exists()&&!armeabi.exists()){
            abiStr = "'armeabi-v7a','arm64-v8a'";
        }
        File jniLibsX86 = new File(targetjniLibs,"x86");

        if(jniLibsX86.exists()){
            abiStr = abiStr+",'x86'";
        }

        File jniLibsX86_64 = new File(targetjniLibs,"x86_64");
        if(jniLibsX86_64.exists()){
            abiStr = abiStr+",'x86_64'";
        }

        try {
            FileUtils.autoReplaceStr(appBuild,"{abi}",abiStr);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //buildconfig

        try {
            FileUtils.autoReplaceStr(appBuild,"{versionCode}",manifestInfo.getVersionCode()!=null?manifestInfo.getVersionCode():"1");
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            FileUtils.autoReplaceStr(appBuild,"{versionName}",manifestInfo.getVersionName()!=null?manifestInfo.getVersionName():"0.01");
        } catch (IOException e) {
            e.printStackTrace();
        }

        String minSdkVersion = manifestInfo.getMinSdkVersion();
        //FileUtil.autoReplaceStr(gameBuildGrandle,"{minSdkVersion}",minSdkVersion);
        String targetSdkVersion =manifestInfo.getTargetSdkVersion();

        if(TextUtil.isEmpty(targetSdkVersion)){
            try {
                FileUtils.autoReplaceStr(appBuild,"{targetSdkVersion}","26");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }else {
            try {
                FileUtils.autoReplaceStr(appBuild,"{targetSdkVersion}",targetSdkVersion);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/ResourceProcesser.java`:

```java
package com.fakerandroid.decoder.transforms;

import brut.androlib.meta.MetaInfo;
import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.apktool.Resources;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.util.FileUtils;
import com.fakerandroid.decoder.util.ManifestEditor;
import org.dom4j.DocumentException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ResourceProcesser extends Transform {
    @Override
    public boolean transform(TransformInvocation transformInvocation) {
        transformInvocation.callBack("Deocoding the apk file...");
        File out = androidProject.getMain();
        if(out.exists()){
            FileUtils.deleteDir(out);
        }
        out.mkdirs();
        Resources.decode(apk.getApkFile(),out);
        project(androidProject);
        discard(androidProject);
        meta(androidProject);
        fixRes(androidProject);
        return true;
    }

    public ResourceProcesser(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }

    private void meta(AndroidProject androidProject) {
        File manifest = androidProject.getAndroidManifest();
        AndroidProject.ManifestInfo manifestInfo = new AndroidProject.ManifestInfo();
        MetaInfo metaInfo = null;
        try {
            metaInfo = MetaInfo.load(new FileInputStream(androidProject.getYmlFile()));
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        }

        ManifestEditor manifestEditor = null;
        try {
            manifestEditor = new ManifestEditor(manifest);
            String packageName = manifestEditor.getPackagenName();
            manifestInfo.setPakcageName(packageName);
            String applicationName = manifestEditor.getApplicationName();
            manifestInfo.setApplicationName(applicationName);
        } catch (DocumentException e) {
            e.printStackTrace();
        }
        if(metaInfo!=null){
            manifestInfo.setVersionCode(metaInfo.versionInfo.versionCode);
            manifestInfo.setVersionName(metaInfo.versionInfo.versionName);
            manifestInfo.setMinSdkVersion(metaInfo.sdkInfo.get("minSdkVersion"));
            manifestInfo.setTargetSdkVersion(metaInfo.sdkInfo.get("targetSdkVersion"));
        }
        androidProject.addIntermediate(AndroidProject.INTERMEDIATE_MANIFESTINFO,manifestInfo);
    }

    private void discard(AndroidProject androidProject) {
        File resources = androidProject.getMain();
        List<File> fs = Arrays.asList(resources.listFiles());
        List<String> dexnames = new ArrayList<>();
        for (File f:fs){
            String fn = f.getName();
            if(fn.startsWith("classes")&&fn.endsWith(".dex")) {
                dexnames.add(fn);
                f.delete();
            }
        }
        androidProject.addIntermediate(AndroidProject.INTERMEDIATE_DEX_NAMES,dexnames);
    }

    private void project(AndroidProject androidProject) {//TODO Rename
        File resources = androidProject.getMain();
        if(!resources.exists()){
            return;
        }
        File libResources = new File(resources,"lib");
        if(libResources.exists()){
            libResources.renameTo(androidProject.getjniLibs());
        }

        File unknownResources = new File(resources,"unknown");
        if(unknownResources.exists()){
            unknownResources.renameTo(androidProject.getResources());
        }

        File originalResources = new File(resources,"original");
        if(originalResources.exists()){
            File assets = androidProject.getAssets();
            if(!assets.exists()){
                assets.mkdirs();
            }
            originalResources.renameTo(new File(assets,"original"));
        }
    }
    void fixRes(AndroidProject androidProject) {
        try {
            File fileRes = androidProject.getRes();
            func(fileRes,fileRes);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    private void func(File res, File file){
        File[] fs = file.listFiles();
        for(File f:fs){
            if(f.isDirectory())	//
                func(res,f);
            if(f.isFile()){
                if(f.getName().startsWith("$")){
                    File fixName = new File(f.getParent(),f.getName().replace("$",""));
                    funcRe(res,getFileNameNoEx(f.getName()),getFileNameNoEx(fixName.getName()));
                    f.renameTo(fixName);
                }
            }
        }
    }
    public static String getFileNameNoEx(String filename) {
        if ((filename != null) && (filename.length() > 0)) {
            int dot = filename.lastIndexOf('.');
            if ((dot >-1) && (dot < (filename.length()))) {
                return filename.substring(0, dot);
            }
        }
        return filename;
    }
    private static void funcRe(File file, String oStr, String nStr){
        File[] fs = file.listFiles();
        for(File f:fs){
            if(f.isDirectory())	//
                funcRe(f,oStr,nStr);
            if(f.isFile()){
                try {
                    if(f.getName().endsWith(".xml")){
                        FileUtils.autoReplaceStr(f,oStr,nStr);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/RuntimeBaseMerge.java`:

```java
package com.fakerandroid.decoder.transforms;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.runtime.base.RuntimeBase;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.util.FileUtils;
import com.fakerandroid.decoder.util.ManifestEditor;
import com.fakerandroid.decoder.util.TextUtil;

import java.io.File;
import java.io.IOException;

public class RuntimeBaseMerge extends Transform {

    public RuntimeBaseMerge(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }

    @Override
    public boolean transform(TransformInvocation transformInvocation)  {
        transformInvocation.callBack("Rumtime base mereging...");
        try {
            RuntimeBase.mergeRuntimeLibsJava(androidProject.getLibs());
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        RuntimeBase.mergeRuntimeLibsCpp(androidProject.getCppLibs());
        try {
            RuntimeBase.mergeRuntimeJavaCode(androidProject.getJava());
        } catch (IOException e) {
            return false;
        }
        try {
            RuntimeBase.mergeRuntimeCppCode(androidProject.getCpp());
        } catch (IOException e) {
            return false;
        }

        fixTmplCode(androidProject);
        return true;
    }

    private void fixTmplCode(AndroidProject androidProject) {
        AndroidProject.ManifestInfo manifestInfo = (AndroidProject.ManifestInfo) androidProject.getIntermediate(AndroidProject.INTERMEDIATE_MANIFESTINFO);
        File fakerActivityFile = new File(androidProject.getJava(),"com/fakerandroid/boot/FakerActivity.java");
        try {
            FileUtils.autoReplaceStr(fakerActivityFile,"{R}",manifestInfo.getPakcageName()+".R");
        } catch (IOException e) {
            e.printStackTrace();
        }
        File file  = new File(androidProject.getJava(),"com/fakerandroid/boot/FakerApp.java");
        String applicationName = manifestInfo.getApplicationName();
        if(!TextUtil.isEmpty(applicationName)) {
            try {
                FileUtils.autoReplaceStr(file,"{APPLICATION_NAME}",applicationName);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }else {
            try {
                FileUtils.autoReplaceStr(file,"{APPLICATION_NAME}","Application");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        File manifest = androidProject.getAndroidManifest();
        ManifestEditor manifestEditor = null;
        try {
            manifestEditor = new ManifestEditor(manifest);
            manifestEditor.modApplication("com.fakerandroid.boot.FakerApp");//
            manifestEditor.extractNativeLibs();
            manifestEditor.save();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

`controller/src/main/java/com/fakerandroid/decoder/transforms/RuntimeIl2cppMerge.java`:

```java
package com.fakerandroid.decoder.transforms;

import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.Transform;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.rutime.il2cpp.RuntimeIl2cpp;
import com.fakerandroid.decoder.util.FileUtils;
import java.io.File;
import java.io.IOException;

public class RuntimeIl2cppMerge extends Transform {

    public RuntimeIl2cppMerge(Apk apk, AndroidProject androidProject) {
        super(apk, androidProject);
    }

    @Override
    public boolean transform(TransformInvocation transformInvocation)  {
        File il2cppScaffoldingARM = new File(androidProject.getCpp(),"Il2cpp-Scaffolding-ARM");
        File il2cppScaffoldingARM64 = new File(androidProject.getCpp(),"Il2cpp-Scaffolding-ARM64");
        if(!il2cppScaffoldingARM.exists()&&!il2cppScaffoldingARM64.exists()) {
            return true;
        }
        transformInvocation.callBack("Runtime il2cpp merging...");
        try {
            RuntimeIl2cpp.mergeRuntimeIl2cppCpp(androidProject.getCpp());
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        try {
            RuntimeIl2cpp.mergeRuntimeIl2cppJava(androidProject.getJava());
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        fixTmplCode(androidProject);
        return true;
    }

    private void fixTmplCode(AndroidProject androidProject) {
        AndroidProject.ManifestInfo manifestInfo = (AndroidProject.ManifestInfo) androidProject.getIntermediate(AndroidProject.INTERMEDIATE_MANIFESTINFO);
        File fakerActivityFile = new File(androidProject.getJava(),"com/fakerandroid/boot/FakerActivity.java");
        try {
            FileUtils.autoReplaceStr(fakerActivityFile,"{R}",manifestInfo.getPakcageName()+".R");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

`controller/src/test/java/com/fakerandroid/decoder/TestDistribution.java`:

```java
package com.fakerandroid.decoder;
import com.fakerandroid.decoder.dex2jar.Dex2jar;
import com.fakerandroid.decoder.runtime.base.RuntimeBase;
import com.fakerandroid.decoder.smali.DexToSmaliException;
import com.fakerandroid.decoder.smali.SmaliDecoder;
import com.fakerandroid.decoder.util.TestUtils;
import com.fakerandroid.decoder.apktool.Resources;
import com.fakerandroid.decoder.exception.BinaryException;
import com.fakerandroid.decoder.exception.FakerAndroidException;
import com.fakerandroid.decoder.il2cpp.Il2cppBinary;
import org.junit.Test;
import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;

public class TestDistribution {
    Logger logger = Logger.getLogger("TestDistribution");
    static File in = TestUtils.getFileFromSampleDir("niuzai.apk");

    @Test
    public void resources() throws IOException {
        File out = TestUtils.getFileOutSampleDir("resources","niuzai");
        Resources.decode(in,out);
    }

    @Test
    public void testDex2Jar() throws IOException {
        File out = TestUtils.getFileOutSampleDir("testDex2Jar","niuzai");
        Dex2jar.toJar(in,out);
    }

    @Test
    public void testDex2Smali() throws IOException, DexToSmaliException {
        File out = TestUtils.getFileOutSampleDir("testDex2Smali","niuzai");
        SmaliDecoder.decode(in,out,"classes.dex",true,23);
    }

    @Test
    public void testIl2CppDumper() throws Exception{
        File out = TestUtils.getFileOutSampleDir("testIl2CppDumper","niuzai");
        Il2cppBinary.dumpIl2cpp(in,out);
    }

    @Test
    public void testMergeJavaLib() throws IOException, BinaryException, FakerAndroidException {
        File out = TestUtils.getFileOutSampleDir("testMergeJavaLib","niuzai");
        RuntimeBase.mergeRuntimeLibsJava(out);
    }

    @Test
    public void testMergeCppLib() throws IOException, BinaryException, FakerAndroidException {
        File out = TestUtils.getFileOutSampleDir("testMergeCppLib","niuzai");
        RuntimeBase.mergeRuntimeLibsCpp(out);
    }

    @Test
    public void testMergeCppCode() throws IOException, BinaryException, FakerAndroidException {
        File out = TestUtils.getFileOutSampleDir("testMergeCppCode","niuzai");
        RuntimeBase.mergeRuntimeCppCode(out);
    }

    @Test
    public void testMergeJavaCode() throws IOException, BinaryException, FakerAndroidException {
        File out = TestUtils.getFileOutSampleDir("testMergeJavaCode","niuzai");
        RuntimeBase.mergeRuntimeJavaCode(out);
    }
}

```

`controller/src/test/java/com/fakerandroid/decoder/TestProject.java`:

```java
package com.fakerandroid.decoder;
import com.fakerandroid.decoder.api.AndroidProject;
import com.fakerandroid.decoder.api.Transfer;
import com.fakerandroid.decoder.transforms.*;
import com.fakerandroid.decoder.util.TestUtils;
import com.luhuiguo.chinese.ChineseUtils;
import com.luhuiguo.chinese.pinyin.PinyinFormat;
import com.fakerandroid.decoder.api.Apk;
import com.fakerandroid.decoder.pipeline.TransformInvocation;
import com.fakerandroid.decoder.pipeline.TransformManager;
import org.junit.Test;
import java.io.File;
import java.io.IOException;

public class TestProject {
    static File in = TestUtils.getFileFromSampleDir("test.apk");
//    static File in = TestUtils.getFileFromSampleDir("niuzai.apk");
    @Test
    public void fakeRroject() throws IOException {
        File out = TestUtils.getFileOutSampleDir("fakeRroject","test");
        //File out = TestUtils.getFileOutSampleDir("fakeRroject","niuzai");
        TransformManager transformManager = new TransformManager(new TransformInvocation() {
            @Override
            public void callBack(String msg) {
                System.out.println(msg);
            }
        });
        Apk apk = new Apk(in);
        AndroidProject androidProject = new AndroidProject(out);
        //Decoder
        transformManager.addTransform(new ResourceProcesser(apk,androidProject));
        transformManager.addTransform(new DexToSmali(apk,androidProject));
        transformManager.addTransform(new DexToJar(apk,androidProject));
        transformManager.addTransform(new Il2cppDumper(apk,androidProject));
        //Merge
        transformManager.addTransform(new RuntimeBaseMerge(apk,androidProject));
        transformManager.addTransform(new RuntimeIl2cppMerge(apk,androidProject));

        //fix
        transformManager.addTransform(new Project(apk,androidProject));

        transformManager.action();
    }

    @Test
    public void batchFakeWithApi() {
        func(new File("D:\\Apk"));
    }

    private static void func(File file){
        File[] fs = file.listFiles();
        for(File f:fs){
            if(f.isDirectory()){
                func(f);
            }else if(f.isFile()) {
                if(f.getName().endsWith(".apk")){
                    TransformInvocation transformInvocation = new TransformInvocation() {
                        @Override
                        public void callBack(String msg) {
                            System.out.println(msg);
                        }
                    };
                    File outs = new File("D:\\Outs");
                    File projectFile = new File(outs, ChineseUtils.toPinyin(f.getName().replace(".apk",""), PinyinFormat.TONELESS_PINYIN_FORMAT).replace(" ","-"));
                    String outDir = projectFile.getAbsolutePath();
                    new Transfer(f.getAbsolutePath(),outDir,transformInvocation).translate();
                }
            }
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-cli/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
apply plugin: 'com.github.johnrengelman.shadow'

dependencies {
    implementation depends.commons_cli
    implementation project(':brut.apktool:apktool-lib')
}

buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath(depends.proguard_gradle) {
            exclude group: 'com.android.tools.build'
        }
    }
}

jar {
    manifest {
        attributes 'Main-Class' : 'brut.apktool.Main'
    }
}

task cleanOutputDirectory(type: Delete) {
    delete fileTree(dir: jar.getDestinationDirectory().getAsFile(), exclude: "apktool-cli-all.jar")
}

task proguard(type: proguard.gradle.ProGuardTask, dependsOn: shadowJar) {
    injars shadowJar.getArchiveFile()

    // Java 9 and prior uses merged package for runtime, later uses split jmod files.
    if (JavaVersion.current() <= JavaVersion.VERSION_1_8) {
        libraryjars "${System.properties['java.home']}/lib/jce.jar"
        libraryjars "${System.properties['java.home']}/lib/rt.jar"
    } else {
        libraryjars "${System.properties['java.home']}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.compiler.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.logging.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.xml.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.desktop.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.sql.jmod", jarfilter: '!**.jar', filter: '!module-info.class'

        libraryjars "${System.properties['java.home']}/jmods/jdk.unsupported.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
    }

    dontobfuscate
    dontoptimize

    keep 'public class brut.apktool.Main { public static void main(java.lang.String[]); }'
    keepclassmembers 'enum * { public static **[] values(); public static ** valueOf(java.lang.String); }'
    dontwarn 'com.google.common.base.**'
    dontwarn 'com.google.common.collect.**'
    dontwarn 'com.google.common.util.**'
    dontwarn 'javax.xml.xpath.**'
    dontnote '**'

    def outPath = jar.getDestinationDirectory().getAsFile().get().toString()
    def extension = jar.archiveExtension.get().toString()
    def outFile = outPath + '/' + "apktool" + '-' + project.apktool_version + '-small' + '.' + extension
    outjars outFile
}

proguard.dependsOn cleanOutputDirectory
tasks.getByPath(':release').dependsOn(proguard)
```

`distribution/apktool/brut.apktool/apktool-cli/src/main/java/brut/apktool/Main.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.apktool;

import brut.androlib.*;
import brut.androlib.err.CantFindFrameworkResException;
import brut.androlib.err.InFileNotFoundException;
import brut.androlib.err.OutDirExistsException;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.util.AaptManager;
import brut.util.OSDetection;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.IOException;
import java.util.logging.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class Main {
    public static void main(String[] args) throws IOException, InterruptedException, BrutException {

        // headless
        System.setProperty("java.awt.headless", "true");

        // set verbosity default
        Verbosity verbosity = Verbosity.NORMAL;

        // cli parser
        CommandLineParser parser = new DefaultParser();
        CommandLine commandLine;

        // load options
        _Options();

        try {
            commandLine = parser.parse(allOptions, args, false);

            if (! OSDetection.is64Bit()) {
                System.err.println("32 bit support is deprecated. Apktool will not support 32bit on v2.6.0.");
            }
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            usage();
            System.exit(1);
            return;
        }

        // check for verbose / quiet
        if (commandLine.hasOption("-v") || commandLine.hasOption("--verbose")) {
            verbosity = Verbosity.VERBOSE;
        } else if (commandLine.hasOption("-q") || commandLine.hasOption("--quiet")) {
            verbosity = Verbosity.QUIET;
        }
        setupLogging(verbosity);

        // check for advance mode
        if (commandLine.hasOption("advance") || commandLine.hasOption("advanced")) {
            setAdvanceMode();
        }

        boolean cmdFound = false;
        for (String opt : commandLine.getArgs()) {
            if (opt.equalsIgnoreCase("d") || opt.equalsIgnoreCase("decode")) {
                cmdDecode(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("b") || opt.equalsIgnoreCase("build")) {
                cmdBuild(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("if") || opt.equalsIgnoreCase("install-framework")) {
                cmdInstallFramework(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("empty-framework-dir")) {
                cmdEmptyFrameworkDirectory(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("list-frameworks")) {
                cmdListFrameworks(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("publicize-resources")) {
                cmdPublicizeResources(commandLine);
                cmdFound = true;
            }
        }

        // if no commands ran, run the version / usage check.
        if (!cmdFound) {
            if (commandLine.hasOption("version")) {
                _version();
                System.exit(0);
            } else {
                usage();
            }
        }
    }

    private static void cmdDecode(CommandLine cli) throws AndrolibException {
        ApkDecoder decoder = new ApkDecoder();

        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);
        File outDir;

        // check for options
        if (cli.hasOption("s") || cli.hasOption("no-src")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_NONE);
        }
        if (cli.hasOption("only-main-classes")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES);
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            System.err.println("SmaliDebugging has been removed in 2.1.0 onward. Please see: https://github.com/iBotPeaches/Apktool/issues/1061");
            System.exit(1);
        }
        if (cli.hasOption("b") || cli.hasOption("no-debug-info")) {
            decoder.setBaksmaliDebugMode(false);
        }
        if (cli.hasOption("t") || cli.hasOption("frame-tag")) {
            decoder.setFrameworkTag(cli.getOptionValue("t"));
        }
        if (cli.hasOption("f") || cli.hasOption("force")) {
            decoder.setForceDelete(true);
        }
        if (cli.hasOption("r") || cli.hasOption("no-res")) {
            decoder.setDecodeResources(ApkDecoder.DECODE_RESOURCES_NONE);
        }
        if (cli.hasOption("force-manifest")) {
            decoder.setForceDecodeManifest(ApkDecoder.FORCE_DECODE_MANIFEST_FULL);
        }
        if (cli.hasOption("no-assets")) {
            decoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_NONE);
        }
        if (cli.hasOption("k") || cli.hasOption("keep-broken-res")) {
            decoder.setKeepBrokenResources(true);
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            decoder.setFrameworkDir(cli.getOptionValue("p"));
        }
        if (cli.hasOption("m") || cli.hasOption("match-original")) {
            decoder.setAnalysisMode(true, false);
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            decoder.setApi(Integer.parseInt(cli.getOptionValue("api")));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outDir = new File(cli.getOptionValue("o"));
            decoder.setOutDir(outDir);
        } else {
            // make out folder manually using name of apk
            String outName = apkName;
            outName = outName.endsWith(".apk") ? outName.substring(0,
                    outName.length() - 4).trim() : outName + ".out";

            // make file from path
            outName = new File(outName).getName();
            outDir = new File(outName);
            decoder.setOutDir(outDir);
        }

        decoder.setApkFile(new File(apkName));

        try {
            decoder.decode();
        } catch (OutDirExistsException ex) {
            System.err
                    .println("Destination directory ("
                            + outDir.getAbsolutePath()
                            + ") "
                            + "already exists. Use -f switch if you want to overwrite it.");
            System.exit(1);
        } catch (InFileNotFoundException ex) {
            System.err.println("Input file (" + apkName + ") " + "was not found or was not readable.");
            System.exit(1);
        } catch (CantFindFrameworkResException ex) {
            System.err
                    .println("Can't find framework resources for package of id: "
                            + String.valueOf(ex.getPkgId())
                            + ". You must install proper "
                            + "framework files, see project website for more info.");
            System.exit(1);
        } catch (IOException ex) {
            System.err.println("Could not modify file. Please ensure you have permission.");
            System.exit(1);
        } catch (DirectoryException ex) {
            System.err.println("Could not modify internal dex files. Please ensure you have permission.");
            System.exit(1);
        } finally {
            try {
                decoder.close();
            } catch (IOException ignored) {}
        }
    }

    private static void cmdBuild(CommandLine cli) throws BrutException {
        String[] args = cli.getArgs();
        String appDirName = args.length < 2 ? "." : args[1];
        File outFile;
        ApkOptions apkOptions = new ApkOptions();

        // check for build options
        if (cli.hasOption("f") || cli.hasOption("force-all")) {
            apkOptions.forceBuildAll = true;
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            apkOptions.debugMode = true;
        }
        if (cli.hasOption("v") || cli.hasOption("verbose")) {
            apkOptions.verbose = true;
        }
        if (cli.hasOption("a") || cli.hasOption("aapt")) {
            apkOptions.aaptPath = cli.getOptionValue("a");
        }
        if (cli.hasOption("c") || cli.hasOption("copy-original")) {
            System.err.println("-c/--copy-original has been deprecated. Removal planned for v2.6.0 (#2129)");
            apkOptions.copyOriginalFiles = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("nc") || cli.hasOption("no-crunch")) {
            apkOptions.noCrunch = true;
        }

        // Temporary flag to enable the use of aapt2. This will tranform in time to a use-aapt1 flag, which will be
        // legacy and eventually removed.
        if (cli.hasOption("use-aapt2")) {
            apkOptions.useAapt2 = true;
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            apkOptions.forceApi = Integer.parseInt(cli.getOptionValue("api"));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outFile = new File(cli.getOptionValue("o"));
        } else {
            outFile = null;
        }

        // try and build apk
        try {
            if (cli.hasOption("a") || cli.hasOption("aapt")) {
                apkOptions.aaptVersion = AaptManager.getAaptVersion(cli.getOptionValue("a"));
            }
            new Androlib(apkOptions).build(new File(appDirName), outFile);
        } catch (BrutException ex) {
            System.err.println(ex.getMessage());
            System.exit(1);
        }
    }

    private static void cmdInstallFramework(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        ApkOptions apkOptions = new ApkOptions();
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("t") || cli.hasOption("tag")) {
            apkOptions.frameworkTag = cli.getOptionValue("t");
        }
        new Androlib(apkOptions).installFramework(new File(apkName));
    }

    private static void cmdListFrameworks(CommandLine cli) throws AndrolibException {
        ApkOptions apkOptions = new ApkOptions();
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }

        new Androlib(apkOptions).listFrameworks();
    }

    private static void cmdPublicizeResources(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        new Androlib().publicizeResources(new File(apkName));
    }

    private static void cmdEmptyFrameworkDirectory(CommandLine cli) throws AndrolibException {
        ApkOptions apkOptions = new ApkOptions();

        if (cli.hasOption("f") || cli.hasOption("force")) {
            apkOptions.forceDeleteFramework = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            apkOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }

        new Androlib(apkOptions).emptyFrameworkDirectory();
    }

    private static void _version() {
        System.out.println(Androlib.getVersion());
    }

    @SuppressWarnings("static-access")
    private static void _Options() {

        // create options
        Option versionOption = Option.builder("version")
                .longOpt("version")
                .desc("prints the version then exits")
                .build();

        Option advanceOption = Option.builder("advance")
                .longOpt("advanced")
                .desc("prints advance information.")
                .build();

        Option noSrcOption = Option.builder("s")
                .longOpt("no-src")
                .desc("Do not decode sources.")
                .build();

        Option onlyMainClassesOption = Option.builder()
                .longOpt("only-main-classes")
                .desc("Only disassemble the main dex classes (classes[0-9]*.dex) in the root.")
                .build();

        Option noResOption = Option.builder("r")
                .longOpt("no-res")
                .desc("Do not decode resources.")
                .build();

        Option forceManOption = Option.builder()
                .longOpt("force-manifest")
                .desc("Decode the APK's compiled manifest, even if decoding of resources is set to \"false\".")
                .build();

        Option noAssetOption = Option.builder()
                .longOpt("no-assets")
                .desc("Do not decode assets.")
                .build();

        Option debugDecOption = Option.builder("d")
                .longOpt("debug")
                .desc("REMOVED (DOES NOT WORK): Decode in debug mode.")
                .build();

        Option analysisOption = Option.builder("m")
                .longOpt("match-original")
                .desc("Keeps files to closest to original as possible. Prevents rebuild.")
                .build();

        Option apiLevelOption = Option.builder("api")
                .longOpt("api-level")
                .desc("The numeric api-level of the file to generate, e.g. 14 for ICS.")
                .hasArg(true)
                .argName("API")
                .build();

        Option debugBuiOption = Option.builder("d")
                .longOpt("debug")
                .desc("Sets android:debuggable to \"true\" in the APK's compiled manifest")
                .build();

        Option noDbgOption = Option.builder("b")
                .longOpt("no-debug-info")
                .desc("don't write out debug info (.local, .param, .line, etc.)")
                .build();

        Option forceDecOption = Option.builder("f")
                .longOpt("force")
                .desc("Force delete destination directory.")
                .build();

        Option frameTagOption = Option.builder("t")
                .longOpt("frame-tag")
                .desc("Uses framework files tagged by <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option frameDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Uses framework files located in <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option frameIfDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Stores framework files into <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option keepResOption = Option.builder("k")
                .longOpt("keep-broken-res")
                .desc("Use if there was an error and some resources were dropped, e.g.\n"
                        + "            \"Invalid config flags detected. Dropping resources\", but you\n"
                        + "            want to decode them anyway, even with errors. You will have to\n"
                        + "            fix them manually before building.")
                .build();

        Option forceBuiOption = Option.builder("f")
                .longOpt("force-all")
                .desc("Skip changes detection and build all files.")
                .build();

        Option aaptOption = Option.builder("a")
                .longOpt("aapt")
                .hasArg(true)
                .argName("loc")
                .desc("Loads aapt from specified location.")
                .build();

        Option aapt2Option = Option.builder()
                .longOpt("use-aapt2")
                .desc("Upgrades apktool to use experimental aapt2 binary.")
                .build();

        Option originalOption = Option.builder("c")
                .longOpt("copy-original")
                .desc("Copies original AndroidManifest.xml and META-INF. See project page for more info.")
                .build();

        Option noCrunchOption = Option.builder("nc")
                .longOpt("no-crunch")
                .desc("Disable crunching of resource files during the build step.")
                .build();

        Option tagOption = Option.builder("t")
                .longOpt("tag")
                .desc("Tag frameworks using <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option outputBuiOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of apk that gets written. Default is dist/name.apk")
                .hasArg(true)
                .argName("dir")
                .build();

        Option outputDecOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of folder that gets written. Default is apk.out")
                .hasArg(true)
                .argName("dir")
                .build();

        Option quietOption = Option.builder("q")
                .longOpt("quiet")
                .build();

        Option verboseOption = Option.builder("v")
                .longOpt("verbose")
                .build();

        // check for advance mode
        if (isAdvanceMode()) {
            DecodeOptions.addOption(noDbgOption);
            DecodeOptions.addOption(keepResOption);
            DecodeOptions.addOption(analysisOption);
            DecodeOptions.addOption(onlyMainClassesOption);
            DecodeOptions.addOption(apiLevelOption);
            DecodeOptions.addOption(noAssetOption);
            DecodeOptions.addOption(forceManOption);

            BuildOptions.addOption(apiLevelOption);
            BuildOptions.addOption(debugBuiOption);
            BuildOptions.addOption(aaptOption);
            BuildOptions.addOption(originalOption);
            BuildOptions.addOption(aapt2Option);
            BuildOptions.addOption(noCrunchOption);
        }

        // add global options
        normalOptions.addOption(versionOption);
        normalOptions.addOption(advanceOption);

        // add basic decode options
        DecodeOptions.addOption(frameTagOption);
        DecodeOptions.addOption(outputDecOption);
        DecodeOptions.addOption(frameDirOption);
        DecodeOptions.addOption(forceDecOption);
        DecodeOptions.addOption(noSrcOption);
        DecodeOptions.addOption(noResOption);

        // add basic build options
        BuildOptions.addOption(outputBuiOption);
        BuildOptions.addOption(frameDirOption);
        BuildOptions.addOption(forceBuiOption);

        // add basic framework options
        frameOptions.addOption(tagOption);
        frameOptions.addOption(frameIfDirOption);

        // add empty framework options
        emptyFrameworkOptions.addOption(forceDecOption);
        emptyFrameworkOptions.addOption(frameIfDirOption);

        // add list framework options
        listFrameworkOptions.addOption(frameIfDirOption);

        // add all, loop existing cats then manually add advance
        for (Object op : normalOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : DecodeOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : BuildOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        for (Object op : frameOptions.getOptions()) {
            allOptions.addOption((Option)op);
        }
        allOptions.addOption(apiLevelOption);
        allOptions.addOption(analysisOption);
        allOptions.addOption(debugDecOption);
        allOptions.addOption(noDbgOption);
        allOptions.addOption(forceManOption);
        allOptions.addOption(noAssetOption);
        allOptions.addOption(keepResOption);
        allOptions.addOption(debugBuiOption);
        allOptions.addOption(aaptOption);
        allOptions.addOption(originalOption);
        allOptions.addOption(verboseOption);
        allOptions.addOption(quietOption);
        allOptions.addOption(aapt2Option);
        allOptions.addOption(noCrunchOption);
        allOptions.addOption(onlyMainClassesOption);
    }

    private static String verbosityHelp() {
        if (isAdvanceMode()) {
            return "[-q|--quiet OR -v|--verbose] ";
        } else {
            return "";
        }
    }

    private static void usage() {
        _Options();
        HelpFormatter formatter = new HelpFormatter();
        formatter.setWidth(120);

        // print out license info prior to formatter.
        System.out.println(
                "Apktool v" + Androlib.getVersion() + " - a tool for reengineering Android apk files\n" +
                        "with smali v" + ApktoolProperties.get("smaliVersion") +
                        " and baksmali v" + ApktoolProperties.get("baksmaliVersion") + "\n" +
                        "Copyright 2010 Ryszard Wiśniewski <brut.alll@gmail.com>\n" +
                        "Copyright 2010 Connor Tumbleson <connor.tumbleson@gmail.com>" );
        if (isAdvanceMode()) {
            System.out.println("Apache License 2.0 (https://www.apache.org/licenses/LICENSE-2.0)\n");
        }else {
            System.out.println("");
        }

        // 4 usage outputs (general, frameworks, decode, build)
        formatter.printHelp("apktool " + verbosityHelp(), normalOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "if|install-framework [options] <framework.apk>", frameOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "d[ecode] [options] <file_apk>", DecodeOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "b[uild] [options] <app_path>", BuildOptions);
        if (isAdvanceMode()) {
            formatter.printHelp("apktool " + verbosityHelp() + "publicize-resources <file_path>", emptyOptions);
            formatter.printHelp("apktool " + verbosityHelp() + "empty-framework-dir [options]", emptyFrameworkOptions);
            formatter.printHelp("apktool " + verbosityHelp() + "list-frameworks [options]", listFrameworkOptions);
            System.out.println("");
        } else {
            System.out.println("");
        }

        // print out more information
        System.out.println(
                "For additional info, see: https://ibotpeaches.github.io/Apktool/ \n"
                        + "For smali/baksmali info, see: https://github.com/JesusFreke/smali");
    }

    private static void setupLogging(final Verbosity verbosity) {
        Logger logger = Logger.getLogger("");
        for (Handler handler : logger.getHandlers()) {
            logger.removeHandler(handler);
        }
        LogManager.getLogManager().reset();

        if (verbosity == Verbosity.QUIET) {
            return;
        }

        Handler handler = new Handler(){
            @Override
            public void publish(LogRecord record) {
                if (getFormatter() == null) {
                    setFormatter(new SimpleFormatter());
                }

                try {
                    String message = getFormatter().format(record);
                    if (record.getLevel().intValue() >= Level.WARNING.intValue()) {
                        System.err.write(message.getBytes());
                    } else {
                        if (record.getLevel().intValue() >= Level.INFO.intValue()) {
                            System.out.write(message.getBytes());
                        } else {
                            if (verbosity == Verbosity.VERBOSE) {
                                System.out.write(message.getBytes());
                            }
                        }
                    }
                } catch (Exception exception) {
                    reportError(null, exception, ErrorManager.FORMAT_FAILURE);
                }
            }
            @Override
            public void close() throws SecurityException {}
            @Override
            public void flush(){}
        };

        logger.addHandler(handler);

        if (verbosity == Verbosity.VERBOSE) {
            handler.setLevel(Level.ALL);
            logger.setLevel(Level.ALL);
        } else {
            handler.setFormatter(new Formatter() {
                @Override
                public String format(LogRecord record) {
                    return record.getLevel().toString().charAt(0) + ": "
                            + record.getMessage()
                            + System.getProperty("line.separator");
                }
            });
        }
    }

    private static boolean isAdvanceMode() {
        return advanceMode;
    }

    private static void setAdvanceMode() {
        Main.advanceMode = true;
    }

    private enum Verbosity {
        NORMAL, VERBOSE, QUIET
    }

    private static boolean advanceMode = false;

    private final static Options normalOptions;
    private final static Options DecodeOptions;
    private final static Options BuildOptions;
    private final static Options frameOptions;
    private final static Options allOptions;
    private final static Options emptyOptions;
    private final static Options emptyFrameworkOptions;
    private final static Options listFrameworkOptions;

    static {
        //normal and advance usage output
        normalOptions = new Options();
        BuildOptions = new Options();
        DecodeOptions = new Options();
        frameOptions = new Options();
        allOptions = new Options();
        emptyOptions = new Options();
        emptyFrameworkOptions = new Options();
        listFrameworkOptions = new Options();
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
import org.apache.tools.ant.filters.*

apply plugin: 'java-library'
apply plugin: 'kotlin'

dependencies {
    testImplementation("junit:junit:4.10") {
        exclude(module: 'hamcrest-core')
    }

    api project(':distribution:apktool:brut.j.dir'),
        project(':distribution:apktool:brut.j.util'),
        project(':distribution:apktool:brut.j.common')

    implementation 'org.smali:baksmali:2.4.0'
    implementation 'org.smali:smali:2.4.0'
    implementation 'xpp3:xpp3:1.1.4c'
    implementation 'xmlunit:xmlunit:1.6'
    implementation 'org.apache.commons:commons-lang3:3.1'
    implementation 'commons-io:commons-io:2.4'
    implementation 'com.google.guava:guava:14.0'
    implementation 'junit:junit:4.12'
    implementation 'org.yaml:snakeyaml:1.18:android'
//
//    implementation depends.baksmali,
//                   depends.smali,
//                   depends.snakeyaml,
//                   depends.xmlpull,
//                   depends.guava,
//                   depends.commons_lang,
//                   depends.commons_io
//
//    testImplementation depends.xmlunit
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/android/content/res/XmlResourceParser.java`:

```java
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.content.res;

import org.xmlpull.v1.XmlPullParser;

import android.util.AttributeSet;

/**
 * The XML parsing interface returned for an XML resource. This is a standard
 * XmlPullParser interface, as well as an extended AttributeSet interface and an
 * additional close() method on this interface for the client to indicate when
 * it is done reading the resource.
 */
public interface XmlResourceParser extends XmlPullParser, AttributeSet {
	/**
	 * Close this interface to the resource. Calls on the interface are no
	 * longer value after this call.
	 */
	public void close();
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/android/util/AttributeSet.java`:

```java
/*
 * Copyright 2008 Android4ME
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.util;

/**
 * @author Dmitry Skiba
 * 
 */
public interface AttributeSet {
	int getAttributeCount();

	String getAttributeName(int index);

	String getAttributeValue(int index);

	String getPositionDescription();

	int getAttributeNameResource(int index);

	int getAttributeListValue(int index, String options[], int defaultValue);

	boolean getAttributeBooleanValue(int index, boolean defaultValue);

	int getAttributeResourceValue(int index, int defaultValue);

	int getAttributeIntValue(int index, int defaultValue);

	int getAttributeUnsignedIntValue(int index, int defaultValue);

	float getAttributeFloatValue(int index, float defaultValue);

	String getIdAttribute();

	String getClassAttribute();

	int getIdAttributeResourceValue(int index);

	int getStyleAttribute();

	String getAttributeValue(String namespace, String attribute);

	int getAttributeListValue(String namespace, String attribute,
			String options[], int defaultValue);

	boolean getAttributeBooleanValue(String namespace, String attribute,
			boolean defaultValue);

	int getAttributeResourceValue(String namespace, String attribute,
			int defaultValue);

	int getAttributeIntValue(String namespace, String attribute,
			int defaultValue);

	int getAttributeUnsignedIntValue(String namespace, String attribute,
			int defaultValue);

	float getAttributeFloatValue(String namespace, String attribute,
			float defaultValue);

	// TODO: remove
	int getAttributeValueType(int index);

	int getAttributeValueData(int index);
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/android/util/TypedValue.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.util;

/**
 * Container for a dynamically typed data value. Primarily used with
 * {@link android.content.res.Resources} for holding resource values.
 */
public class TypedValue {
    /** The value contains no data. */
    public static final int TYPE_NULL = 0x00;

    /** The <var>data</var> field holds a resource identifier. */
    public static final int TYPE_REFERENCE = 0x01;
    /**
     * The <var>data</var> field holds an attribute resource identifier
     * (referencing an attribute in the current theme style, not a resource
     * entry).
     */
    public static final int TYPE_ATTRIBUTE = 0x02;
    /**
     * The <var>string</var> field holds string data. In addition, if
     * <var>data</var> is non-zero then it is the string block index of the
     * string and <var>assetCookie</var> is the set of assets the string came
     * from.
     */
    public static final int TYPE_STRING = 0x03;
    /** The <var>data</var> field holds an IEEE 754 floating point number. */
    public static final int TYPE_FLOAT = 0x04;
    /**
     * The <var>data</var> field holds a complex number encoding a dimension
     * value.
     */
    public static final int TYPE_DIMENSION = 0x05;
    /**
     * The <var>data</var> field holds a complex number encoding a fraction of a
     * container.
     */
    public static final int TYPE_FRACTION = 0x06;
    /**
     * The <var>data</var> holds a dynamic res table reference, which needs to be
     * resolved before it can be used like TYPE_REFERENCE
     */
    public static final int TYPE_DYNAMIC_REFERENCE = 0x07;
    /**
     * The <var>data</var> an attribute resource identifier, which needs to be resolved
     * before it can be used like a TYPE_ATTRIBUTE.
     */
    public static final int TYPE_DYNAMIC_ATTRIBUTE = 0x08;
    /**
     * Identifies the start of plain integer values. Any type value from this to
     * {@link #TYPE_LAST_INT} means the <var>data</var> field holds a generic
     * integer value.
     */
    public static final int TYPE_FIRST_INT = 0x10;

    /**
     * The <var>data</var> field holds a number that was originally specified in
     * decimal.
     */
    public static final int TYPE_INT_DEC = 0x10;
    /**
     * The <var>data</var> field holds a number that was originally specified in
     * hexadecimal (0xn).
     */
    public static final int TYPE_INT_HEX = 0x11;
    /**
     * The <var>data</var> field holds 0 or 1 that was originally specified as
     * "false" or "true".
     */
    public static final int TYPE_INT_BOOLEAN = 0x12;

    /**
     * Identifies the start of integer values that were specified as color
     * constants (starting with '#').
     */
    public static final int TYPE_FIRST_COLOR_INT = 0x1c;

    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #aarrggbb.
     */
    public static final int TYPE_INT_COLOR_ARGB8 = 0x1c;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #rrggbb.
     */
    public static final int TYPE_INT_COLOR_RGB8 = 0x1d;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #argb.
     */
    public static final int TYPE_INT_COLOR_ARGB4 = 0x1e;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #rgb.
     */
    public static final int TYPE_INT_COLOR_RGB4 = 0x1f;

    /**
     * Identifies the end of integer values that were specified as color
     * constants.
     */
    public static final int TYPE_LAST_COLOR_INT = 0x1f;

    /** Identifies the end of plain integer values. */
    public static final int TYPE_LAST_INT = 0x1f;

	/* ------------------------------------------------------------ */

    /** Complex data: bit location of unit information. */
    public static final int COMPLEX_UNIT_SHIFT = 0;
    /**
     * Complex data: mask to extract unit information (after shifting by
     * {@link #COMPLEX_UNIT_SHIFT}). This gives us 16 possible types, as defined
     * below.
     */
    public static final int COMPLEX_UNIT_MASK = 0xf;

    /** {@link #TYPE_DIMENSION} complex unit: Value is raw pixels. */
    public static final int COMPLEX_UNIT_PX = 0;
    /**
     * {@link #TYPE_DIMENSION} complex unit: Value is Device Independent Pixels.
     */
    public static final int COMPLEX_UNIT_DIP = 1;
    /** {@link #TYPE_DIMENSION} complex unit: Value is a scaled pixel. */
    public static final int COMPLEX_UNIT_SP = 2;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in points. */
    public static final int COMPLEX_UNIT_PT = 3;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in inches. */
    public static final int COMPLEX_UNIT_IN = 4;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in millimeters. */
    public static final int COMPLEX_UNIT_MM = 5;

    /**
     * {@link #TYPE_FRACTION} complex unit: A basic fraction of the overall size.
     */
    public static final int COMPLEX_UNIT_FRACTION = 0;
    /** {@link #TYPE_FRACTION} complex unit: A fraction of the parent size. */
    public static final int COMPLEX_UNIT_FRACTION_PARENT = 1;

    /**
     * Complex data: where the radix information is, telling where the decimal
     * place appears in the mantissa.
     */
    public static final int COMPLEX_RADIX_SHIFT = 4;
    /**
     * Complex data: mask to extract radix information (after shifting by
     * {@link #COMPLEX_RADIX_SHIFT}). This give us 4 possible fixed point
     * representations as defined below.
     */
    public static final int COMPLEX_RADIX_MASK = 0x3;

    /** Complex data: the mantissa is an integral number -- i.e., 0xnnnnnn.0 */
    public static final int COMPLEX_RADIX_23p0 = 0;
    /** Complex data: the mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn */
    public static final int COMPLEX_RADIX_16p7 = 1;
    /** Complex data: the mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn */
    public static final int COMPLEX_RADIX_8p15 = 2;
    /** Complex data: the mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn */
    public static final int COMPLEX_RADIX_0p23 = 3;

    /** Complex data: bit location of mantissa information. */
    public static final int COMPLEX_MANTISSA_SHIFT = 8;
    /**
     * Complex data: mask to extract mantissa information (after shifting by
     * {@link #COMPLEX_MANTISSA_SHIFT}). This gives us 23 bits of precision; the
     * top bit is the sign.
     */
    public static final int COMPLEX_MANTISSA_MASK = 0xffffff;

	/* ------------------------------------------------------------ */

    /**
     * {@link #TYPE_NULL} data indicating the value was not specified.
     */
    public static final int DATA_NULL_UNDEFINED = 0;
    /**
     * {@link #TYPE_NULL} data indicating the value was explicitly set to null.
     */
    public static final int DATA_NULL_EMPTY = 1;

    /* ------------------------------------------------------------ */

    /**
     * If {@link #density} is equal to this value, then the density should be
     * treated as the system's default density value:
     * {@link DisplayMetrics#DENSITY_DEFAULT}.
     */
    public static final int DENSITY_DEFAULT = 0;

    /**
     * If {@link #density} is equal to this value, then there is no density
     * associated with the resource and it should not be scaled.
     */
    public static final int DENSITY_NONE = 0xffff;

	/* ------------------------------------------------------------ */

    /**
     * The type held by this value, as defined by the constants here. This tells
     * you how to interpret the other fields in the object.
     */
    public int type;

    private static final float MANTISSA_MULT = 1.0f / (1 << TypedValue.COMPLEX_MANTISSA_SHIFT);
    private static final float[] RADIX_MULTS = new float[] {
            1.0f * MANTISSA_MULT, 1.0f / (1 << 7) * MANTISSA_MULT,
            1.0f / (1 << 15) * MANTISSA_MULT, 1.0f / (1 << 23) * MANTISSA_MULT };

    /**
     * Retrieve the base value from a complex data integer. This uses the
     * {@link #COMPLEX_MANTISSA_MASK} and {@link #COMPLEX_RADIX_MASK} fields of
     * the data to compute a floating point representation of the number they
     * describe. The units are ignored.
     *
     * @param complex
     *            A complex data value.
     *
     * @return A floating point value corresponding to the complex data.
     */
    public static float complexToFloat(int complex) {
        return (complex & (TypedValue.COMPLEX_MANTISSA_MASK << TypedValue.COMPLEX_MANTISSA_SHIFT))
                * RADIX_MULTS[(complex >> TypedValue.COMPLEX_RADIX_SHIFT)
                & TypedValue.COMPLEX_RADIX_MASK];
    }

    private static final String[] DIMENSION_UNIT_STRS = new String[] { "px",
            "dip", "sp", "pt", "in", "mm" };
    private static final String[] FRACTION_UNIT_STRS = new String[] { "%", "%p" };

    /**
     * Perform type conversion as per {@link #coerceToString()} on an explicitly
     * supplied type and data.
     *
     * @param type
     *            The data type identifier.
     * @param data
     *            The data value.
     *
     * @return String The coerced string value. If the value is null or the type
     *         is not known, null is returned.
     */
    public static final String coerceToString(int type, int data) {
        switch (type) {
            case TYPE_NULL:
                return null;
            case TYPE_REFERENCE:
                return "@" + data;
            case TYPE_ATTRIBUTE:
                return "?" + data;
            case TYPE_FLOAT:
                return Float.toString(Float.intBitsToFloat(data));
            case TYPE_DIMENSION:
                return Float.toString(complexToFloat(data))
                        + DIMENSION_UNIT_STRS[(data >> COMPLEX_UNIT_SHIFT)
                        & COMPLEX_UNIT_MASK];
            case TYPE_FRACTION:
                return Float.toString(complexToFloat(data) * 100)
                        + FRACTION_UNIT_STRS[(data >> COMPLEX_UNIT_SHIFT)
                        & COMPLEX_UNIT_MASK];
            case TYPE_INT_HEX:
                return String.format("0x%08X", data);
            case TYPE_INT_BOOLEAN:
                return data != 0 ? "true" : "false";
        }

        if (type >= TYPE_FIRST_COLOR_INT && type <= TYPE_LAST_COLOR_INT) {
            String res = String.format("%08x", data);
            char[] vals = res.toCharArray();
            switch (type) {
                default:
                case TYPE_INT_COLOR_ARGB8:// #AaRrGgBb
                    break;
                case TYPE_INT_COLOR_RGB8:// #FFRrGgBb->#RrGgBb
                    res = res.substring(2);
                    break;
                case TYPE_INT_COLOR_ARGB4:// #AARRGGBB->#ARGB
                    res = new StringBuffer().append(vals[0]).append(vals[2])
                            .append(vals[4]).append(vals[6]).toString();
                    break;
                case TYPE_INT_COLOR_RGB4:// #FFRRGGBB->#RGB
                    res = new StringBuffer().append(vals[2]).append(vals[4])
                            .append(vals[6]).toString();
                    break;
            }
            return "#" + res;
        } else if (type >= TYPE_FIRST_INT && type <= TYPE_LAST_INT) {
            String res;
            switch (type) {
                default:
                case TYPE_INT_DEC:
                    res = Integer.toString(data);
                    break;
            }
            return res;
        }

        return null;
    }

}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/Androlib.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.UsesFramework;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.data.ResUnknownFiles;
import brut.directory.ExtFile;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.androlib.src.SmaliBuilder;
import brut.androlib.src.SmaliDecoder;
import brut.common.BrutException;
import brut.directory.*;
import brut.util.BrutIO;
import brut.util.OS;
import java.io.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class Androlib {
    private final AndrolibResources mAndRes = new AndrolibResources();
    protected final ResUnknownFiles mResUnknownFiles = new ResUnknownFiles();
    public ApkOptions apkOptions;
    private int mMinSdkVersion = 0;

    public Androlib(ApkOptions apkOptions) {
        this.apkOptions = apkOptions;
        mAndRes.apkOptions = apkOptions;
    }

    public Androlib() {
        this.apkOptions = new ApkOptions();
        mAndRes.apkOptions = this.apkOptions;
    }

    public ResTable getResTable(ExtFile apkFile)
            throws AndrolibException {
        return mAndRes.getResTable(apkFile, true);
    }

    public ResTable getResTable(ExtFile apkFile, boolean loadMainPkg)
            throws AndrolibException {
        return mAndRes.getResTable(apkFile, loadMainPkg);
    }

    public void decodeSourcesRaw(ExtFile apkFile, File outDir, String filename)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw " + filename + " file...");
            apkFile.getDirectory().copyToDir(outDir, filename);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeSourcesSmali(File apkFile, File outDir, String filename, boolean bakdeb, int api)
            throws AndrolibException {
        try {
            File smaliDir;
            if (filename.equalsIgnoreCase("classes.dex")) {
                smaliDir = new File(outDir, SMALI_DIRNAME);
            } else {
                smaliDir = new File(outDir, SMALI_DIRNAME + "_" + filename.substring(0, filename.indexOf(".")));
            }
            OS.rmdir(smaliDir);
            smaliDir.mkdirs();
            LOGGER.info("Baksmaling " + filename + "...");
            SmaliDecoder.decode(apkFile, smaliDir, filename, bakdeb, api);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifestRaw(ExtFile apkFile, File outDir)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw manifest...");
            apkFile.getDirectory().copyToDir(outDir, APK_MANIFEST_FILENAMES);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifestFull(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decodeManifest(resTable, apkFile, outDir);
    }

    public void decodeResourcesRaw(ExtFile apkFile, File outDir)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw resources...");
            apkFile.getDirectory().copyToDir(outDir, APK_RESOURCES_FILENAMES);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeResourcesFull(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decode(resTable, apkFile, outDir);
    }

    public void decodeManifestWithResources(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decodeManifestWithResources(resTable, apkFile, outDir);
    }

    public void decodeRawFiles(ExtFile apkFile, File outDir, short decodeAssetMode)
            throws AndrolibException {
        LOGGER.info("Copying assets and libs...");
        try {
            Directory in = apkFile.getDirectory();

            if (decodeAssetMode == ApkDecoder.DECODE_ASSETS_FULL) {
                if (in.containsDir("assets")) {
                    in.copyToDir(outDir, "assets");
                }
            }
            if (in.containsDir("lib")) {
                in.copyToDir(outDir, "lib");
            }
            if (in.containsDir("libs")) {
                in.copyToDir(outDir, "libs");
            }
            if (in.containsDir("kotlin")) {
                in.copyToDir(outDir, "kotlin");
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void recordUncompressedFiles(ExtFile apkFile, Collection<String> uncompressedFilesOrExts) throws AndrolibException {
        try {
            Directory unk = apkFile.getDirectory();
            Set<String> files = unk.getFiles(true);

            for (String file : files) {
                if (isAPKFileNames(file) && unk.getCompressionLevel(file) == 0) {
                    String ext = "";
                    if (unk.getSize(file) != 0) {
                        ext = FilenameUtils.getExtension(file);
                    }

                    if (ext.isEmpty() || !NO_COMPRESS_PATTERN.matcher(ext).find()) {
                        ext = file;
                    }
                    if (!uncompressedFilesOrExts.contains(ext)) {
                        uncompressedFilesOrExts.add(ext);
                    }
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private boolean isAPKFileNames(String file) {
        for (String apkFile : APK_STANDARD_ALL_FILENAMES) {
            if (apkFile.equals(file) || file.startsWith(apkFile + "/")) {
                return true;
            }
        }
        return false;
    }

    public void decodeUnknownFiles(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        LOGGER.info("Copying unknown files...");
        File unknownOut = new File(outDir, UNK_DIRNAME);
        try {
            Directory unk = apkFile.getDirectory();

            // loop all items in container recursively, ignoring any that are pre-defined by aapt
            Set<String> files = unk.getFiles(true);
            for (String file : files) {
                if (!isAPKFileNames(file) && !file.endsWith(".dex")) {

                    // copy file out of archive into special "unknown" folder
                    unk.copyToDir(unknownOut, file);
                    // lets record the name of the file, and its compression type
                    // so that we may re-include it the same way
                    mResUnknownFiles.addUnknownFileInfo(file, String.valueOf(unk.getCompressionLevel(file)));
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void writeOriginalFiles(ExtFile apkFile, File outDir)
            throws AndrolibException {
        LOGGER.info("Copying original files...");
        File originalDir = new File(outDir, "original");
        if (!originalDir.exists()) {
            originalDir.mkdirs();
        }

        try {
            Directory in = apkFile.getDirectory();
            if (in.containsFile("AndroidManifest.xml")) {
                in.copyToDir(originalDir, "AndroidManifest.xml");
            }
            if (in.containsDir("META-INF")) {
                in.copyToDir(originalDir, "META-INF");

                if (in.containsDir("META-INF/services")) {
                    // If the original APK contains the folder META-INF/services folder
                    // that is used for service locators (like coroutines on android),
                    // copy it to the destination folder so it does not get dropped.
                    LOGGER.info("Copying META-INF/services directory");
                    in.copyToDir(outDir, "META-INF/services");
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void writeMetaFile(File mOutDir, MetaInfo meta)
            throws AndrolibException {
        try {
            meta.save(new File(mOutDir, "apktool.yml"));
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public MetaInfo readMetaFile(ExtFile appDir)
            throws AndrolibException {
        try(
                InputStream in = appDir.getDirectory().getFileInput("apktool.yml")
        ) {
            return MetaInfo.load(in);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void build(File appDir, File outFile) throws BrutException {
        build(new ExtFile(appDir), outFile);
    }

    public void build(ExtFile appDir, File outFile)
            throws BrutException {
//        LOGGER.info("Using Apktool " + Androlib.getVersion());
        MetaInfo meta = readMetaFile(appDir);
        apkOptions.isFramework = meta.isFrameworkApk;
        apkOptions.resourcesAreCompressed = meta.compressionType;
        apkOptions.doNotCompress = meta.doNotCompress;

        mAndRes.setSdkInfo(meta.sdkInfo);
        mAndRes.setPackageId(meta.packageInfo);
        mAndRes.setPackageRenamed(meta.packageInfo);
        mAndRes.setVersionInfo(meta.versionInfo);
        mAndRes.setSharedLibrary(meta.sharedLibrary);
        mAndRes.setSparseResources(meta.sparseResources);

        if (meta.sdkInfo != null && meta.sdkInfo.get("minSdkVersion") != null) {
            String minSdkVersion = meta.sdkInfo.get("minSdkVersion");
            mMinSdkVersion = mAndRes.getMinSdkVersionFromAndroidCodename(meta, minSdkVersion);
        }

        if (outFile == null) {
            String outFileName = meta.apkFileName;
            outFile = new File(appDir, "dist" + File.separator + (outFileName == null ? "out.apk" : outFileName));
        }

        new File(appDir, APK_DIRNAME).mkdirs();
        File manifest = new File(appDir, "AndroidManifest.xml");
        File manifestOriginal = new File(appDir, "AndroidManifest.xml.orig");

        buildSources(appDir);
        buildNonDefaultSources(appDir);
        buildManifestFile(appDir, manifest, manifestOriginal);
        buildResources(appDir, meta.usesFramework);
        buildLibs(appDir);
        buildCopyOriginalFiles(appDir);
        buildApk(appDir, outFile);

        // we must go after the Apk is built, and copy the files in via Zip
        // this is because Aapt won't add files it doesn't know (ex unknown files)
        buildUnknownFiles(appDir, outFile, meta);

        // we copied the AndroidManifest.xml to AndroidManifest.xml.orig so we can edit it
        // lets restore the unedited one, to not change the original
        if (manifest.isFile() && manifest.exists() && manifestOriginal.isFile()) {
            try {
                if (new File(appDir, "AndroidManifest.xml").delete()) {
                    FileUtils.moveFile(manifestOriginal, manifest);
                }
            } catch (IOException ex) {
                throw new AndrolibException(ex.getMessage());
            }
        }
        LOGGER.info("Built apk...");
    }

    private void buildManifestFile(File appDir, File manifest, File manifestOriginal)
            throws AndrolibException {

        // If we decoded in "raw", we cannot patch AndroidManifest
        if (new File(appDir, "resources.arsc").exists()) {
            return;
        }
        if (manifest.isFile() && manifest.exists()) {
            try {
                if (manifestOriginal.exists()) {
                    manifestOriginal.delete();
                }
                FileUtils.copyFile(manifest, manifestOriginal);
                ResXmlPatcher.fixingPublicAttrsInProviderAttributes(manifest);
            } catch (IOException ex) {
                throw new AndrolibException(ex.getMessage());
            }
        }
    }

    public void buildSources(File appDir)
            throws AndrolibException {
        if (!buildSourcesRaw(appDir, "classes.dex") && !buildSourcesSmali(appDir, "smali", "classes.dex")) {
            LOGGER.warning("Could not find sources");
        }
    }

    public void buildNonDefaultSources(ExtFile appDir)
            throws AndrolibException {
        try {
            // loop through any smali_ directories for multi-dex apks
            Map<String, Directory> dirs = appDir.getDirectory().getDirs();
            for (Map.Entry<String, Directory> directory : dirs.entrySet()) {
                String name = directory.getKey();
                if (name.startsWith("smali_")) {
                    String filename = name.substring(name.indexOf("_") + 1) + ".dex";

                    if (!buildSourcesRaw(appDir, filename) && !buildSourcesSmali(appDir, name, filename)) {
                        LOGGER.warning("Could not find sources");
                    }
                }
            }

            // loop through any classes#.dex files for multi-dex apks
            File[] dexFiles = appDir.listFiles();
            if (dexFiles != null) {
                for (File dex : dexFiles) {

                    // skip classes.dex because we have handled it in buildSources()
                    if (dex.getName().endsWith(".dex") && ! dex.getName().equalsIgnoreCase("classes.dex")) {
                        buildSourcesRaw(appDir, dex.getName());
                    }
                }
            }
        } catch(DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildSourcesRaw(File appDir, String filename)
            throws AndrolibException {
        File working = new File(appDir, filename);
        if (!working.exists()) {
            return false;
        }
        File stored = new File(appDir, APK_DIRNAME + "/" + filename);
        if (apkOptions.forceBuildAll || isModified(working, stored)) {
            LOGGER.info("Copying " + appDir.toString() + " " + filename + " file...");
            try {
                BrutIO.copyAndClose(new FileInputStream(working), new FileOutputStream(stored));
                return true;
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
        }
        return true;
    }

    public boolean buildSourcesSmali(File appDir, String folder, String filename)
            throws AndrolibException {
        ExtFile smaliDir = new ExtFile(appDir, folder);
        if (!smaliDir.exists()) {
            return false;
        }
        File dex = new File(appDir, APK_DIRNAME + "/" + filename);
        if (! apkOptions.forceBuildAll) {
            LOGGER.info("Checking whether sources has changed...");
        }
        if (apkOptions.forceBuildAll || isModified(smaliDir, dex)) {
            LOGGER.info("Smaling " + folder + " folder into " + filename + "...");
            dex.delete();
            SmaliBuilder.build(smaliDir, dex, apkOptions.forceApi > 0 ? apkOptions.forceApi : mMinSdkVersion);
        }
        return true;
    }

    public void buildResources(ExtFile appDir, UsesFramework usesFramework)
            throws BrutException {
        if (!buildResourcesRaw(appDir) && !buildResourcesFull(appDir, usesFramework)
                && !buildManifest(appDir, usesFramework)) {
            LOGGER.warning("Could not find resources");
        }
    }

    public boolean buildResourcesRaw(ExtFile appDir)
            throws AndrolibException {
        try {
            if (!new File(appDir, "resources.arsc").exists()) {
                return false;
            }
            File apkDir = new File(appDir, APK_DIRNAME);
            if (! apkOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }
            if (apkOptions.forceBuildAll || isModified(newFiles(APK_RESOURCES_FILENAMES, appDir),
                    newFiles(APK_RESOURCES_FILENAMES, apkDir))) {
                LOGGER.info("Copying raw resources...");
                appDir.getDirectory().copyToDir(apkDir, APK_RESOURCES_FILENAMES);
            }
            return true;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildResourcesFull(File appDir, UsesFramework usesFramework)
            throws AndrolibException {
        try {
            if (!new File(appDir, "res").exists()) {
                return false;
            }
            if (! apkOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }
            File apkDir = new File(appDir, APK_DIRNAME);
            File resourceFile = new File(apkDir.getParent(), "resources.zip");

            if (apkOptions.forceBuildAll || isModified(newFiles(APP_RESOURCES_FILENAMES, appDir),
                    newFiles(APK_RESOURCES_FILENAMES, apkDir)) || (apkOptions.isAapt2() && !isFile(resourceFile))) {
                LOGGER.info("Building resources...");

                if (apkOptions.debugMode) {
                    if (apkOptions.isAapt2()) {
                        LOGGER.info("Using aapt2 - setting 'debuggable' attribute to 'true' in AndroidManifest.xml");
                        ResXmlPatcher.setApplicationDebugTagTrue(new File(appDir, "AndroidManifest.xml"));
                    } else {
                        ResXmlPatcher.removeApplicationDebugTag(new File(appDir, "AndroidManifest.xml"));
                    }
                }

                File apkFile = File.createTempFile("APKTOOL", null);
                apkFile.delete();
                resourceFile.delete();

                File ninePatch = new File(appDir, "9patch");
                if (!ninePatch.exists()) {
                    ninePatch = null;
                }
                mAndRes.aaptPackage(apkFile, new File(appDir,
                                "AndroidManifest.xml"), new File(appDir, "res"),
                        ninePatch, null, parseUsesFramework(usesFramework));

                Directory tmpDir = new ExtFile(apkFile).getDirectory();

                // Sometimes an application is built with a resources.arsc file with no resources,
                // Apktool assumes it will have a rebuilt arsc file, when it doesn't. So if we
                // encounter a copy error, move to a warning and continue on. (#1730)
                try {
                    tmpDir.copyToDir(apkDir,
                            tmpDir.containsDir("res") ? APK_RESOURCES_FILENAMES
                                    : APK_RESOURCES_WITHOUT_RES_FILENAMES);
                } catch (DirectoryException ex) {
                    LOGGER.warning(ex.getMessage());
                }

                // delete tmpDir
                apkFile.delete();
            }
            return true;
        } catch (IOException | BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildManifestRaw(ExtFile appDir)
            throws AndrolibException {
        try {
            File apkDir = new File(appDir, APK_DIRNAME);
            LOGGER.info("Copying raw AndroidManifest.xml...");
            appDir.getDirectory().copyToDir(apkDir, APK_MANIFEST_FILENAMES);
            return true;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildManifest(ExtFile appDir, UsesFramework usesFramework)
            throws BrutException {
        try {
            if (!new File(appDir, "AndroidManifest.xml").exists()) {
                return false;
            }
            if (! apkOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }

            File apkDir = new File(appDir, APK_DIRNAME);

            if (apkOptions.forceBuildAll || isModified(newFiles(APK_MANIFEST_FILENAMES, appDir),
                    newFiles(APK_MANIFEST_FILENAMES, apkDir))) {
                LOGGER.info("Building AndroidManifest.xml...");

                File apkFile = File.createTempFile("APKTOOL", null);
                apkFile.delete();

                File ninePatch = new File(appDir, "9patch");
                if (!ninePatch.exists()) {
                    ninePatch = null;
                }

                mAndRes.aaptPackage(apkFile, new File(appDir,
                                "AndroidManifest.xml"), null, ninePatch, null,
                        parseUsesFramework(usesFramework));

                Directory tmpDir = new ExtFile(apkFile).getDirectory();
                tmpDir.copyToDir(apkDir, APK_MANIFEST_FILENAMES);
            }
            return true;
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException(ex);
        } catch (AndrolibException ex) {
            LOGGER.warning("Parse AndroidManifest.xml failed, treat it as raw file.");
            return buildManifestRaw(appDir);
        }
    }

    public void buildLibs(File appDir) throws AndrolibException {
        buildLibrary(appDir, "lib");
        buildLibrary(appDir, "libs");
        buildLibrary(appDir, "kotlin");
        buildLibrary(appDir, "META-INF/services");
    }

    public void buildLibrary(File appDir, String folder) throws AndrolibException {
        File working = new File(appDir, folder);

        if (! working.exists()) {
            return;
        }

        File stored = new File(appDir, APK_DIRNAME + "/" + folder);
        if (apkOptions.forceBuildAll || isModified(working, stored)) {
            LOGGER.info("Copying libs... (/" + folder + ")");
            try {
                OS.rmdir(stored);
                OS.cpdir(working, stored);
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
        }
    }

    public void buildCopyOriginalFiles(File appDir)
            throws AndrolibException {
        if (apkOptions.copyOriginalFiles) {
            File originalDir = new File(appDir, "original");
            if (originalDir.exists()) {
                try {
                    LOGGER.info("Copy original files...");
                    Directory in = (new ExtFile(originalDir)).getDirectory();
                    if (in.containsFile("AndroidManifest.xml")) {
                        LOGGER.info("Copy AndroidManifest.xml...");
                        in.copyToDir(new File(appDir, APK_DIRNAME), "AndroidManifest.xml");
                    }
                    if (in.containsDir("META-INF")) {
                        LOGGER.info("Copy META-INF...");
                        in.copyToDir(new File(appDir, APK_DIRNAME), "META-INF");
                    }
                } catch (DirectoryException ex) {
                    throw new AndrolibException(ex);
                }
            }
        }
    }

    public void buildUnknownFiles(File appDir, File outFile, MetaInfo meta)
            throws AndrolibException {
        if (meta.unknownFiles != null) {
            LOGGER.info("Copying unknown files/dir...");

            Map<String, String> files = meta.unknownFiles;
            File tempFile = new File(outFile.getParent(), outFile.getName() + ".apktool_temp");
            boolean renamed = outFile.renameTo(tempFile);
            if (!renamed) {
                throw new AndrolibException("Unable to rename temporary file");
            }

            try (
                    ZipFile inputFile = new ZipFile(tempFile);
                    ZipOutputStream actualOutput = new ZipOutputStream(new FileOutputStream(outFile))
            ) {
                copyExistingFiles(inputFile, actualOutput);
                copyUnknownFiles(appDir, actualOutput, files);
            } catch (IOException | BrutException ex) {
                throw new AndrolibException(ex);
            }

            // Remove our temporary file.
            tempFile.delete();
        }
    }

    private void copyExistingFiles(ZipFile inputFile, ZipOutputStream outputFile) throws IOException {
        // First, copy the contents from the existing outFile:
        Enumeration<? extends ZipEntry> entries = inputFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = new ZipEntry(entries.nextElement());

            // We can't reuse the compressed size because it depends on compression sizes.
            entry.setCompressedSize(-1);
            outputFile.putNextEntry(entry);

            // No need to create directory entries in the final apk
            if (! entry.isDirectory()) {
                BrutIO.copy(inputFile, outputFile, entry);
            }

            outputFile.closeEntry();
        }
    }

    private void copyUnknownFiles(File appDir, ZipOutputStream outputFile, Map<String, String> files)
            throws BrutException, IOException {
        File unknownFileDir = new File(appDir, UNK_DIRNAME);

        // loop through unknown files
        for (Map.Entry<String,String> unknownFileInfo : files.entrySet()) {
            File inputFile = new File(unknownFileDir, BrutIO.sanitizeUnknownFile(unknownFileDir, unknownFileInfo.getKey()));
            if (inputFile.isDirectory()) {
                continue;
            }

            ZipEntry newEntry = new ZipEntry(unknownFileInfo.getKey());
            int method = Integer.parseInt(unknownFileInfo.getValue());
            LOGGER.fine(String.format("Copying unknown file %s with method %d", unknownFileInfo.getKey(), method));
            if (method == ZipEntry.STORED) {
                newEntry.setMethod(ZipEntry.STORED);
                newEntry.setSize(inputFile.length());
                newEntry.setCompressedSize(-1);
                BufferedInputStream unknownFile = new BufferedInputStream(new FileInputStream(inputFile));
                CRC32 crc = BrutIO.calculateCrc(unknownFile);
                newEntry.setCrc(crc.getValue());
            } else {
                newEntry.setMethod(ZipEntry.DEFLATED);
            }
            outputFile.putNextEntry(newEntry);

            BrutIO.copy(inputFile, outputFile);
            outputFile.closeEntry();
        }
    }

    public void buildApk(File appDir, File outApk) throws AndrolibException {
        LOGGER.info("Building apk file...");
        if (outApk.exists()) {
            outApk.delete();
        } else {
            File outDir = outApk.getParentFile();
            if (outDir != null && !outDir.exists()) {
                outDir.mkdirs();
            }
        }
        File assetDir = new File(appDir, "assets");
        if (!assetDir.exists()) {
            assetDir = null;
        }
        mAndRes.zipPackage(outApk, new File(appDir, APK_DIRNAME), assetDir);
    }

    public void publicizeResources(File arscFile) throws AndrolibException {
        mAndRes.publicizeResources(arscFile);
    }

    public void installFramework(File frameFile)
            throws AndrolibException {
        mAndRes.installFramework(frameFile);
    }

    public void listFrameworks() throws AndrolibException {
        mAndRes.listFrameworkDirectory();
    }

    public void emptyFrameworkDirectory() throws AndrolibException {
        mAndRes.emptyFrameworkDirectory();
    }

    public boolean isFrameworkApk(ResTable resTable) {
        for (ResPackage pkg : resTable.listMainPackages()) {
            if (pkg.getId() < 64) {
                return true;
            }
        }
        return false;
    }

    public static String getVersion() {
        return ApktoolProperties.get("application.version");
    }

    private File[] parseUsesFramework(UsesFramework usesFramework)
            throws AndrolibException {
        if (usesFramework == null) {
            return null;
        }

        List<Integer> ids = usesFramework.ids;
        if (ids == null || ids.isEmpty()) {
            return null;
        }

        String tag = usesFramework.tag;
        File[] files = new File[ids.size()];
        int i = 0;
        for (int id : ids) {
            files[i++] = mAndRes.getFrameworkApk(id, tag);
        }
        return files;
    }

    private boolean isModified(File working, File stored) {
        return ! stored.exists() || BrutIO.recursiveModifiedTime(working) > BrutIO .recursiveModifiedTime(stored);
    }

    private boolean isFile(File working) {
        return working.exists();
    }

    private boolean isModified(File[] working, File[] stored) {
        for (int i = 0; i < stored.length; i++) {
            if (!stored[i].exists()) {
                return true;
            }
        }
        return BrutIO.recursiveModifiedTime(working) > BrutIO.recursiveModifiedTime(stored);
    }

    private File[] newFiles(String[] names, File dir) {
        File[] files = new File[names.length];
        for (int i = 0; i < names.length; i++) {
            files[i] = new File(dir, names[i]);
        }
        return files;
    }

    public void close() throws IOException {
        mAndRes.close();
    }

    private final static Logger LOGGER = Logger.getLogger(Androlib.class.getName());

    private final static String SMALI_DIRNAME = "smali";
    private final static String APK_DIRNAME = "build/apk";
    private final static String UNK_DIRNAME = "unknown";
    private final static String[] APK_RESOURCES_FILENAMES = new String[] {
            "resources.arsc", "AndroidManifest.xml", "res" };
    private final static String[] APK_RESOURCES_WITHOUT_RES_FILENAMES = new String[] {
            "resources.arsc", "AndroidManifest.xml" };
    private final static String[] APP_RESOURCES_FILENAMES = new String[] {
            "AndroidManifest.xml", "res" };
    private final static String[] APK_MANIFEST_FILENAMES = new String[] {
            "AndroidManifest.xml" };
    private final static String[] APK_STANDARD_ALL_FILENAMES = new String[] {
            "classes.dex", "AndroidManifest.xml", "resources.arsc", "res", "r", "R",
            "lib", "libs", "assets", "META-INF", "kotlin" };
    private final static Pattern NO_COMPRESS_PATTERN = Pattern.compile("(" +
            "jpg|jpeg|png|gif|wav|mp2|mp3|ogg|aac|mpg|mpeg|mid|midi|smf|jet|rtttl|imy|xmf|mp4|" +
            "m4a|m4v|3gp|3gpp|3g2|3gpp2|amr|awb|wma|wmv|webm|mkv)$");
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/AndrolibException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.common.BrutException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class AndrolibException extends BrutException {
    public AndrolibException() {
    }

    public AndrolibException(String message) {
        super(message);
    }

    public AndrolibException(String message, Throwable cause) {
        super(message, cause);
    }

    public AndrolibException(Throwable cause) {
        super(cause);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.err.InFileNotFoundException;
import brut.androlib.err.OutDirExistsException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.PackageInfo;
import brut.androlib.meta.UsesFramework;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTable;
import brut.directory.ExtFile;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.util.OS;
import com.google.common.base.Strings;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ApkDecoder {
    public ApkDecoder() {
        this(new Androlib());
    }

    public ApkDecoder(Androlib androlib) {
        mAndrolib = androlib;
    }

    public ApkDecoder(File apkFile) {
        this(apkFile, new Androlib());
    }

    public ApkDecoder(File apkFile, Androlib androlib) {
        mAndrolib = androlib;
        setApkFile(apkFile);
    }

    public void setApkFile(File apkFile) {
        if (mApkFile != null) {
            try {
                mApkFile.close();
            } catch (IOException ignored) {}
        }

        mApkFile = new ExtFile(apkFile);
        mResTable = null;
    }

    public void setOutDir(File outDir) throws AndrolibException {
        mOutDir = outDir;
    }

    public void setApi(int api) {
        mApi = api;
    }

    public void decode() throws AndrolibException, IOException, DirectoryException {
        try {
            File outDir = getOutDir();
            AndrolibResources.sKeepBroken = mKeepBrokenResources;

            if (!mForceDelete && outDir.exists()) {
                throw new OutDirExistsException();
            }

            if (!mApkFile.isFile() || !mApkFile.canRead()) {
                throw new InFileNotFoundException();
            }

            try {
                OS.rmdir(outDir);
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
            outDir.mkdirs();

//            LOGGER.info("Using Apktool " + Androlib.getVersion() + " on " + mApkFile.getName());

            if (hasResources()) {
                switch (mDecodeResources) {
                    case DECODE_RESOURCES_NONE:
                        mAndrolib.decodeResourcesRaw(mApkFile, outDir);
                        if (mForceDecodeManifest == FORCE_DECODE_MANIFEST_FULL) {
                            setTargetSdkVersion();
                            setAnalysisMode(mAnalysisMode, true);

                            // done after raw decoding of resources because copyToDir overwrites dest files
                            if (hasManifest()) {
                                mAndrolib.decodeManifestWithResources(mApkFile, outDir, getResTable());
                            }
                        }
                        break;
                    case DECODE_RESOURCES_FULL:
                        setTargetSdkVersion();
                        setAnalysisMode(mAnalysisMode, true);

                        if (hasManifest()) {
                            mAndrolib.decodeManifestWithResources(mApkFile, outDir, getResTable());
                        }
                        mAndrolib.decodeResourcesFull(mApkFile, outDir, getResTable());
                        break;
                }
            } else {
                // if there's no resources.arsc, decode the manifest without looking
                // up attribute references
                if (hasManifest()) {
                    if (mDecodeResources == DECODE_RESOURCES_FULL
                            || mForceDecodeManifest == FORCE_DECODE_MANIFEST_FULL) {
                        mAndrolib.decodeManifestFull(mApkFile, outDir, getResTable());
                    }
                    else {
                        mAndrolib.decodeManifestRaw(mApkFile, outDir);
                    }
                }
            }

            if (hasSources()) {
                switch (mDecodeSources) {
                    case DECODE_SOURCES_NONE:
                        mAndrolib.decodeSourcesRaw(mApkFile, outDir, "classes.dex");
                        break;
                    case DECODE_SOURCES_SMALI:
                    case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES:
                        mAndrolib.decodeSourcesSmali(mApkFile, outDir, "classes.dex", mBakDeb, mApi);
                        break;
                }
            }

            if (hasMultipleSources()) {
                // foreach unknown dex file in root, lets disassemble it
                Set<String> files = mApkFile.getDirectory().getFiles(true);
                for (String file : files) {
                    if (file.endsWith(".dex")) {
                        if (! file.equalsIgnoreCase("classes.dex")) {
                            switch(mDecodeSources) {
                                case DECODE_SOURCES_NONE:
                                    mAndrolib.decodeSourcesRaw(mApkFile, outDir, file);
                                    break;
                                case DECODE_SOURCES_SMALI:
                                    mAndrolib.decodeSourcesSmali(mApkFile, outDir, file, mBakDeb, mApi);
                                    break;
                                case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES:
                                    if (file.startsWith("classes") && file.endsWith(".dex")) {
                                        mAndrolib.decodeSourcesSmali(mApkFile, outDir, file, mBakDeb, mApi);
                                    } else {
                                        mAndrolib.decodeSourcesRaw(mApkFile, outDir, file);
                                    }
                                    break;
                            }
                        }
                    }
                }
            }

            mAndrolib.decodeRawFiles(mApkFile, outDir, mDecodeAssets);
            mAndrolib.decodeUnknownFiles(mApkFile, outDir, mResTable);
            mUncompressedFiles = new ArrayList<String>();
            mAndrolib.recordUncompressedFiles(mApkFile, mUncompressedFiles);
            mAndrolib.writeOriginalFiles(mApkFile, outDir);
            writeMetaFile();
        } catch (Exception ex) {
            throw ex;
        } finally {
            try {
                mApkFile.close();
            } catch (IOException ignored) {}
        }
    }

    public void setDecodeSources(short mode) throws AndrolibException {
        if (mode != DECODE_SOURCES_NONE && mode != DECODE_SOURCES_SMALI && mode != DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES) {
            throw new AndrolibException("Invalid decode sources mode: " + mode);
        }
        mDecodeSources = mode;
    }

    public void setDecodeResources(short mode) throws AndrolibException {
        if (mode != DECODE_RESOURCES_NONE && mode != DECODE_RESOURCES_FULL) {
            throw new AndrolibException("Invalid decode resources mode");
        }
        mDecodeResources = mode;
    }

    public void setForceDecodeManifest(short mode) throws AndrolibException {
        if (mode != FORCE_DECODE_MANIFEST_NONE && mode != FORCE_DECODE_MANIFEST_FULL) {
            throw new AndrolibException("Invalid force decode manifest mode");
        }
        mForceDecodeManifest = mode;
    }

    public void setDecodeAssets(short mode) throws AndrolibException {
        if (mode != DECODE_ASSETS_NONE && mode != DECODE_ASSETS_FULL) {
            throw new AndrolibException("Invalid decode asset mode");
        }
        mDecodeAssets = mode;
    }

    public void setAnalysisMode(boolean mode, boolean pass) throws AndrolibException{
        mAnalysisMode = mode;

        // only set mResTable, once it exists
        if (pass) {
            if (mResTable == null) {
                mResTable = getResTable();
            }
            mResTable.setAnalysisMode(mode);
        }
    }

    public void setTargetSdkVersion() throws AndrolibException, IOException {
        if (mResTable == null) {
            mResTable = mAndrolib.getResTable(mApkFile);
        }

        Map<String, String> sdkInfo = mResTable.getSdkInfo();
        if (sdkInfo.get("targetSdkVersion") != null) {
            mApi = Integer.parseInt(sdkInfo.get("targetSdkVersion"));
        }
    }

    public void setBaksmaliDebugMode(boolean bakdeb) {
        mBakDeb = bakdeb;
    }

    public void setForceDelete(boolean forceDelete) {
        mForceDelete = forceDelete;
    }

    public void setFrameworkTag(String tag) throws AndrolibException {
        mAndrolib.apkOptions.frameworkTag = tag;
    }

    public void setKeepBrokenResources(boolean keepBrokenResources) {
        mKeepBrokenResources = keepBrokenResources;
    }

    public void setFrameworkDir(String dir) {
        mAndrolib.apkOptions.frameworkFolderLocation = dir;
    }

    public ResTable getResTable() throws AndrolibException {
        if (mResTable == null) {
            boolean hasResources = hasResources();
            boolean hasManifest = hasManifest();
            if (! (hasManifest || hasResources)) {
                throw new AndrolibException(
                        "Apk doesn't contain either AndroidManifest.xml file or resources.arsc file");
            }
            mResTable = mAndrolib.getResTable(mApkFile, hasResources);
        }
        return mResTable;
    }

    public boolean hasSources() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("classes.dex");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasMultipleSources() throws AndrolibException {
        try {
            Set<String> files = mApkFile.getDirectory().getFiles(false);
            for (String file : files) {
                if (file.endsWith(".dex")) {
                    if (! file.equalsIgnoreCase("classes.dex")) {
                        return true;
                    }
                }
            }

            return false;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasManifest() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasResources() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("resources.arsc");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void close() throws IOException {
        if (mAndrolib != null) {
            mAndrolib.close();
        }
    }

    public final static short DECODE_SOURCES_NONE = 0x0000;
    public final static short DECODE_SOURCES_SMALI = 0x0001;
    public final static short DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES = 0x0010;

    public final static short DECODE_RESOURCES_NONE = 0x0100;
    public final static short DECODE_RESOURCES_FULL = 0x0101;

    public final static short FORCE_DECODE_MANIFEST_NONE = 0x0000;
    public final static short FORCE_DECODE_MANIFEST_FULL = 0x0001;

    public final static short DECODE_ASSETS_NONE = 0x0000;
    public final static short DECODE_ASSETS_FULL = 0x0001;

    private File getOutDir() throws AndrolibException {
        if (mOutDir == null) {
            throw new AndrolibException("Out dir not set");
        }
        return mOutDir;
    }

    private void writeMetaFile() throws AndrolibException {
        MetaInfo meta = new MetaInfo();
        meta.version = Androlib.getVersion();
        meta.apkFileName = mApkFile.getName();

        if (mDecodeResources != DECODE_RESOURCES_NONE && (hasManifest() || hasResources())) {
            meta.isFrameworkApk = mAndrolib.isFrameworkApk(getResTable());
            putUsesFramework(meta);
            putSdkInfo(meta);
            putPackageInfo(meta);
            putVersionInfo(meta);
            putSharedLibraryInfo(meta);
            putSparseResourcesInfo(meta);
        }
        putUnknownInfo(meta);
        putFileCompressionInfo(meta);

        mAndrolib.writeMetaFile(mOutDir, meta);
    }

    private void putUsesFramework(MetaInfo meta) throws AndrolibException {
        Set<ResPackage> pkgs = getResTable().listFramePackages();
        if (pkgs.isEmpty()) {
            return;
        }

        Integer[] ids = new Integer[pkgs.size()];
        int i = 0;
        for (ResPackage pkg : pkgs) {
            ids[i++] = pkg.getId();
        }
        Arrays.sort(ids);

        meta.usesFramework = new UsesFramework();
        meta.usesFramework.ids = Arrays.asList(ids);

        if (mAndrolib.apkOptions.frameworkTag != null) {
            meta.usesFramework.tag = mAndrolib.apkOptions.frameworkTag;
        }
    }

    private void putSdkInfo(MetaInfo meta) throws AndrolibException {
        Map<String, String> info = getResTable().getSdkInfo();
        if (info.size() > 0) {
            String refValue;
            if (info.get("minSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("minSdkVersion"));
                if (refValue != null) {
                    info.put("minSdkVersion", refValue);
                }
            }
            if (info.get("targetSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("targetSdkVersion"));
                if (refValue != null) {
                    info.put("targetSdkVersion", refValue);
                }
            }
            if (info.get("maxSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("maxSdkVersion"));
                if (refValue != null) {
                    info.put("maxSdkVersion", refValue);
                }
            }
            meta.sdkInfo = info;
        }
    }

    private void putPackageInfo(MetaInfo meta) throws AndrolibException {
        String renamed = getResTable().getPackageRenamed();
        String original = getResTable().getPackageOriginal();

        int id = getResTable().getPackageId();
        try {
            id = getResTable().getPackage(renamed).getId();
        } catch (UndefinedResObjectException ignored) {}

        if (Strings.isNullOrEmpty(original)) {
            return;
        }

        meta.packageInfo = new PackageInfo();

        // only put rename-manifest-package into apktool.yml, if the change will be required
        if (!renamed.equalsIgnoreCase(original)) {
            meta.packageInfo.renameManifestPackage = renamed;
        }
        meta.packageInfo.forcedPackageId = String.valueOf(id);
    }

    private void putVersionInfo(MetaInfo meta) throws AndrolibException {
        VersionInfo info = getResTable().getVersionInfo();
        String refValue = ResXmlPatcher.pullValueFromStrings(mOutDir, info.versionName);
        if (refValue != null) {
            info.versionName = refValue;
        }
        meta.versionInfo = info;
    }

    private void putUnknownInfo(MetaInfo meta) throws AndrolibException {
        meta.unknownFiles = mAndrolib.mResUnknownFiles.getUnknownFiles();
    }

    private void putFileCompressionInfo(MetaInfo meta) throws AndrolibException {
        if (mUncompressedFiles != null && !mUncompressedFiles.isEmpty()) {
            meta.doNotCompress = mUncompressedFiles;
        }
    }

    private void putSparseResourcesInfo(MetaInfo meta) throws AndrolibException {
        meta.sparseResources = mResTable.getSparseResources();
    }

    private void putSharedLibraryInfo(MetaInfo meta) throws AndrolibException {
        meta.sharedLibrary = mResTable.getSharedLibrary();
    }

    private final Androlib mAndrolib;

    private final static Logger LOGGER = Logger.getLogger(Androlib.class.getName());

    private ExtFile mApkFile;
    private File mOutDir;
    private ResTable mResTable;
    private short mDecodeSources = DECODE_SOURCES_SMALI;
    private short mDecodeResources = DECODE_RESOURCES_FULL;
    private short mForceDecodeManifest = FORCE_DECODE_MANIFEST_NONE;
    private short mDecodeAssets = DECODE_ASSETS_FULL;
    private boolean mForceDelete = false;
    private boolean mKeepBrokenResources = false;
    private boolean mBakDeb = true;
    private Collection<String> mUncompressedFiles;
    private boolean mAnalysisMode = false;
    private int mApi = 15;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkOptions.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.util.Collection;

public class ApkOptions {
    public boolean forceBuildAll = false;
    public boolean forceDeleteFramework = false;
    public boolean debugMode = false;
    public boolean verbose = false;
    public boolean copyOriginalFiles = false;
    public boolean updateFiles = false;
    public boolean isFramework = false;
    public boolean resourcesAreCompressed = false;
    public boolean useAapt2 = false;
    public boolean noCrunch = false;
    public int forceApi = 0;
    public Collection<String> doNotCompress;

    public String frameworkFolderLocation = null;
    public String frameworkTag = null;
    public String aaptPath = "";

    public int aaptVersion = 1; // default to v1

    public boolean isAapt2() {
        return this.useAapt2 || this.aaptVersion == 2;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/ApktoolProperties.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ApktoolProperties {
    public static String get(String key) {
        return get().getProperty(key);
    }

    public static Properties get() {
        if (sProps == null) {
            loadProps();
        }
        return sProps;
    }

    private static void loadProps() {
        InputStream in = ApktoolProperties.class.getResourceAsStream("/properties/apktool.properties");
        sProps = new Properties();
        try {
            sProps.load(in);
            in.close();
        } catch (IOException ex) {
            LOGGER.warning("Can't load properties.");
        }

        InputStream templateStream = null;
        try {
            templateStream = org.jf.baksmali.Main.class.getClassLoader().getResourceAsStream("baksmali.properties");
        } catch(NoClassDefFoundError ex) {
            LOGGER.warning("Can't load baksmali properties.");
        }
        Properties properties = new Properties();
        String version = "(unknown)";

        if (templateStream != null) {
            try {
                properties.load(templateStream);
                version = properties.getProperty("application.version");
                templateStream.close();
            } catch (IOException ignored) { }
        }
        sProps.put("baksmaliVersion", version);

        templateStream = null;
        try {
            templateStream = org.jf.smali.Main.class.getClassLoader().getResourceAsStream("smali.properties");
        } catch(NoClassDefFoundError ex) {
            LOGGER.warning("Can't load smali properties.");
        }
        properties = new Properties();
        version = "(unknown)";

        if (templateStream != null) {
            try {
                properties.load(templateStream);
                version = properties.getProperty("application.version");
                templateStream.close();
            } catch (IOException ignored) { }
        }
        sProps.put("smaliVersion", version);
    }

    private static Properties sProps;

    private static final Logger LOGGER = Logger.getLogger(ApktoolProperties.class.getName());
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/AXmlDecodingException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class AXmlDecodingException extends AndrolibException {
    public AXmlDecodingException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/CantFind9PatchChunkException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class CantFind9PatchChunkException extends AndrolibException {
	public CantFind9PatchChunkException(String message, Throwable cause) {
		super(message, cause);
	}
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/CantFindFrameworkResException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class CantFindFrameworkResException extends AndrolibException {
	public CantFindFrameworkResException(int id) {
		mPkgId = id;
	}

	public int getPkgId() {
		return mPkgId;
	}

	private final int mPkgId;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/InFileNotFoundException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class InFileNotFoundException extends AndrolibException {
	public InFileNotFoundException() {
	}
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/OutDirExistsException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class OutDirExistsException extends AndrolibException {
	public OutDirExistsException() {
	}
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/RawXmlEncounteredException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class RawXmlEncounteredException extends AndrolibException {
    public RawXmlEncounteredException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/err/UndefinedResObjectException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class UndefinedResObjectException extends AndrolibException {
	public UndefinedResObjectException(String message) {
		super(message);
	}
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/MetaInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.introspector.PropertyUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

public class MetaInfo {
    public String version;
    public String apkFileName;
    public boolean isFrameworkApk;
    public UsesFramework usesFramework;
    public  Map<String, String> sdkInfo;
    public PackageInfo packageInfo;
    public VersionInfo versionInfo;
    public boolean compressionType;
    public boolean sharedLibrary;
    public boolean sparseResources;
    public Map<String, String> unknownFiles;
    public Collection<String> doNotCompress;

    private static Yaml getYaml() {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);

        StringExRepresent representer = new StringExRepresent();
        PropertyUtils propertyUtils = representer.getPropertyUtils();
        propertyUtils.setSkipMissingProperties(true);

        return new Yaml(new StringExConstructor(), representer, options);
    }

    public void save(Writer output) {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        getYaml().dump(this, output);
    }

    public void save(File file) throws IOException {
        try(
                FileOutputStream fos = new FileOutputStream(file);
                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
                Writer writer = new BufferedWriter(outputStreamWriter)
        ) {
            save(writer);
        }
    }

    public static MetaInfo load(InputStream is) {
        return getYaml().loadAs(is, MetaInfo.class);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/PackageInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

public class PackageInfo {
    public String forcedPackageId;
    public String renameManifestPackage;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/StringExConstructor.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.constructor.AbstractConstruct;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.ScalarNode;
import org.yaml.snakeyaml.nodes.Tag;

public class StringExConstructor extends Constructor {
    public StringExConstructor() {
        this.yamlConstructors.put(Tag.STR, new ConstructStringEx());
    }

    private class ConstructStringEx extends AbstractConstruct {
        public Object construct(Node node) {
            String val = (String) constructScalar((ScalarNode) node);
            return YamlStringEscapeUtils.unescapeString(val);
        }
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/StringExRepresent.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.representer.Representer;

public class StringExRepresent extends Representer {
    public StringExRepresent() {
        RepresentStringEx representStringEx = new RepresentStringEx();
        multiRepresenters.put(String.class, representStringEx);
        representers.put(String.class, representStringEx);
    }

    private class RepresentStringEx extends RepresentString {

        @Override
        public Node representData(Object data) {
            return super.representData(YamlStringEscapeUtils.escapeString(data.toString()));
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/UsesFramework.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import java.util.List;

public class UsesFramework {
    public List<Integer> ids;
    public String tag;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/VersionInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

public class VersionInfo {
    public String versionCode;
    public String versionName;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/YamlStringEscapeUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.text.translate.CharSequenceTranslator;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;

public class YamlStringEscapeUtils {

    public static String escapeString(String str) {
        return escapeJavaStyleString(str, false, false);
    }

    /**
     * @param str String to escape values in, may be null
     * @param escapeSingleQuotes escapes single quotes if <code>true</code>
     * @param escapeForwardSlash TODO
     * @return the escaped string
     */
    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
        if (str == null) {
            return null;
        }
        try {
            StringWriter writer = new StringWriter(str.length() * 2);
            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

    /**
     * @param out write to receieve the escaped string
     * @param str String to escape values in, may be null
     * @param escapeSingleQuote escapes single quotes if <code>true</code>
     * @param escapeForwardSlash TODO
     * @throws IOException if an IOException occurs
     */
    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
                                              boolean escapeForwardSlash) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);
            // "[^\t\n\r\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD]"
            // handle unicode
            if (ch > 0xFFFD) {
                out.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0xD7FF && ch < 0xE000) {
                out.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0x7E && ch != 0x85 && ch < 0xA0) {
                out.write("\\u00" + CharSequenceTranslator.hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\t' :
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\n' :
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\r' :
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write("\\u00" + CharSequenceTranslator.hex(ch));
                        } else {
                            out.write("\\u000" + CharSequenceTranslator.hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'' :
                        if (escapeSingleQuote) {
                            out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '"' :
                        out.write('\\');
                        out.write('"');
                        break;
                    case '\\' :
                        out.write('\\');
                        out.write('\\');
                        break;
                    case '/' :
                        if (escapeForwardSlash) {
                            out.write('\\');
                        }
                        out.write('/');
                        break;
                    default :
                        out.write(ch);
                        break;
                }
            }
        }
    }

    /**
     * <p>Unescapes any Java literals found in the <code>String</code>.
     * For example, it will turn a sequence of <code>'\'</code> and
     * <code>'n'</code> into a newline character, unless the <code>'\'</code>
     * is preceded by another <code>'\'</code>.</p>
     *
     * @param str  the <code>String</code> to unescape, may be null
     * @return a new unescaped <code>String</code>, <code>null</code> if null string input
     */
    public static String unescapeString(String str) {
        return StringEscapeUtils.unescapeJava(str);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/mod/SmaliMod.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.mod;

import java.io.*;
import java.nio.charset.StandardCharsets;

import org.antlr.runtime.*;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.apache.commons.io.IOUtils;
import org.jf.dexlib2.writer.builder.DexBuilder;
import org.jf.smali.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class SmaliMod {

    public static boolean assembleSmaliFile(String smali, DexBuilder dexBuilder, int apiLevel, boolean verboseErrors,
                                            boolean printTokens, File smaliFile) throws IOException, RuntimeException, RecognitionException {

        InputStream is = new ByteArrayInputStream(smali.getBytes());
        return assembleSmaliFile(is, dexBuilder, apiLevel, verboseErrors, printTokens, smaliFile);
    }

    public static boolean assembleSmaliFile(InputStream is,DexBuilder dexBuilder, int apiLevel, boolean verboseErrors,
                                            boolean printTokens, File smaliFile) throws IOException, RecognitionException {

        // copy our filestream into a tmp file, so we don't overwrite
        File tmp = File.createTempFile("BRUT",".bak");
        tmp.deleteOnExit();

        OutputStream os = new FileOutputStream(tmp);
        IOUtils.copy(is, os);
        os.close();

        return assembleSmaliFile(tmp,dexBuilder, apiLevel, verboseErrors, printTokens);
    }

    public static boolean assembleSmaliFile(File smaliFile,DexBuilder dexBuilder, int apiLevel, boolean verboseErrors,
                                            boolean printTokens) throws IOException, RecognitionException {

        CommonTokenStream tokens;
        smaliFlexLexer lexer;

        InputStream is = new FileInputStream(smaliFile);
        InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8);

        lexer = new smaliFlexLexer(reader, apiLevel);
        (lexer).setSourceFile(smaliFile);
        tokens = new CommonTokenStream(lexer);

        if (printTokens) {
            tokens.getTokens();

            for (int i=0; i<tokens.size(); i++) {
                Token token = tokens.get(i);
                if (token.getChannel() == smaliParser.HIDDEN) {
                    continue;
                }

                System.out.println(smaliParser.tokenNames[token.getType()] + ": " + token.getText());
            }
        }

        smaliParser parser = new smaliParser(tokens);
        parser.setApiLevel(apiLevel);
        parser.setVerboseErrors(verboseErrors);

        smaliParser.smali_file_return result = parser.smali_file();

        if (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {
            is.close();
            reader.close();
            return false;
        }

        CommonTree t = result.getTree();

        CommonTreeNodeStream treeStream = new CommonTreeNodeStream(t);
        treeStream.setTokenStream(tokens);

        smaliTreeWalker dexGen = new smaliTreeWalker(treeStream);
        dexGen.setApiLevel(apiLevel);
        dexGen.setVerboseErrors(verboseErrors);
        dexGen.setDexBuilder(dexBuilder);
        dexGen.smali_file();

        is.close();
        reader.close();

        return dexGen.getNumberOfSyntaxErrors() == 0;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/AndrolibResources.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.AndrolibException;
import brut.androlib.ApkOptions;
import brut.androlib.err.CantFindFrameworkResException;
import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.PackageInfo;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.data.*;
import brut.androlib.res.decoder.*;
import brut.androlib.res.decoder.ARSCDecoder.ARSCData;
import brut.androlib.res.decoder.ARSCDecoder.FlagsOffset;
import brut.directory.*;
import brut.androlib.res.util.ExtMXSerializer;
import brut.androlib.res.util.ExtXmlSerializer;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.common.BrutException;
import brut.util.*;
import org.apache.commons.io.IOUtils;
import org.xmlpull.v1.XmlSerializer;

import java.io.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
final public class AndrolibResources {
    public ResTable getResTable(ExtFile apkFile) throws AndrolibException {
        return getResTable(apkFile, true);
    }

    public ResTable getResTable(ExtFile apkFile, boolean loadMainPkg)
            throws AndrolibException {
        ResTable resTable = new ResTable(this);
        if (loadMainPkg) {
            loadMainPkg(resTable, apkFile);
        }
        return resTable;
    }

    public ResPackage loadMainPkg(ResTable resTable, ExtFile apkFile)
            throws AndrolibException {
        LOGGER.info("Loading resource table...");
        ResPackage[] pkgs = getResPackagesFromApk(apkFile, resTable, sKeepBroken);
        ResPackage pkg = null;

        switch (pkgs.length) {
            case 1:
                pkg = pkgs[0];
                break;
            case 2:
                if (pkgs[0].getName().equals("android")) {
                    LOGGER.warning("Skipping \"android\" package group");
                    pkg = pkgs[1];
                    break;
                } else if (pkgs[0].getName().equals("com.htc")) {
                    LOGGER.warning("Skipping \"htc\" package group");
                    pkg = pkgs[1];
                    break;
                }

            default:
                pkg = selectPkgWithMostResSpecs(pkgs);
                break;
        }

        if (pkg == null) {
            throw new AndrolibException("arsc files with zero packages or no arsc file found.");
        }

        resTable.addPackage(pkg, true);
        return pkg;
    }

    public ResPackage selectPkgWithMostResSpecs(ResPackage[] pkgs)
            throws AndrolibException {
        int id = 0;
        int value = 0;
        int index = 0;

        for (int i = 0; i < pkgs.length; i++) {
            ResPackage resPackage = pkgs[i];
            if (resPackage.getResSpecCount() > value && ! resPackage.getName().equalsIgnoreCase("android")) {
                value = resPackage.getResSpecCount();
                id = resPackage.getId();
                index = i;
            }
        }

        // if id is still 0, we only have one pkgId which is "android" -> 1
        return (id == 0) ? pkgs[0] : pkgs[index];
    }

    public ResPackage loadFrameworkPkg(ResTable resTable, int id, String frameTag)
            throws AndrolibException {
        File apk = getFrameworkApk(id, frameTag);

        LOGGER.info("Loading resource table from file: " + apk);
        mFramework = new ExtFile(apk);
        ResPackage[] pkgs = getResPackagesFromApk(mFramework, resTable, true);

        ResPackage pkg;
        if (pkgs.length > 1) {
            pkg = selectPkgWithMostResSpecs(pkgs);
        } else if (pkgs.length == 0) {
            throw new AndrolibException("Arsc files with zero or multiple packages");
        } else {
            pkg = pkgs[0];
        }

        if (pkg.getId() != id) {
            throw new AndrolibException("Expected pkg of id: " + String.valueOf(id) + ", got: " + pkg.getId());
        }

        resTable.addPackage(pkg, false);
        return pkg;
    }

    public void decodeManifest(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {

        Duo<ResFileDecoder, AXmlResourceParser> duo = getManifestFileDecoder();
        ResFileDecoder fileDecoder = duo.m1;

        // Set ResAttrDecoder
        duo.m2.setAttrDecoder(new ResAttrDecoder());
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        // Fake ResPackage
        attrDecoder.setCurrentPackage(new ResPackage(resTable, 0, null));

        Directory inApk, out;
        try {
            inApk = apkFile.getDirectory();
            out = new FileDirectory(outDir);

            LOGGER.info("Decoding AndroidManifest.xml with only framework resources...");
            fileDecoder.decodeManifest(inApk, "AndroidManifest.xml", out, "AndroidManifest.xml");

        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void adjustPackageManifest(ResTable resTable, String filePath)
            throws AndrolibException {

        // compare resources.arsc package name to the one present in AndroidManifest
        ResPackage resPackage = resTable.getCurrentResPackage();
        String pkgOriginal = resPackage.getName();
        mPackageRenamed = resTable.getPackageRenamed();

        resTable.setPackageId(resPackage.getId());
        resTable.setPackageOriginal(pkgOriginal);

        // 1) Check if pkgOriginal === mPackageRenamed
        // 2) Check if pkgOriginal is ignored via IGNORED_PACKAGES
        if (pkgOriginal.equalsIgnoreCase(mPackageRenamed) || (Arrays.asList(IGNORED_PACKAGES).contains(pkgOriginal))) {
            LOGGER.info("Regular manifest package...");
        } else {
            LOGGER.info("Renamed manifest package found! Replacing " + mPackageRenamed + " with " + pkgOriginal);
            ResXmlPatcher.renameManifestPackage(new File(filePath), pkgOriginal);
        }
    }

    public void decodeManifestWithResources(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {

        Duo<ResFileDecoder, AXmlResourceParser> duo = getResFileDecoder();
        ResFileDecoder fileDecoder = duo.m1;
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        attrDecoder.setCurrentPackage(resTable.listMainPackages().iterator().next());

        Directory inApk, in = null, out;
        try {
            inApk = apkFile.getDirectory();
            out = new FileDirectory(outDir);
            LOGGER.info("Decoding AndroidManifest.xml with resources...");

            fileDecoder.decodeManifest(inApk, "AndroidManifest.xml", out, "AndroidManifest.xml");

            // Remove versionName / versionCode (aapt API 16)
            if (!resTable.getAnalysisMode()) {

                // check for a mismatch between resources.arsc package and the package listed in AndroidManifest
                // also remove the android::versionCode / versionName from manifest for rebuild
                // this is a required change to prevent aapt warning about conflicting versions
                // it will be passed as a parameter to aapt like "--min-sdk-version" via apktool.yml
                adjustPackageManifest(resTable, outDir.getAbsolutePath() + File.separator + "AndroidManifest.xml");

                ResXmlPatcher.removeManifestVersions(new File(
                        outDir.getAbsolutePath() + File.separator + "AndroidManifest.xml"));

                mPackageId = String.valueOf(resTable.getPackageId());
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decode(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {
        Duo<ResFileDecoder, AXmlResourceParser> duo = getResFileDecoder();
        ResFileDecoder fileDecoder = duo.m1;
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        attrDecoder.setCurrentPackage(resTable.listMainPackages().iterator().next());
        Directory inApk, in = null, out;

        try {
            out = new FileDirectory(outDir);

            inApk = apkFile.getDirectory();
            out = out.createDir("res");
            if (inApk.containsDir("res")) {
                in = inApk.getDir("res");
            }
            if (in == null && inApk.containsDir("r")) {
                in = inApk.getDir("r");
            }
            if (in == null && inApk.containsDir("R")) {
                in = inApk.getDir("R");
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }

        ExtMXSerializer xmlSerializer = getResXmlSerializer();
        for (ResPackage pkg : resTable.listMainPackages()) {
            attrDecoder.setCurrentPackage(pkg);

            LOGGER.info("Decoding file-resources...");
            for (ResResource res : pkg.listFiles()) {
                fileDecoder.decode(res, in, out);
            }

            LOGGER.info("Decoding values */* XMLs...");
            for (ResValuesFile valuesFile : pkg.listValuesFiles()) {
                generateValuesFile(valuesFile, out, xmlSerializer);
            }
            generatePublicXml(pkg, out, xmlSerializer);
        }

        AndrolibException decodeError = duo.m2.getFirstError();
        if (decodeError != null) {
            throw decodeError;
        }
    }

    public void setSdkInfo(Map<String, String> map) {
        if (map != null) {
            mMinSdkVersion = map.get("minSdkVersion");
            mTargetSdkVersion = map.get("targetSdkVersion");
            mMaxSdkVersion = map.get("maxSdkVersion");
        }
    }

    public void setVersionInfo(VersionInfo versionInfo) {
        if (versionInfo != null) {
            mVersionCode = versionInfo.versionCode;
            mVersionName = versionInfo.versionName;
        }
    }

    public void setPackageRenamed(PackageInfo packageInfo) {
        if (packageInfo != null) {
            mPackageRenamed = packageInfo.renameManifestPackage;
        }
    }

    public void setPackageId(PackageInfo packageInfo) {
        if (packageInfo != null) {
            mPackageId = packageInfo.forcedPackageId;
        }
    }

    public void setSharedLibrary(boolean flag) {
        mSharedLibrary = flag;
    }

    public void setSparseResources(boolean flag) {
        mSparseResources = flag;
    }

    public String checkTargetSdkVersionBounds() {
        int target = mapSdkShorthandToVersion(mTargetSdkVersion);

        int min = (mMinSdkVersion != null) ? mapSdkShorthandToVersion(mMinSdkVersion) : 0;
        int max = (mMaxSdkVersion != null) ? mapSdkShorthandToVersion(mMaxSdkVersion) : target;

        target = Math.min(max, target);
        target = Math.max(min, target);
        return Integer.toString(target);
    }

    private File createDoNotCompressExtensionsFile(ApkOptions apkOptions) throws AndrolibException {
        if (apkOptions.doNotCompress == null || apkOptions.doNotCompress.isEmpty()) {
            return null;
        }

        File doNotCompressFile;
        try {
            doNotCompressFile = File.createTempFile("APKTOOL", null);
            doNotCompressFile.deleteOnExit();

            BufferedWriter fileWriter = new BufferedWriter(new FileWriter(doNotCompressFile));
            for (String extension : apkOptions.doNotCompress) {
                fileWriter.write(extension);
                fileWriter.newLine();
            }
            fileWriter.close();

            return doNotCompressFile;
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void aapt2Package(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include,
                              List<String> cmd, boolean customAapt)
            throws AndrolibException {

        List<String> compileCommand = new ArrayList<>(cmd);
        File resourcesZip = null;

        if (resDir != null) {
            File buildDir = new File(resDir.getParent(), "build");
            resourcesZip = new File(buildDir, "resources.zip");
        }

        if (resDir != null && !resourcesZip.exists()) {

            // Compile the files into flat arsc files
            cmd.add("compile");

            cmd.add("--dir");
            cmd.add(resDir.getAbsolutePath());

            // Treats error that used to be valid in aapt1 as warnings in aapt2
            cmd.add("--legacy");

            File buildDir = new File(resDir.getParent(), "build");
            resourcesZip = new File(buildDir, "resources.zip");

            cmd.add("-o");
            cmd.add(resourcesZip.getAbsolutePath());

            if (apkOptions.verbose) {
                cmd.add("-v");
            }

            if (apkOptions.noCrunch) {
                cmd.add("--no-crunch");
            }

            try {
                OS.exec(cmd.toArray(new String[0]));
                LOGGER.fine("aapt2 compile command ran: ");
                LOGGER.fine(cmd.toString());
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
        }

        if (manifest == null) {
            return;
        }

        // Link them into the final apk, reusing our old command after clearing for the aapt2 binary
        cmd = new ArrayList<>(compileCommand);
        cmd.add("link");

        cmd.add("-o");
        cmd.add(apkFile.getAbsolutePath());

        if (mPackageId != null && ! mSharedLibrary) {
            cmd.add("--package-id");
            cmd.add(mPackageId);
        }

        if (mSharedLibrary) {
            cmd.add("--shared-lib");
        }

        if (mMinSdkVersion != null) {
            cmd.add("--min-sdk-version");
            cmd.add(mMinSdkVersion);
        }

        if (mTargetSdkVersion != null) {
            cmd.add("--target-sdk-version");
            cmd.add(checkTargetSdkVersionBounds());
        }

        if (mPackageRenamed != null) {
            cmd.add("--rename-manifest-package");
            cmd.add(mPackageRenamed);

            cmd.add("--rename-instrumentation-target-package");
            cmd.add(mPackageRenamed);
        }

        if (mVersionCode != null) {
            cmd.add("--version-code");
            cmd.add(mVersionCode);
        }

        if (mVersionName != null) {
            cmd.add("--version-name");
            cmd.add(mVersionName);
        }

        // Disable automatic changes
        cmd.add("--no-auto-version");
        cmd.add("--no-version-vectors");
        cmd.add("--no-version-transitions");
        cmd.add("--no-resource-deduping");

        if (mSparseResources) {
            cmd.add("--enable-sparse-encoding");
        }

        if (apkOptions.isFramework) {
            cmd.add("-x");
        }

        if (apkOptions.doNotCompress != null && !customAapt) {
            // Use custom -e option to avoid limits on commandline length.
            // Can only be used when custom aapt binary is not used.
            String extensionsFilePath = createDoNotCompressExtensionsFile(apkOptions).getAbsolutePath();
            cmd.add("-e");
            cmd.add(extensionsFilePath);
        } else if (apkOptions.doNotCompress != null) {
            for (String file : apkOptions.doNotCompress) {
                cmd.add("-0");
                cmd.add(file);
            }
        }

        if (!apkOptions.resourcesAreCompressed) {
            cmd.add("-0");
            cmd.add("arsc");
        }

        if (include != null) {
            for (File file : include) {
                cmd.add("-I");
                cmd.add(file.getPath());
            }
        }

        cmd.add("--manifest");
        cmd.add(manifest.getAbsolutePath());

        if (assetDir != null) {
            cmd.add("-A");
            cmd.add(assetDir.getAbsolutePath());
        }

        if (rawDir != null) {
            cmd.add("-R");
            cmd.add(rawDir.getAbsolutePath());
        }

        if (apkOptions.verbose) {
            cmd.add("-v");
        }

        if (resourcesZip != null) {
            cmd.add(resourcesZip.getAbsolutePath());
        }

        try {
            OS.exec(cmd.toArray(new String[0]));
            LOGGER.fine("aapt2 link command ran: ");
            LOGGER.fine(cmd.toString());
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void aapt1Package(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include,
                              List<String> cmd, boolean customAapt)
            throws AndrolibException {

        cmd.add("p");

        if (apkOptions.verbose) { // output aapt verbose
            cmd.add("-v");
        }
        if (apkOptions.updateFiles) {
            cmd.add("-u");
        }
        if (apkOptions.debugMode) { // inject debuggable="true" into manifest
            cmd.add("--debug-mode");
        }
        if (apkOptions.noCrunch) {
            cmd.add("--no-crunch");
        }
        // force package id so that some frameworks build with correct id
        // disable if user adds own aapt (can't know if they have this feature)
        if (mPackageId != null && ! customAapt && ! mSharedLibrary) {
            cmd.add("--forced-package-id");
            cmd.add(mPackageId);
        }
        if (mSharedLibrary) {
            cmd.add("--shared-lib");
        }
        if (mMinSdkVersion != null) {
            cmd.add("--min-sdk-version");
            cmd.add(mMinSdkVersion);
        }
        if (mTargetSdkVersion != null) {
            cmd.add("--target-sdk-version");

            // Ensure that targetSdkVersion is between minSdkVersion/maxSdkVersion if
            // they are specified.
            cmd.add(checkTargetSdkVersionBounds());
        }
        if (mMaxSdkVersion != null) {
            cmd.add("--max-sdk-version");
            cmd.add(mMaxSdkVersion);

            // if we have max sdk version, set --max-res-version
            // so we can ignore anything over that during build.
            cmd.add("--max-res-version");
            cmd.add(mMaxSdkVersion);
        }
        if (mPackageRenamed != null) {
            cmd.add("--rename-manifest-package");
            cmd.add(mPackageRenamed);
        }
        if (mVersionCode != null) {
            cmd.add("--version-code");
            cmd.add(mVersionCode);
        }
        if (mVersionName != null) {
            cmd.add("--version-name");
            cmd.add(mVersionName);
        }
        cmd.add("--no-version-vectors");
        cmd.add("-F");
        cmd.add(apkFile.getAbsolutePath());

        if (apkOptions.isFramework) {
            cmd.add("-x");
        }

        if (apkOptions.doNotCompress != null && !customAapt) {
            // Use custom -e option to avoid limits on commandline length.
            // Can only be used when custom aapt binary is not used.
            String extensionsFilePath = createDoNotCompressExtensionsFile(apkOptions).getAbsolutePath();
            cmd.add("-e");
            cmd.add(extensionsFilePath);
        } else if (apkOptions.doNotCompress != null) {
            for (String file : apkOptions.doNotCompress) {
                cmd.add("-0");
                cmd.add(file);
            }
        }

        if (!apkOptions.resourcesAreCompressed) {
            cmd.add("-0");
            cmd.add("arsc");
        }

        if (include != null) {
            for (File file : include) {
                cmd.add("-I");
                cmd.add(file.getPath());
            }
        }
        if (resDir != null) {
            cmd.add("-S");
            cmd.add(resDir.getAbsolutePath());
        }
        if (manifest != null) {
            cmd.add("-M");
            cmd.add(manifest.getAbsolutePath());
        }
        if (assetDir != null) {
            cmd.add("-A");
            cmd.add(assetDir.getAbsolutePath());
        }
        if (rawDir != null) {
            cmd.add(rawDir.getAbsolutePath());
        }
        try {
            OS.exec(cmd.toArray(new String[0]));
            LOGGER.fine("command ran: ");
            LOGGER.fine(cmd.toString());
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void aaptPackage(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include)
            throws AndrolibException {

        String aaptPath = apkOptions.aaptPath;
        boolean customAapt = !aaptPath.isEmpty();
        List<String> cmd = new ArrayList<String>();

        try {
            String aaptCommand = AaptManager.getAaptExecutionCommand(aaptPath, getAaptBinaryFile());
            cmd.add(aaptCommand);
        } catch (BrutException ex) {
            LOGGER.warning("aapt: " + ex.getMessage() + " (defaulting to $PATH binary)");
            cmd.add(AaptManager.getAaptBinaryName(getAaptVersion()));
        }

        if (apkOptions.isAapt2()) {
            aapt2Package(apkFile, manifest, resDir, rawDir, assetDir, include, cmd, customAapt);
            return;
        }
        aapt1Package(apkFile, manifest, resDir, rawDir, assetDir, include, cmd, customAapt);
    }

    public void zipPackage(File apkFile, File rawDir, File assetDir)
            throws AndrolibException {

        try {
            ZipUtils.zipFolders(rawDir, apkFile, assetDir, apkOptions.doNotCompress);
        } catch (IOException | BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public int getMinSdkVersionFromAndroidCodename(MetaInfo meta, String sdkVersion) {
        int sdkNumber = mapSdkShorthandToVersion(sdkVersion);

        if (sdkNumber == ResConfigFlags.SDK_BASE) {
            return Integer.parseInt(meta.sdkInfo.get("minSdkVersion"));
        }
        return sdkNumber;
    }

    private int mapSdkShorthandToVersion(String sdkVersion) {
        switch (sdkVersion.toUpperCase()) {
            case "M":
                return ResConfigFlags.SDK_MNC;
            case "N":
                return ResConfigFlags.SDK_NOUGAT;
            case "O":
                return ResConfigFlags.SDK_OREO;
            case "P":
                return ResConfigFlags.SDK_P;
            case "Q":
                return ResConfigFlags.SDK_Q;
            case "R":
                return ResConfigFlags.SDK_R;
            case "S":
                return ResConfigFlags.SDK_S;
            default:
                return Integer.parseInt(sdkVersion);
        }
    }

    public boolean detectWhetherAppIsFramework(File appDir)
            throws AndrolibException {
        File publicXml = new File(appDir, "res/values/public.xml");
        if (! publicXml.exists()) {
            return false;
        }

        Iterator<String> it;
        try {
            it = IOUtils.lineIterator(new FileReader(new File(appDir,
                    "res/values/public.xml")));
        } catch (FileNotFoundException ex) {
            throw new AndrolibException(
                    "Could not detect whether app is framework one", ex);
        }
        it.next();
        it.next();
        return it.next().contains("0x01");
    }

    public Duo<ResFileDecoder, AXmlResourceParser> getResFileDecoder() {
        ResStreamDecoderContainer decoders = new ResStreamDecoderContainer();
        decoders.setDecoder("raw", new ResRawStreamDecoder());
        decoders.setDecoder("9patch", new Res9patchStreamDecoder());

        AXmlResourceParser axmlParser = new AXmlResourceParser();
        axmlParser.setAttrDecoder(new ResAttrDecoder());
        decoders.setDecoder("xml", new XmlPullStreamDecoder(axmlParser, getResXmlSerializer()));

        return new Duo<ResFileDecoder, AXmlResourceParser>(new ResFileDecoder(decoders), axmlParser);
    }

    public Duo<ResFileDecoder, AXmlResourceParser> getManifestFileDecoder() {
        ResStreamDecoderContainer decoders = new ResStreamDecoderContainer();

        AXmlResourceParser axmlParser = new AXmlResourceParser();

        decoders.setDecoder("xml", new XmlPullStreamDecoder(axmlParser,getResXmlSerializer()));

        return new Duo<ResFileDecoder, AXmlResourceParser>(new ResFileDecoder(decoders), axmlParser);
    }

    public ExtMXSerializer getResXmlSerializer() {
        ExtMXSerializer serial = new ExtMXSerializer();
        serial.setProperty(ExtXmlSerializer.PROPERTY_SERIALIZER_INDENTATION, "    ");
        serial.setProperty(ExtXmlSerializer.PROPERTY_SERIALIZER_LINE_SEPARATOR, System.getProperty("line.separator"));
        serial.setProperty(ExtXmlSerializer.PROPERTY_DEFAULT_ENCODING, "utf-8");
        serial.setDisabledAttrEscape(true);
        return serial;
    }

    private void generateValuesFile(ResValuesFile valuesFile, Directory out,
                                    ExtXmlSerializer serial) throws AndrolibException {
        try {
            OutputStream outStream = out.getFileOutput(valuesFile.getPath());
            serial.setOutput((outStream), null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResResource res : valuesFile.listResources()) {
                if (valuesFile.isSynthesized(res)) {
                    continue;
                }
                ((ResValuesXmlSerializable) res.getValue()).serializeToResValuesXml(serial, res);
            }

            serial.endTag(null, "resources");
            serial.newLine();
            serial.endDocument();
            serial.flush();
            outStream.close();
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException("Could not generate: " + valuesFile.getPath(), ex);
        }
    }

    private void generatePublicXml(ResPackage pkg, Directory out,
                                   XmlSerializer serial) throws AndrolibException {
        try {
            OutputStream outStream = out.getFileOutput("values/public.xml");
            serial.setOutput(outStream, null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResResSpec spec : pkg.listResSpecs()) {
                serial.startTag(null, "public");
                serial.attribute(null, "type", spec.getType().getName());
                serial.attribute(null, "name", spec.getName());
                serial.attribute(null, "id", String.format("0x%08x", spec.getId().id));
                serial.endTag(null, "public");
            }

            serial.endTag(null, "resources");
            serial.endDocument();
            serial.flush();
            outStream.close();
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException("Could not generate public.xml file", ex);
        }
    }

    private ResPackage[] getResPackagesFromApk(ExtFile apkFile,ResTable resTable, boolean keepBroken)
            throws AndrolibException {
        try {
            Directory dir = apkFile.getDirectory();
            BufferedInputStream bfi = new BufferedInputStream(dir.getFileInput("resources.arsc"));
            try {
                return ARSCDecoder.decode(bfi, false, keepBroken, resTable).getPackages();
            } finally {
                try {
                    bfi.close();
                } catch (IOException ignored) {}
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException("Could not load resources.arsc from file: " + apkFile, ex);
        }
    }

    public File getFrameworkApk(int id, String frameTag)
            throws AndrolibException {
        File dir = getFrameworkDir();
        File apk;

        if (frameTag != null) {
            apk = new File(dir, String.valueOf(id) + '-' + frameTag + ".apk");
            if (apk.exists()) {
                return apk;
            }
        }

        apk = new File(dir, String.valueOf(id) + ".apk");
        if (apk.exists()) {
            return apk;
        }

        if (id == 1) {
            try (InputStream in = AndrolibResources.class.getResourceAsStream("/brut/androlib/android-framework.jar");
                 OutputStream out = new FileOutputStream(apk)) {
                IOUtils.copy(in, out);
                return apk;
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
        }

        throw new CantFindFrameworkResException(id);
    }

    public void emptyFrameworkDirectory() throws AndrolibException {
        File dir = getFrameworkDir();
        File apk;

        apk = new File(dir, "1.apk");

        if (! apk.exists()) {
            LOGGER.warning("Can't empty framework directory, no file found at: " + apk.getAbsolutePath());
        } else {
            try {
                if (apk.exists() && dir.listFiles().length > 1 && ! apkOptions.forceDeleteFramework) {
                    LOGGER.warning("More than default framework detected. Please run command with `--force` parameter to wipe framework directory.");
                } else {
                    for (File file : dir.listFiles()) {
                        if (file.isFile() && file.getName().endsWith(".apk")) {
                            LOGGER.info("Removing " + file.getName() + " framework file...");
                            file.delete();
                        }
                    }
                }
            } catch (NullPointerException e) {
                throw new AndrolibException(e);
            }
        }
    }

    public void listFrameworkDirectory() throws AndrolibException {
        File dir = getFrameworkDir();
        if (dir == null) {
            LOGGER.severe("No framework directory found. Nothing to list.");
            return;
        }

        for (File file : Objects.requireNonNull(dir.listFiles())) {
            if (file.isFile() && file.getName().endsWith(".apk")) {
                LOGGER.info(file.getName());
            }
        }
    }

    public void installFramework(File frameFile) throws AndrolibException {
        installFramework(frameFile, apkOptions.frameworkTag);
    }

    public void installFramework(File frameFile, String tag)
            throws AndrolibException {
        InputStream in = null;
        ZipOutputStream out = null;
        try {
            ZipFile zip = new ZipFile(frameFile);
            ZipEntry entry = zip.getEntry("resources.arsc");

            if (entry == null) {
                throw new AndrolibException("Can't find resources.arsc file");
            }

            in = zip.getInputStream(entry);
            byte[] data = IOUtils.toByteArray(in);

            ARSCData arsc = ARSCDecoder.decode(new ByteArrayInputStream(data), true, true);
            publicizeResources(data, arsc.getFlagsOffsets());

            File outFile = new File(getFrameworkDir(), String.valueOf(arsc
                    .getOnePackage().getId())
                    + (tag == null ? "" : '-' + tag)
                    + ".apk");

            out = new ZipOutputStream(new FileOutputStream(outFile));
            out.setMethod(ZipOutputStream.STORED);
            CRC32 crc = new CRC32();
            crc.update(data);
            entry = new ZipEntry("resources.arsc");
            entry.setSize(data.length);
            entry.setMethod(ZipOutputStream.STORED);
            entry.setCrc(crc.getValue());
            out.putNextEntry(entry);
            out.write(data);
            out.closeEntry();
            
            //Write fake AndroidManifest.xml file to support original aapt
            entry = zip.getEntry("AndroidManifest.xml");
            if (entry != null) {
                in = zip.getInputStream(entry);
                byte[] manifest = IOUtils.toByteArray(in);
                CRC32 manifestCrc = new CRC32();
                manifestCrc.update(manifest);
                entry.setSize(manifest.length);
                entry.setCompressedSize(-1);
                entry.setCrc(manifestCrc.getValue());
                out.putNextEntry(entry);
                out.write(manifest);
                out.closeEntry();
            }

            zip.close();
            LOGGER.info("Framework installed to: " + outFile);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }

    public void publicizeResources(File arscFile) throws AndrolibException {
        byte[] data = new byte[(int) arscFile.length()];

        try(InputStream in = new FileInputStream(arscFile);
            OutputStream out = new FileOutputStream(arscFile)) {
            in.read(data);
            publicizeResources(data);
            out.write(data);
        } catch (IOException ex){
            throw new AndrolibException(ex);
        }
    }

    public void publicizeResources(byte[] arsc) throws AndrolibException {
        publicizeResources(arsc, ARSCDecoder.decode(new ByteArrayInputStream(arsc), true, true).getFlagsOffsets());
    }

    public void publicizeResources(byte[] arsc, FlagsOffset[] flagsOffsets)
            throws AndrolibException {
        for (FlagsOffset flags : flagsOffsets) {
            int offset = flags.offset + 3;
            int end = offset + 4 * flags.count;
            while (offset < end) {
                arsc[offset] |= (byte) 0x40;
                offset += 4;
            }
        }
    }

    public File getFrameworkDir() throws AndrolibException {
        if (mFrameworkDirectory != null) {
            return mFrameworkDirectory;
        }

        String path;

        // if a framework path was specified on the command line, use it
        if (apkOptions.frameworkFolderLocation != null) {
            path = apkOptions.frameworkFolderLocation;
        } else {
            File parentPath = new File(System.getProperty("user.home"));

            if (OSDetection.isMacOSX()) {
                path = parentPath.getAbsolutePath() + String.format("%1$sLibrary%1$sapktool%1$sframework", File.separatorChar);
            } else if (OSDetection.isWindows()) {
                path = parentPath.getAbsolutePath() + String.format("%1$sAppData%1$sLocal%1$sapktool%1$sframework", File.separatorChar);
            } else {
                path = parentPath.getAbsolutePath() + String.format("%1$s.local%1$sshare%1$sapktool%1$sframework", File.separatorChar);
            }
        }

        File dir = new File(path);

        if (!dir.isDirectory() && dir.isFile()) {
            throw new AndrolibException("--frame-path is set to a file, not a directory.");
        }

        if (dir.getParentFile() != null && dir.getParentFile().isFile()) {
            throw new AndrolibException("Please remove file at " + dir.getParentFile());
        }

        if (! dir.exists()) {
            if (! dir.mkdirs()) {
                if (apkOptions.frameworkFolderLocation != null) {
                    LOGGER.severe("Can't create Framework directory: " + dir);
                }
                throw new AndrolibException(String.format(
                        "Can't create directory: (%s). Pass a writable path with --frame-path {DIR}. ", dir
                ));
            }
        }

        if (apkOptions.frameworkFolderLocation == null) {
            if (! dir.canWrite()) {
                LOGGER.severe(String.format("WARNING: Could not write to (%1$s), using %2$s instead...",
                        dir.getAbsolutePath(), System.getProperty("java.io.tmpdir")));
                LOGGER.severe("Please be aware this is a volatile directory and frameworks could go missing, " +
                        "please utilize --frame-path if the default storage directory is unavailable");

                dir = new File(System.getProperty("java.io.tmpdir"));
            }
        }

        mFrameworkDirectory = dir;
        return dir;
    }

    private File getAaptBinaryFile() throws AndrolibException {
        try {
            if (getAaptVersion() == 2) {
                return AaptManager.getAppt2();
            }
            return AaptManager.getAppt1();
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private int getAaptVersion() {
        return apkOptions.isAapt2() ? 2 : 1;
    }

    public File getAndroidResourcesFile() throws AndrolibException {
        try {
            return Jar.getResourceAsFile("/brut/androlib/android-framework.jar");
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void close() throws IOException {
        if (mFramework != null) {
            mFramework.close();
        }
    }

    public ApkOptions apkOptions;

    // TODO: dirty static hack. I have to refactor decoding mechanisms.
    public static boolean sKeepBroken = false;

    private final static Logger LOGGER = Logger.getLogger(AndrolibResources.class.getName());

    private File mFrameworkDirectory = null;

    private ExtFile mFramework = null;

    private String mMinSdkVersion = null;
    private String mMaxSdkVersion = null;
    private String mTargetSdkVersion = null;
    private String mVersionCode = null;
    private String mVersionName = null;
    private String mPackageRenamed = null;
    private String mPackageId = null;

    private boolean mSharedLibrary = false;
    private boolean mSparseResources = false;

    private final static String[] IGNORED_PACKAGES = new String[] {
            "android", "com.htc", "com.lge", "com.lge.internal", "yi", "flyme", "air.com.adobe.appentry",
            "FFFFFFFFFFFFFFFFFFFFFF" };
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResConfigFlags.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResConfigFlags {
    public final short mcc;
    public final short mnc;

    public final char[] language;
    public final char[] region;

    public final byte orientation;
    public final byte touchscreen;
    public final int density;

    public final byte keyboard;
    public final byte navigation;
    public final byte inputFlags;

    public final short screenWidth;
    public final short screenHeight;

    public final short sdkVersion;

    public final byte screenLayout;
    public final byte uiMode;
    public final short smallestScreenWidthDp;

    public final short screenWidthDp;
    public final short screenHeightDp;

    private final char[] localeScript;
    private final char[] localeVariant;

    private final byte screenLayout2;
    private final byte colorMode;

    public final boolean isInvalid;

    private final String mQualifiers;

    private final int size;

    public ResConfigFlags() {
        mcc = 0;
        mnc = 0;
        language = new char[] { '\00', '\00' };
        region = new char[] { '\00', '\00' };
        orientation = ORIENTATION_ANY;
        touchscreen = TOUCHSCREEN_ANY;
        density = DENSITY_DEFAULT;
        keyboard = KEYBOARD_ANY;
        navigation = NAVIGATION_ANY;
        inputFlags = KEYSHIDDEN_ANY | NAVHIDDEN_ANY;
        screenWidth = 0;
        screenHeight = 0;
        sdkVersion = 0;
        screenLayout = SCREENLONG_ANY | SCREENSIZE_ANY;
        uiMode = UI_MODE_TYPE_ANY | UI_MODE_NIGHT_ANY;
        smallestScreenWidthDp = 0;
        screenWidthDp = 0;
        screenHeightDp = 0;
        localeScript = null;
        localeVariant = null;
        screenLayout2 = 0;
        colorMode = COLOR_WIDE_UNDEFINED;
        isInvalid = false;
        mQualifiers = "";
        size = 0;
    }

    public ResConfigFlags(short mcc, short mnc, char[] language,
                          char[] region, byte orientation,
                          byte touchscreen, int density, byte keyboard, byte navigation,
                          byte inputFlags, short screenWidth, short screenHeight,
                          short sdkVersion, byte screenLayout, byte uiMode,
                          short smallestScreenWidthDp, short screenWidthDp,
                          short screenHeightDp, char[] localeScript, char[] localeVariant,
                          byte screenLayout2, byte colorMode, boolean isInvalid, int size) {
        if (orientation < 0 || orientation > 3) {
            LOGGER.warning("Invalid orientation value: " + orientation);
            orientation = 0;
            isInvalid = true;
        }
        if (touchscreen < 0 || touchscreen > 3) {
            LOGGER.warning("Invalid touchscreen value: " + touchscreen);
            touchscreen = 0;
            isInvalid = true;
        }
        if (density < -1) {
            LOGGER.warning("Invalid density value: " + density);
            density = 0;
            isInvalid = true;
        }
        if (keyboard < 0 || keyboard > 3) {
            LOGGER.warning("Invalid keyboard value: " + keyboard);
            keyboard = 0;
            isInvalid = true;
        }
        if (navigation < 0 || navigation > 4) {
            LOGGER.warning("Invalid navigation value: " + navigation);
            navigation = 0;
            isInvalid = true;
        }

        if (localeScript != null && localeScript.length != 0) {
            if (localeScript[0] == '\00') {
                localeScript = null;
            }
        } else {
            localeScript = null;
        }

        if (localeVariant != null && localeVariant.length != 0) {
            if (localeVariant[0] == '\00') {
                localeVariant = null;
            }
        }  else {
            localeVariant = null;
        }

        this.mcc = mcc;
        this.mnc = mnc;
        this.language = language;
        this.region = region;
        this.orientation = orientation;
        this.touchscreen = touchscreen;
        this.density = density;
        this.keyboard = keyboard;
        this.navigation = navigation;
        this.inputFlags = inputFlags;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.sdkVersion = sdkVersion;
        this.screenLayout = screenLayout;
        this.uiMode = uiMode;
        this.smallestScreenWidthDp = smallestScreenWidthDp;
        this.screenWidthDp = screenWidthDp;
        this.screenHeightDp = screenHeightDp;
        this.localeScript = localeScript;
        this.localeVariant = localeVariant;
        this.screenLayout2 = screenLayout2;
        this.colorMode = colorMode;
        this.isInvalid = isInvalid;
        this.size = size;
        mQualifiers = generateQualifiers();
    }

    public String getQualifiers() {
        return mQualifiers;
    }

    private String generateQualifiers() {
        StringBuilder ret = new StringBuilder();
        if (mcc != 0) {
            ret.append("-mcc").append(String.format("%03d", mcc));
            if (mnc != MNC_ZERO) {
                if (mnc != 0) {
                    ret.append("-mnc");
                    if (size <= 32) {
                        if (mnc > 0 && mnc < 10) {
                            ret.append(String.format("%02d", mnc));
                        } else {
                            ret.append(String.format("%03d", mnc));
                        }
                    } else {
                        ret.append(mnc);
                    }
                }
            } else {
                ret.append("-mnc00");
            }
        } else {
            if (mnc != 0) {
                ret.append("-mnc").append(mnc);
            }
        }
        ret.append(getLocaleString());

        switch (screenLayout & MASK_LAYOUTDIR) {
            case SCREENLAYOUT_LAYOUTDIR_RTL:
                ret.append("-ldrtl");
                break;
            case SCREENLAYOUT_LAYOUTDIR_LTR:
                ret.append("-ldltr");
                break;
        }
        if (smallestScreenWidthDp != 0) {
            ret.append("-sw").append(smallestScreenWidthDp).append("dp");
        }
        if (screenWidthDp != 0) {
            ret.append("-w").append(screenWidthDp).append("dp");
        }
        if (screenHeightDp != 0) {
            ret.append("-h").append(screenHeightDp).append("dp");
        }
        switch (screenLayout & MASK_SCREENSIZE) {
            case SCREENSIZE_SMALL:
                ret.append("-small");
                break;
            case SCREENSIZE_NORMAL:
                ret.append("-normal");
                break;
            case SCREENSIZE_LARGE:
                ret.append("-large");
                break;
            case SCREENSIZE_XLARGE:
                ret.append("-xlarge");
                break;
        }
        switch (screenLayout & MASK_SCREENLONG) {
            case SCREENLONG_YES:
                ret.append("-long");
                break;
            case SCREENLONG_NO:
                ret.append("-notlong");
                break;
        }
        switch (screenLayout2 & MASK_SCREENROUND) {
            case SCREENLAYOUT_ROUND_NO:
                ret.append("-notround");
                break;
            case SCREENLAYOUT_ROUND_YES:
                ret.append("-round");
                break;
        }
        switch (colorMode & COLOR_HDR_MASK) {
            case COLOR_HDR_YES:
                ret.append("-highdr");
                break;
            case COLOR_HDR_NO:
                ret.append("-lowdr");
                break;
        }
        switch (colorMode & COLOR_WIDE_MASK) {
            case COLOR_WIDE_YES:
                ret.append("-widecg");
                break;
            case COLOR_WIDE_NO:
                ret.append("-nowidecg");
                break;
        }
        switch (orientation) {
            case ORIENTATION_PORT:
                ret.append("-port");
                break;
            case ORIENTATION_LAND:
                ret.append("-land");
                break;
            case ORIENTATION_SQUARE:
                ret.append("-square");
                break;
        }
        switch (uiMode & MASK_UI_MODE_TYPE) {
            case UI_MODE_TYPE_CAR:
                ret.append("-car");
                break;
            case UI_MODE_TYPE_DESK:
                ret.append("-desk");
                break;
            case UI_MODE_TYPE_TELEVISION:
                ret.append("-television");
                break;
            case UI_MODE_TYPE_SMALLUI:
                ret.append("-smallui");
                break;
            case UI_MODE_TYPE_MEDIUMUI:
                ret.append("-mediumui");
                break;
            case UI_MODE_TYPE_LARGEUI:
                ret.append("-largeui");
                break;
            case UI_MODE_TYPE_GODZILLAUI:
                ret.append("-godzillaui");
                break;
            case UI_MODE_TYPE_HUGEUI:
                ret.append("-hugeui");
                break;
            case UI_MODE_TYPE_APPLIANCE:
                ret.append("-appliance");
                break;
            case UI_MODE_TYPE_WATCH:
                ret.append("-watch");
                break;
            case UI_MODE_TYPE_VR_HEADSET:
                ret.append("-vrheadset");
                break;
        }
        switch (uiMode & MASK_UI_MODE_NIGHT) {
            case UI_MODE_NIGHT_YES:
                ret.append("-night");
                break;
            case UI_MODE_NIGHT_NO:
                ret.append("-notnight");
                break;
        }
        switch (density) {
            case DENSITY_DEFAULT:
                break;
            case DENSITY_LOW:
                ret.append("-ldpi");
                break;
            case DENSITY_MEDIUM:
                ret.append("-mdpi");
                break;
            case DENSITY_HIGH:
                ret.append("-hdpi");
                break;
            case DENSITY_TV:
                ret.append("-tvdpi");
                break;
            case DENSITY_XHIGH:
                ret.append("-xhdpi");
                break;
            case DENSITY_XXHIGH:
                ret.append("-xxhdpi");
                break;
            case DENSITY_XXXHIGH:
                ret.append("-xxxhdpi");
                break;
            case DENSITY_ANY:
                ret.append("-anydpi");
                break;
            case DENSITY_NONE:
                ret.append("-nodpi");
                break;
            default:
                ret.append('-').append(density).append("dpi");
        }
        switch (touchscreen) {
            case TOUCHSCREEN_NOTOUCH:
                ret.append("-notouch");
                break;
            case TOUCHSCREEN_STYLUS:
                ret.append("-stylus");
                break;
            case TOUCHSCREEN_FINGER:
                ret.append("-finger");
                break;
        }
        switch (inputFlags & MASK_KEYSHIDDEN) {
            case KEYSHIDDEN_NO:
                ret.append("-keysexposed");
                break;
            case KEYSHIDDEN_YES:
                ret.append("-keyshidden");
                break;
            case KEYSHIDDEN_SOFT:
                ret.append("-keyssoft");
                break;
        }
        switch (keyboard) {
            case KEYBOARD_NOKEYS:
                ret.append("-nokeys");
                break;
            case KEYBOARD_QWERTY:
                ret.append("-qwerty");
                break;
            case KEYBOARD_12KEY:
                ret.append("-12key");
                break;
        }
        switch (inputFlags & MASK_NAVHIDDEN) {
            case NAVHIDDEN_NO:
                ret.append("-navexposed");
                break;
            case NAVHIDDEN_YES:
                ret.append("-navhidden");
                break;
        }
        switch (navigation) {
            case NAVIGATION_NONAV:
                ret.append("-nonav");
                break;
            case NAVIGATION_DPAD:
                ret.append("-dpad");
                break;
            case NAVIGATION_TRACKBALL:
                ret.append("-trackball");
                break;
            case NAVIGATION_WHEEL:
                ret.append("-wheel");
                break;
        }
        if (screenWidth != 0 && screenHeight != 0) {
            if (screenWidth > screenHeight) {
                ret.append(String.format("-%dx%d", screenWidth, screenHeight));
            } else {
                ret.append(String.format("-%dx%d", screenHeight, screenWidth));
            }
        }
        if (sdkVersion > 0 && sdkVersion >= getNaturalSdkVersionRequirement()) {
            ret.append("-v").append(sdkVersion);
        }
        if (isInvalid) {
            ret.append("-ERR").append(sErrCounter++);
        }

        return ret.toString();
    }

    private short getNaturalSdkVersionRequirement() {
        if ((uiMode & MASK_UI_MODE_TYPE) == UI_MODE_TYPE_VR_HEADSET || (colorMode & COLOR_WIDE_MASK) != 0 || ((colorMode & COLOR_HDR_MASK) != 0)) {
            return SDK_OREO;
        }
        if ((screenLayout2 & MASK_SCREENROUND) != 0) {
            return SDK_MNC;
        }
        if (density == DENSITY_ANY) {
            return SDK_LOLLIPOP;
        }
        if (smallestScreenWidthDp != 0 || screenWidthDp != 0 || screenHeightDp != 0) {
            return SDK_HONEYCOMB_MR2;
        }
        if ((uiMode & (MASK_UI_MODE_TYPE | MASK_UI_MODE_NIGHT)) != UI_MODE_NIGHT_ANY) {
            return SDK_FROYO;
        }
        if ((screenLayout & (MASK_SCREENSIZE | MASK_SCREENLONG)) != SCREENSIZE_ANY || density != DENSITY_DEFAULT) {
            return SDK_DONUT;
        }
        return 0;
    }

    private String getLocaleString() {
        StringBuilder sb = new StringBuilder();

        // check for old style non BCP47 tags
        // allows values-xx-rXX, values-xx, values-xxx-rXX
        // denies values-xxx, anything else
        if (localeVariant == null && localeScript == null && (region[0] != '\00' || language[0] != '\00') &&
                region.length != 3) {
            sb.append("-").append(language);
            if (region[0] != '\00') {
                sb.append("-r").append(region);
            }
        } else { // BCP47
            if (language[0] == '\00' && region[0] == '\00') {
                return sb.toString(); // early return, no language or region
            }
            sb.append("-b+");
            if (language[0] != '\00') {
                sb.append(language);
            }
            if (localeScript != null && localeScript.length == 4) {
                sb.append("+").append(localeScript);
            }
            if ((region.length == 2 || region.length == 3) && region[0] != '\00') {
                sb.append("+").append(region);
            }
            if (localeVariant != null && localeVariant.length >= 5) {
                sb.append("+").append(toUpper(localeVariant));
            }
        }
        return sb.toString();
    }

    private String toUpper(char[] character) {
        StringBuilder sb = new StringBuilder();
        for (char ch: character) {
            sb.append(Character.toUpperCase(ch));
        }
        return sb.toString();
    }


    @Override
    public String toString() {
        return !getQualifiers().equals("") ? getQualifiers() : "[DEFAULT]";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResConfigFlags other = (ResConfigFlags) obj;
        return this.mQualifiers.equals(other.mQualifiers);
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + this.mQualifiers.hashCode();
        return hash;
    }

    // TODO: Dirty static hack. This counter should be a part of ResPackage,
    // but it would be hard right now and this feature is very rarely used.
    private static int sErrCounter = 0;

    public final static byte SDK_BASE = 1;
    public final static byte SDK_BASE_1_1 = 2;
    public final static byte SDK_CUPCAKE = 3;
    public final static byte SDK_DONUT = 4;
    public final static byte SDK_ECLAIR = 5;
    public final static byte SDK_ECLAIR_0_1 = 6;
    public final static byte SDK_ECLAIR_MR1 = 7;
    public final static byte SDK_FROYO = 8;
    public final static byte SDK_GINGERBREAD = 9;
    public final static byte SDK_GINGERBREAD_MR1 = 10;
    public final static byte SDK_HONEYCOMB = 11;
    public final static byte SDK_HONEYCOMB_MR1 = 12;
    public final static byte SDK_HONEYCOMB_MR2 = 13;
    public final static byte SDK_ICE_CREAM_SANDWICH = 14;
    public final static byte SDK_ICE_CREAM_SANDWICH_MR1 = 15;
    public final static byte SDK_JELLY_BEAN = 16;
    public final static byte SDK_JELLY_BEAN_MR1 = 17;
    public final static byte SDK_JELLY_BEAN_MR2 = 18;
    public final static byte SDK_KITKAT = 19;
    public final static byte SDK_LOLLIPOP = 21;
    public final static byte SDK_LOLLIPOP_MR1 = 22;
    public final static byte SDK_MNC = 23;
    public final static byte SDK_NOUGAT = 24;
    public final static byte SDK_NOUGAT_MR1 = 25;
    public final static byte SDK_OREO = 26;
    public final static byte SDK_OREO_MR1 = 27;
    public final static byte SDK_P = 28;
    public final static byte SDK_Q = 29;
    public final static byte SDK_R = 30;

    // AOSP has this as 10,000 for dev purposes.
    // platform_frameworks_base/commit/c7a1109a1fe0771d4c9b572dcf178e2779fc4f2d
    public final static int SDK_S = 10000;

    public final static byte ORIENTATION_ANY = 0;
    public final static byte ORIENTATION_PORT = 1;
    public final static byte ORIENTATION_LAND = 2;
    public final static byte ORIENTATION_SQUARE = 3;

    public final static byte TOUCHSCREEN_ANY = 0;
    public final static byte TOUCHSCREEN_NOTOUCH = 1;
    public final static byte TOUCHSCREEN_STYLUS = 2;
    public final static byte TOUCHSCREEN_FINGER = 3;

    public final static int DENSITY_DEFAULT = 0;
    public final static int DENSITY_LOW = 120;
    public final static int DENSITY_MEDIUM = 160;
    public final static int DENSITY_400 = 190;
    public final static int DENSITY_TV = 213;
    public final static int DENSITY_HIGH = 240;
    public final static int DENSITY_XHIGH = 320;
    public final static int DENSITY_XXHIGH = 480;
    public final static int DENSITY_XXXHIGH = 640;
    public final static int DENSITY_ANY = 0xFFFE;
    public final static int DENSITY_NONE = 0xFFFF;

    public final static int MNC_ZERO = -1;

    public final static short MASK_LAYOUTDIR = 0xc0;
    public final static short SCREENLAYOUT_LAYOUTDIR_ANY = 0x00;
    public final static short SCREENLAYOUT_LAYOUTDIR_LTR = 0x40;
    public final static short SCREENLAYOUT_LAYOUTDIR_RTL = 0x80;
    public final static short SCREENLAYOUT_LAYOUTDIR_SHIFT = 0x06;

    public final static short MASK_SCREENROUND = 0x03;
    public final static short SCREENLAYOUT_ROUND_ANY = 0;
    public final static short SCREENLAYOUT_ROUND_NO = 0x1;
    public final static short SCREENLAYOUT_ROUND_YES = 0x2;

    public final static byte KEYBOARD_ANY = 0;
    public final static byte KEYBOARD_NOKEYS = 1;
    public final static byte KEYBOARD_QWERTY = 2;
    public final static byte KEYBOARD_12KEY = 3;

    public final static byte NAVIGATION_ANY = 0;
    public final static byte NAVIGATION_NONAV = 1;
    public final static byte NAVIGATION_DPAD = 2;
    public final static byte NAVIGATION_TRACKBALL = 3;
    public final static byte NAVIGATION_WHEEL = 4;

    public final static byte MASK_KEYSHIDDEN = 0x3;
    public final static byte KEYSHIDDEN_ANY = 0x0;
    public final static byte KEYSHIDDEN_NO = 0x1;
    public final static byte KEYSHIDDEN_YES = 0x2;
    public final static byte KEYSHIDDEN_SOFT = 0x3;

    public final static byte MASK_NAVHIDDEN = 0xc;
    public final static byte NAVHIDDEN_ANY = 0x0;
    public final static byte NAVHIDDEN_NO = 0x4;
    public final static byte NAVHIDDEN_YES = 0x8;

    public final static byte MASK_SCREENSIZE = 0x0f;
    public final static byte SCREENSIZE_ANY = 0x00;
    public final static byte SCREENSIZE_SMALL = 0x01;
    public final static byte SCREENSIZE_NORMAL = 0x02;
    public final static byte SCREENSIZE_LARGE = 0x03;
    public final static byte SCREENSIZE_XLARGE = 0x04;

    public final static byte MASK_SCREENLONG = 0x30;
    public final static byte SCREENLONG_ANY = 0x00;
    public final static byte SCREENLONG_NO = 0x10;
    public final static byte SCREENLONG_YES = 0x20;

    public final static byte MASK_UI_MODE_TYPE = 0x0f;
    public final static byte UI_MODE_TYPE_ANY = 0x00;
    public final static byte UI_MODE_TYPE_NORMAL = 0x01;
    public final static byte UI_MODE_TYPE_DESK = 0x02;
    public final static byte UI_MODE_TYPE_CAR = 0x03;
    public final static byte UI_MODE_TYPE_TELEVISION = 0x04;
    public final static byte UI_MODE_TYPE_APPLIANCE = 0x05;
    public final static byte UI_MODE_TYPE_WATCH = 0x06;
    public final static byte UI_MODE_TYPE_VR_HEADSET = 0x07;

    // start - miui
    public final static byte UI_MODE_TYPE_GODZILLAUI = 0x0b;
    public final static byte UI_MODE_TYPE_SMALLUI = 0x0c;
    public final static byte UI_MODE_TYPE_MEDIUMUI = 0x0d;
    public final static byte UI_MODE_TYPE_LARGEUI = 0x0e;
    public final static byte UI_MODE_TYPE_HUGEUI = 0x0f;
    // end - miui

    public final static byte MASK_UI_MODE_NIGHT = 0x30;
    public final static byte UI_MODE_NIGHT_ANY = 0x00;
    public final static byte UI_MODE_NIGHT_NO = 0x10;
    public final static byte UI_MODE_NIGHT_YES = 0x20;

    public final static byte COLOR_HDR_MASK = 0xC;
    public final static byte COLOR_HDR_NO = 0x4;
    public final static byte COLOR_HDR_SHIFT = 0x2;
    public final static byte COLOR_HDR_UNDEFINED = 0x0;
    public final static byte COLOR_HDR_YES = 0x8;

    public final static byte COLOR_UNDEFINED = 0x0;

    public final static byte COLOR_WIDE_UNDEFINED = 0x0;
    public final static byte COLOR_WIDE_NO = 0x1;
    public final static byte COLOR_WIDE_YES = 0x2;
    public final static byte COLOR_WIDE_MASK = 0x3;

    private static final Logger LOGGER = Logger.getLogger(ResConfigFlags.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResID.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResID {
    public final int package_;
    public final int type;
    public final int entry;

    public final int id;

    public ResID(int package_, int type, int entry) {
        this(package_, type, entry, (package_ << 24) + (type << 16) + entry);
    }

    public ResID(int id) {
        this((id >> 24) & 0xff, (id >> 16) & 0x000000ff, id & 0x0000ffff, id);
    }

    public ResID(int package_, int type, int entry, int id) {
        this.package_ = (package_ == 0) ? 2 : package_;
        this.type = type;
        this.entry = entry;
        this.id = id;
    }

    @Override
    public String toString() {
        return String.format("0x%08x", id);
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + this.id;
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResID other = (ResID) obj;
        if (this.id != other.id) {
            return false;
        }
        return true;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResPackage.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.value.ResFileValue;
import brut.androlib.res.data.value.ResValueFactory;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.util.*;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResPackage {
    private final ResTable mResTable;
    private final int mId;
    private final String mName;
    private final Map<ResID, ResResSpec> mResSpecs = new LinkedHashMap<ResID, ResResSpec>();
    private final Map<ResConfigFlags, ResType> mConfigs = new LinkedHashMap<ResConfigFlags, ResType>();
    private final Map<String, ResTypeSpec> mTypes = new LinkedHashMap<String, ResTypeSpec>();
    private final Set<ResID> mSynthesizedRes = new HashSet<ResID>();

    private ResValueFactory mValueFactory;

    public ResPackage(ResTable resTable, int id, String name) {
        this.mResTable = resTable;
        this.mId = id;
        this.mName = name;
    }

    public List<ResResSpec> listResSpecs() {
        return new ArrayList<ResResSpec>(mResSpecs.values());
    }

    public boolean hasResSpec(ResID resID) {
        return mResSpecs.containsKey(resID);
    }

    public ResResSpec getResSpec(ResID resID) throws UndefinedResObjectException {
        ResResSpec spec = mResSpecs.get(resID);
        if (spec == null) {
            throw new UndefinedResObjectException("resource spec: " + resID.toString());
        }
        return spec;
    }

    public List<ResType> getConfigs() {
        return new ArrayList<ResType>(mConfigs.values());
    }

    public boolean hasConfig(ResConfigFlags flags) {
        return mConfigs.containsKey(flags);
    }

    public ResType getConfig(ResConfigFlags flags) throws AndrolibException {
        ResType config = mConfigs.get(flags);
        if (config == null) {
            throw new UndefinedResObjectException("config: " + flags);
        }
        return config;
    }

    public int getResSpecCount() {
        return mResSpecs.size();
    }

    public ResType getOrCreateConfig(ResConfigFlags flags) throws AndrolibException {
        ResType config = mConfigs.get(flags);
        if (config == null) {
            config = new ResType(flags);
            mConfigs.put(flags, config);
        }
        return config;
    }

    public List<ResTypeSpec> listTypes() {
        return new ArrayList<ResTypeSpec>(mTypes.values());
    }

    public boolean hasType(String typeName) {
        return mTypes.containsKey(typeName);
    }

    public ResTypeSpec getType(String typeName) throws AndrolibException {
        ResTypeSpec type = mTypes.get(typeName);
        if (type == null) {
            throw new UndefinedResObjectException("type: " + typeName);
        }
        return type;
    }

    public Set<ResResource> listFiles() {
        Set<ResResource> ret = new HashSet<ResResource>();
        for (ResResSpec spec : mResSpecs.values()) {
            for (ResResource res : spec.listResources()) {
                if (res.getValue() instanceof ResFileValue) {
                    ret.add(res);
                }
            }
        }
        return ret;
    }

    public Collection<ResValuesFile> listValuesFiles() {
        Map<Duo<ResTypeSpec, ResType>, ResValuesFile> ret = new HashMap<Duo<ResTypeSpec, ResType>, ResValuesFile>();
        for (ResResSpec spec : mResSpecs.values()) {
            for (ResResource res : spec.listResources()) {
                if (res.getValue() instanceof ResValuesXmlSerializable) {
                    ResTypeSpec type = res.getResSpec().getType();
                    ResType config = res.getConfig();
                    Duo<ResTypeSpec, ResType> key = new Duo<ResTypeSpec, ResType>(type, config);
                    ResValuesFile values = ret.get(key);
                    if (values == null) {
                        values = new ResValuesFile(this, type, config);
                        ret.put(key, values);
                    }
                    values.addResource(res);
                }
            }
        }
        return ret.values();
    }

    public ResTable getResTable() {
        return mResTable;
    }

    public int getId() {
        return mId;
    }

    public String getName() {
        return mName;
    }

    boolean isSynthesized(ResID resId) {
        return mSynthesizedRes.contains(resId);
    }

    public void removeResSpec(ResResSpec spec) throws AndrolibException {
        mResSpecs.remove(spec.getId());
    }

    public void addResSpec(ResResSpec spec) throws AndrolibException {
        if (mResSpecs.put(spec.getId(), spec) != null) {
            throw new AndrolibException("Multiple resource specs: " + spec);
        }
    }

    public void addConfig(ResType config) throws AndrolibException {
        if (mConfigs.put(config.getFlags(), config) != null) {
            throw new AndrolibException("Multiple configs: " + config);
        }
    }

    public void addType(ResTypeSpec type) throws AndrolibException {
        if (mTypes.containsKey(type.getName())) {
            LOGGER.warning("Multiple types detected! " + type + " ignored!");
        } else {
            mTypes.put(type.getName(), type);
        }
    }

    public void addResource(ResResource res) {
    }

    public void removeResource(ResResource res) {
    }

    public void addSynthesizedRes(int resId) {
        mSynthesizedRes.add(new ResID(resId));
    }

    @Override
    public String toString() {
        return mName;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResPackage other = (ResPackage) obj;
        if (this.mResTable != other.mResTable && (this.mResTable == null || !this.mResTable.equals(other.mResTable))) {
            return false;
        }
        if (this.mId != other.mId) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + (this.mResTable != null ? this.mResTable.hashCode() : 0);
        hash = 31 * hash + this.mId;
        return hash;
    }

    public ResValueFactory getValueFactory() {
        if (mValueFactory == null) {
            mValueFactory = new ResValueFactory(this);
        }
        return mValueFactory;
    }

    private final static Logger LOGGER = Logger.getLogger(ResPackage.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResResSpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import java.util.*;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResResSpec {
    private final ResID mId;
    private String mName;
    private final ResPackage mPackage;
    private final ResTypeSpec mType;
    private final Map<ResConfigFlags, ResResource> mResources = new LinkedHashMap<ResConfigFlags, ResResource>();

    public ResResSpec(ResID id, String name, ResPackage pkg, ResTypeSpec type) {
        this.mId = id;
        String cleanName;

        ResResSpec resResSpec = type.getResSpecUnsafe(name);
        if (resResSpec != null) {
            cleanName = name + "_apktool_duplicatename_" + id.toString();
        } else {
            cleanName = ((name == null || name.isEmpty()) ? ("apktool_dummyval_" + id.toString()) : name);
        }
        /**
         * Only Check Self Package 's Name
         */
        if (pkg.getId() == 0x7f && !UnicodeUtilsKt.isValidResourceEntryName(cleanName) || UnicodeUtilsKt.isJavaReversedKeywords(cleanName)){
            cleanName = "apktool_validate_name_" + id.toString();
        }
        this.mName = cleanName;
        this.mPackage = pkg;
        this.mType = type;
    }

    public Set<ResResource> listResources() {
        return new LinkedHashSet<ResResource>(mResources.values());
    }

    public ResResource getResource(ResType config) throws AndrolibException {
        return getResource(config.getFlags());
    }

    public ResResource getResource(ResConfigFlags config) throws AndrolibException {
        ResResource res = mResources.get(config);
        if (res == null) {
            throw new UndefinedResObjectException(String.format("resource: spec=%s, config=%s", this, config));
        }
        return res;
    }

    public boolean hasResource(ResType config) {
        return hasResource(config.getFlags());
    }

    private boolean hasResource(ResConfigFlags flags) {
        return mResources.containsKey(flags);
    }

    public ResResource getDefaultResource() throws AndrolibException {
        return getResource(new ResConfigFlags());
    }

    public boolean hasDefaultResource() {
        return mResources.containsKey(new ResConfigFlags());
    }

    public String getFullName() {
        return getFullName(false, false);
    }

    public String getFullName(ResPackage relativeToPackage, boolean excludeType) {
        return getFullName(getPackage().equals(relativeToPackage), excludeType);
    }

    public String getFullName(boolean excludePackage, boolean excludeType) {
        return (excludePackage ? "" : getPackage().getName() + ":")
                + (excludeType ? "" : getType().getName() + "/") + getName();
    }

    public ResID getId() {
        return mId;
    }

    public String getName() {
        return StringUtils.replace(mName, "\"", "q");
    }

    public ResPackage getPackage() {
        return mPackage;
    }

    public ResTypeSpec getType() {
        return mType;
    }

    public boolean isDummyResSpec() {
        return getName().startsWith("APKTOOL_DUMMY_");
    }

    public void addResource(ResResource res) throws AndrolibException {
        addResource(res, false);
    }

    public void addResource(ResResource res, boolean overwrite) throws AndrolibException {
        ResConfigFlags flags = res.getConfig().getFlags();
        if (mResources.put(flags, res) != null && !overwrite) {
            throw new AndrolibException(String.format("Multiple resources: spec=%s, config=%s", this, flags));
        }
    }

    public void removeResource(ResResource res) throws AndrolibException {
        ResConfigFlags flags = res.getConfig().getFlags();
        mResources.remove(flags);
    }

    public void setName(String mName) {
        this.mName = mName;
    }

    @Override
    public String toString() {
        return mId.toString() + " " + mType.toString() + "/" + mName;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResResource.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.value.ResValue;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResResource {
    private final ResType mConfig;
    private final ResResSpec mResSpec;
    private final ResValue mValue;

    public ResResource(ResType config, ResResSpec spec, ResValue value) {
        this.mConfig = config;
        this.mResSpec = spec;
        this.mValue = value;
    }

    public String getFilePath() {
        return mResSpec.getType().getName() + mConfig.getFlags().getQualifiers() + "/" + mResSpec.getName();
    }

    public ResType getConfig() {
        return mConfig;
    }

    public ResResSpec getResSpec() {
        return mResSpec;
    }

    public ResValue getValue() {
        return mValue;
    }

    public void replace(ResValue value) throws AndrolibException {
        ResResource res = new ResResource(mConfig, mResSpec, value);
        mConfig.addResource(res, true);
        mResSpec.addResource(res, true);
    }

    @Override
    public String toString() {
        return getFilePath();
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResTable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.value.ResValue;
import java.util.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResTable {
    private final AndrolibResources mAndRes;

    private final Map<Integer, ResPackage> mPackagesById = new HashMap<Integer, ResPackage>();
    private final Map<String, ResPackage> mPackagesByName = new HashMap<String, ResPackage>();
    private final Set<ResPackage> mMainPackages = new LinkedHashSet<ResPackage>();
    private final Set<ResPackage> mFramePackages = new LinkedHashSet<ResPackage>();

    private String mPackageRenamed;
    private String mPackageOriginal;
    private int mPackageId;
    private boolean mAnalysisMode = false;
    private boolean mSharedLibrary = false;
    private boolean mSparseResources = false;

    private Map<String, String> mSdkInfo = new LinkedHashMap<>();
    private VersionInfo mVersionInfo = new VersionInfo();

    public ResTable() {
        mAndRes = null;
    }

    public ResTable(AndrolibResources andRes) {
        mAndRes = andRes;
    }

    public ResResSpec getResSpec(int resID) throws AndrolibException {
        // The pkgId is 0x00. That means a shared library is using its
        // own resource, so lie to the caller replacing with its own
        // packageId
        if (resID >> 24 == 0) {
            int pkgId = (mPackageId == 0 ? 2 : mPackageId);
            resID = (0xFF000000 & (pkgId << 24)) | resID;
        }
        return getResSpec(new ResID(resID));
    }

    public ResResSpec getResSpec(ResID resID) throws AndrolibException {
        return getPackage(resID.package_).getResSpec(resID);
    }

    public Set<ResPackage> listMainPackages() {
        return mMainPackages;
    }

    public Set<ResPackage> listFramePackages() {
        return mFramePackages;
    }

    public ResPackage getPackage(int id) throws AndrolibException {
        ResPackage pkg = mPackagesById.get(id);
        if (pkg != null) {
            return pkg;
        }
        if (mAndRes != null) {
            return mAndRes.loadFrameworkPkg(this, id, mAndRes.apkOptions.frameworkTag);
        }
        throw new UndefinedResObjectException(String.format("package: id=%d", id));
    }

    public ResPackage getHighestSpecPackage() throws AndrolibException {
        int id = 0;
        int value = 0;
        for (ResPackage resPackage : mPackagesById.values()) {
            if (resPackage.getResSpecCount() > value && !resPackage.getName().equalsIgnoreCase("android")) {
                value = resPackage.getResSpecCount();
                id = resPackage.getId();
            }
        }
        // if id is still 0, we only have one pkgId which is "android" -> 1
        return (id == 0) ? getPackage(1) : getPackage(id);
    }

    public ResPackage getCurrentResPackage() throws AndrolibException {
        ResPackage pkg = mPackagesById.get(mPackageId);

        if (pkg != null) {
            return pkg;
        } else {
            if (mMainPackages.size() == 1) {
                return mMainPackages.iterator().next();
            }
            return getHighestSpecPackage();
        }
    }

    public ResPackage getPackage(String name) throws AndrolibException {
        ResPackage pkg = mPackagesByName.get(name);
        if (pkg == null) {
            throw new UndefinedResObjectException("package: name=" + name);
        }
        return pkg;
    }

    public boolean hasPackage(int id) {
        return mPackagesById.containsKey(id);
    }

    public boolean hasPackage(String name) {
        return mPackagesByName.containsKey(name);
    }

    public ResValue getValue(String package_, String type, String name) throws AndrolibException {
        return getPackage(package_).getType(type).getResSpec(name).getDefaultResource().getValue();
    }

    public void addPackage(ResPackage pkg, boolean main) throws AndrolibException {
        Integer id = pkg.getId();
        if (mPackagesById.containsKey(id)) {
            throw new AndrolibException("Multiple packages: id=" + id.toString());
        }
        String name = pkg.getName();
        if (mPackagesByName.containsKey(name)) {
            throw new AndrolibException("Multiple packages: name=" + name);
        }

        mPackagesById.put(id, pkg);
        mPackagesByName.put(name, pkg);
        if (main) {
            mMainPackages.add(pkg);
        } else {
            mFramePackages.add(pkg);
        }
    }

    public void setAnalysisMode(boolean mode) {
        mAnalysisMode = mode;
    }

    public void setPackageRenamed(String pkg) {
        mPackageRenamed = pkg;
    }

    public void setPackageOriginal(String pkg) {
        mPackageOriginal = pkg;
    }

    public void setPackageId(int id) {
        mPackageId = id;
    }

    public void setSharedLibrary(boolean flag) {
        mSharedLibrary = flag;
    }

    public void setSparseResources(boolean flag) {
        mSparseResources = flag;
    }

    public void clearSdkInfo() {
        mSdkInfo.clear();
    }

    public void addSdkInfo(String key, String value) {
        mSdkInfo.put(key, value);
    }

    public void setVersionName(String versionName) {
        mVersionInfo.versionName = versionName;
    }

    public void setVersionCode(String versionCode) {
        mVersionInfo.versionCode = versionCode;
    }

    public VersionInfo getVersionInfo() {
        return mVersionInfo;
    }

    public Map<String, String> getSdkInfo() {
        return mSdkInfo;
    }

    public boolean getAnalysisMode() {
        return mAnalysisMode;
    }

    public String getPackageRenamed() {
        return mPackageRenamed;
    }

    public String getPackageOriginal() {
        return mPackageOriginal;
    }

    public int getPackageId() {
        return mPackageId;
    }

    public boolean getSharedLibrary() {
        return mSharedLibrary;
    }

    public boolean getSparseResources() {
        return mSparseResources;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResType.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import java.util.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResType {
    private final ResConfigFlags mFlags;
    private final Map<ResResSpec, ResResource> mResources = new LinkedHashMap<ResResSpec, ResResource>();

    public ResType(ResConfigFlags flags) {
        this.mFlags = flags;
    }

    public Set<ResResource> listResources() {
        return new LinkedHashSet<ResResource>(mResources.values());
    }

    public ResResource getResource(ResResSpec spec) throws AndrolibException {
        ResResource res = mResources.get(spec);
        if (res == null) {
            throw new UndefinedResObjectException(String.format("resource: spec=%s, config=%s", spec, this));
        }
        return res;
    }

    public Set<ResResSpec> listResSpecs() {
        return mResources.keySet();
    }

    public ResConfigFlags getFlags() {
        return mFlags;
    }

    public void addResource(ResResource res) throws AndrolibException {
        addResource(res, false);
    }

    public void removeResource(ResResource res) throws AndrolibException {
        ResResSpec spec = res.getResSpec();
        mResources.remove(spec);
    }

    public void addResource(ResResource res, boolean overwrite) throws AndrolibException {
        ResResSpec spec = res.getResSpec();
        if (mResources.put(spec, res) != null && !overwrite) {
            throw new AndrolibException(String.format("Multiple resources: spec=%s, config=%s", spec, this));
        }
    }

    @Override
    public String toString() {
        return mFlags.toString();
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResTypeSpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import java.util.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public final class ResTypeSpec {

    public static final String RES_TYPE_NAME_ARRAY = "array";
    public static final String RES_TYPE_NAME_PLURALS = "plurals";
    public static final String RES_TYPE_NAME_STYLES = "style";
    public static final String RES_TYPE_NAME_ATTR = "attr";

    private final String mName;
    private final Map<String, ResResSpec> mResSpecs = new LinkedHashMap<String, ResResSpec>();

    private final ResTable mResTable;
    private final ResPackage mPackage;

    private final int mId;
    private final int mEntryCount;

    public ResTypeSpec(String name, ResTable resTable, ResPackage package_, int id, int entryCount) {
        this.mName = name;
        this.mResTable = resTable;
        this.mPackage = package_;
        this.mId = id;
        this.mEntryCount = entryCount;
    }

    public String getName() {
        return mName;
    }

    public int getId() {
        return mId;
    }

    public int getEntryCount() {
        return mEntryCount;
    }

    public boolean isString() {
        return mName.equalsIgnoreCase("string");
    }

    public Set<ResResSpec> listResSpecs() {
        return new LinkedHashSet<ResResSpec>(mResSpecs.values());
    }

    public ResResSpec getResSpec(String name) throws AndrolibException {
        ResResSpec spec = getResSpecUnsafe(name);
        if (spec == null) {
            throw new UndefinedResObjectException(String.format("resource spec: %s/%s", getName(), name));
        }
        return spec;
    }

    public ResResSpec getResSpecUnsafe(String name) {
        return mResSpecs.get(name);
    }

    public void removeResSpec(ResResSpec spec) throws AndrolibException {
        mResSpecs.remove(spec.getName());
    }

    public void addResSpec(ResResSpec spec) throws AndrolibException {
        if (mResSpecs.put(spec.getName(), spec) != null) {
            throw new AndrolibException(String.format("Multiple res specs: %s/%s", getName(), spec.getName()));
        }
    }

    @Override
    public String toString() {
        return mName;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResUnknownFiles.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class ResUnknownFiles {

    private final Map<String, String> mUnknownFiles = new LinkedHashMap<>();

    public void addUnknownFileInfo(String file, String value) {
        mUnknownFiles.put(file, value);
    }

    public Map<String, String> getUnknownFiles() {
        return mUnknownFiles;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResValuesFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.LinkedHashSet;
import java.util.Set;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResValuesFile {
    private final ResPackage mPackage;
    private final ResTypeSpec mType;
    private final ResType mConfig;
    private final Set<ResResource> mResources = new LinkedHashSet<ResResource>();

    public ResValuesFile(ResPackage pkg, ResTypeSpec type, ResType config) {
        this.mPackage = pkg;
        this.mType = type;
        this.mConfig = config;
    }

    public String getPath() {
        return "values" + mConfig.getFlags().getQualifiers() + "/"
                + mType.getName() + (mType.getName().endsWith("s") ? "" : "s")
                + ".xml";
    }

    public Set<ResResource> listResources() {
        return mResources;
    }

    public ResTypeSpec getType() {
        return mType;
    }

    public ResType getConfig() {
        return mConfig;
    }

    public boolean isSynthesized(ResResource res) {
        return mPackage.isSynthesized(res.getResSpec().getId());
    }

    public void addResource(ResResource res) {
        mResources.add(res);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResValuesFile other = (ResValuesFile) obj;
        if (this.mType != other.mType && (this.mType == null || !this.mType.equals(other.mType))) {
            return false;
        }
        if (this.mConfig != other.mConfig && (this.mConfig == null || !this.mConfig.equals(other.mConfig))) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + (this.mType != null ? this.mType.hashCode() : 0);
        hash = 31 * hash + (this.mConfig != null ? this.mConfig.hashCode() : 0);
        return hash;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/UnicodeUtils.kt`:

```kt
package brut.androlib.res.data

/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * transliterated from
 * https://android.googlesource.com/platform/frameworks/base/+/master/tools/aapt2/text/Unicode.cpp
 * and
 * https://android.googlesource.com/platform/frameworks/base/+/master/tools/aapt2/text/Unicode_data.cpp
 */
//package com.android.aaptcompiler

const val XID_START_FLAG = 1 shl 0
const val XID_CONTINUE_FLAG = 1 shl 1
const val XID_EITHER_FLAG = XID_START_FLAG or XID_CONTINUE_FLAG
private fun findCharacterProperties(utf32: Int): Int =
    when (utf32) {
        in 0x30..0x39 -> XID_CONTINUE_FLAG
        in 0x41..0x5a -> XID_EITHER_FLAG
        0x5f -> XID_CONTINUE_FLAG
        in 0x61..0x7a,
        0xaa,
        0xb5 -> XID_EITHER_FLAG
        0xb7 -> XID_CONTINUE_FLAG
        0xba,
        in 0xc0..0xd6,
        in 0xd8..0xf6,
        in 0xf8..0x2c1,
        in 0x2c6..0x2d1,
        in 0x2e0..0x2e4,
        0x2ec,
        0x2ee -> XID_EITHER_FLAG
        in 0x300..0x36f -> XID_CONTINUE_FLAG
        in 0x370..0x374,
        in 0x376..0x377,
        in 0x37b..0x37d,
        0x37f,
        0x386 -> XID_EITHER_FLAG
        0x387 -> XID_CONTINUE_FLAG
        in 0x388..0x38a,
        0x38c,
        in 0x38e..0x3a1,
        in 0x3a3..0x3f5,
        in 0x3f7..0x481 -> XID_EITHER_FLAG
        in 0x483..0x487 -> XID_CONTINUE_FLAG
        in 0x48a..0x52f,
        in 0x531..0x556,
        0x559,
        in 0x561..0x587 -> XID_EITHER_FLAG
        in 0x591..0x5bd,
        0x5bf,
        in 0x5c1..0x5c2,
        in 0x5c4..0x5c5,
        0x5c7 -> XID_CONTINUE_FLAG
        in 0x5d0..0x5ea,
        in 0x5f0..0x5f2 -> XID_EITHER_FLAG
        in 0x610..0x61a -> XID_CONTINUE_FLAG
        in 0x620..0x64a -> XID_EITHER_FLAG
        in 0x64b..0x669 -> XID_CONTINUE_FLAG
        in 0x66e..0x66f -> XID_EITHER_FLAG
        0x670 -> XID_CONTINUE_FLAG
        in 0x671..0x6d3,
        0x6d5 -> XID_EITHER_FLAG
        in 0x6d6..0x6dc,
        in 0x6df..0x6e4 -> XID_CONTINUE_FLAG
        in 0x6e5..0x6e6 -> XID_EITHER_FLAG
        in 0x6e7..0x6e8,
        in 0x6ea..0x6ed -> XID_CONTINUE_FLAG
        in 0x6ee..0x6ef -> XID_EITHER_FLAG
        in 0x6f0..0x6f9 -> XID_CONTINUE_FLAG
        in 0x6fa..0x6fc,
        0x6ff,
        0x710 -> XID_EITHER_FLAG
        0x711 -> XID_CONTINUE_FLAG
        in 0x712..0x72f -> XID_EITHER_FLAG
        in 0x730..0x74a -> XID_CONTINUE_FLAG
        in 0x74d..0x7a5 -> XID_EITHER_FLAG
        in 0x7a6..0x7b0 -> XID_CONTINUE_FLAG
        0x7b1 -> XID_EITHER_FLAG
        in 0x7c0..0x7c9 -> XID_CONTINUE_FLAG
        in 0x7ca..0x7ea -> XID_EITHER_FLAG
        in 0x7eb..0x7f3 -> XID_CONTINUE_FLAG
        in 0x7f4..0x7f5,
        0x7fa,
        in 0x800..0x815 -> XID_EITHER_FLAG
        in 0x816..0x819 -> XID_CONTINUE_FLAG
        0x81a -> XID_EITHER_FLAG
        in 0x81b..0x823 -> XID_CONTINUE_FLAG
        0x824 -> XID_EITHER_FLAG
        in 0x825..0x827 -> XID_CONTINUE_FLAG
        0x828 -> XID_EITHER_FLAG
        in 0x829..0x82d -> XID_CONTINUE_FLAG
        in 0x840..0x858 -> XID_EITHER_FLAG
        in 0x859..0x85b -> XID_CONTINUE_FLAG
        in 0x8a0..0x8b4,
        in 0x8b6..0x8bd -> XID_EITHER_FLAG
        in 0x8d4..0x8e1,
        in 0x8e3..0x903 -> XID_CONTINUE_FLAG
        in 0x904..0x939 -> XID_EITHER_FLAG
        in 0x93a..0x93c -> XID_CONTINUE_FLAG
        0x93d -> XID_EITHER_FLAG
        in 0x93e..0x94f -> XID_CONTINUE_FLAG
        0x950 -> XID_EITHER_FLAG
        in 0x951..0x957 -> XID_CONTINUE_FLAG
        in 0x958..0x961 -> XID_EITHER_FLAG
        in 0x962..0x963,
        in 0x966..0x96f -> XID_CONTINUE_FLAG
        in 0x971..0x980 -> XID_EITHER_FLAG
        in 0x981..0x983 -> XID_CONTINUE_FLAG
        in 0x985..0x98c,
        in 0x98f..0x990,
        in 0x993..0x9a8,
        in 0x9aa..0x9b0,
        0x9b2,
        in 0x9b6..0x9b9 -> XID_EITHER_FLAG
        0x9bc -> XID_CONTINUE_FLAG
        0x9bd -> XID_EITHER_FLAG
        in 0x9be..0x9c4,
        in 0x9c7..0x9c8,
        in 0x9cb..0x9cd -> XID_CONTINUE_FLAG
        0x9ce -> XID_EITHER_FLAG
        0x9d7 -> XID_CONTINUE_FLAG
        in 0x9dc..0x9dd,
        in 0x9df..0x9e1 -> XID_EITHER_FLAG
        in 0x9e2..0x9e3,
        in 0x9e6..0x9ef -> XID_CONTINUE_FLAG
        in 0x9f0..0x9f1 -> XID_EITHER_FLAG
        in 0xa01..0xa03 -> XID_CONTINUE_FLAG
        in 0xa05..0xa0a,
        in 0xa0f..0xa10,
        in 0xa13..0xa28,
        in 0xa2a..0xa30,
        in 0xa32..0xa33,
        in 0xa35..0xa36,
        in 0xa38..0xa39 -> XID_EITHER_FLAG
        0xa3c,
        in 0xa3e..0xa42,
        in 0xa47..0xa48,
        in 0xa4b..0xa4d,
        0xa51 -> XID_CONTINUE_FLAG
        in 0xa59..0xa5c,
        0xa5e -> XID_EITHER_FLAG
        in 0xa66..0xa71 -> XID_CONTINUE_FLAG
        in 0xa72..0xa74 -> XID_EITHER_FLAG
        0xa75,
        in 0xa81..0xa83 -> XID_CONTINUE_FLAG
        in 0xa85..0xa8d,
        in 0xa8f..0xa91,
        in 0xa93..0xaa8,
        in 0xaaa..0xab0,
        in 0xab2..0xab3,
        in 0xab5..0xab9 -> XID_EITHER_FLAG
        0xabc -> XID_CONTINUE_FLAG
        0xabd -> XID_EITHER_FLAG
        in 0xabe..0xac5,
        in 0xac7..0xac9,
        in 0xacb..0xacd -> XID_CONTINUE_FLAG
        0xad0,
        in 0xae0..0xae1 -> XID_EITHER_FLAG
        in 0xae2..0xae3,
        in 0xae6..0xaef -> XID_CONTINUE_FLAG
        0xaf9 -> XID_EITHER_FLAG
        in 0xb01..0xb03 -> XID_CONTINUE_FLAG
        in 0xb05..0xb0c,
        in 0xb0f..0xb10,
        in 0xb13..0xb28,
        in 0xb2a..0xb30,
        in 0xb32..0xb33,
        in 0xb35..0xb39 -> XID_EITHER_FLAG
        0xb3c -> XID_CONTINUE_FLAG
        0xb3d -> XID_EITHER_FLAG
        in 0xb3e..0xb44,
        in 0xb47..0xb48,
        in 0xb4b..0xb4d,
        in 0xb56..0xb57 -> XID_CONTINUE_FLAG
        in 0xb5c..0xb5d,
        in 0xb5f..0xb61 -> XID_EITHER_FLAG
        in 0xb62..0xb63,
        in 0xb66..0xb6f -> XID_CONTINUE_FLAG
        0xb71 -> XID_EITHER_FLAG
        0xb82 -> XID_CONTINUE_FLAG
        0xb83,
        in 0xb85..0xb8a,
        in 0xb8e..0xb90,
        in 0xb92..0xb95,
        in 0xb99..0xb9a,
        0xb9c,
        in 0xb9e..0xb9f,
        in 0xba3..0xba4,
        in 0xba8..0xbaa,
        in 0xbae..0xbb9 -> XID_EITHER_FLAG
        in 0xbbe..0xbc2,
        in 0xbc6..0xbc8,
        in 0xbca..0xbcd -> XID_CONTINUE_FLAG
        0xbd0 -> XID_EITHER_FLAG
        0xbd7,
        in 0xbe6..0xbef,
        in 0xc00..0xc03 -> XID_CONTINUE_FLAG
        in 0xc05..0xc0c,
        in 0xc0e..0xc10,
        in 0xc12..0xc28,
        in 0xc2a..0xc39,
        0xc3d -> XID_EITHER_FLAG
        in 0xc3e..0xc44,
        in 0xc46..0xc48,
        in 0xc4a..0xc4d,
        in 0xc55..0xc56 -> XID_CONTINUE_FLAG
        in 0xc58..0xc5a,
        in 0xc60..0xc61 -> XID_EITHER_FLAG
        in 0xc62..0xc63,
        in 0xc66..0xc6f -> XID_CONTINUE_FLAG
        0xc80 -> XID_EITHER_FLAG
        in 0xc81..0xc83 -> XID_CONTINUE_FLAG
        in 0xc85..0xc8c,
        in 0xc8e..0xc90,
        in 0xc92..0xca8,
        in 0xcaa..0xcb3,
        in 0xcb5..0xcb9 -> XID_EITHER_FLAG
        0xcbc -> XID_CONTINUE_FLAG
        0xcbd -> XID_EITHER_FLAG
        in 0xcbe..0xcc4,
        in 0xcc6..0xcc8,
        in 0xcca..0xccd,
        in 0xcd5..0xcd6 -> XID_CONTINUE_FLAG
        0xcde,
        in 0xce0..0xce1 -> XID_EITHER_FLAG
        in 0xce2..0xce3,
        in 0xce6..0xcef -> XID_CONTINUE_FLAG
        in 0xcf1..0xcf2 -> XID_EITHER_FLAG
        in 0xd01..0xd03 -> XID_CONTINUE_FLAG
        in 0xd05..0xd0c,
        in 0xd0e..0xd10,
        in 0xd12..0xd3a,
        0xd3d -> XID_EITHER_FLAG
        in 0xd3e..0xd44,
        in 0xd46..0xd48,
        in 0xd4a..0xd4d -> XID_CONTINUE_FLAG
        0xd4e,
        in 0xd54..0xd56 -> XID_EITHER_FLAG
        0xd57 -> XID_CONTINUE_FLAG
        in 0xd5f..0xd61 -> XID_EITHER_FLAG
        in 0xd62..0xd63,
        in 0xd66..0xd6f -> XID_CONTINUE_FLAG
        in 0xd7a..0xd7f -> XID_EITHER_FLAG
        in 0xd82..0xd83 -> XID_CONTINUE_FLAG
        in 0xd85..0xd96,
        in 0xd9a..0xdb1,
        in 0xdb3..0xdbb,
        0xdbd,
        in 0xdc0..0xdc6 -> XID_EITHER_FLAG
        0xdca,
        in 0xdcf..0xdd4,
        0xdd6,
        in 0xdd8..0xddf,
        in 0xde6..0xdef,
        in 0xdf2..0xdf3 -> XID_CONTINUE_FLAG
        in 0xe01..0xe30 -> XID_EITHER_FLAG
        0xe31 -> XID_CONTINUE_FLAG
        0xe32 -> XID_EITHER_FLAG
        in 0xe33..0xe3a -> XID_CONTINUE_FLAG
        in 0xe40..0xe46 -> XID_EITHER_FLAG
        in 0xe47..0xe4e,
        in 0xe50..0xe59 -> XID_CONTINUE_FLAG
        in 0xe81..0xe82,
        0xe84,
        in 0xe87..0xe88,
        0xe8a,
        0xe8d,
        in 0xe94..0xe97,
        in 0xe99..0xe9f,
        in 0xea1..0xea3,
        0xea5,
        0xea7,
        in 0xeaa..0xeab,
        in 0xead..0xeb0 -> XID_EITHER_FLAG
        0xeb1 -> XID_CONTINUE_FLAG
        0xeb2 -> XID_EITHER_FLAG
        in 0xeb3..0xeb9,
        in 0xebb..0xebc -> XID_CONTINUE_FLAG
        0xebd,
        in 0xec0..0xec4,
        0xec6 -> XID_EITHER_FLAG
        in 0xec8..0xecd,
        in 0xed0..0xed9 -> XID_CONTINUE_FLAG
        in 0xedc..0xedf,
        0xf00 -> XID_EITHER_FLAG
        in 0xf18..0xf19,
        in 0xf20..0xf29,
        0xf35,
        0xf37,
        0xf39,
        in 0xf3e..0xf3f -> XID_CONTINUE_FLAG
        in 0xf40..0xf47,
        in 0xf49..0xf6c -> XID_EITHER_FLAG
        in 0xf71..0xf84,
        in 0xf86..0xf87 -> XID_CONTINUE_FLAG
        in 0xf88..0xf8c -> XID_EITHER_FLAG
        in 0xf8d..0xf97,
        in 0xf99..0xfbc,
        0xfc6 -> XID_CONTINUE_FLAG
        in 0x1000..0x102a -> XID_EITHER_FLAG
        in 0x102b..0x103e -> XID_CONTINUE_FLAG
        0x103f -> XID_EITHER_FLAG
        in 0x1040..0x1049 -> XID_CONTINUE_FLAG
        in 0x1050..0x1055 -> XID_EITHER_FLAG
        in 0x1056..0x1059 -> XID_CONTINUE_FLAG
        in 0x105a..0x105d -> XID_EITHER_FLAG
        in 0x105e..0x1060 -> XID_CONTINUE_FLAG
        0x1061 -> XID_EITHER_FLAG
        in 0x1062..0x1064 -> XID_CONTINUE_FLAG
        in 0x1065..0x1066 -> XID_EITHER_FLAG
        in 0x1067..0x106d -> XID_CONTINUE_FLAG
        in 0x106e..0x1070 -> XID_EITHER_FLAG
        in 0x1071..0x1074 -> XID_CONTINUE_FLAG
        in 0x1075..0x1081 -> XID_EITHER_FLAG
        in 0x1082..0x108d -> XID_CONTINUE_FLAG
        0x108e -> XID_EITHER_FLAG
        in 0x108f..0x109d -> XID_CONTINUE_FLAG
        in 0x10a0..0x10c5,
        0x10c7,
        0x10cd,
        in 0x10d0..0x10fa,
        in 0x10fc..0x1248,
        in 0x124a..0x124d,
        in 0x1250..0x1256,
        0x1258,
        in 0x125a..0x125d,
        in 0x1260..0x1288,
        in 0x128a..0x128d,
        in 0x1290..0x12b0,
        in 0x12b2..0x12b5,
        in 0x12b8..0x12be,
        0x12c0,
        in 0x12c2..0x12c5,
        in 0x12c8..0x12d6,
        in 0x12d8..0x1310,
        in 0x1312..0x1315,
        in 0x1318..0x135a -> XID_EITHER_FLAG
        in 0x135d..0x135f,
        in 0x1369..0x1371 -> XID_CONTINUE_FLAG
        in 0x1380..0x138f,
        in 0x13a0..0x13f5,
        in 0x13f8..0x13fd,
        in 0x1401..0x166c,
        in 0x166f..0x167f,
        in 0x1681..0x169a,
        in 0x16a0..0x16ea,
        in 0x16ee..0x16f8,
        in 0x1700..0x170c,
        in 0x170e..0x1711 -> XID_EITHER_FLAG
        in 0x1712..0x1714 -> XID_CONTINUE_FLAG
        in 0x1720..0x1731 -> XID_EITHER_FLAG
        in 0x1732..0x1734 -> XID_CONTINUE_FLAG
        in 0x1740..0x1751 -> XID_EITHER_FLAG
        in 0x1752..0x1753 -> XID_CONTINUE_FLAG
        in 0x1760..0x176c,
        in 0x176e..0x1770 -> XID_EITHER_FLAG
        in 0x1772..0x1773 -> XID_CONTINUE_FLAG
        in 0x1780..0x17b3 -> XID_EITHER_FLAG
        in 0x17b4..0x17d3 -> XID_CONTINUE_FLAG
        0x17d7,
        0x17dc -> XID_EITHER_FLAG
        0x17dd,
        in 0x17e0..0x17e9,
        in 0x180b..0x180d,
        in 0x1810..0x1819 -> XID_CONTINUE_FLAG
        in 0x1820..0x1877,
        in 0x1880..0x18a8 -> XID_EITHER_FLAG
        0x18a9 -> XID_CONTINUE_FLAG
        0x18aa,
        in 0x18b0..0x18f5,
        in 0x1900..0x191e -> XID_EITHER_FLAG
        in 0x1920..0x192b,
        in 0x1930..0x193b,
        in 0x1946..0x194f -> XID_CONTINUE_FLAG
        in 0x1950..0x196d,
        in 0x1970..0x1974,
        in 0x1980..0x19ab,
        in 0x19b0..0x19c9 -> XID_EITHER_FLAG
        in 0x19d0..0x19da -> XID_CONTINUE_FLAG
        in 0x1a00..0x1a16 -> XID_EITHER_FLAG
        in 0x1a17..0x1a1b -> XID_CONTINUE_FLAG
        in 0x1a20..0x1a54 -> XID_EITHER_FLAG
        in 0x1a55..0x1a5e,
        in 0x1a60..0x1a7c,
        in 0x1a7f..0x1a89,
        in 0x1a90..0x1a99 -> XID_CONTINUE_FLAG
        0x1aa7 -> XID_EITHER_FLAG
        in 0x1ab0..0x1abd,
        in 0x1b00..0x1b04 -> XID_CONTINUE_FLAG
        in 0x1b05..0x1b33 -> XID_EITHER_FLAG
        in 0x1b34..0x1b44 -> XID_CONTINUE_FLAG
        in 0x1b45..0x1b4b -> XID_EITHER_FLAG
        in 0x1b50..0x1b59,
        in 0x1b6b..0x1b73,
        in 0x1b80..0x1b82 -> XID_CONTINUE_FLAG
        in 0x1b83..0x1ba0 -> XID_EITHER_FLAG
        in 0x1ba1..0x1bad -> XID_CONTINUE_FLAG
        in 0x1bae..0x1baf -> XID_EITHER_FLAG
        in 0x1bb0..0x1bb9 -> XID_CONTINUE_FLAG
        in 0x1bba..0x1be5 -> XID_EITHER_FLAG
        in 0x1be6..0x1bf3 -> XID_CONTINUE_FLAG
        in 0x1c00..0x1c23 -> XID_EITHER_FLAG
        in 0x1c24..0x1c37,
        in 0x1c40..0x1c49 -> XID_CONTINUE_FLAG
        in 0x1c4d..0x1c4f -> XID_EITHER_FLAG
        in 0x1c50..0x1c59 -> XID_CONTINUE_FLAG
        in 0x1c5a..0x1c7d,
        in 0x1c80..0x1c88 -> XID_EITHER_FLAG
        in 0x1cd0..0x1cd2,
        in 0x1cd4..0x1ce8 -> XID_CONTINUE_FLAG
        in 0x1ce9..0x1cec -> XID_EITHER_FLAG
        0x1ced -> XID_CONTINUE_FLAG
        in 0x1cee..0x1cf1 -> XID_EITHER_FLAG
        in 0x1cf2..0x1cf4 -> XID_CONTINUE_FLAG
        in 0x1cf5..0x1cf6 -> XID_EITHER_FLAG
        in 0x1cf8..0x1cf9 -> XID_CONTINUE_FLAG
        in 0x1d00..0x1dbf -> XID_EITHER_FLAG
        in 0x1dc0..0x1df5,
        in 0x1dfb..0x1dff -> XID_CONTINUE_FLAG
        in 0x1e00..0x1f15,
        in 0x1f18..0x1f1d,
        in 0x1f20..0x1f45,
        in 0x1f48..0x1f4d,
        in 0x1f50..0x1f57,
        0x1f59,
        0x1f5b,
        0x1f5d,
        in 0x1f5f..0x1f7d,
        in 0x1f80..0x1fb4,
        in 0x1fb6..0x1fbc,
        0x1fbe,
        in 0x1fc2..0x1fc4,
        in 0x1fc6..0x1fcc,
        in 0x1fd0..0x1fd3,
        in 0x1fd6..0x1fdb,
        in 0x1fe0..0x1fec,
        in 0x1ff2..0x1ff4,
        in 0x1ff6..0x1ffc -> XID_EITHER_FLAG
        in 0x203f..0x2040,
        0x2054 -> XID_CONTINUE_FLAG
        0x2071,
        0x207f,
        in 0x2090..0x209c -> XID_EITHER_FLAG
        in 0x20d0..0x20dc,
        0x20e1,
        in 0x20e5..0x20f0 -> XID_CONTINUE_FLAG
        0x2102,
        0x2107,
        in 0x210a..0x2113,
        0x2115,
        in 0x2118..0x211d,
        0x2124,
        0x2126,
        0x2128,
        in 0x212a..0x2139,
        in 0x213c..0x213f,
        in 0x2145..0x2149,
        0x214e,
        in 0x2160..0x2188,
        in 0x2c00..0x2c2e,
        in 0x2c30..0x2c5e,
        in 0x2c60..0x2ce4,
        in 0x2ceb..0x2cee -> XID_EITHER_FLAG
        in 0x2cef..0x2cf1 -> XID_CONTINUE_FLAG
        in 0x2cf2..0x2cf3,
        in 0x2d00..0x2d25,
        0x2d27,
        0x2d2d,
        in 0x2d30..0x2d67,
        0x2d6f -> XID_EITHER_FLAG
        0x2d7f -> XID_CONTINUE_FLAG
        in 0x2d80..0x2d96,
        in 0x2da0..0x2da6,
        in 0x2da8..0x2dae,
        in 0x2db0..0x2db6,
        in 0x2db8..0x2dbe,
        in 0x2dc0..0x2dc6,
        in 0x2dc8..0x2dce,
        in 0x2dd0..0x2dd6,
        in 0x2dd8..0x2dde -> XID_EITHER_FLAG
        in 0x2de0..0x2dff -> XID_CONTINUE_FLAG
        in 0x3005..0x3007,
        in 0x3021..0x3029 -> XID_EITHER_FLAG
        in 0x302a..0x302f -> XID_CONTINUE_FLAG
        in 0x3031..0x3035,
        in 0x3038..0x303c,
        in 0x3041..0x3096 -> XID_EITHER_FLAG
        in 0x3099..0x309a -> XID_CONTINUE_FLAG
        in 0x309d..0x309f,
        in 0x30a1..0x30fa,
        in 0x30fc..0x30ff,
        in 0x3105..0x312d,
        in 0x3131..0x318e,
        in 0x31a0..0x31ba,
        in 0x31f0..0x31ff,
        in 0x3400..0x4db5,
        in 0x4e00..0x9fd5,
        in 0xa000..0xa48c,
        in 0xa4d0..0xa4fd,
        in 0xa500..0xa60c,
        in 0xa610..0xa61f -> XID_EITHER_FLAG
        in 0xa620..0xa629 -> XID_CONTINUE_FLAG
        in 0xa62a..0xa62b,
        in 0xa640..0xa66e -> XID_EITHER_FLAG
        0xa66f,
        in 0xa674..0xa67d -> XID_CONTINUE_FLAG
        in 0xa67f..0xa69d -> XID_EITHER_FLAG
        in 0xa69e..0xa69f -> XID_CONTINUE_FLAG
        in 0xa6a0..0xa6ef -> XID_EITHER_FLAG
        in 0xa6f0..0xa6f1 -> XID_CONTINUE_FLAG
        in 0xa717..0xa71f,
        in 0xa722..0xa788,
        in 0xa78b..0xa7ae,
        in 0xa7b0..0xa7b7,
        in 0xa7f7..0xa801 -> XID_EITHER_FLAG
        0xa802 -> XID_CONTINUE_FLAG
        in 0xa803..0xa805 -> XID_EITHER_FLAG
        0xa806 -> XID_CONTINUE_FLAG
        in 0xa807..0xa80a -> XID_EITHER_FLAG
        0xa80b -> XID_CONTINUE_FLAG
        in 0xa80c..0xa822 -> XID_EITHER_FLAG
        in 0xa823..0xa827 -> XID_CONTINUE_FLAG
        in 0xa840..0xa873 -> XID_EITHER_FLAG
        in 0xa880..0xa881 -> XID_CONTINUE_FLAG
        in 0xa882..0xa8b3 -> XID_EITHER_FLAG
        in 0xa8b4..0xa8c5,
        in 0xa8d0..0xa8d9,
        in 0xa8e0..0xa8f1 -> XID_CONTINUE_FLAG
        in 0xa8f2..0xa8f7,
        0xa8fb,
        0xa8fd -> XID_EITHER_FLAG
        in 0xa900..0xa909 -> XID_CONTINUE_FLAG
        in 0xa90a..0xa925 -> XID_EITHER_FLAG
        in 0xa926..0xa92d -> XID_CONTINUE_FLAG
        in 0xa930..0xa946 -> XID_EITHER_FLAG
        in 0xa947..0xa953 -> XID_CONTINUE_FLAG
        in 0xa960..0xa97c -> XID_EITHER_FLAG
        in 0xa980..0xa983 -> XID_CONTINUE_FLAG
        in 0xa984..0xa9b2 -> XID_EITHER_FLAG
        in 0xa9b3..0xa9c0 -> XID_CONTINUE_FLAG
        0xa9cf -> XID_EITHER_FLAG
        in 0xa9d0..0xa9d9 -> XID_CONTINUE_FLAG
        in 0xa9e0..0xa9e4 -> XID_EITHER_FLAG
        0xa9e5 -> XID_CONTINUE_FLAG
        in 0xa9e6..0xa9ef -> XID_EITHER_FLAG
        in 0xa9f0..0xa9f9 -> XID_CONTINUE_FLAG
        in 0xa9fa..0xa9fe,
        in 0xaa00..0xaa28 -> XID_EITHER_FLAG
        in 0xaa29..0xaa36 -> XID_CONTINUE_FLAG
        in 0xaa40..0xaa42 -> XID_EITHER_FLAG
        0xaa43 -> XID_CONTINUE_FLAG
        in 0xaa44..0xaa4b -> XID_EITHER_FLAG
        in 0xaa4c..0xaa4d,
        in 0xaa50..0xaa59 -> XID_CONTINUE_FLAG
        in 0xaa60..0xaa76,
        0xaa7a -> XID_EITHER_FLAG
        in 0xaa7b..0xaa7d -> XID_CONTINUE_FLAG
        in 0xaa7e..0xaaaf -> XID_EITHER_FLAG
        0xaab0 -> XID_CONTINUE_FLAG
        0xaab1 -> XID_EITHER_FLAG
        in 0xaab2..0xaab4 -> XID_CONTINUE_FLAG
        in 0xaab5..0xaab6 -> XID_EITHER_FLAG
        in 0xaab7..0xaab8 -> XID_CONTINUE_FLAG
        in 0xaab9..0xaabd -> XID_EITHER_FLAG
        in 0xaabe..0xaabf -> XID_CONTINUE_FLAG
        0xaac0 -> XID_EITHER_FLAG
        0xaac1 -> XID_CONTINUE_FLAG
        0xaac2,
        in 0xaadb..0xaadd,
        in 0xaae0..0xaaea -> XID_EITHER_FLAG
        in 0xaaeb..0xaaef -> XID_CONTINUE_FLAG
        in 0xaaf2..0xaaf4 -> XID_EITHER_FLAG
        in 0xaaf5..0xaaf6 -> XID_CONTINUE_FLAG
        in 0xab01..0xab06,
        in 0xab09..0xab0e,
        in 0xab11..0xab16,
        in 0xab20..0xab26,
        in 0xab28..0xab2e,
        in 0xab30..0xab5a,
        in 0xab5c..0xab65,
        in 0xab70..0xabe2 -> XID_EITHER_FLAG
        in 0xabe3..0xabea,
        in 0xabec..0xabed,
        in 0xabf0..0xabf9 -> XID_CONTINUE_FLAG
        in 0xac00..0xd7a3,
        in 0xd7b0..0xd7c6,
        in 0xd7cb..0xd7fb,
        in 0xf900..0xfa6d,
        in 0xfa70..0xfad9,
        in 0xfb00..0xfb06,
        in 0xfb13..0xfb17,
        0xfb1d -> XID_EITHER_FLAG
        0xfb1e -> XID_CONTINUE_FLAG
        in 0xfb1f..0xfb28,
        in 0xfb2a..0xfb36,
        in 0xfb38..0xfb3c,
        0xfb3e,
        in 0xfb40..0xfb41,
        in 0xfb43..0xfb44,
        in 0xfb46..0xfbb1,
        in 0xfbd3..0xfc5d,
        in 0xfc64..0xfd3d,
        in 0xfd50..0xfd8f,
        in 0xfd92..0xfdc7,
        in 0xfdf0..0xfdf9 -> XID_EITHER_FLAG
        in 0xfe00..0xfe0f,
        in 0xfe20..0xfe2f,
        in 0xfe33..0xfe34,
        in 0xfe4d..0xfe4f -> XID_CONTINUE_FLAG
        0xfe71,
        0xfe73,
        0xfe77,
        0xfe79,
        0xfe7b,
        0xfe7d,
        in 0xfe7f..0xfefc -> XID_EITHER_FLAG
        in 0xff10..0xff19 -> XID_CONTINUE_FLAG
        in 0xff21..0xff3a -> XID_EITHER_FLAG
        0xff3f -> XID_CONTINUE_FLAG
        in 0xff41..0xff5a,
        in 0xff66..0xff9d -> XID_EITHER_FLAG
        in 0xff9e..0xff9f -> XID_CONTINUE_FLAG
        in 0xffa0..0xffbe,
        in 0xffc2..0xffc7,
        in 0xffca..0xffcf,
        in 0xffd2..0xffd7,
        in 0xffda..0xffdc -> XID_EITHER_FLAG
        else -> 0
    }

/**
 * Returns true if the Unicode codepoint has the XID_Start property, meaning it can be used as the
 * first character of a programming language identifier.
 * http://unicode.org/reports/tr31/#Default_Identifier_Syntax
 *
 * XID_Start is a Unicode Derived Core Property. It is a variation of the ID_Start
 * Derived Core Property, accounting for a few characters that, when normalized, yield valid
 * characters in the ID_Start set.
 */
fun isXidStart(utf32: Int): Boolean = (findCharacterProperties(utf32) and XID_START_FLAG) != 0

/**
 * Returns true if the Unicode codepoint has the XID_Continue property, meaning it can be used in
 * any position of a programming language identifier, except the first.
 * http://unicode.org/reports/tr31/#Default_Identifier_Syntax
 *
 * XID_Continue is a Unicode Derived Core Property. It is a variation of the ID_Continue
 * Derived Core Property, accounting for a few characters that, when normalized, yield valid
 * characters in the ID_Continue set.
 */
fun isXidContinue(utf32: Int): Boolean = (findCharacterProperties(utf32) and XID_CONTINUE_FLAG) != 0


private val JAVA_REVERSED_KEYWORDS = arrayListOf<String>(
    "abstract",
    "assert",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "goto",
    "if",
    "implements",
    "import",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "strictfp",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "void",
    "volatile",
    "while",
    "continue",
)

fun isJavaReversedKeywords(string: String): Boolean{
    return JAVA_REVERSED_KEYWORDS.contains(string)
}

/**
 * Returns true if the UTF8 string can be used as a Java identifier.
 * NOTE: This does not check against the set of reserved Java keywords.
 */
fun isJavaIdentifier(string: String): Boolean {
    if (string.isEmpty()) {
        return false
    }
    val firstCodePoint = string.codePointAt(0)
    if (!isXidStart(firstCodePoint) &&
        firstCodePoint != '_'.toInt() &&
        firstCodePoint != '$'.toInt()
    ) {
        return false
    }
    for (i in 1.until(string.codePointCount(0, string.length))) {
        val codePoint = string.codePointAt(i)
        if (!isXidContinue(codePoint) && codePoint != '$'.toInt()) {
            return false
        }
    }
    return true
}

/**
 * Returns true if the UTF8 string can be used as the entry name of a resource name.
 * This is the `entry` part of package:type/entry.
 */
fun isValidResourceEntryName(string: String): Boolean {
    if (string.isEmpty()) {
        return false
    }
    // Resources can start with '_'.
    val firstCodePoint = string.codePointAt(0)
    if (!isXidStart(firstCodePoint) && firstCodePoint != '_'.toInt()) {
        return false
    }
    for (i in 1.until(string.codePointCount(0, string.length))) {
        val codePoint = string.codePointAt(i)
        if (!isXidContinue(codePoint) && codePoint != '.'.toInt() && codePoint != '-'.toInt()) {
            return false
        }
    }
    return true
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResArrayValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.io.IOException;
import java.util.Arrays;

import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResArrayValue extends ResBagValue implements
        ResValuesXmlSerializable {

    ResArrayValue(ResReferenceValue parent, Duo<Integer, ResScalarValue>[] items) {
        super(parent);

        mItems = new ResScalarValue[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = items[i].m2;
        }
    }

    public ResArrayValue(ResReferenceValue parent, ResScalarValue[] items) {
        super(parent);
        mItems = items;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = getType();
        type = (type == null ? "" : type + "-") + "array";
        serializer.startTag(null, type);
        serializer.attribute(null, "name", res.getResSpec().getName());

        // lets check if we need to add formatted="false" to this array
        for (int i = 0; i < mItems.length; i++) {
            if (mItems[i].hasMultipleNonPositionalSubstitutions()) {
                serializer.attribute(null, "formatted", "false");
                break;
            }
        }

        // add <item>'s
        for (int i = 0; i < mItems.length; i++) {
            serializer.startTag(null, "item");
            serializer.text(mItems[i].encodeAsResXmlNonEscapedItemValue());
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, type);
    }

    public String getType() throws AndrolibException {
        if (mItems.length == 0) {
            return null;
        }
        String type = mItems[0].getType();
        for (int i = 0; i < mItems.length; i++) {
            if (mItems[i].encodeAsResXmlItemValue().startsWith("@string")) {
                return "string";
            } else if (mItems[i].encodeAsResXmlItemValue().startsWith("@drawable")) {
                return null;
            } else if (mItems[i].encodeAsResXmlItemValue().startsWith("@integer")) {
                return "integer";
            } else if (!"string".equals(type) && !"integer".equals(type)) {
                return null;
            } else if (!type.equals(mItems[i].getType())) {
                return null;
            }
        }
        if (!Arrays.asList(AllowedArrayTypes).contains(type)) {
            return "string";
        }
        return type;
    }

    private final ResScalarValue[] mItems;
    private final String[] AllowedArrayTypes = {"string", "integer"};

    public static final int BAG_KEY_ARRAY_START = 0x02000000;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResAttr extends ResBagValue implements ResValuesXmlSerializable {
    ResAttr(ResReferenceValue parentVal, int type, Integer min, Integer max,
            Boolean l10n) {
        super(parentVal);
        mType = type;
        mMin = min;
        mMax = max;
        mL10n = l10n;
    }

    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        return null;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = getTypeAsString();

        serializer.startTag(null, "attr");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (type != null) {
            serializer.attribute(null, "format", type);
        }
        if (mMin != null) {
            serializer.attribute(null, "min", mMin.toString());
        }
        if (mMax != null) {
            serializer.attribute(null, "max", mMax.toString());
        }
        if (mL10n != null && mL10n) {
            serializer.attribute(null, "localization", "suggested");
        }
        serializeBody(serializer, res);
        serializer.endTag(null, "attr");
    }

    public static ResAttr factory(ResReferenceValue parent,
                                  Duo<Integer, ResScalarValue>[] items, ResValueFactory factory,
                                  ResPackage pkg) throws AndrolibException {

        int type = ((ResIntValue) items[0].m2).getValue();
        int scalarType = type & 0xffff;
        Integer min = null, max = null;
        Boolean l10n = null;
        int i;
        for (i = 1; i < items.length; i++) {
            switch (items[i].m1) {
                case BAG_KEY_ATTR_MIN:
                    min = ((ResIntValue) items[i].m2).getValue();
                    continue;
                case BAG_KEY_ATTR_MAX:
                    max = ((ResIntValue) items[i].m2).getValue();
                    continue;
                case BAG_KEY_ATTR_L10N:
                    l10n = ((ResIntValue) items[i].m2).getValue() != 0;
                    continue;
            }
            break;
        }

        if (i == items.length) {
            return new ResAttr(parent, scalarType, min, max, l10n);
        }
        Duo<ResReferenceValue, ResIntValue>[] attrItems = new Duo[items.length
                - i];
        int j = 0;
        for (; i < items.length; i++) {
            int resId = items[i].m1;
            pkg.addSynthesizedRes(resId);
            attrItems[j++] = new Duo<ResReferenceValue, ResIntValue>(
                    factory.newReference(resId, null),
                    (ResIntValue) items[i].m2);
        }
        switch (type & 0xff0000) {
            case TYPE_ENUM:
                return new ResEnumAttr(parent, scalarType, min, max, l10n,
                        attrItems);
            case TYPE_FLAGS:
                return new ResFlagsAttr(parent, scalarType, min, max, l10n,
                        attrItems);
        }

        throw new AndrolibException("Could not decode attr value");
    }

    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
    }

    protected String getTypeAsString() {
        String s = "";
        if ((mType & TYPE_REFERENCE) != 0) {
            s += "|reference";
        }
        if ((mType & TYPE_STRING) != 0) {
            s += "|string";
        }
        if ((mType & TYPE_INT) != 0) {
            s += "|integer";
        }
        if ((mType & TYPE_BOOL) != 0) {
            s += "|boolean";
        }
        if ((mType & TYPE_COLOR) != 0) {
            s += "|color";
        }
        if ((mType & TYPE_FLOAT) != 0) {
            s += "|float";
        }
        if ((mType & TYPE_DIMEN) != 0) {
            s += "|dimension";
        }
        if ((mType & TYPE_FRACTION) != 0) {
            s += "|fraction";
        }
        if (s.isEmpty()) {
            return null;
        }
        return s.substring(1);
    }

    private final int mType;
    private final Integer mMin;
    private final Integer mMax;
    private final Boolean mL10n;

    public static final int BAG_KEY_ATTR_TYPE = 0x01000000;
    private static final int BAG_KEY_ATTR_MIN = 0x01000001;
    private static final int BAG_KEY_ATTR_MAX = 0x01000002;
    private static final int BAG_KEY_ATTR_L10N = 0x01000003;

    private final static int TYPE_REFERENCE = 0x01;
    private final static int TYPE_STRING = 0x02;
    private final static int TYPE_INT = 0x04;
    private final static int TYPE_BOOL = 0x08;
    private final static int TYPE_COLOR = 0x10;
    private final static int TYPE_FLOAT = 0x20;
    private final static int TYPE_DIMEN = 0x40;
    private final static int TYPE_FRACTION = 0x80;
    private final static int TYPE_ANY_STRING = 0xee;

    private static final int TYPE_ENUM = 0x00010000;
    private static final int TYPE_FLAGS = 0x00020000;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResBagValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResBagValue extends ResValue implements ResValuesXmlSerializable {
    protected final ResReferenceValue mParent;

    public ResBagValue(ResReferenceValue parent) {
        this.mParent = parent;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = res.getResSpec().getType().getName();
        if ("style".equals(type)) {
            new ResStyleValue(mParent, new Duo[0], null)
                    .serializeToResValuesXml(serializer, res);
            return;
        }
        if ("array".equals(type)) {
            new ResArrayValue(mParent, new Duo[0]).serializeToResValuesXml(
                    serializer, res);
            return;
        }
        if ("plurals".equals(type)) {
            new ResPluralsValue(mParent, new Duo[0]).serializeToResValuesXml(
                    serializer, res);
            return;
        }

        serializer.startTag(null, "item");
        serializer.attribute(null, "type", type);
        serializer.attribute(null, "name", res.getResSpec().getName());
        serializer.endTag(null, "item");
    }

    public ResReferenceValue getParent() {
        return mParent;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResBoolValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResBoolValue extends ResScalarValue {
    private final boolean mValue;

    public ResBoolValue(boolean value, int rawIntValue, String rawValue) {
        super("bool", rawIntValue, rawValue);
        this.mValue = value;
    }

    public boolean getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() {
        return mValue ? "true" : "false";
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResColorValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResColorValue extends ResIntValue {
    public ResColorValue(int value, String rawValue) {
        super(value, rawValue, "color");
    }

    @Override
    protected String encodeAsResXml() {
        return String.format("#%08x", mValue);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResDimenValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResDimenValue extends ResIntValue {
    public ResDimenValue(int value, String rawValue) {
        super(value, rawValue, "dimen");
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(TypedValue.TYPE_DIMENSION, mValue);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResEmptyValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;

public class ResEmptyValue extends ResScalarValue {
    protected final int mValue;
    protected int type;

    public ResEmptyValue(int value, String rawValue, int type) {
        this(value, rawValue, "integer");
        this.type = type;
    }

    public ResEmptyValue(int value, String rawValue, String type) {
        super(type, value, rawValue);
        if (value != 1)
            throw new UnsupportedOperationException();
        this.mValue = value;
    }

    public int getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return "@empty";
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResEnumAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.util.Duo;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResEnumAttr extends ResAttr {
    ResEnumAttr(ResReferenceValue parent, int type, Integer min, Integer max,
                Boolean l10n, Duo<ResReferenceValue, ResIntValue>[] items) {
        super(parent, type, min, max, l10n);
        mItems = items;
    }

    @Override
    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        if (value instanceof ResIntValue) {
            String ret = decodeValue(((ResIntValue) value).getValue());
            if (ret != null) {
                return ret;
            }
        }
        return super.convertToResXmlFormat(value);
    }

    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (Duo<ResReferenceValue, ResIntValue> duo : mItems) {
            int intVal = duo.m2.getValue();
            ResResSpec m1Referent = duo.m1.getReferent();

            serializer.startTag(null, "enum");
            serializer.attribute(null, "name",
                    m1Referent != null ? m1Referent.getName() : "@null"
            );
            serializer.attribute(null, "value", String.valueOf(intVal));
            serializer.endTag(null, "enum");
        }
    }

    private String decodeValue(int value) throws AndrolibException {
        String value2 = mItemsCache.get(value);
        if (value2 == null) {
            ResReferenceValue ref = null;
            for (Duo<ResReferenceValue, ResIntValue> duo : mItems) {
                if (duo.m2.getValue() == value) {
                    ref = duo.m1;
                    break;
                }
            }
            if (ref != null) {
                value2 = ref.getReferent().getName();
                mItemsCache.put(value, value2);
            }
        }
        return value2;
    }

    private final Duo<ResReferenceValue, ResIntValue>[] mItems;
    private final Map<Integer, String> mItemsCache = new HashMap<Integer, String>();
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFileValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResFileValue extends ResIntBasedValue {
    private final String mPath;

    public ResFileValue(String path, int rawIntValue) {
        super(rawIntValue);
        this.mPath = path;
    }

    public String getStrippedPath() throws AndrolibException {
        if (mPath.startsWith("res/")) {
            return mPath.substring(4);
        }
        if (mPath.startsWith("r/") || mPath.startsWith("R/")) {
            return mPath.substring(2);
        }
        throw new AndrolibException("File path does not start with \"res/\" or \"r/\": " + mPath);
    }

    @Override
    public String toString() {
        return mPath;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFlagsAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.util.Duo;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResFlagsAttr extends ResAttr {
    ResFlagsAttr(ResReferenceValue parent, int type, Integer min, Integer max,
                 Boolean l10n, Duo<ResReferenceValue, ResIntValue>[] items) {
        super(parent, type, min, max, l10n);

        mItems = new FlagItem[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = new FlagItem(items[i].m1, items[i].m2.getValue());
        }
    }

    @Override
    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        if(value instanceof ResReferenceValue) {
            return value.encodeAsResXml();
        }
        if (!(value instanceof ResIntValue)) {
            return super.convertToResXmlFormat(value);
        }
        loadFlags();
        int intVal = ((ResIntValue) value).getValue();

        if (intVal == 0) {
            return renderFlags(mZeroFlags);
        }

        FlagItem[] flagItems = new FlagItem[mFlags.length];
        int[] flags = new int[mFlags.length];
        int flagsCount = 0;
        for (int i = 0; i < mFlags.length; i++) {
            FlagItem flagItem = mFlags[i];
            int flag = flagItem.flag;

            if ((intVal & flag) != flag) {
                continue;
            }

            if (!isSubpartOf(flag, flags)) {
                flags[flagsCount] = flag;
                flagItems[flagsCount++] = flagItem;
            }
        }
        return renderFlags(Arrays.copyOf(flagItems, flagsCount));
    }

    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (int i = 0; i < mItems.length; i++) {
            FlagItem item = mItems[i];

            serializer.startTag(null, "flag");
            serializer.attribute(null, "name", item.getValue());
            serializer.attribute(null, "value",
                    String.format("0x%08x", item.flag));
            serializer.endTag(null, "flag");
        }
    }

    private boolean isSubpartOf(int flag, int[] flags) {
        for (int i = 0; i < flags.length; i++) {
            if ((flags[i] & flag) == flag) {
                return true;
            }
        }
        return false;
    }

    private String renderFlags(FlagItem[] flags) throws AndrolibException {
        String ret = "";
        for (int i = 0; i < flags.length; i++) {
            ret += "|" + flags[i].getValue();
        }
        if (ret.isEmpty()) {
            return ret;
        }
        return ret.substring(1);
    }

    private void loadFlags() {
        if (mFlags != null) {
            return;
        }

        FlagItem[] zeroFlags = new FlagItem[mItems.length];
        int zeroFlagsCount = 0;
        FlagItem[] flags = new FlagItem[mItems.length];
        int flagsCount = 0;

        for (int i = 0; i < mItems.length; i++) {
            FlagItem item = mItems[i];
            if (item.flag == 0) {
                zeroFlags[zeroFlagsCount++] = item;
            } else {
                flags[flagsCount++] = item;
            }
        }

        mZeroFlags = Arrays.copyOf(zeroFlags, zeroFlagsCount);
        mFlags = Arrays.copyOf(flags, flagsCount);

        Arrays.sort(mFlags, new Comparator<FlagItem>() {
            @Override
            public int compare(FlagItem o1, FlagItem o2) {
                return Integer.valueOf(Integer.bitCount(o2.flag)).compareTo(
                        Integer.bitCount(o1.flag));
            }
        });
    }

    private final FlagItem[] mItems;

    private FlagItem[] mZeroFlags;
    private FlagItem[] mFlags;

    private static class FlagItem {
        public final ResReferenceValue ref;
        public final int flag;
        public String value;

        public FlagItem(ResReferenceValue ref, int flag) {
            this.ref = ref;
            this.flag = flag;
        }

        public String getValue() throws AndrolibException {
            if (value == null) {
                if (ref.referentIsNull()) {
                    return "@null";
                }
                value = ref.getReferent().getName();
            }
            return value;
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFloatValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResFloatValue extends ResScalarValue {
    private final float mValue;

    public ResFloatValue(float value, int rawIntValue, String rawValue) {
        super("float", rawIntValue, rawValue);
        this.mValue = value;
    }

    public float getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() {
        return String.valueOf(mValue);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFractionValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResFractionValue extends ResIntValue {
    public ResFractionValue(int value, String rawValue) {
        super(value, rawValue, "fraction");
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(TypedValue.TYPE_FRACTION, mValue);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIdValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResIdValue extends ResValue implements ResValuesXmlSerializable {
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        serializer.startTag(null, "item");
        serializer
                .attribute(null, "type", res.getResSpec().getType().getName());
        serializer.attribute(null, "name", res.getResSpec().getName());
        serializer.endTag(null, "item");
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIntBasedValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

/**
 * @author Matt Mastracci <matthew@mastracci.com>
 */
public class ResIntBasedValue extends ResValue {
    private final int mRawIntValue;

    protected ResIntBasedValue(int rawIntValue) {
        mRawIntValue = rawIntValue;
    }

    public int getRawIntValue() {
        return mRawIntValue;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIntValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResIntValue extends ResScalarValue {
    protected final int mValue;
    private int type;

    public ResIntValue(int value, String rawValue, int type) {
        this(value, rawValue, "integer");
        this.type = type;
    }

    public ResIntValue(int value, String rawValue, String type) {
        super(type, value, rawValue);
        this.mValue = value;
    }

    public int getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(type, mValue);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResPluralsValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.Duo;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResPluralsValue extends ResBagValue implements
        ResValuesXmlSerializable {
    ResPluralsValue(ResReferenceValue parent,
                    Duo<Integer, ResScalarValue>[] items) {
        super(parent);

        mItems = new ResScalarValue[6];
        for (int i = 0; i < items.length; i++) {
            mItems[items[i].m1 - BAG_KEY_PLURALS_START] = items[i].m2;
        }
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        serializer.startTag(null, "plurals");
        serializer.attribute(null, "name", res.getResSpec().getName());
        for (int i = 0; i < mItems.length; i++) {
            ResScalarValue item = mItems[i];
            if (item == null) {
                continue;
            }

            serializer.startTag(null, "item");
            serializer.attribute(null, "quantity", QUANTITY_MAP[i]);
            serializer.text(ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(item.encodeAsResXmlNonEscapedItemValue()));
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, "plurals");
    }

    private final ResScalarValue[] mItems;

    public static final int BAG_KEY_PLURALS_START = 0x01000004;
    public static final int BAG_KEY_PLURALS_END = 0x01000009;
    private static final String[] QUANTITY_MAP = new String[] { "other", "zero", "one", "two", "few", "many" };
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResReferenceValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResSpec;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResReferenceValue extends ResIntValue {
    private final ResPackage mPackage;
    private final boolean mTheme;

    public ResReferenceValue(ResPackage package_, int value, String rawValue) {
        this(package_, value, rawValue, false);
    }

    public ResReferenceValue(ResPackage package_, int value, String rawValue,
                             boolean theme) {
        super(value, rawValue, "reference");
        mPackage = package_;
        mTheme = theme;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        if (isNull()) {
            return "@null";
        }

        ResResSpec spec = getReferent();
        if (spec == null) {
            return "@null";
        }
        boolean newId = spec.hasDefaultResource() && spec.getDefaultResource().getValue() instanceof ResIdValue;

        // generate the beginning to fix @android
        String mStart = (mTheme ? '?' : '@') + (newId ? "+" : "");

        return mStart + spec.getFullName(mPackage, mTheme && spec.getType().getName().equals("attr"));
    }

    public ResResSpec getReferent() throws AndrolibException {
        try {
            return mPackage.getResTable().getResSpec(getValue());
        } catch (UndefinedResObjectException ex) {
            return null;
        }
    }

    public boolean isNull() {
        return mValue == 0;
    }

    public boolean referentIsNull() throws AndrolibException {
        return getReferent() == null;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResScalarValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlEncodable;
import brut.androlib.res.xml.ResXmlEncoders;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public abstract class ResScalarValue extends ResIntBasedValue implements
        ResXmlEncodable, ResValuesXmlSerializable {
    protected final String mType;
    protected final String mRawValue;

    protected ResScalarValue(String type, int rawIntValue, String rawValue) {
        super(rawIntValue);
        mType = type;
        mRawValue = rawValue;
    }

    @Override
    public String encodeAsResXmlAttr() throws AndrolibException {
        if (mRawValue != null) {
            return mRawValue;
        }
        return encodeAsResXml();
    }

    public String encodeAsResXmlItemValue() throws AndrolibException {
        return encodeAsResXmlValue();
    }

    @Override
    public String encodeAsResXmlValue() throws AndrolibException {
        if (mRawValue != null) {
            return mRawValue;
        }
        return encodeAsResXml();
    }

    public String encodeAsResXmlNonEscapedItemValue() throws AndrolibException {
        return encodeAsResXmlValue().replace("&amp;", "&").replace("&lt;","<");
    }

    public boolean hasMultipleNonPositionalSubstitutions() throws AndrolibException {
        return ResXmlEncoders.hasMultipleNonPositionalSubstitutions(mRawValue);
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = res.getResSpec().getType().getName();
        boolean item = !"reference".equals(mType) && !type.equals(mType);

        String body = encodeAsResXmlValue();

        // check for resource reference
        if (!type.equalsIgnoreCase("color")) {
            if (body.contains("@")) {
                if (!res.getFilePath().contains("string")) {
                    item = true;
                }
            }
        }

        // Android does not allow values (false) for ids.xml anymore
        // https://issuetracker.google.com/issues/80475496
        // But it decodes as a ResBoolean, which makes no sense. So force it to empty
        if (type.equalsIgnoreCase("id") && !body.isEmpty()) {
            body = "";
        }

        // check for using attrib as node or item
        String tagName = item ? "item" : type;

        serializer.startTag(null, tagName);
        if (item) {
            serializer.attribute(null, "type", type);
        }
        serializer.attribute(null, "name", res.getResSpec().getName());

        serializeExtraXmlAttrs(serializer, res);

        if (!body.isEmpty()) {
            serializer.ignorableWhitespace(body);
        }

        serializer.endTag(null, tagName);
    }

    public String getType() {
        return mType;
    }

    protected void serializeExtraXmlAttrs(XmlSerializer serializer,
                                          ResResource res) throws IOException {
    }

    protected abstract String encodeAsResXml() throws AndrolibException;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResStringValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResXmlEncoders;
import java.io.IOException;
import java.util.regex.Pattern;

import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResStringValue extends ResScalarValue {

    public ResStringValue(String value, int rawValue) {
        this(value, rawValue, "string");
    }

    public ResStringValue(String value, int rawValue, String type) {
        super(type, rawValue, value);
    }

    @Override
    public String encodeAsResXmlAttr() {
        return checkIfStringIsNumeric(ResXmlEncoders.encodeAsResXmlAttr(mRawValue));
    }

    @Override
    public String encodeAsResXmlItemValue() {
        return ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(ResXmlEncoders.encodeAsXmlValue(mRawValue));
    }

    @Override
    public String encodeAsResXmlValue() {
        return ResXmlEncoders.encodeAsXmlValue(mRawValue);
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void serializeExtraXmlAttrs(XmlSerializer serializer, ResResource res) throws IOException {
        if (ResXmlEncoders.hasMultipleNonPositionalSubstitutions(mRawValue)) {
            serializer.attribute(null, "formatted", "false");
        }
    }

    private String checkIfStringIsNumeric(String val) {
        if (val == null || val.isEmpty()) {
            return val;
        }
        return allDigits.matcher(val).matches() ? "\\ " + val : val;
    }

    private static final Pattern allDigits = Pattern.compile("\\d{9,}");
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResStyleValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResStyleValue extends ResBagValue implements
        ResValuesXmlSerializable {
    ResStyleValue(ResReferenceValue parent,
                  Duo<Integer, ResScalarValue>[] items, ResValueFactory factory) {
        super(parent);

        mItems = new Duo[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = new Duo<ResReferenceValue, ResScalarValue>(
                    factory.newReference(items[i].m1, null), items[i].m2);
        }
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        serializer.startTag(null, "style");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (!mParent.isNull() && !mParent.referentIsNull()) {
            serializer.attribute(null, "parent", mParent.encodeAsResXmlAttr());
        } else if (res.getResSpec().getName().indexOf('.') != -1) {
            serializer.attribute(null, "parent", "");
        }
        for (int i = 0; i < mItems.length; i++) {
            ResResSpec spec = mItems[i].m1.getReferent();

            if (spec == null) {
                LOGGER.fine(String.format("null reference: m1=0x%08x(%s), m2=0x%08x(%s)",
                        mItems[i].m1.getRawIntValue(), mItems[i].m1.getType(), mItems[i].m2.getRawIntValue(), mItems[i].m2.getType()));
                continue;
            }

            String name = null;
            String value = null;

            ResValue resource = spec.getDefaultResource().getValue();
            if (resource instanceof ResReferenceValue) {
                continue;
            } else if (resource instanceof ResAttr) {
                ResAttr attr = (ResAttr) resource;
                value = attr.convertToResXmlFormat(mItems[i].m2);
                name = spec.getFullName(res.getResSpec().getPackage(), true);
            } else {
                name = "@" + spec.getFullName(res.getResSpec().getPackage(), false);
            }

            if (value == null) {
                value = mItems[i].m2.encodeAsResXmlValue();
            }

            if (value == null) {
                continue;
            }

            serializer.startTag(null, "item");
            serializer.attribute(null, "name", name);
            serializer.text(value);
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, "style");
    }

    private final Duo<ResReferenceValue, ResScalarValue>[] mItems;

    private static final Logger LOGGER = Logger.getLogger(ResStyleValue.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResValue {

}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResValueFactory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTypeSpec;
import brut.util.Duo;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResValueFactory {
    private final ResPackage mPackage;

    public ResValueFactory(ResPackage package_) {
        this.mPackage = package_;
    }

    public ResScalarValue factory(int type, int value, String rawValue) throws AndrolibException {
        switch (type) {
            case TypedValue.TYPE_NULL:
                if (value == TypedValue.DATA_NULL_UNDEFINED) { // Special case $empty as explicitly defined empty value
                    return new ResStringValue(null, value);
                } else if (value == TypedValue.DATA_NULL_EMPTY) {
                    return new ResEmptyValue(value, rawValue, type);
                }
                return new ResReferenceValue(mPackage, 0, null);
            case TypedValue.TYPE_REFERENCE:
                return newReference(value, null);
            case TypedValue.TYPE_ATTRIBUTE:
            case TypedValue.TYPE_DYNAMIC_ATTRIBUTE:
                return newReference(value, rawValue, true);
            case TypedValue.TYPE_STRING:
                return new ResStringValue(rawValue, value);
            case TypedValue.TYPE_FLOAT:
                return new ResFloatValue(Float.intBitsToFloat(value), value, rawValue);
            case TypedValue.TYPE_DIMENSION:
                return new ResDimenValue(value, rawValue);
            case TypedValue.TYPE_FRACTION:
                return new ResFractionValue(value, rawValue);
            case TypedValue.TYPE_INT_BOOLEAN:
                return new ResBoolValue(value != 0, value, rawValue);
            case TypedValue.TYPE_DYNAMIC_REFERENCE:
                return newReference(value, rawValue);
        }

        if (type >= TypedValue.TYPE_FIRST_COLOR_INT && type <= TypedValue.TYPE_LAST_COLOR_INT) {
            return new ResColorValue(value, rawValue);
        }
        if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
            return new ResIntValue(value, rawValue, type);
        }

        throw new AndrolibException("Invalid value type: " + type);
    }

    public ResIntBasedValue factory(String value, int rawValue) {
        if (value == null) {
            return new ResFileValue("", rawValue);
        }
        if (value.startsWith("res/")) {
            return new ResFileValue(value, rawValue);
        }
        if (value.startsWith("r/") || value.startsWith("R/")) { //AndroResGuard
            return new ResFileValue(value, rawValue);
        }
        return new ResStringValue(value, rawValue);
    }

    public ResBagValue bagFactory(int parent, Duo<Integer, ResScalarValue>[] items, ResTypeSpec resTypeSpec) throws AndrolibException {
        ResReferenceValue parentVal = newReference(parent, null);

        if (items.length == 0) {
            return new ResBagValue(parentVal);
        }
        int key = items[0].m1;
        if (key == ResAttr.BAG_KEY_ATTR_TYPE) {
            return ResAttr.factory(parentVal, items, this, mPackage);
        }

        String resTypeName = resTypeSpec.getName();

        // Android O Preview added an unknown enum for c. This is hardcoded as 0 for now.
        if (ResTypeSpec.RES_TYPE_NAME_ARRAY.equals(resTypeName)
                || key == ResArrayValue.BAG_KEY_ARRAY_START || key == 0) {
            return new ResArrayValue(parentVal, items);
        }

        if (ResTypeSpec.RES_TYPE_NAME_PLURALS.equals(resTypeName) ||
                (key >= ResPluralsValue.BAG_KEY_PLURALS_START && key <= ResPluralsValue.BAG_KEY_PLURALS_END)) {
            return new ResPluralsValue(parentVal, items);
        }

        if (ResTypeSpec.RES_TYPE_NAME_STYLES.equals(resTypeName)) {
            return new ResStyleValue(parentVal, items, this);
        }

        if (ResTypeSpec.RES_TYPE_NAME_ATTR.equals(resTypeName)) {
            return new ResAttr(parentVal, 0, null, null, null);
        }

        throw new AndrolibException("unsupported res type name for bags. Found: " + resTypeName);
    }

    public ResReferenceValue newReference(int resID, String rawValue) {
        return newReference(resID, rawValue, false);
    }

    public ResReferenceValue newReference(int resID, String rawValue, boolean theme) {
        return new ResReferenceValue(mPackage, resID, rawValue, theme);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ARSCDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import android.util.TypedValue;
import brut.androlib.Androlib;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.*;
import brut.androlib.res.data.value.*;
import brut.util.Duo;
import brut.androlib.res.data.ResTable;
import brut.util.ExtDataInput;
import com.google.common.io.LittleEndianDataInputStream;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.logging.Logger;
import org.apache.commons.io.input.CountingInputStream;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ARSCDecoder {
    public static ARSCData decode(InputStream arscStream, boolean findFlagsOffsets, boolean keepBroken)
            throws AndrolibException {
        return decode(arscStream, findFlagsOffsets, keepBroken, new ResTable());
    }

    public static ARSCData decode(InputStream arscStream, boolean findFlagsOffsets, boolean keepBroken,
                                  ResTable resTable)
            throws AndrolibException {
        try {
            ARSCDecoder decoder = new ARSCDecoder(arscStream, resTable, findFlagsOffsets, keepBroken);
            ResPackage[] pkgs = decoder.readTableHeader();
            return new ARSCData(pkgs, decoder.mFlagsOffsets == null
                    ? null
                    : decoder.mFlagsOffsets.toArray(new FlagsOffset[0]), resTable);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode arsc file", ex);
        }
    }

    private ARSCDecoder(InputStream arscStream, ResTable resTable, boolean storeFlagsOffsets, boolean keepBroken) {
        arscStream = mCountIn = new CountingInputStream(arscStream);
        if (storeFlagsOffsets) {
            mFlagsOffsets = new ArrayList<FlagsOffset>();
        } else {
            mFlagsOffsets = null;
        }
        // We need to explicitly cast to DataInput as otherwise the constructor is ambiguous.
        // We choose DataInput instead of InputStream as ExtDataInput wraps an InputStream in
        // a DataInputStream which is big-endian and ignores the little-endian behavior.
        mIn = new ExtDataInput((DataInput) new LittleEndianDataInputStream(arscStream));
        mResTable = resTable;
        mKeepBroken = keepBroken;
    }

    private ResPackage[] readTableHeader() throws IOException, AndrolibException {
        nextChunkCheckType(Header.TYPE_TABLE);
        int packageCount = mIn.readInt();

        mTableStrings = StringBlock.read(mIn);
        ResPackage[] packages = new ResPackage[packageCount];

        nextChunk();
        for (int i = 0; i < packageCount; i++) {
            mTypeIdOffset = 0;
            packages[i] = readTablePackage();
        }
        return packages;
    }

    private ResPackage readTablePackage() throws IOException, AndrolibException {
        checkChunkType(Header.TYPE_PACKAGE);
        int id = mIn.readInt();

        if (id == 0) {
            // This means we are dealing with a Library Package, we should just temporarily
            // set the packageId to the next available id . This will be set at runtime regardless, but
            // for Apktool's use we need a non-zero packageId.
            // AOSP indicates 0x02 is next, as 0x01 is system and 0x7F is private.
            id = 2;
            if (mResTable.getPackageOriginal() == null && mResTable.getPackageRenamed() == null) {
                mResTable.setSharedLibrary(true);
            }
        }

        String name = mIn.readNullEndedString(128, true);
        /* typeStrings */mIn.skipInt();
        /* lastPublicType */mIn.skipInt();
        /* keyStrings */mIn.skipInt();
        /* lastPublicKey */mIn.skipInt();

        // TypeIdOffset was added platform_frameworks_base/@f90f2f8dc36e7243b85e0b6a7fd5a590893c827e
        // which is only in split/new applications.
        int splitHeaderSize = (2 + 2 + 4 + 4 + (2 * 128) + (4 * 5)); // short, short, int, int, char[128], int * 4
        if (mHeader.headerSize == splitHeaderSize) {
            mTypeIdOffset = mIn.readInt();
        }

        if (mTypeIdOffset > 0) {
            LOGGER.warning("Please report this application to Apktool for a fix: https://github.com/iBotPeaches/Apktool/issues/1728");
        }

        mTypeNames = StringBlock.read(mIn);
        mSpecNames = StringBlock.read(mIn);

        mResId = id << 24;
        mPkg = new ResPackage(mResTable, id, name);

        nextChunk();
        while (mHeader.type == Header.TYPE_LIBRARY) {
            readLibraryType();
        }

        while (mHeader.type == Header.TYPE_SPEC_TYPE) {
            readTableTypeSpec();
        }

        return mPkg;
    }

    private void readLibraryType() throws AndrolibException, IOException {
        checkChunkType(Header.TYPE_LIBRARY);
        int libraryCount = mIn.readInt();

        int packageId;
        String packageName;

        for (int i = 0; i < libraryCount; i++) {
            packageId = mIn.readInt();
            packageName = mIn.readNullEndedString(128, true);
            LOGGER.info(String.format("Decoding Shared Library (%s), pkgId: %d", packageName, packageId));
        }

        while(nextChunk().type == Header.TYPE_TYPE) {
            readTableTypeSpec();
        }
    }

    private void readTableTypeSpec() throws AndrolibException, IOException {
        mTypeSpec = readSingleTableTypeSpec();
        addTypeSpec(mTypeSpec);

        int type = nextChunk().type;
        ResTypeSpec resTypeSpec;

        while (type == Header.TYPE_SPEC_TYPE) {
            resTypeSpec = readSingleTableTypeSpec();
            addTypeSpec(resTypeSpec);
            type = nextChunk().type;

            // We've detected sparse resources, lets record this so we can rebuild in that same format (sparse/not)
            // with aapt2. aapt1 will ignore this.
            if (! mResTable.getSparseResources()) {
                mResTable.setSparseResources(true);
            }
        }

        while (type == Header.TYPE_TYPE) {
            readTableType();

            // skip "TYPE 8 chunks" and/or padding data at the end of this chunk
            if (mCountIn.getCount() < mHeader.endPosition) {
                LOGGER.warning("Unknown data detected. Skipping: " + (mHeader.endPosition - mCountIn.getCount()) + " byte(s)");
                mCountIn.skip(mHeader.endPosition - mCountIn.getCount());
            }

            type = nextChunk().type;

            addMissingResSpecs();
        }
    }

    private ResTypeSpec readSingleTableTypeSpec() throws AndrolibException, IOException {
        checkChunkType(Header.TYPE_SPEC_TYPE);
        int id = mIn.readUnsignedByte();
        mIn.skipBytes(3);
        int entryCount = mIn.readInt();

        if (mFlagsOffsets != null) {
            mFlagsOffsets.add(new FlagsOffset(mCountIn.getCount(), entryCount));
        }

		/* flags */mIn.skipBytes(entryCount * 4);
        mTypeSpec = new ResTypeSpec(mTypeNames.getString(id - 1), mResTable, mPkg, id, entryCount);
        mPkg.addType(mTypeSpec);
        return mTypeSpec;
    }

    private ResType readTableType() throws IOException, AndrolibException {
        checkChunkType(Header.TYPE_TYPE);
        int typeId = mIn.readUnsignedByte() - mTypeIdOffset;
        if (mResTypeSpecs.containsKey(typeId)) {
            mResId = (0xff000000 & mResId) | mResTypeSpecs.get(typeId).getId() << 16;
            mTypeSpec = mResTypeSpecs.get(typeId);
        }

        int typeFlags = mIn.readByte();
        /* reserved */mIn.skipBytes(2);
        int entryCount = mIn.readInt();
        int entriesStart = mIn.readInt();
        mMissingResSpecs = new boolean[entryCount];
        Arrays.fill(mMissingResSpecs, true);

        ResConfigFlags flags = readConfigFlags();
        int position = (mHeader.startPosition + entriesStart) - (entryCount * 4);

        // For some APKs there is a disconnect between the reported size of Configs
        // If we find a mismatch skip those bytes.
        if (position != mCountIn.getCount()) {
            LOGGER.warning("Invalid data detected. Skipping: " + (position - mCountIn.getCount()) + " byte(s)");
            mIn.skipBytes(position - mCountIn.getCount());
        }

        if (typeFlags == 1) {
            LOGGER.info("Sparse type flags detected: " + mTypeSpec.getName());
        }
        int[] entryOffsets = mIn.readIntArray(entryCount);

        if (flags.isInvalid) {
            String resName = mTypeSpec.getName() + flags.getQualifiers();
            if (mKeepBroken) {
                LOGGER.warning("Invalid config flags detected: " + resName);
            } else {
                LOGGER.warning("Invalid config flags detected. Dropping resources: " + resName);
            }
        }

        mType = flags.isInvalid && !mKeepBroken ? null : mPkg.getOrCreateConfig(flags);
        HashMap<Integer, EntryData> offsetsToEntryData = new HashMap<Integer, EntryData>();

        for (int offset : entryOffsets) {
            if (offset == -1 || offsetsToEntryData.containsKey(offset)) {
                continue;
            }

            offsetsToEntryData.put(offset, readEntryData());
        }

        for (int i = 0; i < entryOffsets.length; i++) {
            if (entryOffsets[i] != -1) {
                mMissingResSpecs[i] = false;
                mResId = (mResId & 0xffff0000) | i;
                EntryData entryData = offsetsToEntryData.get(entryOffsets[i]);
                readEntry(entryData);
            }
        }

        return mType;
    }


    private EntryData readEntryData() throws IOException, AndrolibException {
        short size = mIn.readShort();
        if (size < 0) {
            throw new AndrolibException("Entry size is under 0 bytes.");
        }

        short flags = mIn.readShort();
        int specNamesId = mIn.readInt();
        ResValue value = (flags & ENTRY_FLAG_COMPLEX) == 0 ? readValue() : readComplexEntry();
        EntryData entryData = new EntryData();
        entryData.mFlags = flags;
        entryData.mSpecNamesId = specNamesId;
        entryData.mValue = value;
        return entryData;
    }

    private void readEntry(EntryData entryData) throws AndrolibException {
        int specNamesId = entryData.mSpecNamesId;
        ResValue value = entryData.mValue;

        if (mTypeSpec.isString() && value instanceof ResFileValue) {
            value = new ResStringValue(value.toString(), ((ResFileValue) value).getRawIntValue());
        }
        if (mType == null) {
            return;
        }

        ResID resId = new ResID(mResId);
        ResResSpec spec;
        if (mPkg.hasResSpec(resId)) {
            spec = mPkg.getResSpec(resId);

            if (spec.isDummyResSpec()) {
                removeResSpec(spec);

                spec = new ResResSpec(resId, mSpecNames.getString(specNamesId), mPkg, mTypeSpec);
                mPkg.addResSpec(spec);
                mTypeSpec.addResSpec(spec);
            }
        } else {
            spec = new ResResSpec(resId, mSpecNames.getString(specNamesId), mPkg, mTypeSpec);
            mPkg.addResSpec(spec);
            mTypeSpec.addResSpec(spec);
        }
        ResResource res = new ResResource(mType, spec, value);

        try {
            mType.addResource(res);
            spec.addResource(res);
        } catch (AndrolibException ex) {
            if (mKeepBroken) {
                mType.addResource(res, true);
                spec.addResource(res, true);
                LOGGER.warning(String.format("Duplicate Resource Detected. Ignoring duplicate: %s", res.toString()));
            } else {
                throw ex;
            }
        }
        mPkg.addResource(res);
    }

    private ResBagValue readComplexEntry() throws IOException, AndrolibException {
        int parent = mIn.readInt();
        int count = mIn.readInt();

        ResValueFactory factory = mPkg.getValueFactory();
        Duo<Integer, ResScalarValue>[] items = new Duo[count];
        ResIntBasedValue resValue;
        int resId;

        for (int i = 0; i < count; i++) {
            resId = mIn.readInt();
            resValue = readValue();

            if (resValue instanceof ResScalarValue) {
                items[i] = new Duo<Integer, ResScalarValue>(resId, (ResScalarValue) resValue);
            } else {
                resValue = new ResStringValue(resValue.toString(), resValue.getRawIntValue());
                items[i] = new Duo<Integer, ResScalarValue>(resId, (ResScalarValue) resValue);
            }
        }

        return factory.bagFactory(parent, items, mTypeSpec);
    }

    private ResIntBasedValue readValue() throws IOException, AndrolibException {
		/* size */mIn.skipCheckShort((short) 8);
		/* zero */mIn.skipCheckByte((byte) 0);
        byte type = mIn.readByte();
        int data = mIn.readInt();

        return type == TypedValue.TYPE_STRING
                ? mPkg.getValueFactory().factory(mTableStrings.getHTML(data), data)
                : mPkg.getValueFactory().factory(type, data, null);
    }

    private ResConfigFlags readConfigFlags() throws IOException, AndrolibException {
        int size = mIn.readInt();
        int read = 28;

        if (size < 28) {
            throw new AndrolibException("Config size < 28");
        }

        boolean isInvalid = false;

        short mcc = mIn.readShort();
        short mnc = mIn.readShort();

        char[] language = this.unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), 'a');
        char[] country = this.unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), '0');

        byte orientation = mIn.readByte();
        byte touchscreen = mIn.readByte();

        int density = mIn.readUnsignedShort();

        byte keyboard = mIn.readByte();
        byte navigation = mIn.readByte();
        byte inputFlags = mIn.readByte();
		/* inputPad0 */mIn.skipBytes(1);

        short screenWidth = mIn.readShort();
        short screenHeight = mIn.readShort();

        short sdkVersion = mIn.readShort();
		/* minorVersion, now must always be 0 */mIn.skipBytes(2);

        byte screenLayout = 0;
        byte uiMode = 0;
        short smallestScreenWidthDp = 0;
        if (size >= 32) {
            screenLayout = mIn.readByte();
            uiMode = mIn.readByte();
            smallestScreenWidthDp = mIn.readShort();
            read = 32;
        }

        short screenWidthDp = 0;
        short screenHeightDp = 0;
        if (size >= 36) {
            screenWidthDp = mIn.readShort();
            screenHeightDp = mIn.readShort();
            read = 36;
        }

        char[] localeScript = null;
        char[] localeVariant = null;
        if (size >= 48) {
            localeScript = readScriptOrVariantChar(4).toCharArray();
            localeVariant = readScriptOrVariantChar(8).toCharArray();
            read = 48;
        }

        byte screenLayout2 = 0;
        byte colorMode = 0;
        if (size >= 52) {
            screenLayout2 = mIn.readByte();
            colorMode = mIn.readByte();
            mIn.skipBytes(2); // reserved padding
            read = 52;
        }

        if (size >= 56) {
            mIn.skipBytes(4);
            read = 56;
        }

        int exceedingSize = size - KNOWN_CONFIG_BYTES;
        if (exceedingSize > 0) {
            byte[] buf = new byte[exceedingSize];
            read += exceedingSize;
            mIn.readFully(buf);
            BigInteger exceedingBI = new BigInteger(1, buf);

            if (exceedingBI.equals(BigInteger.ZERO)) {
                LOGGER.fine(String
                        .format("Config flags size > %d, but exceeding bytes are all zero, so it should be ok.",
                                KNOWN_CONFIG_BYTES));
            } else {
                LOGGER.warning(String.format("Config flags size > %d. Size = %d. Exceeding bytes: 0x%X.",
                        KNOWN_CONFIG_BYTES, size, exceedingBI));
                isInvalid = true;
            }
        }

        int remainingSize = size - read;
        if (remainingSize > 0) {
            mIn.skipBytes(remainingSize);
        }

        return new ResConfigFlags(mcc, mnc, language, country,
                orientation, touchscreen, density, keyboard, navigation,
                inputFlags, screenWidth, screenHeight, sdkVersion,
                screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,
                screenHeightDp, localeScript, localeVariant, screenLayout2,
                colorMode, isInvalid, size);
    }

    private char[] unpackLanguageOrRegion(byte in0, byte in1, char base) throws AndrolibException {
        // check high bit, if so we have a packed 3 letter code
        if (((in0 >> 7) & 1) == 1) {
            int first = in1 & 0x1F;
            int second = ((in1 & 0xE0) >> 5) + ((in0 & 0x03) << 3);
            int third = (in0 & 0x7C) >> 2;

            // since this function handles languages & regions, we add the value(s) to the base char
            // which is usually 'a' or '0' depending on language or region.
            return new char[] { (char) (first + base), (char) (second + base), (char) (third + base) };
        }
        return new char[] { (char) in0, (char) in1 };
    }

    private String readScriptOrVariantChar(int length) throws AndrolibException, IOException {
        StringBuilder string = new StringBuilder(16);

        while(length-- != 0) {
            short ch = mIn.readByte();
            if (ch == 0) {
                break;
            }
            string.append((char) ch);
        }
        mIn.skipBytes(length);

        return string.toString();
    }

    private void addTypeSpec(ResTypeSpec resTypeSpec) {
        mResTypeSpecs.put(resTypeSpec.getId(), resTypeSpec);
    }

    private void addMissingResSpecs() throws AndrolibException {
        int resId = mResId & 0xffff0000;

        for (int i = 0; i < mMissingResSpecs.length; i++) {
            if (!mMissingResSpecs[i]) {
                continue;
            }

            ResResSpec spec = new ResResSpec(new ResID(resId | i), "APKTOOL_DUMMY_" + Integer.toHexString(i), mPkg, mTypeSpec);

            // If we already have this resID dont add it again.
            if (! mPkg.hasResSpec(new ResID(resId | i))) {
                mPkg.addResSpec(spec);
                mTypeSpec.addResSpec(spec);

                if (mType == null) {
                    mType = mPkg.getOrCreateConfig(new ResConfigFlags());
                }

                // We are going to make dummy attributes a null reference (@null) now instead of a boolean false.
                // This is because aapt2 is much more strict when it comes to what we can put in an application.
                ResValue value = new ResReferenceValue(mPkg, 0, "");

                ResResource res = new ResResource(mType, spec, value);
                mPkg.addResource(res);
                mType.addResource(res);
                spec.addResource(res);
            }
        }
    }

    private void removeResSpec(ResResSpec spec) throws AndrolibException {
        if (mPkg.hasResSpec(spec.getId())) {
            mPkg.removeResSpec(spec);
            mTypeSpec.removeResSpec(spec);
        }
    }

    private Header nextChunk() throws IOException {
        return mHeader = Header.read(mIn, mCountIn);
    }

    private void checkChunkType(int expectedType) throws AndrolibException {
        if (mHeader.type != expectedType) {
            throw new AndrolibException(String.format("Invalid chunk type: expected=0x%08x, got=0x%08x",
                    expectedType, mHeader.type));
        }
    }

    private void nextChunkCheckType(int expectedType) throws IOException, AndrolibException {
        nextChunk();
        checkChunkType(expectedType);
    }

    private final ExtDataInput mIn;
    private final ResTable mResTable;
    private final CountingInputStream mCountIn;
    private final List<FlagsOffset> mFlagsOffsets;
    private final boolean mKeepBroken;

    private Header mHeader;
    private StringBlock mTableStrings;
    private StringBlock mTypeNames;
    private StringBlock mSpecNames;
    private ResPackage mPkg;
    private ResTypeSpec mTypeSpec;
    private ResType mType;
    private int mResId;
    private int mTypeIdOffset = 0;
    private boolean[] mMissingResSpecs;
    private HashMap<Integer, ResTypeSpec> mResTypeSpecs = new HashMap<>();

    private final static short ENTRY_FLAG_COMPLEX = 0x0001;
    private final static short ENTRY_FLAG_PUBLIC = 0x0002;
    private final static short ENTRY_FLAG_WEAK = 0x0004;

    public static class Header {
        public final short type;
        public final int headerSize;
        public final int chunkSize;
        public final int startPosition;
        public final int endPosition;

        public Header(short type, int headerSize, int chunkSize, int headerStart) {
            this.type = type;
            this.headerSize = headerSize;
            this.chunkSize = chunkSize;
            this.startPosition = headerStart;
            this.endPosition = headerStart + chunkSize;
        }

        public static Header read(ExtDataInput in, CountingInputStream countIn) throws IOException {
            short type;
            int start = countIn.getCount();
            try {
                type = in.readShort();
            } catch (EOFException ex) {
                return new Header(TYPE_NONE, 0, 0, countIn.getCount());
            }
            return new Header(type, in.readShort(), in.readInt(), start);
        }

        public final static short TYPE_NONE = -1, TYPE_TABLE = 0x0002,
                TYPE_PACKAGE = 0x0200, TYPE_TYPE = 0x0201, TYPE_SPEC_TYPE = 0x0202, TYPE_LIBRARY = 0x0203;
    }

    public static class FlagsOffset {
        public final int offset;
        public final int count;

        public FlagsOffset(int offset, int count) {
            this.offset = offset;
            this.count = count;
        }
    }

    private class EntryData {
        public short mFlags;
        public int mSpecNamesId;
        public ResValue mValue;
    }

    private static final Logger LOGGER = Logger.getLogger(ARSCDecoder.class.getName());
    private static final int KNOWN_CONFIG_BYTES = 56;

    public static class ARSCData {

        public ARSCData(ResPackage[] packages, FlagsOffset[] flagsOffsets, ResTable resTable) {
            mPackages = packages;
            mFlagsOffsets = flagsOffsets;
            mResTable = resTable;
        }

        public FlagsOffset[] getFlagsOffsets() {
            return mFlagsOffsets;
        }

        public ResPackage[] getPackages() {
            return mPackages;
        }

        public ResPackage getOnePackage() throws AndrolibException {
            if (mPackages.length <= 0) {
                throw new AndrolibException("Arsc file contains zero packages");
            } else if (mPackages.length != 1) {
                int id = findPackageWithMostResSpecs();
                LOGGER.info("Arsc file contains multiple packages. Using package "
                        + mPackages[id].getName() + " as default.");

                return mPackages[id];
            }
            return mPackages[0];
        }

        public int findPackageWithMostResSpecs() {
            int count = mPackages[0].getResSpecCount();
            int id = 0;

            for (int i = 0; i < mPackages.length; i++) {
                if (mPackages[i].getResSpecCount() >= count) {
                    count = mPackages[i].getResSpecCount();
                    id = i;
                }
            }
            return id;
        }

        public ResTable getResTable() {
            return mResTable;
        }

        private final ResPackage[] mPackages;
        private final FlagsOffset[] mFlagsOffsets;
        private final ResTable mResTable;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/AXmlResourceParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import android.content.res.XmlResourceParser;
import android.util.TypedValue;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResID;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.ExtDataInput;
import com.google.common.io.LittleEndianDataInputStream;
import java.io.DataInput;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.xmlpull.v1.XmlPullParserException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 * @author Dmitry Skiba
 *
 *         Binary xml files parser.
 *
 *         Parser has only two states: (1) Operational state, which parser
 *         obtains after first successful call to next() and retains until
 *         open(), close(), or failed call to next(). (2) Closed state, which
 *         parser obtains after open(), close(), or failed call to next(). In
 *         this state methods return invalid values or throw exceptions.
 *
 *         TODO: * check all methods in closed state
 *
 */
public class AXmlResourceParser implements XmlResourceParser {

    public AXmlResourceParser() {
        resetEventInfo();
    }

    public AXmlResourceParser(InputStream stream) {
        this();
        open(stream);
    }

    public AndrolibException getFirstError() {
        return mFirstError;
    }

    public ResAttrDecoder getAttrDecoder() {
        return mAttrDecoder;
    }

    public void setAttrDecoder(ResAttrDecoder attrDecoder) {
        mAttrDecoder = attrDecoder;
    }

    public void open(InputStream stream) {
        close();
        if (stream != null) {
            // We need to explicitly cast to DataInput as otherwise the constructor is ambiguous.
            // We choose DataInput instead of InputStream as ExtDataInput wraps an InputStream in
            // a DataInputStream which is big-endian and ignores the little-endian behavior.
            m_reader = new ExtDataInput((DataInput) new LittleEndianDataInputStream(stream));
        }
    }

    @Override
    public void close() {
        if (!m_operational) {
            return;
        }
        m_operational = false;
        m_reader = null;
        m_strings = null;
        m_resourceIDs = null;
        m_namespaces.reset();
        resetEventInfo();
    }

    // ///////////////////////////////// iteration
    @Override
    public int next() throws XmlPullParserException, IOException {
        if (m_reader == null) {
            throw new XmlPullParserException("Parser is not opened.", this, null);
        }
        try {
            doNext();
            return m_event;
        } catch (IOException e) {
            close();
            throw e;
        }
    }

    @Override
    public int nextToken() throws XmlPullParserException, IOException {
        return next();
    }

    @Override
    public int nextTag() throws XmlPullParserException, IOException {
        int eventType = next();
        if (eventType == TEXT && isWhitespace()) {
            eventType = next();
        }
        if (eventType != START_TAG && eventType != END_TAG) {
            throw new XmlPullParserException("Expected start or end tag.", this, null);
        }
        return eventType;
    }

    @Override
    public String nextText() throws XmlPullParserException, IOException {
        if (getEventType() != START_TAG) {
            throw new XmlPullParserException("Parser must be on START_TAG to read next text.", this, null);
        }
        int eventType = next();
        if (eventType == TEXT) {
            String result = getText();
            eventType = next();
            if (eventType != END_TAG) {
                throw new XmlPullParserException("Event TEXT must be immediately followed by END_TAG.", this, null);
            }
            return result;
        } else if (eventType == END_TAG) {
            return "";
        } else {
            throw new XmlPullParserException("Parser must be on START_TAG or TEXT to read text.", this, null);
        }
    }

    @Override
    public void require(int type, String namespace, String name)
            throws XmlPullParserException, IOException {
        if (type != getEventType() || (namespace != null && !namespace.equals(getNamespace()))
                || (name != null && !name.equals(getName()))) {
            throw new XmlPullParserException(TYPES[type] + " is expected.", this, null);
        }
    }

    @Override
    public int getDepth() {
        return m_namespaces.getDepth() - 1;
    }

    @Override
    public int getEventType() throws XmlPullParserException {
        return m_event;
    }

    @Override
    public int getLineNumber() {
        return m_lineNumber;
    }

    @Override
    public String getName() {
        if (m_name == -1 || (m_event != START_TAG && m_event != END_TAG)) {
            return null;
        }
        return m_strings.getString(m_name);
    }

    @Override
    public String getText() {
        if (m_name == -1 || m_event != TEXT) {
            return null;
        }
        return m_strings.getString(m_name);
    }

    @Override
    public char[] getTextCharacters(int[] holderForStartAndLength) {
        String text = getText();
        if (text == null) {
            return null;
        }
        holderForStartAndLength[0] = 0;
        holderForStartAndLength[1] = text.length();
        char[] chars = new char[text.length()];
        text.getChars(0, text.length(), chars, 0);
        return chars;
    }

    @Override
    public String getNamespace() {
        return m_strings.getString(m_namespaceUri);
    }

    @Override
    public String getPrefix() {
        int prefix = m_namespaces.findPrefix(m_namespaceUri);
        return m_strings.getString(prefix);
    }

    @Override
    public String getPositionDescription() {
        return "XML line #" + getLineNumber();
    }

    @Override
    public int getNamespaceCount(int depth) throws XmlPullParserException {
        return m_namespaces.getAccumulatedCount(depth);
    }

    @Override
    public String getNamespacePrefix(int pos) throws XmlPullParserException {
        int prefix = m_namespaces.getPrefix(pos);
        return m_strings.getString(prefix);
    }

    @Override
    public String getNamespaceUri(int pos) throws XmlPullParserException {
        int uri = m_namespaces.getUri(pos);
        return m_strings.getString(uri);
    }

    // ///////////////////////////////// attributes
    @Override
    public String getClassAttribute() {
        if (m_classAttribute == -1) {
            return null;
        }
        int offset = getAttributeOffset(m_classAttribute);
        int value = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];
        return m_strings.getString(value);
    }

    @Override
    public String getIdAttribute() {
        if (m_idAttribute == -1) {
            return null;
        }
        int offset = getAttributeOffset(m_idAttribute);
        int value = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];
        return m_strings.getString(value);
    }

    @Override
    public int getIdAttributeResourceValue(int defaultValue) {
        if (m_idAttribute == -1) {
            return defaultValue;
        }
        int offset = getAttributeOffset(m_idAttribute);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType != TypedValue.TYPE_REFERENCE) {
            return defaultValue;
        }
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public int getStyleAttribute() {
        if (m_styleAttribute == -1) {
            return 0;
        }
        int offset = getAttributeOffset(m_styleAttribute);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public int getAttributeCount() {
        if (m_event != START_TAG) {
            return -1;
        }
        return m_attributes.length / ATTRIBUTE_LENGTH;
    }

    @Override
    public String getAttributeNamespace(int index) {
        int offset = getAttributeOffset(index);
        int namespace = m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI];
        if (namespace == -1) {
            return "";
        }

        // Minifiers like removing the namespace, so we will default to default namespace
        // unless the pkgId of the resource is private. We will grab the non-standard one.
        String value = m_strings.getString(namespace);

        if (value.length() == 0) {
            ResID resourceId = new ResID(getAttributeNameResource(index));
            if (resourceId.package_ == PRIVATE_PKG_ID) {
                value = getNonDefaultNamespaceUri(offset);
            } else {
                value = android_ns;
            }
        }

        return value;
    }

    private String getNonDefaultNamespaceUri(int offset) {
        String prefix = m_strings.getString(m_namespaces.getPrefix(offset));
        if (prefix != null) {
            return  m_strings.getString(m_namespaces.getUri(offset));
        }

        // If we are here. There is some clever obfuscation going on. Our reference points to the namespace are gone.
        // Normally we could take the index * attributeCount to get an offset.
        // That would point to the URI in the StringBlock table, but that is empty.
        // We have the namespaces that can't be touched in the opening tag.
        // Though no known way to correlate them at this time.
        // So return the res-auto namespace.
        return "http://schemas.android.com/apk/res-auto";
    }

    @Override
    public String getAttributePrefix(int index) {
        int offset = getAttributeOffset(index);
        int uri = m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI];
        int prefix = m_namespaces.findPrefix(uri);
        if (prefix == -1) {
            return "";
        }
        return m_strings.getString(prefix);
    }

    @Override
    public String getAttributeName(int index) {
        int offset = getAttributeOffset(index);
        int name = m_attributes[offset + ATTRIBUTE_IX_NAME];
        if (name == -1) {
            return "";
        }

        String value = m_strings.getString(name);

        // some attributes will return "", we must rely on the resource_id and refer to the frameworks
        // to match the resource id to the name. ex: 0x101021C = versionName
        if (value.length() == 0 || android_ns.equals(getAttributeNamespace(index))) {
            try {
                int resourceId = getAttributeNameResource(index);
                if (resourceId != 0) {
                    value = mAttrDecoder.decodeManifestAttr(getAttributeNameResource(index));
                }
            } catch (AndrolibException | NullPointerException e) { }
        } else {
            if (m_resourceIDs!=null&&m_resourceIDs.length > name){
                int resourceID = m_resourceIDs[name];
                if (resourceID >> 24 == 0x7f){
                    try {
//                        Pattern pattern = Pattern.compile("[a-z_][a-z0-9_]*");
                        boolean isValidate = true;//todo moving isValidResourceEntryName to here
                        ResResSpec resResource = null;
                        ResResSpec spec = mAttrDecoder.getCurrentPackage().getResTable().getResSpec(resourceID);
                        if (isValidate){
                            for (ResResource resource : mAttrDecoder.getCurrentPackage().listFiles()) {
                                if (resource.getResSpec().getType().getId() == spec.getType().getId() &&
                                        resource.getResSpec().getName().equals(value)
                                ){
                                    resResource = resource.getResSpec();
                                    break;
                                }
                            }
                            if (resResource == null
                                    && spec.getName().contains("_apktool_") //only processing generated by apktool
                            ){
                                System.out.println(String.format("Axml deobfuscate: Attr Mapping from: %s to to:%s.", spec.getName(), value));
//                                spec.setName(value);
                            }
                        }
                        return spec.getName();
                    }catch (Exception e){ }
                }
            }
        }
        return value;
    }

    @Override
    public int getAttributeNameResource(int index) {
        int offset = getAttributeOffset(index);
        int name = m_attributes[offset + ATTRIBUTE_IX_NAME];
        if (m_resourceIDs == null || name < 0 || name >= m_resourceIDs.length) {
            return 0;
        }
        return m_resourceIDs[name];
    }

    @Override
    public int getAttributeValueType(int index) {
        int offset = getAttributeOffset(index);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
    }

    @Override
    public int getAttributeValueData(int index) {
        int offset = getAttributeOffset(index);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public String getAttributeValue(int index) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        int valueData = m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        int valueRaw = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];

        if (mAttrDecoder != null) {
            try {
                return mAttrDecoder.decode(
                        valueType,
                        valueData,
                        valueRaw == -1 ? null : ResXmlEncoders.escapeXmlChars(m_strings.getString(valueRaw)),
                        getAttributeNameResource(index));
            } catch (AndrolibException ex) {
                setFirstError(ex);
                LOGGER.log(Level.WARNING, String.format("Could not decode attr value, using undecoded value "
                                + "instead: ns=%s, name=%s, value=0x%08x",
                        getAttributePrefix(index),
                        getAttributeName(index),
                        valueData), ex);
            }
        }
        return TypedValue.coerceToString(valueType, valueData);
    }

    @Override
    public boolean getAttributeBooleanValue(int index, boolean defaultValue) {
        return getAttributeIntValue(index, defaultValue ? 1 : 0) != 0;
    }

    @Override
    public float getAttributeFloatValue(int index, float defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType == TypedValue.TYPE_FLOAT) {
            int valueData = m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
            return Float.intBitsToFloat(valueData);
        }
        return defaultValue;
    }

    @Override
    public int getAttributeIntValue(int index, int defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType >= TypedValue.TYPE_FIRST_INT && valueType <= TypedValue.TYPE_LAST_INT) {
            return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        }
        return defaultValue;
    }

    @Override
    public int getAttributeUnsignedIntValue(int index, int defaultValue) {
        return getAttributeIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeResourceValue(int index, int defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType == TypedValue.TYPE_REFERENCE) {
            return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        }
        return defaultValue;
    }

    @Override
    public String getAttributeValue(String namespace, String attribute) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return "";
        }
        return getAttributeValue(index);
    }

    @Override
    public boolean getAttributeBooleanValue(String namespace, String attribute, boolean defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeBooleanValue(index, defaultValue);
    }

    @Override
    public float getAttributeFloatValue(String namespace, String attribute, float defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeFloatValue(index, defaultValue);
    }

    @Override
    public int getAttributeIntValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeUnsignedIntValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeUnsignedIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeResourceValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeResourceValue(index, defaultValue);
    }

    @Override
    public int getAttributeListValue(int index, String[] options, int defaultValue) {
        // TODO implement
        return 0;
    }

    @Override
    public int getAttributeListValue(String namespace, String attribute, String[] options, int defaultValue) {
        // TODO implement
        return 0;
    }

    @Override
    public String getAttributeType(int index) {
        return "CDATA";
    }

    @Override
    public boolean isAttributeDefault(int index) {
        return false;
    }

    // ///////////////////////////////// dummies
    @Override
    public void setInput(InputStream stream, String inputEncoding)
            throws XmlPullParserException {
        open(stream);
    }

    @Override
    public void setInput(Reader reader) throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public String getInputEncoding() {
        return null;
    }

    @Override
    public int getColumnNumber() {
        return -1;
    }

    @Override
    public boolean isEmptyElementTag() throws XmlPullParserException {
        return false;
    }

    @Override
    public boolean isWhitespace() throws XmlPullParserException {
        return false;
    }

    @Override
    public void defineEntityReplacementText(String entityName, String replacementText)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public String getNamespace(String prefix) {
        throw new RuntimeException(E_NOT_SUPPORTED);
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    @Override
    public void setProperty(String name, Object value)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public boolean getFeature(String feature) {
        return false;
    }

    @Override
    public void setFeature(String name, boolean value)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    // /////////////////////////////////////////// implementation
    /**
     * Namespace stack, holds prefix+uri pairs, as well as depth information.
     * All information is stored in one int[] array. Array consists of depth
     * frames: Data=DepthFrame*; DepthFrame=Count+[Prefix+Uri]*+Count;
     * Count='count of Prefix+Uri pairs'; Yes, count is stored twice, to enable
     * bottom-up traversal. increaseDepth adds depth frame, decreaseDepth
     * removes it. push/pop operations operate only in current depth frame.
     * decreaseDepth removes any remaining (not pop'ed) namespace pairs. findXXX
     * methods search all depth frames starting from the last namespace pair of
     * current depth frame. All functions that operate with int, use -1 as
     * 'invalid value'.
     *
     * !! functions expect 'prefix'+'uri' pairs, not 'uri'+'prefix' !!
     *
     */
    private static final class NamespaceStack {

        public NamespaceStack() {
            m_data = new int[32];
        }

        public final void reset() {
            m_dataLength = 0;
            m_count = 0;
            m_depth = 0;
        }

        public final int getTotalCount() {
            return m_count;
        }

        public final int getCurrentCount() {
            if (m_dataLength == 0) {
                return 0;
            }
            int offset = m_dataLength - 1;
            return m_data[offset];
        }

        public final int getAccumulatedCount(int depth) {
            if (m_dataLength == 0 || depth < 0) {
                return 0;
            }
            if (depth > m_depth) {
                depth = m_depth;
            }
            int accumulatedCount = 0;
            int offset = 0;
            for (; depth != 0; --depth) {
                int count = m_data[offset];
                accumulatedCount += count;
                offset += (2 + count * 2);
            }
            return accumulatedCount;
        }

        public final void push(int prefix, int uri) {
            if (m_depth == 0) {
                increaseDepth();
            }
            ensureDataCapacity(2);
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            m_data[offset - 1 - count * 2] = count + 1;
            m_data[offset] = prefix;
            m_data[offset + 1] = uri;
            m_data[offset + 2] = count + 1;
            m_dataLength += 2;
            m_count += 1;
        }

        public final boolean pop(int prefix, int uri) {
            if (m_dataLength == 0) {
                return false;
            }
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            for (int i = 0, o = offset - 2; i != count; ++i, o -= 2) {
                if (m_data[o] != prefix || m_data[o + 1] != uri) {
                    continue;
                }
                count -= 1;
                if (i == 0) {
                    m_data[o] = count;
                    o -= (1 + count * 2);
                    m_data[o] = count;
                } else {
                    m_data[offset] = count;
                    offset -= (1 + 2 + count * 2);
                    m_data[offset] = count;
                    System.arraycopy(m_data, o + 2, m_data, o, m_dataLength - o);
                }
                m_dataLength -= 2;
                m_count -= 1;
                return true;
            }
            return false;
        }

        public final boolean pop() {
            if (m_dataLength == 0) {
                return false;
            }
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            if (count == 0) {
                return false;
            }
            count -= 1;
            offset -= 2;
            m_data[offset] = count;
            offset -= (1 + count * 2);
            m_data[offset] = count;
            m_dataLength -= 2;
            m_count -= 1;
            return true;
        }

        public final int getPrefix(int index) {
            return get(index, true);
        }

        public final int getUri(int index) {
            return get(index, false);
        }

        public final int findPrefix(int uri) {
            return find(uri, false);
        }

        public final int findUri(int prefix) {
            return find(prefix, true);
        }

        public final int getDepth() {
            return m_depth;
        }

        public final void increaseDepth() {
            ensureDataCapacity(2);
            int offset = m_dataLength;
            m_data[offset] = 0;
            m_data[offset + 1] = 0;
            m_dataLength += 2;
            m_depth += 1;
        }

        public final void decreaseDepth() {
            if (m_dataLength == 0) {
                return;
            }
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            if ((offset - 1 - count * 2) == 0) {
                return;
            }
            m_dataLength -= 2 + count * 2;
            m_count -= count;
            m_depth -= 1;
        }

        private void ensureDataCapacity(int capacity) {
            int available = (m_data.length - m_dataLength);
            if (available > capacity) {
                return;
            }
            int newLength = (m_data.length + available) * 2;
            int[] newData = new int[newLength];
            System.arraycopy(m_data, 0, newData, 0, m_dataLength);
            m_data = newData;
        }

        private final int find(int prefixOrUri, boolean prefix) {
            if (m_dataLength == 0) {
                return -1;
            }
            int offset = m_dataLength - 1;
            for (int i = m_depth; i != 0; --i) {
                int count = m_data[offset];
                offset -= 2;
                for (; count != 0; --count) {
                    if (prefix) {
                        if (m_data[offset] == prefixOrUri) {
                            return m_data[offset + 1];
                        }
                    } else {
                        if (m_data[offset + 1] == prefixOrUri) {
                            return m_data[offset];
                        }
                    }
                    offset -= 2;
                }
            }
            return -1;
        }

        private final int get(int index, boolean prefix) {
            if (m_dataLength == 0 || index < 0) {
                return -1;
            }
            int offset = 0;
            for (int i = m_depth; i != 0; --i) {
                int count = m_data[offset];
                if (index >= count) {
                    index -= count;
                    offset += (2 + count * 2);
                    continue;
                }
                offset += (1 + index * 2);
                if (!prefix) {
                    offset += 1;
                }
                return m_data[offset];
            }
            return -1;
        }

        private int[] m_data;
        private int m_dataLength;
        private int m_count;
        private int m_depth;
    }

    final StringBlock getStrings() {
        return m_strings;
    }

    private final int getAttributeOffset(int index) {
        if (m_event != START_TAG) {
            throw new IndexOutOfBoundsException("Current event is not START_TAG.");
        }
        int offset = index * ATTRIBUTE_LENGTH;
        if (offset >= m_attributes.length) {
            throw new IndexOutOfBoundsException("Invalid attribute index (" + index + ").");
        }
        return offset;
    }

    private final int findAttribute(String namespace, String attribute) {
        if (m_strings == null || attribute == null) {
            return -1;
        }
        int name = m_strings.find(attribute);
        if (name == -1) {
            return -1;
        }
        int uri = (namespace != null) ? m_strings.find(namespace) : -1;
        for (int o = 0; o != m_attributes.length; o += ATTRIBUTE_LENGTH) {
            if (name == m_attributes[o + ATTRIBUTE_IX_NAME]
                    && (uri == -1 || uri == m_attributes[o + ATTRIBUTE_IX_NAMESPACE_URI])) {
                return o / ATTRIBUTE_LENGTH;
            }
        }
        return -1;
    }

    private final void resetEventInfo() {
        m_event = -1;
        m_lineNumber = -1;
        m_name = -1;
        m_namespaceUri = -1;
        m_attributes = null;
        m_idAttribute = -1;
        m_classAttribute = -1;
        m_styleAttribute = -1;
    }

    private final void doNext() throws IOException {
        // Delayed initialization.
        if (m_strings == null) {
            m_reader.skipCheckInt(CHUNK_AXML_FILE, CHUNK_AXML_FILE_BROKEN);

			/*
			 * chunkSize
			 */
            m_reader.skipInt();
            m_strings = StringBlock.read(m_reader);
            m_namespaces.increaseDepth();
            m_operational = true;
        }

        if (m_event == END_DOCUMENT) {
            return;
        }

        int event = m_event;
        resetEventInfo();

        while (true) {
            if (m_decreaseDepth) {
                m_decreaseDepth = false;
                m_namespaces.decreaseDepth();
            }

            // Fake END_DOCUMENT event.
            if (event == END_TAG && m_namespaces.getDepth() == 1 && m_namespaces.getCurrentCount() == 0) {
                m_event = END_DOCUMENT;
                break;
            }

            int chunkType;
            if (event == START_DOCUMENT) {
                // Fake event, see CHUNK_XML_START_TAG handler.
                chunkType = CHUNK_XML_START_TAG;
            } else {
                chunkType = m_reader.readInt();
            }

            if (chunkType == CHUNK_RESOURCEIDS) {
                int chunkSize = m_reader.readInt();
                if (chunkSize < 8 || (chunkSize % 4) != 0) {
                    throw new IOException("Invalid resource ids size (" + chunkSize + ").");
                }
                m_resourceIDs = m_reader.readIntArray(chunkSize / 4 - 2);
                continue;
            }

            if (chunkType < CHUNK_XML_FIRST || chunkType > CHUNK_XML_LAST) {
                throw new IOException("Invalid chunk type (" + chunkType + ").");
            }

            // Fake START_DOCUMENT event.
            if (chunkType == CHUNK_XML_START_TAG && event == -1) {
                m_event = START_DOCUMENT;
                break;
            }

            // Common header.
			/* chunkSize */m_reader.skipInt();
            int lineNumber = m_reader.readInt();
			/* 0xFFFFFFFF */m_reader.skipInt();

            if (chunkType == CHUNK_XML_START_NAMESPACE || chunkType == CHUNK_XML_END_NAMESPACE) {
                if (chunkType == CHUNK_XML_START_NAMESPACE) {
                    int prefix = m_reader.readInt();
                    int uri = m_reader.readInt();
                    m_namespaces.push(prefix, uri);
                } else {
					/* prefix */m_reader.skipInt();
					/* uri */m_reader.skipInt();
                    m_namespaces.pop();
                }
                continue;
            }

            m_lineNumber = lineNumber;

            if (chunkType == CHUNK_XML_START_TAG) {
                m_namespaceUri = m_reader.readInt();
                m_name = m_reader.readInt();
				/* flags? */m_reader.skipInt();
                int attributeCount = m_reader.readInt();
                m_idAttribute = (attributeCount >>> 16) - 1;
                attributeCount &= 0xFFFF;
                m_classAttribute = m_reader.readInt();
                m_styleAttribute = (m_classAttribute >>> 16) - 1;
                m_classAttribute = (m_classAttribute & 0xFFFF) - 1;
                m_attributes = m_reader.readIntArray(attributeCount * ATTRIBUTE_LENGTH);
                for (int i = ATTRIBUTE_IX_VALUE_TYPE; i < m_attributes.length; ) {
                    m_attributes[i] = (m_attributes[i] >>> 24);
                    i += ATTRIBUTE_LENGTH;
                }
                m_namespaces.increaseDepth();
                m_event = START_TAG;
                break;
            }

            if (chunkType == CHUNK_XML_END_TAG) {
                m_namespaceUri = m_reader.readInt();
                m_name = m_reader.readInt();
                m_event = END_TAG;
                m_decreaseDepth = true;
                break;
            }

            if (chunkType == CHUNK_XML_TEXT) {
                m_name = m_reader.readInt();
				/* ? */m_reader.skipInt();
				/* ? */m_reader.skipInt();
                m_event = TEXT;
                break;
            }
        }
    }

    private void setFirstError(AndrolibException error) {
        if (mFirstError == null) {
            mFirstError = error;
        }
    }

    // ///////////////////////////////// data
	/*
	 * All values are essentially indices, e.g. m_name is an index of name in
	 * m_strings.
	 */
    private ExtDataInput m_reader;
    private ResAttrDecoder mAttrDecoder;
    private AndrolibException mFirstError;

    private boolean m_operational = false;
    private StringBlock m_strings;
    private int[] m_resourceIDs;
    private NamespaceStack m_namespaces = new NamespaceStack();
    private final String android_ns = "http://schemas.android.com/apk/res/android";
    private boolean m_decreaseDepth;
    private int m_event;
    private int m_lineNumber;
    private int m_name;
    private int m_namespaceUri;
    private int[] m_attributes;
    private int m_idAttribute;
    private int m_classAttribute;
    private int m_styleAttribute;

    private final static Logger LOGGER = Logger.getLogger(AXmlResourceParser.class.getName());
    private static final String E_NOT_SUPPORTED = "Method is not supported.";
    private static final int ATTRIBUTE_IX_NAMESPACE_URI = 0,
            ATTRIBUTE_IX_NAME = 1, ATTRIBUTE_IX_VALUE_STRING = 2,
            ATTRIBUTE_IX_VALUE_TYPE = 3, ATTRIBUTE_IX_VALUE_DATA = 4,
            ATTRIBUTE_LENGTH = 5;

    private static final int CHUNK_AXML_FILE = 0x00080003, CHUNK_AXML_FILE_BROKEN = 0x00080001,
            CHUNK_RESOURCEIDS = 0x00080180, CHUNK_XML_FIRST = 0x00100100,
            CHUNK_XML_START_NAMESPACE = 0x00100100,
            CHUNK_XML_END_NAMESPACE = 0x00100101,
            CHUNK_XML_START_TAG = 0x00100102, CHUNK_XML_END_TAG = 0x00100103,
            CHUNK_XML_TEXT = 0x00100104, CHUNK_XML_LAST = 0x00100104;

    private static final int PRIVATE_PKG_ID = 0x7F;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/Res9patchStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.CantFind9PatchChunkException;
import brut.util.ExtDataInput;
import java.awt.image.BufferedImage;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.*;
import javax.imageio.ImageIO;

import org.apache.commons.io.IOUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class Res9patchStreamDecoder implements ResStreamDecoder {
    @Override
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException {
        try {
            byte[] data = IOUtils.toByteArray(in);

            if (data.length == 0) {
                return;
            }

            BufferedImage im = ImageIO.read(new ByteArrayInputStream(data));
            int w = im.getWidth(), h = im.getHeight();

            BufferedImage im2 = new BufferedImage(w + 2, h + 2, BufferedImage.TYPE_INT_ARGB);
            if (im.getType() == BufferedImage.TYPE_CUSTOM) {
                //TODO: Ensure this is gray + alpha case?
                Raster srcRaster = im.getRaster();
                WritableRaster dstRaster = im2.getRaster();
                int[] gray = null, alpha = null;
                for (int y = 0; y < im.getHeight(); y++) {
                    gray = srcRaster.getSamples(0, y, w, 1, 0, gray);
                    alpha = srcRaster.getSamples(0, y, w, 1, 1, alpha);

                    dstRaster.setSamples(1, y + 1, w, 1, 0, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 1, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 2, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 3, alpha);
                }
            } else {
                im2.createGraphics().drawImage(im, 1, 1, w, h, null);
            }

            NinePatch np = getNinePatch(data);
            drawHLine(im2, h + 1, np.padLeft + 1, w - np.padRight);
            drawVLine(im2, w + 1, np.padTop + 1, h - np.padBottom);

            int[] xDivs = np.xDivs;
            if (xDivs.length == 0) {
                drawHLine(im2, 0, 1, w);
            } else {
                for (int i = 0; i < xDivs.length; i += 2) {
                    drawHLine(im2, 0, xDivs[i] + 1, xDivs[i + 1]);
                }
            }

            int[] yDivs = np.yDivs;
            if (yDivs.length == 0) {
                drawVLine(im2, 0, 1, h);
            } else {
                for (int i = 0; i < yDivs.length; i += 2) {
                    drawVLine(im2, 0, yDivs[i] + 1, yDivs[i + 1]);
                }
            }

            // Some images additionally use Optical Bounds
            // https://developer.android.com/about/versions/android-4.3.html#OpticalBounds
            try {
                OpticalInset oi = getOpticalInset(data);

                for (int i = 0; i < oi.layoutBoundsLeft; i++) {
                    int x = 1 + i;
                    im2.setRGB(x, h + 1, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsRight; i++) {
                    int x = w - i;
                    im2.setRGB(x, h + 1, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsTop; i++) {
                    int y = 1 + i;
                    im2.setRGB(w + 1, y, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsBottom; i++) {
                    int y = h - i;
                    im2.setRGB(w + 1, y, OI_COLOR);
                }
            } catch (CantFind9PatchChunkException t) {
                // This chunk might not exist
            }

            ImageIO.write(im2, "png", out);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        } catch (NullPointerException ex) {
            // In my case this was triggered because a .png file was
            // containing a html document instead of an image.
            // This could be more verbose and try to MIME ?
            throw new AndrolibException(ex);
        }
    }

    private NinePatch getNinePatch(byte[] data) throws AndrolibException,
            IOException {
        ExtDataInput di = new ExtDataInput(new ByteArrayInputStream(data));
        find9patchChunk(di, NP_CHUNK_TYPE);
        return NinePatch.decode(di);
    }

    private OpticalInset getOpticalInset(byte[] data) throws AndrolibException,
            IOException {
        ExtDataInput di = new ExtDataInput(new ByteArrayInputStream(data));
        find9patchChunk(di, OI_CHUNK_TYPE);
        return OpticalInset.decode(di);
    }

    private void find9patchChunk(DataInput di, int magic) throws AndrolibException,
            IOException {
        di.skipBytes(8);
        while (true) {
            int size;
            try {
                size = di.readInt();
            } catch (IOException ex) {
                throw new CantFind9PatchChunkException("Cant find nine patch chunk", ex);
            }
            if (di.readInt() == magic) {
                return;
            }
            di.skipBytes(size + 4);
        }
    }

    private void drawHLine(BufferedImage im, int y, int x1, int x2) {
        for (int x = x1; x <= x2; x++) {
            im.setRGB(x, y, NP_COLOR);
        }
    }

    private void drawVLine(BufferedImage im, int x, int y1, int y2) {
        for (int y = y1; y <= y2; y++) {
            im.setRGB(x, y, NP_COLOR);
        }
    }

    private static final int NP_CHUNK_TYPE = 0x6e705463; // npTc
    private static final int OI_CHUNK_TYPE = 0x6e704c62; // npLb
    private static final int NP_COLOR = 0xff000000;
    private static final int OI_COLOR = 0xffff0000;

    private static class NinePatch {
        public final int padLeft, padRight, padTop, padBottom;
        public final int[] xDivs, yDivs;

        public NinePatch(int padLeft, int padRight, int padTop, int padBottom,
                         int[] xDivs, int[] yDivs) {
            this.padLeft = padLeft;
            this.padRight = padRight;
            this.padTop = padTop;
            this.padBottom = padBottom;
            this.xDivs = xDivs;
            this.yDivs = yDivs;
        }

        public static NinePatch decode(ExtDataInput di) throws IOException {
            di.skipBytes(1); // wasDeserialized
            byte numXDivs = di.readByte();
            byte numYDivs = di.readByte();
            di.skipBytes(1); // numColors
            di.skipBytes(8); // xDivs/yDivs offset
            int padLeft = di.readInt();
            int padRight = di.readInt();
            int padTop = di.readInt();
            int padBottom = di.readInt();
            di.skipBytes(4); // colorsOffset
            int[] xDivs = di.readIntArray(numXDivs);
            int[] yDivs = di.readIntArray(numYDivs);

            return new NinePatch(padLeft, padRight, padTop, padBottom, xDivs,
                    yDivs);
        }
    }

    private static class OpticalInset {
	    public final int layoutBoundsLeft, layoutBoundsTop, layoutBoundsRight, layoutBoundsBottom;

        public OpticalInset(int layoutBoundsLeft, int layoutBoundsTop,
                int layoutBoundsRight, int layoutBoundsBottom) {
            this.layoutBoundsLeft   = layoutBoundsLeft;
            this.layoutBoundsTop    = layoutBoundsTop;
            this.layoutBoundsRight  = layoutBoundsRight;
            this.layoutBoundsBottom = layoutBoundsBottom;
        }

        public static OpticalInset decode(ExtDataInput di) throws IOException {
            int layoutBoundsLeft = Integer.reverseBytes(di.readInt());
            int layoutBoundsTop = Integer.reverseBytes(di.readInt());
            int layoutBoundsRight = Integer.reverseBytes(di.readInt());
            int layoutBoundsBottom = Integer.reverseBytes(di.readInt());
            return new OpticalInset(layoutBoundsLeft, layoutBoundsTop,
                    layoutBoundsRight, layoutBoundsBottom);
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResAttrDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.value.ResAttr;
import brut.androlib.res.data.value.ResScalarValue;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResAttrDecoder {
    public String decode(int type, int value, String rawValue, int attrResId)
            throws AndrolibException {
        ResScalarValue resValue = mCurrentPackage.getValueFactory().factory(
                type, value, rawValue);

        String decoded = null;
        if (attrResId > 0) {
            try {
                ResAttr attr = (ResAttr) getCurrentPackage().getResTable()
                        .getResSpec(attrResId).getDefaultResource().getValue();

                decoded = attr.convertToResXmlFormat(resValue);
            } catch (UndefinedResObjectException | ClassCastException ex) {
                // ignored
            }
        }

        return decoded != null ? decoded : resValue.encodeAsResXmlAttr();
    }

    public String decodeManifestAttr(int attrResId)
        throws AndrolibException {

        if (attrResId != 0) {
            ResResSpec resResSpec = getCurrentPackage().getResTable().getResSpec(attrResId);

            if (resResSpec != null) {
                return resResSpec.getName();
            }
        }

        return null;
    }

    public ResPackage getCurrentPackage() throws AndrolibException {
        if (mCurrentPackage == null) {
            throw new AndrolibException("Current package not set");
        }
        return mCurrentPackage;
    }

    public void setCurrentPackage(ResPackage currentPackage) {
        mCurrentPackage = currentPackage;
    }

    private ResPackage mCurrentPackage;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResFileDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.CantFind9PatchChunkException;
import brut.androlib.err.RawXmlEncounteredException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.data.value.ResBoolValue;
import brut.androlib.res.data.value.ResFileValue;
import brut.directory.DirUtil;
import brut.directory.Directory;
import brut.directory.DirectoryException;

import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResFileDecoder {
    private final ResStreamDecoderContainer mDecoders;

    public ResFileDecoder(ResStreamDecoderContainer decoders) {
        this.mDecoders = decoders;
    }

    public void decode(ResResource res, Directory inDir, Directory outDir)
            throws AndrolibException {

        ResFileValue fileValue = (ResFileValue) res.getValue();
        String inFileName = fileValue.getStrippedPath();
        String outResName = res.getFilePath();
        String typeName = res.getResSpec().getType().getName();

        String ext = null;
        String outFileName;
        int extPos = inFileName.lastIndexOf(".");
        if (extPos == -1) {
            outFileName = outResName;
        } else {
            ext = inFileName.substring(extPos).toLowerCase();
            outFileName = outResName + ext;
        }

        try {
            if (typeName.equals("raw")) {
                decode(inDir, inFileName, outDir, outFileName, "raw");
                return;
            }
            if (typeName.equals("font") && !".xml".equals(ext)) {
                decode(inDir, inFileName, outDir, outFileName, "raw");
                return;
            }
            if (typeName.equals("drawable") || typeName.equals("mipmap")) {
                if (inFileName.toLowerCase().endsWith(".9" + ext)) {
                    outFileName = outResName + ".9" + ext;

                    // check for htc .r.9.png
                    if (inFileName.toLowerCase().endsWith(".r.9" + ext)) {
                        outFileName = outResName + ".r.9" + ext;
                    }

                    // check for raw 9patch images
                    for (String extension : RAW_9PATCH_IMAGE_EXTENSIONS) {
                        if (inFileName.toLowerCase().endsWith("." + extension)) {
                            copyRaw(inDir, outDir, inFileName, outFileName);
                            return;
                        }
                    }

                    // check for xml 9 patches which are just xml files
                    if (inFileName.toLowerCase().endsWith(".xml")) {
                        decode(inDir, inFileName, outDir, outFileName, "xml");
                        return;
                    }

                    try {
                        decode(inDir, inFileName, outDir, outFileName, "9patch");
                        return;
                    } catch (CantFind9PatchChunkException ex) {
                        LOGGER.log(
                                Level.WARNING,
                                String.format(
                                        "Cant find 9patch chunk in file: \"%s\". Renaming it to *.png.",
                                        inFileName), ex);
                        outDir.removeFile(outFileName);
                        outFileName = outResName + ext;
                    }
                }

                // check for raw image
                for (String extension : RAW_IMAGE_EXTENSIONS) {
                    if (inFileName.toLowerCase().endsWith("." + extension)) {
                        copyRaw(inDir, outDir, inFileName, outFileName);
                        return;
                    }
                }

                if (!".xml".equals(ext)) {
                    decode(inDir, inFileName, outDir, outFileName, "raw");
                    return;
                }
            }

            decode(inDir, inFileName, outDir, outFileName, "xml");
        } catch (RawXmlEncounteredException ex) {
            // If we got an error to decode XML, lets assume the file is in raw format.
            // This is a large assumption, that might increase runtime, but will save us for situations where
            // XSD files are AXML`d on aapt1, but left in plaintext in aapt2.
            decode(inDir, inFileName, outDir, outFileName, "raw");
        } catch (AndrolibException ex) {
            LOGGER.log(Level.SEVERE, String.format(
                    "Could not decode file, replacing by FALSE value: %s",
                    inFileName), ex);
            res.replace(new ResBoolValue(false, 0, null));
        }
    }

    public void decode(Directory inDir, String inFileName, Directory outDir,
                       String outFileName, String decoder) throws AndrolibException {
        try (
                InputStream in = inDir.getFileInput(inFileName);
                OutputStream out = outDir.getFileOutput(outFileName)
        ) {
            mDecoders.decode(in, out, decoder);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void copyRaw(Directory inDir, Directory outDir, String inFilename,
                        String outFilename) throws AndrolibException {
        try {
            DirUtil.copyToDir(inDir, outDir, inFilename, outFilename);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifest(Directory inDir, String inFileName,
                               Directory outDir, String outFileName) throws AndrolibException {
        try (
                InputStream in = inDir.getFileInput(inFileName);
                OutputStream out = outDir.getFileOutput(outFileName)
        ) {
            ((XmlPullStreamDecoder) mDecoders.getDecoder("xml")).decodeManifest(in, out);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private final static Logger LOGGER = Logger.getLogger(ResFileDecoder.class.getName());

    private final static String[] RAW_IMAGE_EXTENSIONS = new String[] {
        "m4a", // apple
        "qmg", // samsung
    };

    private final static String[] RAW_9PATCH_IMAGE_EXTENSIONS = new String[] {
        "qmg", // samsung
        "spi", // samsung
    };
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResRawStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.commons.io.IOUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResRawStreamDecoder implements ResStreamDecoder {
    @Override
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException {
        try {
            IOUtils.copy(in, out);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode raw stream", ex);
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public interface ResStreamDecoder {
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResStreamDecoderContainer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ResStreamDecoderContainer {
    private final Map<String, ResStreamDecoder> mDecoders = new HashMap<String, ResStreamDecoder>();

    public void decode(InputStream in, OutputStream out, String decoderName)
            throws AndrolibException {
        getDecoder(decoderName).decode(in, out);
    }

    public ResStreamDecoder getDecoder(String name) throws AndrolibException {
        ResStreamDecoder decoder = mDecoders.get(name);
        if (decoder == null) {
            throw new AndrolibException("Undefined decoder: " + name);
        }
        return decoder;
    }

    public void setDecoder(String name, ResStreamDecoder decoder) {
        mDecoders.put(name, decoder);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/StringBlock.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.ExtDataInput;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.*;
import java.util.logging.Logger;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 * @author Dmitry Skiba
 *
 *         Block of strings, used in binary xml and arsc.
 *
 *         TODO: - implement get()
 *
 */
public class StringBlock {

    /**
     * Reads whole (including chunk type) string block from stream. Stream must
     * be at the chunk type.
     */
    public static StringBlock read(ExtDataInput reader) throws IOException {
        reader.skipCheckChunkTypeInt(CHUNK_STRINGPOOL_TYPE, CHUNK_NULL_TYPE);
        int chunkSize = reader.readInt();

        // ResStringPool_header
        int stringCount = reader.readInt();
        int styleCount = reader.readInt();
        int flags = reader.readInt();
        int stringsOffset = reader.readInt();
        int stylesOffset = reader.readInt();

        StringBlock block = new StringBlock();
        block.m_isUTF8 = (flags & UTF8_FLAG) != 0;
        block.m_stringOffsets = reader.readIntArray(stringCount);

        if (styleCount != 0) {
            block.m_styleOffsets = reader.readIntArray(styleCount);
        }

        int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;
        block.m_strings = new byte[size];
        reader.readFully(block.m_strings);

        if (stylesOffset != 0) {
            size = (chunkSize - stylesOffset);
            block.m_styles = reader.readIntArray(size / 4);

            // read remaining bytes
            int remaining = size % 4;
            if (remaining >= 1) {
                while (remaining-- > 0) {
                    reader.readByte();
                }
            }
        }

        return block;
    }

    /**
     * Returns number of strings in block.
     */
    public int getCount() {
        return m_stringOffsets != null ? m_stringOffsets.length : 0;
    }

    /**
     * Returns raw string (without any styling information) at specified index.
     */
    public String getString(int index) {
        if (index < 0 || m_stringOffsets == null || index >= m_stringOffsets.length) {
            return null;
        }
        int offset = m_stringOffsets[index];
        int length;

        int[] val;
        if (m_isUTF8) {
            val = getUtf8(m_strings, offset);
            offset = val[0];
        } else {
            val = getUtf16(m_strings, offset);
            offset += val[0];
        }
        length = val[1];
        return decodeString(offset, length);
    }

    /**
     * Not yet implemented.
     *
     * Returns string with style information (if any).
     */
    public CharSequence get(int index) {
        return getString(index);
    }

    /**
     * Returns string with style tags (html-like).
     */
    public String getHTML(int index) {
        String raw = getString(index);
        if (raw == null) {
            return null;
        }
        int[] style = getStyle(index);
        if (style == null) {
            return ResXmlEncoders.escapeXmlChars(raw);
        }

        // If the returned style is further in string, than string length. Lets skip it.
        if (style[1] > raw.length()) {
            return ResXmlEncoders.escapeXmlChars(raw);
        }
        StringBuilder html = new StringBuilder(raw.length() + 32);
        int[] opened = new int[style.length / 3];
        boolean[] unclosed = new boolean[style.length / 3];
        int offset = 0, depth = 0;
        while (true) {
            int i = -1, j;
            for (j = 0; j != style.length; j += 3) {
                if (style[j + 1] == -1) {
                    continue;
                }
                if (i == -1 || style[i + 1] > style[j + 1]) {
                    i = j;
                }
            }
            int start = ((i != -1) ? style[i + 1] : raw.length());
            for (j = depth - 1; j >= 0; j--) {
                int last = opened[j];
                int end = style[last + 2];
                if (end >= start) {
                    if (style[last + 1] == -1 && end != -1) {
                        unclosed[j] = true;
                    }
                    break;
                }
                if (offset <= end) {
                    html.append(ResXmlEncoders.escapeXmlChars(raw.substring(offset, end + 1)));
                    offset = end + 1;
                }
                outputStyleTag(getString(style[last]), html, true);
            }
            depth = j + 1;
            if (offset < start) {
                html.append(ResXmlEncoders.escapeXmlChars(raw.substring(offset, start)));
                if (j >= 0 && unclosed.length >= j && unclosed[j]) {
                    if (unclosed.length > (j + 1) && unclosed[j + 1] || unclosed.length == 1) {
                        outputStyleTag(getString(style[opened[j]]), html, true);
                    }
                }
                offset = start;
            }
            if (i == -1) {
                break;
            }
            outputStyleTag(getString(style[i]), html, false);
            style[i + 1] = -1;
            opened[depth++] = i;
        }
        return html.toString();
    }

    private void outputStyleTag(String tag, StringBuilder builder, boolean close) {
        builder.append('<');
        if (close) {
            builder.append('/');
        }

        int pos = tag.indexOf(';');
        if (pos == -1) {
            builder.append(tag);
        } else {
            builder.append(tag.substring(0, pos));
            if (!close) {
                boolean loop = true;
                while (loop) {
                    int pos2 = tag.indexOf('=', pos + 1);

                    // malformed style information will cause crash. so
                    // prematurely end style tags, if recreation
                    // cannot be created.
                    if (pos2 != -1) {
                        builder.append(' ').append(tag.substring(pos + 1, pos2)).append("=\"");
                        pos = tag.indexOf(';', pos2 + 1);

                        String val;
                        if (pos != -1) {
                            val = tag.substring(pos2 + 1, pos);
                        } else {
                            loop = false;
                            val = tag.substring(pos2 + 1);
                        }

                        builder.append(ResXmlEncoders.escapeXmlChars(val)).append('"');
                    } else {
                        loop = false;
                    }

                }
            }
        }
        builder.append('>');
    }

    /**
     * Finds index of the string. Returns -1 if the string was not found.
     */
    public int find(String string) {
        if (string == null) {
            return -1;
        }
        for (int i = 0; i != m_stringOffsets.length; ++i) {
            int offset = m_stringOffsets[i];
            int length = getShort(m_strings, offset);
            if (length != string.length()) {
                continue;
            }
            int j = 0;
            for (; j != length; ++j) {
                offset += 2;
                if (string.charAt(j) != getShort(m_strings, offset)) {
                    break;
                }
            }
            if (j == length) {
                return i;
            }
        }
        return -1;
    }

    private StringBlock() {
    }

    /**
     * Returns style information - array of int triplets, where in each triplet:
     * * first int is index of tag name ('b','i', etc.) * second int is tag
     * start index in string * third int is tag end index in string
     */
    private int[] getStyle(int index) {
        if (m_styleOffsets == null || m_styles == null|| index >= m_styleOffsets.length) {
            return null;
        }
        int offset = m_styleOffsets[index] / 4;
        int count = 0;
        int[] style;

        for (int i = offset; i < m_styles.length; ++i) {
            if (m_styles[i] == -1) {
                break;
            }
            count += 1;
        }

        if (count == 0 || (count % 3) != 0) {
            return null;
        }
        style = new int[count];

        for (int i = offset, j = 0; i < m_styles.length;) {
            if (m_styles[i] == -1) {
                break;
            }
            style[j++] = m_styles[i++];
        }
        return style;
    }

    private String decodeString(int offset, int length) {
        try {
            return (m_isUTF8 ? UTF8_DECODER : UTF16LE_DECODER).decode(
                    ByteBuffer.wrap(m_strings, offset, length)).toString();
        } catch (CharacterCodingException ex) {
            return null;
        }
    }

    private static final int getShort(byte[] array, int offset) {
        return (array[offset + 1] & 0xff) << 8 | array[offset] & 0xff;
    }

    private static final int getShort(int[] array, int offset) {
        int value = array[offset / 4];
        if ((offset % 4) / 2 == 0) {
            return (value & 0xFFFF);
        } else {
            return (value >>> 16);
        }
    }

    private static final int[] getUtf8(byte[] array, int offset) {
        int val = array[offset];
        int length;
        // We skip the utf16 length of the string
        if ((val & 0x80) != 0) {
            offset += 2;
        } else {
            offset += 1;	
        }
        // And we read only the utf-8 encoded length of the string
        val = array[offset];
        offset += 1;
        if ((val & 0x80) != 0) {
        	int low = (array[offset] & 0xFF); 
        	length = ((val & 0x7F) << 8) + low;
            offset += 1;
        } else {
            length = val;
        }
        return new int[] { offset, length};
    }
    
    private static final int[] getUtf16(byte[] array, int offset) {
        int val = ((array[offset + 1] & 0xFF) << 8 | array[offset] & 0xFF);

        if ((val & 0x8000) != 0) {
            int high = (array[offset + 3] & 0xFF) << 8;
            int low = (array[offset + 2] & 0xFF);
            int len_value =  ((val & 0x7FFF) << 16) + (high + low);
            return new int[] {4, len_value * 2};
            
        }
        return new int[] {2, val * 2};
    }

    private int[] m_stringOffsets;
    private byte[] m_strings;
    private int[] m_styleOffsets;
    private int[] m_styles;
    private boolean m_isUTF8;

    private final CharsetDecoder UTF16LE_DECODER = Charset.forName("UTF-16LE").newDecoder();
    private final CharsetDecoder UTF8_DECODER = Charset.forName("UTF-8").newDecoder();
    private static final Logger LOGGER = Logger.getLogger(StringBlock.class.getName());

    // ResChunk_header = header.type (0x0001) + header.headerSize (0x001C)
    private static final int CHUNK_STRINGPOOL_TYPE = 0x001C0001;
    private static final int CHUNK_NULL_TYPE = 0x00000000;
    private static final int UTF8_FLAG = 0x00000100;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/XmlPullStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import brut.androlib.err.AXmlDecodingException;
import brut.androlib.err.RawXmlEncounteredException;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.wrapper.XmlPullParserWrapper;
import org.xmlpull.v1.wrapper.XmlPullWrapperFactory;
import org.xmlpull.v1.wrapper.XmlSerializerWrapper;
import org.xmlpull.v1.wrapper.classic.StaticXmlSerializerWrapper;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.util.ExtXmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class XmlPullStreamDecoder implements ResStreamDecoder {
    public XmlPullStreamDecoder(XmlPullParser parser,
                                ExtXmlSerializer serializer) {
        this.mParser = parser;
        this.mSerial = serializer;
    }

    @Override
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException {
        try {
            XmlPullWrapperFactory factory = XmlPullWrapperFactory.newInstance();
            XmlPullParserWrapper par = factory.newPullParserWrapper(mParser);
            final ResTable resTable = ((AXmlResourceParser) mParser).getAttrDecoder().getCurrentPackage().getResTable();

            XmlSerializerWrapper ser = new StaticXmlSerializerWrapper(mSerial, factory) {
                boolean hideSdkInfo = false;
                boolean hidePackageInfo = false;

                @Override
                public void event(XmlPullParser pp)
                        throws XmlPullParserException, IOException {
                    int type = pp.getEventType();

                    if (type == XmlPullParser.START_TAG) {
                        if ("manifest".equalsIgnoreCase(pp.getName())) {
                            try {
                                hidePackageInfo = parseManifest(pp);
                            } catch (AndrolibException ignored) {}
                        } else if ("uses-sdk".equalsIgnoreCase(pp.getName())) {
                            try {
                                hideSdkInfo = parseAttr(pp);
                                if (hideSdkInfo) {
                                    return;
                                }
                            } catch (AndrolibException ignored) {}
                        }
                    } else if (hideSdkInfo && type == XmlPullParser.END_TAG
                            && "uses-sdk".equalsIgnoreCase(pp.getName())) {
                        return;
                    } else if (hidePackageInfo && type == XmlPullParser.END_TAG
                            && "manifest".equalsIgnoreCase(pp.getName())) {
                        super.event(pp);
                        return;
                    }
                    super.event(pp);
                }

                private boolean parseManifest(XmlPullParser pp)
                        throws AndrolibException {
                    String attr_name;

                    // read <manifest> for package:
                    for (int i = 0; i < pp.getAttributeCount(); i++) {
                        attr_name = pp.getAttributeName(i);

                        if (attr_name.equalsIgnoreCase(("package"))) {
                            resTable.setPackageRenamed(pp.getAttributeValue(i));
                        } else if (attr_name.equalsIgnoreCase("versionCode")) {
                            resTable.setVersionCode(pp.getAttributeValue(i));
                        } else if (attr_name.equalsIgnoreCase("versionName")) {
                            resTable.setVersionName(pp.getAttributeValue(i));
                        }
                    }
                    return true;
                }

                private boolean parseAttr(XmlPullParser pp)
                        throws AndrolibException {
                    for (int i = 0; i < pp.getAttributeCount(); i++) {
                        final String a_ns = "http://schemas.android.com/apk/res/android";
                        String ns = pp.getAttributeNamespace(i);

                        if (a_ns.equalsIgnoreCase(ns)) {
                            String name = pp.getAttributeName(i);
                            String value = pp.getAttributeValue(i);
                            if (name != null && value != null) {
                                if (name.equalsIgnoreCase("minSdkVersion")
                                        || name.equalsIgnoreCase("targetSdkVersion")
                                        || name.equalsIgnoreCase("maxSdkVersion")
                                        || name.equalsIgnoreCase("compileSdkVersion")) {
                                    resTable.addSdkInfo(name, value);
                                } else {
                                    resTable.clearSdkInfo();
                                    return false; // Found unknown flags
                                }
                            }
                        } else {
                            resTable.clearSdkInfo();

                            if (i >= pp.getAttributeCount()) {
                                return false; // Found unknown flags
                            }
                        }
                    }

                    return ! resTable.getAnalysisMode();
                }
            };

            par.setInput(in, null);
            ser.setOutput(out, null);

            while (par.nextToken() != XmlPullParser.END_DOCUMENT) {
                ser.event(par);
            }
            ser.flush();
        } catch (XmlPullParserException ex) {
            throw new AXmlDecodingException("Could not decode XML", ex);
        } catch (IOException ex) {
            throw new RawXmlEncounteredException("Could not decode XML", ex);
        }
    }

    public void decodeManifest(InputStream in, OutputStream out)
            throws AndrolibException {
            decode(in, out);
    }

    private final XmlPullParser mParser;
    private final ExtXmlSerializer mSerial;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import java.io.File;


public class ExtFile extends brut.directory.ExtFile {
    public ExtFile(File file) {
        super(file.getPath());
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtMXSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import java.io.*;
import org.xmlpull.renamed.MXSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ExtMXSerializer extends MXSerializer implements ExtXmlSerializer {
    @Override
    public void startDocument(String encoding, Boolean standalone)
            throws IOException, IllegalArgumentException, IllegalStateException {
        super.startDocument(encoding != null ? encoding : mDefaultEncoding, standalone);
        this.newLine();
    }

    @Override
    protected void writeAttributeValue(String value, Writer out) throws IOException {
        if (mIsDisabledAttrEscape) {
            out.write(value == null ? "" : value);
            return;
        }
        super.writeAttributeValue(value, out);
    }

    @Override
    public void setOutput(OutputStream os, String encoding) throws IOException {
        super.setOutput(os, encoding != null ? encoding : mDefaultEncoding);
    }

    @Override
    public Object getProperty(String name) throws IllegalArgumentException {
        if (PROPERTY_DEFAULT_ENCODING.equals(name)) {
            return mDefaultEncoding;
        }
        return super.getProperty(name);
    }

    @Override
    public void setProperty(String name, Object value) throws IllegalArgumentException, IllegalStateException {
        if (PROPERTY_DEFAULT_ENCODING.equals(name)) {
            mDefaultEncoding = (String) value;
        } else {
            super.setProperty(name, value);
        }
    }

    @Override
    public ExtXmlSerializer newLine() throws IOException {
        super.out.write(lineSeparator);
        return this;
    }

    @Override
    public void setDisabledAttrEscape(boolean disabled) {
        mIsDisabledAttrEscape = disabled;
    }

    private String mDefaultEncoding;
    private boolean mIsDisabledAttrEscape = false;

}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtXmlSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public interface ExtXmlSerializer extends XmlSerializer {

    public ExtXmlSerializer newLine() throws IOException;

    public void setDisabledAttrEscape(boolean disabled);

    public static final String PROPERTY_SERIALIZER_INDENTATION = "http://xmlpull.org/v1/doc/properties.html#serializer-indentation";
    public static final String PROPERTY_SERIALIZER_LINE_SEPARATOR = "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator";
    public static final String PROPERTY_DEFAULT_ENCODING = "DEFAULT_ENCODING";
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResValuesXmlSerializable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import java.io.IOException;
import org.xmlpull.v1.XmlSerializer;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public interface ResValuesXmlSerializable {
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlEncodable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.AndrolibException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public interface ResXmlEncodable {
    public String encodeAsResXmlAttr() throws AndrolibException;

    public String encodeAsResXmlValue() throws AndrolibException;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlEncoders.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.util.Duo;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public final class ResXmlEncoders {

    public static String escapeXmlChars(String str) {
        return StringUtils.replace(StringUtils.replace(str, "&", "&amp;"), "<", "&lt;");
    }

    public static String encodeAsResXmlAttr(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] chars = str.toCharArray();
        StringBuilder out = new StringBuilder(str.length() + 10);

        switch (chars[0]) {
            case '#':
            case '@':
            case '?':
                out.append('\\');
        }

        for (char c : chars) {
            switch (c) {
                case '\\':
                    out.append('\\');
                    break;
                case '"':
                    out.append("&quot;");
                    continue;
                case '\n':
                    out.append("\\n");
                    continue;
                default:
                    if (!isPrintableChar(c)) {
                        out.append(String.format("\\u%04x", (int) c));
                        continue;
                    }
            }
            out.append(c);
        }

        return out.toString();
    }

    public static String encodeAsXmlValue(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] chars = str.toCharArray();
        StringBuilder out = new StringBuilder(str.length() + 10);

        switch (chars[0]) {
            case '#':
            case '@':
            case '?':
                out.append('\\');
        }

        boolean isInStyleTag = false;
        int startPos = 0;
        boolean enclose = false;
        boolean wasSpace = true;
        for (char c : chars) {
            if (isInStyleTag) {
                if (c == '>') {
                    isInStyleTag = false;
                    startPos = out.length() + 1;
                    enclose = false;
                }
            } else if (c == ' ') {
                if (wasSpace) {
                    enclose = true;
                }
                wasSpace = true;
            } else {
                wasSpace = false;
                switch (c) {
                    case '\\':
                        out.append('\\');
                        break;
                    case '\'':
                    case '\n':
                        enclose = true;
                        break;
                    case '"':
                        out.append('\\');
                        break;
                    case '<':
                        isInStyleTag = true;
                        if (enclose) {
                            out.insert(startPos, '"').append('"');
                        }
                        break;
                    default:
                        if (!isPrintableChar(c)) {

                            // lets not write trailing \u0000 if we are at end of string
                            if ((out.length() + 1) == str.length() && c == '\u0000') {
                                continue;
                            }
                            out.append(String.format("\\u%04x", (int) c));
                            continue;
                        }
                }
            }
            out.append(c);
        }

        if (enclose || wasSpace) {
            out.insert(startPos, '"').append('"');
        }
        return out.toString();
    }

    public static boolean hasMultipleNonPositionalSubstitutions(String str) {
        Duo<List<Integer>, List<Integer>> tuple = findSubstitutions(str, 4);
        return ! tuple.m1.isEmpty() && tuple.m1.size() + tuple.m2.size() > 1;
    }

    public static String enumerateNonPositionalSubstitutionsIfRequired(String str) {
        Duo<List<Integer>, List<Integer>> tuple = findSubstitutions(str, 4);
        if (tuple.m1.isEmpty() || tuple.m1.size() + tuple.m2.size() < 2) {
            return str;
        }
        List<Integer> subs = tuple.m1;

        StringBuilder out = new StringBuilder();
        int pos = 0;
        int count = 0;
        for (Integer sub : subs) {
            out.append(str.substring(pos, ++sub)).append(++count).append('$');
            pos = sub;
        }
        out.append(str.substring(pos));

        return out.toString();
    }

    /**
     * It returns a tuple of:
     *   - a list of offsets of non positional substitutions. non-pos is defined as any "%" which isn't "%%" nor "%\d+\$"
     *   - a list of offsets of positional substitutions
     */
    private static Duo<List<Integer>, List<Integer>> findSubstitutions(String str, int nonPosMax) {
        if (nonPosMax == -1) {
            nonPosMax = Integer.MAX_VALUE;
        }
        int pos;
        int pos2 = 0;
        List<Integer> nonPositional = new ArrayList<>();
        List<Integer> positional = new ArrayList<>();

        if (str == null) {
            return new Duo<>(nonPositional, positional);
        }

        int length = str.length();

        while ((pos = str.indexOf('%', pos2)) != -1) {
            pos2 = pos + 1;
            if (pos2 == length) {
                nonPositional.add(pos);
                break;
            }
            char c = str.charAt(pos2++);
            if (c == '%') {
                continue;
            }
            if (c >= '0' && c <= '9' && pos2 < length) {
                while ((c = str.charAt(pos2++)) >= '0' && c <= '9' && pos2 < length);
                if (c == '$') {
                    positional.add(pos);
                    continue;
                }
            }

            nonPositional.add(pos);
            if (nonPositional.size() >= nonPosMax) {
                break;
            }
        }

        return new Duo<>(nonPositional, positional);
    }

    private static boolean isPrintableChar(char c) {
        Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
        return !Character.isISOControl(c) && c != KeyEvent.CHAR_UNDEFINED
                && block != null && block != Character.UnicodeBlock.SPECIALS;
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlPatcher.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.logging.Logger;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.*;
import org.xml.sax.SAXException;

import brut.androlib.AndrolibException;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public final class ResXmlPatcher {

    /**
     * Removes "debug" tag from file
     *
     * @param file AndroidManifest file
     * @throws AndrolibException
     */
    public static void removeApplicationDebugTag(File file) throws AndrolibException {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node application = doc.getElementsByTagName("application").item(0);

                // load attr
                NamedNodeMap attr = application.getAttributes();
                Node debugAttr = attr.getNamedItem("android:debuggable");

                // remove application:debuggable
                if (debugAttr != null) {
                    attr.removeNamedItem("android:debuggable");
                }

                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Sets "debug" tag in the file to true
     *
     * @param file AndroidManifest file
     * @throws AndrolibException
     */
    public static void setApplicationDebugTagTrue(File file) throws AndrolibException {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node application = doc.getElementsByTagName("application").item(0);

                // load attr
                NamedNodeMap attr = application.getAttributes();
                Node debugAttr = attr.getNamedItem("android:debuggable");

                if (debugAttr == null) {
                    debugAttr = doc.createAttribute("android:debuggable");
                    attr.setNamedItem(debugAttr);
                }

                // set application:debuggable to 'true
                debugAttr.setNodeValue("true");

                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Any @string reference in a <provider> value in AndroidManifest.xml will break on
     * build, thus preventing the application from installing. This is from a bug/error
     * in AOSP where public resources cannot be part of an authorities attribute within
     * a <provider> tag.
     *
     * This finds any reference and replaces it with the literal value found in the
     * res/values/strings.xml file.
     *
     * @param file File for AndroidManifest.xml
     * @throws AndrolibException
     */
    public static void fixingPublicAttrsInProviderAttributes(File file) throws AndrolibException {
        boolean saved = false;
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/manifest/application/provider");

                Object result = expression.evaluate(doc, XPathConstants.NODESET);
                NodeList nodes = (NodeList) result;

                for (int i = 0; i < nodes.getLength(); i++) {
                    Node node = nodes.item(i);
                    NamedNodeMap attrs = node.getAttributes();

                    if (attrs != null) {
                        Node provider = attrs.getNamedItem("android:authorities");

                        if (provider != null) {
                            saved = isSaved(file, saved, provider);
                        }
                    }
                }

                // android:scheme
                xPath = XPathFactory.newInstance().newXPath();
                expression = xPath.compile("/manifest/application/activity/intent-filter/data");

                result = expression.evaluate(doc, XPathConstants.NODESET);
                nodes = (NodeList) result;

                for (int i = 0; i < nodes.getLength(); i++) {
                    Node node = nodes.item(i);
                    NamedNodeMap attrs = node.getAttributes();

                    if (attrs != null) {
                        Node provider = attrs.getNamedItem("android:scheme");

                        if (provider != null) {
                            saved = isSaved(file, saved, provider);
                        }
                    }
                }

                if (saved) {
                    saveDocument(file, doc);
                }

            }  catch (SAXException | ParserConfigurationException | IOException |
                    XPathExpressionException | TransformerException ignored) {
            }
        }
    }

    /**
     * Checks if the replacement was properly made to a node.
     *
     * @param file File we are searching for value
     * @param saved boolean on whether we need to save
     * @param provider Node we are attempting to replace
     * @return boolean
     * @throws AndrolibException setting node value failed
     */
    private static boolean isSaved(File file, boolean saved, Node provider) throws AndrolibException {
        String reference = provider.getNodeValue();
        String replacement = pullValueFromStrings(file.getParentFile(), reference);

        if (replacement != null) {
            provider.setNodeValue(replacement);
            saved = true;
        }
        return saved;
    }

    /**
     * Finds key in strings.xml file and returns text value
     *
     * @param directory Root directory of apk
     * @param key String reference (ie @string/foo)
     * @return String|null
     * @throws AndrolibException
     */
    public static String pullValueFromStrings(File directory, String key) throws AndrolibException {
        if (key == null || ! key.contains("@")) {
            return null;
        }

        File file = new File(directory, "/res/values/strings.xml");
        key = key.replace("@string/", "");

        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/resources/string[@name=" + '"' + key + "\"]/text()");

                Object result = expression.evaluate(doc, XPathConstants.STRING);

                if (result != null) {
                    return (String) result;
                }

            }  catch (SAXException | ParserConfigurationException | IOException | XPathExpressionException ignored) {
            }
        }

        return null;
    }

    /**
     * Finds key in integers.xml file and returns text value
     *
     * @param directory Root directory of apk
     * @param key Integer reference (ie @integer/foo)
     * @return String|null
     * @throws AndrolibException
     */
    public static String pullValueFromIntegers(File directory, String key) throws AndrolibException {
        if (key == null || ! key.contains("@")) {
            return null;
        }

        File file = new File(directory, "/res/values/integers.xml");
        key = key.replace("@integer/", "");

        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/resources/integer[@name=" + '"' + key + "\"]/text()");

                Object result = expression.evaluate(doc, XPathConstants.STRING);

                if (result != null) {
                    return (String) result;
                }

            }  catch (SAXException | ParserConfigurationException | IOException | XPathExpressionException ignored) {
            }
        }

        return null;
    }

    /**
     * Removes attributes like "versionCode" and "versionName" from file.
     *
     * @param file File representing AndroidManifest.xml
     * @throws AndrolibException
     */
    public static void removeManifestVersions(File file) throws AndrolibException {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node manifest = doc.getFirstChild();
                NamedNodeMap attr = manifest.getAttributes();
                Node vCode = attr.getNamedItem("android:versionCode");
                Node vName = attr.getNamedItem("android:versionName");

                if (vCode != null) {
                    attr.removeNamedItem("android:versionCode");
                }
                if (vName != null) {
                    attr.removeNamedItem("android:versionName");
                }
                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Replaces package value with passed packageOriginal string
     *
     * @param file File for AndroidManifest.xml
     * @param packageOriginal Package name to replace
     * @throws AndrolibException
     */
    public static void renameManifestPackage(File file, String packageOriginal) throws AndrolibException {
        try {
            Document doc = loadDocument(file);

            // Get the manifest line
            Node manifest = doc.getFirstChild();

            // update package attribute
            NamedNodeMap attr = manifest.getAttributes();
            Node nodeAttr = attr.getNamedItem("package");
            nodeAttr.setNodeValue(packageOriginal);
            saveDocument(file, doc);

        } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
        }
    }

    /**
     *
     * @param file File to load into Document
     * @return Document
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     */
    private static Document loadDocument(File file)
            throws IOException, SAXException, ParserConfigurationException {

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        docFactory.setFeature(FEATURE_DISABLE_DOCTYPE_DECL, true);
        docFactory.setFeature(FEATURE_LOAD_DTD, false);

        try {
            docFactory.setAttribute(ACCESS_EXTERNAL_DTD, " ");
            docFactory.setAttribute(ACCESS_EXTERNAL_SCHEMA, " ");
        } catch (IllegalArgumentException ex) {
            LOGGER.warning("JAXP 1.5 Support is required to validate XML");
        }

        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        // Not using the parse(File) method on purpose, so that we can control when
        // to close it. Somehow parse(File) does not seem to close the file in all cases.
        FileInputStream inputStream = new FileInputStream(file);
        try {
        	return docBuilder.parse(inputStream);
        } finally {
        	inputStream.close();
        }
    }

    /**
     *
     * @param file File to save Document to (ie AndroidManifest.xml)
     * @param doc Document being saved
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     * @throws TransformerException
     */
    private static void saveDocument(File file, Document doc)
            throws IOException, SAXException, ParserConfigurationException, TransformerException {

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(file);
        transformer.transform(source, result);
    }

    private static final String ACCESS_EXTERNAL_DTD = "http://javax.xml.XMLConstants/property/accessExternalDTD";
    private static final String ACCESS_EXTERNAL_SCHEMA = "http://javax.xml.XMLConstants/property/accessExternalSchema";
    private static final String FEATURE_LOAD_DTD = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
    private static final String FEATURE_DISABLE_DOCTYPE_DECL = "http://apache.org/xml/features/disallow-doctype-decl";

    private static final Logger LOGGER = Logger.getLogger(ResXmlPatcher.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/src/SmaliBuilder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.src;

import brut.androlib.AndrolibException;
import brut.androlib.mod.SmaliMod;
import brut.directory.ExtFile;
import brut.directory.DirectoryException;
import java.io.*;
import java.util.logging.Logger;

import org.antlr.runtime.RecognitionException;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.writer.builder.DexBuilder;
import org.jf.dexlib2.writer.io.FileDataStore;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class SmaliBuilder {
    public static void build(ExtFile smaliDir, File dexFile, int apiLevel) throws AndrolibException {
        new SmaliBuilder(smaliDir, dexFile, apiLevel).build();
    }

    public static void build(ExtFile smaliDir, File dexFile) throws AndrolibException {
        new SmaliBuilder(smaliDir, dexFile, 0).build();
    }

    private SmaliBuilder(ExtFile smaliDir, File dexFile, int apiLevel) {
        mSmaliDir = smaliDir;
        mDexFile = dexFile;
        mApiLevel = apiLevel;
    }

    private void build() throws AndrolibException {
        try {
            DexBuilder dexBuilder;
            if (mApiLevel > 0) {
                dexBuilder = new DexBuilder(Opcodes.forApi(mApiLevel));
            } else {
                dexBuilder = new DexBuilder(Opcodes.getDefault());
            }

            for (String fileName : mSmaliDir.getDirectory().getFiles(true)) {
                buildFile(fileName, dexBuilder);
            }
            dexBuilder.writeTo(new FileDataStore( new File(mDexFile.getAbsolutePath())));
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildFile(String fileName, DexBuilder dexBuilder)
            throws AndrolibException, IOException {
        File inFile = new File(mSmaliDir, fileName);
        InputStream inStream = new FileInputStream(inFile);

        if (fileName.endsWith(".smali")) {
            try {
                if (!SmaliMod.assembleSmaliFile(inFile, dexBuilder, mApiLevel, false, false)) {
                    throw new AndrolibException("Could not smali file: " + fileName);
                }
            } catch (IOException | RecognitionException ex) {
                throw new AndrolibException(ex);
            }
        } else {
            LOGGER.warning("Unknown file type, ignoring: " + inFile);
        }
        inStream.close();
    }

    private final ExtFile mSmaliDir;
    private final File mDexFile;
    private int mApiLevel = 0;

    private final static Logger LOGGER = Logger.getLogger(SmaliBuilder.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/brut/androlib/src/SmaliDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.src;

import brut.androlib.AndrolibException;
import org.jf.baksmali.Baksmali;
import org.jf.baksmali.BaksmaliOptions;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.dexbacked.DexBackedDexFile;
import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
import org.jf.dexlib2.analysis.InlineMethodResolver;
import org.jf.dexlib2.iface.MultiDexContainer;

import java.io.File;
import java.io.IOException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class SmaliDecoder {

    public static void decode(File apkFile, File outDir, String dexName, boolean bakdeb, int api)
            throws AndrolibException {
        new SmaliDecoder(apkFile, outDir, dexName, bakdeb, api).decode();
    }

    private SmaliDecoder(File apkFile, File outDir, String dexName, boolean bakdeb, int api) {
        mApkFile = apkFile;
        mOutDir  = outDir;
        mDexFile = dexName;
        mBakDeb  = bakdeb;
        mApi     = api;
    }

    private void decode() throws AndrolibException {
        try {
            final BaksmaliOptions options = new BaksmaliOptions();

            // options
            options.deodex = false;
            options.implicitReferences = false;
            options.parameterRegisters = true;
            options.localsDirective = true;
            options.sequentialLabels = true;
            options.debugInfo = mBakDeb;
            options.codeOffsets = false;
            options.accessorComments = false;
            options.registerInfo = 0;
            options.inlineResolver = null;

            // set jobs automatically
            int jobs = Runtime.getRuntime().availableProcessors();
            if (jobs > 6) {
                jobs = 6;
            }

            // create the container
            MultiDexContainer<? extends DexBackedDexFile> container = DexFileFactory.loadDexContainer(mApkFile, Opcodes.forApi(mApi));
            MultiDexContainer.DexEntry<? extends DexBackedDexFile> dexEntry;
            DexBackedDexFile dexFile;

            // If we have 1 item, ignore the passed file. Pull the DexFile we need.
            if (container.getDexEntryNames().size() == 1) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            } else {
                dexEntry = container.getEntry(mDexFile);
            }

            // Double check the passed param exists
            if (dexEntry == null) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            }

            assert dexEntry != null;
            dexFile = dexEntry.getDexFile();

            if (dexFile.supportsOptimizedOpcodes()) {
                throw new AndrolibException("Warning: You are disassembling an odex file without deodexing it.");
            }

            if (dexFile instanceof DexBackedOdexFile) {
                options.inlineResolver =
                        InlineMethodResolver.createInlineMethodResolver(((DexBackedOdexFile)dexFile).getOdexVersion());
            }

            Baksmali.disassembleDexFile(dexFile, mOutDir, jobs, options);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private final File mApkFile;
    private final File mOutDir;
    private final String mDexFile;
    private final boolean mBakDeb;
    private final int mApi;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/com/fakerandroid/decoder/apktool/Resources.java`:

```java
package com.fakerandroid.decoder.apktool;

import brut.androlib.ApkDecoder;

import java.io.File;

public class Resources {
    public static void decode(File in, File out) {
        ApkDecoder decoder = new ApkDecoder();
        try {
            decoder.setDecodeSources((short) 0);
            decoder.setOutDir(out);
            decoder.setForceDelete(true);
            decoder.setApkFile(in);
            decoder.decode();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/java/org/xmlpull/renamed/MXSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.xmlpull.renamed;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.xmlpull.v1.XmlSerializer;

/**
 * Implementation of XmlSerializer interface from XmlPull V1 API. This
 * implementation is optimized for performance and low memory footprint.
 *
 * <p>
 * Implemented features:
 * <ul>
 * <li>FEATURE_NAMES_INTERNED - when enabled all returned names (namespaces,
 * prefixes) will be interned and it is required that all names passed as
 * arguments MUST be interned
 * <li>FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE
 * </ul>
 * <p>
 * Implemented properties:
 * <ul>
 * <li>PROPERTY_SERIALIZER_INDENTATION
 * <li>PROPERTY_SERIALIZER_LINE_SEPARATOR
 * </ul>
 *
 */
public class MXSerializer implements XmlSerializer {
	protected final static String XML_URI = "http://www.w3.org/XML/1998/namespace";
	protected final static String XMLNS_URI = "http://www.w3.org/2000/xmlns/";
	private static final boolean TRACE_SIZING = false;
	private static final boolean TRACE_ESCAPING = false;

	protected final String FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE = "http://xmlpull.org/v1/doc/features.html#serializer-attvalue-use-apostrophe";
	protected final String FEATURE_NAMES_INTERNED = "http://xmlpull.org/v1/doc/features.html#names-interned";
	protected final String PROPERTY_SERIALIZER_INDENTATION = "http://xmlpull.org/v1/doc/properties.html#serializer-indentation";
	protected final String PROPERTY_SERIALIZER_LINE_SEPARATOR = "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator";
	protected final static String PROPERTY_LOCATION = "http://xmlpull.org/v1/doc/properties.html#location";

	// properties/features
	protected boolean namesInterned;
	protected boolean attributeUseApostrophe;
	protected String indentationString = null; // " ";
	protected String lineSeparator = "\n";

	protected String location;
	protected Writer out;

	protected int autoDeclaredPrefixes;

	protected int depth = 0;

	// element stack
	protected String elNamespace[] = new String[2];
	protected String elName[] = new String[elNamespace.length];
	protected String elPrefix[] = new String[elNamespace.length];
	protected int elNamespaceCount[] = new int[elNamespace.length];

	// namespace stack
	protected int namespaceEnd = 0;
	protected String namespacePrefix[] = new String[8];
	protected String namespaceUri[] = new String[namespacePrefix.length];

	protected boolean finished;
	protected boolean pastRoot;
	protected boolean setPrefixCalled;
	protected boolean startTagIncomplete;

	protected boolean doIndent;
	protected boolean seenTag;

	protected boolean seenBracket;
	protected boolean seenBracketBracket;

	// buffer output if needed to write escaped String see text(String)
	private static final int BUF_LEN = Runtime.getRuntime().freeMemory() > 1000000L ? 8 * 1024 : 256;
	protected char buf[] = new char[BUF_LEN];

	protected static final String precomputedPrefixes[];

	static {
		precomputedPrefixes = new String[32]; // arbitrary number ...
		for (int i = 0; i < precomputedPrefixes.length; i++) {
			precomputedPrefixes[i] = ("n" + i).intern();
		}
	}

	private boolean checkNamesInterned = false;

	private void checkInterning(String name) {
		if (namesInterned && name != name.intern()) {
			throw new IllegalArgumentException("all names passed as arguments must be interned"
					+ "when NAMES INTERNED feature is enabled");
		}
	}

	protected void reset() {
		location = null;
		out = null;
		autoDeclaredPrefixes = 0;
		depth = 0;

		// nullify references on all levels to allow it to be GCed
		for (int i = 0; i < elNamespaceCount.length; i++) {
			elName[i] = null;
			elPrefix[i] = null;
			elNamespace[i] = null;
			elNamespaceCount[i] = 2;
		}

		namespaceEnd = 0;

		// TODO: how to prevent from reporting this namespace?
		// this is special namespace declared for consistency with XML infoset
		namespacePrefix[namespaceEnd] = "xmlns";
		namespaceUri[namespaceEnd] = XMLNS_URI;
		++namespaceEnd;

		namespacePrefix[namespaceEnd] = "xml";
		namespaceUri[namespaceEnd] = XML_URI;
		++namespaceEnd;

		finished = false;
		pastRoot = false;
		setPrefixCalled = false;
		startTagIncomplete = false;
		seenTag = false;

		seenBracket = false;
		seenBracketBracket = false;
	}

	protected void ensureElementsCapacity() {
		final int elStackSize = elName.length;
		final int newSize = (depth >= 7 ? 2 * depth : 8) + 2;

		if (TRACE_SIZING) {
			System.err.println(getClass().getName() + " elStackSize "
					+ elStackSize + " ==> " + newSize);
		}
		final boolean needsCopying = elStackSize > 0;
		String[] arr = null;
		// reuse arr local variable slot
		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elName, 0, arr, 0, elStackSize);
		elName = arr;

		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elPrefix, 0, arr, 0, elStackSize);
		elPrefix = arr;

		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elNamespace, 0, arr, 0, elStackSize);
		elNamespace = arr;

		final int[] iarr = new int[newSize];
		if (needsCopying) {
			System.arraycopy(elNamespaceCount, 0, iarr, 0, elStackSize);
		} else {
			// special initialization
			iarr[0] = 0;
		}
		elNamespaceCount = iarr;
	}

	protected void ensureNamespacesCapacity() { // int size) {
		final int newSize = namespaceEnd > 7 ? 2 * namespaceEnd : 8;
		if (TRACE_SIZING) {
			System.err.println(getClass().getName() + " namespaceSize " + namespacePrefix.length + " ==> " + newSize);
		}
		final String[] newNamespacePrefix = new String[newSize];
		final String[] newNamespaceUri = new String[newSize];
		if (namespacePrefix != null) {
			System.arraycopy(namespacePrefix, 0, newNamespacePrefix, 0, namespaceEnd);
			System.arraycopy(namespaceUri, 0, newNamespaceUri, 0, namespaceEnd);
		}
		namespacePrefix = newNamespacePrefix;
		namespaceUri = newNamespaceUri;
	}

	@Override
	public void setFeature(String name, boolean state)
			throws IllegalArgumentException, IllegalStateException {
		if (name == null) {
			throw new IllegalArgumentException("feature name can not be null");
		}
		if (FEATURE_NAMES_INTERNED.equals(name)) {
			namesInterned = state;
		} else if (FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE.equals(name)) {
			attributeUseApostrophe = state;
		} else {
			throw new IllegalStateException("unsupported feature " + name);
		}
	}

	@Override
	public boolean getFeature(String name) throws IllegalArgumentException {
		if (name == null) {
			throw new IllegalArgumentException("feature name can not be null");
		}
		if (FEATURE_NAMES_INTERNED.equals(name)) {
			return namesInterned;
		} else if (FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE.equals(name)) {
			return attributeUseApostrophe;
		} else {
			return false;
		}
	}

	// precomputed variables to simplify writing indentation
	protected int offsetNewLine;
	protected int indentationJump;
	protected char[] indentationBuf;
	protected int maxIndentLevel;
	protected boolean writeLineSepartor; // should end-of-line be written
	protected boolean writeIndentation; // is indentation used?

	/**
	 * For maximum efficiency when writing indents the required output is
	 * pre-computed This is internal function that recomputes buffer after user
	 * requested chnages.
	 */
	protected void rebuildIndentationBuf() {
		if (doIndent == false)
			return;
		final int maxIndent = 65; // hardcoded maximum indentation size in characters
		int bufSize = 0;
		offsetNewLine = 0;
		if (writeLineSepartor) {
			offsetNewLine = lineSeparator.length();
			bufSize += offsetNewLine;
		}
		maxIndentLevel = 0;
		if (writeIndentation) {
			indentationJump = indentationString.length();
			maxIndentLevel = maxIndent / indentationJump;
			bufSize += maxIndentLevel * indentationJump;
		}
		if (indentationBuf == null || indentationBuf.length < bufSize) {
			indentationBuf = new char[bufSize + 8];
		}
		int bufPos = 0;
		if (writeLineSepartor) {
			for (int i = 0; i < lineSeparator.length(); i++) {
				indentationBuf[bufPos++] = lineSeparator.charAt(i);
			}
		}
		if (writeIndentation) {
			for (int i = 0; i < maxIndentLevel; i++) {
				for (int j = 0; j < indentationString.length(); j++) {
					indentationBuf[bufPos++] = indentationString.charAt(j);
				}
			}
		}
	}

	protected void writeIndent() throws IOException {
		final int start = writeLineSepartor ? 0 : offsetNewLine;
		final int level = (depth > maxIndentLevel) ? maxIndentLevel : depth;

		out.write(indentationBuf, start, ((level - 1) * indentationJump) + offsetNewLine);
	}

	@Override
	public void setProperty(String name, Object value)
			throws IllegalArgumentException, IllegalStateException {
		if (name == null) {
			throw new IllegalArgumentException("property name can not be null");
		}
		if (PROPERTY_SERIALIZER_INDENTATION.equals(name)) {
			indentationString = (String) value;
		} else if (PROPERTY_SERIALIZER_LINE_SEPARATOR.equals(name)) {
			lineSeparator = (String) value;
		} else if (PROPERTY_LOCATION.equals(name)) {
			location = (String) value;
		} else {
			throw new IllegalStateException("unsupported property " + name);
		}
		writeLineSepartor = lineSeparator != null && lineSeparator.length() > 0;
		writeIndentation = indentationString != null
				&& indentationString.length() > 0;
		// optimize - do not write when nothing to write ...
		doIndent = indentationString != null
				&& (writeLineSepartor || writeIndentation);
		// NOTE: when indentationString == null there is no indentation
		// (even though writeLineSeparator may be true ...)
		rebuildIndentationBuf();
		seenTag = false; // for consistency
	}

	@Override
	public Object getProperty(String name) throws IllegalArgumentException {
		if (name == null) {
			throw new IllegalArgumentException("property name can not be null");
		}
		if (PROPERTY_SERIALIZER_INDENTATION.equals(name)) {
			return indentationString;
		} else if (PROPERTY_SERIALIZER_LINE_SEPARATOR.equals(name)) {
			return lineSeparator;
		} else if (PROPERTY_LOCATION.equals(name)) {
			return location;
		} else {
			return null;
		}
	}

	private String getLocation() {
		return location != null ? " @" + location : "";
	}

	// this is special method that can be accessed directly to retrieve Writer
	// serializer is using
	public Writer getWriter() {
		return out;
	}

	@Override
	public void setOutput(Writer writer) {
		reset();
		out = writer;
	}

	@Override
	public void setOutput(OutputStream os, String encoding) throws IOException {
		if (os == null)
			throw new IllegalArgumentException("output stream can not be null");
		reset();
		if (encoding != null) {
			out = new OutputStreamWriter(os, encoding);
		} else {
			out = new OutputStreamWriter(os);
		}
	}

	@Override
	public void startDocument(String encoding, Boolean standalone)
			throws IOException {
		if (attributeUseApostrophe) {
			out.write("<?xml version='1.0'");
		} else {
			out.write("<?xml version=\"1.0\"");
		}
		if (encoding != null) {
			out.write(" encoding=");
			out.write(attributeUseApostrophe ? '\'' : '"');
			out.write(encoding);
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
		if (standalone != null) {
			out.write(" standalone=");
			out.write(attributeUseApostrophe ? '\'' : '"');
			if (standalone.booleanValue()) {
				out.write("yes");
			} else {
				out.write("no");
			}
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
		out.write("?>");
	}

	@Override
	public void endDocument() throws IOException {
		// close all unclosed tag;
		while (depth > 0) {
			endTag(elNamespace[depth], elName[depth]);
		}
		finished = pastRoot = startTagIncomplete = true;
		out.flush();
	}

	@Override
	public void setPrefix(String prefix, String namespace) throws IOException {
		if (startTagIncomplete)
			closeStartTag();

		if (prefix == null) {
			prefix = "";
		}
		if (!namesInterned) {
			prefix = prefix.intern(); // will throw NPE if prefix==null
		} else if (checkNamesInterned) {
			checkInterning(prefix);
		} else if (prefix == null) {
			throw new IllegalArgumentException("prefix must be not null" + getLocation());
		}

		// check that prefix is not duplicated ...
		for (int i = elNamespaceCount[depth]; i < namespaceEnd; i++) {
			if (prefix == namespacePrefix[i]) {
				// Toss out extra namespaces at same depth to fix #1456
				return;
			}
		}

		if (!namesInterned) {
			namespace = namespace.intern();
		} else if (checkNamesInterned) {
			checkInterning(namespace);
		} else if (namespace == null) {
			throw new IllegalArgumentException("namespace must be not null" + getLocation());
		}

		if (namespaceEnd >= namespacePrefix.length) {
			ensureNamespacesCapacity();
		}
		namespacePrefix[namespaceEnd] = prefix;
		namespaceUri[namespaceEnd] = namespace;
		++namespaceEnd;
		setPrefixCalled = true;
	}

	protected String lookupOrDeclarePrefix(String namespace) {
		return getPrefix(namespace, true);
	}

	@Override
	public String getPrefix(String namespace, boolean generatePrefix) {
		return getPrefix(namespace, generatePrefix, false);
	}

	protected String getPrefix(String namespace, boolean generatePrefix,
			boolean nonEmpty) {
		if (!namesInterned) {
			// when String is interned we can do much faster namespace stack lookups ...
			namespace = namespace.intern();
		} else if (checkNamesInterned) {
			checkInterning(namespace);
		}
		if (namespace == null) {
			throw new IllegalArgumentException("namespace must be not null" + getLocation());
		} else if (namespace.length() == 0) {
			throw new IllegalArgumentException("default namespace cannot have prefix" + getLocation());
		}

		// first check if namespace is already in scope
		for (int i = namespaceEnd - 1; i >= 0; --i) {
			if (namespace == namespaceUri[i]) {
				final String prefix = namespacePrefix[i];
				if (nonEmpty && prefix.length() == 0)
					continue;
				// now check that prefix is still in scope
				for (int p = namespaceEnd - 1; p > i; --p) {
					if (prefix == namespacePrefix[p])
						continue; // too bad - prefix is redeclared with different namespace
				}
				return prefix;
			}
		}

		// so not found it ...
		if (!generatePrefix) {
			return null;
		}
		return generatePrefix(namespace);
	}

	private String generatePrefix(String namespace) {
		while (true) {
			++autoDeclaredPrefixes;
			// fast lookup uses table that was pre-initialized in static{} ....
			final String prefix = autoDeclaredPrefixes < precomputedPrefixes.length
					? precomputedPrefixes[autoDeclaredPrefixes]
					: ("n" + autoDeclaredPrefixes).intern();

			// make sure this prefix is not declared in any scope (avoid hiding in-scope prefixes)!
			for (int i = namespaceEnd - 1; i >= 0; --i) {
				if (prefix == namespacePrefix[i]) {
					continue; // prefix is already declared - generate new and try again
				}
			}
			// declare prefix

			if (namespaceEnd >= namespacePrefix.length) {
				ensureNamespacesCapacity();
			}
			namespacePrefix[namespaceEnd] = prefix;
			namespaceUri[namespaceEnd] = namespace;
			++namespaceEnd;

			return prefix;
		}
	}

	@Override
	public int getDepth() {
		return depth;
	}

	@Override
	public String getNamespace() {
		return elNamespace[depth];
	}

	@Override
	public String getName() {
		return elName[depth];
	}

	@Override
	public XmlSerializer startTag(String namespace, String name)
			throws IOException {
		if (startTagIncomplete) {
			closeStartTag();
		}
		seenBracket = seenBracketBracket = false;
		++depth;
		if (doIndent && depth > 0 && seenTag) {
			writeIndent();
		}
		seenTag = true;
		setPrefixCalled = false;
		startTagIncomplete = true;
		if ((depth + 1) >= elName.length) {
			ensureElementsCapacity();
		}

		if (checkNamesInterned && namesInterned)
			checkInterning(namespace);

		elNamespace[depth] = (namesInterned || namespace == null) ? namespace : namespace.intern();
		if (checkNamesInterned && namesInterned)
			checkInterning(name);

		elName[depth] = (namesInterned || name == null) ? name : name.intern();
		if (out == null) {
			throw new IllegalStateException("setOutput() must called set before serialization can start");
		}
		out.write('<');
		if (namespace != null) {
			if (namespace.length() > 0) {
				// in future make this algo a feature on serializer
				String prefix = null;
				if (depth > 0 && (namespaceEnd - elNamespaceCount[depth - 1]) == 1) {
					// if only one prefix was declared un-declare it if the
					// prefix is already declared on parent el with the same URI
					String uri = namespaceUri[namespaceEnd - 1];
					if (uri == namespace || uri.equals(namespace)) {
						String elPfx = namespacePrefix[namespaceEnd - 1];
						for (int pos = elNamespaceCount[depth - 1] - 1; pos >= 2; --pos) {
							String pf = namespacePrefix[pos];
							if (pf == elPfx || pf.equals(elPfx)) {
								String n = namespaceUri[pos];
								if (n == uri || n.equals(uri)) {
									--namespaceEnd; // un-declare namespace: this is kludge!
									prefix = elPfx;
								}
								break;
							}
						}
					}
				}
				if (prefix == null) {
					prefix = lookupOrDeclarePrefix(namespace);
				}
				// make sure that default ("") namespace to not print ":"
				if (prefix.length() > 0) {
					elPrefix[depth] = prefix;
					out.write(prefix);
					out.write(':');
				} else {
					elPrefix[depth] = "";
				}
			} else {
				// make sure that default namespace can be declared
				for (int i = namespaceEnd - 1; i >= 0; --i) {
					if (namespacePrefix[i] == "") {
						final String uri = namespaceUri[i];
						if (uri == null) {
							setPrefix("", "");
						} else if (uri.length() > 0) {
							throw new IllegalStateException("start tag can not be written in empty default namespace "
									+ "as default namespace is currently bound to '"
									+ uri + "'" + getLocation());
						}
						break;
					}
				}
				elPrefix[depth] = "";
			}
		} else {
			elPrefix[depth] = "";
		}
		out.write(name);
		return this;
	}

	@Override
	public XmlSerializer attribute(String namespace, String name, String value)
			throws IOException {
		if (!startTagIncomplete) {
			throw new IllegalArgumentException("startTag() must be called before attribute()" + getLocation());
		}
		out.write(' ');
		if (namespace != null && namespace.length() > 0) {
			if (!namesInterned) {
				namespace = namespace.intern();
			} else if (checkNamesInterned) {
				checkInterning(namespace);
			}
			String prefix = getPrefix(namespace, false, true);
			if (prefix == null) {
				// needs to declare prefix to hold default namespace
				// NOTE: attributes such as a='b' are in NO namespace
				prefix = generatePrefix(namespace);
			}
			out.write(prefix);
			out.write(':');
		}
		out.write(name);
		out.write('=');
		out.write(attributeUseApostrophe ? '\'' : '"');
		writeAttributeValue(value, out);
		out.write(attributeUseApostrophe ? '\'' : '"');
		return this;
	}

	protected void closeStartTag() throws IOException {
		if (finished) {
			throw new IllegalArgumentException("trying to write past already finished output"
					+ getLocation());
		}
		if (seenBracket) {
			seenBracket = seenBracketBracket = false;
		}
		if (startTagIncomplete || setPrefixCalled) {
			if (setPrefixCalled) {
				throw new IllegalArgumentException("startTag() must be called immediately after setPrefix()"
						+ getLocation());
			}
			if (!startTagIncomplete) {
				throw new IllegalArgumentException("trying to close start tag that is not opened"
						+ getLocation());
			}

			// write all namespace declarations!
			writeNamespaceDeclarations();
			out.write('>');
			elNamespaceCount[depth] = namespaceEnd;
			startTagIncomplete = false;
		}
	}

	protected void writeNamespaceDeclarations() throws IOException {
		for (int i = elNamespaceCount[depth - 1]; i < namespaceEnd; i++) {
			if (doIndent && namespaceUri[i].length() > 40) {
				writeIndent();
				out.write(" ");
			}
			if (namespacePrefix[i] != "") {
				out.write(" xmlns:");
				out.write(namespacePrefix[i]);
				out.write('=');
			} else {
				out.write(" xmlns=");
			}
			out.write(attributeUseApostrophe ? '\'' : '"');

			// NOTE: escaping of namespace value the same way as attributes!!!!
			writeAttributeValue(namespaceUri[i], out);
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
	}

	@Override
	public XmlSerializer endTag(String namespace, String name)
			throws IOException {
		seenBracket = seenBracketBracket = false;
		if (namespace != null) {
			if (!namesInterned) {
				namespace = namespace.intern();
			} else if (checkNamesInterned) {
				checkInterning(namespace);
			}
		}

		if (namespace != elNamespace[depth]) {
			throw new IllegalArgumentException("expected namespace " + printable(elNamespace[depth]) + " and not "
					+ printable(namespace) + getLocation());
		}
		if (name == null) {
			throw new IllegalArgumentException("end tag name can not be null" + getLocation());
		}
		if (checkNamesInterned && namesInterned) {
			checkInterning(name);
		}
		String startTagName = elName[depth];
		if ((!namesInterned && !name.equals(startTagName)) || (namesInterned && name != startTagName)) {
			throw new IllegalArgumentException("expected element name "
					+ printable(elName[depth]) + " and not " + printable(name) + getLocation());
		}
		if (startTagIncomplete) {
			writeNamespaceDeclarations();
			out.write(" />"); // space is added to make it easier to work in XHTML!!!
			--depth;
		} else {
			if (doIndent && seenTag) {
				writeIndent();
			}
			out.write("</");
			String startTagPrefix = elPrefix[depth];
			if (startTagPrefix.length() > 0) {
				out.write(startTagPrefix);
				out.write(':');
			}
			out.write(name);
			out.write('>');
			--depth;
		}
		namespaceEnd = elNamespaceCount[depth];
		startTagIncomplete = false;
		seenTag = true;
		return this;
	}

	@Override
	public XmlSerializer text(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		writeElementContent(text, out);
		return this;
	}

	@Override
	public XmlSerializer text(char[] buf, int start, int len)
			throws IOException {
		if (startTagIncomplete || setPrefixCalled)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		writeElementContent(buf, start, len, out);
		return this;
	}

	@Override
	public void cdsect(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<![CDATA[");
		out.write(text); // escape?
		out.write("]]>");
	}

	@Override
	public void entityRef(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write('&');
		out.write(text); // escape?
		out.write(';');
	}

	@Override
	public void processingInstruction(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<?");
		out.write(text); // escape?
		out.write("?>");
	}

	@Override
	public void comment(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<!--");
		out.write(text); // escape?
		out.write("-->");
	}

	@Override
	public void docdecl(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<!DOCTYPE");
		out.write(text); // escape?
		out.write(">");
	}

	@Override
	public void ignorableWhitespace(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		if (text.length() == 0) {
			throw new IllegalArgumentException("empty string is not allowed for ignorable whitespace" + getLocation());
		}
		out.write(text); // no escape?
	}

	@Override
	public void flush() throws IOException {
		if (!finished && startTagIncomplete)
			closeStartTag();
		out.flush();
	}

	// --- utility methods

	protected void writeAttributeValue(String value, Writer out)
			throws IOException {
		// .[apostrophe and <, & escaped],
		final char quot = attributeUseApostrophe ? '\'' : '"';
		final String quotEntity = attributeUseApostrophe ? "&apos;" : "&quot;";

		int pos = 0;
		for (int i = 0; i < value.length(); i++) {
			char ch = value.charAt(i);
			if (ch == '&') {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write("&amp;");
				pos = i + 1;
			}
			if (ch == '<') {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write("&lt;");
				pos = i + 1;
			} else if (ch == quot) {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write(quotEntity);
				pos = i + 1;
			} else if (ch < 32) {
				// in XML 1.0 only legal character are #x9 | #xA | #xD
				// and they must be escaped otherwise in attribute value they
				// are normalized to spaces
				if (ch == 13 || ch == 10 || ch == 9) {
					if (i > pos)
						out.write(value.substring(pos, i));
					out.write("&#");
					out.write(Integer.toString(ch));
					out.write(';');
					pos = i + 1;
				} else {
					if (TRACE_ESCAPING)
						System.err.println(getClass().getName() + " DEBUG ATTR value.len=" + value.length()
								+ " " + printable(value));

					throw new IllegalStateException(
							"character " + printable(ch) + " (" + Integer.toString(ch) + ") is not allowed in output"
									+ getLocation() + " (attr value="
									+ printable(value) + ")");
				}
			}
		}
		if (pos > 0) {
			out.write(value.substring(pos));
		} else {
			out.write(value); // this is shortcut to the most common case
		}
	}

	protected void writeElementContent(String text, Writer out)
			throws IOException {

		// For some reason, some non-empty, empty characters are surviving this far and getting filtered out
		// So we are left with null, which causes an NPE
		if (text == null) {
			return;
		}

		// escape '<', '&', ']]>', <32 if necessary
		int pos = 0;
		for (int i = 0; i < text.length(); i++) {
			// TODO: check if doing char[] text.getChars() would be faster than
			// getCharAt(i) ...
			char ch = text.charAt(i);
			if (ch == ']') {
				if (seenBracket) {
					seenBracketBracket = true;
				} else {
					seenBracket = true;
				}
			} else {
				if (ch == '&') {
					if (!(i < text.length() - 3 && text.charAt(i+1) == 'l'
					    && text.charAt(i+2) == 't' && text.charAt(i+3) == ';')) {
					    if (i > pos)
					        out.write(text.substring(pos, i));
					    out.write("&amp;");
					    pos = i + 1;
                    }
				} else if (ch == '<') {
					if (i > pos)
						out.write(text.substring(pos, i));
					out.write("&lt;");
					pos = i + 1;
				} else if (seenBracketBracket && ch == '>') {
					if (i > pos)
						out.write(text.substring(pos, i));
					out.write("&gt;");
					pos = i + 1;
				} else if (ch < 32) {
					// in XML 1.0 only legal character are #x9 | #xA | #xD
					if (ch == 9 || ch == 10 || ch == 13) {
						// pass through
					} else {
						if (TRACE_ESCAPING)
							System.err.println(getClass().getName() + " DEBUG TEXT value.len=" + text.length()
									+ " " + printable(text));
						throw new IllegalStateException("character " + Integer.toString(ch)
								+ " is not allowed in output" + getLocation()
								+ " (text value=" + printable(text) + ")");
					}
				}
				if (seenBracket) {
					seenBracketBracket = seenBracket = false;
				}

			}
		}
		if (pos > 0) {
			out.write(text.substring(pos));
		} else {
			out.write(text); // this is shortcut to the most common case
		}

	}

	protected void writeElementContent(char[] buf, int off, int len, Writer out)
			throws IOException {
		// escape '<', '&', ']]>'
		final int end = off + len;
		int pos = off;
		for (int i = off; i < end; i++) {
			final char ch = buf[i];
			if (ch == ']') {
				if (seenBracket) {
					seenBracketBracket = true;
				} else {
					seenBracket = true;
				}
			} else {
				if (ch == '&') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&amp;");
					pos = i + 1;
				} else if (ch == '<') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&lt;");
					pos = i + 1;

				} else if (seenBracketBracket && ch == '>') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&gt;");
					pos = i + 1;
				} else if (ch < 32) {
					// in XML 1.0 only legal character are #x9 | #xA | #xD
					if (ch == 9 || ch == 10 || ch == 13) {
						// pass through
					} else {
						if (TRACE_ESCAPING)
							System.err.println(getClass().getName() + " DEBUG TEXT value.len=" + len + " "
									+ printable(new String(buf, off, len)));
						throw new IllegalStateException("character "
								+ printable(ch) + " (" + Integer.toString(ch)
								+ ") is not allowed in output" + getLocation());
					}
				}
				if (seenBracket) {
					seenBracketBracket = seenBracket = false;
				}
			}
		}
		if (end > pos) {
			out.write(buf, pos, end - pos);
		}
	}

	/** simple utility method -- good for debugging */
	protected static final String printable(String s) {
		if (s == null) {
			return "null";
		}
		StringBuffer retval = new StringBuffer(s.length() + 16);
		retval.append("'");
		for (int i = 0; i < s.length(); i++) {
			addPrintable(retval, s.charAt(i));
		}
		retval.append("'");
		return retval.toString();
	}

	protected static final String printable(char ch) {
		StringBuffer retval = new StringBuffer();
		addPrintable(retval, ch);
		return retval.toString();
	}

	private static void addPrintable(StringBuffer retval, char ch) {
		switch (ch) {
		case '\b':
			retval.append("\\b");
			break;
		case '\t':
			retval.append("\\t");
			break;
		case '\n':
			retval.append("\\n");
			break;
		case '\f':
			retval.append("\\f");
			break;
		case '\r':
			retval.append("\\r");
			break;
		case '\"':
			retval.append("\\\"");
			break;
		case '\'':
			retval.append("\\\'");
			break;
		case '\\':
			retval.append("\\\\");
			break;
		default:
			if (ch < 0x20 || ch > 0x7e) {
				final String ss = "0000" + Integer.toString(ch, 16);
				retval.append("\\u" + ss.substring(ss.length() - 4));
			} else {
				retval.append(ch);
			}
		}
	}
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/main/resources/properties/apktool.properties`:

```properties
application.version=@version@
git.commit.id.abbrev=@gitrev@

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/BaseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.MetaInfo;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.directory.FileDirectory;
import org.custommonkey.xmlunit.*;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class BaseTest {

    protected void compareUnknownFiles() throws BrutException {
        MetaInfo control = new Androlib().readMetaFile(sTestOrigDir);
        MetaInfo test = new Androlib().readMetaFile(sTestNewDir);
        assertNotNull(control.unknownFiles);
        assertNotNull(test.unknownFiles);

        Map<String, String> controlFiles = control.unknownFiles;
        Map<String, String> testFiles = test.unknownFiles;
        assertTrue(controlFiles.size() == testFiles.size());

        // Make sure that the compression methods are still the same
        for (Map.Entry<String, String> controlEntry : controlFiles.entrySet()) {
            assertTrue(controlEntry.getValue().equals(testFiles.get(controlEntry.getKey())));
        }
    }

    protected void compareBinaryFolder(String path, boolean res) throws BrutException, IOException {
        Boolean exists = true;

        String prefixPath = "";
        if (res) {
            prefixPath = File.separatorChar + "res" + File.separatorChar;
        }

        String location = prefixPath + path;

        FileDirectory fileDirectory = new FileDirectory(sTestOrigDir, location);

        Set<String> files = fileDirectory.getFiles(true);
        for (String filename : files) {

            File control = new File((sTestOrigDir + location), filename);
            File test =  new File((sTestNewDir + location), filename);

            if (! test.isFile() || ! control.isFile()) {
                exists = false;
            }
        }

        assertTrue(exists);
    }

    protected void compareResFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(path, true);
    }

    protected void compareLibsFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(File.separatorChar + path, false);
    }

    protected void compareAssetsFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(File.separatorChar + "assets" + File.separatorChar + path, false);
    }

    protected void compareValuesFiles(String path) throws BrutException {
        compareXmlFiles("res/" + path, new ElementNameAndAttributeQualifier("name"));
    }

    protected void compareXmlFiles(String path) throws BrutException {
        compareXmlFiles(path, null);
    }

    protected  void checkFolderExists(String path) {
        File f =  new File(sTestNewDir, path);

        assertTrue(f.isDirectory());
    }

    protected boolean isTransparent(int pixel) {
        return pixel >> 24 == 0x00;
    }

    private void compareXmlFiles(String path, ElementQualifier qualifier) throws BrutException {
        DetailedDiff diff;
        try {
            Reader control = new FileReader(new File(sTestOrigDir, path));
            Reader test = new FileReader(new File(sTestNewDir, path));

            if (qualifier == null) {
                XMLUnit.setIgnoreWhitespace(true);
                XMLUnit.setIgnoreAttributeOrder(true);
                XMLUnit.setCompareUnmatched(false);
                assertXMLEqual(control, test);
                return;
            }

            diff = new DetailedDiff(new Diff(control, test));
        } catch (SAXException | IOException ex) {
            throw new BrutException(ex);
        }

        diff.overrideElementQualifier(qualifier);
        assertTrue(path + ": " + diff.getAllDifferences().toString(), diff.similar());
    }

    protected static ExtFile sTmpDir;
    protected static ExtFile sTestOrigDir;
    protected static ExtFile sTestNewDir;

    protected final static Logger LOGGER = Logger.getLogger(BaseTest.class.getName());
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/TestUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.res.AndrolibResources;
import brut.common.BrutException;
import brut.directory.*;
import java.io.*;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

import brut.util.OS;
import org.custommonkey.xmlunit.ElementQualifier;
import org.w3c.dom.Element;
import org.xmlpull.v1.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public abstract class TestUtils {

    public static Map<String, String> parseStringsXml(File file)
            throws BrutException {
        try {
            XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
            xpp.setInput(new FileReader(file));

            int eventType;
            String key = null;
            Map<String, String> map = new HashMap<String, String>();
            while ((eventType = xpp.next()) != XmlPullParser.END_DOCUMENT) {
                switch (eventType) {
                    case XmlPullParser.START_TAG:
                        if ("string".equals(xpp.getName())) {
                            int attrCount = xpp.getAttributeCount();
                            for (int i = 0; i < attrCount; i++) {
                                if ("name".equals(xpp.getAttributeName(i))) {
                                    key = xpp.getAttributeValue(i);
                                    break;
                                }
                            }
                        }
                        break;
                    case XmlPullParser.END_TAG:
                        if ("string".equals(xpp.getName())) {
                            key = null;
                        }
                        break;
                    case XmlPullParser.TEXT:
                        if (key != null) {
                            map.put(key, xpp.getText());
                        }
                        break;
                }
            }

            return map;
        } catch (IOException | XmlPullParserException ex) {
            throw new BrutException(ex);
        }
    }

    public static void copyResourceDir(Class class_, String dirPath, File out) throws BrutException {
        if (!out.exists()) {
            out.mkdirs();
        }
        copyResourceDir(class_, dirPath, new FileDirectory(out));
    }

    public static void copyResourceDir(Class class_, String dirPath, Directory out) throws BrutException {
        if (class_ == null) {
            class_ = Class.class;
        }

        URL dirURL = class_.getClassLoader().getResource(dirPath);
        if (dirURL != null && dirURL.getProtocol().equals("file")) {
            try {
                DirUtil.copyToDir(new FileDirectory(dirURL.getFile()), out);
            } catch (UnsupportedEncodingException ex) {
                throw new BrutException(ex);
            }
            return;
        }

        if (dirURL == null) {
            String className = class_.getName().replace(".", "/") + ".class";
            dirURL = class_.getClassLoader().getResource(className);
        }

        if (dirURL.getProtocol().equals("jar")) {
            String jarPath;
            try {
                jarPath = URLDecoder.decode(dirURL.getPath().substring(5, dirURL.getPath().indexOf("!")), "UTF-8");
                DirUtil.copyToDir(new FileDirectory(jarPath), out);
            } catch (UnsupportedEncodingException ex) {
                throw new BrutException(ex);
            }
        }
    }

    public static void cleanFrameworkFile() throws BrutException {
        File framework = new File(getFrameworkDir(), "1.apk");

        if (Files.exists(framework.toPath())) {
            OS.rmfile(framework.getAbsolutePath());
        }
    }

    public static byte[] readHeaderOfFile(File file, int size) throws IOException {
        byte[] buffer = new byte[size];
        InputStream inputStream = new FileInputStream(file);
        if (inputStream.read(buffer) != buffer.length) {
            throw new IOException("File size too small for buffer length: " + size);
        }
        inputStream.close();

        return buffer;
    }

    static File getFrameworkDir() throws AndrolibException {
        AndrolibResources androlibResources = new AndrolibResources();
        androlibResources.apkOptions = new ApkOptions();
        return androlibResources.getFrameworkDir();
    }

    public static class ResValueElementQualifier implements ElementQualifier {

        @Override
        public boolean qualifyForComparison(Element control, Element test) {
            String controlType = control.getTagName();
            if ("item".equals(controlType)) {
                controlType = control.getAttribute("type");
            }

            String testType = test.getTagName();
            if ("item".equals(testType)) {
                testType = test.getAttribute("type");
            }

            return controlType.equals(testType) && control.getAttribute("name").equals(test.getAttribute("name"));
        }
    }

    public static String replaceNewlines(String value) {
        return value.replace("\n", "").replace("\r", "");
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/AndroidOreoNotSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class AndroidOreoNotSparseTest extends BaseTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1594-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1594-new");
        LOGGER.info("Unpacking not_sparse.apk...");
        TestUtils.copyResourceDir(AndroidOreoNotSparseTest.class, "aapt1/issue1594", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "not_sparse.apk");

        LOGGER.info("Decoding not_sparse.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building not_sparse.apk...");
        ApkOptions apkOptions = new ApkOptions();
        new Androlib(apkOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/AndroidOreoSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class AndroidOreoSparseTest extends BaseTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1594-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1594-new");
        LOGGER.info("Unpacking sparse.apk...");
        TestUtils.copyResourceDir(AndroidOreoSparseTest.class, "aapt1/issue1594", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "sparse.apk");

        LOGGER.info("Decoding sparse.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building sparse.apk...");
        ApkOptions apkOptions = new ApkOptions();
        new Androlib(apkOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }

    @Test
    public void ensureStringsOreoTest() {
        assertTrue((new File(sTestNewDir, "res/values-v26/strings.xml").isFile()));
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/BuildAndDecodeJarTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class BuildAndDecodeJarTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testjar-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testjar-new");
        LOGGER.info("Unpacking testjar...");
        TestUtils.copyResourceDir(BuildAndDecodeJarTest.class, "aapt1/testjar/", sTestOrigDir);

        LOGGER.info("Building testjar.jar...");
        File testJar = new File(sTmpDir, "testjar.jar");
        new Androlib().build(sTestOrigDir, testJar);

        LOGGER.info("Decoding testjar.jar...");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/BuildAndDecodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;

import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Map;

import brut.util.OSDetection;
import org.junit.*;

import static org.junit.Assert.*;
import static org.junit.Assume.*;

import javax.imageio.ImageIO;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class BuildAndDecodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt1/testapp/", sTestOrigDir);

        LOGGER.info("Building testapp.apk...");
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib().build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void manifestTaggingNotSupressed() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void valuesAnimsTest() throws BrutException {
        compareValuesFiles("values-mcc001/anims.xml");
    }

    @Test
    public void valuesArraysTest() throws BrutException {
        compareValuesFiles("values-mcc001/arrays.xml");
    }

    @Test
    public void valuesArraysCastingTest() throws BrutException {
        compareValuesFiles("values-mcc002/arrays.xml");
        compareValuesFiles("values-mcc003/arrays.xml");
    }

    @Test
    public void valuesAttrsTest() throws BrutException {
        compareValuesFiles("values/attrs.xml");
    }

    @Test
    public void valuesBoolsTest() throws BrutException {
        compareValuesFiles("values-mcc001/bools.xml");
    }

    @Test
    public void valuesColorsTest() throws BrutException {
        compareValuesFiles("values-mcc001/colors.xml");
    }

    @Test
    public void bug702Test() throws BrutException {
        compareValuesFiles("values-mcc001-mnc00/strings.xml");
    }

    @Test
    public void valuesDimensTest() throws BrutException {
        compareValuesFiles("values-mcc001/dimens.xml");
    }

    @Test
    public void valuesDrawablesTest() throws BrutException {
        compareValuesFiles("values-mcc001/drawables.xml");
    }

    @Test
    public void valuesIdsTest() throws BrutException {
        compareValuesFiles("values-mcc001/ids.xml");
    }

    @Test
    public void valuesIntegersTest() throws BrutException {
        compareValuesFiles("values-mcc001/integers.xml");
    }

    @Test
    public void valuesLayoutsTest() throws BrutException {
        compareValuesFiles("values-mcc001/layouts.xml");
    }

    @Test
    public void xmlPluralsTest() throws BrutException {
        compareValuesFiles("values-mcc001/plurals.xml");
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values-mcc001/strings.xml");
    }

    @Test
    public void valuesStylesTest() throws BrutException {
        compareValuesFiles("values-mcc001/styles.xml");
    }

    @Test
    public void valuesReferencesTest() throws BrutException {
        compareValuesFiles("values-mcc002/strings.xml");
    }

    @Test
    public void valuesExtraLongTest() throws BrutException {
        compareValuesFiles("values-en/strings.xml");
    }

    @Test
    public void valuesExtraLongExactLengthTest() throws BrutException {
        Map<String, String> strs = TestUtils.parseStringsXml(new File(sTestNewDir, "res/values-en/strings.xml"));

        // long_string6 should be exactly 0x8888 chars of "a"
        // the valuesExtraLongTest() should handle this
        // but such an edge case, want a specific test
        String aaaa = strs.get("long_string6");
        assertEquals(0x8888, aaaa.length());
    }

    @Test
    public void storedMp3FilesAreNotCompressedTest() throws BrutException {
        ExtFile extFile = new ExtFile(sTmpDir, "testapp.apk");
        Integer built = extFile.getDirectory().getCompressionLevel("res/raw/rain.mp3");
        assertEquals(new Integer(0), built);
    }

    @Test
    public void crossTypeTest() throws BrutException {
        compareValuesFiles("values-mcc003/strings.xml");
        compareValuesFiles("values-mcc003/integers.xml");
        compareValuesFiles("values-mcc003/bools.xml");
    }

    @Test
    public void xmlLiteralsTest() throws BrutException {
        compareXmlFiles("res/xml/literals.xml");
    }

    @Test
    public void xmlReferencesTest() throws BrutException {
        compareXmlFiles("res/xml/references.xml");
    }

    @Test
    public void xmlXsdFileTest() throws BrutException {
        compareXmlFiles("res/xml/ww_box_styles_schema.xsd");
    }

    @Test
    public void xmlIdsEmptyTest() throws BrutException {
        compareXmlFiles("res/values/ids.xml");
    }

    @Test
    public void xmlReferenceAttributeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1040.xml");
    }

    @Test
    public void xmlCustomAttributeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1063.xml");
    }

    @Test
    public void xmlSmallNumbersDontEscapeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1130.xml");
    }

    @Test
    public void xmlUniformAutoTextTest() throws BrutException {
        compareXmlFiles("res/layout/issue1674.xml");
    }

    @Test(expected = AssertionError.class)
    public void xmlFillParentBecomesMatchTest() throws BrutException {
        compareXmlFiles("res/layout/issue1274.xml");
    }

    @Test
    public void xmlCustomAttrsNotAndroidTest() throws BrutException {
        compareXmlFiles("res/layout/issue1157.xml");
    }

    @Test
    public void qualifiersTest() throws BrutException {
        compareValuesFiles("values-mcc004-mnc4-en-rUS-ldrtl-sw100dp-w200dp-h300dp"
                + "-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key"
                + "-navhidden-dpad-v26/strings.xml");
    }

    @Test
    public void shortendedMncTest() throws BrutException {
        compareValuesFiles("values-mcc001-mnc1/strings.xml");
    }

    @Test
    public void shortMncHtcTest() throws BrutException {
        compareValuesFiles("values-mnc1/strings.xml");
    }

    @Test
    public void shortMncv2Test() throws BrutException {
        compareValuesFiles("values-mcc238-mnc6/strings.xml");
    }

    @Test
    public void longMncTest() throws BrutException {
        compareValuesFiles("values-mcc238-mnc870/strings.xml");
    }

    @Test
    public void anyDpiTest() throws BrutException {
        compareValuesFiles("values-watch/strings.xml");
    }

    @Test
    public void packed3CharsTest() throws BrutException {
        compareValuesFiles("values-ast-rES/strings.xml");
    }

    @Test
    public void rightToLeftTest() throws BrutException {
        compareValuesFiles("values-ldrtl/strings.xml");
    }

    @Test
    public void scriptBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+Latn+US/strings.xml");
    }

    @Test
    public void threeLetterLangBcp47Test() throws BrutException {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void androidOStringTest() throws BrutException {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void twoLetterNotHandledAsBcpTest() {
        checkFolderExists("res/values-fr");
    }

    @Test
    public void twoLetterLangBcp47Test() throws BrutException {
        compareValuesFiles("values-en-rUS/strings.xml");
    }

    @Test
    public void variantBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+US+POSIX/strings.xml");
    }

    @Test
    public void fourpartBcp47Test() throws BrutException {
        compareValuesFiles("values-b+ast+Latn+IT+AREVELA/strings.xml");
    }

    @Test
    public void RegionLocaleBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+Latn+419/strings.xml");
    }

    @Test
    public void numericalRegionBcp47Test() throws BrutException {
        compareValuesFiles("values-b+eng+419/strings.xml");
    }

    @Test
    public void api23ConfigurationsTest() throws BrutException {
        compareValuesFiles("values-round/strings.xml");
        compareValuesFiles("values-notround/strings.xml");
    }

    @Test
    public void api26ConfigurationsTest() throws BrutException {
        compareValuesFiles("values-widecg-v26/strings.xml");
        compareValuesFiles("values-lowdr-v26/strings.xml");
        compareValuesFiles("values-nowidecg-v26/strings.xml");
        compareValuesFiles("values-vrheadset-v26/strings.xml");
    }

    @Test
    public void fontTest() throws BrutException {
        File fontXml = new File((sTestNewDir + "/res/font"), "lobster.xml");
        File fontFile = new File((sTestNewDir + "/res/font"), "lobster_regular.otf");

        // Per #1662, ensure font file is not encoded.
        assertTrue(fontXml.isFile());
        compareXmlFiles("/res/font/lobster.xml");

        // If we properly skipped decoding the font (otf) file, this file should not exist
        assertFalse((new File((sTestNewDir + "/res/values"), "fonts.xml")).isFile());
        assertTrue(fontFile.isFile());
    }

    @Test
    public void drawableNoDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-nodpi");
    }

    @Test
    public void drawableAnyDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-anydpi");
    }

    @Test
    public void drawableNumberedDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-534dpi");
    }

    @Test
    public void drawableLdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-ldpi");
    }

    @Test
    public void drawableMdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-mdpi");
    }

    @Test
    public void drawableTvdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-tvdpi");
    }

    @Test
    public void drawableXhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xhdpi");
    }

    @Test
    public void ninePatchImageColorTest() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xhdpi" + slash;

        File control = new File((sTestOrigDir + location), "9patch.9.png");
        File test =  new File((sTestNewDir + location), "9patch.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // lets start with 0,0 - empty
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // then with 30, 0 - black
        assertEquals(controlImage.getRGB(30, 0), testImage.getRGB(30, 0));

        // then 30, 30 - blue
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1508Test() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xhdpi" + slash;

        File control = new File((sTestOrigDir + location), "btn_zoom_up_normal.9.png");
        File test = new File((sTestNewDir + location), "btn_zoom_up_normal.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // 0, 0 = clear
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // 30, 0 = black line
        assertEquals(controlImage.getRGB(0, 30), testImage.getRGB(0, 30));

        // 30, 30 = greyish button
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1511Test() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xxhdpi" + slash;

        File control = new File((sTestOrigDir + location), "textfield_activated_holo_dark.9.png");
        File test = new File((sTestNewDir + location), "textfield_activated_holo_dark.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // Check entire image as we cannot mess this up
        final int w = controlImage.getWidth(),
                  h = controlImage.getHeight();

        final int[] controlImageGrid = controlImage.getRGB(0, 0, w, h, null, 0, w);
        final int[] testImageGrid = testImage.getRGB(0, 0, w, h, null, 0, w);

        for (int i = 0; i < controlImageGrid.length; i++) {
            assertEquals("Image lost Optical Bounds at i = " + i, controlImageGrid[i], testImageGrid[i]);
        }
    }

    @Test
    public void robust9patchTest() throws IOException {
        String[] ninePatches = {"ic_notification_overlay.9.png", "status_background.9.png",
                "search_bg_transparent.9.png", "screenshot_panel.9.png", "recents_lower_gradient.9.png"};

        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xxhdpi" + slash;

        for (String ninePatch : ninePatches) {
            File control = new File((sTestOrigDir + location), ninePatch);
            File test = new File((sTestNewDir + location), ninePatch);

            BufferedImage controlImage = ImageIO.read(control);
            BufferedImage testImage = ImageIO.read(test);

            int w = controlImage.getWidth(), h = controlImage.getHeight();

            // Check the entire horizontal line
            for (int i = 1; i < w; i++) {
                if (isTransparent(controlImage.getRGB(i, 0))) {
                    assertTrue(isTransparent(testImage.getRGB(i, 0)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + i + "," + 0 + ")",
                            controlImage.getRGB(i, 0), testImage.getRGB(i, 0));
                }
            }

            // Check the entire vertical line
            for (int i = 1; i < h; i++) {
                if (isTransparent(controlImage.getRGB(0, i))) {
                    assertTrue(isTransparent(testImage.getRGB(0, i)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + 0 + "," + i + ")",
                            controlImage.getRGB(0, i), testImage.getRGB(0, i));
                }
            }
        }
    }

    @Test
    public void confirmZeroByteFileExtensionIsNotStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);

        for (String item : metaInfo.doNotCompress) {
            assertFalse(item.equals("jpg"));
        }
    }

    @Test
    public void confirmZeroByteFileIsStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertTrue(metaInfo.doNotCompress.contains("assets/0byte_file.jpg"));
    }

    @Test
    public void drawableXxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxhdpi");
    }

    @Test
    public void drawableQualifierXxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxhdpi-v4");
    }

    @Test
    public void drawableXxxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxxhdpi");
    }

    @Test
    public void resRawTest() throws BrutException, IOException {
        compareResFolder("raw");
    }

    @Test
    public void libsTest() throws BrutException, IOException {
        compareLibsFolder("libs");
        compareLibsFolder("lib");
    }

    @Test
    public void unknownFolderTest() throws BrutException {
        compareUnknownFiles();
    }

    @Test
    public void fileAssetTest() throws BrutException, IOException {
        compareAssetsFolder("txt");
    }

    @Test
    public void unicodeAssetTest() throws BrutException, IOException {
        assumeTrue(! OSDetection.isWindows());
        compareAssetsFolder("unicode-txt");
    }

    @Test
    public void multipleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali_classes2", false);
        compareBinaryFolder("/smali_classes3", false);

        File classes2Dex = new File(sTestOrigDir, "build/apk/classes2.dex");
        File classes3Dex = new File(sTestOrigDir, "build/apk/classes3.dex");

        assertTrue(classes2Dex.isFile());
        assertTrue(classes3Dex.isFile());
    }

    @Test
    public void singleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali", false);

        File classesDex = new File(sTestOrigDir, "build/apk/classes.dex");
        assertTrue(classesDex.isFile());
    }

    @Test
    public void confirmKotlinFolderPersistsTest() {
        checkFolderExists("/kotlin");
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/DebugTagRetainedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertTrue;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DebugTagRetainedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1235-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1235-new");
        LOGGER.info("Unpacking issue1235...");
        TestUtils.copyResourceDir(DebugTagRetainedTest.class, "aapt1/issue1235/", sTestOrigDir);

        LOGGER.info("Building issue1235.apk...");
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.debugMode = true;

        File testApk = new File(sTmpDir, "issue1235.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue1235.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue1235-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue1235\" platformBuildVersionCode=\"20\" " +
                "platformBuildVersionName=\"4.4W.2-1537038\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/DefaultBaksmaliVariableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

public class DefaultBaksmaliVariableTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testjar-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testjar-new");
        LOGGER.info("Unpacking testjar...");
        TestUtils.copyResourceDir(DefaultBaksmaliVariableTest.class, "aapt1/issue1481/", sTestOrigDir);

        LOGGER.info("Building issue1481.jar...");
        File testJar = new File(sTmpDir, "issue1481.jar");
        new Androlib().build(sTestOrigDir, testJar);

        LOGGER.info("Decoding issue1481.jar...");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void confirmBaksmaliParamsAreTheSame() throws BrutException, IOException {
        String expected = TestUtils.replaceNewlines(".class public final Lcom/ibotpeaches/issue1481/BuildConfig;\n" +
                ".super Ljava/lang/Object;\n" +
                ".source \"BuildConfig.java\"\n" +
                "\n" +
                "\n" +
                "# static fields\n" +
                ".field public static final APPLICATION_ID:Ljava/lang/String; = \"com.ibotpeaches.issue1481\"\n" +
                "\n" +
                ".field public static final BUILD_TYPE:Ljava/lang/String; = \"debug\"\n" +
                "\n" +
                ".field public static final DEBUG:Z\n" +
                "\n" +
                ".field public static final FLAVOR:Ljava/lang/String; = \"\"\n" +
                "\n" +
                ".field public static final VERSION_CODE:I = 0x1\n" +
                "\n" +
                ".field public static final VERSION_NAME:Ljava/lang/String; = \"1.0\"\n" +
                "\n" +
                "\n" +
                "# direct methods\n" +
                ".method static constructor <clinit>()V\n" +
                "    .locals 1\n" +
                "\n" +
                "    .prologue\n" +
                "    .line 7\n" +
                "    const-string v0, \"true\"\n" +
                "\n" +
                "    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z\n" +
                "\n" +
                "    move-result v0\n" +
                "\n" +
                "    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z\n" +
                "\n" +
                "    return-void\n" +
                ".end method\n" +
                "\n" +
                ".method public constructor <init>()V\n" +
                "    .locals 0\n" +
                "\n" +
                "    .prologue\n" +
                "    .line 6\n" +
                "    invoke-direct {p0}, Ljava/lang/Object;-><init>()V\n" +
                "\n" +
                "    return-void\n" +
                ".end method");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestNewDir + File.separator + "smali" + File.separator
        + "com" + File.separator + "ibotpeaches" + File.separator + "issue1481" + File.separator + "BuildConfig.smali"));

        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/EmptyResourcesArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.ApkOptions;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.util.logging.Logger;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class EmptyResourcesArscTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1730-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1730-new");
        LOGGER.info("Unpacking issue1730.apk...");
        TestUtils.copyResourceDir(EmptyResourcesArscTest.class, "aapt1/issue1730", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "issue1730.apk");

        LOGGER.info("Decoding issue1730.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building issue1730.apk...");
        ApkOptions apkOptions = new ApkOptions();
        new Androlib(apkOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }

    private static ExtFile sTmpDir;
    private static ExtFile sTestOrigDir;
    private static ExtFile sTestNewDir;

    private final static Logger LOGGER = Logger.getLogger(EmptyResourcesArscTest.class.getName());
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/LargeIntsInManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;

public class LargeIntsInManifestTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(LargeIntsInManifestTest.class, "aapt1/issue767/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfLargeIntsAreHandledTest() throws BrutException, IOException {
        String apk = "issue767.apk";

        // decode issue767.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        // build issue767
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;

        // decode issue767 again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out.two");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.decode();

        compareXmlFiles("AndroidManifest.xml");
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/ProviderAttributeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

public class ProviderAttributeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws BrutException {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ProviderAttributeTest.class, "aapt1/issue636/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void isProviderStringReplacementWorking() throws BrutException, IOException, SAXException {
        String apk = "issue636.apk";

        // decode issue636.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        // build issue636
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;
        assertTrue(fileExists(newApk));

        // decode issues636 again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.decode();

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue636\" platformBuildVersionCode=\"22\" platformBuildVersionName=\"5.1-1756733\">\n" +
                "    <application android:allowBackup=\"true\" android:debuggable=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\">\n" +
                "        <provider android:authorities=\"com.ibotpeaches.issue636.Provider\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.Provider\"/>\n" +
                "        <provider android:authorities=\"com.ibotpeaches.issue636.ProviderTwo\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.ProviderTwo\"/>\n" +
                "    </application>\n" +
                "</manifest>");


        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + ".out.two" + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/ReferenceVersionCodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class ReferenceVersionCodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ReferenceVersionCodeTest.class, "aapt1/issue1234/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void referenceBecomesLiteralTest() throws BrutException, IOException {
        String apk = "issue1234.apk";

        // decode issue1234.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        assertEquals("v1.0.0", metaInfo.versionInfo.versionName);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/SharedLibraryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertTrue;

public class SharedLibraryTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws BrutException {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(SharedLibraryTest.class, "aapt1/shared_libraries/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void isFrameworkTaggingWorking() throws AndrolibException {
        String apkName = "library.apk";

        ApkOptions apkOptions = new ApkOptions();
        apkOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();
        apkOptions.frameworkTag = "building";

        new Androlib(apkOptions).installFramework(new File(sTmpDir + File.separator + apkName));

        assertTrue(fileExists("2-building.apk"));
    }

    @Test
    public void isFrameworkInstallingWorking() throws AndrolibException {
        String apkName = "library.apk";

        ApkOptions apkOptions = new ApkOptions();
        apkOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();

        new Androlib(apkOptions).installFramework(new File(sTmpDir + File.separator + apkName));

        assertTrue(fileExists("2.apk"));
    }

    @Test
    public void isSharedResourceDecodingAndRebuildingWorking() throws IOException, BrutException {
        String library = "library.apk";
        String client = "client.apk";

        // setup apkOptions
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();
        apkOptions.frameworkTag = "shared";

        // install library/framework
        new Androlib(apkOptions).installFramework(new File(sTmpDir + File.separator + library));
        assertTrue(fileExists("2-shared.apk"));

        // decode client.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + client));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + client + ".out"));
        apkDecoder.setFrameworkDir(apkOptions.frameworkFolderLocation);
        apkDecoder.setFrameworkTag(apkOptions.frameworkTag);
        apkDecoder.decode();

        // decode library.apk
        ApkDecoder libraryDecoder = new ApkDecoder(new File(sTmpDir + File.separator + library));
        libraryDecoder.setOutDir(new File(sTmpDir + File.separator + library + ".out"));
        libraryDecoder.setFrameworkDir(apkOptions.frameworkFolderLocation);
        libraryDecoder.setFrameworkTag(apkOptions.frameworkTag);
        libraryDecoder.decode();

        // build client.apk
        ExtFile clientApk = new ExtFile(sTmpDir, client + ".out");
        new Androlib(apkOptions).build(clientApk, null);
        assertTrue(fileExists(client + ".out" + File.separator + "dist" + File.separator + client));

        // build library.apk (shared library)
        ExtFile libraryApk = new ExtFile(sTmpDir, library + ".out");
        new Androlib(apkOptions).build(libraryApk, null);
        assertTrue(fileExists(library + ".out" + File.separator + "dist" + File.separator + library));
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/SkipAssetTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;
import static org.junit.Assert.*;

public class SkipAssetTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(SkipAssetTest.class, "aapt1/issue1605/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfEnablingSkipAssetWorks() throws BrutException, IOException {
        String apk = "issue1605.apk";

        // decode issue1605.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(sTestOrigDir);
        apkDecoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_NONE);
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        checkFileDoesNotExist("assets" + File.separator + "kotlin.kotlin_builtins");
        checkFileDoesNotExist("assets" + File.separator + "ranges" + File.separator + "ranges.kotlin_builtins");
    }

    @Test
    public void checkControl() throws BrutException, IOException {
        String apk = "issue1605.apk";

        // decode issue1605.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(sTestOrigDir);
        apkDecoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_FULL);
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        checkFileDoesExist("assets" + File.separator + "kotlin.kotlin_builtins");
        checkFileDoesExist("assets" + File.separator + "ranges" + File.separator + "ranges.kotlin_builtins");
    }

    private void checkFileDoesNotExist(String path) throws BrutException {
        File f =  new File(sTestOrigDir, path);

        assertFalse(f.isFile());
    }

    private void checkFileDoesExist(String path) throws BrutException {
        File f =  new File(sTestOrigDir, path);

        assertTrue(f.isFile());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/UnknownCompressionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotSame;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class UnknownCompressionTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(UnknownCompressionTest.class, "aapt1/unknown_compression/", sTmpDir);

        String apk = "deflated_unknowns.apk";
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();

        sTestOrigDir = new ExtFile(sTmpDir, apk);

        // decode deflated_unknowns.apk
        ApkDecoder apkDecoder = new ApkDecoder(sTestOrigDir);
        apkDecoder.setOutDir(new File(sTestOrigDir.getAbsolutePath() + ".out"));
        apkDecoder.decode();

        // build deflated_unknowns
        ExtFile clientApkFolder = new ExtFile(sTestOrigDir.getAbsolutePath() + ".out");
        new Androlib(apkOptions).build(clientApkFolder, null);
        sTestNewDir = new ExtFile(clientApkFolder, "dist" + File.separator + apk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void pkmExtensionDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("assets/bin/Data/test.pkm");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("assets/bin/Data/test.pkm");

        // Check that control = rebuilt (both deflated)
        // Add extra check for checking not equal to 0, just in case control gets broken
        assertEquals(control, rebuilt);
        assertNotSame(0, rebuilt);
    }

    @Test
    public void doubleExtensionStoredTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("assets/bin/Data/two.extension.file");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("assets/bin/Data/two.extension.file");

        // Check that control = rebuilt (both stored)
        // Add extra check for checking = 0 to enforce check for stored just in case control breaks
        assertEquals(control, rebuilt);
        assertEquals(new Integer(0), rebuilt);
    }

    @Test
    public void confirmJsonFileIsDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("test.json");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("test.json");

        assertEquals(control, rebuilt);
        assertEquals(new Integer(8), rebuilt);
    }

    @Test
    public void confirmPngFileIsCorrectlyDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("950x150.png");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("950x150.png");

        assertEquals(control, rebuilt);
        assertEquals(new Integer(8), rebuilt);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/BuildAndDecodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.meta.MetaInfo;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class BuildAndDecodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt2/testapp/", sTestOrigDir);

        ApkOptions apkOptions = new ApkOptions();
        apkOptions.useAapt2 = true;
        apkOptions.verbose = true;

        LOGGER.info("Building testapp.apk...");
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values/strings.xml");
    }

    @Test
    public void valuesMaxLengthTest() throws BrutException {
        compareValuesFiles("values-es/strings.xml");
    }

    @Test
    public void confirmZeroByteFileExtensionIsNotStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertFalse(metaInfo.doNotCompress.contains("jpg"));
    }

    @Test
    public void confirmZeroByteFileIsStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertTrue(metaInfo.doNotCompress.contains("assets/0byte_file.jpg"));
    }

    @Test
    public void navigationResourceTest() throws BrutException {
        compareXmlFiles("res/navigation/nav_graph.xml");
    }

    @Test
    public void xmlIdsEmptyTest() throws BrutException {
        compareXmlFiles("res/values/ids.xml");
    }

    @Test
    public void leadingDollarSignResourceNameTest() throws BrutException {
        compareXmlFiles("res/drawable/$avd_hide_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__1.xml");
        compareXmlFiles("res/drawable/$avd_show_password__2.xml");
        compareXmlFiles("res/drawable/avd_show_password.xml");
    }

    @Test
    public void samsungQmgFilesHandledTest() throws IOException, BrutException {
        compareBinaryFolder("drawable-xhdpi", true);
    }

    @Test
    public void confirmManifestStructureTest() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void xmlXsdFileTest() throws BrutException {
        compareXmlFiles("res/xml/ww_box_styles_schema.xsd");
    }

    @Test
    public void multipleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali_classes2", false);
        compareBinaryFolder("/smali_classes3", false);

        File classes2Dex = new File(sTestOrigDir, "build/apk/classes2.dex");
        File classes3Dex = new File(sTestOrigDir, "build/apk/classes3.dex");

        assertTrue(classes2Dex.isFile());
        assertTrue(classes3Dex.isFile());
    }

    @Test
    public void singleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali", false);

        File classesDex = new File(sTestOrigDir, "build/apk/classes.dex");
        assertTrue(classesDex.isFile());
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableFalseChangeToTrueTest.java`:

```java
/**
 *  Copyright (C) 2019 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2019 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DebuggableFalseChangeToTrueTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-false-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-flase-new");
        LOGGER.info("Unpacking issue2328-debuggable-flase...");
        TestUtils.copyResourceDir(DebuggableFalseChangeToTrueTest.class, "aapt2/issue2328/debuggable-false", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-flase.apk...");
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.debugMode = true;
        apkOptions.useAapt2 = true;
        apkOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-flase.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-flase.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-flase-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableTrueAddedTest.java`:

```java
/**
 *  Copyright (C) 2019 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2019 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DebuggableTrueAddedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-missing-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-missing-new");
        LOGGER.info("Unpacking issue2328-debuggable-missing...");
        TestUtils.copyResourceDir(DebuggableTrueAddedTest.class, "aapt2/issue2328/debuggable-missing", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-missing.apk...");
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.debugMode = true;
        apkOptions.useAapt2 = true;
        apkOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-missing.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-missing.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-missing-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableTrueRetainedTest.java`:

```java
/**
 *  Copyright (C) 2019 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2019 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DebuggableTrueRetainedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-true-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-true-new");
        LOGGER.info("Unpacking issue2328-debuggable-true...");
        TestUtils.copyResourceDir(DebuggableTrueRetainedTest.class, "aapt2/issue2328/debuggable-true", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-true.apk...");
        ApkOptions apkOptions = new ApkOptions();
        apkOptions.debugMode = true;
        apkOptions.useAapt2 = true;
        apkOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-true.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-true.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-true-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/NonStandardPkgIdTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.res.data.ResTable;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.*;

public class NonStandardPkgIdTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTmpDir.deleteOnExit();

        sTestOrigDir = new ExtFile(sTmpDir, "pkgid8-orig");
        sTestNewDir = new ExtFile(sTmpDir, "pkgid8-new");
        LOGGER.info("Unpacking pkgid8...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt2/pkgid8/", sTestOrigDir);

        ApkOptions apkOptions = new ApkOptions();
        apkOptions.useAapt2 = true;
        apkOptions.verbose = true;

        LOGGER.info("Building pkgid8.apk...");
        File testApk = new File(sTmpDir, "pkgid8.apk");
        new Androlib(apkOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding pkgid8.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
        mResTable = apkDecoder.getResTable();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values/strings.xml");
    }

    @Test
    public void confirmManifestStructureTest() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void confirmResourcesAreFromPkgId8() throws AndrolibException {
        assertEquals(0x80, mResTable.getPackageId());

        assertEquals(0x80, mResTable.getResSpec(0x80020000).getPackage().getId());
        assertEquals(0x80, mResTable.getResSpec(0x80020001).getPackage().getId());
        assertEquals(0x80, mResTable.getResSpec(0x80030000).getPackage().getId());
    }

    private static ResTable mResTable;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/androlib/InvalidSdkBoundingTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.androlib;

import brut.androlib.BaseTest;
import brut.androlib.res.AndrolibResources;
import java.util.LinkedHashMap;
import java.util.Map;

import org.junit.*;

import static org.junit.Assert.assertEquals;

public class InvalidSdkBoundingTest extends BaseTest {

    @Test
    public void checkIfInvalidValuesPass() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("minSdkVersion", "15");
        sdkInfo.put("targetSdkVersion", "25");
        sdkInfo.put("maxSdkVersion", "19");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("19", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingMinPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "25");
        sdkInfo.put("maxSdkVersion", "19");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("19", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingMaxPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("minSdkVersion", "15");
        sdkInfo.put("targetSdkVersion", "25");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("25", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingBothPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "25");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("25", androlibResources.checkTargetSdkVersionBounds());
    }


    @Test
    public void checkForShortHandSdkTag() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "O");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("26", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkForSdkDevelopmentInsaneTestValue() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "S");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("10000", androlibResources.checkTargetSdkVersionBounds());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/AndResGuardTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;
import static org.junit.Assert.*;

public class AndResGuardTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(AndResGuardTest.class, "decode/issue1170/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkifAndResDecodeRemapsRFolder() throws BrutException, IOException {
        String apk = "issue1170.apk";

        // decode issue1170.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        File aPng =  new File(sTestOrigDir,"res/mipmap-hdpi-v4/a.png");
        assertTrue(aPng.isFile());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeArrayTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.data.value.ResArrayValue;
import brut.androlib.res.data.value.ResValue;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static junit.framework.Assert.assertTrue;

public class DecodeArrayTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingVersionManifestTest.class, "decode/issue1994/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void decodeStringArray() throws BrutException {
        String apk = "issue1994.apk";
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));

        ResTable resTable = apkDecoder.getResTable();
        ResValue value = resTable.getResSpec(0x7f020001).getDefaultResource().getValue();

        assertTrue("Not a ResArrayValue. Found: " + value.getClass(), value instanceof ResArrayValue);
    }

    @Test
    public void decodeArray() throws BrutException {
        String apk = "issue1994.apk";
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));

        ResTable resTable = apkDecoder.getResTable();
        ResValue value = resTable.getResSpec(0x7f020000).getDefaultResource().getValue();

        assertTrue("Not a ResArrayValue. Found: " + value.getClass(), value instanceof ResArrayValue);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeKotlinCoroutinesTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import brut.androlib.Androlib;
import brut.androlib.AndrolibException;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.util.OS;

import static org.junit.Assert.assertTrue;

/**
 * @author Adib Faramarzi <adibfara@gmail.com>
 */
public class DecodeKotlinCoroutinesTest extends BaseTest {
    private static String apk = "test-kotlin-coroutines.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DecodeKotlinCoroutinesTest.class, "decode/kotlin-coroutines/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }


    @Test
    public void kotlinCoroutinesDecodeTest() throws IOException, AndrolibException, DirectoryException {

        // decode kotlin coroutines
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();
        File coroutinesExceptionHandler = new File(sTmpDir + File.separator + apk + ".out" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.CoroutineExceptionHandler");
        File coroutinenMainDispatcherHandler = new File(sTmpDir + File.separator + apk + ".out" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.internal.MainDispatcherFactory");

        assert (coroutinesExceptionHandler.exists());
        assert (coroutinenMainDispatcherHandler.exists());
    }

    @Test
    public void kotlinCoroutinesEncodeAfterDecodeTest() throws IOException, BrutException {

        // decode kotlin coroutines
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        // build kotlin coroutines
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;
        assertTrue(fileExists(newApk));

        // decode kotlin coroutines again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + ".out.two" + File.separator + "AndroidManifest.xml"));
        File coroutinesExceptionHandler = new File(sTmpDir + File.separator + apk + ".out.two" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.CoroutineExceptionHandler");
        File coroutinenMainDispatcherHandler = new File(sTmpDir + File.separator + apk + ".out.two" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.internal.MainDispatcherFactory");

        assert (coroutinesExceptionHandler.exists());
        assert (coroutinenMainDispatcherHandler.exists());
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeKotlinTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.apache.commons.io.FileUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DecodeKotlinTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DecodeKotlinTest.class, "decode/testkotlin/", sTmpDir);

        String apk = "testkotlin.apk";

        // decode testkotlin.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void kotlinFolderExistsTest() {
        assertTrue(sTestNewDir.isDirectory());

        File testKotlinFolder = new File(sTestNewDir, "kotlin");
        assertTrue(testKotlinFolder.isDirectory());
    }

    @Test
    public void kotlinDecodeTest() throws IOException {
        File kotlinActivity = new File(sTestNewDir, "smali/org/example/kotlin/mixed/KotlinActivity.smali");

        assertTrue(FileUtils.readFileToString(kotlinActivity).contains("KotlinActivity.kt"));
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DoubleExtensionUnknownFileTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.apache.commons.lang3.StringUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class DoubleExtensionUnknownFileTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DoubleExtensionUnknownFileTest.class, "decode/issue1244/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void multipleExtensionUnknownFileTest() throws BrutException, IOException {
        String apk = "issue1244.apk";

        // decode issue1244.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        for (String string : metaInfo.doNotCompress) {
            if (StringUtils.countMatches(string, ".") > 1) {
                assertTrue(string.equalsIgnoreCase("assets/bin/Data/sharedassets1.assets.split0"));
            }
        }
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DuplicateDexTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.*;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.*;

import java.io.File;
import java.io.IOException;


public class DuplicateDexTest extends BaseTest {

    @Before
    public void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "duplicatedex-orig");
        sTestNewDir = new ExtFile(sTmpDir, "duplicatedex-new");
        LOGGER.info("Unpacking duplicatedex.apk...");
        TestUtils.copyResourceDir(DuplicateDexTest.class, "decode/duplicatedex", sTestOrigDir);
    }

    @After
    public void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test(expected = AndrolibException.class)
    public void decodeAllSourcesShouldThrowException() throws BrutException, IOException {
        File testApk = new File(sTestOrigDir, "duplicatedex.apk");

        LOGGER.info("Decoding duplicatedex.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building duplicatedex.apk...");
        ApkOptions apkOptions = new ApkOptions();
        new Androlib(apkOptions).build(sTestNewDir, testApk);
    }

    @Test
    public void decodeUsingOnlyMainClassesMode() throws BrutException, IOException {
        File testApk = new File(sTestOrigDir, "duplicatedex.apk");

        LOGGER.info("Decoding duplicatedex.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building duplicatedex.apk...");
        ApkOptions apkOptions = new ApkOptions();
        new Androlib(apkOptions).build(sTestNewDir, testApk);
    }

}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/Empty9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class Empty9PatchTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(Empty9PatchTest.class, "decode/empty9patch/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void decodeWithEmpty9PatchFile() throws BrutException, IOException {
        String apk = "empty9patch.apk";

        // decode empty9patch.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        File aPng =  new File(sTestOrigDir,"res/drawable-xhdpi/empty.9.png");
        assertTrue(aPng.isFile());
        assertTrue(aPng.length() == 0);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ExternalEntityTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class ExternalEntityTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ExternalEntityTest.class, "decode/doctype/", sTestOrigDir);

        LOGGER.info("Building doctype.apk...");
        File testApk = new File(sTestOrigDir, "doctype.apk");
        new Androlib().build(sTestOrigDir, testApk);

        LOGGER.info("Decoding doctype.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(new File(sTestOrigDir + File.separator + "output"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTestOrigDir);
    }

    @Test
    public void doctypeTest() throws IOException {

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                "<manifest android:versionCode=\"1\" android:versionName=\"1.0\" android:compileSdkVersion=\"23\" android:compileSdkVersionCodename=\"6.0-2438415\" " +
                "hardwareAccelerated=\"true\" package=\"com.ibotpeaches.doctype\" platformBuildVersionCode=\"24\" platformBuildVersionName=\"6.0-2456767\"  " +
                "xmlns:android=\"http://schemas.android.com/apk/res/android\">    <supports-screens android:anyDensity=\"true\" android:smallScreens=\"true\" " +
                "android:normalScreens=\"true\" android:largeScreens=\"true\" android:resizeable=\"true\" android:xlargeScreens=\"true\" /></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestOrigDir + File.separator + "output" + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ForceManifestDecodeNoResourcesTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class ForceManifestDecodeNoResourcesTest extends BaseTest {

    private byte[] xmlHeader = new byte[] {
            0x3C, // <
            0x3F, // ?
            0x78, // x
            0x6D, // m
            0x6C, // l
            0x20, // (empty)
    };

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ForceManifestDecodeNoResourcesTest.class, "decode/issue1680/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfForceManifestWithNoResourcesWorks() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_NONE,
                ApkDecoder.FORCE_DECODE_MANIFEST_FULL, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertTrue(Arrays.equals(this.xmlHeader, magic));

        // confirm resources.arsc still exists, as its raw
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertTrue(resourcesArsc.isFile());
    }

    @Test
    public void checkIfForceManifestWorksWithNoChangeToResources() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_FULL,
                ApkDecoder.FORCE_DECODE_MANIFEST_FULL, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertTrue(Arrays.equals(this.xmlHeader, magic));

        // confirm resources.arsc does not exist
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertFalse(resourcesArsc.isFile());
    }

    @Test
    public void checkForceManifestToFalseWithResourcesEnabledIsIgnored() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_FULL,
                ApkDecoder.FORCE_DECODE_MANIFEST_NONE, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertTrue(Arrays.equals(this.xmlHeader, magic));

        // confirm resources.arsc does not exist
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertFalse(resourcesArsc.isFile());
    }

    @Test
    public void checkBothManifestAndResourcesSetToNone() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_NONE,
                ApkDecoder.FORCE_DECODE_MANIFEST_NONE, output);

        // lets probe filetype of manifest, we should not detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertFalse(Arrays.equals(this.xmlHeader, magic));

        // confirm resources.arsc exists
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertTrue(resourcesArsc.isFile());
    }

    private void decodeFile(String apk, short decodeResources, short decodeManifest, String output)
            throws BrutException, IOException {
        ApkDecoder apkDecoder = new ApkDecoder(new File(apk));
        apkDecoder.setDecodeResources(decodeResources);
        apkDecoder.setForceDecodeManifest(decodeManifest);
        apkDecoder.setForceDelete(true); // delete directory due to multiple tests.

        apkDecoder.setOutDir(new File(output));
        apkDecoder.decode();
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MinifiedArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class MinifiedArscTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MinifiedArscTest.class, "decode/issue1157/", sTmpDir);

        String apk = "issue1157.apk";
        sTestNewDir = new ExtFile(sTmpDir, "issue1157");

        // decode issue1157.apk
        ApkDecoder apkDecoder = new ApkDecoder(new ExtFile(sTmpDir, apk));
        apkDecoder.setForceDelete(true);
        apkDecoder.setOutDir(sTestNewDir);

        // this should not raise an exception:
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfMinifiedArscLayoutFileMatchesTest() throws IOException {
        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
                "<LinearLayout n1:orientation=\"vertical\" n1:layout_width=\"fill_parent\" n1:layout_height=\"fill_parent\"\n" +
                "  xmlns:n1=\"http://schemas.android.com/apk/res/android\">\n" +
                "    <com.ibotpeaches.issue1157.MyCustomView n1:max=\"100\" n2:default_value=\"1.0\" n2:max_value=\"5.0\" n2:min_value=\"0.2\" xmlns:n2=\"http://schemas.android.com/apk/res-auto\" />\n" +
                "</LinearLayout>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestNewDir + File.separator + "res" + File.separator + "xml" + File.separator + "custom.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MissingDiv9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.res.decoder.Res9patchStreamDecoder;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;

import static org.junit.Assert.*;

public class MissingDiv9PatchTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingDiv9PatchTest.class, "decode/issue1522/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void assertMissingDivAdded() throws Exception {
        InputStream inputStream = getFileInputStream();
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        Res9patchStreamDecoder decoder = new Res9patchStreamDecoder();
        decoder.decode(inputStream, outputStream);

        BufferedImage image = ImageIO.read(new ByteArrayInputStream(outputStream.toByteArray()));
        int height = image.getHeight() - 1;

        // First and last pixel will be invisible, so lets check the first column and ensure its all black
        for (int y = 1; y < height; y++) {
            assertEquals("y coordinate failed at: " + y, NP_COLOR, image.getRGB(0, y));
        }

    }

    private FileInputStream getFileInputStream() throws IOException {
        File file = new File(sTmpDir, "pip_dismiss_scrim.9.png");
        return new FileInputStream(file.toPath().toString());
    }

    private static final int NP_COLOR = 0xff000000;
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MissingVersionManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class MissingVersionManifestTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingVersionManifestTest.class, "decode/issue1264/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void missingVersionParsesCorrectlyTest() throws BrutException, IOException {
        String apk = "issue1264.apk";

        // decode issue1264.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        assertEquals(null, metaInfo.versionInfo.versionName);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/OutsideOfDirectoryEntryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class OutsideOfDirectoryEntryTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(OutsideOfDirectoryEntryTest.class, "decode/issue1589/", sTmpDir);

        String apk = "issue1589.apk";

        // decode issue1589.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void skippedDecodingOfInvalidFileTest() {
        assertTrue(sTestNewDir.isDirectory());

        File testAssetFolder = new File(sTestNewDir, "assets");
        assertFalse(testAssetFolder.isDirectory());
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ParentDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

public class ParentDirectoryTraversalTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ParentDirectoryTraversalTest.class, "decode/issue1498/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws BrutException, IOException {
        String apk = "issue1498.apk";

        // decode issue1498.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setDecodeResources(ApkDecoder.DECODE_RESOURCES_NONE);

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));

        // this should not raise an exception:
        apkDecoder.decode();
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/VectorDrawableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class VectorDrawableTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(VectorDrawableTest.class, "decode/issue1456/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws BrutException, IOException {
        String apk = "issue1456.apk";

        // decode issue1456.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        checkFileExists("res/drawable/ic_arrow_drop_down_black_24dp.xml");
        checkFileExists("res/drawable/ic_android_black_24dp.xml");
    }

    private void checkFileExists(String path) {
        File f =  new File(sTestOrigDir, path);

        assertTrue(f.isFile());
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/encoders/PositionalEnumerationTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.encoders;

import brut.androlib.BaseTest;
import brut.androlib.res.xml.ResXmlEncoders;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class PositionalEnumerationTest extends BaseTest {

    @Test
    public void noArgumentsTest() {
        assertEquals("test", enumerateArguments("test"));
    }

    @Test
    public void twoArgumentsTest() {
        assertEquals("%1$s, %2$s, and 1 other.", enumerateArguments("%s, %s, and 1 other."));
    }

    @Test
    public void twoPositionalArgumentsTest() {
        assertEquals("%1$s, %2$s and 1 other", enumerateArguments("%1$s, %2$s and 1 other"));
    }

    @Test
    public void threeArgumentsTest() {
        assertEquals("%1$s, %2$s, and %3$d other.", enumerateArguments("%s, %s, and %d other."));
    }

    @Test
    public void threePositionalArgumentsTest() {
        assertEquals(" %1$s, %2$s and %3$d other", enumerateArguments(" %1$s, %2$s and %3$d other"));
    }

    @Test
    public void fourArgumentsTest() {
        assertEquals("%1$s, %2$s, and %3$d other and %4$d.", enumerateArguments("%s, %s, and %d other and %d."));
    }

    @Test
    public void fourPositionalArgumentsTest() {
        assertEquals(" %1$s, %2$s and %3$d other and %4$d.", enumerateArguments(" %1$s, %2$s and %3$d other and %4$d."));
    }

    private String enumerateArguments(String value) {
        return ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(value);
    }
}
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/util/AaptVersionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.util;

import brut.common.BrutException;
import brut.util.AaptManager;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class AaptVersionTest {

    @Test
    public void testAapt2Iterations() throws BrutException {
        assertEquals(2, AaptManager.getAppVersionFromString("Android Asset Packaging Tool (aapt) 2:17"));
        assertEquals(2, AaptManager.getAppVersionFromString("Android Asset Packaging Tool (aapt) 2.17"));
        assertEquals(1, AaptManager.getAppVersionFromString("Android Asset Packaging Tool, v0.9"));
        assertEquals(1, AaptManager.getAppVersionFromString("Android Asset Packaging Tool, v0.2-2679779"));
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/java/brut/androlib/util/UnknownDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.util;

import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import brut.directory.ExtFile;
import brut.util.BrutIO;
import brut.util.OS;
import brut.util.OSDetection;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/**
 * @author Connor Tumbleson <connor.tumbleson@gmail.com>
 */
public class UnknownDirectoryTraversalTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(UnknownDirectoryTraversalTest.class, "util/traversal", sTmpDir);
    }

    @Test
    public void validFileTest() throws IOException, BrutException {
        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, "file");
        assertEquals(validFilename, "file");

        File validFile = new File(sTmpDir, validFilename);
        assertTrue(validFile.isFile());
    }

    @Test(expected = TraversalUnknownFileException.class)
    public void invalidBackwardFileTest() throws IOException, BrutException {
        BrutIO.sanitizeUnknownFile(sTmpDir, "../file");
    }

    @Test(expected = RootUnknownFileException.class)
    public void invalidRootFileTest() throws IOException, BrutException {
        String rootLocation = OSDetection.isWindows() ? "C:/" : File.separator;
        BrutIO.sanitizeUnknownFile(sTmpDir, rootLocation + "file");
    }

    @Test(expected = InvalidUnknownFileException.class)
    public void noFilePassedTest() throws IOException, BrutException {
        BrutIO.sanitizeUnknownFile(sTmpDir, "");
    }

    @Test(expected = TraversalUnknownFileException.class)
    public void invalidBackwardPathOnWindows() throws IOException, BrutException {
        String invalidPath;
        if (! OSDetection.isWindows()) {
            invalidPath = "../../app";
        } else {
            invalidPath = "..\\..\\app.exe";
        }

        BrutIO.sanitizeUnknownFile(sTmpDir, invalidPath);
    }

    @Test
    public void validDirectoryFileTest() throws IOException, BrutException {
        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, "dir" + File.separator + "file");
        assertEquals("dir" + File.separator + "file", validFilename);
    }
}

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue1235" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="false"/>
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue1235.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/issue1481/apktool.yml`:

```yml
version: 2.2.3
apkFileName: issue1481.jar
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/issue1481/smali/com/ibotpeaches/issue1481/BuildConfig.smali`:

```smali
.class public final Lcom/ibotpeaches/issue1481/BuildConfig;
.super Ljava/lang/Object;
.source "BuildConfig.java"


# static fields
.field public static final APPLICATION_ID:Ljava/lang/String; = "com.ibotpeaches.issue1481"

.field public static final BUILD_TYPE:Ljava/lang/String; = "debug"

.field public static final DEBUG:Z

.field public static final FLAVOR:Ljava/lang/String; = ""

.field public static final VERSION_CODE:I = 0x1

.field public static final VERSION_NAME:Ljava/lang/String; = "1.0"


# direct methods
.method static constructor <clinit>()V
    .registers 1

    .prologue
    .line 7
    const-string v0, "true"

    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z

    move-result v0

    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z

    return-void
.end method

.method public constructor <init>()V
    .registers 1

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:appCategory="game" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <uses-feature android:glEsVersion="0x00020000" />
    <uses-feature android:glEsVersion="0x00030002" />
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
doNotCompress:
- assets/0byte_file.jpg
- arsc
- png
- mp3
unknownFiles:
  hidden.file: '8'
  non\u007Fprintable.file: '8'
  stored.file: '0'
  unk_folder/unknown_file: '8'
  lib_bug603/bug603: '8'
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/assets/txt/no-unicode.txt`:

```txt
This is an empty file.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/assets/unicode-txt/∂-unicode.txt`:

```txt
∂ char.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/font/lobster.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/lobster_regular" />
</font-family>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1040.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:gravity="@integer/reference_test"
    />
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1063.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:custom="http://schemas.android.com/apk/res-auto">
    <TextView custom:test_attr11="TEST_ONE" />
    <TextView custom:test_attr11="TEST_ZERO" />
</LinearLayout>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1130.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android">
    <TableLayout android:shrinkColumns="1" />
    <TableLayout android:shrinkColumns="\ 2147483647" />
    <TableLayout android:shrinkColumns="\ 2147483648" />
    <TableLayout android:shrinkColumns="\ 555555555555555555" />
</LinearLayout>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1157.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen android:title="test" app:min_value="0.2" app:max_value="5.0" app:default_value="1.0"
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res/brut.apktool.testapp" />
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1274.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">
</LinearLayout>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1674.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android" android:autoSizeTextType="uniform" />
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/raw/no_extension`:

```
This file has no extension.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ar-rXB/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">"‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test2">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬\n.‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏</string>
    <string name="test3">          (string8) "‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test4">Forgot your username or password?\nVisit google.com/accounts/recovery.</string>
    <string name="test5">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏
        ‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ast-rES/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ast/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+ast+Latn+IT+AREVELA/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+Latn+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+Latn+US/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+US+POSIX/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+eng+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-en-rUS/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-en/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string1">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</string>
    <string name="long_string2">6AFlEYGyrlcU1nFfzjqa1PcHc4TaP1NwQSmwCrbzHhs5gMXW4caYJd0saK1dsDSuH0YUIvObu8OdH9O9yy569KhrIPTmJWJn4Y1wp3Lp7LGbElGPuD3iqJb0uvtEXyfilV1zipZyPGnwWn7MuhywBrGBeRJN5B8h92NRhb7uRbAaDedo4vLsaVwArSVKANH5PnSSdmv3qXDoZJ55q9EmL1RviozrnoruBL9EjMWVdwOf8YcQ44aJHf7nRPRAOYC8rfxfulZPVEkbPcQXjcXY64jtDtOuAgNyikCTiYzBuYvAsIxO1Oq8hwJEdFvToFYdfu74dBVR5dapyBPUqUScjkz41uITaNA82Z30PtA9y9AO2D2rm5ctHzAZzz3IA79lfCTQN3fcufsvYY5HyiTFLg6vGjMn6UadhPT7AmvriQDCe9Fvlwx8nyJBW1hi8Fb3fklugWaCd1kNpXZ9tfi2fkvrfwCATvS5jV6F3XhVnerWOt5DzWsMl5esFQXnVCtTGmRiSFh5hLyS635h29L9ZHPtiZ7IA5vvY7uF3FcytSh3b6HzJBCiniIFsUZLYIyUHcfwuERusHe0XqYDwqez7aXG7YY2R7tTbX4caO57FqHg6FTdBznFTkw8Ds4SAndtYDNiZ5NbCBsjDTVSL3nIb4tVRvvyxwLAfYxzvHDskxpfPgihnxCCrA1iLWQLHoeZh1qhjVTKDNM19VNza2xKF4tojpA9m0fD9qz2jj7NpLNPVD2PgS9hexHQkOIxuyGoimMixP2SQ8b7s7PizRAImMJo6PkC3feGBH2RQMzB25HTr7YB3UHE9ByoZuAKH7xxOCoceHKlNAcLoT67cT1HFk5eBpynt133Jvxj632JIOpzgF50DT1ZuD0CnbVg9o0p5k4OgxNfg2kefF1CS2gAz2HlGjDoPOjKgL5kOEU62L2mBf1G4tFlzwv5tyvC3a2kNLyUaWbCrK6kcQlFbVmfvN9mlA9d9e9oFxiqc3xSMwsa3WMsEq1MNK37kJdJ38VbhA0KGXBWJ0yC12DtFjiuxDs3k30F7DFpf8nYGrvNx9Qiv7ofbltjcVVH3jsl0thdAGrEmICKnrmW4GymvI9tg35hoBg0Ugystx1WYTe7xolrJogWh5X9F8VpDNq5Bur9avLurQjPWOsU8McxmEdMiB8uM1iCroSLCIIHTkPxS4ULn4aBxgjo8FLF3Pk2bwDDK9gpwlDS4nkAyHjwQHYgAr0BdEUQhPBt3tXOeZJ0xyobLI84wrqa2Ynl58QIjenucDGzIKBcttkPx3j2g4HbqXfiiyjgzGB8teY0LawpquSXJ7yYwa92XeLFKfV7BMYNsHHjkMsRQkpQqO75RQhDwLGieM1TBb2DIZ5JxOk0z8riYWeiocEQ8W636qSAozJuZTaOiIJLc1vOt5VNtzPD2PV1Ak1UVNI51K6ktEpJ9ndNQP0HIbBlYBOgvTARJir1bfcWU3oBe2TjVOmkZ6K2kfg85kQWz4MEQCoIdQ6CDKbcnvbqmGwnVfdS6mrOBBjKLP0VsxHQneWgECZVPtLujy1m2iuYVs7eZCkxxnRCdG33YC8RpVp5GYNn5yEwWtfws8lQh3QTIuXupQwdZKm3KfGPZZPwnYTp34dnoDfMddNEJ6rrESivoCcmW91QRm7p0sfUNPBSbpVuhPKQf7lm9WQlUmi7euFH0VDn0SDUkHIxMNx3X7eUgMGRJaQ5MyuVzbKQ7RXJjYjMvWavX5q3nyibrTQIG5exQqJrIGgDiV6IRnV947KjfCXF09sKJNp5uo8B7rRiKPoIoa7jDjxJOSmpYrQ2IxZaaWvV1z3mRpoWug45gvzndYFLRsL8FA8NYeiJwh3UcDQWvkt6g8Txhyup6qFv1WUE7qJlWofVsAC8BsZuW5iGhVN0LqsCpDWkInwaNoDcSNQRm6nZ8d5yt8QofkJgaP5ALv6RFWT6G5XBdQniITCUmqPcKYLcJzdhmljZrb970480NjBk1Nm1PtolrMsp1iTJQXvlrBYtzZOatrCbY2bgyMaXPjpDZ7LsfvzdeamZbjgF8VZbS3YGur8OSJgVk2Z8vsttHqvWyNvmuJNh3dCY9Zd6GrLhGB5FrvGqyk9lVWuukPGWx57SjCGXP5YRPGmraMrOkfjL7fJZIDPV838pXYGbjItYUsoSKXjDYNGFiE6q94SuT3baSUMLTDTaHNK8Wg87o8jS0W6tuLIfp7YTmfTWvJTHCxqtyybXwcgGw1gSwsHjoPLVCk0sPO7bv82Eh8Xh9Jx9dajRCditM8FDZEiCod9SJ985p1POH8q8Fwrw7dLTaDDfBB3bQDP89kr6Hphegx1DpgmgUvMEbZkXOPxpUGrjdeoADe5c82hLNKoMiEtD6ECsH86TX15uclprJJeJb4haf2lFIm7dbgrynwLjn8XSM4VfWVwXzNXwVB0h2zV37LgCN4Lcod2EK4jAWnB4lHjREJqziflL1mtoBLdnUR86wjI34ZdCpjmf6zeMyjyNm1YvMSikVbaXfZoazGxPWGWmlcwHx9dy5upMtfJjnXmCkLqfNNYSOLJjC1dJaavEG2jiPYkiZUUoubyljJHyLnAAS2IljdS8bUcJvOWt6pOT90tB5EWkOcqfiGpKDZi9H7FZVN2xxapDitYULqyWolTYzyqMRCDNEvgBkxu58nSZhBlSc8NZk4B7sk36EL3V41vXzwpggw1IGELffCovQt1xE1W715KUwnYUWu0bg9bnkFPBOdUGn9zK7BDJHqP2wFEcGsJUiGt8ZvFqDzxhmcWfEW7KKw77mB4OvlaYKYL4IbPtv1dNnHRNvRFLDFvGO064LOwhjtyfJh7jVvow94K8vU8i6jtRpfn9zYM3nbufSdKbdG6un1XB9xX1sXRyjSMcTMkfXYylZvVLebjrtqdWRdIriz5qVNivLWvcsJMVzBxU4iLw7JX3ROcojBPlxOgbEUK6MS66kI99tpY3ixd1D3CmcQzjdAhbS3OIRZQlEafgJEbauXL0KzHnWgJKx89xjZXtLlE3yRGlrI82mQEwCRLSvGjVQIKBFSOxawBZDNht9o65jv4D3aoE68SSrhvsDbvGIPx2pimgaWMxx18G7lTmUtvETlNkjxLIth1zEHAgZBY75GIbkABqtz8nwy2N49YmbnQhiCN8D2IfkFyIk0OOVts8M3X9xW7AumUYP3wwqRPy6cCgLDNq0Ymk1bxP9K8pBPkcDSwS9kIFlb1SVOtXit0nuqfBzRh7eo2sFxFOsm3E9ziP4rfsm9Ts5DoKE7kw7HdJi1drgmU1OLXE9d3ZHCwUbWxLB7me0zv6Oz90TFWiwrHMRoNDoNdP3Zcu6bfUmNmbC38bS1t6fLgFAy6AdONqYbKn22J8vYFBSb8XQ4HFc2eRm6wxVnSas5akg1tDWi0Ll5lPRYyfijZDy7uewgbimS3IKzWjFOwGQaRFjDCSbEOU6t8pk2ctrj9byEYUKOjlnRCbo3PD4VDbwyHQ</string>
    <string name="long_string3">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</string>
    <string name="long_string4">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</string>
    <string name="long_string5">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u6MYXpq2b1NwJQjPlQhvYhMltxGKNiDmMoc9BH7akSIO4MA8aGwYzdV7OFdE4xt4LIySWLHrM9nfLYOlZOx80XdNwZtxmNIGVd4cVRzbq0NHjFjm6FdTBEG0zvWXrdDwq5ErpJFsAEcHw8Va7JNMZFbbZaiDd1pdAgtX1nEMWqDquehFy7VyWZW4HdvrZpJa4FaVFHcVGLJlO2boCoqebdUQhVc7vUvaO124p4gGNHo2RsjfwSgC0cwmg0vnVMiex1ezcBcbfc1kXwKixauyMWFKDOvomcolbaSA3OlTScmTfXS2LJixdLOXOBeSD28Ym2klVq6IS5CIGKwpn0CcciycI35ReYMK5f8r1JG3iYnR1jpeCASt9ggmT87eP0zgu01YYVUMNRgm9mDYU16Pce36HwDoD6yNxp6Czk3kJUpqygSpntVyuf6uuOsFwUfi3ii9TZqMlsbbcEqlYybVh5K5OjcZBCzmYqF4D1aLWfDtRDuc314paLfOga7J2ghuujoTXeqP328GdqQmCfsQEvUw9Oxef7hA7X0Bx68XCJ2yMKEaNOdirG5ubXxVQPFb7YFTdtNrMqPpbpVpqMRqU506LGTRnKYD90qqPF7ctgbIfjzQLV5CDymsiclAg77rLgw8T7p9o9CXIJesrZR95YZKGgsE7FOlpnsOrVSnjwQFO6u1I5oe1Q2uoQ33BfrzxwQ99pkZilFlZOzs6xsMtCb6h8E71TtfrLbwoPv15WniTNwvpYIq807Aq8zzVchw5xFF2cX1KohDIDnef8c0EztchHVvwTEOmpOrqslhl5n5yAa1vgorHThisisAnAdditionalBitofTextAddedSoWeCanMakeSureOurShortLimitIsFixedForMoreThanOneStringLongerThanItsLimit</string>
    <string name="long_string6">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_formatting1"><a href="http://www.foo.com" style="text-decoration:none;">http://www.foo.com</a></string>
    <string name="test_formatting2"><a href="http://www.foo.com" style="text-decoration:none">http://www.foo.com</a></string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ldrtl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-lowdr-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001-mnc00/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001-mnc1/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/anims.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_anims1" type="anim">@android:anim/bounce_interpolator</item>
    <item name="test_anims2" type="anim">@android:anim/cycle_interpolator</item>
    <item name="test_anims3" type="anim">@android:anim/decelerate_interpolator</item>
    <item name="test_anims4" type="anim">@android:anim/fade_in</item>
    <item name="test_anims5" type="anim">@android:anim/fade_out</item>
    <item name="test_anims6" type="anim">@android:anim/linear_interpolator</item>
    <item name="test_anims7" type="anim">@android:anim/overshoot_interpolator</item>
    <item name="test_anims8" type="anim">@android:anim/slide_in_left</item>
    <item name="test_anims9" type="anim">@android:anim/slide_out_right</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array1">
        <item>TEST1</item>
        <item>TEST2</item>
        <item>TEST3</item>
        <item>%2$s foo %1$d</item>
        <item>http://google.com&amp;boo=1&amp;foo=2</item>
        <item>&lt;b>Bolded Text&lt;/b></item>
        <item>&lt;font size=16 align=middle>Small&lt;/font></item>
    </string-array>
    <integer-array name="test_array2">
        <item>-1</item>
        <item>0</item>
        <item>1</item>
    </integer-array>
    <array name="test_array3">
        <item></item>
        <item>true</item>
        <item>TEST</item>
        <item>5</item>
        <item>5.5</item>
        <item>10.0sp</item>
        <item>#ff123456</item>
    </array>
    <string-array name="issue_409">
        <item>@string/test1</item>
        <item>foo</item>
        <item>foo2</item>
    </string-array>
    <string-array name="issue_677" formatted="false">
        <item>category=temp%temp%foo</item>
    </string-array>
    <string-array name="issue_329">
        <item>res/</item>
        <item>view/</item>
    </string-array>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <bool name="test_bool1">false</bool>
    <bool name="test_bool2">true</bool>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="test_color1">#ff123456</color>
    <color name="test_color2">@android:color/white</color>
    <color name="test_color3">#00000000</color>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="test_dimen1">10.0dip</dimen>
    <dimen name="test_dimen2">10.0sp</dimen>
    <dimen name="test_dimen3">10.0pt</dimen>
    <dimen name="test_dimen4">10.0px</dimen>
    <dimen name="test_dimen5">10.0mm</dimen>
    <dimen name="test_dimen6">10.0in</dimen>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/drawables.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_drawable1" type="drawable">@android:drawable/btn_default</item>
    <item name="test_drawable2" type="drawable">#00000000</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="id" name="test_id1" />
    <item type="id" name="test_id2" />
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/layouts.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_layouts1" type="layout">@android:layout/activity_list_item</item>
    <item name="test_layouts2" type="layout">@android:layout/browser_link_context_header</item>
    <item name="test_layouts3" type="layout">@android:layout/simple_list_item_1</item>
    <item name="test_layouts4" type="layout">@android:layout/simple_spinner_item</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/plurals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <plurals name="test_plurals1">
        <item quantity="other">%1$s, %2$d foo(s)</item>
        <item quantity="one">%1$s, %2$d foo</item>
    </plurals>
    <plurals name="test_plurals2">
        <item quantity="other">%d foos</item>
        <item quantity="one">%d foo</item>
    </plurals>
    <plurals name="test_plurals3">
        <item quantity="other">foo %d moos</item>
        <item quantity="one">foo %d moo</item>
    </plurals>
    <plurals name="test_plurals4">
        <item quantity="other">foo %d</item>
        <item quantity="one">foo 1</item>
    </plurals>
    <plurals name="issue_658">
        <item quantity="other">&lt;b>%d&lt;/b> guide123</item>
        <item quantity="one">&lt;b>%d&lt;/b> 1</item>
    </plurals>
    <plurals name="issue_1431">
        <item quantity="other">Vous disposez de &lt;font color=#8c593c>%1$d contenus&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
        <item quantity="one">Vous disposez de &lt;font color=#8c593c>%1$d contenu&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
    </plurals>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_string1"></string>
    <string name="test_string2">Lorem ipsum...</string>
    <string name="test_string3">\@</string>
    <string name="test_string4">\?</string>
    <string name="test_string5">\#ff123456</string>
    <string name="test_string7">&amp;</string>
    <string name="test_string8">"'"</string>
    <string name="test_string9">\"</string>
    <string name="test_string10">\u0005</string>
    <string name="test_string11">" foo  bar   "</string>
    <string name="test_string12">"foo
bar"</string>
    <string name="test_string13">" foo"<b>bar <i> baz </i></b> <u>foo</u></string>
    <string name="test_string14">foo<sometag someattr1="someval1" someattr2="someval2">bar</sometag>baz</string>
    <string name="test_string16">foo<b>bar<i>"b
        az"</i></b>foo</string>
    <string name="test_string17" formatted="false">%d of %d</string>
    <string name="test_string18" formatted="false">foo %d bar %</string>
    <string name="test_string19">%2$s foo %1$d</string>
    <string name="test_string20" formatted="false">%-e foo %,d</string>
    <string name="test_string21">%2$-e foo %1$,d</string>
    <string name="test_string22" formatted="false">%02d foo %01d</string>
    <string name="test_string23" formatted="false">%d foo %1</string>
    <string name="test_string24" formatted="false">%1% foo %2%</string>
    <string name="test_string25" formatted="false">foo %s bar %2$s baz</string>
    <string name="test_string26">賞金鬥士14</string>
    <string name="test_string27">{id:65538,v:2,tid:20003,mst:1,x:-1,y:-1,a:6000,b:3000,lm:{chp:1000,rep:0,bt:0,mp:[[101,0,1,0],[101,0,1,1],[101,0,1,2],[101,0,1,3],[101,0,1,4],[101,0,1,5],[100,0,0,0],[100,0,0,1],[100,0,0,2],[100,0,0,3],[100,0,0,4],[100,0,0,5]]},rm:{chp:1000,rep:0,bt:0,mp:[[100,0,1,0],[100,0,1,1],[100,0,1,2],[100,0,1,3],[100,0,1,4],[100,0,1,5],[101,0,0,0],[101,0,0,1],[101,0,0,2],[101,0,0,3],[101,0,0,4],[101,0,0,5]]}}</string>
    <string name="test_string28">{al:[[180,0,7,0,0,1000],[109,0,5,0,0],[109,0,5,2,0],[109,0,5,4,0],[100,0,3,0,0],[100,0,3,1,0],[100,0,3,2,0],[100,0,3,3,0],[100,0,3,4,0],[100,0,3,5,0],[103,0,1,0,0],[103,0,1,1,0],[103,0,1,2,0],[103,0,1,3,0],[103,0,1,4,0],[103,0,1,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[800,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[850],[950],[900,0],[1000,0,0]],v:4,s:-1575044211,rl:[[180,0,7,0,0,1000],[103,0,0,0,0],[103,0,0,1,0],[103,0,0,2,0],[103,0,0,3,0],[103,0,0,4,0],[103,0,0,5,0],[111,0,3,0,0],[111,0,3,1,0],[111,0,3,2,0],[111,0,3,3,0],[111,0,3,4,0],[111,0,3,5,0],[102,0,4,0,0],[102,0,4,1,0],[102,0,4,2,0],[102,0,4,3,0],[102,0,4,4,0],[102,0,4,5,0],[107,0,5,0,0],[107,0,5,1,0],[107,0,5,2,0],[107,0,5,3,0],[107,0,5,4,0],[107,0,5,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[900],[1000,0,0]],m:[]}</string>
    <string name="test_string29" formatted="false">category=temp%temp%foo</string>
    <string name="test_string30">res/foo/</string>
    <string name="test_string31">res/foo</string>
    <string name="test_string32">[<font size="17">TEST STRING</font>]</string>
    <string name="test_string33"><font size="17">[TEST STRING]</font></string>
    <string name="test_string34">[<font size="17">TEST STRING]</font></string>
    <string name="test_string35"><font size="17">[TEST STRING</font>]</string>
    <string name="test_string36"><font size="17">TEST STRING</font></string>
    <string name="test_string37">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
    <string name="test_string38">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string39"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string40">[<font size="17">]Ţåþ ţö ţýþé þåššŵöŕð one two three</font></string>
    <string name="test_string41"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TextAppearance" parent="@android:style/TextAppearance" />
    <style name="TextAppearance.EditEvent_Label" parent="@style/TextAppearance">
        <item name="android:gravity">center_vertical</item>
        <item name="android:popupAnimationStyle">@empty</item>
    </style>
    <style name="TextAppearance.EditEvent_Button" parent="@style/TextAppearance.EditEvent_Label">
        <item name="android:textColor">#ff777777</item>
        <item name="@string/issue_477">?android:dividerVertical</item>
    </style>
    <style name="Foo.Bar" parent=""/>
    <style name="IssueStyle">
        <item name="@string/issue_1123">@null</item>
    </style>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc002/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>@string/test_string1</item>
        <item>@string/test_string2</item>
    </string-array>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc002/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_reference1">@string/test1</string>
    <string name="test_reference2">@android:string/ok</string>
    <string name="test_reference3">?android:textStyle</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>3.0in</item>
    </string-array>
    <string-array name="test_array5">
        <item>65.0%</item>
        <item>65%</item>
    </string-array>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="bool" name="test_crossType_str2bool">TEST</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="integer" name="test_crossType_str2int">TEST</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="string" name="test_crossType_bool2str">true</item>
    <item type="string" name="test_crossType_int2str">5</item>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc238-mnc6/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc238-mnc870/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mnc1/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-notround/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-nowidecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-round/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-vrheadset-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-watch/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-widecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <attr format="integer" name="test_attr1"/>
    <attr format="reference" name="test_attr2"/>
    <attr format="reference" name="test_attr3"/>
    <attr format="string" name="test_attr4"/>
    <attr name="test_attr5">
        <enum name="out_test" value="0"/>
        <enum name="in_test" value="1"/>
    </attr>
    <attr format="reference" name="test_attr6"/>
    <attr format="reference" name="test_attr7"/>
    <attr format="reference|color" name="test_attr8"/>
    <attr format="color" name="test_attr9"/>
    <attr format="boolean" name="test_attr10"/>
    <attr name="test_attr11">
        <enum name="TEST_ZERO" value="0" />
        <enum name="TEST_ONE" value="1" />
    </attr>
    <attr name="min_value" format="float" />
    <attr name="max_value" format="float" />
    <attr name="default_value" format="float" />
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item type="id" name="test_attr1" />
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
    <integer name="reference_test">0</integer>
    <integer name="issue_1223_1">700</integer>
    <integer name="issue_1223_2">@integer/issue_1223_1</integer>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
    <public type="xml" name="ww_box_styles_schema" id="0x7f1500df" />
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1" />
    <string name="hello_world">Hello World</string>
    <string name="issue_477">divider</string>
    <string name="issue_1123">divider</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/literals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<View xmlns:android="http://schemas.android.com/apk/res/android"
    test1=""
    test2="Lorem ipsum"
    test3="\@"
    test4="\?"
    test5="#ff123456"
    test6="\#ff123456"
    test7="&amp;"
    test8="'"
    test9="&quot;"
    test10="\u0005"
    test11=" foo  bar   "
    test12="foo \n bar"
    test15="5"
/>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/references.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<View xmlns:android="http://schemas.android.com/apk/res/android"
    test1="@string/test1"
    test2="@android:string/ok"
    test3="?android:textStyle"
/>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/ww_box_styles_schema.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="test">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="person" type="xs:string"/>
                <xs:element name="address">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali_classes2/HelloDualDexSupport.smali`:

```smali
.class public LHelloDualDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali_classes3/HelloTripleDexSupport.smali`:

```smali
.class public LHelloTripleDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/hidden.file`:

```file
This file is unknown.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/lib_bug603/bug603`:

```
https://code.google.com/p/android-apktool/issues/detail?id=603
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/nonprintable.file`:

```file
This file's name contains a non-printable character.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/stored.file`:

```file
This file is not compressed.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/unk_folder/unknown_file`:

```
I am a hidden file. Put here by a developer to make recompilation difficult.
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testjar.jar
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/original/META-INF/MANIFEST.MF`:

```MF
Manifest-Version: 1.0
Created-By: 1.6.0_45 (Sun Microsystems Inc.)


```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/smali/com/apktool/test/Test.smali`:

```smali
.class public LTest;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="false"/>
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application/>
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="true"/>
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.aapt2.pkgid8" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415" featureName="feature">
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/apktool.yml`:

```yml
version: 2.0.0
apkFileName: pkgid8.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '128'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="foo3">117</integer>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="foo1" id="0x80020000" />
    <public type="string" name="foo2" id="0x80020001" />
    <public type="integer" name="foo3" id="0x80030000" />
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="foo1">foo</string>
    <string name="foo2">bar</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:appCategory="game" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.aapt1.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
</manifest>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/apktool.yml`:

```yml
version: 2.3.2
apkFileName: testapp.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
doNotCompress:
- assets/0byte_file.jpg
sparseResources: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_hide_password__0.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"></vector>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__0.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector android:height="24.0dip" android:width="24.0dip" android:viewportWidth="24.0" android:viewportHeight="24.0"
        xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
</vector>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__1.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueType="pathType" android:propertyName="pathData"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueFrom="1" android:valueTo="0" android:propertyName="trimPathEnd"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/avd_show_password.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-vector android:drawable="@drawable/$avd_show_password__0"
                 xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
    <target android:name="eye_mask" android:animation="@drawable/$avd_show_password__1" />
    <target android:name="strike_through" android:animation="@drawable/$avd_show_password__2" />
</animated-vector>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/navigation/nav_graph.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android">
</navigation>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string_32767">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <attr format="integer" name="test_attr1"/>
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item type="id" name="test_attr1" />
</resources>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
    <string name="long_string_32767" />
</resources>

```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/xml/ww_box_styles_schema.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="test">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="person" type="xs:string"/>
                <xs:element name="address">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali_classes2/HelloDualDexSupport.smali`:

```smali
.class public LHelloDualDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali_classes3/HelloTripleDexSupport.smali`:

```smali
.class public LHelloTripleDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/decode/doctype/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE manifest [<!ENTITY e1 SYSTEM 'http://ibotpeaches.com?z=APKTOOLXXE;'>]>
<manifest hardwareAccelerated="true" package="com.ibotpeaches.doctype" platformBuildVersionCode="24" platformBuildVersionName="6.0-2456767" xmlns:android="http://schemas.android.com/apk/res/android">
    &e1;
<supports-screens android:anyDensity="true" android:largeScreens="true" android:normalScreens="true" android:resizeable="true" android:smallScreens="true" android:xlargeScreens="true"/>
</manifest>
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/decode/doctype/apktool.yml`:

```yml
version: 2.0.0
apkFileName: doctype.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`distribution/apktool/brut.apktool/apktool-lib/src/test/resources/util/traversal/file`:

```
file
```

`distribution/apktool/brut.j.common/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
//    testImplementation depends.junit
}


```

`distribution/apktool/brut.j.common/src/main/java/brut/common/BrutException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class BrutException extends Exception {
    public BrutException(Throwable cause) {
        super(cause);
    }

    public BrutException(String message, Throwable cause) {
        super(message, cause);
    }

    public BrutException(String message) {
        super(message);
    }

    public BrutException() {
    }
}

```

`distribution/apktool/brut.j.common/src/main/java/brut/common/InvalidUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class InvalidUnknownFileException extends BrutException {
    public InvalidUnknownFileException(String message) {
        super(message);
    }
}

```

`distribution/apktool/brut.j.common/src/main/java/brut/common/RootUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class RootUnknownFileException extends BrutException {
    public RootUnknownFileException(String message) {
        super(message);
    }
}

```

`distribution/apktool/brut.j.common/src/main/java/brut/common/TraversalUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class TraversalUnknownFileException extends BrutException {
    public TraversalUnknownFileException(String message) {
        super(message);
    }
}

```

`distribution/apktool/brut.j.common/src/templates/apache2.0-header.txt`:

```txt
 Copyright (C) ${year} ${brut} <${brutEmail}>
 Copyright (C) ${year} ${ibot} <${ibotEmail}>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.


```

`distribution/apktool/brut.j.dir/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
//  implementation project(':brut.j.common'),
//                 project(':brut.j.util'),
//                 depends.commons_io
//  testImplementation depends.junit
  implementation project(':distribution:apktool:brut.j.util')
  implementation project(':distribution:apktool:brut.j.common')
  implementation 'commons-io:commons-io:2.4'


}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/AbstractDirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

public abstract class AbstractDirectory implements Directory {
    protected Set<String> mFiles;
    protected Set<String> mFilesRecursive;
    protected Map<String, AbstractDirectory> mDirs;

    @Override
    public Set<String> getFiles() {
        return getFiles(false);
    }

    @Override
    public Set<String> getFiles(boolean recursive) {
        if (mFiles == null) {
            loadFiles();
        }
        if (!recursive) {
            return mFiles;
        }
        if (mFilesRecursive == null) {
            mFilesRecursive = new LinkedHashSet<String>(mFiles);
            for (Map.Entry<String, ? extends Directory> dir : getAbstractDirs().entrySet()) {
                for (String path : dir.getValue().getFiles(true)) {
                    mFilesRecursive.add(dir.getKey() + separator + path);
                }
            }
        }
        return mFilesRecursive;
    }

    @Override
    public boolean containsFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsFile(subpath.path);
        }
        return getFiles().contains(subpath.path);
    }

    @Override
    public boolean containsDir(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsDir(subpath.path);
        }
        return getAbstractDirs().containsKey(subpath.path);
    }

    @Override
    public Map<String, Directory> getDirs()
            throws UnsupportedOperationException {
        return getDirs(false);
    }

    @Override
    public Map<String, Directory> getDirs(boolean recursive)
            throws UnsupportedOperationException {
        return new LinkedHashMap<String, Directory>(getAbstractDirs(recursive));
    }

    @Override
    public InputStream getFileInput(String path) throws DirectoryException {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getFileInput(subpath.path);
        }
        if (! getFiles().contains(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getFileInputLocal(subpath.path);
    }

    @Override
    public OutputStream getFileOutput(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            getFiles().add(parsed.subpath);
            return getFileOutputLocal(parsed.subpath);
        }
        
        Directory dir;
        // IMPOSSIBLE_EXCEPTION
        try {
            dir = createDir(parsed.dir);
        } catch (PathAlreadyExists e) {
            dir = getAbstractDirs().get(parsed.dir);
        }
        return dir.getFileOutput(parsed.subpath);
    }

    @Override
    public Directory getDir(String path) throws PathNotExist {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getDir(subpath.path);
        }
        if (! getAbstractDirs().containsKey(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getAbstractDirs().get(subpath.path);
    }

    @Override
    public Directory createDir(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        AbstractDirectory dir;
        if (parsed.dir == null) {
            if (getAbstractDirs().containsKey(parsed.subpath)) {
                throw new PathAlreadyExists(path);
            }
            dir = createDirLocal(parsed.subpath);
            getAbstractDirs().put(parsed.subpath, dir);
            return dir;
        }
        
        if (getAbstractDirs().containsKey(parsed.dir)) {
            dir = getAbstractDirs().get(parsed.dir);
        } else {
            dir = createDirLocal(parsed.dir);
            getAbstractDirs().put(parsed.dir, dir);
        }
        return dir.createDir(parsed.subpath);
    }

    @Override
    public boolean removeFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.removeFile(subpath.path);
        }
        if (! getFiles().contains(subpath.path)) {
            return false;
        }
        removeFileLocal(subpath.path);
        getFiles().remove(subpath.path);
        return true;
    }

    public void copyToDir(Directory out) throws DirectoryException {
        DirUtil.copyToDir(out, out);
    }

    public void copyToDir(Directory out, String[] fileNames)
            throws DirectoryException {
        DirUtil.copyToDir(out, out, fileNames);
    }

    public void copyToDir(Directory out, String fileName)
            throws DirectoryException {
        DirUtil.copyToDir(out, out, fileName);
    }

    public void copyToDir(File out) throws DirectoryException {
        DirUtil.copyToDir(this, out);
    }

    public void copyToDir(File out, String[] fileNames)
            throws DirectoryException {
        DirUtil.copyToDir(this, out, fileNames);
    }

    public void copyToDir(File out, String fileName)
            throws DirectoryException {
        DirUtil.copyToDir(this, out, fileName);
    }

    public int getCompressionLevel(String fileName)
            throws DirectoryException {
        return -1;  // Unknown
    }

    protected Map<String, AbstractDirectory> getAbstractDirs() {
        return getAbstractDirs(false);
    }

    protected Map<String, AbstractDirectory> getAbstractDirs(boolean recursive) {
        if (mDirs == null) {
            loadDirs();
        }
        if (!recursive) {
            return mDirs;
        }

        Map<String, AbstractDirectory> dirs = new LinkedHashMap<String, AbstractDirectory>(mDirs);
        for (Map.Entry<String, AbstractDirectory> dir : getAbstractDirs().entrySet()) {
            for (Map.Entry<String, AbstractDirectory> subdir : dir.getValue().getAbstractDirs(
                    true).entrySet()) {
                dirs.put(dir.getKey() + separator + subdir.getKey(),
                        subdir.getValue());
            }
        }
        return dirs;
    }


    public void close() throws IOException {

    }

    private SubPath getSubPath(String path) throws PathNotExist {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            return new SubPath(null, parsed.subpath);
        }
        if (! getAbstractDirs().containsKey(parsed.dir)) {
            throw new PathNotExist(path);
        }
        return new SubPath(getAbstractDirs().get(parsed.dir), parsed.subpath);
    }
    
    private ParsedPath parsePath(String path) {
        int pos = path.indexOf(separator);
        if (pos == -1) {
            return new ParsedPath(null, path);
        }
        return new ParsedPath(path.substring(0, pos), path.substring(pos + 1));        
    }

    abstract protected void loadFiles();
    abstract protected void loadDirs();
    abstract protected InputStream getFileInputLocal(String name)
        throws DirectoryException;
    abstract protected OutputStream getFileOutputLocal(String name)
        throws DirectoryException;
    abstract protected AbstractDirectory createDirLocal(String name)
        throws DirectoryException;
    abstract protected void removeFileLocal(String name);
    
    
    private class ParsedPath {
        public String dir;
        public String subpath;
        public ParsedPath(String dir, String subpath) {
            this.dir = dir;
            this.subpath = subpath;
        }
    }    
    
    private class SubPath {
        public AbstractDirectory dir;
        public String path;

        public SubPath(AbstractDirectory dir, String path) {
            this.dir = dir;
            this.path = path;
        }
    }
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/DirUtil.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;
import brut.util.BrutIO;
import brut.util.OS;
import java.io.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class DirUtil {
    public static void copyToDir(Directory in, Directory out)
            throws DirectoryException {
        for (String fileName : in.getFiles(true)) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, Directory out,
            String[] fileNames) throws DirectoryException {
        for (int i = 0; i < fileNames.length; i++) {
            copyToDir(in, out, fileNames[i]);
        }
    }

    public static void copyToDir(Directory in, Directory out, String fileName)
            throws DirectoryException {
        copyToDir(in, out, fileName, fileName);
    }

    public static void copyToDir(Directory in, Directory out, String inFile, String outFile)
            throws DirectoryException {
        try {
            if (in.containsDir(inFile)) {
                in.getDir(inFile).copyToDir(out.createDir(outFile));
            } else {
                BrutIO.copyAndClose(in.getFileInput(inFile), out.getFileOutput(outFile));
            }
        } catch (IOException ex) {
            throw new DirectoryException("Error copying file: " + inFile, ex);
        }
    }

    public static void copyToDir(Directory in, File out)
            throws DirectoryException {
        for (String fileName : in.getFiles(true)) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, File out, String[] fileNames)
            throws DirectoryException {
        for (int i = 0; i < fileNames.length; i++) {
            copyToDir(in, out, fileNames[i]);
        }
    }

    public static void copyToDir(Directory in, File out, String fileName)
            throws DirectoryException {
        try {
            if (in.containsDir(fileName)) {
                OS.rmdir(new File(out, fileName));
                in.getDir(fileName).copyToDir(new File(out, fileName));
            } else {
                if (fileName.equals("res") && !in.containsFile(fileName)) {
                    return;
                }
                String cleanedFilename = BrutIO.sanitizeUnknownFile(out, fileName);
                File outFile = new File(out, cleanedFilename);
                outFile.getParentFile().mkdirs();
                BrutIO.copyAndClose(in.getFileInput(fileName),
                    new FileOutputStream(outFile));
            }
        } catch (IOException ex) {
            throw new DirectoryException(
                "Error copying file: " + fileName, ex);
        } catch (BrutException ex) {
            throw new DirectoryException(
                "Error copying file: " + fileName, ex);
        }
    }
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/Directory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.*;
import java.util.Map;
import java.util.Set;

public interface Directory {
    public Set<String> getFiles();
    public Set<String> getFiles(boolean recursive);
    public Map<String, Directory> getDirs();
    public Map<String, Directory> getDirs(boolean recursive);
    
    public boolean containsFile(String path);
    public boolean containsDir(String path);
    
    public InputStream getFileInput(String path) throws DirectoryException;
    public OutputStream getFileOutput(String path) throws DirectoryException;
    public Directory getDir(String path) throws PathNotExist;
    public Directory createDir(String path) throws DirectoryException;
    
    public boolean removeFile(String path);

    public void copyToDir(Directory out) throws DirectoryException;
    public void copyToDir(Directory out, String[] fileNames)
        throws DirectoryException;
    public void copyToDir(Directory out, String fileName)
        throws DirectoryException;
    public void copyToDir(File out) throws DirectoryException;
    public void copyToDir(File out, String[] fileNames)
        throws DirectoryException;
    public void copyToDir(File out, String fileName)
        throws DirectoryException;

    public long getSize(String fileName)
            throws DirectoryException;
    public long getCompressedSize(String fileName)
            throws DirectoryException;
    public int getCompressionLevel(String fileName)
            throws DirectoryException;


    public void close() throws IOException;
    
    public final char separator = '/';
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/DirectoryException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;

public class DirectoryException extends BrutException {
    private static final long serialVersionUID = -8871963042836625387L;

    public DirectoryException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    public DirectoryException(String detailMessage) {
        super(detailMessage);
    }

    public DirectoryException(Throwable throwable) {
        super(throwable);
    }

    public DirectoryException() {
        super();
    }
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/ExtFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.net.URI;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ExtFile extends File {
    public ExtFile(File file) {
        super(file.getPath());
    }

    public ExtFile(URI uri) {
        super(uri);
    }

    public ExtFile(File parent, String child) {
        super(parent, child);
    }

    public ExtFile(String parent, String child) {
        super(parent, child);
    }

    public ExtFile(String pathname) {
        super(pathname);
    }

    public Directory getDirectory() throws DirectoryException {
        if (mDirectory == null) {
            if (isDirectory()) {
                mDirectory = new FileDirectory(this);
            } else {
                mDirectory = new ZipRODirectory(this);
            }
        }
        return mDirectory;
    }

    public void close() throws IOException {
        if (mDirectory != null) {
            mDirectory.close();
        }
    }

    private Directory mDirectory;
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/FileDirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.*;
import java.net.URLDecoder;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;

public class FileDirectory extends AbstractDirectory {
    private File mDir;

    public FileDirectory(ExtFile dir, String folder) throws DirectoryException, UnsupportedEncodingException {
        this(new File(dir.toString().replaceAll("%20", " "), folder));
    }

    public FileDirectory(String dir) throws DirectoryException, UnsupportedEncodingException {
        this(new File(URLDecoder.decode(dir, "UTF-8")));
    }

    public FileDirectory(File dir) throws DirectoryException {
        super();
        if (! dir.isDirectory()) {
            throw new DirectoryException("file must be a directory: " + dir);
        }
        mDir = dir;
    }

    @Override
    public long getSize(String fileName)
            throws DirectoryException {
        File file = new File(generatePath(fileName));
        if (! file.isFile()) {
            throw new DirectoryException("file must be a file: " + file);
        }
        return file.length();
    }

    @Override
    public long getCompressedSize(String fileName)
            throws DirectoryException {
        return getSize(fileName);
    }

    @Override
    protected AbstractDirectory createDirLocal(String name) throws DirectoryException {
        File dir = new File(generatePath(name));
        dir.mkdir();
        return new FileDirectory(dir);
    }

    @Override
    protected InputStream getFileInputLocal(String name) throws DirectoryException {
        try {
            return new FileInputStream(generatePath(name));
        } catch (FileNotFoundException e) {
            throw new DirectoryException(e);
        }
    }

    @Override
    protected OutputStream getFileOutputLocal(String name) throws DirectoryException {
        try {
            return new FileOutputStream(generatePath(name));
        } catch (FileNotFoundException e) {
            throw new DirectoryException(e);
        }
    }

    @Override
    protected void loadDirs() {
        loadAll();
    }

    @Override
    protected void loadFiles() {
        loadAll();
    }

    @Override
    protected void removeFileLocal(String name) {
        new File(generatePath(name)).delete();
    }

    private String generatePath(String name) {
        return getDir().getPath() + separator + name;
    }

    private void loadAll() {
        mFiles = new LinkedHashSet<String>();
        mDirs = new LinkedHashMap<String, AbstractDirectory>();

        File[] files = getDir().listFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.isFile()) {
                mFiles.add(file.getName());
            } else {
                // IMPOSSIBLE_EXCEPTION
                try {
                    mDirs.put(file.getName(), new FileDirectory(file));
                } catch (DirectoryException e) {}
            }
        }
    }

    private File getDir() {
        return mDir;
    }
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/PathAlreadyExists.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathAlreadyExists extends DirectoryException {
    public PathAlreadyExists() {
    }

    public PathAlreadyExists(Throwable throwable) {
        super(throwable);
    }

    public PathAlreadyExists(String detailMessage) {
        super(detailMessage);
    }

    public PathAlreadyExists(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    private static final long serialVersionUID = 3776428251424428904L;
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/PathNotExist.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathNotExist extends DirectoryException {
    public PathNotExist() {
        super();
    }

    public PathNotExist(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    public PathNotExist(String detailMessage) {
        super(detailMessage);
    }

    public PathNotExist(Throwable throwable) {
        super(throwable);
    }

    private static final long serialVersionUID = -6949242015506342032L;
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/ZipRODirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class ZipRODirectory extends AbstractDirectory {
    private ZipFile mZipFile;
    private String mPath;

    public ZipRODirectory(String zipFileName) throws DirectoryException {
        this(zipFileName, "");
    }

    public ZipRODirectory(File zipFile) throws DirectoryException {
        this(zipFile, "");
    }

    public ZipRODirectory(ZipFile zipFile) {
        this(zipFile, "");
    }

    public ZipRODirectory(String zipFileName, String path)
            throws DirectoryException {
        this(new File(zipFileName), path);
    }

    public ZipRODirectory(File zipFile, String path) throws DirectoryException {
        super();
        try {
            mZipFile = new ZipFile(zipFile);
        } catch (IOException e) {
            throw new DirectoryException(e);
        }
        mPath = path;
    }

    public ZipRODirectory(ZipFile zipFile, String path) {
        super();
        mZipFile = zipFile;
        mPath = path;
    }

    @Override
    protected AbstractDirectory createDirLocal(String name)
            throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    @Override
    protected InputStream getFileInputLocal(String name)
            throws DirectoryException {
        try {
            return getZipFile().getInputStream(new ZipEntry(getPath() + name));
        } catch (IOException e) {
            throw new PathNotExist(name, e);
        }
    }

    @Override
    protected OutputStream getFileOutputLocal(String name)
            throws DirectoryException {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void loadDirs() {
        loadAll();
    }

    @Override
    protected void loadFiles() {
        loadAll();
    }

    @Override
    protected void removeFileLocal(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public long getSize(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getSize();
    }

    @Override
    public long getCompressedSize(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getCompressedSize();
    }

    @Override
    public int getCompressionLevel(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getMethod();
    }

    private ZipEntry getZipFileEntry(String fileName)
            throws DirectoryException {
        ZipEntry entry = mZipFile.getEntry(fileName);
        if (entry == null) {
            throw new PathNotExist("Entry not found: " + fileName);
        }
        return entry;
    }

    private void loadAll() {
        mFiles = new LinkedHashSet<String>();
        mDirs = new LinkedHashMap<String, AbstractDirectory>();
        
        int prefixLen = getPath().length();
        Enumeration<? extends ZipEntry> entries = getZipFile().entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            String name = entry.getName();
            
            if (name.equals(getPath()) || ! name.startsWith(getPath()) || name.contains(".." + separator)) {
                continue;
            }
            
            String subname = name.substring(prefixLen);
            
            int pos = subname.indexOf(separator);
            if (pos == -1) {
                if (! entry.isDirectory()) {
                    mFiles.add(subname);
                    continue;
                }
            } else {
                subname = subname.substring(0, pos);
            }
            
            if (! mDirs.containsKey(subname)) {
                AbstractDirectory dir = new ZipRODirectory(getZipFile(), getPath() + subname + separator);
                mDirs.put(subname, dir);                
            }
        }
    }

    private String getPath() {
        return mPath;
    }

    private ZipFile getZipFile() {
        return mZipFile;
    }


    public void close() throws IOException {
        mZipFile.close();
    }
}

```

`distribution/apktool/brut.j.dir/src/main/java/brut/directory/ZipUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;
import brut.util.BrutIO;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.Collection;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private static Collection<String> mDoNotCompress;

    public static void zipFolders(final File folder, final File zip, final File assets, final Collection<String> doNotCompress)
            throws BrutException, IOException {

        mDoNotCompress = doNotCompress;
        ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(zip));
        zipFolders(folder, zipOutputStream);

        // We manually set the assets because we need to retain the folder structure
        if (assets != null) {
            processFolder(assets, zipOutputStream, assets.getPath().length() - 6);
        }
        zipOutputStream.close();
    }

    private static void zipFolders(final File folder, final ZipOutputStream outputStream)
            throws BrutException, IOException {
        processFolder(folder, outputStream, folder.getPath().length() + 1);
    }

    private static void processFolder(final File folder, final ZipOutputStream zipOutputStream, final int prefixLength)
            throws BrutException, IOException {
        for (final File file : folder.listFiles()) {
            if (file.isFile()) {
                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));
                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));

                // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be
                // compressed. We will replicate that behavior
                final String extension = FilenameUtils.getExtension(file.getAbsolutePath());
                if (mDoNotCompress != null && (mDoNotCompress.contains(extension) || mDoNotCompress.contains(zipEntry.getName()))) {
                    zipEntry.setMethod(ZipEntry.STORED);
                    zipEntry.setSize(file.length());
                    BufferedInputStream unknownFile = new BufferedInputStream(new FileInputStream(file));
                    CRC32 crc = BrutIO.calculateCrc(unknownFile);
                    zipEntry.setCrc(crc.getValue());
                    unknownFile.close();
                } else {
                    zipEntry.setMethod(ZipEntry.DEFLATED);
                }

                zipOutputStream.putNextEntry(zipEntry);
                try (FileInputStream inputStream = new FileInputStream(file)) {
                    IOUtils.copy(inputStream, zipOutputStream);
                }
                zipOutputStream.closeEntry();
            } else if (file.isDirectory()) {
                processFolder(file, zipOutputStream, prefixLength);
            }
        }
    }
}

```

`distribution/apktool/brut.j.util/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
//  implementation project(':brut.j.common'),
//                 depends.commons_io
//  testImplementation depends.junit
  implementation project(':distribution:apktool:brut.j.common')

  implementation 'commons-io:commons-io:2.4'
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/AaptManager.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class AaptManager {

    public static File getAppt2() throws BrutException {
        return getAppt(2);
    }

    public static File getAppt1() throws BrutException {
        return getAppt(1);
    }

    private static File getAppt(Integer version) throws BrutException {
        File aaptBinary;
        String aaptVersion = getAaptBinaryName(version);

        if (! OSDetection.is64Bit() && OSDetection.isMacOSX()) {
            throw new BrutException("32 bit OS detected. No 32 bit binaries available.");
        }

        // Set the 64 bit flag
        aaptVersion += OSDetection.is64Bit() ? "_64" : "";

        try {
            if (OSDetection.isMacOSX()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/macosx/" + aaptVersion, AaptManager.class);
            } else if (OSDetection.isUnix()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/linux/" + aaptVersion, AaptManager.class);
            } else if (OSDetection.isWindows()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/windows/" + aaptVersion + ".exe", AaptManager.class);
            } else {
                throw new BrutException("Could not identify platform: " + OSDetection.returnOS());
            }
        } catch (BrutException ex) {
            throw new BrutException(ex);
        }

        if (aaptBinary.setExecutable(true)) {
            return aaptBinary;
        }

        throw new BrutException("Can't set aapt binary as executable");
    }

    public static String getAaptExecutionCommand(String aaptPath, File aapt) throws BrutException {
        if (! aaptPath.isEmpty()) {
            File aaptFile = new File(aaptPath);
            if (aaptFile.canRead() && aaptFile.exists()) {
                aaptFile.setExecutable(true);
                return aaptFile.getPath();
            } else {
                throw new BrutException("binary could not be read: " + aaptFile.getAbsolutePath());
            }
        } else {
            return aapt.getAbsolutePath();
        }
    }

    public static int getAaptVersion(String aaptLocation) throws BrutException {
        return getApptVersion(new File(aaptLocation));
    }

    public static String getAaptBinaryName(Integer version) {
        return "aapt" + (version == 2 ? "2" : "");
    }

    public static int getAppVersionFromString(String version) throws BrutException {
        if (version.startsWith("Android Asset Packaging Tool (aapt) 2:")) {
            return 2;
        } else if (version.startsWith("Android Asset Packaging Tool (aapt) 2.")) {
            return 2; // Prior to Android SDK 26.0.2
        } else if (version.startsWith("Android Asset Packaging Tool, v0.")) {
            return 1;
        }

        throw new BrutException("aapt version could not be identified: " + version);
    }

    public static int getApptVersion(File aapt) throws BrutException {
        if (!aapt.isFile()) {
            throw new BrutException("Could not identify aapt binary as executable.");
        }
        aapt.setExecutable(true);

        List<String> cmd = new ArrayList<>();
        cmd.add(aapt.getAbsolutePath());
        cmd.add("version");

        String version = OS.execAndReturn(cmd.toArray(new String[0]));

        if (version == null) {
            throw new BrutException("Could not execute aapt binary at location: " + aapt.getAbsolutePath());
        }

        return getAppVersionFromString(version);
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/BrutIO.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.io.*;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import brut.common.BrutException;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import org.apache.commons.io.IOUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class BrutIO {
    public static void copyAndClose(InputStream in, OutputStream out)
            throws IOException {
        try {
            IOUtils.copy(in, out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }

    public static long recursiveModifiedTime(File[] files) {
        long modified = 0;
        for (int i = 0; i < files.length; i++) {
            long submodified = recursiveModifiedTime(files[i]);
            if (submodified > modified) {
                modified = submodified;
            }
        }
        return modified;
    }

    public static long recursiveModifiedTime(File file) {
        long modified = file.lastModified();
        if (file.isDirectory()) {
            File[] subfiles = file.listFiles();
            for (int i = 0; i < subfiles.length; i++) {
                long submodified = recursiveModifiedTime(subfiles[i]);
                if (submodified > modified) {
                    modified = submodified;
                }
            }
        }
        return modified;
    }

    public static CRC32 calculateCrc(InputStream input) throws IOException {
        CRC32 crc = new CRC32();
        int bytesRead;
        byte[] buffer = new byte[8192];
        while((bytesRead = input.read(buffer)) != -1) {
            crc.update(buffer, 0, bytesRead);
        }
        return crc;
    }

    public static String sanitizeUnknownFile(final File directory, final String entry) throws IOException, BrutException {
        if (entry.length() == 0) {
            throw new InvalidUnknownFileException("Invalid Unknown File - " + entry);
        }

        if (new File(entry).isAbsolute()) {
            throw new RootUnknownFileException("Absolute Unknown Files is not allowed - " + entry);
        }

        final String canonicalDirPath = directory.getCanonicalPath() + File.separator;
        final String canonicalEntryPath = new File(directory, entry).getCanonicalPath();

        if (!canonicalEntryPath.startsWith(canonicalDirPath)) {
            throw new TraversalUnknownFileException("Directory Traversal is not allowed - " + entry);
        }

        // https://stackoverflow.com/q/2375903/455008
        return canonicalEntryPath.substring(canonicalDirPath.length());
    }

    public static String normalizePath(String path) {
        char separator = File.separatorChar;

        if (separator != '/') {
            return path.replace(separator, '/');
        }

        return path;
    }

    public static void copy(File inputFile, ZipOutputStream outputFile) throws IOException {
        try (
                FileInputStream fis = new FileInputStream(inputFile)
        ) {
            IOUtils.copy(fis, outputFile);
        }
    }

    public static void copy(ZipFile inputFile, ZipOutputStream outputFile, ZipEntry entry) throws IOException {
        try (
                InputStream is = inputFile.getInputStream(entry)
        ) {
            IOUtils.copy(is, outputFile);
        }
    }

}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/DataInputDelegate.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.io.DataInput;
import java.io.IOException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
abstract public class DataInputDelegate implements DataInput {
    protected final DataInput mDelegate;

    public DataInputDelegate(DataInput delegate) {
        this.mDelegate = delegate;
    }

    public int skipBytes(int n) throws IOException {
        return mDelegate.skipBytes(n);
    }

    public int readUnsignedShort() throws IOException {
        return mDelegate.readUnsignedShort();
    }

    public int readUnsignedByte() throws IOException {
        return mDelegate.readUnsignedByte();
    }

    public String readUTF() throws IOException {
        return mDelegate.readUTF();
    }

    public short readShort() throws IOException {
        return mDelegate.readShort();
    }

    public long readLong() throws IOException {
        return mDelegate.readLong();
    }

    public String readLine() throws IOException {
        return mDelegate.readLine();
    }

    public int readInt() throws IOException {
        return mDelegate.readInt();
    }

    public void readFully(byte[] b, int off, int len) throws IOException {
        mDelegate.readFully(b, off, len);
    }

    public void readFully(byte[] b) throws IOException {
        mDelegate.readFully(b);
    }

    public float readFloat() throws IOException {
        return mDelegate.readFloat();
    }

    public double readDouble() throws IOException {
        return mDelegate.readDouble();
    }

    public char readChar() throws IOException {
        return mDelegate.readChar();
    }

    public byte readByte() throws IOException {
        return mDelegate.readByte();
    }

    public boolean readBoolean() throws IOException {
        return mDelegate.readBoolean();
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/Duo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class Duo<T1, T2> {
    public final T1 m1;
    public final T2 m2;

    public Duo(T1 t1, T2 t2) {
        this.m1 = t1;
        this.m2 = t2;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Duo<T1, T2> other = (Duo<T1, T2>) obj;
        if (this.m1 != other.m1 && (this.m1 == null || !this.m1.equals(other.m1))) {
            return false;
        }
        if (this.m2 != other.m2 && (this.m2 == null || !this.m2.equals(other.m2))) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 71 * hash + (this.m1 != null ? this.m1.hashCode() : 0);
        hash = 71 * hash + (this.m2 != null ? this.m2.hashCode() : 0);
        return hash;
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/ExtDataInput.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.io.*;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class ExtDataInput extends DataInputDelegate {
    public ExtDataInput(InputStream in) {
        this((DataInput) new DataInputStream(in));
    }

    public ExtDataInput(DataInput delegate) {
        super(delegate);
    }

    public int[] readIntArray(int length) throws IOException {
        int[] array = new int[length];
        for(int i = 0; i < length; i++) {
            array[i] = readInt();
        }
        return array;
    }

    public void skipInt() throws IOException {
        skipBytes(4);
    }

    public void skipCheckInt(int expected1, int expected2) throws IOException {
        int got = readInt();
        if (got != expected1 && got != expected2) {
            throw new IOException(String.format(
                "Expected: 0x%08x or 0x%08x, got: 0x%08x", expected1, expected2, got));
        }
    }

    public void skipCheckShort(short expected) throws IOException {
        short got = readShort();
        if (got != expected) {
            throw new IOException(String.format(
                "Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    public void skipCheckByte(byte expected) throws IOException {
        byte got = readByte();
        if (got != expected) {
            throw new IOException(String.format(
                    "Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    public void skipCheckChunkTypeInt(int expected, int possible) throws IOException {
        int got = readInt();

        if (got == possible || got < expected) {
            skipCheckChunkTypeInt(expected, -1);
        } else if (got != expected) {
            throw new IOException(String.format("Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    /**
     * The general contract of DataInput doesn't guarantee all the bytes requested will be skipped
     * and failure can occur for many reasons. We override this to try harder to skip all the bytes
     * requested (this is similar to DataInputStream's wrapper).
     */
    public final int skipBytes(int n) throws IOException {
        int total = 0;
        int cur = 0;

        while ((total < n) && ((cur = (int) super.skipBytes(n - total)) > 0)) {
            total += cur;
        }

        return total;
    }

    public String readNullEndedString(int length, boolean fixed)
            throws IOException {
        StringBuilder string = new StringBuilder(16);
        while(length-- != 0) {
            short ch = readShort();
            if (ch == 0) {
                break;
            }
            string.append((char) ch);
        }
        if (fixed) {
            skipBytes(length * 2);
        }

        return string.toString();
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/Jar.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;

import brut.common.BrutException;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
abstract public class Jar {
    private final static Set<String> mLoaded = new HashSet<String>();
    private final static Map<String, File> mExtracted = new HashMap<String, File>();

    public static File getResourceAsFile(String name, Class clazz) throws BrutException {
        File file = mExtracted.get(name);
        if (file == null) {
            file = extractToTmp(name, clazz);
            mExtracted.put(name, file);
        }
        return file;
    }

    public static File getResourceAsFile(String name) throws BrutException {
        return getResourceAsFile(name, Class.class);
    }

    public static void load(String libPath) {
        if (mLoaded.contains(libPath)) {
            return;
        }

        File libFile;
        try {
            libFile = getResourceAsFile(libPath);
        } catch (BrutException ex) {
            throw new UnsatisfiedLinkError(ex.getMessage());
        }

        System.load(libFile.getAbsolutePath());
    }

    public static File extractToTmp(String resourcePath) throws BrutException {
        return extractToTmp(resourcePath, Class.class);
    }

    public static File extractToTmp(String resourcePath, Class clazz) throws BrutException {
        return extractToTmp(resourcePath, "brut_util_Jar_", clazz);
    }

    public static File extractToTmp(String resourcePath, String tmpPrefix) throws BrutException {
        return extractToTmp(resourcePath, tmpPrefix, Class.class);
    }

    public static File extractToTmp(String resourcePath, String tmpPrefix, Class clazz) throws BrutException {
        try {
            InputStream in = clazz.getResourceAsStream(resourcePath);
            if (in == null) {
                throw new FileNotFoundException(resourcePath);
            }
            long suffix = ThreadLocalRandom.current().nextLong();
            suffix = suffix == Long.MIN_VALUE ? 0 : Math.abs(suffix);
            File fileOut = File.createTempFile(tmpPrefix, suffix + ".tmp");
            fileOut.deleteOnExit();

            OutputStream out = new FileOutputStream(fileOut);
            IOUtils.copy(in, out);
            in.close();
            out.close();

            return fileOut;
        } catch (IOException ex) {
            throw new BrutException("Could not extract resource: " + resourcePath, ex);
        }
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/OS.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import java.io.*;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import org.apache.commons.io.IOUtils;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
public class OS {

    private static final Logger LOGGER = Logger.getLogger("");

    public static void rmdir(File dir) throws BrutException {
        if (! dir.exists()) {
            return;
        }
        File[] files = dir.listFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.isDirectory()) {
                rmdir(file);
            } else {
                file.delete();
            }
        }
        dir.delete();
    }
        
    public static void rmfile(String file) throws BrutException {
    	File del = new File(file);
    	del.delete();
    }

    public static void rmdir(String dir) throws BrutException {
        rmdir(new File(dir));
    }

    public static void cpdir(File src, File dest) throws BrutException {
        dest.mkdirs();
        File[] files = src.listFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            File destFile = new File(dest.getPath() + File.separatorChar
                + file.getName());
            if (file.isDirectory()) {
                cpdir(file, destFile);
                continue;
            }
            try {
                InputStream in = new FileInputStream(file);
                OutputStream out = new FileOutputStream(destFile);
                IOUtils.copy(in, out);
                in.close();
                out.close();
            } catch (IOException ex) {
                throw new BrutException("Could not copy file: " + file, ex);
            }
        }
    }

    public static void cpdir(String src, String dest) throws BrutException {
        cpdir(new File(src), new File(dest));
    }

    public static void exec(String[] cmd) throws BrutException {
        Process ps = null;
        int exitValue = -99;
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            ps = builder.start();
            new StreamForwarder(ps.getErrorStream(), "ERROR").start();
            new StreamForwarder(ps.getInputStream(), "OUTPUT").start();
            exitValue = ps.waitFor();
            if (exitValue != 0)
                throw new BrutException("could not exec (exit code = " + exitValue + "): " + Arrays.toString(cmd));
        } catch (IOException ex) {
            throw new BrutException("could not exec: " + Arrays.toString(cmd), ex);
        } catch (InterruptedException ex) {
            throw new BrutException("could not exec : " + Arrays.toString(cmd), ex);
        }
    }

    public static String execAndReturn(String[] cmd) {
        ExecutorService executor = Executors.newCachedThreadPool();
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            builder.redirectErrorStream(true);

            Process process = builder.start();
            StreamCollector collector = new StreamCollector(process.getInputStream());
            executor.execute(collector);

            process.waitFor();
            if (! executor.awaitTermination(15, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                if (! executor.awaitTermination(5, TimeUnit.SECONDS)) {
                    System.err.println("Stream collector did not terminate.");
                }
            }
            return collector.get();
        } catch (IOException | InterruptedException e) {
            return null;
        }
    }

    public static File createTempDirectory() throws BrutException {
        try {
            File tmp = File.createTempFile("BRUT", null);
            tmp.deleteOnExit();
            if (!tmp.delete()) {
                throw new BrutException("Could not delete tmp file: " + tmp.getAbsolutePath());
            }
            if (!tmp.mkdir()) {
                throw new BrutException("Could not create tmp dir: " + tmp.getAbsolutePath());
            }
            return tmp;
        } catch (IOException ex) {
            throw new BrutException("Could not create tmp dir", ex);
        }
    }

    static class StreamForwarder extends Thread {

        StreamForwarder(InputStream is, String type) {
            mIn = is;
            mType = type;
        }

        @Override
        public void run() {
            try {
                BufferedReader br = new BufferedReader(new InputStreamReader(mIn));
                String line;
                while ((line = br.readLine()) != null) {
                    if (mType.equals("OUTPUT")) {
                        LOGGER.info(line);
                    } else {
                        LOGGER.warning(line);
                    }
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

        private final InputStream mIn;
        private final String mType;
    }

    static class StreamCollector implements Runnable {
        private final StringBuffer buffer = new StringBuffer();
        private final InputStream inputStream;

        public StreamCollector(InputStream inputStream) {
            super();
            this.inputStream = inputStream;
        }

        @Override
        public void run() {
            String line;
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
                while ((line = reader.readLine()) != null) {
                    buffer.append(line).append('\n');
                }
            } catch (IOException ignored) {}
        }

        public String get() {
            return buffer.toString();
        }
    }
}

```

`distribution/apktool/brut.j.util/src/main/java/brut/util/OSDetection.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

public class OSDetection {
    private static String OS = System.getProperty("os.name").toLowerCase();
    private static String Bit = System.getProperty("sun.arch.data.model").toLowerCase();

    public static boolean isWindows() {
        return (OS.contains("win"));
    }

    public static boolean isMacOSX() {
        return (OS.contains("mac"));
    }

    public static boolean isUnix() {
        return (OS.contains("nix") || OS.contains("nux") || OS.contains("aix") || (OS.contains("sunos")));
    }

    public static boolean is64Bit() {
        if (isWindows()) {
            String arch = System.getenv("PROCESSOR_ARCHITECTURE");
            String wow64Arch = System.getenv("PROCESSOR_ARCHITEW6432");

            return arch != null && arch.endsWith("64") || wow64Arch != null && wow64Arch.endsWith("64");
        }
        return Bit.equalsIgnoreCase("64");
    }

    public static String returnOS() {
        return OS;
    }
}

```

`distribution/dex2jar/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/dex2jar/libs/open-source-license.txt`:

```txt
==== dx-*.jar
Apache 2.0 http://www.apache.org/licenses/LICENSE-2.0.html


==== antlr-*.jar
[The BSD License]
Copyright (c) 2003-2007, Terence Parr
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.
* Neither the name of the author nor the names of its contributors
  may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.


==== asm-*.jar

 ASM: a very small and fast Java bytecode manipulation framework
 Copyright (c) 2000-2005 INRIA, France Telecom
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. Neither the name of the copyright holders nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.


```

`distribution/dex2jar/src/main/java/com/fakerandroid/decoder/dex2jar/Dex2jar.java`:

```java
package com.fakerandroid.decoder.dex2jar;

import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.dex2jar.tools.BaksmaliBaseDexExceptionHandler;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Logger;

public class Dex2jar {

    private static Logger logger = Logger.getLogger("Dex2jar");
    public static void toJar(File apk,File out)  {
        TreeMap<String, DexFileReader> fileReaderTreeMap = null;
        try {
            fileReaderTreeMap = PatchMultiDexFileReader.open(Files.readAllBytes(apk.toPath()));
        } catch (IOException e) {
            e.printStackTrace();
        }
        BaksmaliBaseDexExceptionHandler handler = false ? null : new BaksmaliBaseDexExceptionHandler();
        Iterator it = fileReaderTreeMap.entrySet().iterator();
        File outPath = new File(out,"classes.all.dex.jar");
        if(outPath.exists()){
            outPath.delete();
        }
        while (it.hasNext()){
            Map.Entry<String, DexFileReader>  entry = (Map.Entry) it.next();
            DexFileReader dexFileReader = entry.getValue();
            try {
                PatchDex2jar.from(dexFileReader).withExceptionHandler(handler).reUseReg(false).topoLogicalSort()
                        .skipDebug(false).optimizeSynchronized(false).printIR(false)
                        .noCode(false).skipExceptions(false).to(outPath.toPath());
            } catch (IOException e) {
                logger.info("dex2jar fail :"+dexFileReader.getClassSize());
                e.printStackTrace();
            }
        }
    }
}

```

`distribution/dex2jar/src/main/java/com/fakerandroid/decoder/dex2jar/PatchDex2jar.java`:

```java
package com.fakerandroid.decoder.dex2jar;

import com.googlecode.d2j.converter.IR2JConverter;
import com.googlecode.d2j.dex.*;
import com.googlecode.d2j.node.DexFileNode;
import com.googlecode.d2j.node.DexMethodNode;
import com.googlecode.d2j.reader.BaseDexFileReader;
import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.reader.zip.ZipUtil;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.ir.stmt.LabelStmt;
import com.googlecode.dex2jar.ir.stmt.Stmt;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.file.*;
import java.nio.file.spi.FileSystemProvider;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class PatchDex2jar {
    private DexExceptionHandler exceptionHandler;
    private final BaseDexFileReader reader;
    private int readerConfig;
    private int v3Config;

    public static PatchDex2jar from(byte[] in) throws IOException {
        return from((BaseDexFileReader)(new DexFileReader(ZipUtil.readDex(in))));
    }

    public static PatchDex2jar from(ByteBuffer in) throws IOException {
        return from((BaseDexFileReader)(new DexFileReader(in)));
    }

    public static PatchDex2jar from(BaseDexFileReader reader) {
        return new PatchDex2jar(reader);
    }

    public static PatchDex2jar from(File in) throws IOException {
        return from(Files.readAllBytes(in.toPath()));
    }

    public static PatchDex2jar from(InputStream in) throws IOException {
        return from((BaseDexFileReader)(new DexFileReader(in)));
    }

    public static PatchDex2jar from(String in) throws IOException {
        return from(new File(in));
    }

    private PatchDex2jar(BaseDexFileReader reader) {
        this.reader = reader;
        this.readerConfig |= 1;
    }

    private void doTranslate(final Path dist) throws IOException {
        DexFileNode fileNode = new DexFileNode();

        try {
            this.reader.accept(fileNode, this.readerConfig | 32);
        } catch (Exception var4) {
            this.exceptionHandler.handleFileException(var4);
        }

        ClassVisitorFactory cvf = new ClassVisitorFactory() {
            public ClassVisitor create(String name) {
                final ClassWriter cw = new ClassWriter(1);
                final LambadaNameSafeClassAdapter rca = new LambadaNameSafeClassAdapter(cw);
                return new ClassVisitor(327680, rca) {
                    public void visitEnd() {
                        super.visitEnd();
                        String className = rca.getClassName();

                        byte[] data;
                        try {
                            data = cw.toByteArray();
                        } catch (Exception var6) {
                            System.err.println(String.format("ASM fail to generate .class file: %s", className));
                            PatchDex2jar.this.exceptionHandler.handleFileException(var6);
                            return;
                        }

                        try {
                            Path dist1 = dist.resolve(className + ".class");
                            Path parent = dist1.getParent();
                            if (parent != null && !Files.exists(parent, new LinkOption[0])) {
                                Files.createDirectories(parent);
                            }

                            Files.write(dist1, data, new OpenOption[0]);
                        } catch (IOException var5) {
                            var5.printStackTrace(System.err);
                        }

                    }
                };
            }
        };
        (new ExDex2Asm(this.exceptionHandler) {
            public void convertCode(DexMethodNode methodNode, MethodVisitor mv) {
                if ((PatchDex2jar.this.readerConfig & 4) == 0 || !methodNode.method.getName().equals("<clinit>")) {
                    super.convertCode(methodNode, mv);
                }
            }

            public void optimize(IrMethod irMethod) {
                T_cleanLabel.transform(irMethod);
                if (0 != (PatchDex2jar.this.v3Config & 2)) {
                }

                T_deadCode.transform(irMethod);
                T_removeLocal.transform(irMethod);
                T_removeConst.transform(irMethod);
                T_zero.transform(irMethod);
                if (T_npe.transformReportChanged(irMethod)) {
                    T_deadCode.transform(irMethod);
                    T_removeLocal.transform(irMethod);
                    T_removeConst.transform(irMethod);
                }

                T_new.transform(irMethod);
                T_fillArray.transform(irMethod);
                T_agg.transform(irMethod);
                T_multiArray.transform(irMethod);
                T_voidInvoke.transform(irMethod);
                if (0 != (PatchDex2jar.this.v3Config & 4)) {
                    int i = 0;
                    Iterator var3 = irMethod.stmts.iterator();

                    while(var3.hasNext()) {
                        Stmt p = (Stmt)var3.next();
                        if (p.st == Stmt.ST.LABEL) {
                            LabelStmt labelStmt = (LabelStmt)p;
                            labelStmt.displayName = "L" + i++;
                        }
                    }

                    System.out.println(irMethod);
                }

                T_type.transform(irMethod);
                T_unssa.transform(irMethod);
                T_ir2jRegAssign.transform(irMethod);
                T_trimEx.transform(irMethod);
            }

            public void ir2j(IrMethod irMethod, MethodVisitor mv) {
                (new IR2JConverter(0 != (8 & PatchDex2jar.this.v3Config))).convert(irMethod, mv);
            }
        }).convertDex(fileNode, cvf);
    }

    public DexExceptionHandler getExceptionHandler() {
        return this.exceptionHandler;
    }

    public BaseDexFileReader getReader() {
        return this.reader;
    }

    public PatchDex2jar reUseReg(boolean b) {
        if (b) {
            this.v3Config |= 1;
        } else {
            this.v3Config &= -2;
        }

        return this;
    }

    public PatchDex2jar topoLogicalSort(boolean b) {
        if (b) {
            this.v3Config |= 2;
        } else {
            this.v3Config &= -3;
        }

        return this;
    }

    public PatchDex2jar noCode(boolean b) {
        if (b) {
            this.readerConfig |= 132;
        } else {
            this.readerConfig &= -133;
        }

        return this;
    }

    public PatchDex2jar optimizeSynchronized(boolean b) {
        if (b) {
            this.v3Config |= 8;
        } else {
            this.v3Config &= -9;
        }

        return this;
    }

    public PatchDex2jar printIR(boolean b) {
        if (b) {
            this.v3Config |= 4;
        } else {
            this.v3Config &= -5;
        }

        return this;
    }

    public PatchDex2jar reUseReg() {
        this.v3Config |= 1;
        return this;
    }

    public PatchDex2jar optimizeSynchronized() {
        this.v3Config |= 8;
        return this;
    }

    public PatchDex2jar printIR() {
        this.v3Config |= 4;
        return this;
    }

    public PatchDex2jar topoLogicalSort() {
        this.v3Config |= 2;
        return this;
    }

    public void setExceptionHandler(DexExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }

    public PatchDex2jar skipDebug(boolean b) {
        if (b) {
            this.readerConfig |= 1;
        } else {
            this.readerConfig &= -2;
        }

        return this;
    }

    public PatchDex2jar skipDebug() {
        this.readerConfig |= 1;
        return this;
    }

    public void to(Path file) throws IOException {
        if (Files.exists(file, new LinkOption[0]) && Files.isDirectory(file, new LinkOption[0])) {
            this.doTranslate(file);
        } else {
            FileSystem fs = createZip(file);
            Throwable var3 = null;

            try {
                this.doTranslate(fs.getPath("/"));
            } catch (Throwable var12) {
                var3 = var12;
                throw var12;
            } finally {
                if (fs != null) {
                    if (var3 != null) {
                        try {
                            fs.close();
                        } catch (Throwable var11) {
                            var3.addSuppressed(var11);
                        }
                    } else {
                        fs.close();
                    }
                }

            }
        }

    }

    private static FileSystem createZip(Path output) throws IOException {
        Map<String, Object> env = new HashMap();
        env.put("create", "true");
//        Files.deleteIfExists(output);
        Path parent = output.getParent();
        if (parent != null && !Files.exists(parent, new LinkOption[0])) {
            Files.createDirectories(parent);
        }

        Iterator var3 = FileSystemProvider.installedProviders().iterator();

        FileSystemProvider p;
        String s;
        do {
            if (!var3.hasNext()) {
                throw new IOException("cant find zipfs support");
            }

            p = (FileSystemProvider)var3.next();
            s = p.getScheme();
        } while(!"jar".equals(s) && !"zip".equalsIgnoreCase(s));

        return p.newFileSystem(output, env);
    }

    public PatchDex2jar withExceptionHandler(DexExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
        return this;
    }

    public PatchDex2jar skipExceptions(boolean b) {
        if (b) {
            this.readerConfig |= 256;
        } else {
            this.readerConfig &= -257;
        }

        return this;
    }
}

```

`distribution/dex2jar/src/main/java/com/fakerandroid/decoder/dex2jar/PatchMultiDexFileReader.java`:

```java
package com.fakerandroid.decoder.dex2jar;

import com.googlecode.d2j.reader.DexFileReader;
import com.googlecode.d2j.util.zip.AccessBufByteArrayOutputStream;
import com.googlecode.d2j.util.zip.ZipEntry;
import com.googlecode.d2j.util.zip.ZipFile;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;
import java.util.TreeMap;

public class PatchMultiDexFileReader {

    public static TreeMap<String, DexFileReader> open(byte[] data) throws IOException {
        TreeMap<String, DexFileReader> dexFileReaders = new TreeMap();
        if (data.length < 3) {
            throw new IOException("File too small to be a dex/zip");
        } else if("PK".equals(new String(data, 0, 2, StandardCharsets.ISO_8859_1))) {

            ZipFile zipFile = new ZipFile(data);
            Throwable var3 = null;

            try {
                Iterator var4 = zipFile.entries().iterator();

                while(var4.hasNext()) {
                    ZipEntry e = (ZipEntry)var4.next();
                    String entryName = e.getName();
                    if (entryName.startsWith("classes") && entryName.endsWith(".dex") && !dexFileReaders.containsKey(entryName)) {
                        dexFileReaders.put(entryName, new DexFileReader(toByteArray(zipFile.getInputStream(e))));
                    }
                }
            } catch (Throwable var14) {
                var3 = var14;
                throw var14;
            } finally {
                if (zipFile != null) {
                    if (var3 != null) {
                        try {
                            zipFile.close();
                        } catch (Throwable var13) {
                            var3.addSuppressed(var13);
                        }
                    } else {
                        zipFile.close();
                    }
                }

            }

            if (dexFileReaders.size() == 0) {
                throw new IOException("Can not find classes.dex in zip file");
            } else {
                return dexFileReaders;
            }
        } else {
            throw new IOException("the src file not a .dex or zip file");
        }
    }

    private static byte[] toByteArray(InputStream is) throws IOException {
        AccessBufByteArrayOutputStream out = new AccessBufByteArrayOutputStream();
        byte[] buff = new byte[1024];

        for(int c = is.read(buff); c > 0; c = is.read(buff)) {
            out.write(buff, 0, c);
        }

        return out.getBuf();
    }
}

```

`distribution/il2cpp-dumper/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation(project(':library'))
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/il2cpp-dumper/src/main/java/com/fakerandroid/decoder/il2cpp/Il2cppBinary.java`:

```java
package com.fakerandroid.decoder.il2cpp;

import com.fakerandroid.decoder.exception.BinaryException;
import com.fakerandroid.decoder.util.Jar;
import com.fakerandroid.decoder.util.OS;
import com.fakerandroid.decoder.util.OSDetection;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Il2cppBinary {

    private static  File getIl2cppBinary() throws BinaryException {
        File il2cppBinary=null;
        if (OSDetection.isMacOSX()) {
            il2cppBinary = Jar.getResourceAsFile("/prebuilt/macosx/"+"il2cpp", Il2cppBinary.class);
        } else if (OSDetection.isUnix()) {
            il2cppBinary = Jar.getResourceAsFile("/prebuilt/linux/"+"il2cpp", Il2cppBinary.class);
        } else if (OSDetection.isWindows()) {
            il2cppBinary = Jar.getResourceAsFile("/prebuilt/windows/"+"il2cpp.exe", Il2cppBinary.class);
        }
        if(il2cppBinary!=null){
            il2cppBinary.setExecutable(true);
        }
        return il2cppBinary;
    }

    public static void dumpIl2cpp(File in,File out) throws Exception {
        List<String> il2cppBinaryCommad = new ArrayList<>();
        File il2cppBinary = getIl2cppBinary();
        if(il2cppBinary==null){
            throw  new RuntimeException("null il2cppBinary file");
        }
        il2cppBinaryCommad.add(il2cppBinary.getAbsolutePath());

        il2cppBinaryCommad.add("-i");
        il2cppBinaryCommad.add(in.getAbsolutePath());

        File il2cppScaffolding = new File(out.getAbsolutePath(),"Il2cpp-Scaffolding");
        il2cppBinaryCommad.add("-h");
        il2cppBinaryCommad.add(il2cppScaffolding.getAbsolutePath());

        il2cppBinaryCommad.add("-e");
        il2cppBinaryCommad.add("none");

        File il2cppScaffoldingHelper = new File(out.getAbsolutePath(),"Il2cppScaffoldingHelper");

        il2cppBinaryCommad.add("-c");
        il2cppBinaryCommad.add(new File(il2cppScaffoldingHelper,"help.cs").getAbsolutePath());

        il2cppBinaryCommad.add("-p");
        il2cppBinaryCommad.add(new File(il2cppScaffoldingHelper,"help.py").getAbsolutePath());

        il2cppBinaryCommad.add("-o");
        il2cppBinaryCommad.add(new File(il2cppScaffoldingHelper,"help.json").getAbsolutePath());

        il2cppBinaryCommad.add("--cpp-compiler");
        il2cppBinaryCommad.add("GCC");


        try {
            OS.exec(il2cppBinaryCommad.toArray(new String[0]));
            File scaffolding_ARM = new File(out,"Il2cpp-Scaffolding-ARM");
            if(scaffolding_ARM.exists()){
                formatScaffolding(scaffolding_ARM);
            }
            File Scaffolding_ARM64 = new File(out,"Il2cpp-Scaffolding-ARM64");
            if(Scaffolding_ARM64.exists()){
                formatScaffolding(Scaffolding_ARM64);
            }
            File il2cppScaffoldingx86 = new File(out,"Il2cpp-Scaffolding-x86");
            if(il2cppScaffoldingx86.exists()){
                formatScaffolding(il2cppScaffoldingx86);
            }
            File il2cppScaffoldingx64 = new File(out,"Il2cpp-Scaffolding-x64");
            if(il2cppScaffoldingx64.exists()){
                formatScaffolding(il2cppScaffoldingx64);
            }
        } catch (Exception e) {
            //
        }
    }
    private static void  formatScaffolding(File scaffolding) throws IOException {
        if(scaffolding.exists()&&scaffolding.isDirectory()){
            File scaffolding_ARM_spam[] =scaffolding.listFiles();

            for (File f:scaffolding_ARM_spam ) {//删除无用文件
                if(!f.isDirectory()){
                    f.delete();
                }
            }
            File userDir = new File(scaffolding,"user");
            delete(userDir);
            File frameworkDir = new File(scaffolding,"framework");
            delete(frameworkDir);
            File appdataDir = new File(scaffolding,"appdata");
            File appdataFils[] = appdataDir.listFiles();
            for (File f:appdataFils) {
                f.renameTo(new File(scaffolding,f.getName()));
            }
            delete(appdataDir);
        }
    }
    public static void delete(File file) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (File f : files) {
                delete(f);
            }
        }
        file.delete();
    }
}

```

`distribution/project/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation(project(':library'))
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/project/src/main/java/com/fakerandroid/decoder/project/ProjectMerge.java`:

```java
package com.fakerandroid.decoder.project;

import com.fakerandroid.decoder.util.PatchUtil;

import java.io.File;
import java.io.IOException;

public class ProjectMerge {
    public static void copyProject(File out) throws IOException {
        PatchUtil.copyDirFromJar("/project/",out.getAbsolutePath());
    }

}

```

`distribution/project/src/main/resources/project/app/build.gradle.tmpl`:

```tmpl
// Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
//apply plugin: 'faker.android.application'
apply plugin: 'com.android.application'
dependencies {
    compileOnly fileTree(dir: 'javaScaffoding', include: ['*.jar'])
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    //Below you can custom your dependencies
}

android {
    compileSdkVersion 29
    buildToolsVersion '29.0.3'
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion 23
        targetSdkVersion {targetSdkVersion}
        applicationId '{pkg}'
        externalNativeBuild {
            cmake {
                cppFlags "-std=c++11"
            }
        }
        ndk {
            abiFilters {abi} // you can make one only for dev to improve building speed
        }
        versionCode {versionCode}
        versionName '{versionName}'
        multiDexEnabled true
    }

    aaptOptions {//TODO NOTE when you happen a asset file access problem you can try add pattern here
        noCompress = ['.unity3d', '.ress', '.resource', '.obb']
        ignoreAssetsPattern = "!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~"
    }

    lintOptions {
        abortOnError false
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }

    buildTypes {
        debug {
            debuggable true
            minifyEnabled false
            useProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt')
            signingConfig signingConfigs.debug
            jniDebuggable true
        }
        release {
            debuggable false
            minifyEnabled false
            useProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt')
            signingConfig signingConfigs.debug
        }
    }
    //TODO NOTE This is a FakerAndroid feature for hiding sensitive code avoid static dex analysis like passing a appstore checker
    sensitiveOptions {//when build type debuggable is false this feature working only and with this feature working building speed will slow down ,you can make it working when building a release apk
        //collapseToAssetFile 'dex' //keep this string same as c++ fakeDex method last param
        /**confing packages or classe with no ext but this cant include application class or application ref classes **/
        //collapsePackage 'com.google'
        //collapsePackage 'com.vungle'
        //collapsePackage 'com.inmobi'
        //collapsePackage 'com.adcolony'
        //collapsePackage 'com.applovin'
        //collapsePackage 'com.chartboost'
    }
//    packagingOptions { //TODO if you happen a symbol problem try open this
//        doNotStrip '*/armeabi-v7a/*.so'
//        doNotStrip '*/arm64-v8a/*.so'
//    }
}

```

`distribution/project/src/main/resources/project/build.gradle.tmpl`:

```tmpl
// Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
allprojects {
    buildscript {
        repositories {
            google()
            mavenCentral()
        }

        dependencies {
            classpath 'com.fakerandroid.tools.build:gradle:1.0.37'
            //classpath 'com.android.tools.build:gradle:4.1.0' // if you happen a plugin problem when uese thirdpart gradle plugin oppen this
        }
    }

    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`distribution/project/src/main/resources/project/gradle.properties.tmpl`:

```tmpl
#Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
org.gradle.jvmargs=-Xmx4096M
android.injected.testOnly=false
```

`distribution/project/src/main/resources/project/gradle/wrapper/gradle-wrapper.properties.tmpl`:

```tmpl
#Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-6.5.1-all.zip

```

`distribution/project/src/main/resources/project/gradlew.bat.tmpl`:

```tmpl
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`distribution/project/src/main/resources/project/gradlew.tmpl`:

```tmpl
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`distribution/project/src/main/resources/project/settings.gradle.tmpl`:

```tmpl
//Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
include ':app'
```

`distribution/runtime-base/build.gradle`:

```gradle
plugins {
    id 'java'
}
group 'faker.android'
version '1.0-SNAPSHOT'
repositories {
    mavenCentral()
}

dependencies {
    implementation(project(':library'))
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/runtime-base/src/main/java/com/fakerandroid/decoder/runtime/base/RuntimeBase.java`:

```java
package com.fakerandroid.decoder.runtime.base;

import com.fakerandroid.decoder.util.PatchUtil;

import java.io.File;
import java.io.IOException;

public class RuntimeBase {
    public static void mergeRuntimeLibsCpp(File out){
//        PatchUtil.copyDirFromJar("/libs/cpp",out.getAbsolutePath());
    }

    public static void mergeRuntimeLibsJava(File out) throws IOException {
        PatchUtil.copyDirFromJar("/libs/java",out.getAbsolutePath());
    }

    public static void mergeRuntimeJavaCode(File out) throws IOException {
        PatchUtil.copyDirFromJar("/template/java",out.getAbsolutePath());
    }

    public static void mergeRuntimeCppCode(File out) throws IOException {
        PatchUtil.copyDirFromJar("/template/cpp",out.getAbsolutePath());
    }
}

```

`distribution/runtime-base/src/main/resources/libs/java/note.txt`:

```txt
This dir you can custom your jar files
```

`distribution/runtime-base/src/main/resources/template/cpp/CMakeLists.txt.tmpl`:

```tmpl
#Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid

add_definitions(-DENABLE_DEBUG -DABC)
cmake_minimum_required(VERSION 3.6)
include_directories(src/main/cpp/include)

find_package(base REQUIRED CONFIG)

file(GLOB native_srcc "${CMAKE_SOURCE_DIR}/*.cpp")
add_library(
        native-lib
        SHARED
        ${native_srcc}
        )
target_link_libraries(
        native-lib
        base::tool
        android
        z
        log)
```

`distribution/runtime-base/src/main/resources/template/cpp/common.h.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
#include <android/log.h>
#define LOG_TAG "xNative"
#define DEBUG //del this line for closing log
#ifdef DEBUG
    #define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
    #define LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
    #define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#else
    #define  LOGI(...) NULL;
    #define LOGD(...)  NULL;
    #define LOGE(...)  NULL;
#endif



```

`distribution/runtime-base/src/main/resources/template/cpp/include/faker.h.tmpl`:

```tmpl
#include <jni.h>
jint onJniLoad(JavaVM *vm, void *reserved);
long baseImageAddr(const char *soname);
bool fakeCpp(void *function_address, void *replace_call,void **origin_call);
bool fakeDex(JNIEnv *env,jobject base,const char *fakeDexAssetFileName);
```

`distribution/runtime-base/src/main/resources/template/cpp/native-lib.cpp.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
#include <jni.h>
#include <string>
#include "common.h"
#include <fstream>
#include <sstream>
#include "include/faker.h"
JavaVM *global_jvm;
JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if ((*vm).GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) == JNI_OK) {
        LOGI("JNI_OnLoad %s","sucess");
    }else{
        LOGI("JNI_OnLoad %s","erro");
    }
    global_jvm = vm;

    return onJniLoad(vm,reserved);
}


static jobject callBack;
/**
 * in your replace_call method you can call this method to call java
 * @param event
 */
void callJava(const char *event) {
    if(callBack==NULL) {
        return;
    }
    JNIEnv* env;
    global_jvm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_4);
    jclass clazz = env->GetObjectClass(callBack);
    jmethodID onCall = env->GetMethodID(clazz, "onJniCall", "(Ljava/lang/String;)V");
    jstring envent = env->NewStringUTF(event);
    env->CallVoidMethod(callBack, onCall, envent);
    env->DeleteLocalRef(envent);
}



extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerApp_fakeApp(JNIEnv *env, jobject thiz, jobject application) {
    /**
     * you can do yor hook work here
     * below  is demo code demo code hook libil2cpp.so
     */
     //long base = baseImageAddr("libil2cpp.so");
     //LOGE("baseImageAddr : %ld",base);
     //By ida get or ghidra get the method offset
     //Behaviour_get_isActiveAndEnabled =base + offset,HookedBehaviour_get_isActiveAndEnabled = your define method,Behaviour_get_isActiveAndEnabled =  base + offset
     //fakeCpp((void *) Behaviour_get_isActiveAndEnabled, (void *)HookedBehaviour_get_isActiveAndEnabled ,reinterpret_cast<void **>(&Behaviour_get_isActiveAndEnabled));

}
extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerApp_fakeDex(JNIEnv *env, jobject thiz, jobject base) {
    fakeDex(env,base,"dex");//dex collapse feature support
}

extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerActivity_registerCallBack(JNIEnv *env, jobject thiz,jobject object) {
    /**
     * init the callback global for other c++ method to call
     */
    callBack = env->NewGlobalRef(object);//
}
```

`distribution/runtime-base/src/main/resources/template/java/com/fakerandroid/boot/FakerActivity.java.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
package com.fakerandroid.boot;
import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.Window;
import {R};
/**
 * TODO NOTE:this is a demo act if you want run it you should mode the manifest and extends the original main act best
 * TODO NOTE:if the original act is a final class you cna mod smali to change it public then run it run you got the public javascaffoding api to extends it
 * TODO NOTE: you can extend the original main act
 */
public class FakerActivity extends Activity implements JniBridge {
    public native void registerCallBack(Object object);
    static final int HANDLER_MSG_CALLJAVA = 1000;
    final Handler handler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case HANDLER_MSG_CALLJAVA:
                    String cmsg = (String) msg.obj;
                    callJava(cmsg);
                    break;
            }
            super.handleMessage(msg);
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState){
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        super.onCreate(savedInstanceState);
        registerCallBack(this);

    }
    @Override
    public void onJniCall(String msg) {// unity player isnot main thread transfer method to main thread
        Message message = new Message();
        message.what =HANDLER_MSG_CALLJAVA;
        message.obj = msg;
        handler.sendMessage(message);
    }

    private void callJava(String msg){
        Logger.log(msg);
    }
}

```

`distribution/runtime-base/src/main/resources/template/java/com/fakerandroid/boot/FakerApp.java.tmpl`:

```tmpl
package com.fakerandroid.boot;
import android.app.Application;
import android.content.Context;

public class FakerApp extends {APPLICATION_NAME} {

    static {
        System.loadLibrary("native-lib");
    }
    @Override
    public void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        fakeDex(base);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        fakeApp(this);
    }

    private native void fakeApp(Application application);

    private native void fakeDex(Context base);

}

```

`distribution/runtime-base/src/main/resources/template/java/com/fakerandroid/boot/JniBridge.java.tmpl`:

```tmpl
package com.fakerandroid.boot;

public interface JniBridge {
    void onJniCall(String event);
}

```

`distribution/runtime-base/src/main/resources/template/java/com/fakerandroid/boot/Logger.java.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
package com.fakerandroid.boot;

import android.util.Log;

public class Logger {
    private static final boolean DEBUG = true;
    private static final String TAG = "FakerAndroid";
    public static void log(String log){
        if(DEBUG){
            Log.e(TAG,log);
        }
    }
}

```

`distribution/runtime-il2cpp/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation(project(':library'))
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/runtime-il2cpp/src/main/java/com/fakerandroid/decoder/rutime/il2cpp/RuntimeIl2cpp.java`:

```java
package com.fakerandroid.decoder.rutime.il2cpp;

import com.fakerandroid.decoder.util.PatchUtil;

import java.io.File;
import java.io.IOException;

public class RuntimeIl2cpp {
    public static void mergeRuntimeIl2cppCpp(File out) throws IOException {
        PatchUtil.copyDirFromJar("/il2cpp-template/cpp",out.getAbsolutePath());
        mergeRuntimeIl2cppscaffolding(out);
    }

    public static void mergeRuntimeIl2cppJava(File out) throws IOException {
        PatchUtil.copyDirFromJar("/il2cpp-template/java",out.getAbsolutePath());
    }

    private static void mergeRuntimeIl2cppscaffolding(File out) throws IOException {
        File il2cppScaffoldingARM = new File(out,"Il2cpp-Scaffolding-ARM");
        if(il2cppScaffoldingARM.exists()){
            PatchUtil.copyDirFromJar("/il2cpp-template/scaffolding-cpp",il2cppScaffoldingARM.getAbsolutePath());
        }
        File il2cppScaffoldingARM64 = new File(out,"Il2cpp-Scaffolding-ARM64");
        if(il2cppScaffoldingARM64.exists()){
            PatchUtil.copyDirFromJar("/il2cpp-template/scaffolding-cpp",il2cppScaffoldingARM64.getAbsolutePath());
        }
        File il2cppScaffoldingx86 = new File(out,"Il2cpp-Scaffolding-x86");
        if(il2cppScaffoldingARM64.exists()){
            PatchUtil.copyDirFromJar("/il2cpp-template/scaffolding-cpp",il2cppScaffoldingx86.getAbsolutePath());
        }
    }
}

```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/cpp/CMakeLists.txt.tmpl`:

```tmpl
#Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid

add_definitions(-DENABLE_DEBUG -DABC)
cmake_minimum_required(VERSION 3.6)
include_directories(src/main/cpp/include)
if(${ANDROID_ABI} MATCHES "arm64-v8a")
    file(GLOB Scaffolding "${CMAKE_SOURCE_DIR}/Il2cpp-Scaffolding-ARM64/*.cpp")
elseif(${ANDROID_ABI} MATCHES  "armeabi-v7a")
    file(GLOB Scaffolding "${CMAKE_SOURCE_DIR}/Il2cpp-Scaffolding-ARM/*.cpp")
elseif(${ANDROID_ABI} MATCHES  "x86")
    file(GLOB Scaffolding "${CMAKE_SOURCE_DIR}/Il2cpp-Scaffolding-x86/*.cpp")
endif()

find_package(base REQUIRED CONFIG)

file(GLOB native_srcc "${CMAKE_SOURCE_DIR}/*.cpp")

add_library(
        native-lib
        SHARED
        ${native_srcc}
        ${Scaffolding}
        )
target_link_libraries(
        native-lib
        base::tool
        android
        z
        log)
```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/cpp/native-lib.cpp.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
#include <jni.h>
#include <string>
#include "common.h"

#include <fstream>
#include <sstream>
#if defined(__aarch64__)
#include "Il2cpp-Scaffolding-ARM64/il2cpp-init.h"
#include "Il2cpp-Scaffolding-ARM64/il2cpp-appdata.h"
#elif defined(__arm__)
#include "Il2cpp-Scaffolding-ARM/il2cpp-init.h"
#include "Il2cpp-Scaffolding-ARM/il2cpp-appdata.h"
#elif defined(__i386__)
#include "Il2cpp-Scaffolding-x86/il2cpp-init.h"
#include "Il2cpp-Scaffolding-x86/il2cpp-appdata.h"
#elif defined(__x86_64__)
#include "Il2cpp-Scaffolding-x86_64/il2cpp-init.h"
#include "Il2cpp-Scaffolding-x86_64/il2cpp-appdata.h"
#endif
#include "include/faker.h"
using namespace app;
JavaVM *global_jvm;

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if ((*vm).GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) == JNI_OK) {
        LOGI("JNI_OnLoad %s","sucess");
    }else{
        LOGI("JNI_OnLoad %s","erro");
    }
    global_jvm = vm;

    return onJniLoad(vm,reserved);
}

/**
 * this a util cover c# string to c string
 * @param str
 * @return
 */
const char* coverIl2cppString2Char(Il2CppString *str){
    MonoString *monoString = reinterpret_cast<MonoString *>(str);
    const char *s = monoString->toChars();
    return s;
}


MonoString* coverChar2Il2cppString(const char *c){
    MonoString *monoString =  new MonoString();
    monoString->setMonoString(c);
    return monoString;
}

static jobject callBack;
/**
 * in your replace_call method you can call this method to call java
 * @param event
 */
void callJava(const char *event) {
    if(callBack==NULL) {
        return;
    }
    JNIEnv* env;
    global_jvm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_4);
    jclass clazz = env->GetObjectClass(callBack);
    jmethodID onCall = env->GetMethodID(clazz, "onJniCall", "(Ljava/lang/String;)V");
    jstring envent = env->NewStringUTF(event);
    env->CallVoidMethod(callBack, onCall, envent);
    env->DeleteLocalRef(envent);
}


/**
 * this is a demo hook replace call method
 * @param klass
 * @return
 */
//bool HookedBehaviour_get_isActiveAndEnabled(Behaviour *klass) {
//    bool  b = Behaviour_get_isActiveAndEnabled(klass, NULL);
//    if(!b){
//        return b;
//    }
//    GameObject *gameObject = Component_get_gameObject(reinterpret_cast<Component *>(klass), NULL);
//    if(gameObject==nullptr){
//        return b;
//    }
//    LOGI("class %p---- HookedBehaviour_get_isActiveAndEnabled GameObject Mame: %s",klass,"");
//    String *name = Object_1_get_name(reinterpret_cast<Object_1 *>(gameObject), NULL);
//
//    if(name== nullptr){
//        return b;
//    }
//    const char *s = coverIl2cppString2Char(reinterpret_cast<Il2CppString *>(name));
//
//    LOGI("class %p---- HookedBehaviour_get_isActiveAndEnabled GameObject Mame: %s",klass,s);
//    if(strcmp(s,"Share")==0){
//
//    }
//    return b;
//}

extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerApp_fakeApp(JNIEnv *env, jobject thiz, jobject application) {
    /**
     * you can do yor hook work here
     * below  is demo code demo code hook libil2cpp.so
     */
    long base = baseImageAddr("libil2cpp.so");
    LOGE("baseImageAddr : %ld",base);
    init_il2cpp(base);
    //fakeCpp((void *) Behaviour_get_isActiveAndEnabled, (void *)HookedBehaviour_get_isActiveAndEnabled ,reinterpret_cast<void **>(&Behaviour_get_isActiveAndEnabled));
}
extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerApp_fakeDex(JNIEnv *env, jobject thiz, jobject base) {
    fakeDex(env,base,"dex");//dex collapse feature support
}

extern "C"
JNIEXPORT void JNICALL
Java_com_fakerandroid_boot_FakerActivity_registerCallBack(JNIEnv *env, jobject thiz,jobject object) {
    /**
     * init the callback global for other c++ method to call
     */
    callBack = env->NewGlobalRef(object);//


}
```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/java/com/fakerandroid/boot/FakerActivity.java.tmpl`:

```tmpl
/**
 * Generated by FakerAndroid for doc or help by https://github.com/Efaker/FakerAndroid
 */
package com.fakerandroid.boot;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.KeyEvent;
import android.view.Window;
import {R};
/**
 * TODO NOTE:this is a demo act if you want run it you should mode the manifest,if the app's main act extends com.unity3d.player.UnityPlayerActivity
 * TODO NOTE: else you can make this to main
 * TODO NOTE: you can extend the original main act
 */
public class FakerActivity extends com.unity3d.player.UnityPlayerActivity implements JniBridge {
    public native void registerCallBack(Object object);
    static final int HANDLER_MSG_CALLJAVA = 1000;
    final Handler handler = new Handler(Looper.getMainLooper()) {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case HANDLER_MSG_CALLJAVA:
                    String cmsg = (String) msg.obj;
                    callJava(cmsg);
                    break;
            }
            super.handleMessage(msg);
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState){
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        super.onCreate(savedInstanceState);
        registerCallBack(this);

        //TODO NOTE: this is a simple to call UnityPlayer java api
        //imageView = new ImageView(this);
        //imageView.setImageResource(R.drawable.faker_android_v_splash);
        //imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
        //mUnityPlayer.addViewToPlayer(imageView,false);
        //new Handler().postDelayed(new Runnable() {
        //  @Override
        //    public void run() {
        //        mUnityPlayer.removeViewFromPlayer(imageView);
        //    }
        //},3000);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)   {
        if(keyCode==KeyEvent.KEYCODE_BACK) {
        }
        return mUnityPlayer.injectEvent(event);
    }

    @Override
    public void onJniCall(String msg) {// unity player isnot main thread transfer method to main thread
        Message message = new Message();
        message.what =HANDLER_MSG_CALLJAVA;
        message.obj = msg;
        handler.sendMessage(message);
    }

    private void callJava(String msg){
        Logger.log(msg);
    }
}

```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/scaffolding-cpp/MonoString.cpp.tmpl`:

```tmpl
#include <cstring>
#include "MonoString.h"

void MonoString::setMonoString(const char *s) {
    string str(s);
    length = strlen(s);
    u16string basicString = utf8_to_utf16le(str);
    const char16_t *cStr = basicString.c_str();
    memcpy(getChars(), cStr, getLength() * 2);
}

void MonoString::setMonoString(string s) {
    length = s.length();
    u16string basicString = utf8_to_utf16le(s);
    const char16_t *str = basicString.c_str();
    memcpy(getChars(), str, getLength() * 2);
}

const char *MonoString::toChars() {
    u16string ss((char16_t *) getChars(), 0, getLength());
    string str = utf16le_to_utf8(ss);
    return str.c_str();
}

string MonoString::toString() {
    u16string ss((char16_t *) getChars(), 0, getLength());
    string str = utf16le_to_utf8(ss);
    return str;
}


static inline uint16_t byteswap_ushort(uint16_t number) {
#if defined(_MSC_VER) && _MSC_VER > 1310
    return _byteswap_ushort(number);
#elif defined(__GNUC__)
    return __builtin_bswap16(number);
#else
    return (number >> 8) | (number << 8);
#endif
}


std::string utf16_to_utf8(const std::u16string &u16str) {
    if (u16str.empty()) { return std::string(); }
    //Byte Order Mark
    char16_t bom = u16str[0];
    switch (bom) {
        case 0xFEFF:    //Little Endian
            return utf16le_to_utf8(u16str);
            break;
        case 0xFFFE:    //Big Endian
            return utf16be_to_utf8(u16str);
            break;
        default:
            return std::string();
    }
}


std::string utf16le_to_utf8(const std::u16string &u16str) {
    if (u16str.empty()) { return std::string(); }
    const char16_t *p = u16str.data();
    std::u16string::size_type len = u16str.length();
    if (p[0] == 0xFEFF) {
        p += 1;
        len -= 1;
    }

    std::string u8str;
    u8str.reserve(len * 3);

    char16_t u16char;
    for (std::u16string::size_type i = 0; i < len; ++i) {
        u16char = p[i];

        if (u16char < 0x0080) {
            // u16char <= 0x007f
            // U- 0000 0000 ~ 0000 07ff : 0xxx xxxx
            u8str.push_back((char) (u16char & 0x00FF));  // 取低8bit
            continue;
        }
        if (u16char >= 0x0080 && u16char <= 0x07FF) {
            // * U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
            u8str.push_back((char) (((u16char >> 6) & 0x1F) | 0xC0));
            u8str.push_back((char) ((u16char & 0x3F) | 0x80));
            continue;
        }
        if (u16char >= 0xD800 && u16char <= 0xDBFF) {
            // * U-00010000 - U-001FFFFF: 1111 0xxx 10xxxxxx 10xxxxxx 10xxxxxx
            uint32_t highSur = u16char;
            uint32_t lowSur = p[++i];
            uint32_t codePoint = highSur - 0xD800;
            codePoint <<= 10;
            codePoint |= lowSur - 0xDC00;
            codePoint += 0x10000;
            u8str.push_back((char) ((codePoint >> 18) | 0xF0));
            u8str.push_back((char) (((codePoint >> 12) & 0x3F) | 0x80));
            u8str.push_back((char) (((codePoint >> 06) & 0x3F) | 0x80));
            u8str.push_back((char) ((codePoint & 0x3F) | 0x80));
            continue;
        }
        {
            // * U-0000E000 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
            u8str.push_back((char) (((u16char >> 12) & 0x0F) | 0xE0));
            u8str.push_back((char) (((u16char >> 6) & 0x3F) | 0x80));
            u8str.push_back((char) ((u16char & 0x3F) | 0x80));
            continue;
        }
    }

    return u8str;
}


std::string utf16be_to_utf8(const std::u16string &u16str) {
    if (u16str.empty()) { return std::string(); }
    const char16_t *p = u16str.data();
    std::u16string::size_type len = u16str.length();
    if (p[0] == 0xFEFF) {
        p += 1;
        len -= 1;
    }


    std::string u8str;
    u8str.reserve(len * 2);
    char16_t u16char;
    for (std::u16string::size_type i = 0; i < len; ++i) {
        u16char = p[i];
        u16char = byteswap_ushort(u16char);
        if (u16char < 0x0080) {
            // u16char <= 0x007f
            // U- 0000 0000 ~ 0000 07ff : 0xxx xxxx
            u8str.push_back((char) (u16char & 0x00FF));
            continue;
        }
        if (u16char >= 0x0080 && u16char <= 0x07FF) {
            // * U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
            u8str.push_back((char) (((u16char >> 6) & 0x1F) | 0xC0));
            u8str.push_back((char) ((u16char & 0x3F) | 0x80));
            continue;
        }
        if (u16char >= 0xD800 && u16char <= 0xDBFF) {
            // * U-00010000 - U-001FFFFF: 1111 0xxx 10xxxxxx 10xxxxxx 10xxxxxx
            uint32_t highSur = u16char;
            uint32_t lowSur = byteswap_ushort(p[++i]);
            uint32_t codePoint = highSur - 0xD800;
            codePoint <<= 10;
            codePoint |= lowSur - 0xDC00;
            codePoint += 0x10000;
            u8str.push_back((char) ((codePoint >> 18) | 0xF0));
            u8str.push_back((char) (((codePoint >> 12) & 0x3F) | 0x80));
            u8str.push_back((char) (((codePoint >> 06) & 0x3F) | 0x80));
            u8str.push_back((char) ((codePoint & 0x3F) | 0x80));
            continue;
        }
        {
            // * U-0000E000 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
            u8str.push_back((char) (((u16char >> 12) & 0x0F) | 0xE0));
            u8str.push_back((char) (((u16char >> 6) & 0x3F) | 0x80));
            u8str.push_back((char) ((u16char & 0x3F) | 0x80));
            continue;
        }
    }
    return u8str;
}


std::u16string utf8_to_utf16le(const std::string &u8str, bool addbom, bool *ok) {
    std::u16string u16str;
    u16str.reserve(u8str.size());
    if (addbom) {
        u16str.push_back(0xFEFF);   //bom
    }
    std::string::size_type len = u8str.length();

    const unsigned char *p = (unsigned char *) (u8str.data());
    if (len > 3 && p[0] == 0xEF && p[1] == 0xBB && p[2] == 0xBF) {
        p += 3;
        len -= 3;
    }

    bool is_ok = true;
    for (std::string::size_type i = 0; i < len; ++i) {
        uint32_t ch = p[i];
        if ((ch & 0x80) == 0) {
            u16str.push_back((char16_t) ch);
            continue;
        }
        switch (ch & 0xF0) {
            case 0xF0:
            {
                uint32_t c2 = p[++i];
                uint32_t c3 = p[++i];
                uint32_t c4 = p[++i];
                uint32_t codePoint =
                        ((ch & 0x07U) << 18) | ((c2 & 0x3FU) << 12) | ((c3 & 0x3FU) << 6) |
                        (c4 & 0x3FU);
                if (codePoint >= 0x10000) {
                    codePoint -= 0x10000;
                    u16str.push_back((char16_t) ((codePoint >> 10) | 0xD800U));
                    u16str.push_back((char16_t) ((codePoint & 0x03FFU) | 0xDC00U));
                } else {
                    u16str.push_back((char16_t) codePoint);
                }
            }
                break;
            case 0xE0:
            {
                uint32_t c2 = p[++i];
                uint32_t c3 = p[++i];
                uint32_t codePoint = ((ch & 0x0FU) << 12) | ((c2 & 0x3FU) << 6) | (c3 & 0x3FU);
                u16str.push_back((char16_t) codePoint);
            }
                break;
            case 0xD0:
            case 0xC0: {
                uint32_t c2 = p[++i];
                uint32_t codePoint = ((ch & 0x1FU) << 12) | ((c2 & 0x3FU) << 6);
                u16str.push_back((char16_t) codePoint);
            }
                break;
            default:
                is_ok = false;
                break;
        }
    }
    if (ok != NULL) { *ok = is_ok; }

    return u16str;
}


std::u16string utf8_to_utf16be(const std::string &u8str, bool addbom, bool *ok) {
    std::u16string u16str = utf8_to_utf16le(u8str, addbom, ok);
    for (size_t i = 0; i < u16str.size(); ++i) {
        u16str[i] = byteswap_ushort(u16str[i]);
    }
    return u16str;
}

```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/scaffolding-cpp/MonoString.h.tmpl`:

```tmpl
#ifndef U3DINJECT_MASTER_MONOSTRING_H
#define U3DINJECT_MASTER_MONOSTRING_H

#include <string>
#include <stdint.h>

#ifdef __GNUC__

#include <endian.h>

#endif // __GNUC__
using namespace std;

class MonoString {
    void *klass;
    void *monitor;
    int length;
    char chars[1];
    char *getChars() {
        return chars;
    }

public:
    int getLength() {
        return length;
    }
    const char *toChars();

    string toString();

    void setMonoString(const char *s);

    void setMonoString(string s);
};

std::string utf16_to_utf8(const std::u16string &u16str);

std::string utf16le_to_utf8(const std::u16string &u16str);

std::string utf16be_to_utf8(const std::u16string &u16str);

std::u16string utf8_to_utf16le(const std::string &u8str, bool addbom = false, bool *ok = NULL);

std::u16string utf8_to_utf16be(const std::string &u8str, bool addbom = false, bool *ok = NULL);

#endif //U3DINJECT_MASTER_MONOSTRING_H


```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/scaffolding-cpp/il2cpp-appdata.h.tmpl`:

```tmpl
#pragma once

#include <cstdint>

// Application-specific types
#include "il2cpp-types.h"

#include "MonoString.h"

// IL2CPP API function pointers
#include "il2cpp-api-functions-ptr.h"

// IL2CPP APIs
#define DO_API(r, n, p) extern r (*n) p
#include "il2cpp-api-functions.h"
#undef DO_API

// Application-specific functions
#define DO_APP_FUNC(a, r, n, p) extern r (*n) p
#define DO_APP_FUNC_METHODINFO(a, n) extern struct MethodInfo ** n
namespace app {
	#include "il2cpp-functions.h"
}
#undef DO_APP_FUNC
#undef DO_APP_FUNC_METHODINFO

// TypeInfo pointers
#define DO_TYPEDEF(a, n) extern n ## __Class** n ## __TypeInfo
namespace app {
	#include "il2cpp-types-ptr.h"
}
#undef DO_TYPEDEF
```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/scaffolding-cpp/il2cpp-init.cpp.tmpl`:

```tmpl
#include "il2cpp-appdata.h"
#include "il2cpp-init.h"

// IL2CPP APIs
#define DO_API(r, n, p) r (*n) p
#include "il2cpp-api-functions.h"
#undef DO_API

// Application-specific functions
#define DO_APP_FUNC(a, r, n, p) r (*n) p
#define DO_APP_FUNC_METHODINFO(a, n) struct MethodInfo ** n
namespace app {
#include "il2cpp-functions.h"
}
#undef DO_APP_FUNC
#undef DO_APP_FUNC_METHODINFO

// TypeInfo pointers
#define DO_TYPEDEF(a, n) n ## __Class** n ## __TypeInfo
namespace app {
#include "il2cpp-types-ptr.h"
}
#undef DO_TYPEDEF

// IL2CPP application initializer
void init_il2cpp(long baseAddress)
{
	using namespace app;

	// Define IL2CPP API function addresses
	#define DO_API(r, n, p) n = (r (*) p)(baseAddress + n ## _ptr)
	#include "il2cpp-api-functions.h"
	#undef DO_API

	// Define function addresses
	#define DO_APP_FUNC(a, r, n, p) n = (r (*) p)(baseAddress + a)
 	#define DO_APP_FUNC_METHODINFO(a, n) n = (struct MethodInfo **)(baseAddress + a)
	#include "il2cpp-functions.h"
	#undef DO_APP_FUNC
 	#undef DO_APP_FUNC_METHODINFO

	// Define TypeInfo variables
	#define DO_TYPEDEF(a, n) n ## __TypeInfo = (n ## __Class**) (baseAddress + a);
	#include "il2cpp-types-ptr.h"
	#undef DO_TYPEDEF
}
```

`distribution/runtime-il2cpp/src/main/resources/il2cpp-template/scaffolding-cpp/il2cpp-init.h.tmpl`:

```tmpl
#pragma once

// IL2CPP application initializer
void init_il2cpp(long baseAdress);
```

`distribution/smali/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'org.example'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.smali:baksmali:2.4.0'
    implementation 'org.smali:smali:2.4.0'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`distribution/smali/settings.gradle`:

```gradle
rootProject.name = 'smali'


```

`distribution/smali/src/main/java/com/fakerandroid/decoder/smali/DexToSmaliException.java`:

```java
package com.fakerandroid.decoder.smali;

public class DexToSmaliException extends Exception{
    public DexToSmaliException(Throwable cause) {
        super(cause);
    }

    public DexToSmaliException(String message, Throwable cause) {
        super(message, cause);
    }

    public DexToSmaliException(String message) {
        super(message);
    }

    public DexToSmaliException() {
    }
}

```

`distribution/smali/src/main/java/com/fakerandroid/decoder/smali/SmaliDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.fakerandroid.decoder.smali;

import org.jf.baksmali.Baksmali;
import org.jf.baksmali.BaksmaliOptions;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.analysis.InlineMethodResolver;
import org.jf.dexlib2.dexbacked.DexBackedDexFile;
import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
import org.jf.dexlib2.iface.MultiDexContainer;

import java.io.File;
import java.io.IOException;

public class SmaliDecoder {

    public static void decode(File apkFile, File outDir, String dexName, boolean bakdeb, int api) throws DexToSmaliException {
        new SmaliDecoder(apkFile, outDir, dexName, bakdeb, api).decode();
    }

    private SmaliDecoder(File apkFile, File outDir, String dexName, boolean bakdeb, int api) {
        mApkFile = apkFile;
        mOutDir  = outDir;
        mDexFile = dexName;
        mBakDeb  = bakdeb;
        mApi     = api;
    }

    private void decode() throws DexToSmaliException {
        try {
            final BaksmaliOptions options = new BaksmaliOptions();

            // options
            options.deodex = false;
            options.implicitReferences = false;
            options.parameterRegisters = true;
            options.localsDirective = true;
            options.sequentialLabels = true;
            options.debugInfo = mBakDeb;
            options.codeOffsets = false;
            options.accessorComments = false;
            options.registerInfo = 0;
            options.inlineResolver = null;

            // set jobs automatically
            int jobs = Runtime.getRuntime().availableProcessors();
            if (jobs > 6) {
                jobs = 6;
            }

            // create the container
            MultiDexContainer<? extends DexBackedDexFile> container = DexFileFactory.loadDexContainer(mApkFile, Opcodes.forApi(mApi));
            MultiDexContainer.DexEntry<? extends DexBackedDexFile> dexEntry;
            DexBackedDexFile dexFile;

            // If we have 1 item, ignore the passed file. Pull the DexFile we need.
            if (container.getDexEntryNames().size() == 1) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            } else {
                dexEntry = container.getEntry(mDexFile);
            }

            // Double check the passed param exists
            if (dexEntry == null) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            }

            assert dexEntry != null;
            dexFile = dexEntry.getDexFile();

            if (dexFile.supportsOptimizedOpcodes()) {
                throw new DexToSmaliException("Warning: You are disassembling an odex file without deodexing it.");
            }

            if (dexFile instanceof DexBackedOdexFile) {
                options.inlineResolver =
                        InlineMethodResolver.createInlineMethodResolver(((DexBackedOdexFile)dexFile).getOdexVersion());
            }

            Baksmali.disassembleDexFile(dexFile, mOutDir, jobs, options);
        } catch (IOException ex) {
            throw new DexToSmaliException(ex);
        }
    }

    private final File mApkFile;
    private final File mOutDir;
    private final String mDexFile;
    private final boolean mBakDeb;
    private final int mApi;
}

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-6.3-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`library/build.gradle`:

```gradle
plugins {
    id 'java'
}

group 'faker.android'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.dom4j:dom4j:2.1.1'
    implementation 'commons-io:commons-io:2.4'
    implementation 'com.google.guava:guava:29.0-jre'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

```

`library/src/main/java/com/fakerandroid/decoder/exception/BinaryException.java`:

```java
package com.fakerandroid.decoder.exception;

public class BinaryException extends Exception {
}

```

`library/src/main/java/com/fakerandroid/decoder/exception/DexToSmaliException.java`:

```java
package com.fakerandroid.decoder.exception;

public class DexToSmaliException extends Exception{
    public DexToSmaliException(Throwable cause) {
        super(cause);
    }

    public DexToSmaliException(String message, Throwable cause) {
        super(message, cause);
    }

    public DexToSmaliException(String message) {
        super(message);
    }

    public DexToSmaliException() {
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/exception/FakerAndroidException.java`:

```java
package com.fakerandroid.decoder.exception;

public class FakerAndroidException extends Exception {
    public FakerAndroidException(Throwable cause) {
        super(cause);
    }

    public FakerAndroidException(String message, Throwable cause) {
        super(message, cause);
    }

    public FakerAndroidException(String message) {
        super(message);
    }

    public FakerAndroidException() {
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/exception/FileException.java`:

```java
package com.fakerandroid.decoder.exception;

public class FileException extends RuntimeException {
    private static final long serialVersionUID = -7410848445429898248L;

    public FileException(String message) {
        super(message);
    }

    public FileException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/FileUtils.java`:

```java
package com.fakerandroid.decoder.util;

import com.fakerandroid.decoder.exception.FileException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class FileUtils {
	private static final Logger LOG = Logger.getLogger(FileUtils.class.getName());

	public static final int READ_BUFFER_SIZE = 8 * 1024;
	private static final int MAX_FILENAME_LENGTH = 128;

	public static final String JADX_TMP_INSTANCE_PREFIX = "jadx-instance-";
	public static final String JADX_TMP_PREFIX = "jadx-tmp-";

	private FileUtils() {
	}
	public static void autoReplaceStr(File file, String oldstr, String newStr) throws IOException {
		if(oldstr==null||newStr==null){
			return;
		}
		Long fileLength = file.length();
		byte[] fileContext = new byte[fileLength.intValue()];
		FileInputStream in = null;
		PrintWriter out = null;
		in = new FileInputStream(file);
		in.read(fileContext);
		String str = new String(fileContext, "utf-8");//
		str = str.replace(oldstr, newStr);
		out = new PrintWriter(file, "utf-8");//
		out.write(str);
		out.flush();
		out.close();
		in.close();
	}
	public static void addFileToJar(JarOutputStream jar, File source, String entryName) throws IOException {
		try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(source))) {
			JarEntry entry = new JarEntry(entryName);
			entry.setTime(source.lastModified());
			jar.putNextEntry(entry);

			copyStream(in, jar);
			jar.closeEntry();
		}
	}

	public static void makeDirsForFile(Path path) {
		if (path != null) {
			makeDirs(path.getParent().toFile());
		}
	}

	public static void makeDirsForFile(File file) {
		if (file != null) {
			makeDirs(file.getParentFile());
		}
	}

	private static final Object MKDIR_SYNC = new Object();

	public static void makeDirs(@Nullable File dir) {
		if (dir != null) {
			synchronized (MKDIR_SYNC) {
				if (!dir.mkdirs() && !dir.isDirectory()) {
					throw new FileException("Can't create directory " + dir);
				}
			}
		}
	}

	public static void makeDirs(@Nullable Path dir) {
		if (dir != null) {
			makeDirs(dir.toFile());
		}
	}

	public static boolean deleteDir(File dir) {
		File[] content = dir.listFiles();
		if (content != null) {
			for (File file : content) {
				deleteDir(file);
			}
		}
		return dir.delete();
	}

	public static void deleteDir(Path dir) {
		try (Stream<Path> pathStream = Files.walk(dir)) {
			pathStream.sorted(Comparator.reverseOrder())
					.map(Path::toFile)
					.forEach(File::delete);
		} catch (Exception e) {
			throw new FileException("Failed to delete directory " + dir, e);
		}
	}

	private static final Path TEMP_ROOT_DIR = createTempRootDir();

	private static Path createTempRootDir() {
		try {
			String jadxTmpDir = System.getenv("JADX_TMP_DIR");
			Path dir;
			if (jadxTmpDir != null) {
				dir = Files.createTempDirectory(Paths.get(jadxTmpDir), "jadx-instance-");
			} else {
				dir = Files.createTempDirectory(JADX_TMP_INSTANCE_PREFIX);
			}
			dir.toFile().deleteOnExit();
			return dir;
		} catch (Exception e) {
			throw new FileException("Failed to create temp root directory", e);
		}
	}

	public static void deleteTempRootDir() {
		deleteDir(TEMP_ROOT_DIR);
	}

	public static void clearTempRootDir() {
		deleteDir(TEMP_ROOT_DIR);
		makeDirs(TEMP_ROOT_DIR);
	}

	public static Path createTempDir(String prefix) {
		try {
			Path dir = Files.createTempDirectory(TEMP_ROOT_DIR, prefix);
			dir.toFile().deleteOnExit();
			return dir;
		} catch (Exception e) {
			throw new FileException("Failed to create temp directory with suffix: " + prefix, e);
		}
	}

	public static Path createTempFile(String suffix) {
		try {
			Path path = Files.createTempFile(TEMP_ROOT_DIR, JADX_TMP_PREFIX, suffix);
			path.toFile().deleteOnExit();
			return path;
		} catch (Exception e) {
			throw new FileException("Failed to create temp file with suffix: " + suffix, e);
		}
	}

	public static Path createTempFileNoDelete(String suffix) {
		try {
			return Files.createTempFile(TEMP_ROOT_DIR, JADX_TMP_PREFIX, suffix);
		} catch (Exception e) {
			throw new FileException("Failed to create temp file with suffix: " + suffix, e);
		}
	}

	public static void copyStream(InputStream input, OutputStream output) throws IOException {
		byte[] buffer = new byte[READ_BUFFER_SIZE];
		while (true) {
			int count = input.read(buffer);
			if (count == -1) {
				break;
			}
			output.write(buffer, 0, count);
		}
	}

	public static byte[] streamToByteArray(InputStream input) throws IOException {
		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
			copyStream(input, out);
			return out.toByteArray();
		}
	}

	public static void close(Closeable c) {
		if (c == null) {
			return;
		}
		try {
			c.close();
		} catch (IOException e) {
//			LOG.error("Close exception for {}", c, e);
		}
	}

	@NotNull
	public static File prepareFile(File file) {
		File saveFile = cutFileName(file);
		makeDirsForFile(saveFile);
		return saveFile;
	}

	private static File cutFileName(File file) {
		String name = file.getName();
		if (name.length() <= MAX_FILENAME_LENGTH) {
			return file;
		}
		int dotIndex = name.indexOf('.');
		int cutAt = MAX_FILENAME_LENGTH - name.length() + dotIndex - 1;
		if (cutAt <= 0) {
			name = name.substring(0, MAX_FILENAME_LENGTH - 1);
		} else {
			name = name.substring(0, cutAt) + name.substring(dotIndex);
		}
		return new File(file.getParentFile(), name);
	}

	private static String bytesToHex(byte[] bytes) {
		char[] hexArray = "0123456789abcdef".toCharArray();
		if (bytes == null || bytes.length <= 0) {
			return null;
		}
		char[] hexChars = new char[bytes.length * 2];
		for (int j = 0; j < bytes.length; j++) {
			int v = bytes[j] & 0xFF;
			hexChars[j * 2] = hexArray[v >>> 4];
			hexChars[j * 2 + 1] = hexArray[v & 0x0F];
		}
		return new String(hexChars);
	}

	public static boolean isZipFile(File file) {
		try (InputStream is = new FileInputStream(file)) {
			byte[] headers = new byte[4];
			int read = is.read(headers, 0, 4);
			if (read == headers.length) {
				String headerString = bytesToHex(headers);
				if (Objects.equals(headerString, "504b0304")) {
					return true;
				}
			}
		} catch (Exception e) {
//			LOG.error("Failed read zip file: {}", file.getAbsolutePath(), e);
		}
		return false;
	}

	private static List<String> getZipFileList(File file) {
		List<String> filesList = new ArrayList<>();
		try (ZipFile zipFile = new ZipFile(file)) {
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();
				filesList.add(entry.getName());
			}
		} catch (Exception e) {
			LOG.warning(String.format("Error read zip file '{%s}' e:%s",file.getAbsolutePath(), e));
		}
		return filesList;
	}

	public static boolean isApkFile(File file) {
		if (!isZipFile(file)) {
			return false;
		}
		List<String> filesList = getZipFileList(file);
		return filesList.contains("AndroidManifest.xml")
				&& filesList.contains("classes.dex");
	}

	public static boolean isZipDexFile(File file) {
		if (!isZipFile(file) || !isZipFileCanBeOpen(file)) {
			return false;
		}
		List<String> filesList = getZipFileList(file);
		return filesList.contains("classes.dex");
	}

	private static boolean isZipFileCanBeOpen(File file) {
		try (ZipFile zipFile = new ZipFile(file)) {
			return zipFile.entries().hasMoreElements();
		} catch (Exception e) {
			return false;
		}
	}

	public static String getPathBaseName(Path file) {
		String fileName = file.getFileName().toString();
		int extEndIndex = fileName.lastIndexOf('.');
		if (extEndIndex == -1) {
			return fileName;
		}
		return fileName.substring(0, extEndIndex);
	}

	public static File toFile(String path) {
		if (path == null) {
			return null;
		}
		return new File(path);
	}
}

```

`library/src/main/java/com/fakerandroid/decoder/util/Jar.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.fakerandroid.decoder.util;

import com.fakerandroid.decoder.exception.FileException;
import org.apache.commons.io.IOUtils;
import java.io.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;

/**
 * @author Ryszard Wiśniewski <brut.alll@gmail.com>
 */
abstract public class Jar {
    private final static Set<String> mLoaded = new HashSet<String>();
    private final static Map<String, File> mExtracted = new HashMap<String, File>();

    public static File getResourceAsFile(String name, Class clazz) throws FileException {
        File file = mExtracted.get(name);
        if (file == null) {
            file = extractToTmp(name, clazz);
            mExtracted.put(name, file);
        }
        return file;
    }

    public static File getResourceAsFile(String name) throws FileException {
        return getResourceAsFile(name, Class.class);
    }

    public static void load(String libPath) {
        if (mLoaded.contains(libPath)) {
            return;
        }
        File libFile;
        try {
            libFile = getResourceAsFile(libPath);
        } catch (FileException ex) {
            throw new UnsatisfiedLinkError(ex.getMessage());
        }

        System.load(libFile.getAbsolutePath());
    }

    public static File extractToTmp(String resourcePath) throws FileException {
        return extractToTmp(resourcePath, Class.class);
    }

    public static File extractToTmp(String resourcePath, Class clazz) throws FileException {
        return extractToTmp(resourcePath, "brut_util_Jar_", clazz);
    }

    public static File extractToTmp(String resourcePath, String tmpPrefix) throws FileException {
        return extractToTmp(resourcePath, tmpPrefix, Class.class);
    }

    public static File extractToTmp(String resourcePath, String tmpPrefix, Class clazz) throws FileException {
        try {
            InputStream in = clazz.getResourceAsStream(resourcePath);
            if (in == null) {
                throw new FileNotFoundException(resourcePath);
            }
            long suffix = ThreadLocalRandom.current().nextLong();
            suffix = suffix == Long.MIN_VALUE ? 0 : Math.abs(suffix);
            File fileOut = File.createTempFile(tmpPrefix, suffix + ".tmp");
            fileOut.deleteOnExit();

            OutputStream out = new FileOutputStream(fileOut);
            IOUtils.copy(in, out);
            in.close();
            out.close();

            return fileOut;
        } catch (IOException ex) {
            throw new FileException("Could not extract resource: " + resourcePath, ex);
        }
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/ManifestEditor.java`:

```java
package com.fakerandroid.decoder.util;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class ManifestEditor {
    public static final String TAG_ACTIVITY = "activity";
    public static final String TAG_SERVICE = "service";
    public static final String TAG_PROVIDER = "provider";
    public static final String TAG_INTENT_FILTER = "intent-filter";

    /**
     * manifest 路径
     */
    File manifestFile;

    /**
     *
     */
    Document document;


    /**
     * manifest
     */
    Element manifestElement;

    /**
     * application 节点
     */
    Element applicationElement;

    Element usessdk;

    public ManifestEditor(File manifestFile) throws DocumentException {
        this.manifestFile = manifestFile;
        SAXReader reader = new SAXReader();
        document = reader.read(manifestFile);
        manifestElement = document.getRootElement();
        applicationElement = manifestElement.element("application");
        usessdk = manifestElement.element("uses-sdk");
    }

    public Element getManifestElement(){
        return manifestElement;
    }
    public String getPackagenName() {
        return manifestElement.attributeValue("package");
    }

    public String getVersionName() {
        return manifestElement.attributeValue("versionName");
    }

    public String getVersionCode() {
        return manifestElement.attributeValue("versionCode");
    }
    public String getCompileSdkVersion(){
        return manifestElement.attributeValue("compileSdkVersion");
    }
    public String getPlatformBuildVersionCode(){
        return manifestElement.attributeValue("platformBuildVersionCode");
    }

    public String getMinSdkVersion(){
        if(usessdk!=null){
            return usessdk.attributeValue("minSdkVersion");
        }
        return null;
    }
    public String getTargetSdkVersion(){
        if(usessdk!=null){
            return usessdk.attributeValue("targetSdkVersion");
        }
        return null;
    }


    public String getNetConfig(){
        return applicationElement.attributeValue("networkSecurityConfig");
    }
    /**
     *
     * @param elementFrom
     * @param elementTo
     */
    public void copyApplicaionElements(Element elementFrom, Element elementTo) {//TODO
        List<Element> elements = elementFrom.elements();
        for (Element element : elements) {
            //排除测试代码
            if(isMainActivityElement(element)){
                continue;
            }
            Element copy = element.createCopy();
            elementTo.add(copy);
        }
    }




    public Element getApplicationElement(){
        return applicationElement;
    }
    /**
     *
     * @return
     */
    public String getAppName() {
        return applicationElement.attributeValue("label");
    }

    /**
     * @return
     */
    public String getApplicationName() {
        return applicationElement.attributeValue("name");
    }

    public String getAextractNativeLibs() {
        return applicationElement.attributeValue("extractNativeLibs");
    }

    public String getApplicationDebuggable() {
        return applicationElement.attributeValue("debuggable");
    }

    public List<String> getUsesPermissions(){
        List<String> permissions = new ArrayList<>();
        List<Element> permissionElements = manifestElement.elements("uses-permission");
        for (Element element : permissionElements) {
            permissions.add(element.attributeValue("name"));
        }
        return permissions;
    }

    public List<String> getPermissions(){
        List<String> permissions = new ArrayList<>();
        List<Element> permissionElements = manifestElement.elements("permission");
        for (Element element : permissionElements) {
            permissions.add(element.attributeValue("name"));
        }
        return permissions;
    }

    public String getLogoFileName(){
        String logoValue =  applicationElement.attributeValue("icon");
        if(logoValue.contains("/")){
            String logoFileName = logoValue.split("/")[1];
            return logoFileName;
        }
        return null;
    }

    public String getNetworkSecurityConfig() {
        String networkSecurityConfig = applicationElement.attributeValue("networkSecurityConfig");
        if(networkSecurityConfig==null){
            return null;
        }
        return networkSecurityConfig.replace("@xml/","");
    }

    public void modNetworkSecurityConfig(String name) {
        Attribute isSelfAttr = applicationElement.attribute("networkSecurityConfig");
        if(isSelfAttr!=null){
            isSelfAttr.setValue(String.format("@xml/%s", name));
        }else{
            applicationElement.addAttribute("android:networkSecurityConfig", String.format("@xml/%s", name));
        }
    }

    /**
     * 获取启动act
     *
     * @return
     */
    public Element getLancherActivityElement() {
        /**
         */
        List<Element> activityElements = applicationElement.elements(TAG_ACTIVITY);
        for (Element activityElement : activityElements) {
            if (isMainActivityElement(activityElement)) return activityElement;
        }
        return null;
    }



    private  boolean isProvider(Element element){
        if("provider".equals(element.getName())){
                return true;
        }
        return false;
    }
    private boolean isMainActivityElement(Element activityElement) {
        List<Element> filterElements = activityElement.elements("intent-filter");
        for (Element filterElement : filterElements) {
            List<Element> actionElements = filterElement.elements("action");
            boolean main =false;
            for (Element actionElement : actionElements) {
                if ("android.intent.action.MAIN".equals(actionElement.attributeValue("name"))) {
                    main = true;
                    break;
                }
            }

            boolean launcher = false;
            List<Element> categoryElements = filterElement.elements("category");
            for (Element categoryElement : categoryElements) {
                if ("android.intent.category.LAUNCHER".equals(categoryElement.attributeValue("name"))) {
                    launcher = true;
                    break;
                }
            }

            if(main&&launcher){
                return true;
            }
        }
        return false;
    }

    public List<String> getActivityNames() {

        List<String> strings = new ArrayList<>();
        List<Element> activityElements = applicationElement.elements(TAG_ACTIVITY);
        for (Element activityElement : activityElements) {
            String name = activityElement.attributeValue("name");
            strings.add(name);
        }
        return strings;
    }


    public String getLancherActivityName() {
        Element activityElement = getLancherActivityElement();

        if(activityElement==null){
            return "";
        }
        //该ACT为入口类
        String name = activityElement.attributeValue("name");
        if (name.startsWith(".")) {
            return getPackagenName() + name;
        }
        return name;
    }

    public void modModelProviderAuthorities(String domain, String replaceValue){
            List<Element> providerElements = getProviderElements();
            for (Element element:providerElements) {
                if(isModelProvider(element,domain)){
                    String authorities = element.attributeValue("authorities");
                    authorities = authorities.replace(domain,replaceValue);
                    Attribute isSelfAttr = element.attribute("authorities");
                    isSelfAttr.setValue(authorities);
                }
        }

    }
    public List<Element> getProviderElements() {
        return applicationElement.elements(TAG_PROVIDER);
    }

    boolean isModelProvider(Element element, String domain){

        if(element.attributeValue("authorities").contains(domain)){
            return true;
        }
        return false;
    }

    /**
     * 增加meta
     *
     * @param metaKey
     * @param metaValue
     */
    public void insertMeta(String metaKey, String metaValue) {
        if (checkIsExist(applicationElement, "meta-data", metaKey)) {
            throw new RuntimeException();
        }
        Element metaDataElement = applicationElement.addElement("meta-data");
        metaDataElement.addAttribute("android:name", metaKey);
        metaDataElement.addAttribute("android:value", metaValue);
    }

    public void coverMeta(String metaKey, String metaValue) {
        if (checkIsExist(applicationElement, "meta-data", metaKey)) {
            modMeta(metaKey,metaValue);
            return;
        }
        Element metaDataElement = applicationElement.addElement("meta-data");
        metaDataElement.addAttribute("android:name", metaKey);
        metaDataElement.addAttribute("android:value", metaValue);
    }

    public void modMeta(String name, String value) {
        List<Element> metaDataElements = applicationElement.elements("meta-data");
        for (Element element: metaDataElements) {
            String metaName = element.attributeValue("name");
            System.out.println("metaName------"+metaName);
            if(metaName.equals(name)){
                element.attribute("value").setValue(value);
            }
        }
    }

    /**
     * 增加权限
     *
     * @param name
     */
    public void insertUsesPermission(String name) {
        if (checkIsExist(manifestElement, "uses-permission", name)) {
            return;
        }
        Element metaDataElement = manifestElement.addElement("uses-permission");
        metaDataElement.addAttribute("android:name", name);
    }

    public void insertPermission(String name, String protectLavel) {
        if (checkIsExist(manifestElement, "permission", name)) {
            return;
        }
        Element metaDataElement = manifestElement.addElement("permission");
        metaDataElement.addAttribute("android:name", name);
        if(!TextUtil.isEmpty(protectLavel)){
            metaDataElement.addAttribute("android:protectionLevel", protectLavel);
        }
    }
    /**
     */
    public void insertActivity(String name, String screenOrientation, String theme, String configChanges, String process) {

        if (checkIsExist(applicationElement, TAG_ACTIVITY, name)) {
            throw new RuntimeException();
        }
        Element activityElement = applicationElement.addElement(TAG_ACTIVITY);
        setActivityAttribute(name, screenOrientation, theme, configChanges, process, activityElement);
    }

    public void insertMainActivity(String name, String screenOrientation, String theme, String configChanges, String process) {

        if (checkIsExist(applicationElement, TAG_ACTIVITY, name)) {
            throw new RuntimeException();
        }
        Element activityElement = applicationElement.addElement(TAG_ACTIVITY);
        setActivityAttribute(name, screenOrientation, theme, configChanges, process, activityElement);
        Element intentFilter = activityElement.addElement("intent-filter");
        Element action = intentFilter.addElement("action");
        action.addAttribute("android:name", "android.intent.action.MAIN");
        Element category1 = intentFilter.addElement("category");
        category1.addAttribute("android:name", "android.intent.category.LAUNCHER");
//        Element category2 = intentFilter.addElement("category");
//        category2.addAttribute("android:name","android.intent.category.LEANBACK_LAUNCHER");

    }

    /**
     * vivo
     *
     * @param name
     * @param screenOrientation
     * @param theme
     * @param configChanges
     * @param proress
     */
    public void insertActivityVivoWithFilter(String name, String screenOrientation, String theme, String configChanges, String proress) {
        if (checkIsExist(applicationElement, TAG_ACTIVITY, name)) {
            return;
        }
        Element activityElement = applicationElement.addElement(TAG_ACTIVITY);
        setActivityAttribute(name, screenOrientation, theme, configChanges, proress, activityElement);
        Element filter = activityElement.addElement("intent-filter");
        Element action = filter.addElement("action");
        action.addAttribute("android:name", "android.intent.action.VIEW");
        Element category1 = filter.addElement("category");
        category1.addAttribute("android:name", "android.intent.category.DEFAULT");
        Element category2 = filter.addElement("category");
        category2.addAttribute("android:name", "android.intent.category.BROWSABLE");
        Element data = filter.addElement("data");
        data.addAttribute("android:host", "union.vivo.com");
        data.addAttribute("android:path", "/openjump");
        data.addAttribute("android:scheme", "vivounion");
    }

    /**
     * 插入服务
     * @param name
     */
    public void insertService(String name, String process, String priority, String exported) {
        if (checkIsExist(applicationElement, TAG_SERVICE, name)) {
            return;
        }
        Element serviceElement = applicationElement.addElement(TAG_SERVICE);
        serviceElement.addAttribute("android:name", name);
        if (!TextUtil.isEmpty(process)) {
            serviceElement.addAttribute("android:process", process);
        }
        if (!TextUtil.isEmpty(priority)) {
            serviceElement.addAttribute("android:priority", priority);
        }
        if (!TextUtil.isEmpty(exported)) {
            serviceElement.addAttribute("android:exported", exported);
        }
    }

    /**
     * 插入provider
     * @param name
     * @param authorities
     * @param exported
     * @param grantUriPermissions
     * @param metaName
     * @param metaResource
     */
    public void insertProvider(String name, String authorities, String exported, String grantUriPermissions, String metaName, String metaResource) {
        if (checkIsExist(applicationElement, TAG_PROVIDER, name)) {
            return;
        }
        Element provicerElement = applicationElement.addElement(TAG_PROVIDER);
        provicerElement.addAttribute("android:name", name);
        if (!TextUtil.isEmpty(authorities)) {
            provicerElement.addAttribute("android:authorities", authorities);
        }
        if (!TextUtil.isEmpty(exported)) {
            provicerElement.addAttribute("android:exported", exported);
        }
        if (!TextUtil.isEmpty(grantUriPermissions)) {
            provicerElement.addAttribute("android:grantUriPermissions", grantUriPermissions);
        }
        if (!TextUtil.isEmpty(metaName)) {
            Element meta = provicerElement.addElement("meta-data");
            meta.addAttribute("android:name", metaName);
            meta.addAttribute("android:resource", metaResource);
        }
    }

    private boolean checkIsExist(Element element, String tag, String name) {
        List<Element> originalElements = element.elements(tag);
        for (Element originalElement : originalElements) {
            String originalElementName = originalElement.attributeValue("name");
            if (name.equals(originalElementName)) {
                return true;
            }
        }
        return false;
    }

    public String getMateValue(String name) {
        List<Element> originalElements = applicationElement.elements("meta-data");
        for (Element originalElement : originalElements) {
            String originalElementName = originalElement.attributeValue("name");
            if (name.equals(originalElementName)) {
                return originalElement.attributeValue("value");
            }
        }
        return null;
    }

    public List<String> getMateNames() {
        List<Element> originalElements = applicationElement.elements("meta-data");
        List<String> metaNames = new ArrayList<>();
        for (Element originalElement : originalElements) {
            String originalElementName = originalElement.attributeValue("name");
            metaNames.add(originalElementName);
        }
        return metaNames;
    }


    private void setActivityAttribute(String name, String screenOrientation, String theme, String configChanges, String proress, Element activityElement) {
        activityElement.addAttribute("android:name", name);
        if (!TextUtil.isEmpty(screenOrientation)) {
            activityElement.addAttribute("android:screenOrientation", screenOrientation);
        }
        if (!TextUtil.isEmpty(theme)) {
            activityElement.addAttribute("android:theme", theme);
        }
        if (!TextUtil.isEmpty(configChanges)) {
            activityElement.addAttribute("android:configChanges", configChanges);
        }
        if (!TextUtil.isEmpty(proress)) {
            activityElement.addAttribute("android:process", proress);
        }
    }

    /**
     * 插入权限
     *
     * @param name
     */
    public void modApplication(String name) {
        String applicationName = getApplicationName();
        if (null == applicationName) {
            applicationElement.addAttribute("android:name", name);
        } else {
            Attribute isSelfAttr = applicationElement.attribute("name");
            isSelfAttr.setValue(name);
        }

//        String applicationDebuggable = getApplicationDebuggable();
//        if (null == applicationDebuggable) {
//            applicationElement.addAttribute("android:debuggable", "true");
//        } else {
//            Attribute isSelfAttr = applicationElement.attribute("debuggable");
//            isSelfAttr.setValue("true");
//        }
    }

    public void extractNativeLibs() {
        String applicationName = getAextractNativeLibs();
        if (null == applicationName) {
            applicationElement.addAttribute("android:extractNativeLibs", "true");
        } else {
            Attribute isSelfAttr = applicationElement.attribute("extractNativeLibs");
            isSelfAttr.setValue("true");
        }
    }

    public void modApplicationTheme(String theme) {
        Attribute isSelfAttr = applicationElement.attribute("theme");
        if (isSelfAttr == null) {
            applicationElement.addAttribute("android:theme", theme);
        } else {
            isSelfAttr.setValue(theme);
        }


    }

    public void modPkg(String name) {
        Attribute isSelfAttr = manifestElement.attribute("package");
        isSelfAttr.setValue(name);
    }

    /**
     * 修改游戏名称
     *
     * @param name
     */
    public void modApplicationLabel(String name) {
        Attribute isSelfAttr = applicationElement.attribute("label");
        isSelfAttr.setValue(name);
    }

    public void modLancherActivityLabel(String name) {
        Element lancherActivityElement = getLancherActivityElement();
        if(lancherActivityElement==null){
            return;
        }
        Attribute isSelfAttr = lancherActivityElement.attribute("label");
        if (isSelfAttr == null) {
            lancherActivityElement.addAttribute("android:label", name);
        } else {
            isSelfAttr.setValue(name);
        }

    }

    public void modLancherActivityScreenOrientation(String screenOrientation) {
        Element lancherActivityElement = getLancherActivityElement();
        Attribute isSelfAttr = lancherActivityElement.attribute("screenOrientation");
        isSelfAttr.setValue(screenOrientation);
    }

    public void modLancherActivityTheme(String theme) {
        Element lancherActivityElement = getLancherActivityElement();
        Attribute isSelfAttr = lancherActivityElement.attribute("theme");
        if (isSelfAttr == null) {
            lancherActivityElement.addAttribute("android:theme", theme);
        } else {
            isSelfAttr.setValue(theme);
        }
    }

    public void modLancherActivityIntent() {
        Element lancherActivityElement = getLancherActivityElement();
        List<Element> intentFilters = lancherActivityElement.elements("intent-filter");
        for (Element ele : intentFilters) {
            lancherActivityElement.remove(ele);
        }
    }


    public static void main(String[] args) {

    }

    public void save() throws IOException {
        OutputFormat xmlFormat = OutputFormat.createPrettyPrint();
        xmlFormat.setEncoding("UTF-8");
        xmlFormat.setNewlines(true);
        xmlFormat.setIndent(true);
        xmlFormat.setIndent("    ");

        XMLWriter writer = new XMLWriter(new FileWriter(manifestFile), xmlFormat);
        writer.write(document);
        writer.close();
    }
}


```

`library/src/main/java/com/fakerandroid/decoder/util/OS.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.fakerandroid.decoder.util;

import com.fakerandroid.decoder.exception.FakerAndroidException;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

public class OS {

    private static final Logger LOGGER = Logger.getLogger("");

    public static void rmdir(File dir) throws FakerAndroidException {
        if (! dir.exists()) {
            return;
        }
        File[] files = dir.listFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.isDirectory()) {
                rmdir(file);
            } else {
                file.delete();
            }
        }
        dir.delete();
    }
        
    public static void rmfile(String file) throws FakerAndroidException {
    	File del = new File(file);
    	del.delete();
    }

    public static void rmdir(String dir) throws FakerAndroidException {
        rmdir(new File(dir));
    }

    public static void cpdir(File src, File dest) throws FakerAndroidException {
        dest.mkdirs();
        File[] files = src.listFiles();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            File destFile = new File(dest.getPath() + File.separatorChar
                + file.getName());
            if (file.isDirectory()) {
                cpdir(file, destFile);
                continue;
            }
            try {
                InputStream in = new FileInputStream(file);
                OutputStream out = new FileOutputStream(destFile);
                IOUtils.copy(in, out);
                in.close();
                out.close();
            } catch (IOException ex) {
                throw new FakerAndroidException("Could not copy file: " + file, ex);
            }
        }
    }

    public static void cpdir(String src, String dest) throws FakerAndroidException {
        cpdir(new File(src), new File(dest));
    }

    public static void exec(String[] cmd) throws Exception {
        Process ps = null;
        int exitValue = -99;
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            ps = builder.start();
            new StreamForwarder(ps.getErrorStream(), "ERROR").start();
            new StreamForwarder(ps.getInputStream(), "OUTPUT").start();
            exitValue = ps.waitFor();
            if (exitValue != 0)
                throw new FakerAndroidException("could not exec (exit code = " + exitValue + "): " + Arrays.toString(cmd));
        } catch (IOException ex) {
            throw new FakerAndroidException("could not exec: " + Arrays.toString(cmd), ex);
        } catch (InterruptedException ex) {
            throw new FakerAndroidException("could not exec : " + Arrays.toString(cmd), ex);
        }
    }

    public static String execAndReturn(String[] cmd) {
        ExecutorService executor = Executors.newCachedThreadPool();
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            builder.redirectErrorStream(true);

            Process process = builder.start();
            StreamCollector collector = new StreamCollector(process.getInputStream());
            executor.execute(collector);

            process.waitFor();
            if (! executor.awaitTermination(15, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                if (! executor.awaitTermination(5, TimeUnit.SECONDS)) {
                    System.err.println("Stream collector did not terminate.");
                }
            }
            return collector.get();
        } catch (IOException | InterruptedException e) {
            return null;
        }
    }

    public static File createTempDirectory() throws FakerAndroidException {
        try {
            File tmp = File.createTempFile("BRUT", null);
            tmp.deleteOnExit();
            if (!tmp.delete()) {
                throw new FakerAndroidException("Could not delete tmp file: " + tmp.getAbsolutePath());
            }
            if (!tmp.mkdir()) {
                throw new FakerAndroidException("Could not create tmp dir: " + tmp.getAbsolutePath());
            }
            return tmp;
        } catch (IOException ex) {
            throw new FakerAndroidException("Could not create tmp dir", ex);
        }
    }

    static class StreamForwarder extends Thread {

        StreamForwarder(InputStream is, String type) {
            mIn = is;
            mType = type;
        }

        @Override
        public void run() {
            try {
                BufferedReader br = new BufferedReader(new InputStreamReader(mIn));
                String line;
                while ((line = br.readLine()) != null) {
                    if (mType.equals("OUTPUT")) {
                        LOGGER.info(line);
                    } else {
                        LOGGER.warning(line);
                    }
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

        private final InputStream mIn;
        private final String mType;
    }

    static class StreamCollector implements Runnable {
        private final StringBuffer buffer = new StringBuffer();
        private final InputStream inputStream;

        public StreamCollector(InputStream inputStream) {
            super();
            this.inputStream = inputStream;
        }

        @Override
        public void run() {
            String line;
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
                while ((line = reader.readLine()) != null) {
                    buffer.append(line).append('\n');
                }
            } catch (IOException ignored) {}
        }

        public String get() {
            return buffer.toString();
        }
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/OSDetection.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.fakerandroid.decoder.util;

public class OSDetection {
    private static String OS = System.getProperty("os.name").toLowerCase();
    private static String Bit = System.getProperty("sun.arch.data.model").toLowerCase();

    public static boolean isWindows() {
        return (OS.contains("win"));
    }

    public static boolean isMacOSX() {
        return (OS.contains("mac"));
    }

    public static boolean isUnix() {
        return (OS.contains("nix") || OS.contains("nux") || OS.contains("aix") || (OS.contains("sunos")));
    }

    public static boolean is64Bit() {
        if (isWindows()) {
            String arch = System.getenv("PROCESSOR_ARCHITECTURE");
            String wow64Arch = System.getenv("PROCESSOR_ARCHITEW6432");

            return arch != null && arch.endsWith("64") || wow64Arch != null && wow64Arch.endsWith("64");
        }
        return Bit.equalsIgnoreCase("64");
    }

    public static String returnOS() {
        return OS;
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/PatchUtil.java`:

```java
package com.fakerandroid.decoder.util;
import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class PatchUtil {

    //平行拷贝目录
    public static void copyDirFromJar(String folderPath,String toFolderPath) throws IOException {
        loadRecourseFromJarByFolder(folderPath,toFolderPath, PatchUtil.class,null);
    }
    public static void loadRecourseFromJarByFolder(String folderPath,String targetFolderPath ,Class clazz,String basePath) throws IOException {
        URL url = clazz.getResource(folderPath);
        if(basePath==null){
            basePath = url.getPath();
        }
        URLConnection urlConnection = url.openConnection();
        if (urlConnection instanceof JarURLConnection) {
            copyJarResources((JarURLConnection) urlConnection,folderPath,targetFolderPath,clazz,basePath);
        }else{
            copyFileResources(url, folderPath,targetFolderPath,clazz,basePath);
        }
    }
    private static void copyFileResources(URL url, String folderPath,String targetFolderPath, Class clazz,String basePath) throws IOException {
        File root = new File(url.getPath());
        System.out.println("basePath"+ basePath);
        if (root.isDirectory()) {
            File[] files = root.listFiles();
            for (File file : files) {
                if (file.isDirectory()) {
                    loadRecourseFromJarByFolder(folderPath + "/" + file.getName(),targetFolderPath,clazz,basePath);
                } else {
                    String toPath = file.getPath().replace(new File(basePath).getAbsolutePath(),targetFolderPath);
                    loadRecourseFromJar(folderPath + "/" + file.getName(),toPath,clazz);
                }
            }
        }
    }
    /**
     *
     * @param jarURLConnection
     * @throws IOException
     */
    private static void copyJarResources(JarURLConnection jarURLConnection,String folderPath,String targetFolderPath,Class clazz,String basePath) throws IOException {
        JarFile jarFile = jarURLConnection.getJarFile();
//        String baseUrl = jarURLConnection.getURL().getPath();
//        System.out.println("base url "+baseUrl);
        Enumeration<JarEntry> entrys = jarFile.entries();
        while (entrys.hasMoreElements()) {
            JarEntry entry = entrys.nextElement();
            if (entry.getName().startsWith(jarURLConnection.getEntryName()) && !entry.getName().endsWith("/")) {
                String target = ("/"+entry.getName()).replace(folderPath,"");
//                String pathTarget = target.replace("/","\\");
                File file  = new File(targetFolderPath,target);
                String toPath = file.getAbsolutePath();
                loadRecourseFromJar("/" + entry.getName(),toPath,clazz);
            }
        }
        jarFile.close();
    }
    public static void loadRecourseFromJar(String path,String toPath,Class clazz) throws IOException {
        if (!path.startsWith("/")) {
            throw new IllegalArgumentException("The path has to be absolute (start with '/').");
        }

        if (path.endsWith("/")) {
            throw new IllegalArgumentException("The path has to be absolute (cat not end with '/').");
        }

//        int index = toPath.lastIndexOf('/');
//        String filename = recourseFolder.substring(index + 1);
        String folderPath = new File(toPath).getParent();
        // If the folder does not exist yet, it will be created. If the folder
        // exists already, it will be ignored
        File dir = new File(folderPath);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        if(toPath.endsWith(".tmpl")){
            toPath = getFileNameNoEx(toPath);
        }
        // If the file does not exist yet, it will be created. If the file
        // exists already, it will be ignored
//        filename = folderPath + filename;
        File file = new File(toPath);

        if (!file.exists() && !file.createNewFile()) {
            return;
        }

        // Prepare buffer for data copying
        byte[] buffer = new byte[1024];
        int readBytes;

        // Open and check input stream
        URL url = clazz.getResource(path);
        URLConnection urlConnection = url.openConnection();
        InputStream is = urlConnection.getInputStream();

        if (is == null) {
            throw new FileNotFoundException("File " + path + " was not found inside JAR.");
        }
        OutputStream os = new FileOutputStream(file);
        try {
            while ((readBytes = is.read(buffer)) != -1) {
                os.write(buffer, 0, readBytes);
            }
        } finally {
            os.close();
            is.close();
        }

    }
    public static String getExtensionName(String filename) {
        if ((filename != null) && (filename.length() > 0)) {
            int dot = filename.lastIndexOf('.');
            if ((dot >-1) && (dot < (filename.length() - 1))) {
                return filename.substring(dot + 1);
            }
        }
        return filename;
    }
    public static String getFileNameNoEx(String filename) {
        if ((filename != null) && (filename.length() > 0)) {
            int dot = filename.lastIndexOf('.');
            if ((dot >-1) && (dot < (filename.length()))) {
                return filename.substring(0, dot);
            }
        }
        return filename;
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/TestUtils.java`:

```java
package com.fakerandroid.decoder.util;
import java.io.File;
import java.io.IOException;
import java.net.URL;

public class TestUtils {
    private static final String TEST_SAMPLES_DIR = "test-samples/";
    private static final String TEST_SAMPLES_DIRP_OUT = "test-samples-out/";

    public static File getFileFromSampleDir(String fileName) {
        URL resource = TestUtils.class.getClassLoader().getResource(TEST_SAMPLES_DIR + fileName);
        String pathStr = resource.getFile();
        return new File(pathStr);
    }
    public static File getFileOutSampleDir(String testCase,String fileName) throws IOException {
        File caseDir =new File(TEST_SAMPLES_DIRP_OUT,testCase);
        File outDir = new File(caseDir,fileName);
        if(outDir.exists()){
            FileUtils.deleteDir(outDir);
        }
        outDir.mkdirs();
        return outDir;
    }
}

```

`library/src/main/java/com/fakerandroid/decoder/util/TextUtil.java`:

```java
package com.fakerandroid.decoder.util;

public class TextUtil {
    public static boolean isEmpty(String text) {
        if (text != null && !"".equals(text)) {
            return false;
        }
        return true;
    }
}

```

`settings.gradle`:

```gradle
rootProject.name = 'FakerAndroid'

include 'bin'
include 'bin:FakerAndroid-gui'
include 'bin:FakerAndroid-cli'
include 'bin:FakerAndroid-AS'
include 'library'
include 'controller'
include 'distribution:runtime-base'
include 'distribution:runtime-il2cpp'
include 'distribution:master'
include 'distribution:resources'
include 'distribution:smali'
include 'distribution:il2cpp-dumper'
include 'distribution:dex2jar'
include 'distribution:il2cpp'
include 'distribution:project'
include 'distribution:apktool'
include 'distribution:apktool:brut.apktool:apktool-lib'
include 'distribution:apktool:brut.j.common'
include 'distribution:apktool:brut.j.util'
include 'distribution:apktool:brut.j.dir'





```