Project Path: arc_gmh5225_Basic_Anti-Cheat_5xnjuovz

Source Tree:

```txt
arc_gmh5225_Basic_Anti-Cheat_5xnjuovz
├── API
│   ├── API.cpp
│   └── API.hpp
├── AntiCheat.cpp
├── AntiCheat.hpp
├── AntiDebugger.cpp
├── AntiDebugger.hpp
├── Integrity
│   ├── Integrity.cpp
│   ├── Integrity.hpp
│   ├── NAuthenticode.cpp
│   ├── NAuthenticode.hpp
│   ├── remap.cpp
│   └── remap.hpp
├── Network
│   ├── NetClient.cpp
│   ├── NetClient.hpp
│   └── Packets
│       ├── PacketWriter.hpp
│       ├── Packets.cpp
│       └── Packets.hpp
├── PEB.hpp
├── Process.cpp
├── Process.hpp
├── README.md
├── SHA256.cpp
├── SHA256.hpp
├── Services.cpp
├── Services.hpp
├── Shellcodes.asm
├── SymbolicHash.cpp
├── SymbolicHash.hpp
├── Utility.cpp
├── Utility.hpp
├── main.cpp
└── ntdll.h

```

`API/API.cpp`:

```cpp
#include "API.hpp"

int __declspec(dllexport) API::Initialize(string licenseKey, wstring parentProcessName)
{
	int errorCode = Error::OK;
	bool isLicenseValid = false;

	//TODO: check licenseKey against some centralized web server, possibly using HTTP requests. once we have verified our license, we can try to connect using Initialize()
	//gernerate user identifying info and send to server

	if (isLicenseValid)
	{
		if (g_AC->GetNetworkClient()->Initialize("127.0.0.1", 5445) != Error::OK) //initialize client is separate from license key auth
		{
			//don't allow continuing if networking doesn't work
			errorCode = Error::CANT_STARTUP;
		}
		else
		{
			//check parent process
			if (Process::CheckParentProcess(parentProcessName))
			{
				g_AC->GetProcessObject()->SetParentName(parentProcessName);
			}
			else //bad parent process detected, or parent process mismatch, shut down the program after reporting the error to the server
			{
				errorCode = Error::PARENT_PROCESS_MISMATCH;
			}
		}
	}

	return errorCode;
}

int __declspec(dllexport) API::Dispatch(DispatchCode code, int reason) //todo: finish this
{
	int errorCode = 0;

	switch (code)
	{
		case FAILED_INITIALIZE:

			break;

		case CLIENT_EXIT:

			break;

		case CLIENT_DISCONNECT:

			break;

		case HEARTBEAT:

			break;
	};

	return errorCode;
}
```

`API/API.hpp`:

```hpp
#pragma once
#include "../AntiCheat.hpp"
//API is exported routines needed for a game to initialize this anti-cheat program

using namespace std;

extern AntiCheat* g_AC;

namespace API
{
	enum DispatchCode //Codes which the game/process might send to us. communication is one-way
	{
		FAILED_INITIALIZE,
		CLIENT_EXIT,
		CLIENT_DISCONNECT,
		HEARTBEAT,
	};

	int __declspec(dllexport) Initialize(string licenseKey, wstring parentProcessName);
	int __declspec(dllexport) Dispatch(DispatchCode code, int reason);
}



```

`AntiCheat.cpp`:

```cpp
#include "AntiCheat.hpp"

void AntiCheat::ShellcodeTests()
{
	//NoStaticAnalysis(); 

	byte* buffer = (byte*)"\x53\x47\x82\xEB\x07\x47\x8A\x43\x23\x0F\xFE\xDF"; //will be executed as a function, is 'unpacked' at runtime

	DWORD dOldProt = 0;
	VirtualProtect((LPVOID)buffer, sizeof(buffer), PAGE_EXECUTE_READWRITE, &dOldProt);

	for (int i = 0; i < sizeof(buffer); i++) //basic transform of bytes, add 1 to each
		buffer[i] = buffer[i] + 1;

	void (*foo)();
	foo = (void(*)())(buffer);
	foo(); //shellcode call

	///Part 2: virtualalloc + shellcode func call

	LPVOID p = VirtualAlloc(NULL, 13, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (p != 0)
	{
		memcpy(p, buffer, 13);

		foo = (void(*)())(p);
		foo(); //shellcode call

		FunctionTypePtr* foo2 = (void(**)()) & p; //same as above line technically
		(*foo2)(); //just to check how compilers treat each of these calls
		//the above actually works just fine 

		printf("Called foo2: %p!\n", *foo2);

		VirtualFree(p, 0, MEM_RELEASE);	 //memory begone
	}
	
}

template<class T>
static inline void** AntiCheat::GetVTableArray(T* pClass, int* pSize) 
{
    void** ppVTable = *(void***)pClass;

    if (pSize)
    {
        *pSize = 0;

        while (!IsBadReadPtr(ppVTable[*pSize], sizeof(unsigned __int64)))
            (*pSize)++;
    }

    return ppVTable;
}

bool AntiCheat::IsVTableHijacked(void* pClass) //checks some class ptr's vtable to see if any functions jump outside of this module. sort of neat but unlikely anyone would be hooking here, and if they are it means theyre already leaving other fingerprints
{
    DWORD dOldProt = 0;
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
    MODULEENTRY32 moduleEntry;

    // Take a snapshot of all modules in the specified process
    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
    if (hModuleSnap == INVALID_HANDLE_VALUE)
        return false;

    // Set the size of the structure before using it
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    // Retrieve information about the first module (current process)
    if (!Module32First(hModuleSnap, &moduleEntry))
    {
        CloseHandle(hModuleSnap);
        return false;
    }

    // Grab the base address and size of our module (the address range where
    // the VTable can validly point to)
    UINT_PTR ulBaseAddress = reinterpret_cast<UINT_PTR>(moduleEntry.modBaseAddr);
    UINT_PTR ulBaseSize = moduleEntry.modBaseSize;

    // Get the VTable array and VTable member count
    int nMethods;
    void** ppVTable = GetVTableArray(pClass, &nMethods);

    VirtualProtect(ppVTable, nMethods * sizeof(UINT_PTR), PAGE_EXECUTE, &dOldProt);

    // Clean up the snapshot object
    CloseHandle(hModuleSnap);

    // Ensure all VTable pointers are in our current module's address range
    for (int i = 0; i < nMethods; ++i)
    {
        // Get address of the method this VTable pointer points to
        UINT_PTR ulFuncAddress = reinterpret_cast<UINT_PTR>(ppVTable[i]);
        printf("vTable member points to address: %llX\n", ulFuncAddress);
        // Check the address is within our current module range
        if (ulFuncAddress < ulBaseAddress || ulFuncAddress > ulBaseAddress + ulBaseSize)
            return false;
    }

    return true;
}

```

`AntiCheat.hpp`:

```hpp
#pragma once
// Check windows
#if _WIN32 || _WIN64
#if _WIN64
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

#include <iostream>
#include "Process/Process.hpp"
#include "AntiDebug/AntiDebugger.hpp"
#include "AntiTamper/Integrity.hpp"
#include "Services.hpp"
#include "Obfuscation.hpp"
#include "Process/Memory/remap.hpp"

extern "C" __forceinline bool MisleadingFunction(); //the goal here is to get the compiler to inline our function (although apparently not possible on x64) which breaks the static analysis of REing tools.
extern "C" void inline_test(); //using macros within masm file

class AntiCheat //main class of the program, or 'hub'. contains all the detection methods
{
public:

	Process* GetProcessObject() { return this->_Proc; }
	Debugger::AntiDebug* GetAntiDebugger() { return this->_AntiDebugger; }

	typedef void (*FunctionTypePtr)();

	inline void ShellcodeTests();

	inline Integrity* GetIntegrityChecker() { return this->integrityChecker; }

	static bool IsVTableHijacked(void* pClass);

	template<class T>
	static inline void** GetVTableArray(T* pClass, int* pSize);

protected:

private:
	
	Process* _Proc = new Process();
	Debugger::AntiDebug* _AntiDebugger = new Debugger::AntiDebug();

	Integrity* integrityChecker = new Integrity();
};

```

`AntiDebugger.cpp`:

```cpp
#include "AntiDebugger.hpp"

void Debugger::AntiDebug::StartAntiDebugThread()
{
	HANDLE thread = this->GetDetectionThread();
	thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Debugger::AntiDebug::CheckForDebugger, (LPVOID)this, 0, 0);
}

inline bool Debugger::AntiDebug::_IsDebuggerPresent()
{
	if (IsDebuggerPresent()) //winapi
	{
		DebuggerMethodsDetected = DebuggerMethodsDetected | WINAPI_DEBUGGER;
		return true;
	}
	else
	{
		return false;
	}
}



bool Debugger::AntiDebug::_IsHardwareDebuggerPresent()
{
	DWORD ProcessId = GetCurrentProcessId(); //this can be replaced later, or a process that is not us

	//first we must iterate on all threads in process
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take a snapshot of all running threads  
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE)
		return(FALSE);

	// Fill in the size of the structure before using it. 
	te32.dwSize = sizeof(THREADENTRY32);

	// Retrieve information about the first thread,
	// and exit if unsuccessful
	if (!Thread32First(hThreadSnap, &te32))
	{
		CloseHandle(hThreadSnap);     // Must clean up the snapshot object!
		return(FALSE);
	}
	
	//WOW64: The handle must also have THREAD_QUERY_INFORMATION access.
	// Now walk the thread list of the system,
	// and display information about each thread
	// associated with the specified process
	do
	{
		if (te32.th32OwnerProcessID == ProcessId)
		{
			printf(("\n     THREAD ID      = 0x%08X"), te32.th32ThreadID);

			CONTEXT lpContext;
			memset(&lpContext, 0, sizeof(CONTEXT));
			lpContext.ContextFlags = CONTEXT_FULL;

			HANDLE _tThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);

			if (_tThread)
			{
				if (GetThreadContext(_tThread, &lpContext))
				{
					if (lpContext.Dr0 || lpContext.Dr1 || lpContext.Dr2 || lpContext.Dr3 )
					{
						printf("Found a debug register enabled!\n");
						CloseHandle(hThreadSnap);
						CloseHandle(_tThread);
						return true;
					}
				}
				else
				{
					printf("GetThreadContext failed with: %d\n", GetLastError());
                                        CloseHandle(_tThread);
					continue;
				}
			}
			else
			{
				printf("Could not call openthread! %d\n", GetLastError());
				continue;
			}
		}
	} while (Thread32Next(hThreadSnap, &te32));

	printf(("\n"));

	//  Don't forget to clean up the snapshot object.
	CloseHandle(hThreadSnap);
	return false;
}


bool Debugger::AntiDebug::_IsKernelDebuggerPresent()
{
	typedef long NTSTATUS;
	HANDLE hProcess = GetCurrentProcess();

	typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION { bool DebuggerEnabled; bool DebuggerNotPresent; } SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

	enum SYSTEM_INFORMATION_CLASS { SystemKernelDebuggerInformation = 35 };
	typedef NTSTATUS(__stdcall* ZW_QUERY_SYSTEM_INFORMATION)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass, IN OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength);
	ZW_QUERY_SYSTEM_INFORMATION ZwQuerySystemInformation;
	SYSTEM_KERNEL_DEBUGGER_INFORMATION Info;

	HMODULE hModule = LoadLibraryA("ntdll.dll");
	ZwQuerySystemInformation = (ZW_QUERY_SYSTEM_INFORMATION)GetProcAddress(hModule, "ZwQuerySystemInformation");
	if (ZwQuerySystemInformation == NULL)
		return false;

	if (!ZwQuerySystemInformation(SystemKernelDebuggerInformation, &Info, sizeof(Info), NULL)) {
		if (Info.DebuggerEnabled && !Info.DebuggerNotPresent)
			return true; 
		else
			return false;
	}

	return false;
}

bool Debugger::AntiDebug::_IsDebuggerPresentHeapFlags()
{
	DWORD_PTR pPeb64 = (DWORD_PTR)pPEB::GetPEB();

	if (pPeb64)
	{
		PVOID ptrHeap = (PVOID)*(PDWORD_PTR)((PBYTE)pPeb64 + 0x30);
		PDWORD heapForceFlagsPtr = (PDWORD)((PBYTE)ptrHeap + 0x74);

		if (*heapForceFlagsPtr == 0x40000060)
			return true;
	}

	return false;
}


```

`AntiDebugger.hpp`:

```hpp
#pragma once
#include <Winternl.h>
#include <Windows.h>
#include <stdio.h> //for printing info
#include <tlhelp32.h> //process watching
#include <Psapi.h> //process watching
#include "../Process/PEB.hpp"


#define MAX_DLLS 128 
#define MAX_FILE_PATH_LENGTH 256

namespace Debugger
{
    //Todo: Get all methods from scyllahide
    //see bottom of file for list of windows structures related to debugging
    enum Detections
    {
        WINAPI_DEBUGGER,
        PEB_FLAG,
        HARDWARE_REGISTERS,
        HEAP,
        INTC,
        INT2C,
        DEBUG_EVENT, 
        DEBUG_OBJECT,
        KNOWN_DEBUGGER, //for commonly used tools such as IDA, olly, etc
        VEH_DEBUGGER, //https://github.com/cheat-engine/cheat-engine/blob/66d2ad3ba7f4de6726f61437300b24fa00c425f5/Cheat%20Engine/VEHDebugger.pas -> calls CreateFileMapping, MapViewOfFile, CreateEvent, DuplicateHandle, then injects a DLL (vehdebug_x86/64.dll) -> calls "vehdebug.InitializeVEH' export, thus we can likely detect this by a simple module enum

        ALL = -1
    };

    class AntiDebug
    {
    public:
        
        AntiDebug()
        {
            this->DebuggerMethodsDetected = 0;
            this->DebuggerDetectionMethods = WINAPI_DEBUGGER;
        }
        
        inline int GetDebuggerMethodsDetected() { return DebuggerMethodsDetected; }
    
        inline HANDLE GetDetectionThread() { return this->DetectionThread; }

        inline bool _IsDebuggerPresent();
        inline bool _IsDebuggerPresentHeapFlags();
        inline bool _IsKernelDebuggerPresent();
        inline bool _IsHardwareDebuggerPresent();

       // bool CheckForDebugger();
        static void CheckForDebugger(LPVOID AD);
        void StartAntiDebugThread();

    private:
        
        int DebuggerMethodsDetected = 0;
        int DebuggerDetectionMethods = 0;
    
        HANDLE DetectionThread;
    };
}

//The following structures are used with debugging :
//
//CONTEXT
//CREATE_PROCESS_DEBUG_INFO
//CREATE_THREAD_DEBUG_INFO
//DEBUG_EVENT
//EXCEPTION_DEBUG_INFO
//EXIT_PROCESS_DEBUG_INFO
//EXIT_THREAD_DEBUG_INFO
//LDT_ENTRY
//LOAD_DLL_DEBUG_INFO
//OUTPUT_DEBUG_STRING_INFO
//RIP_INFO
//UNLOAD_DLL_DEBUG_INFO
//WOW64_CONTEXT
//WOW64_FLOATING_SAVE_AREA
//WOW64_LDT_ENTRY
//

```

`Integrity/Integrity.cpp`:

```cpp
#include "Integrity.hpp"

//Call chain: GetHash() to get a hash list of module, then later call Check with the result from GetHash originally.
//returns false if any static memory is modified (assuming we pass in moduleBase and sizeOfModule.
bool Integrity::Check(uint64_t Address, int nBytes, std::list<uint64_t>* hashList)
{
	list<uint64_t>* hashes = GetMemoryHash(Address, nBytes);

	bool b_perm = std::is_permutation(hashList->begin(), hashList->end(), hashes->begin()); //check if our ordered hash list is the same as the one we compute above

	delete hashes;

	return b_perm;
}

//we can build an array here at some memory location with nBytes, then SHA256 
list<uint64_t>* Integrity::GetMemoryHash(uint64_t Address, int nBytes)
{
	std::list<uint64_t>* hashList = new list<uint64_t>();

	byte* arr = new byte[nBytes];

	memcpy(arr, (void*)Address, nBytes);

	SHA256 sha;
	uint8_t* digest = 0;
	UINT64 digestCache = 0; //we keep adding 

	for (int i = 0; i < nBytes; i = i + 32) //as long as input->output matches consistently and does not create collisions, the underlying algo doesn't matter too much. 
	{
		sha.update(&arr[i], 32);
		digest = sha.digest();
		digestCache += *(UINT64*)digest + i;
		hashList->push_back(digestCache);
		delete digest;
	}

	delete[] arr;
	return hashList;
}

void Integrity::SetMemoryHashList(std::list<uint64_t>* hList)
{
	if (this->_MemorySectionHashes == nullptr)
		this->_MemorySectionHashes = new list<uint64_t>();

	this->_MemorySectionHashes->assign(hList->begin(), hList->end());
}

list<wstring> Integrity::GetLoadedDLLs()
{
	list<wstring> dlls;
	HMODULE  hMod[1024] = { 0 };
	DWORD cbNeeded;

	if (EnumProcessModules(GetCurrentProcess(), hMod, sizeof(hMod), &cbNeeded))
	{
		for (int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
		{
			TCHAR szModName[MAX_PATH];

			if (GetModuleFileNameExW(GetCurrentProcess(), hMod[i], szModName, sizeof(szModName) / sizeof(TCHAR)))
			{
				// Print the module name and handle value.
				if(wcsstr(szModName, L".exe") == NULL)
					dlls.push_back(szModName);
			}
		}
	}

	return dlls;
}
/*
In addition to authenticode, we can make hashes of all the loaded DLLs and then periodically check these hashes again to see if any modifications have been made/modules hijacked
*/
list<uint64_t>* Integrity::GetDllHashes(list<wchar_t*> LoadedDlls)
{
	list<uint64_t>* HashesList;

	for (auto dll : LoadedDlls)
	{
		list<uint64_t>* dllHashes = Integrity::GetMemoryHash((uint64_t)GetModuleHandleW(dll), 0x1000);
		//HashesList->push_back(dllHashes[0]);
		delete dllHashes;
	}

	
	return HashesList; //todo: finish this routine
}

/*
Authenticode check on loaded DLLs, any unsigned/unverified loaded returns true
*/
bool Integrity::IsUnknownDllPresent()
{
	bool foundUnknown = false;

	list<wstring> dlls = Integrity::GetLoadedDLLs();

	for (auto str : dlls)
	{
		if (!Authenticode::VerifyEmbeddedSignature(str.c_str()))
		{
			wprintf(L"Bad signature found for: %s\n", str.c_str());
			foundUnknown = true;
		}
	}

	return foundUnknown;
}

bool Integrity::DisableDynamicCode()
{
	PROCESS_MITIGATION_DYNAMIC_CODE_POLICY dynamicCodePolicy = { 0 };

	dynamicCodePolicy.ProhibitDynamicCode = 1; // Enable dynamic code restriction

	if (!SetProcessMitigationPolicy((PROCESS_MITIGATION_POLICY)2,
		&dynamicCodePolicy,
		sizeof(dynamicCodePolicy))) {
		fprintf(stderr, "Failed to set process mitigation policy. Error code: %lu\n", GetLastError());
		return false;
	}

	return true;
}

bool Integrity::DisableUnsignedCode() //stops unsigned dlls from being loaded! Gives 'Bad Image' error (0xc00000428)
{
	_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY signPolicy = { 0 };

	signPolicy.MicrosoftSignedOnly = true;

	if (!SetProcessMitigationPolicy((PROCESS_MITIGATION_POLICY)8,
		&signPolicy,
		sizeof(signPolicy))) {
		fprintf(stderr, "Failed to set process mitigation policy. Error code: %lu\n", GetLastError());
		return false;
	}

	return true;
}
```

`Integrity/Integrity.hpp`:

```hpp
#pragma once
#include "../Common/Utility.hpp"
#include "../Common/SHA256.hpp"
#include "../Common/MD5.hpp"
#include "../Process/Process.hpp"
#include "NAuthenticode.hpp"
#include <stdio.h>
#include <algorithm>

//the purpose of this class is to form a list containing our program's computed hashes
class Integrity
{
public:

	bool Check(uint64_t Address, int nBytes, std::list<uint64_t>* hashList);
	
	static list<uint64_t>* GetMemoryHash(uint64_t Address, int nBytes);

	void SetMemoryHashList(std::list<uint64_t>* hList);
	list< uint64_t>* GetMemoryHashList() { return this->_MemorySectionHashes; }

	static list<wstring> GetLoadedDLLs(); //use this to fill _LoadedDlls
	static list<uint64_t>* GetDllHashes(list<wchar_t*> LoadedDlls);

	static bool IsUnknownDllPresent();

	static bool DisableDynamicCode();
	static bool DisableUnsignedCode();

private:
	
	list<wstring> _LoadedDlls;
	list<uint64_t> _DllHashes;

	list<uint64_t>* _MemorySectionHashes = nullptr; 
	
	Process* _Proc = new Process(); //get memory sections, etc, make hash of each section
};
```

`Integrity/NAuthenticode.cpp`:

```cpp
#include "NAuthenticode.hpp"

BOOL Authenticode::VerifyEmbeddedSignature(LPCWSTR pwszSourceFile)
{
    LONG lStatus;
    DWORD dwLastError;
    bool trusted = false;

    // Initialize the WINTRUST_FILE_INFO structure.

    WINTRUST_FILE_INFO FileData;
    memset(&FileData, 0, sizeof(FileData));
    FileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
    FileData.pcwszFilePath = pwszSourceFile;
    FileData.hFile = NULL;
    FileData.pgKnownSubject = NULL;

    /*
    WVTPolicyGUID specifies the policy to apply on the file
    WINTRUST_ACTION_GENERIC_VERIFY_V2 policy checks:

    1) The certificate used to sign the file chains up to a root
    certificate located in the trusted root certificate store. This
    implies that the identity of the publisher has been verified by
    a certification authority.

    2) In cases where user interface is displayed (which this example
    does not do), WinVerifyTrust will check for whether the
    end entity certificate is stored in the trusted publisher store,
    implying that the user trusts content from this publisher.

    3) The end entity certificate has sufficient permission to sign
    code, as indicated by the presence of a code signing EKU or no
    EKU.
    */

    GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA WinTrustData;

    // Initialize the WinVerifyTrust input data structure.

    // Default all fields to 0.
    memset(&WinTrustData, 0, sizeof(WinTrustData));

    WinTrustData.cbStruct = sizeof(WinTrustData);

    // Use default code signing EKU.
    WinTrustData.pPolicyCallbackData = NULL;

    // No data to pass to SIP.
    WinTrustData.pSIPClientData = NULL;

    // Disable WVT UI.
    WinTrustData.dwUIChoice = WTD_UI_NONE;

    // No revocation checking.
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;

    // Verify an embedded signature on a file.
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;

    // Verify action.
    WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;

    // Verification sets this value.
    WinTrustData.hWVTStateData = NULL;

    // Not used.
    WinTrustData.pwszURLReference = NULL;

    // This is not applicable if there is no UI because it changes 
    // the UI to accommodate running applications instead of 
    // installing applications.
    WinTrustData.dwUIContext = 0;

    // Set pFile.
    WinTrustData.pFile = &FileData;

    // WinVerifyTrust verifies signatures as specified by the GUID 
    // and Wintrust_Data.
    lStatus = WinVerifyTrust(
        NULL,
        &WVTPolicyGUID,
        &WinTrustData);

    //MOST cases here we won't need to use
    switch (lStatus)
    {
        case ERROR_SUCCESS:
            /*
            Signed file:
                - Hash that represents the subject is trusted.
                - Trusted publisher without any verification errors.
                - UI was disabled in dwUIChoice. No publisher or
                    time stamp chain errors.
                - UI was enabled in dwUIChoice and the user clicked
                    "Yes" when asked to install and run the signed
                    subject.
            */
            //wprintf_s(L"The file \"%s\" is signed and the signature was verified (%x).\n",pwszSourceFile, WinTrustData.pCert->dwFlags);
            trusted = true;
            break;

        case TRUST_E_NOSIGNATURE:
            // The file was not signed or had a signature 
            // that was not valid.

            // Get the reason for no signature.
            dwLastError = GetLastError();
            if (TRUST_E_NOSIGNATURE == dwLastError ||
                TRUST_E_SUBJECT_FORM_UNKNOWN == dwLastError ||
                TRUST_E_PROVIDER_UNKNOWN == dwLastError)
            {
                // The file was not signed.
               // wprintf_s(L"The file \"%s\" is not signed.\n", pwszSourceFile);
                trusted = false;
            }
            else
            {
                // The signature was not valid or there was an error 
                // opening the file. In our context, rogue DLLs fall into this category.
                //wprintf_s(L"An unknown error occurred trying to verify the signature of the \"%s\" file.\n", pwszSourceFile);
            }

            break;

        case TRUST_E_EXPLICIT_DISTRUST: //policy
            // The hash that represents the subject or the publisher 
            // is not allowed by the admin or user.
            //wprintf_s(L"The signature is present, but specifically disallowed.\n");
            break;

        case TRUST_E_SUBJECT_NOT_TRUSTED:
            // The user clicked "No" when asked to install and run.
            break;

        case CRYPT_E_SECURITY_SETTINGS:
            /*
            The hash that represents the subject or the publisher
            was not explicitly trusted by the admin and the
            admin policy has disabled user trust. No signature,
            publisher or time stamp errors.
            */
            break;

        default:
            // The UI was disabled in dwUIChoice or the admin policy 
            // has disabled user trust. lStatus contains the 
            // publisher or time stamp chain error.
            wprintf_s(L"Error is: 0x%x.\n",
                lStatus);
            break;
    }

    // Any hWVTStateData must be released by a call with close.
    WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;

    lStatus = WinVerifyTrust(
        NULL,
        &WVTPolicyGUID,
        &WinTrustData);

    return trusted;
}

```

`Integrity/NAuthenticode.hpp`:

```hpp
//-------------------------------------------------------------------
// Copyright (C) Microsoft.  All rights reserved.
// Example of verifying the embedded signature of a PE file by using 
// the WinVerifyTrust function.

#define _UNICODE 1
#define UNICODE 1

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <Softpub.h>
#include <wincrypt.h>
#include <wintrust.h>

// Link with the Wintrust.lib file.
#pragma comment (lib, "wintrust")

namespace Authenticode
{
	BOOL VerifyEmbeddedSignature(LPCWSTR pwszSourceFile);
}

```

`Integrity/remap.cpp`:

```cpp
#include "remap.hpp"
#include "../Process/Memory/ntdll.h"

//=============================================================================
// Private Types
//=============================================================================
typedef BOOL(NTAPI* REMAP_ROUTINE)(
    _In_ PVOID pRemapRegion
    );


//=============================================================================
// Module Globals
//=============================================================================
static ULONG g_CharacteristicsProtectionMap[2][2][2] =
{
    {
        { PAGE_NOACCESS, PAGE_WRITECOPY },
        { PAGE_READONLY, PAGE_READWRITE }

    },
    {
        { PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY },
        { PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE }
    },
};


//=============================================================================
// Private Prototypes
//=============================================================================
_Check_return_
static
BOOL
RmppVerifyPeSectionAlignment(
    _In_ PIMAGE_NT_HEADERS pNtHeaders
);

static
VOID
RmppCopyPeSections(
    _In_ PIMAGE_NT_HEADERS pNtHeaders,
    _In_ ULONG_PTR DestinationBase
);

_Check_return_
static
BOOL
RmppRemapImageRoutine(
    _In_ PVOID pRemapRegion
);

_Check_return_
static
ULONG
RmppConvertSectionCharacteristicsToPageProtection(
    _In_ ULONG Characteristics
);

_Check_return_
static
BOOL
RmppMapProtectedView(
    _In_ HANDLE hSection,
    _In_ ULONG_PTR BaseAddress,
    _In_ SIZE_T cbSize,
    _In_ SIZE_T cbOffset,
    _In_ ULONG Protection
);

_Check_return_
static
BOOL
RmppValidateRemappedImageProtection(
    _In_ ULONG_PTR ImageBase
);

_Check_return_
static
BOOL
RmppValidateRemappedPeSectionProtection(
    _In_ PVOID pSectionBase
);


//=============================================================================
// Public Interface
//=============================================================================

//
// RmpRemapImage
//
// This function remaps the pe image at 'ImageBase' so that the page protection
//  of all pages contained in the image cannot be changed.
//
// The remapping process uses the following strategy:
//
//  1. The image is copied to an executable buffer referred to as the 'remap
//      region'.
//
//  2. The remap routine inside the remap region is located and invoked.
//
//  3. The remap routine creates a page-file-backed section to store the
//      remapped image.
//
//  4. The remap routine maps a view of the entire section and copies the
//      contents of the image to the view. This view is then unmapped.
//
//  5. The remap routine maps a view for each pe section in the image using the
//      relative virtual address of the pe section as the section offset for
//      the view. Each view is mapped using the 'SEC_NO_CHANGE' allocation
//      type to prevent page protection changes.
//
//  6. The remap routine completes and execution returns to the remapped image.
//
// NOTE This strategy requires each pe section in the image to be aligned to
//  the system allocation granularity. See the documentation for
//  'ZwMapViewOfSection' for details.
//
// NOTE This function currently only supports x64 images.
//
_Use_decl_annotations_
BOOL
RmpRemapImage(
    ULONG_PTR ImageBase
)
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    PVOID pRemapRegion = NULL;
    REMAP_ROUTINE fpRemapRoutine = NULL;
    BOOL status = TRUE;

    printf("Remapping image at 0x%IX\n", ImageBase);

    pNtHeaders = RtlImageNtHeader((PVOID)ImageBase);
    if (!pNtHeaders)
    {
        printf("RtlImageNtHeader failed. (BaseAddress = 0x%IX)\n",
            ImageBase);
        status = FALSE;
        goto exit;
    }

    status = RmppVerifyPeSectionAlignment(pNtHeaders);
    if (!status)
    {
        printf("RmppVerifyPeSectionAlignment failed.\n");
        goto exit;
    }

    //
    // Allocate an executable and writable buffer where the remap routine will
    //  execute.
    //
    pRemapRegion = VirtualAlloc(
        NULL,
        pNtHeaders->OptionalHeader.SizeOfImage,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    if (!pRemapRegion)
    {
        printf("VirtualAlloc failed: %u\n", GetLastError());
        status = FALSE;
        goto exit;
    }

    printf("RemapRegion:    0x%IX\n", (ULONG_PTR)pRemapRegion);

    //
    // Copy the image to the remap region.
    //
    RmppCopyPeSections(pNtHeaders, (ULONG_PTR)pRemapRegion);

    //
    // Locate the address of the remap routine inside the remap region.
    //
    fpRemapRoutine = (REMAP_ROUTINE)(
        (ULONG_PTR)pRemapRegion +
        (ULONG_PTR)RmppRemapImageRoutine -
        ImageBase);

    printf("RemapRoutine:   0x%IX\n", (ULONG_PTR)fpRemapRoutine);

    //
    // Invoke the remap routine inside the remap region.
    //
    status = fpRemapRoutine(pRemapRegion);
    if (!status)
    {
        printf("RmppRemapImageRoutine failed.\n");
        goto exit;
    }

    //
    // Verify that each pe section in the remapped image is protected.
    //
    status = RmppValidateRemappedImageProtection(ImageBase);
    if (!status)
    {
        printf("RmppValidateRemappedImageProtection failed.\n");
        goto exit;
    }

exit:
    if (pRemapRegion)
    {
        if (!VirtualFree(pRemapRegion, 0, MEM_RELEASE))
        {
            printf("VirtualFree failed: %u\n", GetLastError());
        }
    }

    return status;
}


//=============================================================================
// Private Interface
//=============================================================================

//
// RmppVerifyPeSectionAlignment
//
// Verify that each pe section is aligned to the system allocation granularity.
//
_Use_decl_annotations_
static
BOOL
RmppVerifyPeSectionAlignment(
    PIMAGE_NT_HEADERS pNtHeaders
)
{
    SYSTEM_INFO SystemInfo = {};
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;
    ULONG_PTR SectionBase = 0;
    BOOL status = TRUE;

    printf("Verifying pe section alignment:\n");

    //
    // Query the system allocation granularity.
    //
    GetSystemInfo(&SystemInfo);

    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i)
    {
        SectionBase =
            pNtHeaders->OptionalHeader.ImageBase +
            pSectionHeader[i].VirtualAddress;

        printf("    %-8.8s    0x%IX - 0x%IX,  0x%08X\n",
            pSectionHeader[i].Name,
            SectionBase,
            SectionBase + pSectionHeader[i].Misc.VirtualSize,
            pSectionHeader[i].Misc.VirtualSize);

        status = POINTER_IS_ALIGNED(
            SectionBase,
            SystemInfo.dwAllocationGranularity);
        if (!status)
        {
            printf("Unexpected section alignment. (SectionBase = 0x%IX)\n",
                SectionBase);
            goto exit;
        }
    }

    //
    // Verify pe header alignment.
    //
    status = POINTER_IS_ALIGNED(
        pNtHeaders->OptionalHeader.ImageBase,
        SystemInfo.dwAllocationGranularity);
    if (!status)
    {
        printf("Unexpected section alignment. (SectionBase = 0x%IX)\n",
            SectionBase);
        goto exit;
    }

exit:
    return status;
}


//
// RmppCopyPeSections
//
_Use_decl_annotations_
static
VOID
RmppCopyPeSections(
    PIMAGE_NT_HEADERS pNtHeaders,
    ULONG_PTR DestinationBase
)
{
    ULONG_PTR SourceBase = 0;
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;

    SourceBase = pNtHeaders->OptionalHeader.ImageBase;

    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    //
    // We copy each pe section individually because images compiled with the
    //  '/ALIGN' linker option will have reserved memory padding.
    //
    for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i)
    {
        printf("Copying %-8.8s from 0x%IX to 0x%IX,  0x%08X\n",
            pSectionHeader[i].Name,
            SourceBase + pSectionHeader[i].VirtualAddress,
            DestinationBase + pSectionHeader[i].VirtualAddress,
            pSectionHeader[i].Misc.VirtualSize);

        RtlCopyMemory(
            (PVOID)(DestinationBase + pSectionHeader[i].VirtualAddress),
            (PVOID)(SourceBase + pSectionHeader[i].VirtualAddress),
            pSectionHeader[i].Misc.VirtualSize);
    }

    //
    // Copy the pe header.
    //
    RtlCopyMemory((PVOID)DestinationBase, (PVOID)SourceBase, PAGE_SIZE);
}


//
// RmppRemapImageRoutine
//
// This routine unmaps the original image then reconstructs it as contiguous
//  memory mapped views.
//
_Use_decl_annotations_
static
BOOL
RmppRemapImageRoutine(
    PVOID pRemapRegion
)
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    HANDLE hSection = NULL;
    LARGE_INTEGER cbSectionSize = {};
    PVOID pViewBase = NULL;
    ULONG_PTR ImageBase = 0;
    LARGE_INTEGER cbSectionOffset = {};
    SIZE_T cbViewSize = 0;
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;
    ULONG Protection = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    BOOL status = TRUE;

    pNtHeaders = RtlImageNtHeader(pRemapRegion);
    if (!pNtHeaders)
    {
        printf("RtlImageNtHeader failed. (BaseAddress = 0x%IX)\n",
            pRemapRegion);
        status = FALSE;
        goto exit;
    }

    cbSectionSize.QuadPart = pNtHeaders->OptionalHeader.SizeOfImage;

    //
    // Create a page-file-backed section to store the remapped image.
    //
    ntstatus = NtCreateSection(
        &hSection,
        SECTION_ALL_ACCESS,
        NULL,
        &cbSectionSize,
        PAGE_EXECUTE_READWRITE,
        SEC_COMMIT | SEC_NO_CHANGE,
        NULL);
    if (!NT_SUCCESS(ntstatus))
    {
        printf("NtCreateSection failed: 0x%X\n", ntstatus);
        status = FALSE;
        goto exit;
    }

    //
    // Map a view of the entire section.
    //
    ntstatus = NtMapViewOfSection(
        hSection,
        NtCurrentProcess(),
        &pViewBase,
        0,
        pNtHeaders->OptionalHeader.SizeOfImage,
        &cbSectionOffset,
        &cbViewSize,
        ViewUnmap,
        0,
        PAGE_READWRITE);
    if (!NT_SUCCESS(ntstatus))
    {
        printf("NtMapViewOfSection failed: 0x%X\n", ntstatus);
        status = FALSE;
        goto exit;
    }

    //
    // Copy the image to our view.
    //
    RmppCopyPeSections(pNtHeaders, (ULONG_PTR)pViewBase);

    //
    // Unmap the copy-view because we no longer need it.
    //
    ntstatus = NtUnmapViewOfSection(NtCurrentProcess(), pViewBase);
    if (!NT_SUCCESS(ntstatus))
    {
        printf("NtUnmapViewOfSection failed: 0x%X\n", ntstatus);
        status = FALSE;
        goto exit;
    }

    //
    // Unmap the original image.
    //
    ImageBase = pNtHeaders->OptionalHeader.ImageBase;

    ntstatus = NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)ImageBase);
    if (!NT_SUCCESS(ntstatus))
    {
        printf("NtUnmapViewOfSection failed: 0x%X\n", ntstatus);
        status = FALSE;
        goto exit;
    }

    //
    // Reconstruct the image by mapping a view of the section for each pe
    //  section in the image.
    //
    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i)
    {
        Protection = RmppConvertSectionCharacteristicsToPageProtection(
            pSectionHeader[i].Characteristics);

        status = RmppMapProtectedView(
            hSection,
            ImageBase + pSectionHeader[i].VirtualAddress,
            pSectionHeader[i].Misc.VirtualSize,
            pSectionHeader[i].VirtualAddress,
            Protection);
        if (!status)
        {
            printf("RmppMapProtectedView failed.\n");
            goto exit;
        }

        printf("Mapped protected view at: %llx\n", ImageBase + pSectionHeader[i].VirtualAddress);
    }

    //
    // Map a view for the pe header.
    //
    status = RmppMapProtectedView(
        hSection,
        ImageBase,
        PAGE_SIZE,
        0,
        PAGE_READONLY);
    if (!status)
    {
        printf("RmppMapProtectedView failed.\n");
        goto exit;
    }

exit:
    if (hSection)
    {
        ntstatus = NtClose(hSection);
        if (!NT_SUCCESS(ntstatus))
        {
            printf("NtClose failed: 0x%X\n", ntstatus);
        }
    }

    return status;
}


//
// RmppConvertSectionCharacteristicsToPageProtection
//
_Use_decl_annotations_
static
ULONG
RmppConvertSectionCharacteristicsToPageProtection(
    ULONG Characteristics
)
{
    BOOL fExecutable = FALSE;
    BOOL fReadable = FALSE;
    BOOL fWritable = FALSE;
    ULONG Protection = 0;

    if (0 != (IMAGE_SCN_MEM_EXECUTE & Characteristics))
    {
        fExecutable = TRUE;
    }

    if (0 != (IMAGE_SCN_MEM_READ & Characteristics))
    {
        fReadable = TRUE;
    }

    if (0 != (IMAGE_SCN_MEM_WRITE & Characteristics))
    {
        fWritable = TRUE;
    }

    Protection =
        g_CharacteristicsProtectionMap[fExecutable][fReadable][fWritable];

    if (0 != (IMAGE_SCN_MEM_NOT_CACHED & Characteristics))
    {
        Protection |= PAGE_NOCACHE;
    }

    return Protection;
}


//
// RmppMapProtectedView
//
_Use_decl_annotations_
static
BOOL
RmppMapProtectedView(
    HANDLE hSection,
    ULONG_PTR BaseAddress,
    SIZE_T cbSize,
    SIZE_T cbOffset,
    ULONG Protection
)
{
    LARGE_INTEGER cbSectionOffset = {};
    PVOID pViewBase = NULL;
    SIZE_T cbViewSize = 0;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    BOOL status = TRUE;

    pViewBase = (PVOID)BaseAddress;
    cbViewSize = cbSize;
    cbSectionOffset.QuadPart = cbOffset;

    ntstatus = NtMapViewOfSection(
        hSection,
        NtCurrentProcess(),
        &pViewBase,
        0,
        0,
        &cbSectionOffset,
        &cbViewSize,
        ViewUnmap,
        SEC_NO_CHANGE,
        Protection);
    if (!NT_SUCCESS(ntstatus))
    {
        printf(
            "NtMapViewOfSection failed: 0x%X (Base = 0x%IX, Offset = 0x%IX, Size = 0x%IX)\n",
            ntstatus,
            pViewBase,
            cbSectionOffset.QuadPart,
            cbViewSize);
        status = FALSE;
        goto exit;
    }

exit:
    return status;
}


//
// RmppValidateRemappedImageProtection
//
_Use_decl_annotations_
static
BOOL
RmppValidateRemappedImageProtection(
    ULONG_PTR ImageBase
)
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;
    BOOL status = TRUE;

    pNtHeaders = RtlImageNtHeader((PVOID)ImageBase);
    if (!pNtHeaders)
    {
        printf("RtlImageNtHeader failed. (BaseAddress = 0x%IX)\n",
            ImageBase);
        status = FALSE;
        goto exit;
    }

    pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i)
    {
        status = RmppValidateRemappedPeSectionProtection(
            (PVOID)(ImageBase + pSectionHeader[i].VirtualAddress));
        if (!status)
        {
            printf("RmppValidateRemappedPeSectionProtection failed.\n");
            goto exit;
        }
    }

    //
    // Validate the pe header.
    //
    status = RmppValidateRemappedPeSectionProtection((PVOID)ImageBase);
    if (!status)
    {
        printf("RmppValidateRemappedPeSectionProtection failed.\n");
        goto exit;
    }

exit:
    return status;
}


//
// RmppValidateRemappedPeSectionProtection
//
_Use_decl_annotations_
static
BOOL
RmppValidateRemappedPeSectionProtection(
    PVOID pSectionBase
)
{
    MEMORY_BASIC_INFORMATION MemoryBasicInfo = {};
    ULONG TestProtect = 0;
    ULONG PreviousProtect = 0;
    BOOL status = TRUE;

    //
    // Query the current page protection.
    //
    if (!VirtualQuery(pSectionBase, &MemoryBasicInfo, sizeof(MemoryBasicInfo)))
    {
        printf("VirtualQuery failed: %u (BaseAddress = 0x%IX)\n",
            GetLastError(),
            pSectionBase);
        status = FALSE;
        goto exit;
    }

    //
    // We use PAGE_EXECUTE_READWRITE as our test protection value because it is
    //  the most permissive page protection.
    //
    if (PAGE_EXECUTE_READWRITE != MemoryBasicInfo.Protect)
    {
        TestProtect = PAGE_EXECUTE_READWRITE;
    }
    else
    {
        TestProtect = PAGE_NOACCESS;
    }

    //
    // Attempt to modify the page protection of every page contained in the
    //  memory region. This should fail because each view was mapped with the
    //  SEC_NO_CHANGE allocation type.
    //
    status = VirtualProtect(
        pSectionBase,
        MemoryBasicInfo.RegionSize,
        TestProtect,
        &PreviousProtect);
    if (status)
    {
        printf(
            "Section is not protected. (BaseAddress = 0x%IX, Protect = 0x%X)\n",
            pSectionBase,
            PreviousProtect);
        status = FALSE;
        goto exit;
    }

    // Reset the status code to indicate success.
    status = TRUE;

exit:
    return status;
}

```

`Integrity/remap.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <stdio.h>
//=============================================================================
// Public Interface
//=============================================================================
_Check_return_
BOOL
RmpRemapImage(
    _In_ ULONG_PTR ImageBase
);

```

`Network/NetClient.cpp`:

```cpp
#include "NetClient.hpp"

Error NetClient::Initialize(string ip, uint16_t port)
{
	WSADATA wsaData;
	SOCKET Socket = INVALID_SOCKET;
	SOCKADDR_IN SockAddr;

	this->HardwareID = this->GetHardwareID("C://"); //todo: add some detection to fetch the correct drive automatically

	const char recvBuffer[DEFAULT_RECV_LENGTH] = { 0 };

	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
	{
		return Error::CANT_STARTUP;
	}

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	SockAddr.sin_addr.S_un.S_addr = inet_addr(ip.c_str());
	SockAddr.sin_port = htons(port);
	SockAddr.sin_family = AF_INET;

	this->Socket = Socket;

	if (connect(Socket, (SOCKADDR*)(&SockAddr), sizeof(SockAddr)) != 0)
	{
		closesocket(Socket);
		WSACleanup();
		shutdown(Socket, 0);
		return Error::CANT_CONNECT;
	}

	PacketWriter* p = Packets::Builder::ClientHello(this->HardwareID.c_str(), this->GetIpv4().c_str(), this->GetMACAddress().c_str());
	p->WriteString(this->HardwareID.c_str());
	p->WriteString(this->GetIpv4().c_str());

	int BytesSent = send(Socket, (const char*)p->GetBuffer(), p->GetSize(), 0);

	delete p->GetBuffer();
	delete p;

	if (BytesSent <= 0)
	{
		return Error::CANT_SEND;
	}

	int nRecvDataLength;

	if (BytesSent == p->GetSize())
	{
		while ((nRecvDataLength = recv(Socket, (char*)recvBuffer, DEFAULT_RECV_LENGTH, 0)) == 0);

		if (nRecvDataLength > 4 && recvBuffer[0] != 0) //change this later... MINIMUM OFFSETS NEEDED..
		{
			try
			{
				uint16_t packetLength = 0;
				memcpy((void*)&packetLength, (const void*)recvBuffer[0], sizeof(uint16_t));

				PacketWriter* recvP = new PacketWriter(recvBuffer, packetLength); //todo: make constructor where we can pass in a byte* and it auto copies 
				Error err = HandleInboundPacket(recvP); //Handle incoming packet. after the initial handshake is done, this will be called from our recv loop.

				delete recvP->GetBuffer();
				delete recvP;
			}
			catch (std::exception e)
			{
				return Error::DATA_LENGTH_MISMATCH;
			}
		}
	}
	else
	{
		return Error::INCOMPLETE_SEND;
		//error, didnt send enough bytes. maybe packets were modified along the way by the user, or some blip in the wire occured.
	}

	//we can choose to either disconnect or leave the connection open at this point. we still will be sending more data shortly
	//...for now we will leave the connection open

	this->Ip = ip;
	this->Port = port;

	this->ConnectedAt = GetTickCount();
	this->ConnectedDuration = 0;

	//create a thread for handling server replies
	this->RecvLoopThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)&NetClient::ProcessRequests, this, 0, &this->recvThreadId);

	if (this->RecvLoopThread == NULL || this->recvThreadId == NULL)
	{
		return Error::NO_RECV_THREAD;
	}

	return Error::OK;
}

Error NetClient::EndConnection(int reason)
{
	PacketWriter* p = Packets::Builder::ClientGoodbye(reason);
	Error err = Error::OK;

	if (this->Socket != SOCKET_ERROR)
	{
		//send CS_GOODBYE then disconnect

		if (this->SendData(p) != Error::OK)
		{
			err = Error::CANT_SEND;
		}
	}

	if (Socket != SOCKET_ERROR && Socket != NULL)
	{
		closesocket(Socket);
	}

	WSACleanup();
	shutdown(Socket, 0);

	delete p->GetBuffer();
	delete p;
	return err;
}

Error NetClient::SendData(PacketWriter* outPacket)
{
	if (outPacket->GetBuffer() == nullptr || outPacket == nullptr)
		return Error::NULL_MEMORY_REFERENCE;

	if (this->Socket == SOCKET_ERROR)
		return Error::BAD_SOCKET;

	Error err = Error::OK;

	int BytesSent = send(Socket, (const char*)outPacket->GetBuffer(), outPacket->GetSize(), 0);

	int nRecvDataLength = 0;

	if (BytesSent != outPacket->GetSize()) //make sure we sent the hwid
	{
		err = Error::INCOMPLETE_SEND;
	}

	return err;
}

void NetClient::ProcessRequests(LPVOID Param)
{
	bool receiving = true;

	NetClient* Client = reinterpret_cast<NetClient*>(Param);

	char recvBuf[DEFAULT_RECV_LENGTH] = { 0 };

	while (receiving)
	{
		SOCKET s = Client->GetClientSocket();

		if (s)
		{
			int bytesIn = recv(s, recvBuf, DEFAULT_RECV_LENGTH, 0);

			if (bytesIn != SOCKET_ERROR)
			{
				PacketWriter* p = new PacketWriter(recvBuf, bytesIn);
				Client->HandleInboundPacket(p);
			}
		}
	}
}

string NetClient::GetIpv4() //todo: finish this function: convert values into string 
{
	struct IPv4
	{
		unsigned char b1, b2, b3, b4;
	};

	IPv4 myIP;
	string sIpv4;

	char szBuffer[1024];

#ifdef WIN32
	WSADATA wsaData;
	WORD wVersionRequested = MAKEWORD(2, 0);
	if (::WSAStartup(wVersionRequested, &wsaData) != 0)
		return "";
#endif
	if (gethostname(szBuffer, sizeof(szBuffer)) == SOCKET_ERROR)
	{
#ifdef WIN32
		WSACleanup();
#endif
		return "";
	}

	struct hostent* host = gethostbyname(szBuffer);
	if (host == NULL)
	{
#ifdef WIN32
		WSACleanup();
#endif
		return "";
	}

	//Obtain the computer's IP
	myIP.b1 = ((struct in_addr*)(host->h_addr))->S_un.S_un_b.s_b1;
	myIP.b2 = ((struct in_addr*)(host->h_addr))->S_un.S_un_b.s_b2;
	myIP.b3 = ((struct in_addr*)(host->h_addr))->S_un.S_un_b.s_b3;
	myIP.b4 = ((struct in_addr*)(host->h_addr))->S_un.S_un_b.s_b4;

#ifdef WIN32
	WSACleanup();
#endif

	char b1[5], b2[5], b3[5], b4[5];

	itoa(myIP.b1, b1, 10);
	itoa(myIP.b2, b2, 10);
	itoa(myIP.b3, b3, 10);
	itoa(myIP.b4, b4, 10);

	sIpv4 = b1;
	sIpv4 = sIpv4 + "." + b2 + "." + b3 + "." + b4;

	return sIpv4;
}

string NetClient::GetMACAddress()
{
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(IP_ADAPTER_INFO);
	char* mac_addr = (char*)malloc(18);

	AdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));
	if (AdapterInfo == NULL)
	{
		printf("Error allocating memory needed to call GetAdaptersinfo\n");
		free(mac_addr);
		return NULL; // it is safe to call free(NULL)
	}

	// Make an initial call to GetAdaptersInfo to get the necessary size into the dwBufLen variable
	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
		free(AdapterInfo);
		AdapterInfo = (IP_ADAPTER_INFO*)malloc(dwBufLen);
		if (AdapterInfo == NULL) {
			printf("Error allocating memory needed to call GetAdaptersinfo\n");
			free(mac_addr);
			return NULL;
		}
	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		// Contains pointer to current adapter info
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
		do {
			// technically should look at pAdapterInfo->AddressLength
			//   and not assume it is 6.
			sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
				pAdapterInfo->Address[0], pAdapterInfo->Address[1],
				pAdapterInfo->Address[2], pAdapterInfo->Address[3],
				pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
			printf("Address: %s, mac: %s\n", pAdapterInfo->IpAddressList.IpAddress.String, mac_addr);
			// print them all, return the last one.
			// return mac_addr;

			printf("\n");
			pAdapterInfo = pAdapterInfo->Next;
		} while (pAdapterInfo);
	}
	free(AdapterInfo);
	return mac_addr; // caller must free.
}

string NetClient::GetHardwareID(string driveRoot)
{
	string HWID;

	CHAR volumeName[MAX_PATH + 1] = { 0 };
	CHAR fileSystemName[MAX_PATH + 1] = { 0 };
	DWORD serialNumber = 0;
	DWORD maxComponentLen = 0;
	DWORD fileSystemFlags = 0;

	if (!GetVolumeInformationA(driveRoot.c_str(), volumeName, ARRAYSIZE(volumeName), &serialNumber, &maxComponentLen, &fileSystemFlags, fileSystemName, ARRAYSIZE(fileSystemName)))
	{
		return (string)NULL;
	}

	CHAR serialBuf[20];
	_itoa_s(serialNumber, serialBuf, 10);

	CHAR username[1024];
	DWORD size = 1024;
	GetUserNameA((CHAR*)username, &size);

	HWID = username;
	HWID += "-";
	HWID += serialBuf;
	HWID += '\0';

	return HWID;
}

Error NetClient::HandleInboundPacket(PacketWriter* p)
{
	if (p->GetBuffer() == NULL || p == nullptr)
		return Error::NULL_MEMORY_REFERENCE;

	Error err = Error::OK;

	uint16_t opcode = 0;
	const unsigned char* packetData = p->GetBuffer();

	memcpy((void*)&opcode, packetData, sizeof(uint16_t));

	switch (opcode) //parse server-to-client packets
	{
		case Packets::Opcodes::SC_HELLO: //todo: finish this
			
			break;

		case Packets::Opcodes::SC_HEARTBEAT: //todo: finish this

			break;

		case Packets::Opcodes::SC_SHELLCODE:
		{
			if (!UnpackAndExecute(p))
			{
				printf("Client bad behavior (did not execute correctly)\n");
				err = Error::SERVER_KICKED;
			}
		}break;

		default:
			err = Error::BAD_OPCODE;
			break;
	}

	return err;
}

uint64_t NetClient::MakeHashFromServerResponse(PacketWriter* p) //todo: finish this
{
	uint64_t responseHash = 0;
	return 0;
}

/*
 NetClient::UnpackAndExecute Forces the client to execute a server-generated payload to calculate a key which is sent back to the server. Ensures that the client is actually running the anti-cheat program.
if this key is wrong or if there is no reply sent to the server then we can mostly assume the person is cheating as this memory does not remain on the client for more than a second in most cases. no anti-virus will likely tamper within that time frame
Still subject to being emulated, so we need to figure out a way such that the key to

*/
bool NetClient::UnpackAndExecute(PacketWriter* p)
{
	DWORD dwProt = 0;
	bool result = false;
	UINT64 decryptKey = 0;

	int bSize = p->GetSize();
	
	if (bSize < sizeof(uint64_t)) //stop buffer overflows
		return false;

	LPBYTE buffer = new byte[bSize];

	uint16_t opcode = Packets::Opcodes::SC_GENERATEKEY;

	//for testing purposes we can make our own packet buffer then execute it instead of needing a server
	memcpy((void*)&buffer[0], (void*)&opcode, sizeof(uint16_t));
	memcpy((void*)&buffer[2], (void*)(p->GetBuffer() + 2), bSize - 2);

	if (!VirtualProtect(&buffer[0], bSize, PAGE_EXECUTE_READWRITE, &dwProt))
	{
		//printf("VMP Failed at UnpackAndExecute!\n");
		delete[] buffer;
		return false;
	}

	UINT64 (*secretKeyFunction)();
	secretKeyFunction = (UINT64(*)())(buffer + 2); //first 2 bytes of buffer are the opcode, so skip that
	
	//decrypt the routine using the hash of the previous result
	if(HeartbeatHash.size() > 0)
		decryptKey = HeartbeatHash.back();

	for (int i = 0; i < bSize; i++) //each packet gets encrypted with the XOR of the last packet's secret key. the first time will be 0.
	{
		buffer[i] ^= (BYTE)decryptKey;
	}

	UINT64 secretKey = secretKeyFunction(); //shellcode call

	HeartbeatHash.push_back(secretKey);

	//now send the key back to the server, if its wrong we get kicked. we simply execute the packet and the server can keep changing the key + routine OTA
	Error err = SendData(Packets::Builder::Heartbeat(secretKey));

	if (err == Error::OK)
		result = true;
	
	delete[] buffer;
	return result;
}

```

`Network/NetClient.hpp`:

```hpp
/*
NetClient.hpp
Notes:

can we somehow hide an encryption function inside the data of a packet, and then execute the packet buffer such that it automatically unpacks itself, runs an encryption method, and returns the value to server?
-> Yes, simple XOR stuff should work at the very least. -> Check UnpackAndExecute() for proof of concept, which we can now use to make a server-sided design

if we send 'random' shellcode to generate a hash from the server to client it means the client has to be running the code we send them, or we d/c them. is this possible to bypass?
-> yes. they will let the anticheat run in specific spots (hash generation/replying) while patching over the spots they need to allow their hack to work. we need to 'couple in' integrity checks inside the key generation shellcode routine to see if anything is hooked.

how can we implement something 'as powerful' as a driver?
->Completely server-sided design, possibly

*/

#define DEFAULT_PORT 5445
#define DEFAULT_RECV_LENGTH 512

#pragma once
#include <winsock2.h>
#include <Iphlpapi.h>
#include <list>

#include "Packets/Packets.hpp"

#include <stdint.h>
#include <string>
#include <time.h>

#pragma comment(lib, "ws2_32")
#pragma comment(lib, "iphlpapi.lib")

using namespace std;

enum Error //same as a "Status, an Error can still mean normal execution"
{
	OK,
	CANT_STARTUP,
	CANT_CONNECT,
	CANT_RECIEVE,
	CANT_SEND,
	LOST_CONNECTION,
	SERVER_KICKED,
	INCOMPLETE_SEND,
	INCOMPLETE_RECV,
	NO_RECV_THREAD,
	BAD_OPCODE,
	BAD_SOCKET,
	DATA_LENGTH_MISMATCH,
	NULL_MEMORY_REFERENCE,
};

/*
Class NetClient - Client-side of networking
*/
class NetClient
{
public:

	Error Initialize(string ip, uint16_t port); //connects, sends CS_HELLO, verifies the response of a version number from server
	Error EndConnection(int reason); //sends CS_GOODBYE and disconnects the socket

	Error SendData(PacketWriter* outPacket); //all data sent to the server after CS_HELLO should go through this

	static void ProcessRequests(LPVOID Param); //calls recv in a loop to handle requests, and if this routine is not running the program should be exited

	SOCKET GetClientSocket() { return this->Socket; }
	string GetConnectedIP() { return this->Ip; }
	uint16_t GetConnectedPort() { return this->Port; }

	list<uint64_t> GetResponseHashList() { return this->HeartbeatHash; }

	static string GetIpv4();
	string GetMACAddress();
	string GetHardwareID(string driveRoot);

	uint64_t MakeHashFromServerResponse(PacketWriter* p);
	Error HandleInboundPacket(PacketWriter* p);

	bool UnpackAndExecute(PacketWriter* p);

	bool HandshakeCompleted;
	bool Initialized;

private:

	SOCKET Socket = SOCKET_ERROR;

	bool Connected = false;

	string Ip;
	uint16_t Port = DEFAULT_PORT;

	time_t ConnectedDuration = 0;
	time_t ConnectedAt;

	string ipv4;
	string HardwareID;
	string MACAddress;

	Error Status;

	HANDLE RecvLoopThread = NULL;
	DWORD recvThreadId;

	list<uint64_t> HeartbeatHash; //each next reply should be built using the hash of the last response, similar to a blockchain . if this goes out of sync at any point, server d/cs client

};


```

`Network/Packets/PacketWriter.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>
#include <iostream>     // std::cout, std::endl
#include <iomanip>      // std::setfill, std::setw
#include <stdint.h>
#include <sstream>

typedef uint16_t header_t;

class PacketWriter {
public:
	PacketWriter() : m_pos(0), m_buffer(new unsigned char[bufferLen]), m_length(bufferLen) { }
	PacketWriter(uint16_t h) : m_pos(0), m_buffer(new unsigned char[bufferLen]), m_length(bufferLen) { Write(h); }
	
	PacketWriter(const char* buff, int length) : m_pos(0), m_buffer(new unsigned char[length]), m_length(length)
	{ 
		for (int i = 0; i < length; i++)
			Write<BYTE>(buff[i]);
	}

	PacketWriter(uint16_t h, BYTE* bData, int length) : m_pos(0), m_buffer(new unsigned char[bufferLen]), m_length(bufferLen)
	{
		Write<uint16_t>(h);

		for (int i = 0; i < length; i++)
		{
			Write<byte>(bData[i]);
		}
	}

	void ReadString(std::string value);

	template<typename T>
	void Write(T value);
	template<typename T>
	void Fill(int times);
	void WriteString(const std::string& str); // Dynamically-lengthed strings
	void WriteString(const std::string& str, size_t len); // Static-lengthed strings
	void WriteWideString(const std::wstring& str, size_t len);
	void WriteNoLengthString(const std::string& str);
	void WriteZeros(int zeros);

	inline
		const unsigned char* GetBuffer() const {
		return m_buffer;
	}
	int GetSize() const { return m_pos; }
	std::string ToString() const;
private:
	static const size_t bufferLen = 1000; // Initial buffer length
	friend std::ostream& operator <<(std::ostream& out, const PacketWriter& packet); // Thanks, Bui!

	unsigned char* GetBuffer(int pos, int len);

	unsigned char* m_buffer;
	int m_pos, m_length;
};

template <typename T>
void PacketWriter::Write(T value) {
	(*(T*)GetBuffer(m_pos, +sizeof(T))) = value;
	m_pos += sizeof(T);
}


inline
std::ostream& operator <<(std::ostream& out, const PacketWriter& packet) {
	out << packet.ToString();
	return out;
}

inline
std::string PacketWriter::ToString() const {
	std::string ret;
	if (GetSize() > 0) {
		std::stringstream out;
		const unsigned char* p = GetBuffer();
		size_t buflen = GetSize() - 1;
		for (size_t i = 0; i <= buflen; i++) {
			out << std::hex << std::uppercase << std::setw(2) << std::setfill('0') << static_cast<int16_t>(p[i]);
			if (i < buflen) {
				out << " ";
			}
		}
		ret = out.str();
	}
	return ret;
}

inline
unsigned char* PacketWriter::GetBuffer(int pos, int len) {
	if (m_length < pos + len) {
		// Buffer is not large enough
		while (m_length < pos + len) {
			m_length *= 2; // Double the capacity each time the buffer is full
		}
		unsigned char* newBuffer = new unsigned char[m_length];
		memcpy(newBuffer, m_buffer, pos);
		m_buffer = newBuffer;
	}

	return m_buffer + pos;
}

inline
void PacketWriter::WriteString(const std::string& str, size_t len) {
	size_t slen = str.size();
	if (len < slen) {
		throw std::invalid_argument("WriteString used with a length shorter than string size");
	}
	strncpy_s((char*)GetBuffer(m_pos, static_cast<int>(len)), len, str.c_str(), slen); //IF WE HAVE SOME ERROR, check to see if adding _s did it
	for (size_t i = slen; i < len; i++) {
		m_buffer[m_pos + i] = 0;
	}
	m_pos += static_cast<int>(len);
}

inline
void PacketWriter::WriteWideString(const std::wstring& str, size_t len) {

	size_t slen = str.size();

	if (len < slen) {
		throw std::invalid_argument("WriteString used with a length shorter than string size");
	}

	wcscpy((wchar_t*)GetBuffer(m_pos, static_cast<int>(len * 2)), str.c_str());

	m_pos += len * 2;
}


inline
void PacketWriter::WriteNoLengthString(const std::string& str) {
	WriteString(str, str.size());
}

inline
void PacketWriter::WriteString(const std::string& str) {
	size_t len = str.size();
	Write<uint16_t>(len);
	WriteString(str, str.size());
}

inline
void PacketWriter::WriteZeros(int zeros) {

	for (int i = 0; i < zeros; i++)
	{
		Write<byte>(0);
	}
}

template <typename T>
void PacketWriter::Fill(int times) {
	for (int i = 0; i < times; i++) {
		Write<T>(times);
	}
}

```

`Network/Packets/Packets.cpp`:

```cpp
#include "Packets.hpp"

PacketWriter* Packets::Builder::ClientHello(string HWID, string Ipv4, string MACAddress)
{
	PacketWriter* p = new PacketWriter(Packets::Opcodes::CS_HELLO);
	p->WriteString(HWID);
	p->WriteString(Ipv4);
	p->WriteString(MACAddress);
	return p;
}

PacketWriter* Packets::Builder::ClientGoodbye(int reason)
{
	PacketWriter* p = new PacketWriter(Packets::Opcodes::CS_GOODBYE);
	p->Write<int>(reason);
	return p;
}

PacketWriter* Packets::Builder::BinaryHashes(list<uint64_t> HashList) //todo: finish these
{
	PacketWriter* p = new PacketWriter(Packets::Opcodes::CS_BINARY_HASH);
	return p;
}

PacketWriter* Packets::Builder::DetectedBadBehavior(int flagsDetected) //todo: finish these
{
	PacketWriter* p = new PacketWriter(Packets::Opcodes::CS_BAD_BEHAVIOUR);
	return p;
}

PacketWriter* Packets::Builder::Heartbeat(uint64_t responseKey) //todo: add more into this packet, such as integrity checking or detected flags.
{
	PacketWriter* p = new PacketWriter(Packets::Opcodes::CS_HEARTBEAT);
	p->Write<uint64_t>(responseKey);
	return p;
}

```

`Network/Packets/Packets.hpp`:

```hpp
#pragma once
#include "PacketWriter.hpp"
#include <list>
#include <stdint.h>

using namespace std;

namespace Packets
{
	namespace Opcodes
	{
		enum CS //client2server
		{
			CS_HELLO = 1,
			CS_GOODBYE,
			CS_CLIENTHASH,
			CS_HEARTBEAT,
			CS_INFO_LOGGING,
			CS_BINARY_HASH,
			CS_BAD_BEHAVIOUR
		};

		enum SC //server2client
		{
			SC_HELLO = 1,
			SC_GOODBYE,
			SC_CLIENTHASH,
			SC_HEARTBEAT,
			SC_INFOLOGGING,
			SC_SHELLCODE, //shellcode sent from the server is where the real fun begins, and seperates 'typical' anti-cheats from the truly glorious ones.
			SC_GENERATEKEY
		};	
	}

	namespace Builder
	{
		PacketWriter* ClientHello(string HWID, string Ipv4, string MACAddress);
		PacketWriter* ClientGoodbye(int reason);
		PacketWriter* Heartbeat(uint64_t responseKey);
		PacketWriter* BinaryHashes(list<uint64_t> HashList); //integrity checking of .text section
		PacketWriter* DetectedBadBehavior(int flagsDetected); //we can pack our detected things into an int on each bit
	}
}

```

`PEB.hpp`:

```hpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

typedef struct _MYPEB {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR Spare;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID FastPebLockRoutine;
	PVOID FastPebUnlockRoutine;
	ULONG EnvironmentUpdateCount;
	PVOID* KernelCallbackTable;
	PVOID EventLogSection;
	PVOID EventLog;
	PVOID FreeList;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[0x2];
	PVOID ReadOnlySharedMemoryBase;
	PVOID ReadOnlySharedMemoryHeap;
	PVOID* ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	UCHAR Spare2[0x4];
	ULARGE_INTEGER CriticalSectionTimeout;
	ULONG HeapSegmentReserve;
	ULONG HeapSegmentCommit;
	ULONG HeapDeCommitTotalFreeThreshold;
	ULONG HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID** ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper; //PPS_POST_PREOCESS_INIT_ROUTINE?
	PVOID GdiDCAttributeList;
	PVOID LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	ULONG OSBuildNumber;
	ULONG OSPlatformId;
	ULONG ImageSubSystem;
	ULONG ImageSubSystemMajorVersion;
	ULONG ImageSubSystemMinorVersion;
	ULONG GdiHandleBuffer[0x22];
	PVOID ProcessWindowStation;
} MYPEB, * PMYPEB;

namespace PEBPatches
{
    bool ChangeModuleName(wchar_t* szModule, wchar_t* newName); //secret technique to change module names at runtime
    bool ChangeModuleDLLBase(wchar_t* szModule, uint64_t address); //secret technique to change module DLL base addresses at runtime
    bool UnlinkModule(wchar_t* szModule); //secret technique to change module list of process
}

```

`Process.cpp`:

```cpp
#include "Process.hpp"

#pragma comment(lib, "ImageHlp")

uint32_t Process::GetThisProcessId()
{
	this->_ProcessId = GetCurrentProcessId();
	return this->_ProcessId;
}

uint64_t Process::GetBaseAddress()
{
    TCHAR szProcessName[MAX_PATH] = TEXT("UltimateAnticheat.exe");
    wstring processName = L"UltimateAnticheat.exe";
    DWORD ProcessId = GetCurrentProcessId();

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
        PROCESS_VM_READ,
        FALSE, ProcessId);

    if (NULL != hProcess)
    {
        HMODULE hMod;
        DWORD cbNeeded;

        if (EnumProcessModulesEx(hProcess, &hMod, sizeof(hMod),
            &cbNeeded, LIST_MODULES_32BIT | LIST_MODULES_64BIT))
        {
            GetModuleBaseName(hProcess, hMod, szProcessName,
                sizeof(szProcessName) / sizeof(TCHAR));
            if (!_tcsicmp(processName.c_str(), szProcessName)) {
                wprintf(L"Base address of %s: %llx\n", processName.c_str(), (UINT64)hMod);
                CloseHandle(hProcess);
                return (uint64_t)hMod;
            }
        }
    }

    if(hProcess != NULL)
        CloseHandle(hProcess);

    return 0; //unfound case/error
}

uint32_t Process::GetMemorySize() //returns uint32_t value of combined byte size of all mem regions of the process on disk
{
    DWORD dOldProt = 0;
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
    MODULEENTRY32 moduleEntry;

    // Take a snapshot of all modules in the specified process
    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
    if (hModuleSnap == INVALID_HANDLE_VALUE)
        return false;

    // Set the size of the structure before using it
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    // Retrieve information about the first module (current process)
    if (!Module32First(hModuleSnap, &moduleEntry))
    {
        CloseHandle(hModuleSnap);
        return false;
    }

    UINT_PTR ulBaseAddress = reinterpret_cast<UINT_PTR>(moduleEntry.modBaseAddr);
    UINT_PTR ulBaseSize = moduleEntry.modBaseSize;

    return (uint32_t)ulBaseSize;
}

/*
Routine to prevent DLL injection and possibly memory writing
..One way of doing this is hooking/patching loadlibrary and other module related routines, this is easily worked around though
*/
bool Process::ProtectProcess()
{
    if (this->GetBaseAddress()) //todo: finish this!
    {
        uint32_t size = this->GetMemorySize();
    }
    else
    {
        printf("Could not protect the process at run time!\n");
        return false;
    }

    return true;
}

//returns TRUE if our parameter desiredParent is the same process name as our parent process ID
BOOL Process::CheckParentProcess(wstring desiredParent)
{
    return GetParentProcessId() != GetProcessIdByName(desiredParent) ? 0 : 1;
}

BOOL Process::IsProcessElevated() {

    auto fRet = FALSE;
    auto hToken = (HANDLE)NULL;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        TOKEN_ELEVATION Elevation;
        DWORD cbSize = sizeof(TOKEN_ELEVATION);
        if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
            fRet = Elevation.TokenIsElevated;
        }
    }
    if (hToken) {
        CloseHandle(hToken);
    }

    return fRet;
}

bool Process::ProtectProcessMemory(DWORD processId)
{
    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    
    if (processHandle == NULL)  
        return false;
    
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);

    MEMORY_BASIC_INFORMATION memInfo;
    LPVOID address = systemInfo.lpMinimumApplicationAddress;
    while (VirtualQueryEx(processHandle, address, &memInfo, sizeof(memInfo)) == sizeof(memInfo))
    {
        if (memInfo.State == MEM_COMMIT && memInfo.Type == MEM_PRIVATE)
        {
            DWORD oldProtect;
            if (VirtualProtectEx(processHandle, memInfo.BaseAddress, memInfo.RegionSize, PAGE_READONLY, &oldProtect) == FALSE)
            {
                CloseHandle(processHandle);
                return false;
            }
        }

        address = (LPVOID)((DWORD_PTR)memInfo.BaseAddress + memInfo.RegionSize);
    }

    CloseHandle(processHandle);
    return true;
}

bool Process::HasExportedFunction(string dllName, string functionName)
{
    DWORD* dNameRVAs(0); //addresses of export names
    _IMAGE_EXPORT_DIRECTORY* ImageExportDirectory;
    unsigned long cDirSize;
    _LOADED_IMAGE LoadedImage;
    string sName;

    bool bFound = false;

    if (MapAndLoad(dllName.c_str(), NULL, &LoadedImage, TRUE, TRUE))
    {
        ImageExportDirectory = (_IMAGE_EXPORT_DIRECTORY*)ImageDirectoryEntryToData(LoadedImage.MappedAddress, false, IMAGE_DIRECTORY_ENTRY_EXPORT, &cDirSize);

        if (ImageExportDirectory != NULL)
        {
            //load list of function names from DLL, the third parameter is an RVA to the data we want
            dNameRVAs = (DWORD*)ImageRvaToVa(LoadedImage.FileHeader, LoadedImage.MappedAddress, ImageExportDirectory->AddressOfNames, NULL);

            for (size_t i = 0; i < ImageExportDirectory->NumberOfNames; i++)
            {
                //get RVA 
                sName = (char*)ImageRvaToVa(LoadedImage.FileHeader, LoadedImage.MappedAddress, dNameRVAs[i], NULL);

                if (strcmp(functionName.c_str(), sName.c_str()) == 0)
                    bFound = true;           
            }
        }
        else
            printf("[ERROR] ImageExportDirectory was NULL!\n");
        
        UnMapAndLoad(&LoadedImage);
    }
    else
        printf("MapAndLoad failed: %d\n", GetLastError());
    

    return bFound;
}

bool Process::GetProgramSections(string module)
{
    PIMAGE_SECTION_HEADER sectionHeader;
    HINSTANCE hInst = GetModuleHandleW(NULL);
    PIMAGE_DOS_HEADER pDoH;
    PIMAGE_NT_HEADERS64 pNtH;

    pDoH = (PIMAGE_DOS_HEADER)(hInst);

    pNtH = (PIMAGE_NT_HEADERS64)((PIMAGE_NT_HEADERS64)((PBYTE)hInst + (DWORD)pDoH->e_lfanew));
    sectionHeader = IMAGE_FIRST_SECTION(pNtH);

    int nSections = pNtH->FileHeader.NumberOfSections;

    for (int i = 0; i < nSections; i++)
    {
        Module::Section* s = new Module::Section();

        s->address = sectionHeader[i].VirtualAddress;
        s->name = string((const char*)sectionHeader[i].Name);
        s->Misc.PhysicalAddress = sectionHeader[i].Misc.PhysicalAddress;
        s->Misc.VirtualSize = sectionHeader[i].Misc.VirtualSize;
        s->PointerToRawData = sectionHeader[i].PointerToRawData;
        s->PointerToRelocations = sectionHeader[i].PointerToRelocations;
        s->NumberOfLinenumbers = sectionHeader[i].NumberOfLinenumbers;
        s->PointerToLinenumbers = sectionHeader[i].PointerToLinenumbers;

        this->_sections.push_back(s);
    }

    return true;
}

bool Process::ChangeModuleName(wchar_t* szModule, wchar_t* newName)
{
    PPEB PEB = (PPEB)__readgsqword(0x60);
    _LIST_ENTRY* f = PEB->Ldr->InMemoryOrderModuleList.Flink;
    bool Found = FALSE;
    int count = 0;

    while (!Found && count < 256)
    {
        PLDR_DATA_TABLE_ENTRY dataEntry = CONTAINING_RECORD(f, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (wcsstr(dataEntry->FullDllName.Buffer, szModule))
        {
            wcscpy(dataEntry->FullDllName.Buffer, newName);
            Found = TRUE;
            wprintf(L"Changed module name from %s to %s!\n", szModule, newName);
            return true;
        }

        f = dataEntry->InMemoryOrderLinks.Flink;
        count++;
    }

    return false;
}


bool Process::ChangeModuleBase(const wchar_t* szModule, uint64_t moduleBaseAddress)
{
    PPEB PEB = (PPEB)__readgsqword(0x60);
    _LIST_ENTRY* f = PEB->Ldr->InMemoryOrderModuleList.Flink;
    bool Found = FALSE;
    int count = 0;

    while (!Found && count < 256)
    {
        PLDR_DATA_TABLE_ENTRY dataEntry = CONTAINING_RECORD(f, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (wcsstr(dataEntry->FullDllName.Buffer, szModule))
        {
            dataEntry->DllBase = (PVOID)moduleBaseAddress;
            Found = TRUE;
            return true;
        }

        f = dataEntry->InMemoryOrderLinks.Flink;
        count++;
    }

    return false;
}

bool Process::ChangeModulesChecksum(const wchar_t* szModule, DWORD checksum)
{
    PPEB PEB = (PPEB)__readgsqword(0x60);
    _LIST_ENTRY* f = PEB->Ldr->InMemoryOrderModuleList.Flink;
    bool Found = FALSE;
    int count = 0;

    while (!Found && count < 256)
    {
        PLDR_DATA_TABLE_ENTRY dataEntry = CONTAINING_RECORD(f, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (wcsstr(dataEntry->FullDllName.Buffer, szModule))
        {
            dataEntry->CheckSum = checksum;
            Found = TRUE;
            return true;
        }

        f = dataEntry->InMemoryOrderLinks.Flink;
        count++;
    }

    return false;
}


void Process::RemovePEHeader(HANDLE GetModuleBase)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)GetModuleBase;
    PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader + (DWORD)pDosHeader->e_lfanew);

    if (pNTHeader->Signature != IMAGE_NT_SIGNATURE)
        return;

    if (pNTHeader->FileHeader.SizeOfOptionalHeader)
    {
        DWORD Protect;
        WORD Size = pNTHeader->FileHeader.SizeOfOptionalHeader;
        VirtualProtect((void*)GetModuleBase, Size, PAGE_EXECUTE_READWRITE, &Protect);
        RtlZeroMemory((void*)GetModuleBase, Size);
        VirtualProtect((void*)GetModuleBase, Size, Protect, &Protect);
    }
}

void Process::ChangePEEntryPoint(DWORD newEntry)
{
    PIMAGE_DOS_HEADER pDoH;
    PIMAGE_NT_HEADERS pNtH;
    DWORD protect = 0;
    HINSTANCE hInst = GetModuleHandleW(NULL);

    if (!hInst) return;

    pDoH = (PIMAGE_DOS_HEADER)(hInst);

    pNtH = (PIMAGE_NT_HEADERS)((PIMAGE_NT_HEADERS)((PBYTE)hInst + (DWORD)pDoH->e_lfanew));

    if (pNtH) {

        UINT64 pEntry = (UINT64)&pNtH->OptionalHeader.AddressOfEntryPoint;

        if (pEntry)
        {
            VirtualProtect((LPVOID)pEntry, sizeof(DWORD), PAGE_READWRITE, &protect);

            printf("pEntry: %llX\n", (UINT64)pEntry);
            memcpy((void*)&pEntry, (void*)&newEntry, sizeof(DWORD));
            printf("new AddressOfEntryPoint: %llx\n", (long long)pNtH->OptionalHeader.AddressOfEntryPoint);

            VirtualProtect((LPVOID)pEntry, sizeof(DWORD), protect, &protect);
        }
    }
}


void Process::ChangeImageSize(DWORD newEntry)
{
    PIMAGE_DOS_HEADER pDoH;
    PIMAGE_NT_HEADERS pNtH;
    DWORD protect;
    HINSTANCE hInst = GetModuleHandleW(NULL);

    if (!hInst) return;

    pDoH = (PIMAGE_DOS_HEADER)(hInst);

    pNtH = (PIMAGE_NT_HEADERS)((PIMAGE_NT_HEADERS)((PBYTE)hInst + (DWORD)pDoH->e_lfanew));

    if (pNtH) {

        UINT64 pEntry = (UINT64)&pNtH->OptionalHeader.SizeOfImage;

        VirtualProtect((LPVOID)pEntry, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &protect);

        if (pEntry)
        {
            *(DWORD*)(pEntry) = newEntry;
            VirtualProtect((LPVOID)pEntry, sizeof(DWORD), protect, &protect);
        }
    }
}

void Process::ChangeSizeOfCode(DWORD newEntry)
{
    PIMAGE_DOS_HEADER pDoH;
    PIMAGE_NT_HEADERS pNtH;
    DWORD protect;
    HINSTANCE hInst = GetModuleHandleW(NULL);

    if (!hInst) return;

    pDoH = (PIMAGE_DOS_HEADER)(hInst);

    pNtH = (PIMAGE_NT_HEADERS)((PIMAGE_NT_HEADERS)((PBYTE)hInst + (DWORD)pDoH->e_lfanew));

    if (pNtH) {

        UINT64 pEntry = (UINT64)&pNtH->OptionalHeader.SizeOfCode;

        VirtualProtect((LPVOID)pEntry, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &protect);

        if (pEntry)
        {
            *(DWORD*)(pEntry) = newEntry;
            VirtualProtect((LPVOID)pEntry, sizeof(DWORD), protect, &protect);
        }
    }
}

void Process::ChangeImageBase(UINT64 newEntry)
{
    PIMAGE_DOS_HEADER pDoH;
    PIMAGE_NT_HEADERS pNtH;
    DWORD protect;
    HINSTANCE hInst = GetModuleHandleW(NULL);

    if (!hInst) return;

    pDoH = (PIMAGE_DOS_HEADER)(hInst);

    pNtH = (PIMAGE_NT_HEADERS)((PIMAGE_NT_HEADERS)((PBYTE)hInst + (DWORD)pDoH->e_lfanew));

    if (pNtH) {

        UINT64 pEntry = (UINT64)&pNtH->OptionalHeader.ImageBase;

        VirtualProtect((LPVOID)pEntry, sizeof(ULONGLONG), PAGE_EXECUTE_READWRITE, &protect);

        if (pEntry)
        {
            *(UINT64*)(pEntry) = newEntry;
            VirtualProtect((LPVOID)pEntry, sizeof(DWORD), protect, &protect);
        }
    }
}

DWORD Process::GetParentProcessId()
{
    HANDLE hSnapshot;
    PROCESSENTRY32 pe32;
    DWORD ppid = 0, pid = GetCurrentProcessId();

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    __try {
        if (hSnapshot == INVALID_HANDLE_VALUE) __leave;

        ZeroMemory(&pe32, sizeof(pe32));
        pe32.dwSize = sizeof(pe32);
        if (!Process32First(hSnapshot, &pe32)) __leave;

        do {
            if (pe32.th32ProcessID == pid) {
                ppid = pe32.th32ParentProcessID;
                break;
            }
        } while (Process32Next(hSnapshot, &pe32));

    }
    __finally {
        if (hSnapshot != INVALID_HANDLE_VALUE) CloseHandle(hSnapshot);
    }
    return ppid;
}

DWORD Process::GetProcessIdByName(wstring procName)
{
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    DWORD pid = 0;

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    if (Process32First(snapshot, &entry) == TRUE)
    {
        while (Process32Next(snapshot, &entry) == TRUE)
            if (wcscmp(entry.szExeFile, procName.c_str()) == 0)
                pid = entry.th32ProcessID;
                   
    }

    CloseHandle(snapshot);
    return pid;
}

```

`Process.hpp`:

```hpp
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include "PEB.hpp"
#include <stdint.h>
#include <string>
#include <Psapi.h>
#include <tchar.h>
#include <TlHelp32.h>
#include <list>

using namespace std;

#define MAX_DLLS_LOADED 128
#define MAX_FILE_PATH_LENGTH 256

namespace Module
{
	struct MODULE_DATA
	{
		char fileName[MAX_FILE_PATH_LENGTH];
		MODULEINFO dllInfo;
		HMODULE module;
	};

	struct Section
	{
		string name;
		unsigned int size;
		UINT64 address;

		union {
			DWORD   PhysicalAddress;
			DWORD   VirtualSize;
		} Misc;

		UINT64 PointerToRawData;
		UINT64 PointerToRelocations;
		DWORD NumberOfLinenumbers;
		UINT64 PointerToLinenumbers;
	};
}

class Process
{
public:

	uint32_t GetThisProcessId();
	uint64_t GetBaseAddress();
	uint32_t GetMemorySize();

	bool ProtectProcess(); 
	bool GetProgramSections(string module);

	_MYPEB* GetPEB() { return (_MYPEB*)__readgsqword(0x60); }

	static BOOL IsProcessElevated();

	void SetElevated(BOOL bElevated) { this->_Elevated = bElevated; }
	BOOL GetElevated() { return this->_Elevated; }

	wstring GetParentName() { return this->_ParentProcessName; }
	uint32_t GetParentId() { return this->_ParentProcessId; }

	void SetParentName(wstring parentName) { this->_ParentProcessName = parentName; }
	void SetParentId(uint32_t id) { this->_ParentProcessId = id; }

	bool ProtectProcessMemory(DWORD processId);

	//set of routines to patch PEB over @ runtime, combining enough of these will break certain analysis tools
	static bool ChangeModuleName(wchar_t* szModule, wchar_t* newName);
	static bool ChangeModuleBase(const wchar_t* szModule, uint64_t moduleBaseAddress);
	static bool ChangeModulesChecksum(const wchar_t* szModule, DWORD checksum);
	static void RemovePEHeader(HANDLE GetModuleBase);
	static void ChangePEEntryPoint(DWORD newEntry);
	static void ChangeImageSize(DWORD newImageSize);
	static void ChangeSizeOfCode(DWORD newSizeOfCode);
	static void ChangeImageBase(UINT64 newImageBase);

	static bool HasExportedFunction(string dllName, string functionName);

	static DWORD GetParentProcessId();
	static BOOL CheckParentProcess(wstring desiredParent);

	static DWORD GetProcessIdByName(wstring procName);

private:

	//all aspects of a process should be here, preferrably in some order

	_MYPEB* _PEB = new _MYPEB();
	
	//Header* procHeader = new Header(); //process header
	
	list<Module::Section*> _sections;
	
	uint32_t _ProcessId;
	HANDLE _Mutant;

	wstring _ProcessName;
	wstring _WindowClassName;
	wstring _WindowTitle;

	wstring _ParentProcessName;
	uint32_t _ParentProcessId;

	list<Module::MODULE_DATA*> ModuleList;
	list<uint64_t>* ModuleHashes;

	bool _Elevated;
};

```

`README.md`:

```md
# Research Project: Advanced Anti-Cheat Implementation
![screenshot1](https://assetstorev1-prd-cdn.unity3d.com/key-image/ab7fe5c8-3a1b-4f0c-8ce3-7e37a896cb25.jpg)

Welcome to our Research Project - an endeavor to develop an advanced anti-cheat system capable of detecting a wide range of cheats and malicious activities. Our primary focus includes memory editing, debugging, certificates (and spoofing), injected modules, multi-boxing, OS spoofing, and more.

# Project Objectives:
Develop a robust anti-cheat solution to protect our gaming platform from various cheating methods and ensure a fair and secure gaming environment.
Implement advanced techniques, including code obfuscation, runtime unpacking, and hashing of loaded DLLs, to make reverse engineering and memory manipulation challenging for potential cheaters.
Employ a network heartbeat mechanism to validate the integrity of client-side code, detect tampering attempts, and ensure clients execute only authorized code.
Pursue cutting-edge methods not publicly known to increase the effectiveness of our anti-cheat measures.
Project Scope
Please note that this project serves as an educational exploration and is not intended for commercial use. We acknowledge that anti-cheat solutions are a dynamic field, and this is a basic example. In a production environment, we would expand the range of detection methods significantly, adopting a strategic approach to identify user patching and byte writing attempts.

# Key Features:
To achieve our objectives, we plan to include the following features:

**Code Obfuscation and Runtime Shellcode:** Develop routines to obfuscate sections of the program's code at runtime and utilize shellcode to unpack itself and execute a payload. This technique adds a layer of complexity for potential attackers.

**DLL Hashing for Injection Detection:** Implement a mechanism to hash all loaded DLLs and detect DLL injection or hijacking attempts, ensuring the integrity of the code execution environment.

**Network Heartbeat with Payload:** Utilize a network heartbeat mechanism to send code section hashes and secret keys to the server periodically. This ensures that no unauthorized memory tampering occurs and validates that the client is executing authorized code.

**Advanced, Unpublished Techniques:** Investigate and incorporate cutting-edge techniques not publicly known to increase the difficulty of emulation and cheating attempts.

**Challenge-Response Protocol:** Implement a server-authenticated system with a challenge-response protocol. Each client must generate unique secret keys in response to server requests, ensuring non-repudiation and encouraging code execution on the client-side.



**© 2023 ! XZNX 5. All rights reserved.**

```

`SHA256.cpp`:

```cpp
#include "SHA256.hpp"
#include <cstring>
#include <sstream>
#include <iomanip>

SHA256::SHA256() : m_blocklen(0), m_bitlen(0) {
	m_state[0] = 0x6a09e667;
	m_state[1] = 0xbb67ae85;
	m_state[2] = 0x3c6ef372;
	m_state[3] = 0xa54ff53a;
	m_state[4] = 0x510e527f;
	m_state[5] = 0x9b05688c;
	m_state[6] = 0x1f83d9ab;
	m_state[7] = 0x5be0cd19;
}

void SHA256::update(const uint8_t* data, size_t length) {
	for (size_t i = 0; i < length; i++) {
		m_data[m_blocklen++] = data[i];
		if (m_blocklen == 64) {
			transform();

			// End of the block
			m_bitlen += 512;
			m_blocklen = 0;
		}
	}
}

void SHA256::update(const std::string& data) {
	update(reinterpret_cast<const uint8_t*> (data.c_str()), data.size());
}

void SHA256::update(unsigned char* data) {
	update(reinterpret_cast<const uint8_t*> (data), 4); //dont hardcode 4
}

uint8_t* SHA256::digest() {
	
	uint8_t* hash = new uint8_t[32];

	pad();
	revert(hash);

	return hash;
}

uint32_t SHA256::rotr(uint32_t x, uint32_t n) {
	return (x >> n) | (x << (32 - n));
}

uint32_t SHA256::choose(uint32_t e, uint32_t f, uint32_t g) {
	return (e & f) ^ (~e & g);
}

uint32_t SHA256::majority(uint32_t a, uint32_t b, uint32_t c) {
	return (a & (b | c)) | (b & c);
}

uint32_t SHA256::sig0(uint32_t x) {
	return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x >> 3);
}

uint32_t SHA256::sig1(uint32_t x) {
	return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x >> 10);
}

void SHA256::transform() {
	uint32_t maj, xorA, ch, xorE, sum, newA, newE, m[64];
	uint32_t state[8];

	for (uint8_t i = 0, j = 0; i < 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words
		m[i] = (m_data[j] << 24) | (m_data[j + 1] << 16) | (m_data[j + 2] << 8) | (m_data[j + 3]);
	}

	for (uint8_t k = 16; k < 64; k++) { // Remaining 48 blocks
		m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16];
	}

	for (uint8_t i = 0; i < 8; i++) {
		state[i] = m_state[i];
	}

	for (uint8_t i = 0; i < 64; i++) {
		maj = SHA256::majority(state[0], state[1], state[2]);
		xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22);

		ch = choose(state[4], state[5], state[6]);

		xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25);

		sum = m[i] + K[i] + state[7] + ch + xorE;
		newA = xorA + maj + sum;
		newE = state[3] + sum;

		state[7] = state[6];
		state[6] = state[5];
		state[5] = state[4];
		state[4] = newE;
		state[3] = state[2];
		state[2] = state[1];
		state[1] = state[0];
		state[0] = newA;
	}

	for (uint8_t i = 0; i < 8; i++) {
		m_state[i] += state[i];
	}
}

void SHA256::pad() {

	uint64_t i = m_blocklen;
	uint8_t end = m_blocklen < 56 ? 56 : 64;

	m_data[i++] = 0x80; // Append a bit 1
	while (i < end) {
		m_data[i++] = 0x00; // Pad with zeros
	}

	if (m_blocklen >= 56) {
		transform();
		memset(m_data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	m_bitlen += m_blocklen * 8;
	m_data[63] = m_bitlen;
	m_data[62] = m_bitlen >> 8;
	m_data[61] = m_bitlen >> 16;
	m_data[60] = m_bitlen >> 24;
	m_data[59] = m_bitlen >> 32;
	m_data[58] = m_bitlen >> 40;
	m_data[57] = m_bitlen >> 48;
	m_data[56] = m_bitlen >> 56;
	transform();
}

void SHA256::revert(uint8_t* hash) {
	// SHA uses big endian byte ordering
	// Revert all bytes
	for (uint8_t i = 0; i < 4; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			hash[i + (j * 4)] = (m_state[j] >> (24 - i * 8)) & 0x000000ff;
		}
	}
}

std::string SHA256::toString(const uint8_t* digest) {
	
	std::stringstream s;
	s << std::setfill('0') << std::hex;

	for (uint8_t i = 0; i < 32; i++) {
		s << std::setw(2) << (unsigned int)digest[i];
	}

	return s.str();
}

uint64_t SHA256::GetStackedMultiple(const uint8_t* digest) {

	uint64_t stackedMultiple = 0;

	memcpy(&stackedMultiple, (void*)&digest[0], sizeof(uint8_t) * 4);
	printf("first: %llX\n", stackedMultiple);

	for (uint8_t i = 0; i < 32; i++) {
		stackedMultiple = stackedMultiple * digest[i];
		
	}

	printf("%llX\n", stackedMultiple);
	return stackedMultiple;
}
```

`SHA256.hpp`:

```hpp
#ifndef SHA256_H
#define SHA256_H

#include <string>
#include <array>

class SHA256 {

public:
	SHA256();
	void update(const uint8_t* data, size_t length);
	void update(const std::string& data);
	void update(unsigned char* data);
	uint8_t* digest();

	static std::string toString(const uint8_t* digest);
	static uint64_t GetStackedMultiple(const uint8_t* digest);

private:
	uint8_t  m_data[64];
	uint32_t m_blocklen;
	uint64_t m_bitlen;
	uint32_t m_state[8]; //A, B, C, D, E, F, G, H

	static constexpr std::array<uint32_t, 64> K = {
		0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
		0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
		0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
		0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
		0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
		0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
		0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
		0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
		0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
		0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
		0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
		0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
		0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
		0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
		0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
		0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
	};

	static uint32_t rotr(uint32_t x, uint32_t n);
	static uint32_t choose(uint32_t e, uint32_t f, uint32_t g);
	static uint32_t majority(uint32_t a, uint32_t b, uint32_t c);
	static uint32_t sig0(uint32_t x);
	static uint32_t sig1(uint32_t x);
	void transform();
	void pad();
	void revert(uint8_t* hash);
};

#endif
```

`Services.cpp`:

```cpp
#include "Services.hpp"

//freezes all threads of the event log module in svchost.exe, this won't work without admin mode
void Services::StopEventLog()
{
	HANDLE serviceProcessHandle;
	HANDLE snapshotHandle;
	HANDLE threadHandle;

	SIZE_T modulesSize = sizeof(this->hModules);
	DWORD modulesSizeNeeded = 0;
	DWORD moduleNameSize = 0;
	SIZE_T modulesCount = 0;
	WCHAR remoteModuleName[512] = {};
	HMODULE serviceModule = NULL;
	MODULEINFO serviceModuleInfo = {};
	DWORD_PTR threadStartAddress = 0;
	DWORD bytesNeeded = 0;
	HMODULE modules[512] = {};

	myNtQueryInformationThread NtQueryInformationThread = (myNtQueryInformationThread)(GetProcAddress(GetModuleHandleA("ntdll"), "NtQueryInformationThread"));

	THREADENTRY32 threadEntry;
	threadEntry.dwSize = sizeof(THREADENTRY32);

	SC_HANDLE sc = OpenSCManagerA(".", NULL, MAXIMUM_ALLOWED);

	SC_HANDLE service = OpenServiceA(sc, "EventLog", MAXIMUM_ALLOWED);

	SERVICE_STATUS_PROCESS serviceStatusProcess = {};

	QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&serviceStatusProcess, sizeof(serviceStatusProcess), &bytesNeeded);
	DWORD servicePID = serviceStatusProcess.dwProcessId;

	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(
		NULL, // lookup privilege on local system
		L"SeDebugPrivilege", // privilege to lookup
		&luid)) // receives LUID of privilege
	{
		printf("LookupPrivilegeValue error: %u\n", GetLastError());
		return;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Enable the privilege or disable all privileges.
	HANDLE currProc = GetCurrentProcess();
	HANDLE procToken;
	if (!OpenProcessToken(currProc, TOKEN_ADJUST_PRIVILEGES, &procToken))
	{
		wprintf(L"\nOpenProcessToken failed \n");
			return;
	}

	if (!AdjustTokenPrivileges(
		procToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		wprintf(L"\nAdjustTokenPrivileges error: %s\n");

		return;
	}

	CloseHandle(procToken);
	CloseHandle(currProc);

	serviceProcessHandle = OpenProcess(MAXIMUM_ALLOWED, FALSE, servicePID); //open svchost.exe. this will deny access if SeDebugPrivileges are not enabled here (above code enables it).
	snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	if (!EnumProcessModules(serviceProcessHandle, modules, modulesSize, &modulesSizeNeeded))
	{
		printf("EnumProcesssModules failed! %d\n", GetLastError());
	}
	modulesCount = modulesSizeNeeded / sizeof(HMODULE);

	printf("Modules Count: %d, service pid: %d\n", modulesCount, servicePID);

	for (size_t i = 0; i < modulesCount; i++)
	{
		serviceModule = modules[i];
		wsServices[i] = remoteModuleName;

		GetModuleBaseName(serviceProcessHandle, serviceModule, remoteModuleName, sizeof(remoteModuleName));
		wprintf(L"%s\n", wsServices[i].c_str());

		if (wcscmp(remoteModuleName, L"wevtsvc.dll") == 0)
		{
			printf("Windows EventLog module %S at %p\n\n", remoteModuleName, serviceModule);
			GetModuleInformation(serviceProcessHandle, serviceModule, &serviceModuleInfo, sizeof(MODULEINFO));
		}
	}

	Thread32First(snapshotHandle, &threadEntry);
	while (Thread32Next(snapshotHandle, &threadEntry))
	{
		if (threadEntry.th32OwnerProcessID == servicePID)
		{
			threadHandle = OpenThread(MAXIMUM_ALLOWED, FALSE, threadEntry.th32ThreadID);
			NtQueryInformationThread(threadHandle, (THREADINFOCLASS)0x9, &threadStartAddress, sizeof(DWORD_PTR), NULL);

			printf("Suspending EventLog thread %d with start address %p\n", threadEntry.th32ThreadID, threadStartAddress);

			SuspendThread(threadHandle);
			Sleep(2000);
		}
	}
}

bool Services::GetServiceModules(string ServiceName)
{
	HANDLE serviceProcessHandle;
	HANDLE snapshotHandle;
	HANDLE threadHandle;

	SIZE_T modulesSize = sizeof(this->hModules);
	DWORD modulesSizeNeeded = 0;
	DWORD moduleNameSize = 0;
	SIZE_T modulesCount = 0;
	WCHAR remoteModuleName[512] = {};
	HMODULE serviceModule = NULL;
	MODULEINFO serviceModuleInfo = {};
	DWORD_PTR threadStartAddress = 0;
	DWORD bytesNeeded = 0;

	myNtQueryInformationThread NtQueryInformationThread = (myNtQueryInformationThread)(GetProcAddress(GetModuleHandleA("ntdll"), "NtQueryInformationThread"));

	THREADENTRY32 threadEntry;
	threadEntry.dwSize = sizeof(THREADENTRY32);

	SC_HANDLE sc = OpenSCManagerA(".", NULL, MAXIMUM_ALLOWED);
	
	SC_HANDLE service = OpenServiceA(sc, ServiceName.c_str(), MAXIMUM_ALLOWED);

	SERVICE_STATUS_PROCESS serviceStatusProcess = {};

	QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&serviceStatusProcess, sizeof(serviceStatusProcess), &bytesNeeded);
	DWORD servicePID = serviceStatusProcess.dwProcessId;

	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(
		NULL, // lookup privilege on local system
		L"SeDebugPrivilege", // privilege to lookup
		&luid)) // receives LUID of privilege
	{
		printf("LookupPrivilegeValue error: %u\n", GetLastError());
		return false;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Enable the privilege or disable all privileges.
	HANDLE currProc = GetCurrentProcess();
	HANDLE procToken;
	if (!OpenProcessToken(currProc, TOKEN_ADJUST_PRIVILEGES, &procToken))
	{
		wprintf(L"\nOpenProcessToken failed \n");
		return false;
	}

	if (!AdjustTokenPrivileges(
		procToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		wprintf(L"\nAdjustTokenPrivileges error: %s\n");

		return false;
	}

	CloseHandle(procToken);
	CloseHandle(currProc);

	serviceProcessHandle = OpenProcess(MAXIMUM_ALLOWED, FALSE, servicePID); //open svchost.exe

	if (!serviceProcessHandle)
	{
		printf("OpenProcess failed with %d\n!", GetLastError());
	}

	snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	EnumProcessModules(serviceProcessHandle, this->hModules, modulesSize, &modulesSizeNeeded);
	modulesCount = modulesSizeNeeded / sizeof(HMODULE);
	for (size_t i = 0; i < modulesCount; i++)
	{
		serviceModule = this->hModules[i];
		wsServices[i] = remoteModuleName;

		wprintf(L"Module: %s\n", wsServices[i].c_str());

		if (!GetModuleBaseName(serviceProcessHandle, serviceModule, remoteModuleName, sizeof(remoteModuleName)))
		{
			printf("GetModuleBaseName failed! %d\n", GetLastError());
		}
	}

	return true;
}

```

`Services.hpp`:

```hpp
#pragma once
#include <iostream>
#include <Windows.h>
#include <Psapi.h>
#include <TlHelp32.h>
#include <dbghelp.h>
#include <winternl.h>
#include <string>

using namespace std;
using myNtQueryInformationThread = NTSTATUS(NTAPI*)(IN HANDLE ThreadHandle, IN THREADINFOCLASS ThreadInformationClass, OUT PVOID ThreadInformation, IN ULONG ThreadInformationLength, OUT PULONG ReturnLength);

class Services
{
public:

	bool GetRunningServices();
	bool GetServiceModules(string ServiceName);
	void StopEventLog();

private:
	wstring wsServices[128];
	HMODULE hModules[256] = {};

};

```

`Shellcodes.asm`:

```asm
.data



.code

;we want to somehow get this function to be inline with native C++ code despite documentation stating it shouldnt be possible.. x86 is of course no problem
;basic design to trick decompilers into thinking the function is something which it isnt. For example, the below will cause 'IDA Free' software to assume it has one argument, and returns the first argument as the only statement. The 'arg_0' will point to undefined/error memory.
InlineMeTest PROC

	push rsp ;push return addr
  sub rsp, 8 ;keep the stack from moving
  
  ;other logic goes here, perhaps call some other function
  
	mov rsp, rsp //junk instruction
	mov rax, [rsp+10h] //jumps back to return address, thus 'returns' the return address and not the 'first argument'.
	jmp rax

InlineMeTest ENDP
;it would be ideal to create some 'function prototype' which includes a templated return value and decompilation corruption

END

```

`SymbolicHash.cpp`:

```cpp
#include "Obfuscation.hpp"

HANDLE SymbolicHash::CreateThread_Hash(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE  lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
	// Resolve CreateThread address by hash
  //thanks to unprotect project
	PDWORD functionAddress = SymbolicHash::getFunctionAddressByHash((char*)"kernel32", 0x00544e304); //this is the hash for createthread, when we call the function it will push the hash then call RDI (pointing to the symbolic func) or some register instead of directly calling the library func

	printf("Got function address: %llx\n", functionAddress);

	// Define CreateThread function prototype as an example
	//it would be nice to find some easier way than a typedef for each winapi, however it might be nice to make some reusable library too with all the function defs.
	using customCreateThread = HANDLE(NTAPI*)(
		LPSECURITY_ATTRIBUTES   lpThreadAttributes,
		SIZE_T                  dwStackSize,
		LPTHREAD_START_ROUTINE  lpStartAddress,
		__drv_aliasesMem LPVOID lpParameter,
		DWORD                   dwCreationFlags,
		LPDWORD                 lpThreadId
		);

	// Point CreateThread function pointer to the CreateThread virtual address resolved by its hash
	customCreateThread myCreateThread = (customCreateThread)functionAddress;
	DWORD tid = 0;

	// Call CreateThread
	HANDLE th = myCreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, &tid);
	return th;
}

DWORD SymbolicHash::getHashFromString(char* string)
{
	size_t stringLength = strnlen_s(string, 50);
	DWORD hash = 0x35;

	for (size_t i = 0; i < stringLength; i++)
	{
		hash += (hash * 0xab10f29f + string[i]) & 0xffffff;
	}

	return hash;
}

PDWORD SymbolicHash::getFunctionAddressByHash(char* library, DWORD hash)
{
	PDWORD functionAddress = (PDWORD)0;

	// Get base address of the module in which our exported function of interest resides (kernel32 in the case of CreateThread)
	HMODULE libraryBase = LoadLibraryA(library);

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase;

	PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader->e_lfanew);

	DWORD_PTR exportDirectoryRVA = imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA);

	PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfFunctions);
	PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfNames);
	PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory->AddressOfNameOrdinals);

	for (DWORD i = 0; i < imageExportDirectory->NumberOfFunctions; i++)
	{
		DWORD functionNameRVA = addressOfNamesRVA[i];
		DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA;
		char* functionName = (char*)functionNameVA;
		DWORD_PTR functionAddressRVA = 0;

		// Calculate hash for this exported function
		DWORD functionNameHash = SymbolicHash::getHashFromString(functionName);

		// If hash for CreateThread is found, resolve the function address
		if (functionNameHash == hash)
		{
			functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]];
			functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA);
			printf("%s : 0x%x : %p\n", functionName, functionNameHash, functionAddress);
			return functionAddress;
		}
	}

	return 0;
}

```

`SymbolicHash.hpp`:

```hpp
#pragma once
#include <iostream>
#include <Windows.h>

/*
this class allows us to call winapi or other library symbolic named funcs without actually referencing the function. if you view the assembly instructions here, you'll get something along 'push 0x554043, call RDI' instead of Call CreateThread or whatever function.
*/
class SymbolicHash
{
public:

	static PDWORD getFunctionAddressByHash(char* library, DWORD hash);
	static DWORD getHashFromString(char* str);

	static HANDLE CreateThread_Hash(LPSECURITY_ATTRIBUTES   lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE  lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

private:

};

```

`Utility.cpp`:

```cpp
#include "Common/Utility.hpp"

```

`Utility.hpp`:

```hpp
#pragma once
#include <stdint.h>
#include <Windows.h>

//pointer utilities -> reading and writing pointers and dereferencing 'safely'
class Utility
{
public:
	
	template<class T>
	static T ReadPointer(uint64_t ulBase, uint64_t ulOffset)
	{
		__try
		{
			return *(T*)(*(uint64_t*)ulBase + ulOffset);
		}
		__except (1) { return (T)NULL; }
	}

	template<class T>
	static bool WritePointer(uint64_t ulBase, uint64_t ulOffset, T iValue)
	{
		__try { *(T*)(*(uint64_t*)ulBase + ulOffset) = iValue; return true; }
		__except (1) { return false; }
	}

	template<class T>
	static T DereferenceSafe(uint64_t ulAddress)
	{
		__try
		{
			return *(T*)ulAddress;
		}
		__except (1) { return (T)NULL; }
	}
};

```

`main.cpp`:

```cpp
// UltimateAnticheat.cpp : This file contains the 'main' function. Program execution begins and ends there. main.cpp contains testing of functionality
// an 'in-development' anti-cheat (anti-tamper + anti-debug + anti-load) for x86, x64, aiming to be eventually be server-sided logic
// Author: Alsch092,  github: alsch092)

#pragma comment(linker, "/ALIGN:0x10000") //for remapping code

#define DLL_PROCESS_DETACH 0
#define DLL_PROCESS_ATTACH 1
#define DLL_THREAD_ATTACH 2
#define DLL_THREAD_DETACH 3

#include "API/API.hpp"

void NTAPI __stdcall TLSCallback(PVOID DllHandle, DWORD dwReason, PVOID Reserved); //in a commercial setting our AC would be in a .dll and the game/process would have the Tls callback
                                                                                   //todo: find way to insert Tls callback into an EXE from a DLL at runtime (modify the directory ptrs to callbacks?)
#ifdef _M_IX86
#pragma comment (linker, "/INCLUDE:__tls_used")
#pragma comment (linker, "/INCLUDE:__tls_callback")
#else
#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:_tls_callback")
#endif
EXTERN_C
#ifdef _M_X64
#pragma const_seg (".CRT$XLB")
const
#else
#pragma data_seg (".CRT$XLB")
#endif

PIMAGE_TLS_CALLBACK _tls_callback = TLSCallback;
#pragma data_seg ()
#pragma const_seg ()

using namespace std;

extern "C" uint64_t shellxor(); //test routine for generating shellcode, can be removed when we are done messing around with shellcode

AntiCheat* g_AC = new AntiCheat(); //global single instance of our AC class

void NTAPI __stdcall TLSCallback(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        printf("New process attached\n");
        break;

    case DLL_THREAD_ATTACH:
        printf("New thread spawned!\n");
        //ExitThread(0); //we can stop DLL injecting + DLL debuggers this way, but make sure you're handling your threads carefully..
        break;

    case DLL_THREAD_DETACH:
        printf("Thread detached!\n");
        break;
    };
}

void TestFunction() //called by our 'rogue'/SymLink CreateThread. WINAPI is not directly called for this!
{
    printf("Hello! this thread was made without calling CreateThread directly!\n");
}

bool TestMemoryIntegrity(AntiCheat* AC)
{
    uint64_t module = (uint64_t)GetModuleHandleW(L"UltimateAnticheat.exe");

    if (!module)
    {
        printf("Failed to get current module! %d\n", GetLastError());
        return false;
    }

    DWORD moduleSize = AC->GetProcessObject()->GetMemorySize();

    AC->GetIntegrityChecker()->SetMemoryHashList(AC->GetIntegrityChecker()->GetMemoryHash((uint64_t)module, 0x1000)); //cache the list of hashes we get from the process .text section

    MessageBoxA(0, "Patch over '.text' section memory here to test integrity checking!", 0, 0);

    if (AC->GetIntegrityChecker()->Check((uint64_t)module, 0x1000, AC->GetIntegrityChecker()->GetMemoryHashList()))
    {
        printf("Hashes match! Program appears genuine! Remember to put this inside a TLS callback (and then make sure TLS callback isn't hooked) to ensure we get hashes before memory is tampered.\n");
    }
    else
    {
        printf("Program is modified!\n");
        return true;
    }

    return false;
}

void TestNetworkHeartbeat()
{
    //normally the server would send this packet to us as a heartbeat. the first packet has no 'added' encryption on it, the ones after it do.
    //the first packet sent has no additional encryption, the ones sent after will be encrypted with the secret key of the last request
    BYTE shellcode[] = { 0x54,0x48,0x81,0xEC,0x80,0x00,0x00,0x00,0x51,0xB0,0x08,0x48,0xC7,0xC1,0x01,0x02,0x03,0x04,0x48,0xC7,0xC2,0x37,0x13,0x00,0x00,0x48,0x33,0xCA,0x48,0x81,0xC2,0x34,0x12,0x00,0x00,0x84,0xC0,0xFE,0xC8,0x75,0xF0,0x48,0x8B,0xC1,0x59,0x48,0x81,0xC4,0x80,0x00,0x00,0x00,0x5C,0xC3 };
    PacketWriter* p = new PacketWriter(Packets::Opcodes::SC_HEARTBEAT, shellcode, sizeof(shellcode)); //write opcode onto packet, then buffer

    if (!g_AC->GetNetworkClient()->UnpackAndExecute(p)) //so that we don't need a server running, just simulate a packet. every heartbeat is encrypted using the hash of the last heartbeat/some server gen'd key to prevent emulation
    {
        PacketWriter* p1 = new PacketWriter(Packets::Opcodes::SC_HEARTBEAT);
        uint64_t hash = g_AC->GetNetworkClient()->GetResponseHashList().back();

        for (int i = 0; i < sizeof(shellcode); i++) //this time we should xor our 'packet' by the last hash to simulate real environment, if we don't then we will get execution error 
        {
            p1->Write<byte>(shellcode[i] ^ (BYTE)hash);
        }

        if (!g_AC->GetNetworkClient()->UnpackAndExecute(p1)) //we call this a 2nd time to demonstrate how encrypting using the last hash works
        {
            printf("secret key gen failed: No server is present?\n");
        }

        delete p1;
    }

    delete p;
}

void TestFunctionalities()
{  
    if (Integrity::IsUnknownDllPresent()) //authenticode DLL verification
    {
        printf("Found unsigned/rogue dll: We only want verified, signed dlls in our application (which is still subject to spoofing)!\n");
    }

    //can we somehow create inline assembly in x64? this might be possible using macros -> make some routine with extra junk instructions/enough space for our asm, write over the junk instructions @ runtime with custom ASM -> should work but is not flexible and doesnt scale well 

    ULONG_PTR ImageBase = (ULONG_PTR)GetModuleHandle(NULL);

    if (!API::Initialize("LICENSE-123456789", L"explorer.exe")) //license server checks for whitelisted IPs to disallow others from hi-jacking service
    {
        printf("Initializing failed!\n");
        //exit(Error::CANT_STARTUP);
    }

    TestNetworkHeartbeat();

    g_AC->GetProcessObject()->SetElevated(Process::IsProcessElevated()); //this checks+sets our variable, it does not set our process to being elevated

    if (!g_AC->GetProcessObject()->GetProgramSections("UltimateAnticheat.exe")) //we can stop a routine like this from working if we patch NumberOfSections to 0
    {
        printf("Failed to parse program sections?\n");
    }

    if (!Process::CheckParentProcess(g_AC->GetProcessObject()->GetParentName())) //parent process check, the parent process would normally be set using our API methods
    {
        printf("Parent process was not explorer.exe! hekker detected!\n"); //sometimes people will launch a game from their own process, which we can easily detect if they haven't spoofed it
    }

    TestMemoryIntegrity(g_AC);

    SymbolicHash::CreateThread_Hash(0, 0, (LPTHREAD_START_ROUTINE)&TestFunction, 0, 0, 0); //shows how we can call CreateThread without directly calling winapi, we call our pointer instead which then invokes createthread

    g_AC->GetAntiDebugger()->StartAntiDebugThread();

    std::wstring newModuleName = L"new_name";

    if (Process::ChangeModuleName((wchar_t*)L"UltimateAnticheat.exe", (wchar_t*)newModuleName.c_str()))
    {
        wprintf(L"Changed module name to %s!\n", newModuleName.c_str());
    }

    if (g_AC->GetAntiDebugger()->_IsHardwareDebuggerPresent())
    {
        printf("Found hardware debugger!\n");
    }

    if (AntiCheat::IsVTableHijacked((void*)g_AC))
    {
        printf("VTable of Anticheat has been compromised/hooked.\n");
    }

    if (!g_AC->GetProcessObject()->ProtectProcess()) //todo: find way to stop process attaching or OpenProcess
    {
        printf("Could not protect process.\n");
    }
   
    if (ImageBase)
    {
        if (!RmpRemapImage(ImageBase)) //re-mapping of image to stop patching, and of course we can easily detect if someone bypasses this
        {
            printf("RmpRemapImage failed.\n");
        }
        else
        {
            //check page protections, if they're writable then some cheater has re-mapped our image to make it write-friendly and we need to ban them!
            MEMORY_BASIC_INFORMATION mbi = {};
            
            if (VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ImageBase, &mbi, sizeof(mbi)))
            {
                if (mbi.AllocationProtect != PAGE_READONLY && mbi.State == MEM_COMMIT && mbi.Type == MEM_MAPPED)
                {
                    printf("Cheater! Change back the protections NOW!\n");
                }
            }
        }
    }
    else
    {
        printf("Imagebase was NULL!\n");
    }

    delete g_AC->GetAntiDebugger();
    delete g_AC->GetProcessObject();
    delete g_AC->GetIntegrityChecker();
    delete g_AC;
}

int main(int argc, char** argv)
{
    //  _MessageBox();
    TestFunctionalities();
    return 0;
}

```

`ntdll.h`:

```h
#pragma once
#pragma once

#include <Windows.h>

#ifndef _NTDEF_
typedef _Return_type_success_(return >= 0) LONG NTSTATUS;
#endif


#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#define STATUS_INVALID_PAGE_PROTECTION   ((NTSTATUS)0xC0000045L)
#define STATUS_PROCEDURE_NOT_FOUND       ((NTSTATUS)0xC000007AL)

#define SEC_NO_CHANGE 0x00400000

#define PAGE_SIZE 0x1000
#define POINTER_IS_ALIGNED(Pointer, Alignment) \
    (((((ULONG_PTR)(Pointer)) & (((Alignment)-1))) == 0) ? TRUE : FALSE)

#define NtCurrentProcess()  ((HANDLE)(LONG_PTR)-1)


typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation
} MEMORY_INFORMATION_CLASS, * PMEMORY_INFORMATION_CLASS;


EXTERN_C
NTSTATUS
NTAPI
NtCreateSection(
    _Out_    PHANDLE            SectionHandle,
    _In_     ACCESS_MASK        DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER     MaximumSize,
    _In_     ULONG              SectionPageProtection,
    _In_     ULONG              AllocationAttributes,
    _In_opt_ HANDLE             FileHandle
);

EXTERN_C
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_        HANDLE          SectionHandle,
    _In_        HANDLE          ProcessHandle,
    _Inout_     PVOID * BaseAddress,
    _In_        ULONG_PTR       ZeroBits,
    _In_        SIZE_T          CommitSize,
    _Inout_opt_ PLARGE_INTEGER  SectionOffset,
    _Inout_     PSIZE_T         ViewSize,
    _In_        SECTION_INHERIT InheritDisposition,
    _In_        ULONG           AllocationType,
    _In_        ULONG           Win32Protect
);

EXTERN_C
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_        HANDLE  ProcessHandle,
    _In_opt_    PVOID   BaseAddress
);

EXTERN_C
NTSTATUS
NTAPI
NtClose(
    _In_ HANDLE Handle
);

EXTERN_C
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID BaseAddress
);

```