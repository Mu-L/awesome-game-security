Project Path: arc_gmh5225_Driver-RPM-DirectPageManipulation_50zd361x

Source Tree:

```txt
arc_gmh5225_Driver-RPM-DirectPageManipulation_50zd361x
├── DPM
│   ├── DPM
│   │   ├── DPM.vcxproj
│   │   ├── DPM.vcxproj.filters
│   │   ├── Defines.h
│   │   ├── General.h
│   │   ├── Main.cpp
│   │   ├── Memory.cpp
│   │   ├── Memory.h
│   │   ├── Utils.cpp
│   │   └── Utils.h
│   └── DPM.sln
├── README.md
└── screenshot.png

```

`DPM/DPM.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33723.286
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DPM", "DPM\DPM.vcxproj", "{25955396-5A81-4B4E-8550-F3EA49E8D0B5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{25955396-5A81-4B4E-8550-F3EA49E8D0B5}.Release|x64.ActiveCfg = Release|x64
		{25955396-5A81-4B4E-8550-F3EA49E8D0B5}.Release|x64.Build.0 = Release|x64
		{25955396-5A81-4B4E-8550-F3EA49E8D0B5}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D47DD7FF-FFCC-4E6B-910D-1C87D70402D0}
	EndGlobalSection
EndGlobal

```

`DPM/DPM/DPM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{25955396-5A81-4B4E-8550-F3EA49E8D0B5}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>DPM</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Defines.h" />
    <ClInclude Include="General.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DPM/DPM/DPM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="General.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Defines.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DPM/DPM/Defines.h`:

```h
#pragma once

#define PFN_TO_PAGE(pfn) (pfn << PAGE_SHIFT)
#define PAGE_TO_PFN(pfn) (pfn >> PAGE_SHIFT)

#pragma warning(push)
#pragma warning(disable : 4201) // nonstandard extension used: nameless struct/union

#pragma pack(push, 1)
typedef union CR3_
{
	ULONG64 Value;
	struct
	{
		ULONG64 Ignored1 : 3;
		ULONG64 WriteThrough : 1;
		ULONG64 CacheDisable : 1;
		ULONG64 Ignored2 : 7;
		ULONG64 Pml4 : 40;
		ULONG64 Reserved : 12;
	};
} PTE_CR3;

typedef union VIRT_ADDR_
{
	ULONG64 Value;
	void* Pointer;
	struct
	{
		ULONG64 Offset : 12;
		ULONG64 PtIndex : 9;
		ULONG64 PdIndex : 9;
		ULONG64 PdptIndex : 9;
		ULONG64 Pml4Index : 9;
		ULONG64 Reserved : 16;
	};
} VIRTUAL_ADDRESS;

typedef union PML4E_
{
	ULONG64 Value;
	struct
	{
		ULONG64 Present : 1;
		ULONG64 Rw : 1;
		ULONG64 User : 1;
		ULONG64 WriteThrough : 1;
		ULONG64 CacheDisable : 1;
		ULONG64 Accessed : 1;
		ULONG64 Ignored1 : 1;
		ULONG64 Reserved1 : 1;
		ULONG64 Ignored2 : 4;
		ULONG64 Pdpt : 40;
		ULONG64 Ignored3 : 11;
		ULONG64 Xd : 1;
	};
} PML4E;

typedef union PDPTE_
{
	ULONG64 Value;
	struct
	{
		ULONG64 Present : 1;
		ULONG64 Rw : 1;
		ULONG64 User : 1;
		ULONG64 WriteThrough : 1;
		ULONG64 CacheDisable : 1;
		ULONG64 Accessed : 1;
		ULONG64 Dirty : 1;
		ULONG64 PageSize : 1;
		ULONG64 Ignored2 : 4;
		ULONG64 Pd : 40;
		ULONG64 Ignored3 : 11;
		ULONG64 Xd : 1;
	};
} PDPTE;

typedef union PDE_
{
	ULONG64 Value;
	struct
	{
		ULONG64 Present : 1;
		ULONG64 Rw : 1;
		ULONG64 User : 1;
		ULONG64 WriteThrough : 1;
		ULONG64 CacheDisable : 1;
		ULONG64 Accessed : 1;
		ULONG64 Dirty : 1;
		ULONG64 PageSize : 1;
		ULONG64 Ignored2 : 4;
		ULONG64 Pt : 40;
		ULONG64 Ignored3 : 11;
		ULONG64 Xd : 1;
	};
} PDE;

typedef union PTE_
{
	ULONG64 Value;
	VIRTUAL_ADDRESS VirtualAddress;
	struct
	{
		ULONG64 Present : 1;
		ULONG64 Rw : 1;
		ULONG64 User : 1;
		ULONG64 WriteThrough : 1;
		ULONG64 CacheDisable : 1;
		ULONG64 Accessed : 1;
		ULONG64 Dirty : 1;
		ULONG64 Pat : 1;
		ULONG64 Global : 1;
		ULONG64 Ignored1 : 3;
		ULONG64 PageFrame : 40;
		ULONG64 Ignored3 : 11;
		ULONG64 Xd : 1;
	};
} PTE;
#pragma pack(pop)

#pragma warning(pop)

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _POOL_TRACKER_BIG_PAGES
{
	volatile ULONGLONG Va;
	ULONG Key;
	ULONG Pattern : 8;
	ULONG PoolType : 12;
	ULONG SlushSize : 12;
	ULONGLONG NumberOfBytes;
} POOL_TRACKER_BIG_PAGES, * PPOOL_TRACKER_BIG_PAGES;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

EXTERN_C NTKERNELAPI PPEB PsGetProcessPeb(PEPROCESS process);

#define Log(x, ...) DbgPrintEx(0, 0, "[DPM] " x "\n", __VA_ARGS__)
```

`DPM/DPM/General.h`:

```h
#pragma once

#include <ntifs.h>
#include <intrin.h>
#include <ntimage.h>
#include <minwindef.h>

#include "Defines.h"
#include "Memory.h"
#include "Utils.h"
```

`DPM/DPM/Main.cpp`:

```cpp
#include "General.h"

#define OFFSET_ActiveProcessLinks 0x448
PEPROCESS FindProcess(const wchar_t* executableName, PVOID* mainModuleBaseAddress)
{
	PEPROCESS currentProcess = IoGetCurrentProcess();
	PLIST_ENTRY list = reinterpret_cast<PLIST_ENTRY>(reinterpret_cast<PCHAR>(currentProcess) + OFFSET_ActiveProcessLinks);

	for (; list->Flink != reinterpret_cast<PLIST_ENTRY>(reinterpret_cast<PCHAR>(currentProcess) + OFFSET_ActiveProcessLinks); list = list->Flink)
	{
		PEPROCESS targetProcess = reinterpret_cast<PEPROCESS>(reinterpret_cast<PCHAR>(list->Flink) - OFFSET_ActiveProcessLinks);
		PPEB pebAddress = PsGetProcessPeb(targetProcess);
		if (!pebAddress)
			continue;

		PEB pebLocal = { 0 };
		Memory::CopyProcessMemory(targetProcess, pebAddress, currentProcess, &pebLocal, sizeof(PEB));

		PEB_LDR_DATA loaderData = { 0 };
		Memory::CopyProcessMemory(targetProcess, pebLocal.Ldr, currentProcess, &loaderData, sizeof(PEB_LDR_DATA));

		PLIST_ENTRY currentListEntry = loaderData.InMemoryOrderModuleList.Flink;
		while (true)
		{
			LIST_ENTRY listEntryLocal = { 0 };
			Memory::CopyProcessMemory(targetProcess, currentListEntry, currentProcess, &listEntryLocal, sizeof(LIST_ENTRY));
			if (loaderData.InMemoryOrderModuleList.Flink == listEntryLocal.Flink || !listEntryLocal.Flink)
				break;

			PLDR_DATA_TABLE_ENTRY entryAddress = CONTAINING_RECORD(currentListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

			LDR_DATA_TABLE_ENTRY entryLocal = { 0 };
			Memory::CopyProcessMemory(targetProcess, entryAddress, currentProcess, &entryLocal, sizeof(LDR_DATA_TABLE_ENTRY));

			UNICODE_STRING modulePathStr = { 0 };
			wchar_t moduleName[256];
			Memory::CopyProcessMemory(targetProcess, entryLocal.BaseDllName.Buffer, currentProcess, moduleName, min(entryLocal.BaseDllName.Length, 256));

			modulePathStr.Buffer = moduleName;
			modulePathStr.Length = min(entryLocal.BaseDllName.Length, 256);
			modulePathStr.MaximumLength = min(entryLocal.BaseDllName.MaximumLength, 256);

			UNICODE_STRING moduleNameStr = { 0 };
			RtlInitUnicodeString(&moduleNameStr, executableName);

			LONG compare = RtlCompareUnicodeString(&modulePathStr, &moduleNameStr, TRUE);
			if (compare == 0)
			{
				*mainModuleBaseAddress = entryLocal.DllBase;
				return targetProcess;
			}

			currentListEntry = listEntryLocal.Flink;
		}
	}

	return nullptr;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT driverObject, PUNICODE_STRING registryPath)
{
	UNREFERENCED_PARAMETER(driverObject);
	UNREFERENCED_PARAMETER(registryPath);

	Log("Entry called from 0x%p in context of process with PID %u", _ReturnAddress(), PsGetCurrentProcessId());

	NTSTATUS status = Memory::Init();
	if (!NT_SUCCESS(status))
		return status;

	PVOID moduleBase = NULL;
	PEPROCESS targetProcess = FindProcess(L"ProcessHacker.exe", &moduleBase);
	if (!targetProcess || !moduleBase)
		return STATUS_NOT_FOUND;

	HANDLE processId = PsGetProcessId(targetProcess);
	Log("ProcessHacker.exe has PID of %u with base at 0x%p", processId, moduleBase);

	ULONG64 header = 0;
	Memory::CopyProcessMemory(targetProcess, moduleBase, IoGetCurrentProcess(), &header, sizeof(ULONG64));

	Log("Main module header value is 0x%p", header);

	return STATUS_SUCCESS;
}
```

`DPM/DPM/Memory.cpp`:

```cpp
#include "General.h"

#pragma warning(disable : 4996) // ExAllocatePool is deprecated

NTSTATUS Memory::Init()
{
	PHYSICAL_ADDRESS maxAddress;
	maxAddress.QuadPart = MAXULONG64;

	MainVirtualAddress = MmAllocateContiguousMemory(PAGE_SIZE, maxAddress);
	if (!MainVirtualAddress)
		return STATUS_INSUFFICIENT_RESOURCES;

	VIRTUAL_ADDRESS virtualAddress;
	virtualAddress.Pointer = MainVirtualAddress;

	PTE_CR3 cr3;
	cr3.Value = __readcr3();

	PML4E* pml4 = static_cast<PML4E*>(Utils::PhysicalToVirtual(PFN_TO_PAGE(cr3.Pml4)));
	PML4E* pml4e = (pml4 + virtualAddress.Pml4Index);
	if (!pml4e->Present)
		return STATUS_NOT_FOUND;

	PDPTE* pdpt = static_cast<PDPTE*>(Utils::PhysicalToVirtual(PFN_TO_PAGE(pml4e->Pdpt)));
	PDPTE* pdpte = pdpte = (pdpt + virtualAddress.PdptIndex);
	if (!pdpte->Present)
		return STATUS_NOT_FOUND;

	// sanity check 1GB page
	if (pdpte->PageSize)
		return STATUS_INVALID_PARAMETER;

	PDE* pd = static_cast<PDE*>(Utils::PhysicalToVirtual(PFN_TO_PAGE(pdpte->Pd)));
	PDE* pde = pde = (pd + virtualAddress.PdIndex);
	if (!pde->Present)
		return STATUS_NOT_FOUND;

	// sanity check 2MB page
	if (pde->PageSize)
		return STATUS_INVALID_PARAMETER;

	PTE* pt = static_cast<PTE*>(Utils::PhysicalToVirtual(PFN_TO_PAGE(pde->Pt)));
	PTE* pte = (pt + virtualAddress.PtIndex);
	if (!pte->Present)
		return STATUS_NOT_FOUND;

	MainPageEntry = pte;

	return STATUS_SUCCESS;
}

PVOID Memory::OverwritePage(ULONG64 physicalAddress)
{
	// page boundary checks are done by Read/WriteProcessMemory
	// and page entries are not spread over different pages
	ULONG pageOffset = physicalAddress % PAGE_SIZE;
	ULONG64 pageStartPhysical = physicalAddress - pageOffset;
	MainPageEntry->PageFrame = PAGE_TO_PFN(pageStartPhysical);
	__invlpg(MainVirtualAddress);
	return (PVOID)((ULONG64)MainVirtualAddress + pageOffset);
}

NTSTATUS Memory::ReadPhysicalAddress(ULONG64 targetAddress, PVOID buffer, SIZE_T size)
{
	PVOID virtualAddress = OverwritePage(targetAddress);
	memcpy(buffer, virtualAddress, size);
	return STATUS_SUCCESS;
}

NTSTATUS Memory::WritePhysicalAddress(ULONG64 targetAddress, PVOID buffer, SIZE_T size)
{
	PVOID virtualAddress = OverwritePage(targetAddress);
	memcpy(virtualAddress, buffer, size);
	return STATUS_SUCCESS;
}

#define PAGE_OFFSET_SIZE 12
static const ULONG64 PMASK = (~0xfull << 8) & 0xfffffffffull;
ULONG64 Memory::TranslateLinearAddress(ULONG64 directoryTableBase, ULONG64 virtualAddress)
{
	directoryTableBase &= ~0xf;

	ULONG64 pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
	ULONG64 pte = ((virtualAddress >> 12) & (0x1ffll));
	ULONG64 pt = ((virtualAddress >> 21) & (0x1ffll));
	ULONG64 pd = ((virtualAddress >> 30) & (0x1ffll));
	ULONG64 pdp = ((virtualAddress >> 39) & (0x1ffll));

	ULONG64 pdpe = 0;
	ReadPhysicalAddress(directoryTableBase + 8 * pdp, &pdpe, sizeof(pdpe));
	if (~pdpe & 1)
		return 0;

	ULONG64 pde = 0;
	ReadPhysicalAddress((pdpe & PMASK) + 8 * pd, &pde, sizeof(pde));
	if (~pde & 1)
		return 0;

	// 1GB large page, use pde's 12-34 bits
	if (pde & 0x80)
		return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

	ULONG64 pteAddr = 0;
	ReadPhysicalAddress((pde & PMASK) + 8 * pt, &pteAddr, sizeof(pteAddr));
	if (~pteAddr & 1)
		return 0;

	// 2MB large page
	if (pteAddr & 0x80)
		return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

	virtualAddress = 0;
	ReadPhysicalAddress((pteAddr & PMASK) + 8 * pte, &virtualAddress, sizeof(virtualAddress));
	virtualAddress &= PMASK;

	if (!virtualAddress)
		return 0;

	return virtualAddress + pageOffset;
}

ULONG64 Memory::GetProcessDirectoryBase(PEPROCESS inputProcess)
{
	UCHAR* process = reinterpret_cast<UCHAR*>(inputProcess);
	ULONG64 dirbase = *reinterpret_cast<ULONG64*>(process + 0x28);
	if (!dirbase)
	{
		ULONG64 userDirbase = *reinterpret_cast<ULONG64*>(process + 0x388);
		return userDirbase;
	}
	return dirbase;
}

NTSTATUS Memory::ReadProcessMemory(PEPROCESS process, ULONG64 address, PVOID buffer, SIZE_T size)
{
	if (!address)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = STATUS_UNSUCCESSFUL;
	ULONG64 processDirbase = GetProcessDirectoryBase(process);
	SIZE_T currentOffset = 0;
	SIZE_T totalSize = size;
	while (totalSize)
	{
		ULONG64 currentPhysicalAddress = TranslateLinearAddress(processDirbase, address + currentOffset);
		if (!currentPhysicalAddress)
			return STATUS_NOT_FOUND;

		ULONG64 readSize = min(PAGE_SIZE - (currentPhysicalAddress & 0xFFF), totalSize);

		status = ReadPhysicalAddress(currentPhysicalAddress, reinterpret_cast<PVOID>(reinterpret_cast<ULONG64>(buffer) + currentOffset), readSize);

		totalSize -= readSize;
		currentOffset += readSize;

		if (!NT_SUCCESS(status))
			break;

		if (!readSize)
			break;
	}

	return status;
}

NTSTATUS Memory::WriteProcessMemory(PEPROCESS process, ULONG64 address, PVOID buffer, SIZE_T size)
{
	if (!address)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = STATUS_UNSUCCESSFUL;
	ULONG64 processDirbase = GetProcessDirectoryBase(process);
	SIZE_T currentOffset = 0;
	SIZE_T totalSize = size;
	while (totalSize)
	{
		ULONG64 currentPhysicalAddress = TranslateLinearAddress(processDirbase, address + currentOffset);
		if (!currentPhysicalAddress)
			return STATUS_NOT_FOUND;

		ULONG64 writeSize = min(PAGE_SIZE - (currentPhysicalAddress & 0xFFF), totalSize);

		status = WritePhysicalAddress(currentPhysicalAddress, reinterpret_cast<PVOID>(reinterpret_cast<ULONG64>(buffer) + currentOffset), writeSize);

		totalSize -= writeSize;
		currentOffset += writeSize;

		if (!NT_SUCCESS(status))
			break;

		if (!writeSize)
			break;
	}

	return status;
}

NTSTATUS Memory::CopyProcessMemory(PEPROCESS sourceProcess, PVOID sourceAddress, PEPROCESS targetProcess, PVOID targetAddress, SIZE_T bufferSize)
{
	PVOID temporaryBuffer = ExAllocatePool(NonPagedPoolNx, bufferSize);
	if (!temporaryBuffer)
		return STATUS_INSUFFICIENT_RESOURCES;

	NTSTATUS status = ReadProcessMemory(sourceProcess, reinterpret_cast<ULONG64>(sourceAddress), temporaryBuffer, bufferSize);
	if (!NT_SUCCESS(status))
		goto Exit;

	status = WriteProcessMemory(targetProcess, reinterpret_cast<ULONG64>(targetAddress), temporaryBuffer, bufferSize);

Exit:
	ExFreePool(temporaryBuffer);
	return status;
}
```

`DPM/DPM/Memory.h`:

```h
#pragma once

namespace Memory
{
	inline PVOID MainVirtualAddress;
	inline PTE* MainPageEntry;

	NTSTATUS Init();
	PVOID OverwritePage(ULONG64 physicalAddress);
	NTSTATUS ReadPhysicalAddress(ULONG64 targetAddress, PVOID buffer, SIZE_T size);
	NTSTATUS WritePhysicalAddress(ULONG64 targetAddress, PVOID buffer, SIZE_T size);
	ULONG64 TranslateLinearAddress(ULONG64 directoryTableBase, ULONG64 virtualAddress);
	ULONG64 GetProcessDirectoryBase(PEPROCESS inputProcess);
	NTSTATUS ReadProcessMemory(PEPROCESS process, ULONG64 address, PVOID buffer, SIZE_T size);
	NTSTATUS WriteProcessMemory(PEPROCESS process, ULONG64 address, PVOID buffer, SIZE_T size);
	NTSTATUS CopyProcessMemory(PEPROCESS sourceProcess, PVOID sourceAddress, PEPROCESS targetProcess, PVOID targetAddress, SIZE_T bufferSize);
}

```

`DPM/DPM/Utils.cpp`:

```cpp
#include "General.h"

PVOID Utils::PhysicalToVirtual(ULONG64 address)
{
	PHYSICAL_ADDRESS physical;
	physical.QuadPart = address;
	return MmGetVirtualForPhysical(physical);
}
```

`DPM/DPM/Utils.h`:

```h
#pragma once

namespace Utils
{
	PVOID PhysicalToVirtual(ULONG64 address);
}
```

`README.md`:

```md
# Direct Page Manipulation (DPM)
This is a bare minimum example project that demonstrates how to overwrite paging structures directly to read/write into physical memory, and how to use this for interprocess memory copying. This project doesn't take into account paged-out memory and, more importantly, multithreading, in order to keep it as simple to understand as possible.

![screenshot](screenshot.png)

Some functions are rightfully stolen from [here](https://www.unknowncheats.me/forum/anti-cheat-bypass/444289-read-process-physical-memory-attach.html).
```