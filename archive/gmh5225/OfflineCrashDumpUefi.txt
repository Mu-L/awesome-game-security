Project Path: arc_gmh5225_OfflineCrashDumpUefi_wr4o2wpy

Source Tree:

```txt
arc_gmh5225_OfflineCrashDumpUefi_wr4o2wpy
├── CODE_OF_CONDUCT.md
├── LICENSE
├── OfflineDumpPkg
│   ├── Application
│   │   ├── OfflineDumpBench.c
│   │   ├── OfflineDumpBench.inf
│   │   ├── OfflineDumpSampleApp.c
│   │   ├── OfflineDumpSampleApp.inf
│   │   ├── OfflineDumpWrite.c
│   │   └── OfflineDumpWrite.inf
│   ├── Include
│   │   ├── Guid
│   │   │   ├── OfflineDumpConfig.h
│   │   │   ├── OfflineDumpCpuContext.h
│   │   │   ├── OfflineDumpEncryption.h
│   │   │   └── OfflineDumpHeaders.h
│   │   ├── Library
│   │   │   ├── OfflineDumpLib.h
│   │   │   └── OfflineDumpWriterLib.h
│   │   └── Protocol
│   │       └── OfflineDumpProvider.h
│   ├── Library
│   │   ├── OfflineDumpLib
│   │   │   ├── Execute.c
│   │   │   ├── OfflineDumpLib.inf
│   │   │   ├── Partition.c
│   │   │   ├── RedactionScratchBufferLength.c
│   │   │   └── Variables.c
│   │   └── OfflineDumpWriterLib
│   │       ├── AARCH64-GCC
│   │       │   └── aesv8-armx.S
│   │       ├── Collect.c
│   │       ├── Encryptor.c
│   │       ├── OfflineDumpWriterLib.inf
│   │       ├── RedactionMap.c
│   │       ├── Writer.c
│   │       └── X64-MSFT
│   │           └── aesni-x86_64.nasm
│   ├── OfflineDumpPkg.dec
│   ├── OfflineDumpPkg.dsc
│   ├── Private
│   │   ├── Library
│   │   │   ├── OfflineDumpEncryptor.h
│   │   │   ├── OfflineDumpRedactionMap.h
│   │   │   ├── OfflineDumpRedactionMapInternal.h
│   │   │   ├── OfflineDumpVariables.h
│   │   │   └── OfflineDumpWriter.h
│   │   ├── Readme.md
│   │   ├── arpa
│   │   │   ├── inet.h
│   │   │   └── nameser.h
│   │   ├── assert.h
│   │   ├── ctype.h
│   │   ├── errno.h
│   │   ├── fcntl.h
│   │   ├── inttypes.h
│   │   ├── limits.h
│   │   ├── memory.h
│   │   ├── netinet
│   │   │   └── in.h
│   │   ├── openssl
│   │   │   ├── add_OpensslGen.bat
│   │   │   ├── add_openssl.bat
│   │   │   ├── aes.h
│   │   │   ├── asn1.h
│   │   │   ├── asn1err.h
│   │   │   ├── bio.h
│   │   │   ├── bioerr.h
│   │   │   ├── bn.h
│   │   │   ├── bnerr.h
│   │   │   ├── buffer.h
│   │   │   ├── buffererr.h
│   │   │   ├── cms.h
│   │   │   ├── conf.h
│   │   │   ├── conferr.h
│   │   │   ├── configuration.h
│   │   │   ├── conftypes.h
│   │   │   ├── core.h
│   │   │   ├── core_dispatch.h
│   │   │   ├── crypto.h
│   │   │   ├── cryptoerr.h
│   │   │   ├── cryptoerr_legacy.h
│   │   │   ├── e_os2.h
│   │   │   ├── ec.h
│   │   │   ├── ecerr.h
│   │   │   ├── evp.h
│   │   │   ├── evperr.h
│   │   │   ├── http.h
│   │   │   ├── indicator.h
│   │   │   ├── lhash.h
│   │   │   ├── macros.h
│   │   │   ├── obj_mac.h
│   │   │   ├── objects.h
│   │   │   ├── objectserr.h
│   │   │   ├── opensslconf.h
│   │   │   ├── opensslv.h
│   │   │   ├── params.h
│   │   │   ├── pkcs7.h
│   │   │   ├── pkcs7err.h
│   │   │   ├── safestack.h
│   │   │   ├── sha.h
│   │   │   ├── stack.h
│   │   │   ├── symhacks.h
│   │   │   ├── types.h
│   │   │   ├── x509.h
│   │   │   ├── x509_vfy.h
│   │   │   └── x509err.h
│   │   ├── stdarg.h
│   │   ├── stddef.h
│   │   ├── stdint.h
│   │   ├── stdio.h
│   │   ├── stdlib.h
│   │   ├── string.h
│   │   ├── strings.h
│   │   ├── stubs-32.h
│   │   ├── sys
│   │   │   ├── param.h
│   │   │   ├── shm.h
│   │   │   ├── socket.h
│   │   │   ├── syscall.h
│   │   │   ├── time.h
│   │   │   ├── types.h
│   │   │   └── utsname.h
│   │   ├── syslog.h
│   │   ├── time.h
│   │   └── unistd.h
│   ├── Test
│   │   ├── OfflineDumpTest.cpp
│   │   ├── OfflineDumpTest.h
│   │   ├── OfflineDumpTest.inf
│   │   ├── RedactionScratchBufferLengthTest.cpp
│   │   └── SparseBitmapTest.cpp
│   ├── dumpvars.nsh
│   ├── sample_keys.cer
│   ├── sample_keys.pfx
│   └── sample_keys.txt
├── README.md
├── SECURITY.md
├── SUPPORT.md
├── edk2
├── get-iasl.cmd
├── get-nasm.cmd
├── usetup.sh
└── wsetup.cmd

```

`CODE_OF_CONDUCT.md`:

```md
# Microsoft Open Source Code of Conduct

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).

Resources:

- [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/)
- [Microsoft Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)
- Contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with questions or concerns

```

`LICENSE`:

```
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE

```

`OfflineDumpPkg/Application/OfflineDumpBench.c`:

```c
#include <OfflineDumpLib.h>
#include <Library/OfflineDumpWriter.h>

#include <Uefi.h>
#include <Protocol/ShellParameters.h>
#include <Protocol/Smbios.h>

#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/TimerLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiLib.h>

#ifdef __INTELLISENSE__
#define PcdGetBool(x)  TRUE
#endif

// For use in printf format values.
typedef long long unsigned llu_t;

static void
GetLargestConventionalRegion (
  OUT UINT8 const  **ppPhysicalBase,
  OUT UINTN        *pSize
  )
{
  EFI_PHYSICAL_ADDRESS  LargestPhysicalStart = 0;
  UINT64                LargestNumberOfPages = 0;

  EFI_STATUS             Status;
  UINTN                  MemoryMapSize = 0;
  EFI_MEMORY_DESCRIPTOR  *MemoryMap    = NULL;
  UINTN                  MapKey;
  UINTN                  DescriptorSize;
  UINT32                 DescriptorVersion;

  Status = gBS->GetMemoryMap (&MemoryMapSize, MemoryMap, &MapKey, &DescriptorSize, &DescriptorVersion);
  if (Status != EFI_BUFFER_TOO_SMALL) {
    Print (L"GetMemoryMap() failed (%r)\n", Status);
    return;
  }

  MemoryMap = AllocatePool (MemoryMapSize);
  if (MemoryMap == NULL) {
    Print (L"AllocatePool(MemoryMapSize = %u) failed\n", MemoryMapSize);
    return;
  }

  Status = gBS->GetMemoryMap (&MemoryMapSize, MemoryMap, &MapKey, &DescriptorSize, &DescriptorVersion);
  if (EFI_ERROR (Status)) {
    Print (L"GetMemoryMap() failed (%r)\n", Status);
    FreePool (MemoryMap);
    return;
  }

  for (EFI_MEMORY_DESCRIPTOR *Desc = MemoryMap; (UINT8 *)Desc < (UINT8 *)MemoryMap + MemoryMapSize; Desc = (EFI_MEMORY_DESCRIPTOR *)((UINT8 *)Desc + DescriptorSize)) {
    if (Desc->Type != EfiConventionalMemory) {
      continue;
    }

    if (Desc->NumberOfPages > LargestNumberOfPages) {
      LargestPhysicalStart = Desc->PhysicalStart;
      LargestNumberOfPages = Desc->NumberOfPages;
    }
  }

  if (LargestNumberOfPages > MAX_UINTN / EFI_PAGE_SIZE) {
    LargestNumberOfPages = MAX_UINTN / EFI_PAGE_SIZE;
  }

  FreePool (MemoryMap);

  *ppPhysicalBase = (UINT8 const *)(UINTN)LargestPhysicalStart;
  *pSize          = (UINTN)LargestNumberOfPages * EFI_PAGE_SIZE;
}

static UINT64
StrToUint64 (
  IN CHAR8 const   *pArgName,
  IN CHAR16 const  *pStr,
  IN OUT BOOLEAN   *pAllOk
  )
{
  UINT64  Value = 0;

  if ((pStr[0] == L'0') &&
      ((pStr[1] == L'x') || (pStr[1] == L'X')))
  {
    for (UINTN Digits = 0; pStr[Digits + 2]; Digits += 1) {
      CHAR16  Digit = pStr[Digits + 2];
      UINT8   DigitValue;
      if ((Digit >= L'0') && (Digit <= L'9')) {
        DigitValue = (UINT8)(Digit - L'0');
      } else if ((Digit >= L'A') && (Digit <= L'F')) {
        DigitValue = (UINT8)(Digit - L'A' + 10);
      } else if ((Digit >= L'a') && (Digit <= L'f')) {
        DigitValue = (UINT8)(Digit - L'a' + 10);
      } else {
        Print (L"Invalid hex integer for <%a>: %s\n", pArgName, pStr);
        *pAllOk = FALSE;
        return 0;
      }

      if (Value > (MAX_UINT64 - DigitValue) / 16) {
        Print (L"Hex integer for <%a> overflows: %s\n", pArgName, pStr);
        *pAllOk = FALSE;
        return 0;
      }

      Value = Value * 16 + DigitValue;
    }
  } else {
    for (UINTN Digits = 0; pStr[Digits]; Digits += 1) {
      CHAR16  Digit = pStr[Digits];
      UINT8   DigitValue;
      if ((Digit >= L'0') && (Digit <= L'9')) {
        DigitValue = (UINT8)(Digit - L'0');
      } else {
        Print (L"Invalid decimal integer for <%a>: %s\n", pArgName, pStr);
        *pAllOk = FALSE;
        return 0;
      }

      if (Value > (MAX_UINT64 - DigitValue) / 10) {
        Print (L"Decimal integer for <%a> overflows: %s\n", pArgName, pStr);
        *pAllOk = FALSE;
        return 0;
      }

      Value = Value * 10 + DigitValue;
    }
  }

  return Value;
}

static BOOLEAN
StrToBool (
  IN CHAR8 const   *pArgName,
  IN CHAR16 const  *pStr,
  IN OUT BOOLEAN   *pAllOk
  )
{
  UINT64  Value = StrToUint64 (pArgName, pStr, pAllOk);

  if (Value > 1) {
    Print (L"Invalid boolean for <%a>: %s\n", pArgName, pStr);
    *pAllOk = FALSE;
    return FALSE;
  }

  return Value != 0;
}

static UINT8
StrToUint8 (
  IN CHAR8 const   *pArgName,
  IN CHAR16 const  *pStr,
  IN OUT BOOLEAN   *pAllOk
  )
{
  UINT64  Value = StrToUint64 (pArgName, pStr, pAllOk);

  if (Value > MAX_UINT8) {
    Print (L"Invalid UINT8 for <%a>: %s\n", pArgName, pStr);
    *pAllOk = FALSE;
    return FALSE;
  }

  return (UINT8)Value;
}

static UINT32
StrToUint32 (
  IN CHAR8 const   *pArgName,
  IN CHAR16 const  *pStr,
  IN OUT BOOLEAN   *pAllOk
  )
{
  UINT64  Value = StrToUint64 (pArgName, pStr, pAllOk);

  if (Value > MAX_UINT32) {
    Print (L"Invalid UINT32 for <%a>: %s\n", pArgName, pStr);
    *pAllOk = FALSE;
    return FALSE;
  }

  return (UINT32)Value;
}

static void
PrintPerformanceCounterProperties (
  void
  )
{
  UINT64  StartValue, EndValue;
  UINT64  Frequency = GetPerformanceCounterProperties (&StartValue, &EndValue);

  Print (
         L"Timestamp info: Freq=%llu Start=0x%llX End=0x%llX\n",
         (llu_t)Frequency,
         (llu_t)StartValue,
         (llu_t)EndValue
         );
}

static void
PrintCpuInfo (
  void
  )
{
  EFI_STATUS           Status;
  EFI_SMBIOS_PROTOCOL  *pSmbiosProtocol;

  Status = gBS->LocateProtocol (&gEfiSmbiosProtocolGuid, NULL, (void **)&pSmbiosProtocol);
  if (!EFI_ERROR (Status)) {
    EFI_SMBIOS_HANDLE  SmbiosHandle = SMBIOS_HANDLE_PI_RESERVED;
    SMBIOS_TYPE        Type4        = 4;
    for ( ; ;) {
      EFI_SMBIOS_TABLE_HEADER  *pHeader;
      Status = pSmbiosProtocol->GetNext (pSmbiosProtocol, &SmbiosHandle, &Type4, &pHeader, NULL);
      if (EFI_ERROR (Status) || (SmbiosHandle == SMBIOS_HANDLE_PI_RESERVED)) {
        break;
      }

      if ((pHeader->Type != Type4) || (pHeader->Length < OFFSET_OF (SMBIOS_TABLE_TYPE4, CoreCount))) {
        continue;
      }

      SMBIOS_TABLE_TYPE4 const  *pType4 = (SMBIOS_TABLE_TYPE4 const *)pHeader;
      Print (L"SMBIOS CPU info: MaxSpeed=%u, CurrentSpeed=%u\n", pType4->MaxSpeed, pType4->CurrentSpeed);
    }
  }
}

static EFI_STATUS
ShowUsage (
  void
  )
{
  Print (L"Usage:   bench <DumpSize> [ <BufferMem> <BufferCount> <NoEncrypt> <NoAsync> ]\n");
  Print (L"Example: bench 0x1000000    0x100000    8             0           0\n");
  // Undocumented 5th parameter: UsePartition
  return EFI_INVALID_PARAMETER;
}

EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS                   Status;
  OFFLINE_DUMP_WRITER_OPTIONS  Options = { 0 };
  UINT64                       DumpSize;
  BOOLEAN                      UsePartition;

  {
    EFI_SHELL_PARAMETERS_PROTOCOL  *pShellParameters;

    Status = gBS->HandleProtocol (gImageHandle, &gEfiShellParametersProtocolGuid, (void **)&pShellParameters);
    if (EFI_ERROR (Status)) {
      Print (L"HandleProtocol(ShellParameters) failed (%r)\n", Status);
      return Status;
    }

    CHAR16 *const *const  Argv = pShellParameters->Argv;
    UINTN                 Argc = pShellParameters->Argc;
    UINTN                 ArgI = 1;

    if (Argc <= ArgI) {
      return ShowUsage ();
    }

    BOOLEAN  AllOk = TRUE;
    DumpSize                  = StrToUint64 ("DumpSize", Argv[ArgI++], &AllOk);
    Options.BufferMemoryLimit = Argc <= ArgI ? 0u : StrToUint32 ("BufferMem", Argv[ArgI++], &AllOk);
    Options.BufferCount       = Argc <= ArgI ? 0u : StrToUint8 ("BufferCount", Argv[ArgI++], &AllOk);
    Options.ForceUnencrypted  = Argc <= ArgI ? 0u : StrToBool ("NoEncrypt", Argv[ArgI++], &AllOk);
    Options.DisableBlockIo2   = Argc <= ArgI ? 0u : StrToBool ("NoAsync", Argv[ArgI++], &AllOk);
    UsePartition              = Argc <= ArgI ? PcdGetBool (PcdOfflineDumpUsePartition) : StrToBool ("UsePartition", Argv[ArgI++], &AllOk);

    if (!AllOk) {
      return ShowUsage ();
    }
  }

  UINT8 const  *pPhysicalBase;
  UINTN        PhysicalSize;

  GetLargestConventionalRegion (&pPhysicalBase, &PhysicalSize);

  EFI_HANDLE  BlockDeviceHandle;

  Status = UsePartition
           // For normal usage: Look for GPT partition with Type = OFFLINE_DUMP_PARTITION_GUID.
    ? FindOfflineDumpPartitionHandle (&BlockDeviceHandle)
           // For testing on Emulator: Look for a raw block device that is not a partition.
    : FindOfflineDumpRawBlockDeviceHandleForTesting (&BlockDeviceHandle);
  if (EFI_ERROR (Status)) {
    Print (L"Find offline dump device failed (%r)\n", Status);
    goto Done;
  }

  UINT32 const  SectionCount = (UINT32)(DumpSize / PhysicalSize + 1);
  UINT64 const  TimeStart    = GetPerformanceCounter ();

  OFFLINE_DUMP_WRITER  *DumpWriter;

  Status = OfflineDumpWriterOpen (
                                  BlockDeviceHandle,
                                  0,
                                  SectionCount,
                                  &Options,
                                  &DumpWriter
                                  );
  if (EFI_ERROR (Status)) {
    Print (L"DumpWriterOpen() failed (%r)\n", Status);
    goto Done;
  }

  RAW_DUMP_SECTION_INFORMATION  Information;

  ZeroMem (&Information, sizeof (Information));

  UINT8 const  *pFakeBase = pPhysicalBase;
  UINT64       Remaining  = DumpSize;

  while (Remaining != 0) {
    UINTN const  SectionSize = (UINTN)MIN (Remaining, PhysicalSize);
    Information.DdrRange.Base = (UINT64)(UINTN)pFakeBase;
    Status                    = OfflineDumpWriterWriteSection (
                                                               DumpWriter,
                                                               RAW_DUMP_SECTION_HEADER_DUMP_VALID,
                                                               RAW_DUMP_DDR_RANGE_CURRENT_MAJOR_VERSION,
                                                               RAW_DUMP_DDR_RANGE_CURRENT_MINOR_VERSION,
                                                               RAW_DUMP_SECTION_DDR_RANGE,
                                                               &Information,
                                                               "Memory",
                                                               NULL,
                                                               pPhysicalBase,
                                                               SectionSize
                                                               );
    if (EFI_ERROR (Status)) {
      Print (L"DumpWriterWriteSection() failed (%r)\n", Status);
      goto Done;
    }

    pFakeBase += SectionSize;
    Remaining -= SectionSize;
  }

  EFI_STATUS const  LastError           = OfflineDumpWriterLastWriteError (DumpWriter);
  UINT64 const      MediaPos            = OfflineDumpWriterMediaPosition (DumpWriter);
  UINT64 const      MediaSize           = OfflineDumpWriterMediaSize (DumpWriter);
  BOOLEAN  const    InsufficientStorage = OfflineDumpWriterHasInsufficientStorage (DumpWriter);
  UINT32 const      BufferSize          = OfflineDumpWriterBufferSize (DumpWriter);
  UINT8 const       BufferCount         = OfflineDumpWriterBufferCount (DumpWriter);
  UINT32 const      EncryptionAlgorithm = OfflineDumpWriterEncryptionAlgorithm (DumpWriter);
  BOOLEAN const     IsAsync             = OfflineDumpWriterUsingBlockIo2 (DumpWriter);

  Status = OfflineDumpWriterClose (DumpWriter, TRUE);
  if (EFI_ERROR (Status)) {
    Print (L"DumpWriterClose() failed (%r)\n", Status);
    goto Done;
  }

  if (LastError != EFI_SUCCESS) {
    Print (L"Last write error: %r\n", LastError);
  }

  if (InsufficientStorage) {
    Print (
           L"Insufficient storage (Have 0x%llX Need 0x%llX)\n",
           (llu_t)MediaSize,
           (llu_t)MediaPos
           );
  }

  if ((LastError != EFI_SUCCESS) || InsufficientStorage) {
    Status = EFI_ABORTED;
    goto Done;
  }

  UINT64 const  TimeEnd            = GetPerformanceCounter ();
  UINT64 const  TimeNS             = GetTimeInNanoSecond (TimeEnd - TimeStart);
  UINT64 const  KilobytesPerSecond = DumpSize * (1000000000 / 1024) / (TimeNS ? TimeNS : 1);

  PrintPerformanceCounterProperties ();
  PrintCpuInfo ();
  Print (
         L"Settings: Buffers = %u * %u KB, Encrypt = %u, AsyncIO = %u\n",
         BufferCount,
         BufferSize / 1024,
         EncryptionAlgorithm,
         IsAsync
         );
  Print (
         L"Results: Data = %u MB, Time = %llu ms, Rate = %u MB/sec\n",
         (unsigned)(DumpSize / (1024 * 1024)),
         (llu_t)(TimeNS / 1000000),
         (unsigned)(KilobytesPerSecond / 1024)
         );
  Status = EFI_SUCCESS;

Done:

  Print (L"Exiting (%r)\n", Status);
  return Status;
}

```

`OfflineDumpPkg/Application/OfflineDumpBench.inf`:

```inf
[Defines] 

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpBench
  VERSION_STRING                 = 0.1
  FILE_GUID                      = 3e55e640-d872-4ab0-8d6a-738713981fec
  MODULE_TYPE                    = UEFI_APPLICATION
  ENTRY_POINT                    = UefiMain

[Sources]

  OfflineDumpBench.c

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec

  CryptoPkg/CryptoPkg.dec
  MdePkg/MdePkg.dec

[LibraryClasses]

  OfflineDumpLib
  OfflineDumpWriterLib

  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  TimerLib
  UefiBootServicesTableLib
  UefiLib

  UefiApplicationEntryPoint

[Protocols]

  gEfiBlockIoProtocolGuid           ## CONSUMES
  gEfiPartitionInfoProtocolGuid     ## CONSUMES
  gEfiShellParametersProtocolGuid   ## CONSUMES
  gEfiSmbiosProtocolGuid            ## CONSUMES

[Pcd]

  gOfflineDumpTokenSpaceGuid.PcdOfflineDumpUsePartition

```

`OfflineDumpPkg/Application/OfflineDumpSampleApp.c`:

```c
#include <Library/OfflineDumpLib.h>
#include <Guid/OfflineDumpCpuContext.h> // CONTEXT_AMD64, CONTEXT_ARM64

#include <Uefi.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h> // ASSERT
#include <Library/DevicePathLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/TimerLib.h> // For benchmarking.
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiLib.h>
#include <Protocol/LoadedImage.h>

#ifdef __INTELLISENSE__
#define PcdGetBool(x)  TRUE
#endif

// For use in printf format values.
typedef long long unsigned llu_t;

static CHAR8 const * const  HelloSectionName     = "HelloSection";
static CHAR8 const          HelloSectionData[]   = "Hello, World!";
static UINTN const          HelloSectionDataSize = sizeof (HelloSectionData);

// Silicon-vendor sections are typically identified by GUID.
// GUID {740A5381-34D6-488d-B03C-A8E6D0181808} identifies the demonstration "Hello" section.
static GUID const  HelloSectionGuid =
{
  0x740a5381, 0x34d6, 0x488d, {
    0xb0,     0x3c,   0xa8,   0xe6, 0xd0, 0x18, 0x18, 0x8
  }
};

// Normally, section data is provided as a pointer to a buffer, but it can also be generated
// by a callback. This is a simple example of a callback that generates a section's data.
static BOOLEAN EFIAPI
CopyHelloDataCallback (
  IN void const  *pDataStart,
  IN UINTN       Offset,
  IN UINTN       Size,
  OUT UINT8      *pDestinationPos
  )
{
  // Callback should perform any custom logic needed to generate the section's data,
  // e.g. it could call into a coprocessor to copy the data.
  //
  // In real code, you should not use a callback if you are just performing a normal CopyMem.
  // If you pass NULL as the callback, the writer will perform an optimized copy as if by CopyMem.
  CopyMem (pDestinationPos, (UINT8 *)pDataStart + Offset, Size);
  return TRUE;
}

// This is the data we need for our implementation of OFFLINE_DUMP_PROVIDER_PROTOCOL.
// We pass this protocol implementation to the writer.
typedef struct {
  // Protocol implementation must always start with the protocol interface:

  OFFLINE_DUMP_PROVIDER_PROTOCOL     Protocol;

  // Additional fields needed by the protocol implementation can go here:

  OFFLINE_DUMP_PROVIDER_DUMP_INFO    DumpInfo; // Information that will be returned by Begin.
  OFFLINE_DUMP_PROVIDER_END_INFO     EndInfo;  // Information that was captured by End.
} SAMPLE_DUMP_PROVIDER;

// Simple implementation of the Begin callback for the OfflineDumpProviderProtocol.
// This is called by the writer to get dump configuration and dump data.
// It needs to fill in the pDumpInfo information.
static EFI_STATUS EFIAPI
SampleBegin (
  IN  OFFLINE_DUMP_PROVIDER_PROTOCOL          *pThisProtocol,
  IN  UINTN                                   BeginInfoSize,
  IN  OFFLINE_DUMP_PROVIDER_BEGIN_INFO const  *pBeginInfo,
  IN  UINTN                                   DumpInfoSize,
  OUT OFFLINE_DUMP_PROVIDER_DUMP_INFO         *pDumpInfo
  )
{
  EFI_STATUS                   Status;
  SAMPLE_DUMP_PROVIDER *const  pThis = BASE_CR (pThisProtocol, SAMPLE_DUMP_PROVIDER, Protocol);

  // BeginInfo holds the information we copy from pBeginInfo.
  OFFLINE_DUMP_PROVIDER_BEGIN_INFO  BeginInfo = { 0 };

  // Copy the writer's BeginInfo buffer to our local BeginInfo.
  // In case of size mismatch between us and the writer, copy the smaller of the two.
  CopyMem (&BeginInfo, pBeginInfo, MIN (BeginInfoSize, sizeof (BeginInfo)));

  // Begin performs any work needed to prepare for the dump. In this case, most of the work
  // happened during protocol initialization.
  //
  // We want to validate UseCapabilityFlags before searching for the BlockDevice,
  // so let's do that now.

  if (0 == (BeginInfo.UseCapabilityFlags & OFFLINE_DUMP_USE_CAPABILITY_LOCATION_GPT_SCAN)) {
    Print (L"Dump disabled: OfflineMemoryDumpUseCapability = 0x%X.\n", BeginInfo.UseCapabilityFlags);
    Status = EFI_NOT_STARTED;
    goto Done;
  }

  // Fill in the BlockDevice value in the protocol's DumpInfo:
  Status = PcdGetBool (PcdOfflineDumpUsePartition)
           // For normal dumps: Look for a GPT partition with Type = OFFLINE_DUMP_PARTITION_GUID.
           ? FindOfflineDumpPartitionHandle (&pThis->DumpInfo.BlockDevice)
           // For testing on X86 Emulator: Look for a raw block device that is not a partition.
           : FindOfflineDumpRawBlockDeviceHandleForTesting (&pThis->DumpInfo.BlockDevice);
  if (EFI_ERROR (Status)) {
    Print (L"Dump error: FindOfflineDumpPartitionHandle failed (%r)\n", Status);
    goto Done;
  }

  Status = EFI_SUCCESS;

Done:

  // Copy our DumpInfo to the writer's DumpInfo buffer.
  // In case of size mismatch between us and the writer, copy the smaller of the two.
  CopyMem (pDumpInfo, &pThis->DumpInfo, MIN (DumpInfoSize, sizeof (pThis->DumpInfo)));

  Print (L"Begin: %r\n", Status);
  return Status;
}

// Simple implementation of the End callback for the OfflineDumpProviderProtocol.
// This is called by the writer to signal that dump generation has ended.
// It should perform cleanup as needed.
// This will be called if and only if the Begin callback returned successfully.
static VOID EFIAPI
SampleEnd (
  IN  OFFLINE_DUMP_PROVIDER_PROTOCOL        *pThisProtocol,
  IN  UINTN                                 EndInfoSize,
  IN  OFFLINE_DUMP_PROVIDER_END_INFO const  *pEndInfo
  )
{
  SAMPLE_DUMP_PROVIDER *const  pThis = BASE_CR (pThisProtocol, SAMPLE_DUMP_PROVIDER, Protocol);

  // Copy the writer's EndInfo buffer to our local EndInfo.
  // In case of size mismatch between us and the writer, copy the smaller of the two.
  CopyMem (&pThis->EndInfo, pEndInfo, MIN (EndInfoSize, sizeof (pThis->EndInfo)));

  pThis->DumpInfo.BlockDevice = NULL;          // Cleanup as needed.
  Print (
         L"End: ENC=%u Status=%r\n",
         (unsigned)pThis->EndInfo.EncryptionAlgorithm,
         pThis->EndInfo.Status // OfflineDumpWrite will return the same status.
         );
}

// Simple implementation of the ReportProgress callback for the OfflineDumpProviderProtocol.
// This is called periodically by the writer to give the provider a chance to update progress UI.
// This will only be called if the Begin callback returned successfully.
static EFI_STATUS EFIAPI
SampleReportProgress (
  IN  OFFLINE_DUMP_PROVIDER_PROTOCOL                    *pThisProtocol,
  IN  UINTN                                             ProgressInfoSize,
  IN  OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO const  *pProgressInfo
  )
{
  (void)pThisProtocol; // Parameter not used.

  // ProgressInfo holds the information we copy from pProgressInfo.
  OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO  ProgressInfo = { 0 };

  // Copy the writer's ProgressInfo buffer to our local ProgressInfo.
  // In case of size mismatch between us and the writer, copy the smaller of the two.
  CopyMem (&ProgressInfo, pProgressInfo, MIN (ProgressInfoSize, sizeof (ProgressInfo)));

  // This implementation just prints the progress.
  // A more complex implementation might update a progress bar or other UI.
  Print (L"ReportProgress: %llu/%llu\n", (llu_t)ProgressInfo.WrittenBytes, (llu_t)ProgressInfo.ExpectedBytes);
  return EFI_SUCCESS; // If this returns an error, the writer will stop writing the dump.
}

// Create a device path that points to OfflineDumpWriter.efi.
// For demonstration purposes, look for OfflineDumpWrite.efi in the same directory as
// this sample app.
static EFI_DEVICE_PATH_PROTOCOL *
SampleGetPathToOfflineDumpWrite (
  IN EFI_HANDLE  ImageHandle
  )
{
  EFI_STATUS  Status;

  // Get device path of the running app (OfflineDumpSampleApp.efi).
  EFI_DEVICE_PATH_PROTOCOL  *pThisImagePath = NULL;

  Status = gBS->HandleProtocol (ImageHandle, &gEfiLoadedImageDevicePathProtocolGuid, (void **)&pThisImagePath);

  if (EFI_ERROR (Status)) {
    Print (L"HandleProtocol(LoadedImageDevicePath) failed (%r)\n", Status);
    return NULL;
  }

  // Get text path of the running app.
  CHAR16  *pThisImagePathText = ConvertDevicePathToText (pThisImagePath, FALSE, FALSE);
  if (pThisImagePathText == NULL) {
    Print (L"ConvertDevicePathToText(LoadedImageDevicePath) failed\n");
    return NULL;
  }

  // Find the end of the directory part of the running app's path.
  UINTN  ThisImageDirEnd = StrLen (pThisImagePathText);
  while (ThisImageDirEnd > 0 && pThisImagePathText[ThisImageDirEnd - 1] != L'\\') {
    ThisImageDirEnd -= 1;
  }

  // Create a text path that points to OfflineDumpWrite.efi in the running app's directory.
  CHAR16  *pOfflineDumpWritePathText = CatSPrint (NULL, L"%.*sOfflineDumpWrite.efi", (UINT32)ThisImageDirEnd, pThisImagePathText);
  FreePool (pThisImagePathText);
  pThisImagePathText = NULL;
  if (pOfflineDumpWritePathText == NULL) {
    Print (L"CatSPrint(OfflineDumpWritePath) failed\n");
    return NULL;
  }

  Print (L"Running \"%s\"\n", pOfflineDumpWritePathText);

  // Get device path of OfflineDumpWrite.efi in the running app's directory.
  EFI_DEVICE_PATH_PROTOCOL  *pOfflineDumpWritePath = ConvertTextToDevicePath (pOfflineDumpWritePathText);
  FreePool (pOfflineDumpWritePathText);
  pOfflineDumpWritePathText = NULL;
  if (pOfflineDumpWritePath == NULL) {
    Print (L"ConvertTextToDevicePath(OfflineDumpWritePath) failed\n");
    return NULL;
  }

  return pOfflineDumpWritePath;
}

EFI_STATUS EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS                          Status;
  UINT8                               *MemoryMap = NULL;
  OFFLINE_DUMP_PROVIDER_SECTION_INFO  *Sections  = NULL;
  OFFLINE_DUMP_PROVIDER_SECTION_INFO  *pSection  = NULL;

  UINTN   MemoryMapSize = 0;
  UINTN   MapKey;
  UINTN   DescriptorSize;
  UINT32  DescriptorVersion;

  // Get the memory map.
  // TODO: Real crash dump will use a customized memory map to include carve-outs.

  Status = gBS->GetMemoryMap (&MemoryMapSize, (EFI_MEMORY_DESCRIPTOR *)MemoryMap, &MapKey, &DescriptorSize, &DescriptorVersion);
  if (Status != EFI_BUFFER_TOO_SMALL) {
    Print (L"GetMemoryMap() failed (%r)\n", Status);
    goto Done;
  }

  MemoryMap = AllocatePool (MemoryMapSize);
  if (MemoryMap == NULL) {
    Print (L"AllocatePool(MemoryMapSize = %u) failed\n", MemoryMapSize);
    goto Done;
  }

  Status = gBS->GetMemoryMap (&MemoryMapSize, (EFI_MEMORY_DESCRIPTOR *)MemoryMap, &MapKey, &DescriptorSize, &DescriptorVersion);
  if (EFI_ERROR (Status)) {
    Print (L"GetMemoryMap() failed (%r)\n", Status);
    goto Done;
  }

  // Determine the size of the sections array.

  UINT32  SectionsCount = 0;

  // Count one SV_SPECIFIC section (HelloSection for demonstration purposes)
  // TODO: Real crash dump will likely include several SV_SPECIFIC sections.
  SectionsCount += 1;

  // Count the DDR_RANGE sections.
  for (UINT8 const *DescPos = MemoryMap; DescPos < MemoryMap + MemoryMapSize; DescPos += DescriptorSize) {
    EFI_MEMORY_DESCRIPTOR const  *Desc = (EFI_MEMORY_DESCRIPTOR const *)DescPos;
    if (Desc->Type != EfiConventionalMemory) {
      continue;
    }

    SectionsCount += 1; // DDR_RANGE
  }

  // Allocate the sections array.

  Sections = AllocateZeroPool (SectionsCount * sizeof (OFFLINE_DUMP_PROVIDER_SECTION_INFO));
  if (Sections == NULL) {
    Print (L"AllocatePool(SectionsCount = %u) failed\n", SectionsCount);
    goto Done;
  }

  // Prepare the sections array.

  UINT32  SectionsIndex = 0;
  UINT64  DdrEnd        = 0;

  // Prepare one SV_SPECIFIC section (HelloSection).
  // For demonstration purposes, use a callback to copy the data.
  // In real code, you would only use a callback if you need to perform custom logic to read/generate the data.
  pSection        = &Sections[SectionsIndex++];
  pSection->Type  = OfflineDumpProviderSectionType_SvSpecific;
  pSection->pName = HelloSectionName;
  CopyGuid ((GUID *)pSection->Information.SVSpecific.SVSpecificData, &HelloSectionGuid);
  pSection->pDataStart       = HelloSectionData;
  pSection->DataSize         = HelloSectionDataSize;
  pSection->DataCopyCallback = CopyHelloDataCallback; // Demonstrate using a callback (normally you would set this to NULL).

  // Prepare the DDR_RANGE sections.
  // TODO: Real crash dump will use a customized memory map to include carve-outs.
  for (UINT8 const *DescPos = MemoryMap; DescPos < MemoryMap + MemoryMapSize; DescPos += DescriptorSize) {
    EFI_MEMORY_DESCRIPTOR const  *Desc = (EFI_MEMORY_DESCRIPTOR const *)DescPos;
    if (Desc->Type != EfiConventionalMemory) {
      continue;
    }

    pSection                            = &Sections[SectionsIndex++];
    pSection->Type                      = OfflineDumpProviderSectionType_DdrRange;
    pSection->Information.DdrRange.Base = Desc->PhysicalStart;
    pSection->pDataStart                = (void const *)(UINTN)Desc->PhysicalStart;
    pSection->DataSize                  = EFI_PAGES_TO_SIZE (Desc->NumberOfPages);

    // DDR_RANGE sections must be specified in order of their start address and must not overlap.
    ASSERT (DdrEnd <= Desc->PhysicalStart);
    DdrEnd = Desc->PhysicalStart + EFI_PAGES_TO_SIZE (Desc->NumberOfPages);
  }

  ASSERT (SectionsCount == SectionsIndex);

  // Fill in the CPU context data for each core.

  #define CPU_CONTEXT_COUNT  4 // TODO: Get the actual number of CPU cores.
  CONTEXT_ARM64  CpuContexts[CPU_CONTEXT_COUNT];
  SetMem (CpuContexts, sizeof (CpuContexts), 0);
  UINT32 const  CpuContextCount = CPU_CONTEXT_COUNT;
  for (unsigned i = 0; i < CpuContextCount; i += 1) {
    CONTEXT_ARM64  *pContext = &CpuContexts[i];

    // TODO: Get real CPU context data that was captured at the time of the crash.
    pContext->Pc = 0x1234;
  }

  // Create our provider.

  SAMPLE_DUMP_PROVIDER  SampleDumpProvider = {
    // Provider public fields (used by the writer):
    .Protocol.Revision       = OfflineDumpProviderProtocolRevision_1_0,
    .Protocol.Begin          = SampleBegin,
    .Protocol.ReportProgress = SampleReportProgress,
    .Protocol.End            = SampleEnd,

    // Provider private fields (used by the callbacks):
    .DumpInfo                  = {
      .BlockDevice          = NULL, // Filled in by SampleBegin.
      .pSections            = Sections,
      .SectionCount         = SectionsCount,
      .Architecture         = RAW_DUMP_ARCHITECTURE_ARM64,
      .pCpuContexts         = CpuContexts,
      .CpuContextCount      = CpuContextCount,
      .CpuContextSize       = sizeof (CpuContexts[0]),
      .pVendor              = "Vend",     // TODO: Use real vendor.
      .pPlatform            = "Platform", // TODO: Use real platform.
      .DumpReasonParameters =             // TODO: Use real dump bucket parameters.
      {
        0x12345678,
        0xA,
        0x1234,
        0x0,
      },
      .Flags                   = RAW_DUMP_HEADER_IS_DDR_CACHE_FLUSHED,         // TODO: Set this only if DDR was flushed before warm boot.
      .pSecureConfiguration    = NULL,                                         // TODO: Use real configuration ptr from trusted firmware (SMC).
      .SecureConfigurationSize = 0,                                            // TODO: Use real configuration size from trusted firmware (SMC).
      .SecureControl           = OfflineDumpProviderSecureControl_DumpAllowed, // TODO: Use real control value from trusted firmware (SMC).
    },
  };

  // Run OfflineDumpWrite.efi to write the dump.
  // Alternative would be to link against OfflineDumpWriterLib and call OfflineDumpWrite(&Protocol).

  EFI_DEVICE_PATH_PROTOCOL  *pOfflineDumpWritePath = SampleGetPathToOfflineDumpWrite (ImageHandle);
  if (pOfflineDumpWritePath == NULL) {
    Status = EFI_OUT_OF_RESOURCES;
    goto Done;
  }

  UINT64 const  TimeStart = GetPerformanceCounter ();
  Status = OfflineDumpWriteExecutePath (
                                        &SampleDumpProvider.Protocol,
                                        ImageHandle,
                                        pOfflineDumpWritePath
                                        );
  UINT64 const  TimeEnd = GetPerformanceCounter ();
  FreePool (pOfflineDumpWritePath);
  pOfflineDumpWritePath = NULL;

  // Report results.

  if (EFI_ERROR (Status)) {
    Print (
           L"OfflineDumpWrite failed: %r\n",
           Status
           );
  } else if (SampleDumpProvider.EndInfo.SizeRequired > SampleDumpProvider.EndInfo.SizeAvailable) {
    Print (
           L"OfflineDumpWrite truncated: %lluKB required, %lluKB available\n",
           (llu_t)SampleDumpProvider.EndInfo.SizeRequired / 1024,
           (llu_t)SampleDumpProvider.EndInfo.SizeAvailable / 1024
           );
  } else {
    UINT64 const  TimeNS             = GetTimeInNanoSecond (TimeEnd - TimeStart);
    UINT64 const  KilobytesPerSecond = SampleDumpProvider.EndInfo.SizeRequired * (1000000000 / 1024) / (TimeNS ? TimeNS : 1);
    Print (
           L"OfflineDumpWrite succeeded: %lluKB / %llus = %llu KB/s\n",
           (llu_t)SampleDumpProvider.EndInfo.SizeRequired / 1024,
           (llu_t)TimeNS / 1000000000,
           (llu_t)KilobytesPerSecond
           );
  }

Done:

  if (MemoryMap != NULL) {
    FreePool (MemoryMap);
  }

  if (Sections != NULL) {
    FreePool (Sections);
  }

  Print (L"Exit: %r\n", Status);
  return Status;
}

```

`OfflineDumpPkg/Application/OfflineDumpSampleApp.inf`:

```inf
[Defines] 

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpSampleApp
  VERSION_STRING                 = 0.1
  FILE_GUID                      = 813959c1-07bf-4a21-97eb-765f853acae1
  MODULE_TYPE                    = UEFI_APPLICATION
  ENTRY_POINT                    = UefiMain

[Sources]

  OfflineDumpSampleApp.c

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec

  MdePkg/MdePkg.dec

[LibraryClasses]

  OfflineDumpLib

  BaseMemoryLib
  DebugLib
  DevicePathLib
  MemoryAllocationLib
  UefiBootServicesTableLib
  UefiLib

  UefiApplicationEntryPoint

[Pcd]

  gOfflineDumpTokenSpaceGuid.PcdOfflineDumpUsePartition

[Protocols]

  gEfiLoadedImageDevicePathProtocolGuid ## CONSUMES
  gOfflineDumpProviderProtocolGuid      ## PRODUCES

```

`OfflineDumpPkg/Application/OfflineDumpWrite.c`:

```c
#include <OfflineDumpWriterLib.h>
#include <Uefi.h>
#include <Library/DebugLib.h>
#include <Library/UefiBootServicesTableLib.h>

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a " fmt, "OfflineDumpWrite:", ##__VA_ARGS__)

EFI_STATUS EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS                      Status;
  OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProvider = NULL;

  DEBUG_PRINT (DEBUG_INFO, "Entry\n");

  Status = gBS->LocateProtocol (&gOfflineDumpProviderProtocolGuid, NULL, (VOID **)&pProvider);
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "LocateProtocol(gOfflineDumpProviderProtocolGuid) failed (%r)\n", Status);
    goto Done;
  }

  Status = OfflineDumpWrite (pProvider);

Done:

  DEBUG_PRINT (DEBUG_INFO, "Exit (Status=%r)\n", Status);
  return Status;
}

```

`OfflineDumpPkg/Application/OfflineDumpWrite.inf`:

```inf
# Application that writes an offline dump.
# Obtains dump parameters via LocateProtocol(gOfflineDumpProviderProtocolGuid).
# Status is reported via DebugLib.
# Requires RngDxe for secure random numbers.
[Defines]

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpWrite
  VERSION_STRING                 = 0.1
  FILE_GUID                      = 88d2ca98-f98b-44ff-b02e-8ab10072a5a5
  MODULE_TYPE                    = UEFI_APPLICATION
  ENTRY_POINT                    = UefiMain

[Sources]

  OfflineDumpWrite.c

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec

  CryptoPkg/CryptoPkg.dec
  MdePkg/MdePkg.dec

[LibraryClasses]

  OfflineDumpLib
  OfflineDumpWriterLib

  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  UefiBootServicesTableLib
  UefiLib

  UefiApplicationEntryPoint

[Protocols]

  gOfflineDumpProviderProtocolGuid      ## CONSUMES

```

`OfflineDumpPkg/Include/Guid/OfflineDumpConfig.h`:

```h
/*
Microsoft Offline Dump - Definitions for communication between firmware and OS.
*/

#ifndef _included_Guid_OfflineDumpConfig_h
#define _included_Guid_OfflineDumpConfig_h

//
// OFFLINE_DUMP_CONFIGURATION_TABLE used to pass information from the firmware to the OS.
//

#define OFFLINE_DUMP_CONFIGURATION_TABLE_GUID  /* 3804CF02-8538-11E2-8847-8DF16088709B */ \
  { 0x3804CF02, 0x8538, 0x11E2, { 0x88, 0x47, 0x8D, 0xF1, 0x60, 0x88, 0x70, 0x9B }}

typedef enum {
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_NONE                 = 0,

  // The firmware supports scanning for a dedicated GPT dump partition.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_LOCATION_GPT_SCAN    = 0x01,

  // Deprecated. Do not set this flag.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_LOCATION_BYTE_OFFSET = 0x02,

  // Deprecated. Do not set this flag.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_RESET_DATA           = 0x04,

  // Deprecated. Do not set this flag.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_LOCATION_EFI_SYSTEM  = 0x08,

  // The firmware supports encrypting the dump with AES_CTR + RSAES_OAEP.
  // The firmware supports AES128, AES192, and AES256.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_AES_CTR              = 0x10,
} OFFLINE_DUMP_CONFIGURATION_CAPABLE_FLAGS;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_CONFIGURATION_CAPABLE_FLAGS) == 4,
               "OFFLINE_DUMP_CONFIGURATION_CAPABLE_FLAGS should be 4 bytes"
               );

// For use on current versions of Windows.
typedef struct {
  // Set to 2.
  UINT32                                      Version;

  // 0: No abnormal reset occurred on the most recent system boot.
  // 1: An abnormal reset occurred on the most recent system boot.
  UINT32                                      AbnormalResetOccurred;

  // Capability flags.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_FLAGS    OfflineMemoryDumpCapable;

  // Set to 0.
  UINT32                                      Padding1;

  // Set to 0.
  UINT64                                      ResetDataAddress;

  // Set to 0.
  UINT32                                      ResetDataSize;

  // Set to 0.
  UINT32                                      Padding2;
} OFFLINE_DUMP_CONFIGURATION_TABLE_V2;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_CONFIGURATION_TABLE_V2) == 32,
               "OFFLINE_DUMP_CONFIGURATION_TABLE_V2 should be 32 bytes"
               );

// For use on future versions of Windows.
typedef struct {
  // Set to 3.
  UINT32                                      Version;

  // Bit 0: Set to 1 if an abnormal reset occurred on the most recent system boot.
  //
  // Bits 1-31: Reserved, must be 0.
  UINT32                                      AbnormalResetOccurred;

  // Capability flags, e.g. LOCATION_GPT_SCAN | AES_CTR.
  OFFLINE_DUMP_CONFIGURATION_CAPABLE_FLAGS    OfflineMemoryDumpCapable;

  // Bit 0: Set to 1 if the device is correctly configured for offline crash dump
  //        collection. Firmware must set this bit after verifying all required
  //        preconditions necessary for offline crash dump collection.
  //
  //        For example, this should be set to 0 if the device is in a retail
  //        configuration (retail fused and no debug certificate installed).
  //
  // Bits 1-31: Reserved, must be 0.
  UINT32                                      OfflineMemoryDumpEnabled;

  // Bit 0: Set when the firmware has attempted offline crash dump collection
  //        after an abnormal reset. 
  //
  // Bits 1-31: Reserved, must be 0.
  UINT32                                      OfflineMemoryDumpExpected;

  // Bits 0-31: Bitfield to indicate any offline dump collection errors. Definitions of
  //            values will be controlled by and specific to the SV.
  UINT32                                      OfflineDumpCreationErrors;
} OFFLINE_DUMP_CONFIGURATION_TABLE_V3;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_CONFIGURATION_TABLE_V3) == 24,
               "OFFLINE_DUMP_CONFIGURATION_TABLE_V3 should be 24 bytes"
               );

#define OFFLINE_DUMP_CONFIGURATION_TABLE_CURRENT_VERSION  2
typedef OFFLINE_DUMP_CONFIGURATION_TABLE_V2 OFFLINE_DUMP_CONFIGURATION_TABLE;

//
// Firmware variables used to pass information from the OS to the firmware.
//

// Vendor GUID for firmware variables set by the OS.
#define OFFLINE_DUMP_VARIABLE_GUID  /* 77fa9abd-0359-4d32-bd60-28f4e78f784b */ \
  { 0x77fa9abd, 0x0359, 0x4d32, { 0xBD, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b }}

// OfflineMemoryDumpUseCapability: UINT8 (OFFLINE_DUMP_USE_CAPABILITY_FLAGS).
// Bit 0: Firmware must scan the GPT partition table for the dump partition and
//        write the dump to that partition.
// Bit 1: Deprecated, ignore.
// Bit 2: Deprecated, ignore.
// Bit 3: Deprecated, ignore.
#define OFFLINE_DUMP_USE_CAPABILITY_VARIABLE_NAME  L"OfflineMemoryDumpUseCapability"

// Flags used by the OfflineMemoryDumpUseCapability variable.
typedef enum {
  OFFLINE_DUMP_USE_CAPABILITY_NONE                 = 0,
  OFFLINE_DUMP_USE_CAPABILITY_LOCATION_GPT_SCAN    = 0x01,
  OFFLINE_DUMP_USE_CAPABILITY_LOCATION_BYTE_OFFSET = 0x02,  // Deprecated
  OFFLINE_DUMP_USE_CAPABILITY_RESET_DATA           = 0x04,  // Deprecated
  OFFLINE_DUMP_USE_CAPABILITY_LOCATION_EFI_SYSTEM  = 0x08,  // Deprecated
} OFFLINE_DUMP_USE_CAPABILITY_FLAGS;

// OfflineMemoryDumpOsData: UINT64.
// Windows will persist a book-keeping value in this variable. The firmware should query this
// data and copy it to RAW_DUMP_HEADER.OsData (reference this section) when writing a dump.
#define OFFLINE_DUMP_OS_DATA_VARIABLE_NAME  L"OfflineMemoryDumpOsData"

// OfflineMemoryDumpEncryptionAlgorithm: UINT32 (ENC_DUMP_ALGORITHM).
// ENC_DUMP_ALGORITHM_NONE (0): The firmware may write an unencrypted dump.
// ENC_DUMP_ALGORITHM_AES128_CTR (1): The firmware must encrypt the dump with AES128_CTR.
// Other: Reserved - the firmware must not write a dump.
#define OFFLINE_DUMP_ENCRYPTION_ALGORITHM_VARIABLE_NAME  L"OfflineMemoryDumpEncryptionAlgorithm"

// OfflineMemoryDumpEncryptionPublicKey: Binary.
// X.509 DER-encoded certificate with the public key to be used for key transport when writing
// an encrypted dump.
#define OFFLINE_DUMP_ENCRYPTION_PUBLIC_KEY_VARIABLE_NAME  L"OfflineMemoryDumpEncryptionPublicKey"

//
// GPT partition information
//

// Partition type GUID for the offline dump partition.
// This value is found in EFI_PARTITION_ENTRY::PartitionTypeGUID.
#define OFFLINE_DUMP_PARTITION_TYPE_GUID  /* 66C9B323-F7FC-48B6-BF96-6F32E335A428 */ \
  { 0x66C9B323, 0xF7FC, 0x48B6, { 0xBF, 0x96, 0x6F, 0x32, 0xE3, 0x35, 0xA4, 0x28 }}

//
// GUIDs defined in this header:
//

extern EFI_GUID  gOfflineDumpConfigurationTableGuid;
extern EFI_GUID  gOfflineDumpVariableGuid;
extern EFI_GUID  gOfflineDumpPartitionTypeGuid;

#endif // _included_Guid_OfflineDumpConfig_h

```

`OfflineDumpPkg/Include/Guid/OfflineDumpCpuContext.h`:

```h
/*
Microsoft Offline Dump - Definitions for CPU context information.
*/

#ifndef _included_Guid_OfflineDumpCpuContext_h
#define _included_Guid_OfflineDumpCpuContext_h

#ifdef DUMMYSTRUCTNAME
#define CPU_CONTEXT_DUMMYSTRUCTNAME  DUMMYSTRUCTNAME
#else
#define CPU_CONTEXT_DUMMYSTRUCTNAME  s
#endif

#ifdef DUMMYUNIONNAME
#define CPU_CONTEXT_DUMMYUNIONNAME  DUMMYUNIONNAME
#else
#define CPU_CONTEXT_DUMMYUNIONNAME  u
#endif

//
// PROCESSOR_ARCHITECTURE_AMD64
//

// For use in RAW_DUMP_SECTION_INFORMATION_CPU_CONTEXT field Architecture.
// From winnt.h: PROCESSOR_ARCHITECTURE_AMD64.
#define PROCESSOR_ARCHITECTURE_AMD64  9

// A 128-bit XMM register.
// From winnt.h: M128A.
typedef struct {
  UINT64    Low;
  INT64     High;
} M128A;

STATIC_ASSERT (
               sizeof (M128A) == 16,
               "M128A should be 16 bytes"
               );

// XSAVE_FORMAT: AMD64 floating point state.
// From winnt.h: XSAVE_FORMAT for _M_AMD64.
typedef struct {
  UINT16    ControlWord;
  UINT16    StatusWord;
  UINT8     TagWord;
  UINT8     Reserved1;
  UINT16    ErrorOpcode;
  UINT32    ErrorOffset;
  UINT16    ErrorSelector;
  UINT16    Reserved2;
  UINT32    DataOffset;
  UINT16    DataSelector;
  UINT16    Reserved3;
  UINT32    MxCsr;
  UINT32    MxCsr_Mask;
  M128A     FloatRegisters[8];

  M128A     XmmRegisters[16];
  UINT8     Reserved4[96];
} XSAVE_FORMAT;

STATIC_ASSERT (
               sizeof (XSAVE_FORMAT) == 512,
               "XSAVE_FORMAT should be 512 bytes"
               );

// CONTEXT_AMD64: AMD64 processor context for use in RAW_DUMP_SECTION_CPU_CONTEXT data.
// From winnt.h: CONTEXT for _M_AMD64.
typedef struct {
  //
  // Register parameter home addresses.
  //
  // N.B. These fields are for convience - they could be used to extend the
  //      context record in the future.
  //

  UINT64    P1Home;
  UINT64    P2Home;
  UINT64    P3Home;
  UINT64    P4Home;
  UINT64    P5Home;
  UINT64    P6Home;

  //
  // Control flags.
  //

  UINT32    ContextFlags;
  UINT32    MxCsr;

  //
  // Segment Registers and processor flags.
  //

  UINT16    SegCs;
  UINT16    SegDs;
  UINT16    SegEs;
  UINT16    SegFs;
  UINT16    SegGs;
  UINT16    SegSs;
  UINT32    EFlags;

  //
  // Debug registers
  //

  UINT64    Dr0;
  UINT64    Dr1;
  UINT64    Dr2;
  UINT64    Dr3;
  UINT64    Dr6;
  UINT64    Dr7;

  //
  // Integer registers.
  //

  UINT64    Rax;
  UINT64    Rcx;
  UINT64    Rdx;
  UINT64    Rbx;
  UINT64    Rsp;
  UINT64    Rbp;
  UINT64    Rsi;
  UINT64    Rdi;
  UINT64    R8;
  UINT64    R9;
  UINT64    R10;
  UINT64    R11;
  UINT64    R12;
  UINT64    R13;
  UINT64    R14;
  UINT64    R15;

  //
  // Program counter.
  //

  UINT64    Rip;

  //
  // Floating point state.
  //

  union {
    XSAVE_FORMAT    FltSave;
    struct {
      M128A    Header[2];
      M128A    Legacy[8];
      M128A    Xmm0;
      M128A    Xmm1;
      M128A    Xmm2;
      M128A    Xmm3;
      M128A    Xmm4;
      M128A    Xmm5;
      M128A    Xmm6;
      M128A    Xmm7;
      M128A    Xmm8;
      M128A    Xmm9;
      M128A    Xmm10;
      M128A    Xmm11;
      M128A    Xmm12;
      M128A    Xmm13;
      M128A    Xmm14;
      M128A    Xmm15;
    } XmmSave;
  } CPU_CONTEXT_DUMMYUNIONNAME;

  //
  // Vector registers.
  //

  M128A     VectorRegister[26];
  UINT64    VectorControl;

  //
  // Special debug control registers.
  //

  UINT64    DebugControl;
  UINT64    LastBranchToRip;
  UINT64    LastBranchFromRip;
  UINT64    LastExceptionToRip;
  UINT64    LastExceptionFromRip;
} CONTEXT_AMD64;

STATIC_ASSERT (
               sizeof (CONTEXT_AMD64) == 1232,
               "CONTEXT_AMD64 should be 1232 bytes"
               );

//
// PROCESSOR_ARCHITECTURE_ARM64
//

// For use in RAW_DUMP_SECTION_INFORMATION_CPU_CONTEXT field Architecture.
// From winnt.h: PROCESSOR_ARCHITECTURE_ARM64.
#define PROCESSOR_ARCHITECTURE_ARM64  12

// From winnt.h: ARM64_MAX_BREAKPOINTS.
#define ARM64_MAX_BREAKPOINTS  8

// From winnt.h: ARM64_MAX_WATCHPOINTS.
#define ARM64_MAX_WATCHPOINTS  2

// From winnt.h: ARM64_NT_NEON128.
typedef union {
  struct {
    UINT64    Low;
    INT64     High;
  } CPU_CONTEXT_DUMMYSTRUCTNAME;
  double    D[2];
  float     S[4];
  UINT16    H[8];
  UINT8     B[16];
} ARM64_NT_NEON128;

STATIC_ASSERT (
               sizeof (ARM64_NT_NEON128) == 16,
               "ARM64_NT_NEON128 should be 16 bytes"
               );

// CONTEXT_ARM64: ARM64 processor context for use in RAW_DUMP_SECTION_CPU_CONTEXT data.
// From winnt.h: CONTEXT for _M_ARM64.
typedef struct {
  //
  // Control flags.
  //

  /* +0x000 */ UINT32    ContextFlags;

  //
  // Integer registers
  //

  /* +0x004 */ UINT32    Cpsr;      // NZVF + DAIF + CurrentEL + SPSel
  /* +0x008 */ union {
    struct {
      UINT64                        X0;
      UINT64                        X1;
      UINT64                        X2;
      UINT64                        X3;
      UINT64                        X4;
      UINT64                        X5;
      UINT64                        X6;
      UINT64                        X7;
      UINT64                        X8;
      UINT64                        X9;
      UINT64                        X10;
      UINT64                        X11;
      UINT64                        X12;
      UINT64                        X13;
      UINT64                        X14;
      UINT64                        X15;
      UINT64                        X16;
      UINT64                        X17;
      UINT64                        X18;
      UINT64                        X19;
      UINT64                        X20;
      UINT64                        X21;
      UINT64                        X22;
      UINT64                        X23;
      UINT64                        X24;
      UINT64                        X25;
      UINT64                        X26;
      UINT64                        X27;
      UINT64                        X28;
      /* +0x0f0 */        UINT64    Fp;
      /* +0x0f8 */        UINT64    Lr;
    } CPU_CONTEXT_DUMMYSTRUCTNAME;
    UINT64    X[31];
  } CPU_CONTEXT_DUMMYUNIONNAME;
  /* +0x100 */ UINT64              Sp;
  /* +0x108 */ UINT64              Pc;

  //
  // Floating Point/NEON Registers
  //

  /* +0x110 */ ARM64_NT_NEON128    V[32];
  /* +0x310 */ UINT32              Fpcr;
  /* +0x314 */ UINT32              Fpsr;

  //
  // Debug registers
  //

  /* +0x318 */ UINT32              Bcr[ARM64_MAX_BREAKPOINTS];
  /* +0x338 */ UINT64              Bvr[ARM64_MAX_BREAKPOINTS];
  /* +0x378 */ UINT32              Wcr[ARM64_MAX_WATCHPOINTS];
  /* +0x380 */ UINT64              Wvr[ARM64_MAX_WATCHPOINTS];
  /* +0x390 */
} CONTEXT_ARM64;

STATIC_ASSERT (
               sizeof (CONTEXT_ARM64) == 912,
               "CONTEXT_ARM64 should be 912 bytes"
               );

#undef CPU_CONTEXT_DUMMYSTRUCTNAME
#undef CPU_CONTEXT_DUMMYUNIONNAME
#endif // _included_Guid_OfflineDumpCpuContext_h

```

`OfflineDumpPkg/Include/Guid/OfflineDumpEncryption.h`:

```h
/*
Microsoft Offline Dump - Definitions for dump encryption.
*/

#ifndef _included_Guid_OfflineDumpEncryption_h
#define _included_Guid_OfflineDumpEncryption_h

// Signature for the encrypted dump header.
// 8 Bytes - "Enc_Dmp!" - in hex, LittleEndian order
#define ENC_DUMP_HEADER_SIGNATURE  (UINT64)(0x21706D445F636E45)

// Algorithms used for dump data encryption.
typedef enum {
  // No encryption.
  ENC_DUMP_ALGORITHM_NONE = 0,

  // AES128_CTR mode encryption.
  // - EncryptedKeyCms content must decrypt to the 16-byte DumpKey (AES128 key).
  // - InitializationVectorSize is an 8-byte random value.
  // - ENC_DUMP_CTR_COUNTER (little-endian) is the structure for the counter.
  //
  // Both encryption and decryption are performed using 16-byte blocks as follows:
  // OutputBlock[N] = InputBlock[N] XOR AesEncryptBlock<DumpKey>(ENC_DUMP_CTR_COUNTER{N, IV})
  //
  // If input is not a multiple of 16 bytes, the last block is padded to a multiple of 16 bytes,
  // the encryption/decryption is performed, and then the output is truncated to the original
  // size.
  ENC_DUMP_ALGORITHM_AES128_CTR = 1,

  // AES192_CTR mode encryption: Same as AES128_CTR, but with 24-byte DumpKey (AES192 key).
  ENC_DUMP_ALGORITHM_AES192_CTR = 2,

  // AES256_CTR mode encryption: Same as AES128_CTR, but with 32-byte DumpKey (AES256 key).
  ENC_DUMP_ALGORITHM_AES256_CTR = 3,
} ENC_DUMP_ALGORITHM;

STATIC_ASSERT (
               sizeof (ENC_DUMP_ALGORITHM) == 4,
               "ENC_DUMP_ALGORITHM should be 4 bytes"
               );

// Encrypted dump header.
// Encrypted dump = ENC_DUMP_HEADER + ENC_DUMP_KEY_INFO block + Encrypt(Unencrypted dump).
typedef struct {
  UINT64    Signature;     // ENC_DUMP_HEADER_SIGNATURE
  UINT32    HeaderSize;    // sizeof(ENC_DUMP_HEADER)
  UINT32    KeyInfoOffset; // offset from start of ENC_DUMP_HEADER to start of ENC_DUMP_KEY_INFO.
  UINT32    RawDumpOffset; // offset from start of ENC_DUMP_HEADER to start of encrypted RAW_DUMP_HEADER.
  UINT32    Reserved;      // Reserved for future use (padding for 8-byte structure size).
  // Followed by ENC_DUMP_KEY_INFO block.
  // Followed by Encrypt(Unencrypted dump).
} ENC_DUMP_HEADER;

STATIC_ASSERT (
               sizeof (ENC_DUMP_HEADER) == 24,
               "ENC_DUMP_HEADER should be 24 bytes"
               );

// Encrypted dump key information.
// ENC_DUMP_KEY_INFO block = ENC_DUMP_KEY_INFO + InitializationVector + EncryptedKeyCms + padding.
typedef struct {
  UINT32                BlockSize;                // sizeof(ENC_DUMP_KEY_INFO + InitializationVector + EncryptedKeyCms + padding).
  ENC_DUMP_ALGORITHM    Algorithm;                // Encryption algorithm used, e.g. ENC_DUMP_ALGORITHM_AES???_CTR.
  UINT32                InitializationVectorSize; // Size of InitializationVector in bytes, e.g. 8 for AES???_CTR.
  UINT32                EncryptedKeyCmsSize;      // Size of EncryptedKeyCms in bytes.
  // Followed by InitializationVectorSize bytes of InitializationVector data.
  // Followed by EncryptedKeyCmsSize bytes of EncryptedKeyCms data.
  // Followed by 0..7 bytes of padding as needed to make BlockSize a multiple of 8.
} ENC_DUMP_KEY_INFO;

STATIC_ASSERT (
               sizeof (ENC_DUMP_KEY_INFO) == 16,
               "ENC_DUMP_KEY_INFO should be 16 bytes"
               );

// Counter value for AES???_CTR mode encryption.
// CounterLow is set to 0 for the first 16-byte block, 1 for the next block, etc.
// CounterHigh is set to the 8-byte InitializationVector.
typedef struct {
  UINT64    CounterLow;  // Set to RawDumpBlockIndex, i.e. RawDumpBytePos / 16.
  UINT64    CounterHigh; // Set to IV.
} ENC_DUMP_CTR_COUNTER;

STATIC_ASSERT (
               sizeof (ENC_DUMP_CTR_COUNTER) == 16,
               "ENC_DUMP_CTR_COUNTER should be 16 bytes"
               );

#endif // _included_Guid_OfflineDumpEncryption_h

```

`OfflineDumpPkg/Include/Guid/OfflineDumpHeaders.h`:

```h
/*
Microsoft Offline Dump - Definitions for dump file format.
*/

#ifndef _included_Guid_OfflineDumpHeaders_h
#define _included_Guid_OfflineDumpHeaders_h

#pragma pack(push,1)

// Signature for the raw dump file header.
// 8 Bytes - "Raw_Dmp!" - in hex, LittleEndian order
#define RAW_DUMP_HEADER_SIGNATURE  (UINT64)(0x21706D445F776152)

#define RAW_DUMP_HEADER_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_HEADER_CURRENT_MINOR_VERSION  0

// Flags for RAW_DUMP_HEADER.
typedef enum {
  RAW_DUMP_HEADER_NONE                     = 0,
  RAW_DUMP_HEADER_DUMP_VALID               = 0x01, // This dump was successfully written.
  RAW_DUMP_HEADER_INSUFFICIENT_STORAGE     = 0x02, // The dump is incomplete due to insufficient storage.
  RAW_DUMP_HEADER_IS_HYPERV_DATA_PROTECTED = 0x04, // All Hyper-V/SecureKernel memory is redacted or encrypted.
  RAW_DUMP_HEADER_IS_DDR_CACHE_FLUSHED     = 0x08, // DDR cache was successfully flushed before the warm reset.
} RAW_DUMP_HEADER_FLAGS;

STATIC_ASSERT (
               sizeof (RAW_DUMP_HEADER_FLAGS) == 4,
               "RAW_DUMP_HEADER_FLAGS should be 4 bytes"
               );

// Raw dump header.
// The raw dump is: RAW_DUMP_HEADER + RAW_DUMP_SECTION_HEADER[SectionsCount] + section data.
typedef struct {
  UINT64                   Signature;    // Set to RAW_DUMP_HEADER_SIGNATURE.
  UINT16                   MajorVersion; // Set to 1. Back-compat: if MajorVersion > 4096, treat as v0.MajorVersion, e.g. 0.4096
  UINT16                   MinorVersion; // Set to 0.
  RAW_DUMP_HEADER_FLAGS    Flags;
  UINT64                   OsData;
  UINT64                   CpuContext;            // Deprecated, set to 0.
  UINT32                   ResetTrigger;          // Deprecated, set to 0.
  UINT64                   DumpSize;              // Size of the written dump data from start of RAW_DUMP_HEADER to end of last section's data.
  UINT64                   TotalDumpSizeRequired; // If dump fails due to insufficient storage, set to the storage size required.
  UINT32                   SectionsCount;         // Number of RAW_DUMP_SECTION_HEADER structures following this header.
  // Immediately followed (no padding) by: RAW_DUMP_SECTION_HEADER Sections[SectionsCount];
} RAW_DUMP_HEADER;

STATIC_ASSERT (
               sizeof (RAW_DUMP_HEADER) == 56,
               "RAW_DUMP_HEADER should be 56 bytes"
               );

// Architecture for RAW_DUMP_SECTION_INFORMATION_SYSTEM_INFORMATION.
typedef enum {
  RAW_DUMP_ARCHITECTURE_ARM64 = 0,
  RAW_DUMP_ARCHITECTURE_X64   = 1,
} RAW_DUMP_ARCHITECTURE;

STATIC_ASSERT (
               sizeof (RAW_DUMP_ARCHITECTURE) == 4,
               "RAW_DUMP_ARCHITECTURE should be 4 bytes"
               );

// Flags for RAW_DUMP_SECTION_HEADER.
typedef enum {
  RAW_DUMP_SECTION_HEADER_NONE                 = 0,
  RAW_DUMP_SECTION_HEADER_DUMP_VALID           = 0x01,  // This section was successfully written.
  RAW_DUMP_SECTION_HEADER_INSUFFICIENT_STORAGE = 0x02,  // This section was not written due to insufficient storage.
} RAW_DUMP_SECTION_HEADER_FLAGS;

STATIC_ASSERT (
               sizeof (RAW_DUMP_SECTION_HEADER_FLAGS) == 4,
               "RAW_DUMP_SECTION_HEADER_FLAGS should be 4 bytes"
               );

// Type for RAW_DUMP_SECTION_HEADER.
typedef enum {
  RAW_DUMP_SECTION_NONE               = 0,
  RAW_DUMP_SECTION_DDR_RANGE          = 1,
  RAW_DUMP_SECTION_CPU_CONTEXT        = 2,
  RAW_DUMP_SECTION_SV_SPECIFIC        = 3,
  RAW_DUMP_SECTION_DUMP_REASON        = 4,
  RAW_DUMP_SECTION_SYSTEM_INFORMATION = 5,
} RAW_DUMP_SECTION_TYPE;

STATIC_ASSERT (
               sizeof (RAW_DUMP_SECTION_TYPE) == 4,
               "RAW_DUMP_SECTION_TYPE should be 4 bytes"
               );

// Information for RAW_DUMP_SECTION_HEADER when Type is DDR_RANGE.
typedef struct {
  UINT64    Base;
} RAW_DUMP_SECTION_INFORMATION_DDR_RANGE;

#define RAW_DUMP_DDR_RANGE_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_DDR_RANGE_CURRENT_MINOR_VERSION  0

// Information for RAW_DUMP_SECTION_HEADER when Type is CPU_CONTEXT.
typedef struct {
  UINT16    Architecture; // PROCESSOR_ARCHITECTURE_* from OfflineDumpCpuContext.h.
  UINT32    CoreCount;
  UINT32    ContextSize; // sizeof(CONTEXT_*) from OfflineDumpCpuContext.h.
} RAW_DUMP_SECTION_INFORMATION_CPU_CONTEXT;

#define RAW_DUMP_CPU_CONTEXT_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_CPU_CONTEXT_CURRENT_MINOR_VERSION  0

// Information for RAW_DUMP_SECTION_HEADER when Type is SV_SPECIFIC.
typedef struct {
  UINT8    SVSpecificData[16];
} RAW_DUMP_SECTION_INFORMATION_SV_SPECIFIC;

#define RAW_DUMP_SV_SPECIFIC_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_SV_SPECIFIC_CURRENT_MINOR_VERSION  0

// Information for RAW_DUMP_SECTION_HEADER when Type is DUMP_REASON.
typedef struct {
  UINT32    Parameter1; // Primary bucketization parameter
  UINT32    Parameter2; // Secondary bucketization parameter
  UINT32    Parameter3; // Reserved
  UINT32    Parameter4; // Reserved
} RAW_DUMP_SECTION_INFORMATION_DUMP_REASON;

#define RAW_DUMP_DUMP_REASON_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_DUMP_REASON_CURRENT_MINOR_VERSION  0

// Information for RAW_DUMP_SECTION_HEADER when Type is SYSTEM_INFORMATION.
typedef struct {
  CHAR8                    Vendor[4];   // 4-character vendor ACPI ID.
  CHAR8                    Platform[8]; // 8-character silicon vendor platform ID.
  RAW_DUMP_ARCHITECTURE    Architecture;
} RAW_DUMP_SECTION_INFORMATION_SYSTEM_INFORMATION;

#define RAW_DUMP_SYSTEM_INFORMATION_CURRENT_MAJOR_VERSION  1
#define RAW_DUMP_SYSTEM_INFORMATION_CURRENT_MINOR_VERSION  0

// Information for RAW_DUMP_SECTION_HEADER. Active field selected by Type.
typedef union {
  RAW_DUMP_SECTION_INFORMATION_DDR_RANGE             DdrRange;
  RAW_DUMP_SECTION_INFORMATION_CPU_CONTEXT           CpuContext;
  RAW_DUMP_SECTION_INFORMATION_SV_SPECIFIC           SVSpecific;
  RAW_DUMP_SECTION_INFORMATION_DUMP_REASON           DumpReason;
  RAW_DUMP_SECTION_INFORMATION_SYSTEM_INFORMATION    SystemInformation;
  UINT8                                              Bytes[16];
} RAW_DUMP_SECTION_INFORMATION;

STATIC_ASSERT (
               sizeof (RAW_DUMP_SECTION_INFORMATION) == 16,
               "RAW_DUMP_SECTION_INFORMATION should be 16 bytes"
               );

// Raw dump section header - array of section headers follows the RAW_DUMP_HEADER.
typedef struct {
  RAW_DUMP_SECTION_HEADER_FLAGS    Flags;
  UINT16                           MajorVersion; // Varies based on section type. If MajorVersion > 4096, treat as v0.MajorVersion, e.g. 0.4096
  UINT16                           MinorVersion; // Varies based on section type.
  RAW_DUMP_SECTION_TYPE            Type;
  UINT64                           Offset;      // Offset from the start of the RAW_DUMP_HEADER to the start of the section data.
  UINT64                           Size;        // Size of the section data.
  RAW_DUMP_SECTION_INFORMATION     Information; // Varies based on Type.
  CHAR8                            Name[20];
} RAW_DUMP_SECTION_HEADER;

STATIC_ASSERT (
               sizeof (RAW_DUMP_SECTION_HEADER) == 64,
               "RAW_DUMP_SECTION_HEADER should be 64 bytes"
               );

#pragma pack(pop)
#endif // _included_Guid_OfflineDumpHeaders_h

```

`OfflineDumpPkg/Include/Library/OfflineDumpLib.h`:

```h
/*
Microsoft Offline Dump - Functions for working with an Offline Dump.
*/

#ifndef _included_Library_OfflineDumpLib_h
#define _included_Library_OfflineDumpLib_h

#include <Uefi/UefiBaseType.h>
#include <Protocol/OfflineDumpProvider.h>
#include <Protocol/DevicePath.h>

/**
Launches OfflineDumpWrite.efi (located using device path) to write an offline dump
using information from the specified provider.

This function publishes the specified protocol, launches the application specified by
pOfflineDumpWritePath (assumed to be the path to OfflineDumpWrite.efi), and then
un-publishes the protocol.

Specifically, it does the following:

- LoadImage(FALSE, ParentImageHandle, pOfflineDumpWritePath, NULL, 0, &WriteImageHandle);
- InstallProtocolInterface(WriteImageHandle, ..., pProviderProtocol);
- StartImage(WriteImageHandle, NULL, NULL);
- UninstallProtocolInterface(ParentImageHandle, ..., pProviderProtocol);
- UnloadImage(WriteImageHandle);
**/
EFI_STATUS
OfflineDumpWriteExecutePath (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProviderProtocol,
  IN EFI_HANDLE                      ParentImageHandle,
  IN EFI_DEVICE_PATH_PROTOCOL        *pOfflineDumpWritePath
  );

/**
Launches OfflineDumpWrite.efi (previously loaded into memory) to write an offline dump
using information from the specified provider.

This function publishes the specified protocol, launches the application specified by
pOfflineDumpWriteSourceBuffer (assumed to the contents of OfflineDumpWrite.efi), and
then un-publishes the protocol.

Specifically, it does the following:

- LoadImage(FALSE, ParentImageHandle, NULL, pOfflineDumpWritePath, OfflineDumpWriteSourceSize, &WriteImageHandle);
- InstallProtocolInterface(WriteImageHandle, ..., pProviderProtocol);
- StartImage(WriteImageHandle, NULL, NULL);
- UninstallProtocolInterface(ParentImageHandle, ..., pProviderProtocol);
- UnloadImage(WriteImageHandle);
**/
EFI_STATUS
OfflineDumpWriteExecuteMemory (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProviderProtocol,
  IN EFI_HANDLE                      ParentImageHandle,
  IN VOID                            *pOfflineDumpWriteSourceBuffer,
  IN UINTN                           OfflineDumpWriteSourceSize
  );

/**
Returns true if the specified handle represents an offline dump partition.

Specifically, all of the following must be true:

- Handle supports the BlockIo protocol.
- Handle supports the PartitionInfo protocol.
- PartitionInfo Type is GPT.
- PartitionInfo PartitionTypeGUID is gOfflineDumpPartitionTypeGuid.

Consumes:

  BaseMemoryLib
  DebugLib
  UefiBootServicesTableLib
**/
BOOLEAN
HandleIsOfflineDumpPartition (
  IN EFI_HANDLE  DeviceHandle
  );

/**
Simple behavior for locating the partition to use for offline dump:

- Looks through all partitions in the handle table.
- If exactly one Offline Dump partition is found (as determined by
  HandleIsOfflineDumpPartition), returns that partition's device handle.
- If no such partition is found or if more than one such partition is found,
  returns EFI_NOT_FOUND.

Consumes:

  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  UefiBootServicesTableLib
**/
EFI_STATUS
FindOfflineDumpPartitionHandle (
  OUT EFI_HANDLE  *pOfflineDumpDeviceHandle
  );

/**
Simple behavior for locating a raw block device that is not a partition and
does not contain any partitions. This is useful for testing on the emulator.

- Looks through all block I/O devices in the handle table.
- If exactly one non-partition device is found, returns that device's handle.
- If no such device is found or if more than one such device is found,
  returns EFI_NOT_FOUND.

Consumes:

  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  UefiBootServicesTableLib
**/
EFI_STATUS
FindOfflineDumpRawBlockDeviceHandleForTesting (
  OUT EFI_HANDLE  *pRawBlockDeviceHandle
  );

/**
Determines the size of the working buffer needed by the offline dump writer to
perform offline dump memory redaction. The value returned in pScratchBufferLength
can be used for the "Scratch Buffer Length" field of the "Offline Dump Capabilities"
table.

- HighestPhysicalAddress: The highest physical address in the memory map provided to
  Windows, e.g. 0x21FFFFFFFF (128GB of memory + 8GB of holes = 136GB-1).
- pScratchBufferLength: Receives the size of the working buffer needed, in bytes.

This function will return an error if HighestPhysicalAddress is greater than about
127TB because the size of the required scratch buffer would not fit in a UINT32.

This function provides accurate results when the memory map starts at an address
less than 4GB and has no 4GB holes (or larger). If the memory map has large holes,
this function will return a value that is larger than necessary.

For example, on a system with 128GB of memory and ~8GB of scattered holes in the
memory map, the highest physical address might be 0x21FFFFFFFF. This function will
compute the scratch buffer length 4464640 (4360KB) as the sum of:

  - 4KB * ceil(HighestPhysicalAddress / 2^52) = 4KB * 1 = 4KB
  - 4KB * Number of 4TB regions touched by the memory map = 4KB * 1 = 4KB
  - 128KB * Number of 4GB regions touched by the memory map = 128KB * 34 = 4352KB.
  */
EFI_STATUS
GetOfflineDumpRedactionScratchBufferLength (
  IN  UINT64  HighestPhysicalAddress,
  OUT UINT32  *pLength
  );

#endif // _included_Library_OfflineDumpLib_h

```

`OfflineDumpPkg/Include/Library/OfflineDumpWriterLib.h`:

```h
/*
Microsoft Offline Dump - Function to write an Offline Dump.
*/

#ifndef _included_Library_OfflineDumpWriterLib_h
#define _included_Library_OfflineDumpWriterLib_h

#include <Uefi/UefiBaseType.h>
#include <Protocol/OfflineDumpProvider.h>

/**
Writes an offline dump using information from the specified provider.

Static-link with this function to write an offline dump.

Alternatively, invoke OfflineDumpWrite.efi as an application using one of
the OfflineDumpWriteExecutePath or OfflineDumpWriteExecuteMemory functions.

General process:

- Validate protocol fields. Return EFI_UNSUPPORTED if invalid or out of range.
- Call pProvider->Begin(...). If it returns an error, return that error.
- Validate the dump information returned by Begin. If valid, write a dump.
- Call pProvider->End(Status) and then return Status.

Notes:

- OfflineDumpWrite may return an error without calling either Begin or End.
- If Begin returns an error, OfflineDumpWrite will immediately return that error
  without calling End.
- If Begin returns EFI_SUCCESS, OfflineDumpWrite will always call End(Status) and
  will return the same Status as it passed to End.

Consumes:

  BaseLib
  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  SynchronizationLib
  UefiBootServicesTableLib

  BaseCryptLib
  OpensslLib
**/
EFI_STATUS
OfflineDumpWrite (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL const  *pProvider
);

#endif // _included_Library_OfflineDumpWriterLib_h

```

`OfflineDumpPkg/Include/Protocol/OfflineDumpProvider.h`:

```h
/** @file
  Microsoft Offline Dump provider protocol - implemented by platform ISV.

  The ISV implements this protocol to provide dump information to the
  Offline Crash Dump writer and to configure writer behavior.

  - OFFLINE_DUMP_PROVIDER_BEGIN (function pointer)
  - OFFLINE_DUMP_PROVIDER_BEGIN_INFO (struct)
  - OFFLINE_DUMP_PROVIDER_DATA_COPY (function pointer)
  - OFFLINE_DUMP_PROVIDER_DUMP_INFO (struct)
  - OFFLINE_DUMP_PROVIDER_DUMP_OPTIONS (struct)
  - OFFLINE_DUMP_PROVIDER_END (function pointer)
  - OFFLINE_DUMP_PROVIDER_END_INFO (struct)
  - OFFLINE_DUMP_PROVIDER_PROTOCOL (struct)
  - OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION (enum)
  - OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS (function pointer)
  - OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO (struct)
  - OFFLINE_DUMP_PROVIDER_SECTION_INFO (struct)
  - OFFLINE_DUMP_PROVIDER_SECTION_OPTIONS (struct)
  - OFFLINE_DUMP_PROVIDER_SECTION_TYPE (enum)
  - OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_ARM64 (struct)
  - OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_X64 (struct)
  - OFFLINE_DUMP_PROVIDER_SECURE_CONTROL (enum)
**/

#ifndef _included_Protocol_OfflineDumpProvider_h
#define _included_Protocol_OfflineDumpProvider_h

#include <Uefi/UefiBaseType.h>
#include <Guid/OfflineDumpConfig.h>     // OFFLINE_DUMP_USE_CAPABILITY_FLAGS
#include <Guid/OfflineDumpEncryption.h> // OFFLINE_MEMORY_DUMP_ENCRYPTION_ALGORITHM
#include <Guid/OfflineDumpHeaders.h>    // FLAGS, ARCHITECTURE, SECTION_INFORMATION

// {56B79CF2-9D1F-42FC-B45A-16BBBA5C623A}
#define OFFLINE_DUMP_PROVIDER_PROTOCOL_GUID \
  { 0x56b79cf2, 0x9d1f, 0x42fc, { 0xb4, 0x5a, 0x16, 0xbb, 0xba, 0x5c, 0x62, 0x3a } }

/**
  Protocol implemented by platform ISV to provide dump information to the Offline
  Crash Dump Writer (OfflineDumpWrite) and to configure Writer behavior.

When OfflineDumpWrite is invoked as a function:

  - ISV implements this protocol.
  - ISV invokes OfflineDumpWrite, passing a pointer to the protocol.
    - OfflineDumpWrite calls the protocol's Begin function to get dump parameters.
    - OfflineDumpWrite writes the dump data, periodically calling the protocol's ReportProgress function.
    - OfflineDumpWrite calls the protocol's End function, providing status and statistics.
    - OfflineDumpWrite returns status.
  - ISV updates dump status variables and reboots.

When OfflineDumpWrite.efi is invoked as an application:

  - ISV implements this protocol.
  - ISV invokes an OfflineDumpWriteExecute helper, passing a pointer to the protocol
    and the path to the OfflineDumpWrite.efi application binary.
    - OfflineDumpWriteExecute installs the protocol instance into the EFI handle table.
    - OfflineDumpWriteExecute loads and starts the OfflineDumpWrite.efi application.
    - OfflineDumpWrite.efi calls the protocol's Begin function to get dump parameters.
    - OfflineDumpWrite.efi writes the dump data, periodically calling the protocol's ReportProgress function.
    - OfflineDumpWrite.efi calls the protocol's End function, providing status and statistics.
    - OfflineDumpWrite returns status.
    - OfflineDumpWriteExecute returns status.
  - ISV updates dump status variables and reboots.

**/
typedef struct _OFFLINE_DUMP_PROVIDER_PROTOCOL OFFLINE_DUMP_PROVIDER_PROTOCOL;

/**
  Revision of the OFFLINE_DUMP_PROVIDER_PROTOCOL interface that a component supports.

  The protocol implementation (provider) specifies its revision in the Revision field
  of the OFFLINE_DUMP_PROVIDER_PROTOCOL structure. The writer uses this value to
  determine which fields of the protocol structure can be accessed. It will never access
  fields that were added in a later revision and will use a default value instead
  (typically NULL or 0).

  The writer implementation specifies its revision value when calling the Begin
  function. The provider uses this value to determine which features the
  writer supports. For example, if a new section type is added in a future version of the
  specification, the provider can use the revision value to determine whether
  the new section type will be recognized.

**/
typedef enum {
  OfflineDumpProviderProtocolRevision_1_0     = 0x00010000,
  OfflineDumpProviderProtocolRevision_Current = OfflineDumpProviderProtocolRevision_1_0,
} OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION) == 4,
               "OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION should be 4 bytes"
               );

/**
  Value that reflects any restriction that the high-level operating system (typically the
  trusted OS) has placed on the dump writer's behavior. This enumeration is used in the
  SecureControl field of the OFFLINE_DUMP_PROVIDER_DUMP_INFO structure.
**/
typedef enum {
  //
  // This value indicates that the high-level operating system has prohibited generation
  // of offline dumps. For example, the high-level OS might set this value if it has
  // started a trusted OS kernel, has secrets in memory that it does not want to be
  // written to the dump, and has not yet configured dump redaction.
  //
  // If this value is specified, the dump writer will not write a dump and will
  // return an error.
  //
  OfflineDumpProviderSecureControl_DumpNotAllowed,

  //
  // This value indicates that the high-level operating system has not placed any
  // restrictions on dump generation. Typically this means that the high-level OS has not
  // started a trusted OS and that no secure-kernel secrets are expected to be in memory.
  //
  // This is the default value (the value that the writer should use if the high-level
  // OS has not set any restrictions).
  //
  // If this value is specified, the dump writer will ignore the
  // SecureConfiguration field and will not attempt to redact any
  // secure-kernel data from the dump.
  //
  OfflineDumpProviderSecureControl_DumpAllowed,

  //
  // This value indicates that the high-level operating system allows an offline dump
  // only if secure-kernel data is redacted from the dump. For example, the high-level
  // OS might set this value if it has started a trusted OS kernel, has secrets in memory
  // that it does not want to be written to the dump, and has successfully configured
  // dump redaction.
  //
  // If this value is specified, the dump writer will use the
  // SecureConfiguration field to determine how to redact secure-kernel
  // data from the dump. If the SecureConfiguration field does not provide
  // valid configuration data, the dump writer will not write the dump and will
  // return an error.
  //
  OfflineDumpProviderSecureControl_RedactedDumpAllowed,
} OFFLINE_DUMP_PROVIDER_SECURE_CONTROL;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_PROVIDER_SECURE_CONTROL) == 4,
               "OFFLINE_DUMP_PROVIDER_SECURE_CONTROL should be 4 bytes"
               );

/**
  Type of the section provided by the provider.

  This enumeration type is used in the OFFLINE_DUMP_PROVIDER_SECTION_INFO structure to
  indicate the type of the section being specified. The writer uses this value to determine
  how to process the section when generating a dump.

  This is not always the same as the RAW_DUMP_SECTION_TYPE enumeration. At present,
  OfflineDumpProviderSectionType_DdrRange maps closely to RAW_DUMP_SECTION_DDR_RANGE and
  OfflineDumpProviderSectionType_SvSpecific maps closely to RAW_DUMP_SECTION_SV_SPECIFIC, but
  future OFFLINE_DUMP_PROVIDER_SECTION_TYPE values may not always have a direct mapping to
  RAW_DUMP_SECTION_TYPE values.
**/
typedef enum {
  //
  // Invalid section type.
  //
  OfflineDumpProviderSectionType_None = 0,

  //
  // DDR range section. This section describes a range of DDR memory. This maps closely to
  // RAW_DUMP_SECTION_DDR_RANGE.
  //
  // Implies the following:
  //
  // - The data will generally be written to the dump as a RAW_DUMP_SECTION_DDR_RANGE section
  //   unless it contains non-VTL0 memory, in which case it may be redacted or split into multiple
  //   sections.
  // - The DdrRange variant of the Information union should be used.
  // - The section's name should start with "DDR".
  //
  OfflineDumpProviderSectionType_DdrRange,

  //
  // SV-specific section. This section vendor-defined data. This maps closely to
  // RAW_DUMP_SECTION_SV_SPECIFIC.
  //
  // Implies the following:
  //
  // - The data will be written to the dump as a RAW_DUMP_SECTION_SV_SPECIFIC section.
  // - The SVSpecific variant of the Information union should be used.
  //
  OfflineDumpProviderSectionType_SvSpecific,
} OFFLINE_DUMP_PROVIDER_SECTION_TYPE;

/**
  Callback used for reading the section data, e.g. to access fenced memory regions.
  Used in the OFFLINE_DUMP_PROVIDER_SECTION_INFO structure's DataCopyCallback field.

  @param[in]  pDataStart      The value of the opaque pDataStart parameter that was set in
                              OFFLINE_DUMP_PROVIDER_SECTION_INFO.
  @param[in]  Offset          Offset into the section. This will always be less than the DataSize
                              parameter that was set in OFFLINE_DUMP_PROVIDER_SECTION_INFO.
                              This will always be a multiple of 16.
  @param[in]  Size            Number of bytes to read. Offset + Size will always be less than or
                              equal to the DataSize parameter that was set in
                              OFFLINE_DUMP_PROVIDER_SECTION_INFO. Size will always be a
                              multiple of 16 unless DataSize was not, in which case the final call
                              to this callback will have a Size that is not a multiple of 16 (to
                              read the last bytes).
  @param[out] pDestinationPos Destination buffer for the data. Buffer has room for Size bytes.
                              Important: Copy to pDestinationPos[0..Size]. Do not add Offset to this
                              pointer.

  @retval TRUE  The data was successfully copied to pDestinationPos.
  @retval FALSE The data could not be copied to pDestinationPos. The section will be truncated
                to the last successfully-copied offset and the section will be marked as invalid.
                (Does not make the dump invalid. Does not prevent writing subsequent sections.)

  Section data will be copied by code that looks approximately like this:

  UINT8 DestinationBuffer[MultipleOf16];
  for (UINT64 Offset = 0; Offset < DataSize; Offset += sizeof(DestinationBuffer)) {
    UINTN Size = (UINTN)MIN(DataSize - Offset, sizeof(DestinationBuffer));
    if (DataCopyCallback == NULL) {
      // Fast path - treat pDataStart as a pointer to normal readable memory.
      // May implement some optimizations, e.g. may inline data processing.
      CopyMem(DestinationBuffer, (UINT8 const*)pDataStart + Offset, Size);
    } else {
      // Flexible path - treat pDataStart as an opaque context value for the callback.
      if (!DataCopyCallback(pProtocol, pDataStart, Offset, Size, DestinationBuffer)) {
        Section->Flags &= ~RAW_DUMP_SECTION_HEADER_DUMP_VALID; // Mark section as invalid.
        Section->Size = Offset; // Truncate section size to the last successfully-copied offset.
        break; // Stop copying data for this section (continue to other sections).
      }
    }
    AppendToDump(DestinationBuffer, Size);
  }

**/
typedef
  BOOLEAN
(EFIAPI *OFFLINE_DUMP_PROVIDER_DATA_COPY)(
                                          IN VOID const *pDataStart,
                                          IN UINTN      Offset,
                                          IN UINTN      Size,
                                          OUT UINT8     *pDestinationPos
                                          );

/**
  Information from the writer that is passed to the provider's Begin function.

  The writer provides this information to the protocol implementation (provider) when calling the
  Begin function. The provider uses this information to configure its behavior.

  If the writer and the provider are compiled against different revisions of the
  protocol, they may disagree on the size of this structure. The provider's Begin
  function should only read the first BeginInfoSize bytes of the pBeginInfo buffer. One way
  to handle this is to use a copy of the structure. For example, the Begin function might have
  code like this:

    OFFLINE_DUMP_PROVIDER_BEGIN_INFO BeginInfoCopy = { 0 };
    CopyMem(&BeginInfoCopy, pBeginInfo, MIN(sizeof(BeginInfoCopy), BeginInfoSize));
    // ... Use BeginInfoCopy rather than reading from pBeginInfo ...
**/
typedef struct {
  //
  // The revision of the writer that is calling this function.
  //
  // The protocol implementation (provider) uses this value to determine which features the
  // writer supports. For example, if a new section type is added in a future version of the
  // specification, the provider can use the revision value to determine whether
  // the new section type will be recognized by the current version of the writer.
  //
  OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION    WriterRevision;

  //
  // The capability flags that are requested by the high-level operating system.
  //
  OFFLINE_DUMP_USE_CAPABILITY_FLAGS          UseCapabilityFlags;
} OFFLINE_DUMP_PROVIDER_BEGIN_INFO;

/**
  Information from the writer that is passed to the provider's ReportProgress function.

  The writer provides this information to the protocol implementation (provider) when calling the
  ReportProgress function.

  If the writer and the provider are compiled against different revisions of the
  protocol, they may disagree on the size of this structure. The provider's ReportProgress
  function should only read the first ProgressInfoSize bytes of the pProgressInfo buffer. One way
  to handle this is to use a copy of the structure. For example, the Progress function might have
  code like this:

    OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO ProgressInfoCopy = { 0 };
    CopyMem(&ProgressInfoCopy, pProgressInfo, MIN(sizeof(ProgressInfoCopy), ProgressInfoSize));
    // ... Use ProgressInfoCopy rather than reading from pProgressInfo ...
**/
typedef struct {
  // The total number of bytes expected to be written.
  UINT64    ExpectedBytes;

  // The number of bytes written so far.
  UINT64    WrittenBytes;
} OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO;

/**
  Information from the writer that is passed to the provider's End function.

  The writer provides this information to the protocol implementation (provider) when calling the
  End function.

  If the writer and the provider are compiled against different revisions of the
  protocol, they may disagree on the size of this structure. The provider's End
  function should only read the first EndInfoSize bytes of the pEndInfo buffer. One way
  to handle this is to use a copy of the structure. For example, the End function might have
  code like this:

    OFFLINE_DUMP_PROVIDER_END_INFO EndInfoCopy = { 0 };
    CopyMem(&EndInfoCopy, pEndInfo, MIN(sizeof(EndInfoCopy), EndInfoSize));
    // ... Use EndInfoCopy rather than reading from pEndInfo ...
**/
typedef struct {
  //
  // EFI_SUCCESS if the dump was successfully written. An error code otherwise.
  // Note that if OfflineDumpWrite calls End(Status), OfflineDumpWrite will
  // always return the same Status.
  //
  EFI_STATUS            Status;

  //
  // The encryption algorithm that was used for full-dump encryption, or NONE if not encrypted.
  //
  ENC_DUMP_ALGORITHM    EncryptionAlgorithm;

  //
  // The amount of storage space available for the dump.
  //
  UINT64                SizeAvailable;

  //
  // The amount of storage space required for the dump.
  //
  // This may be greater than SizeAvailable, indicating that the dump was truncated.
  //
  UINT64                SizeRequired;
} OFFLINE_DUMP_PROVIDER_END_INFO;

/**
  Information used to perform redaction of secure-kernel CPU context information for
  ARM64. This structure is used in the pSecureCpuContexts field of
  OFFLINE_DUMP_PROVIDER_DUMP_INFO.
*/
typedef struct {
  UINT64 TTBR1_EL1; // Translation Table Base Register 1 (EL1)
} OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_ARM64;

/**
  Information used to perform redaction of secure-kernel CPU context information for
  X64. This structure is used in the pSecureCpuContexts field of
  OFFLINE_DUMP_PROVIDER_DUMP_INFO.
*/
typedef struct {
  UINT64 Reserved1; // Reserved
} OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_X64;

/**
  Information provided by the protocol implementation (provider) to the writer to control
  writer behavior. This information is provided in the Options field of
  OFFLINE_DUMP_PROVIDER_DUMP_INFO.
**/
typedef struct {
  //
  // Maximum total bytes to allocate for the dump writer's I/O buffers (soft limit). If
  // this is 0, the writer will select a reasonable default.
  //
  // - If BufferMemoryLimit == 0 then ActualBufferMemoryLimit will be set to a default
  //   value (currently 3MB).
  // - Else if BufferMemoryLimit < BlockSize * ActualBufferCount then
  //   ActualBufferMemoryLimit will be set to BlockSize * ActualBufferCount.
  // - Else ActualBufferMemoryLimit will be set to BufferMemoryLimit.
  //
  // This value is used to determine
  // ActualBufferSize = RoundDownToBlockSize(ActualBufferMemoryLimit / ActualBufferCount).
  //
  // Note that this does not cap total memory usage of the writer. The dump writer also
  // allocates several other buffers, e.g. it allocates SectionCount * 64 bytes to track
  // section headers.
  //
  UINT32    BufferMemoryLimit;

  //
  // Number of data buffers to use for async I/O. Significant only if the device supports
  // async I/O (EFI_BLOCK_IO2_PROTOCOL). If this is 0, the writer will select a
  // reasonable default.
  //
  // Current implementation:
  //
  // - If the device only supports EFI_BLOCK_IO_PROTOCOL or if DisableBlockIo2 is TRUE
  //   then ActualBufferCount will be set to 1.
  // - Else if BufferCount == 0 then ActualBufferCount will be set to a default (currently 3).
  // - Else if BufferCount < 2 then ActualBufferCount will be set to 2.
  // - Else ActualBufferCount will be set to BufferCount.
  //
  UINT32    BufferCount : 8;

  //
  // If TRUE, the writer will use EFI_BLOCK_IO_PROTOCOL (synchronous I/O) even if the
  // device supports EFI_BLOCK_IO2_PROTOCOL. Set this to improve performance if a
  // device implements the BLOCK_IO2 protocol but does not actually implement async
  // operations, e.g. the EDK2 ATA driver.
  //
  // Implementation detail: in addition to forcing the use of EFI_BLOCK_IO_PROTOCOL, this
  // flag also affects how the writer manages buffers. Since the device does not support
  // async I/O, the writer will allocate one large buffer instead of several smaller buffers.
  //
  UINT32    DisableBlockIo2  : 1;

  //
  // For testing/debugging purposes.
  //
  // If TRUE, the writer will not set the DUMP_VALID flag when finalizing the dump.
  //
  UINT32    ForceDumpInvalid : 1;

  //
  // For testing/debugging purposes. Production environment MUST NOT set this flag.
  //
  // If TRUE, the writer will ignore the full-dump encryption UEFI variables and will
  // always produce an unencrypted dump.
  //
  UINT32    ForceUnencrypted : 1;

  //
  // For testing/debugging purposes. Production environment MUST NOT set this flag.
  //
  // If TRUE, the writer will ignore the SecureControl field and will
  // behave as if SecureControl == OfflineDumpProviderSecureControl_DumpAllowed.
  //
  UINT32    ForceDumpAllowed : 1;

  //
  // Reserved - must be set to 0.
  //
  UINT32    Reserved1        : 20;
} OFFLINE_DUMP_PROVIDER_DUMP_OPTIONS;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_PROVIDER_DUMP_OPTIONS) == 8,
               "OFFLINE_DUMP_PROVIDER_DUMP_OPTIONS should be 8 bytes"
               );

/**
  Information provided by the protocol implementation (provider) to the writer to control section
  behavior. This information is provided in the Options field of OFFLINE_DUMP_PROVIDER_SECTION_INFO.
**/
typedef struct {
  //
  // Normally FALSE. If TRUE, indicates that the writer should not set the DUMP_VALID flag
  // for the section.
  //
  UINT32    ForceSectionInvalid : 1;

  //
  // Reserved - must be set to 0.
  //
  UINT32    Reserved1           : 31;

  //
  // Reserved - must be set to 0.
  //
  UINT32    Reserved2;
} OFFLINE_DUMP_PROVIDER_SECTION_OPTIONS;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_PROVIDER_SECTION_OPTIONS) == 8,
               "OFFLINE_DUMP_PROVIDER_SECTION_OPTIONS should be 8 bytes"
               );

/**
  Information provided by the protocol implementation (provider) to the writer about a section to be included
  in the dump. This information is provided in the pSections field of OFFLINE_DUMP_PROVIDER_DUMP_INFO.

  Note that in some cases, a single OFFLINE_DUMP_PROVIDER_SECTION_INFO element may result in
  multiple sections being written to the dump, or it may be ignored entirely. For example:

  - A single DdrRange section may result in multiple DDR sections being written to the dump, e.g. if
    parts of the section contain secure-kernel data and need to be encrypted.
  - If the writer does not support the specified section, it will ignore the section and will not write
    it to the dump.
**/
typedef struct {
  //
  // Configuration options for the section. Usually the default (0) values are ok.
  //
  OFFLINE_DUMP_PROVIDER_SECTION_OPTIONS    Options;

  //
  // Section type, e.g. DdrRange or SvSpecific.
  //
  OFFLINE_DUMP_PROVIDER_SECTION_TYPE       Type;

  //
  // Normally NONE. Should not include DUMP_VALID or INSUFFICIENT_STORAGE.
  //
  RAW_DUMP_SECTION_HEADER_FLAGS            Flags;

  //
  // Section name. Ends at first '\0', or at 20 chars.
  // If this is set to NULL or "" then the writer will generate a default name like
  // "DDR-004.bin" for the section.
  //
  // Section names should be unique and should be valid NTFS file names (not checked).
  // DdrRange section names should start with "DDR".
  //
  CHAR8 const                     *pName;

  //
  // Additional information about the section. The format of this information depends on the
  // section type. For example, if Type=DdrRange, the Information.DdrRange field of the union
  // must be filled-in.
  //
  RAW_DUMP_SECTION_INFORMATION    Information;

  //
  // Size of the section data.
  //
  UINT64                          DataSize;

  //
  // If DataCopyCallback == NULL, this is a pointer to the section data (must be normal readable memory).
  //
  // If DataCopyCallback != NULL, this is an opaque context value that will be passed to DataCopyCallback.
  //
  VOID const                      *pDataStart;

  //
  // If DataCopyCallback == NULL, the writer will treat pDataStart as a pointer to normal readable memory
  // and will access it directly. (Preferred - this allows the writer to optimize the data copy.)
  //
  // If DataCopyCallback != NULL, the writer will treat pDataStart as an opaque context value and will call
  // DataCopyCallback as needed to read the section data. This might be used for data that is
  // generated/filtered on-the-fly or for data that is copied by a co-processor from a fenced region.
  //
  OFFLINE_DUMP_PROVIDER_DATA_COPY    DataCopyCallback;

  //
  // Must be set to NULL. (Potential future use: extended section configuration.)
  //
  VOID const                         *Reserved1;
} OFFLINE_DUMP_PROVIDER_SECTION_INFO;

STATIC_ASSERT (
               sizeof (OFFLINE_DUMP_PROVIDER_SECTION_INFO) == 72,
               "OFFLINE_DUMP_PROVIDER_SECTION_INFO should be 72 bytes"
               );

/**
  Dump configuration information returned to the writer by the provider's
  Begin function.

  If the writer and the provider are compiled against different revisions of the
  protocol, they may disagree on the size of this structure. The provider's Begin
  function should only write the first DumpInfoSize bytes of the pDumpInfo buffer. One way
  to handle this is to use a copy of the structure. For example, the Begin function might have
  code like this:

    OFFLINE_DUMP_PROVIDER_DUMP_INFO DumpInfoCopy = { 0 };
    // ... Initialize DumpInfoCopy rather than writing to pDumpInfo ...
    CopyMem(pDumpInfo, &DumpInfoCopy, MIN(DumpInfoSize, sizeof(DumpInfoCopy)));
*/
typedef struct {
  //
  // Configuration options for the writer, including options for adjusting the I/O
  // buffer allocation (for tuning I/O performance and memory usage). Usually the default
  // (0) values are ok.
  //
  OFFLINE_DUMP_PROVIDER_DUMP_OPTIONS    Options;

  //
  // The block device to which the dump should be written, or NULL for default device.
  //
  // If set to non-NULL, the writer will use the specified device. The device must implement
  // EFI_BLOCK_IO2_PROTOCOL (preferred) or EFI_BLOCK_IO_PROTOCOL. Normally the device is the
  // handle of a partition, not the handle of a physical device. The dump will be written
  // directly to this device, starting at LBA 0 (no filesystem is involved).
  //
  // If set to NULL, the writer will attempt to locate an appropriate device, guided by the
  // value of the OfflineMemoryDumpUseCapability UEFI variable. If the writer is unable to
  // find an appropriate device, the writer will fail to write a dump and will end the dump
  // with status EFI_NOT_FOUND.
  //
  EFI_HANDLE    BlockDevice;

  //
  // Pointer to an OFFLINE_DUMP_PROVIDER_SECTION_INFO[SectionCount] array with the
  // information for DdrRange and SvSpecific sections to be included in the dump.
  //
  // This should not include CPU_CONTEXT, DUMP_REASON, or SYSTEM_INFORMATION sections.
  // The writer will automatically add these sections based on the information provided
  // below.
  //
  OFFLINE_DUMP_PROVIDER_SECTION_INFO const    *pSections;

  //
  // Number of elements in the pSections array.
  //
  UINT32                                      SectionCount;

  //
  // Indicates the CPU architecture of the system. This is used in the generated
  // CPU_CONTEXT and SYSTEM_INFORMATION sections.
  //
  RAW_DUMP_ARCHITECTURE                       Architecture;

  //
  // Pointer to an array of CPU context structures, one for each core on the system. This
  // is used in the generated CPU_CONTEXT section.
  //
  // - If Architecture == RAW_DUMP_ARCHITECTURE_ARM64, this should point at a
  //   CONTEXT_ARM64[CpuContextCount] array.
  // - If Architecture == RAW_DUMP_ARCHITECTURE_X64, this should point at a
  //   CONTEXT_AMD64[CpuContextCount] array.
  //
  // The CONTEXT_ARM64 and CONTEXT_AMD64 structures are defined in <Guid/OfflineDumpCpuContext.h>.
  //
  VOID const    *pCpuContexts;

  //
  // Number of elements in the pCpuContexts array (number of cores on the system).
  //
  UINT32        CpuContextCount;

  //
  // The size of each element in the pCpuContexts array.
  // This must be a multiple of 8 (alignment for 64-bit registers).
  //
  // - If Architecture == RAW_DUMP_ARCHITECTURE_ARM64, this should be sizeof(CONTEXT_ARM64).
  // - If Architecture == RAW_DUMP_ARCHITECTURE_X64, this should be sizeof(CONTEXT_AMD64).
  //
  // The CONTEXT_ARM64 and CONTEXT_AMD64 structures are defined in <Guid/OfflineDumpCpuContext.h>.
  //
  UINT32                   CpuContextSize;

  //
  // 4-character vendor ACPI ID. This is used in the generated SYSTEM_INFORMATION section.
  //
  CHAR8 const              *pVendor;

  //
  // 8-character silicon vendor platform ID. This is used in the generated SYSTEM_INFORMATION
  // section.
  //
  CHAR8 const              *pPlatform;

  //
  // Bucketization parameters for the dump. These are used in the generated DUMP_REASON
  // section.
  //
  UINT32                   DumpReasonParameters[4];

  //
  // Dump flags. Should not include DUMP_VALID, INSUFFICIENT_STORAGE, or
  // IS_HYPERV_DATA_PROTECTED.
  //
  RAW_DUMP_HEADER_FLAGS    Flags;

  //
  // Reserved (padding to multiple of 8 bytes). Must be set to 0.
  //
  UINT32                   Reserved1;

  //
  // Set to the address of a buffer containing secure kernel configuration data from
  // the high-level operating system. This is used to redact secure-kernel secrets
  // when generating the offline dump.
  //
  // This value should be obtained from trusted firmware.
  // The firmware should provide a CSRT "Offline Dump Capabilities" entry. The entry
  // includes a "Configuration SMC ID" and a "Control SMC ID". If the high-level OS
  // requires offline dump redaction, it will invoke the  SMCs to apply the necessary
  // restrictions.
  //
  // - Trusted firmware should store pOfflineDumpSecureConfiguration and
  //   OfflineDumpSecureConfigurationSize variables in secure (fenced) memory. The values
  //   should be initialized to { NULL, 0 }.
  // - The high-level OS may invoke the "Offline Dump Configuration" SMC to change the
  //   value of the variables. The SMC handler should update its stored value
  //   accordingly.
  // - If a crash occurs, the firmware should save the referenced buffer
  //   so that it can be used during offline dump generation. During generation,
  //   the variable values from trusted firmware are used to set the
  //   pSecureConfiguration and SecureConfigurationSize fields.
  //
  VOID const    *pSecureConfiguration;

  //
  // Size of the secure offline dump configuration data provided by the OS via SMC, or
  // 0 if none.
  //
  UINT32        SecureConfigurationSize;

  //
  // Set to a value indicating any restrictions that the high-level operating system has
  // placed on the dump writer's behavior.
  //
  // This value should be obtained from trusted firmware.
  // The firmware should provide a CSRT "Offline Dump Capabilities" entry. The entry
  // includes a "Configuration SMC ID" and a "Control SMC ID". If the high-level OS
  // requires offline dump redaction, it will invoke the  SMCs to apply the necessary
  // restrictions.
  //
  // - Trusted firmware should store an OfflineDumpSecureControl variable in secure (fenced)
  //   memory. The value should be initialized to OfflineDumpProviderSecureControl_DumpAllowed (1).
  // - The high-level OS may invoke the "Offline Dump Control" SMC to change the value
  //   of the OfflineDumpSecureControl variable. The SMC handler should update its stored value
  //   accordingly.
  // - If a crash occurs, the firmware should save the value of the OfflineDumpSecureControl
  //   variable so that it can be used during offline dump generation. During generation,
  //   the variable value from trusted firmware is used to set the SecureControl
  //   field.
  //
  // This value MUST reflect the true state of the high-level operating system's restrictions.
  // In a debug scenario where the high-level operating system's restrictions need to be
  // ignored, use the ForceDumpAllowed option instead of setting this field to an inaccurate
  // value.
  //
  // The writer uses this value to determine how to redact secure-kernel CPU and memory.
  //
  // - If the ForceDumpAllowed option is set, the writer will ignore this field and will
  //   write the dump with no redaction.
  // - If the ForceDumpAllowed option is unset and this value is set to Allowed, the
  //   writer will generate an unredacted dump.
  // - If the ForceDumpAllowed option is unset and this value is set to RedactedDumpAllowed,
  //   the writer will generate a redacted dump using the pSecureConfiguration
  //   field to determine how to redact secure-kernel CPU and memory. If the
  //   pSecureConfiguration field is NULL or invalid, the writer will not write
  //   the dump and will return an error.
  // - If the ForceDumpAllowed option is unset and this value is set to any other value, the
  //   writer will not generate a dump and will return an error.
  //
  OFFLINE_DUMP_PROVIDER_SECURE_CONTROL    SecureControl;

  //
  // Pointer to an array of secure context structures, one for each core on the
  // system. Core contexts must be ordered the same way as in the pCpuContexts
  // field (i.e. SecureCpuContexts[N] must be the secure context for the core
  // described by CpuContexts[N]).
  //
  // This field is used when performing CPU context redaction.
  //
  // - If Architecture == RAW_DUMP_ARCHITECTURE_ARM64, this should point at an
  //   OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_ARM64[SecureCpuContextCount] array.
  // - If Architecture == RAW_DUMP_ARCHITECTURE_X64, this should point at an
  //   OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_X64[SecureCpuContextCount] array.
  //
  VOID const    *pSecureCpuContexts;

  //
  // Number of elements in the pSecureCpuContexts array (number of cores on the system).
  // This should be the same as the CpuContextCount field.
  //
  UINT32        SecureCpuContextCount;

  //
  // The size of each element in the pSecureCpuContexts array.
  // This must be a multiple of 8 (alignment for 64-bit registers).
  //
  // - If Architecture == RAW_DUMP_ARCHITECTURE_ARM64, this should be sizeof(OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_ARM64).
  // - If Architecture == RAW_DUMP_ARCHITECTURE_X64, this should be sizeof(OFFLINE_DUMP_PROVIDER_SECURE_CPU_CONTEXT_X64).
  //
  UINT32        SecureCpuContextSize;
} OFFLINE_DUMP_PROVIDER_DUMP_INFO;

/**
  Called by the writer when it is about to begin writing the dump. The provider
  uses this function to identify the revision of the writer, initialize any state needed
  for the dump, and provide information about the dump to the writer.

  @param[in]   pThis              A pointer to the OFFLINE_DUMP_PROVIDER_PROTOCOL instance.
  @param[in]   BeginInfoSize      The size of the pBeginInfo buffer (i.e.
                                  sizeof(OFFLINE_DUMP_PROVIDER_BEGIN_INFO) when the writer was
                                  compiled). The provider should not read more than
                                  this many bytes from the buffer.
  @param[in]   pBeginInfo         A pointer to a buffer that contains information that the
                                  writer provides to the protocol).
  @param[in]   DumpInfoSize       The size of the pDumpInfo buffer (i.e.
                                  sizeof(OFFLINE_DUMP_PROVIDER_DUMP_INFO) when the writer was
                                  compiled). The provider should not write more than
                                  this many bytes to the buffer.
  @param[out]  pDumpInfo          A pointer to a buffer that receives the dump information
                                  (information that the protocol returns to the writer).

  @returns                        EFI_SUCCESS if the dump information was successfully written to
                                  pDumpInfo. An error code if the dump information could not be
                                  written to pDumpInfo (writer will fail writing the dump, will not
                                  invoke the End method, and will return the specified error).
**/
typedef
  EFI_STATUS
(EFIAPI *OFFLINE_DUMP_PROVIDER_BEGIN)(
                                      IN  OFFLINE_DUMP_PROVIDER_PROTOCOL *pThis,
                                      IN  UINTN BeginInfoSize,
                                      IN  OFFLINE_DUMP_PROVIDER_BEGIN_INFO const *pBeginInfo,
                                      IN  UINTN DumpInfoSize,
                                      OUT OFFLINE_DUMP_PROVIDER_DUMP_INFO *pDumpInfo
                                      );

/**
  Called by the writer every few seconds to report on dump progress.

  The provider uses this function to update UI to reflect dump progress.
  For example, the provider might update a progress bar or blink an LED.

  @param[in]   pThis            A pointer to the OFFLINE_DUMP_PROVIDER_PROTOCOL instance.
  @param[in]   ProgressInfoSize The size of the pProgressInfo buffer (i.e.
                                sizeof(OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO) when the writer was
                                compiled). The provider should not read more than
                                this many bytes from the buffer.
  @param[in]   pProgressInfo    A pointer to a buffer that contains information that the
                                writer provides to the protocol).

  @returns                      EFI_SUCCESS if the writer should continue writing the dump.
                                An error code if the writer should stop writing and return the
                                specified error.

**/
typedef
  EFI_STATUS
(EFIAPI *OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS)(
                                                IN OFFLINE_DUMP_PROVIDER_PROTOCOL *pThis,
                                                IN  UINTN ProgressInfoSize,
                                                IN  OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO const *pProgressInfo
                                                );

/**
  Called by the writer when it has finished writing the dump.
  This will be called if and only if the Begin function returned EFI_SUCCESS.

  The provider uses this function to clean up any actions performed by Begin.
  It may also record the status of the dump.

  @param[in] pThis         A pointer to the OFFLINE_DUMP_PROVIDER_PROTOCOL instance.
  @param[in]   EndInfoSize The size of the pEndInfo buffer (i.e.
                           sizeof(OFFLINE_DUMP_PROVIDER_END_INFO) when the writer was
                           compiled). The provider should not read more than
                           this many bytes from the buffer.
  @param[in]   pEndInfo    A pointer to a buffer that contains information that the
                           writer provides to the protocol).

**/
typedef
  VOID
(EFIAPI *OFFLINE_DUMP_PROVIDER_END)(
                                    IN  OFFLINE_DUMP_PROVIDER_PROTOCOL *pThis,
                                    IN  UINTN EndInfoSize,
                                    IN  OFFLINE_DUMP_PROVIDER_END_INFO const *pEndInfo
                                    );

struct _OFFLINE_DUMP_PROVIDER_PROTOCOL {
  OFFLINE_DUMP_PROVIDER_PROTOCOL_REVISION    Revision;
  OFFLINE_DUMP_PROVIDER_BEGIN                Begin;          // Revision_1_0
  OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS      ReportProgress; // Revision_1_0
  OFFLINE_DUMP_PROVIDER_END                  End;            // Revision_1_0
};

// {56B79CF2-9D1F-42FC-B45A-16BBBA5C623A}
extern EFI_GUID  gOfflineDumpProviderProtocolGuid;

#endif // _included_Protocol_OfflineDumpProvider_h

```

`OfflineDumpPkg/Library/OfflineDumpLib/Execute.c`:

```c
#include <OfflineDumpLib.h>
#include <Library/DebugLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Uefi.h>

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a: " fmt, __func__, ##__VA_ARGS__)

static EFI_STATUS
OfflineDumpWriteExecute (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProviderProtocol,
  IN EFI_HANDLE                      ParentImageHandle,
  IN EFI_DEVICE_PATH_PROTOCOL        *pOfflineDumpWritePath   OPTIONAL,
  IN VOID                            *pOfflineDumpWriteSourceBuffer OPTIONAL,
  IN UINTN                           OfflineDumpWriteSourceSize
  )
{
  EFI_STATUS  Status;
  EFI_HANDLE  WriteImageHandle = NULL;

  Status = gBS->LoadImage (
                           FALSE,
                           ParentImageHandle,
                           pOfflineDumpWritePath,
                           pOfflineDumpWriteSourceBuffer,
                           OfflineDumpWriteSourceSize,
                           &WriteImageHandle
                           );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "LoadImage(OfflineDumpWrite.efi) failed (%r)\n", Status);
    return Status;
  }

  Status = gBS->InstallProtocolInterface (
                                          &WriteImageHandle,
                                          &gOfflineDumpProviderProtocolGuid,
                                          EFI_NATIVE_INTERFACE,
                                          pProviderProtocol
                                          );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "InstallProtocolInterface(ProviderProtocol) failed (%r)\n", Status);
    goto Done;
  }

  Status = gBS->StartImage (WriteImageHandle, NULL, NULL);
  gBS->UninstallProtocolInterface (WriteImageHandle, &gOfflineDumpProviderProtocolGuid, pProviderProtocol);

Done:

  gBS->UnloadImage (WriteImageHandle);
  return Status;
}

EFI_STATUS
OfflineDumpWriteExecutePath (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProviderProtocol,
  IN EFI_HANDLE                      ParentImageHandle,
  IN EFI_DEVICE_PATH_PROTOCOL        *pOfflineDumpWritePath
  )
{
  return OfflineDumpWriteExecute (pProviderProtocol, ParentImageHandle, pOfflineDumpWritePath, NULL, 0);
}

EFI_STATUS
OfflineDumpWriteExecuteMemory (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL  *pProviderProtocol,
  IN EFI_HANDLE                      ParentImageHandle,
  IN VOID                            *pOfflineDumpWriteSourceBuffer,
  IN UINTN                           OfflineDumpWriteSourceSize
  )
{
  return OfflineDumpWriteExecute (pProviderProtocol, ParentImageHandle, NULL, pOfflineDumpWriteSourceBuffer, OfflineDumpWriteSourceSize);
}

```

`OfflineDumpPkg/Library/OfflineDumpLib/OfflineDumpLib.inf`:

```inf
[Defines]

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpLib
  VERSION_STRING                 = 0.1
  FILE_GUID                      = bca01068-c3e1-41f7-808b-4aab6cbd5d65
  MODULE_TYPE                    = DXE_DRIVER
  LIBRARY_CLASS                  = OfflineDumpLib|DXE_DRIVER DXE_CORE UEFI_APPLICATION UEFI_DRIVER

[Sources]

  Execute.c
  Partition.c
  RedactionScratchBufferLength.c
  Variables.c

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec
  MdePkg/MdePkg.dec

[LibraryClasses]

  BaseLib
  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  PrintLib
  SynchronizationLib
  UefiBootServicesTableLib

[Guids]

  gOfflineDumpPartitionTypeGuid
  gOfflineDumpVariableGuid

[Protocols]

  gEfiBlockIoProtocolGuid           ## CONSUMES
  gEfiPartitionInfoProtocolGuid     ## CONSUMES
  gOfflineDumpProviderProtocolGuid  ## CONSUMES

```

`OfflineDumpPkg/Library/OfflineDumpLib/Partition.c`:

```c
#include <OfflineDumpLib.h>
#include <Guid/OfflineDumpConfig.h>

#include <Uefi.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>

#include <Protocol/BlockIo.h>
#include <Protocol/PartitionInfo.h>

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a: " fmt, __func__, ##__VA_ARGS__)

BOOLEAN
HandleIsOfflineDumpPartition (
  IN EFI_HANDLE  DeviceHandle
  )
{
  EFI_STATUS  Status;

  Status = gBS->OpenProtocol (DeviceHandle, &gEfiBlockIoProtocolGuid, NULL, gImageHandle, NULL, EFI_OPEN_PROTOCOL_TEST_PROTOCOL);
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (
                 DEBUG_INFO,
                 "OpenProtocol(BlockIo) failed (%r) for device %p\n",
                 Status,
                 DeviceHandle
                 );
    return FALSE;
  }

  EFI_PARTITION_INFO_PROTOCOL  *pPartitionInfo;

  Status = gBS->OpenProtocol (
                              DeviceHandle,
                              &gEfiPartitionInfoProtocolGuid,
                              (VOID **)&pPartitionInfo,
                              gImageHandle,
                              NULL,
                              EFI_OPEN_PROTOCOL_GET_PROTOCOL
                              );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (
                 DEBUG_INFO,
                 "OpenProtocol(PartitionInfo) failed (%r) for device %p\n",
                 Status,
                 DeviceHandle
                 );
    return FALSE;
  }

  if (pPartitionInfo->Type != PARTITION_TYPE_GPT) {
    DEBUG_PRINT (
                 DEBUG_INFO,
                 "device %p partition Type %u != GPT\n",
                 DeviceHandle,
                 pPartitionInfo->Type
                 );
    return FALSE;
  }

  if (!CompareGuid (&pPartitionInfo->Info.Gpt.PartitionTypeGUID, &gOfflineDumpPartitionTypeGuid)) {
    DEBUG_PRINT (
                 DEBUG_INFO,
                 "device %p PartitionTypeGUID %g != OfflineDump\n",
                 DeviceHandle,
                 &pPartitionInfo->Info.Gpt.PartitionTypeGUID
                 );
    return FALSE;
  }

  DEBUG_PRINT (DEBUG_INFO, "device %p is an OfflineDump partition\n", DeviceHandle);
  return TRUE;
}

EFI_STATUS
FindOfflineDumpPartitionHandle (
  OUT EFI_HANDLE  *pOfflineDumpDeviceHandle
  )
{
  EFI_STATUS  Status;
  EFI_HANDLE  OfflineDumpDeviceHandle = NULL;
  EFI_HANDLE  *pPartitionHandleBuffer = NULL;
  UINTN       PartitionHandleCount    = 0;

  Status = gBS->LocateHandleBuffer (
                                    ByProtocol,
                                    &gEfiPartitionInfoProtocolGuid,
                                    NULL,
                                    &PartitionHandleCount,
                                    &pPartitionHandleBuffer
                                    );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "LocateHandleBuffer(PartitionInfoProtocol) failed (%r)\n", Status);
  } else {
    UINT32  OfflineDumpDeviceCount = 0;
    for (UINTN HandleIndex = 0; HandleIndex != PartitionHandleCount; HandleIndex += 1) {
      EFI_HANDLE  const  PartitionHandle = pPartitionHandleBuffer[HandleIndex];
      if (HandleIsOfflineDumpPartition (PartitionHandle)) {
        OfflineDumpDeviceCount += 1;
        OfflineDumpDeviceHandle = PartitionHandle;
      }
    }

    FreePool (pPartitionHandleBuffer);
    pPartitionHandleBuffer = NULL;

    if (1 != OfflineDumpDeviceCount) {
      DEBUG_PRINT (DEBUG_ERROR, "Found %u offline dump partitions, expected 1\n", OfflineDumpDeviceCount);
      OfflineDumpDeviceHandle = NULL;
      Status                  = EFI_NOT_FOUND;
    } else {
      Status = EFI_SUCCESS;
    }
  }

  ASSERT ((Status == EFI_SUCCESS) == (OfflineDumpDeviceHandle != NULL));
  *pOfflineDumpDeviceHandle = OfflineDumpDeviceHandle;
  return Status;
}

EFI_STATUS
FindOfflineDumpRawBlockDeviceHandleForTesting (
  OUT EFI_HANDLE  *pRawBlockDeviceHandle
  )
{
  EFI_STATUS  Status;
  EFI_HANDLE  RawBlockDeviceHandle  = NULL;
  EFI_HANDLE  *pBlockIoHandleBuffer = NULL;
  UINTN       BlockIoHandleCount    = 0;

  UINT8   *pBlock0    = NULL;
  UINT32  Block0Size  = 0;
  UINT32  Block0Align = 0;

  Status = gBS->LocateHandleBuffer (
                                    ByProtocol,
                                    &gEfiBlockIoProtocolGuid,
                                    NULL,
                                    &BlockIoHandleCount,
                                    &pBlockIoHandleBuffer
                                    );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "LocateHandleBuffer(BlockIoProtocol) failed (%r)\n", Status);
  } else {
    UINT32  RawBlockDeviceCount = 0;
    for (UINTN HandleIndex = 0; HandleIndex != BlockIoHandleCount; HandleIndex += 1) {
      EFI_HANDLE  const  BlockIoHandle = pBlockIoHandleBuffer[HandleIndex];

      EFI_BLOCK_IO_PROTOCOL  *pBlockIo = NULL;
      Status = gBS->OpenProtocol (
                                  BlockIoHandle,
                                  &gEfiBlockIoProtocolGuid,
                                  (VOID **)&pBlockIo,
                                  gImageHandle,
                                  NULL,
                                  EFI_OPEN_PROTOCOL_GET_PROTOCOL
                                  );
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_WARN, "OpenProtocol(BlockIoProtocol) failed (%r) for device %p\n", Status, BlockIoHandle);
        continue;
      }

      if (pBlockIo->Media->LogicalPartition) {
        DEBUG_PRINT (DEBUG_INFO, "Device %p is unusable (logical partition)\n", BlockIoHandle);
        continue;
      }

      if (pBlockIo->Media->ReadOnly) {
        DEBUG_PRINT (DEBUG_INFO, "Device %p is unusable (read-only)\n", BlockIoHandle);
        continue;
      }

      // Skip if the device contains a valid partition table.

      if ((pBlockIo->Media->BlockSize > Block0Size) ||
          (pBlockIo->Media->IoAlign > Block0Align))
      {
        if (pBlock0) {
          FreeAlignedPages (pBlock0, EFI_SIZE_TO_PAGES (Block0Size));
          pBlock0     = 0;
          Block0Size  = 0;
          Block0Align = 0;
        }

        pBlock0 = AllocateAlignedPages (
                                        EFI_SIZE_TO_PAGES (pBlockIo->Media->BlockSize),
                                        pBlockIo->Media->IoAlign
                                        );
        if (!pBlock0) {
          DEBUG_PRINT (DEBUG_ERROR, "AllocateAlignedPages(%u, %u) failed\n", pBlockIo->Media->BlockSize, pBlockIo->Media->IoAlign);
          Status = EFI_OUT_OF_RESOURCES;
          break;
        }

        Block0Size  = pBlockIo->Media->BlockSize;
        Block0Align = pBlockIo->Media->IoAlign;
      }

      Status = pBlockIo->ReadBlocks (
                                     pBlockIo,
                                     pBlockIo->Media->MediaId,
                                     0,
                                     Block0Size,
                                     pBlock0
                                     );
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_WARN, "ReadBlocks(0) failed (%r) for device %p\n", Status, BlockIoHandle);
        continue;
      }

      if ((pBlock0[510] == 0x55) && (pBlock0[511] == 0xAA)) {
        DEBUG_PRINT (DEBUG_INFO, "Device %p is unusable (contains an MBR)\n", BlockIoHandle);
        continue;
      }

      EFI_PARTITION_INFO_PROTOCOL  *pPartitionInfo = NULL;
      Status = gBS->OpenProtocol (
                                  BlockIoHandle,
                                  &gEfiPartitionInfoProtocolGuid,
                                  (VOID **)&pPartitionInfo,
                                  gImageHandle,
                                  NULL,
                                  EFI_OPEN_PROTOCOL_GET_PROTOCOL
                                  );
      if (!EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_INFO, "device %p is unusable (has PartitionInfo)\n", BlockIoHandle);
        continue;
      }

      RawBlockDeviceCount += 1;
      RawBlockDeviceHandle = BlockIoHandle;
      DEBUG_PRINT (DEBUG_INFO, "device %p is USABLE (raw device, not a partition)\n", BlockIoHandle);
    }

    FreePool (pBlockIoHandleBuffer);
    pBlockIoHandleBuffer = NULL;

    if (1 != RawBlockDeviceCount) {
      DEBUG_PRINT (DEBUG_ERROR, "Found %u raw block devices, expected 1\n", RawBlockDeviceCount);
      RawBlockDeviceHandle = NULL;
      Status               = EFI_NOT_FOUND;
    } else {
      Status = EFI_SUCCESS;
    }
  }

  if (pBlock0) {
    FreeAlignedPages (pBlock0, EFI_SIZE_TO_PAGES (Block0Size));
    pBlock0 = NULL;
  }

  ASSERT ((Status == EFI_SUCCESS) == (RawBlockDeviceHandle != NULL));
  *pRawBlockDeviceHandle = RawBlockDeviceHandle;
  return Status;
}

```

`OfflineDumpPkg/Library/OfflineDumpLib/RedactionScratchBufferLength.c`:

```c
#include <OfflineDumpLib.h>
#include <Library/OfflineDumpRedactionMapInternal.h>

#define PAGE_SHIFT     12u
#define BITS_PER_BYTE  8

EFI_STATUS
GetOfflineDumpRedactionScratchBufferLength (
  IN  UINT64  HighestPhysicalAddress,
  OUT UINT32  *pLength
  )
{
  static UINT32 const  Table0Size = 4 * 1024; // Minimal 4KB Table0 covers addresses up to 0xFFFFFFFFFFFFF.

  static UINT32 const    Table1Size            = BITMAPS_PER_TABLE1 * sizeof (UINT32); // Size in indexes * 4 bytes per index = size in bytes
  static unsigned const  AddressPerTable1Shift = BITS_PER_TABLE1_SHIFT + PAGE_SHIFT;   // 2^42 = 4TB

  static UINT32 const    BitmapSize            = BITS_PER_BITMAP / BITS_PER_BYTE;    // size in bits / 8 bits per byte = size in bytes
  static unsigned const  AddressPerBitmapShift = BITS_PER_BITMAP_SHIFT + PAGE_SHIFT; // 2^32 = 4GB

  // Larger addresses require more than 4GB of scratch space.
  if (HighestPhysicalAddress > 0x7FFDFFFFFFFF) {
    *pLength = 0xFFFFF000; // Largest valid scratch space size.
    return EFI_INVALID_PARAMETER;
  }

  UINT32  RequiredBytes = Table0Size;  // Minimal 4KB Table0.
  RequiredBytes += (UINT32)((HighestPhysicalAddress >> AddressPerTable1Shift) + 1) * Table1Size;
  RequiredBytes += (UINT32)((HighestPhysicalAddress >> AddressPerBitmapShift) + 1) * BitmapSize;

  *pLength = RequiredBytes;
  return EFI_SUCCESS;
}

```

`OfflineDumpPkg/Library/OfflineDumpLib/Variables.c`:

```c
#include <Library/OfflineDumpVariables.h>

#include <Uefi.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>

static UINT32 const  mOfflineDumpEncryptionPublicKeyMaxSize = SIZE_64KB;

EFI_STATUS
GetVariableOfflineMemoryDumpUseCapability (
  OUT OFFLINE_DUMP_USE_CAPABILITY_FLAGS  *pFlags
  )
{
  EFI_STATUS  Status;
  UINT32      Data     = 0;
  UINTN       DataSize = sizeof (Data);

  Status = gST->RuntimeServices->GetVariable (
                                              OFFLINE_DUMP_USE_CAPABILITY_VARIABLE_NAME,
                                              &gOfflineDumpVariableGuid,
                                              NULL,
                                              &DataSize,
                                              &Data
                                              );
  *pFlags = Data;
  return Status;
}

EFI_STATUS
GetVariableOfflineMemoryDumpOsData (
  OUT UINT64  *pOsData
  )
{
  EFI_STATUS  Status;
  UINT64      Data     = 0;
  UINTN       DataSize = sizeof (Data);

  Status = gST->RuntimeServices->GetVariable (
                                              OFFLINE_DUMP_OS_DATA_VARIABLE_NAME,
                                              &gOfflineDumpVariableGuid,
                                              NULL,
                                              &DataSize,
                                              &Data
                                              );
  *pOsData = Data;
  return Status;
}

EFI_STATUS
GetVariableOfflineMemoryDumpEncryptionAlgorithm (
  OUT ENC_DUMP_ALGORITHM  *pAlgorithm
  )
{
  EFI_STATUS  Status;
  UINT32      Data     = 0;
  UINTN       DataSize = sizeof (Data);

  Status = gST->RuntimeServices->GetVariable (
                                              OFFLINE_DUMP_ENCRYPTION_ALGORITHM_VARIABLE_NAME,
                                              &gOfflineDumpVariableGuid,
                                              NULL,
                                              &DataSize,
                                              &Data
                                              );
  *pAlgorithm = Data;
  return Status;
}

EFI_STATUS
GetVariableOfflineMemoryDumpEncryptionPublicKey (
  OUT void    **ppRecipientCertificate,
  OUT UINT32  *pRecipientCertificateSize
  )
{
  EFI_STATUS  Status;
  void        *pData;
  UINTN       DataSize = 0;

  Status = gST->RuntimeServices->GetVariable (
                                              OFFLINE_DUMP_ENCRYPTION_PUBLIC_KEY_VARIABLE_NAME,
                                              &gOfflineDumpVariableGuid,
                                              NULL,
                                              &DataSize,
                                              NULL
                                              );
  if (Status != EFI_BUFFER_TOO_SMALL) {
    if (!EFI_ERROR (Status)) {
      Status = EFI_NOT_FOUND;
    }

    pData    = NULL;
    DataSize = 0;
  } else if (DataSize >= mOfflineDumpEncryptionPublicKeyMaxSize) {
    Status   = EFI_BAD_BUFFER_SIZE;
    pData    = NULL;
    DataSize = 0;
  } else {
    pData = AllocatePool (DataSize);
    if (pData == NULL) {
      Status   = EFI_OUT_OF_RESOURCES;
      DataSize = 0;
    } else {
      Status = gST->RuntimeServices->GetVariable (
                                                  OFFLINE_DUMP_ENCRYPTION_PUBLIC_KEY_VARIABLE_NAME,
                                                  &gOfflineDumpVariableGuid,
                                                  NULL,
                                                  &DataSize,
                                                  pData
                                                  );
      if (EFI_ERROR (Status)) {
        FreePool (pData);
        pData    = NULL;
        DataSize = 0;
      }
    }
  }

  *ppRecipientCertificate    = pData;
  *pRecipientCertificateSize = (UINT32)DataSize;
  return Status;
}

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/AARCH64-GCC/aesv8-armx.S`:

```S
// Adapted from openssl/crypto/aes/asm/aesv8-armx.pl

#if defined(__ARM_FEATURE_BTI_DEFAULT) && __ARM_FEATURE_BTI_DEFAULT == 1
# define GNU_PROPERTY_AARCH64_BTI (1 << 0)   /* Has Branch Target Identification */
# define AARCH64_VALID_CALL_TARGET hint #34  /* BTI 'c' */
#else
# define GNU_PROPERTY_AARCH64_BTI 0  /* No Branch Target Identification */
# define AARCH64_VALID_CALL_TARGET
#endif

.arch   armv8-a+crypto
.text
.align  5
.Lrcon:
.long   0x01,0x01,0x01,0x01
.long   0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d     // rotate-n-splat
.long   0x1b,0x1b,0x1b,0x1b

.globl  OD_accelerated_aes_set_encrypt_key
.type   OD_accelerated_aes_set_encrypt_key,%function
.align  5
OD_accelerated_aes_set_encrypt_key:
.Lenc_key:
        AARCH64_VALID_CALL_TARGET
        // Armv8.3-A PAuth: even though x30 is pushed to stack it is not popped later.
        stp     x29,x30,[sp,#-16]!
        add     x29,sp,#0
        mov     x3,#-1
        cmp     x0,#0
        b.eq    .Lenc_key_abort
        cmp     x2,#0
        b.eq    .Lenc_key_abort
        mov     x3,#-2
        cmp     w1,#128
        b.lt    .Lenc_key_abort
        cmp     w1,#256
        b.gt    .Lenc_key_abort
        tst     w1,#0x3f
        b.ne    .Lenc_key_abort

        adr     x3,.Lrcon
        cmp     w1,#192

        eor     v0.16b,v0.16b,v0.16b
        ld1     {v3.16b},[x0],#16
        mov     w1,#8           // reuse w1
        ld1     {v1.4s,v2.4s},[x3],#32

        b.lt    .Loop128
        b.eq    .L192
        b       .L256

.align  4
.Loop128:
        tbl     v6.16b,{v3.16b},v2.16b
        ext     v5.16b,v0.16b,v3.16b,#12
        st1     {v3.4s},[x2],#16
        aese    v6.16b,v0.16b
        subs    w1,w1,#1

        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v6.16b,v6.16b,v1.16b
        eor     v3.16b,v3.16b,v5.16b
        shl     v1.16b,v1.16b,#1
        eor     v3.16b,v3.16b,v6.16b
        b.ne    .Loop128

        ld1     {v1.4s},[x3]

        tbl     v6.16b,{v3.16b},v2.16b
        ext     v5.16b,v0.16b,v3.16b,#12
        st1     {v3.4s},[x2],#16
        aese    v6.16b,v0.16b

        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v6.16b,v6.16b,v1.16b
        eor     v3.16b,v3.16b,v5.16b
        shl     v1.16b,v1.16b,#1
        eor     v3.16b,v3.16b,v6.16b

        tbl     v6.16b,{v3.16b},v2.16b
        ext     v5.16b,v0.16b,v3.16b,#12
        st1     {v3.4s},[x2],#16
        aese    v6.16b,v0.16b

        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v6.16b,v6.16b,v1.16b
        eor     v3.16b,v3.16b,v5.16b
        eor     v3.16b,v3.16b,v6.16b
        st1     {v3.4s},[x2]
        add     x2,x2,#0x50

        mov     w12,#10
        b       .Ldone

.align  4
.L192:
        ld1     {v4.8b},[x0],#8
        movi    v6.16b,#8                       // borrow v6.16b
        st1     {v3.4s},[x2],#16
        sub     v2.16b,v2.16b,v6.16b    // adjust the mask

.Loop192:
        tbl     v6.16b,{v4.16b},v2.16b
        ext     v5.16b,v0.16b,v3.16b,#12
#ifdef __AARCH64EB__
        st1     {v4.4s},[x2],#16
        sub     x2,x2,#8
#else
        st1     {v4.8b},[x2],#8
#endif
        aese    v6.16b,v0.16b
        subs    w1,w1,#1

        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b

        dup     v5.4s,v3.s[3]
        eor     v5.16b,v5.16b,v4.16b
        eor     v6.16b,v6.16b,v1.16b
        ext     v4.16b,v0.16b,v4.16b,#12
        shl     v1.16b,v1.16b,#1
        eor     v4.16b,v4.16b,v5.16b
        eor     v3.16b,v3.16b,v6.16b
        eor     v4.16b,v4.16b,v6.16b
        st1     {v3.4s},[x2],#16
        b.ne    .Loop192

        mov     w12,#12
        add     x2,x2,#0x20
        b       .Ldone

.align  4
.L256:
        ld1     {v4.16b},[x0]
        mov     w1,#7
        mov     w12,#14
        st1     {v3.4s},[x2],#16

.Loop256:
        tbl     v6.16b,{v4.16b},v2.16b
        ext     v5.16b,v0.16b,v3.16b,#12
        st1     {v4.4s},[x2],#16
        aese    v6.16b,v0.16b
        subs    w1,w1,#1

        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v3.16b,v3.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v6.16b,v6.16b,v1.16b
        eor     v3.16b,v3.16b,v5.16b
        shl     v1.16b,v1.16b,#1
        eor     v3.16b,v3.16b,v6.16b
        st1     {v3.4s},[x2],#16
        b.eq    .Ldone

        dup     v6.4s,v3.s[3]           // just splat
        ext     v5.16b,v0.16b,v4.16b,#12
        aese    v6.16b,v0.16b

        eor     v4.16b,v4.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v4.16b,v4.16b,v5.16b
        ext     v5.16b,v0.16b,v5.16b,#12
        eor     v4.16b,v4.16b,v5.16b

        eor     v4.16b,v4.16b,v6.16b
        b       .Loop256

.Ldone:
        str     w12,[x2]
        mov     x3,#0

.Lenc_key_abort:
        mov     x0,x3                   // return value
        ldr     x29,[sp],#16
        ret
.size   OD_accelerated_aes_set_encrypt_key,.-OD_accelerated_aes_set_encrypt_key

.globl  OD_accelerated_aes_ecb_encrypt
.type   OD_accelerated_aes_ecb_encrypt,%function
.align  5
OD_accelerated_aes_ecb_encrypt:
        AARCH64_VALID_CALL_TARGET
        subs    x2,x2,#16
        // Original input data size bigger than 16, jump to big size processing.
        b.ne    .Lecb_big_size
        ld1     {v0.16b},[x0]
        //cmp     w4,#0                                   // en- or decrypting?
        ldr     w5,[x3,#240]
        ld1     {v5.4s,v6.4s},[x3],#32                  // load key schedule...

        //b.eq    .Lecb_small_dec
        aese    v0.16b,v5.16b
        aesmc   v0.16b,v0.16b
        ld1     {v16.4s,v17.4s},[x3],#32                        // load key schedule...
        aese    v0.16b,v6.16b
        aesmc   v0.16b,v0.16b
        subs    w5,w5,#10                       // if rounds==10, jump to aes-128-ecb processing
        b.eq    .Lecb_128_enc
.Lecb_round_loop:
        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        ld1     {v16.4s},[x3],#16                               // load key schedule...
        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        ld1     {v17.4s},[x3],#16                               // load key schedule...
        subs    w5,w5,#2                        // bias
        b.gt    .Lecb_round_loop
.Lecb_128_enc:
        ld1     {v18.4s,v19.4s},[x3],#32                // load key schedule...
        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        ld1     {v20.4s,v21.4s},[x3],#32                // load key schedule...
        aese    v0.16b,v18.16b
        aesmc   v0.16b,v0.16b
        aese    v0.16b,v19.16b
        aesmc   v0.16b,v0.16b
        ld1     {v22.4s,v23.4s},[x3],#32                // load key schedule...
        aese    v0.16b,v20.16b
        aesmc   v0.16b,v0.16b
        aese    v0.16b,v21.16b
        aesmc   v0.16b,v0.16b
        ld1     {v7.4s},[x3]
        aese    v0.16b,v22.16b
        aesmc   v0.16b,v0.16b
        aese    v0.16b,v23.16b
        eor     v0.16b,v0.16b,v7.16b
        st1     {v0.16b},[x1]
        b       .Lecb_Final_abort
.Lecb_big_size:
        stp     x29,x30,[sp,#-16]!
        add     x29,sp,#0
        mov     x8,#16
        b.lo    .Lecb_done
        csel    x8,xzr,x8,eq

        //cmp     w4,#0                                   // en- or decrypting?
        ldr     w5,[x3,#240]
        and     x2,x2,#-16
        ld1     {v0.16b},[x0],x8

        ld1     {v16.4s,v17.4s},[x3]                            // load key schedule...
        sub     w5,w5,#6
        add     x7,x3,x5,lsl#4                          // pointer to last 7 round keys
        sub     w5,w5,#2
        ld1     {v18.4s,v19.4s},[x7],#32
        ld1     {v20.4s,v21.4s},[x7],#32
        ld1     {v22.4s,v23.4s},[x7],#32
        ld1     {v7.4s},[x7]

        add     x7,x3,#32
        mov     w6,w5
        //b.eq    .Lecb_dec

        ld1     {v1.16b},[x0],#16
        subs    x2,x2,#32                               // bias
        add     w6,w5,#2
        orr     v3.16b,v1.16b,v1.16b
        orr     v24.16b,v1.16b,v1.16b
        orr     v1.16b,v0.16b,v0.16b
        b.lo    .Lecb_enc_tail

        orr     v1.16b,v3.16b,v3.16b
        ld1     {v24.16b},[x0],#16
        cmp     x2,#32
        b.lo    .Loop3x_ecb_enc

        ld1     {v25.16b},[x0],#16
        ld1     {v26.16b},[x0],#16
        sub     x2,x2,#32                               // bias
        mov     w6,w5

.Loop5x_ecb_enc:
        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v16.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v16.16b
        aesmc   v26.16b,v26.16b
        ld1     {v16.4s},[x7],#16
        subs    w6,w6,#2
        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v17.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v17.16b
        aesmc   v26.16b,v26.16b
        ld1     {v17.4s},[x7],#16
        b.gt    .Loop5x_ecb_enc

        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v16.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v16.16b
        aesmc   v26.16b,v26.16b
        cmp     x2,#0x40                                        // because .Lecb_enc_tail4x
        sub     x2,x2,#0x50

        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v17.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v17.16b
        aesmc   v26.16b,v26.16b
        csel    x6,xzr,x2,gt                    // borrow x6, w6, "gt" is not typo
        mov     x7,x3

        aese    v0.16b,v18.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v18.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v18.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v18.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v18.16b
        aesmc   v26.16b,v26.16b
        add     x0,x0,x6                                // x0 is adjusted in such way that
                                                        // at exit from the loop v1.16b-v26.16b
                                                        // are loaded with last "words"
        add     x6,x2,#0x60                 // because .Lecb_enc_tail4x

        aese    v0.16b,v19.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v19.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v19.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v19.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v19.16b
        aesmc   v26.16b,v26.16b

        aese    v0.16b,v20.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v20.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v20.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v20.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v20.16b
        aesmc   v26.16b,v26.16b

        aese    v0.16b,v21.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v21.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v21.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v21.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v21.16b
        aesmc   v26.16b,v26.16b

        aese    v0.16b,v22.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v22.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v22.16b
        aesmc   v24.16b,v24.16b
        aese    v25.16b,v22.16b
        aesmc   v25.16b,v25.16b
        aese    v26.16b,v22.16b
        aesmc   v26.16b,v26.16b

        aese    v0.16b,v23.16b
        ld1     {v2.16b},[x0],#16
        aese    v1.16b,v23.16b
        ld1     {v3.16b},[x0],#16
        aese    v24.16b,v23.16b
        ld1     {v27.16b},[x0],#16
        aese    v25.16b,v23.16b
        ld1     {v28.16b},[x0],#16
        aese    v26.16b,v23.16b
        ld1     {v29.16b},[x0],#16
        cbz     x6,.Lecb_enc_tail4x
        ld1     {v16.4s},[x7],#16                       // re-pre-load rndkey[0]
        eor     v4.16b,v7.16b,v0.16b
        orr     v0.16b,v2.16b,v2.16b
        eor     v5.16b,v7.16b,v1.16b
        orr     v1.16b,v3.16b,v3.16b
        eor     v17.16b,v7.16b,v24.16b
        orr     v24.16b,v27.16b,v27.16b
        eor     v30.16b,v7.16b,v25.16b
        orr     v25.16b,v28.16b,v28.16b
        eor     v31.16b,v7.16b,v26.16b
        st1     {v4.16b},[x1],#16
        orr     v26.16b,v29.16b,v29.16b
        st1     {v5.16b},[x1],#16
        mov     w6,w5
        st1     {v17.16b},[x1],#16
        ld1     {v17.4s},[x7],#16                       // re-pre-load rndkey[1]
        st1     {v30.16b},[x1],#16
        st1     {v31.16b},[x1],#16
        b.hs    .Loop5x_ecb_enc

        add     x2,x2,#0x50
        cbz     x2,.Lecb_done

        add     w6,w5,#2
        subs    x2,x2,#0x30
        orr     v0.16b,v27.16b,v27.16b
        orr     v1.16b,v28.16b,v28.16b
        orr     v24.16b,v29.16b,v29.16b
        b.lo    .Lecb_enc_tail

        b       .Loop3x_ecb_enc

.align  4
.Lecb_enc_tail4x:
        eor     v5.16b,v7.16b,v1.16b
        eor     v17.16b,v7.16b,v24.16b
        eor     v30.16b,v7.16b,v25.16b
        eor     v31.16b,v7.16b,v26.16b
        st1     {v5.16b},[x1],#16
        st1     {v17.16b},[x1],#16
        st1     {v30.16b},[x1],#16
        st1     {v31.16b},[x1],#16

        b       .Lecb_done
.align  4
.Loop3x_ecb_enc:
        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        ld1     {v16.4s},[x7],#16
        subs    w6,w6,#2
        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        ld1     {v17.4s},[x7],#16
        b.gt    .Loop3x_ecb_enc

        aese    v0.16b,v16.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        subs    x2,x2,#0x30
        csel    x6,x2,x6,lo                             // x6, w6, is zero at this point
        aese    v0.16b,v17.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        add     x0,x0,x6                        // x0 is adjusted in such way that
                                                // at exit from the loop v1.16b-v24.16b
                                                // are loaded with last "words"
        mov     x7,x3
        aese    v0.16b,v20.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v20.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v20.16b
        aesmc   v24.16b,v24.16b
        ld1     {v2.16b},[x0],#16
        aese    v0.16b,v21.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v21.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v21.16b
        aesmc   v24.16b,v24.16b
        ld1     {v3.16b},[x0],#16
        aese    v0.16b,v22.16b
        aesmc   v0.16b,v0.16b
        aese    v1.16b,v22.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v22.16b
        aesmc   v24.16b,v24.16b
        ld1     {v27.16b},[x0],#16
        aese    v0.16b,v23.16b
        aese    v1.16b,v23.16b
        aese    v24.16b,v23.16b
        ld1     {v16.4s},[x7],#16               // re-pre-load rndkey[0]
        add     w6,w5,#2
        eor     v4.16b,v7.16b,v0.16b
        eor     v5.16b,v7.16b,v1.16b
        eor     v24.16b,v24.16b,v7.16b
        ld1     {v17.4s},[x7],#16               // re-pre-load rndkey[1]
        st1     {v4.16b},[x1],#16
        orr     v0.16b,v2.16b,v2.16b
        st1     {v5.16b},[x1],#16
        orr     v1.16b,v3.16b,v3.16b
        st1     {v24.16b},[x1],#16
        orr     v24.16b,v27.16b,v27.16b
        b.hs    .Loop3x_ecb_enc

        cmn     x2,#0x30
        b.eq    .Lecb_done
        nop

.Lecb_enc_tail:
        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        ld1     {v16.4s},[x7],#16
        subs    w6,w6,#2
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        ld1     {v17.4s},[x7],#16
        b.gt    .Lecb_enc_tail

        aese    v1.16b,v16.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v16.16b
        aesmc   v24.16b,v24.16b
        aese    v1.16b,v17.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v17.16b
        aesmc   v24.16b,v24.16b
        aese    v1.16b,v20.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v20.16b
        aesmc   v24.16b,v24.16b
        cmn     x2,#0x20
        aese    v1.16b,v21.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v21.16b
        aesmc   v24.16b,v24.16b
        aese    v1.16b,v22.16b
        aesmc   v1.16b,v1.16b
        aese    v24.16b,v22.16b
        aesmc   v24.16b,v24.16b
        aese    v1.16b,v23.16b
        aese    v24.16b,v23.16b
        b.eq    .Lecb_enc_one
        eor     v5.16b,v7.16b,v1.16b
        eor     v17.16b,v7.16b,v24.16b
        st1     {v5.16b},[x1],#16
        st1     {v17.16b},[x1],#16
        b       .Lecb_done

.Lecb_enc_one:
        eor     v5.16b,v7.16b,v24.16b
        st1     {v5.16b},[x1],#16
        b       .Lecb_done

.align  4
.Lecb_tail4x:
        eor     v5.16b,v7.16b,v1.16b
        eor     v17.16b,v7.16b,v24.16b
        eor     v30.16b,v7.16b,v25.16b
        eor     v31.16b,v7.16b,v26.16b
        st1     {v5.16b},[x1],#16
        st1     {v17.16b},[x1],#16
        st1     {v30.16b},[x1],#16
        st1     {v31.16b},[x1],#16

        b       .Lecb_done

.Lecb_done:
        ldr     x29,[sp],#16
.Lecb_Final_abort:
        ret
.size   OD_accelerated_aes_ecb_encrypt,.-OD_accelerated_aes_ecb_encrypt

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/Collect.c`:

```c
#include <OfflineDumpLib.h>
#include <Library/OfflineDumpWriter.h>
#include <Library/OfflineDumpVariables.h>

#include <Uefi.h>
#include <Protocol/OfflineDumpProvider.h>
#include <Guid/OfflineDumpCpuContext.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/PrintLib.h>
#include <Library/UefiBootServicesTableLib.h>

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a: " fmt, __func__, ##__VA_ARGS__)

// Copies up to MaxSize bytes from Source to Destination.
// If Source is not null-terminated, Destination will not be null-terminated.
static void
AsciiStrnCpy (
  OUT CHAR8        *pDestination,
  IN  CHAR8 const  *pSource,
  IN  UINTN        MaxCount
  )
{
  for (UINTN i = 0; i != MaxCount; i += 1) {
    pDestination[i] = pSource[i];
    if (pSource[i] == '\0') {
      return;
    }
  }
}

// Returns NULL if the section is ok, else a string describing the reason it is skipped.
static CHAR8 const *
OfflineDumpSectionSkipReason (
  IN OFFLINE_DUMP_PROVIDER_SECTION_INFO const  *pSection
  )
{
  switch (pSection->Type) {
    case OfflineDumpProviderSectionType_DdrRange:
      // DDR ranges must be full memory pages (page aligned and a multiple of page length).
      if (pSection->DataSize % 4096 != 0) {
        return "DDR region DataSize is not a multiple of 4096";
      } else if (pSection->Information.DdrRange.Base % 4096 != 0) {
        return "Information.DdrRange.Base is not a multiple of 4096";
      } else if (pSection->Information.DdrRange.Base + pSection->DataSize < pSection->Information.DdrRange.Base) {
        return "DDR region Base + Size overflow";
      }

      break;

    case OfflineDumpProviderSectionType_SvSpecific:
      break;

    default:
      return "unsupported Type";
  }

  if ((pSection->Options.Reserved1 != 0) ||
      (pSection->Options.Reserved2 != 0) ||
      (pSection->Reserved1 != NULL))
  {
    return "non-zero Reserved field";
  }

  if (pSection->Flags & (RAW_DUMP_SECTION_HEADER_DUMP_VALID | RAW_DUMP_SECTION_HEADER_INSUFFICIENT_STORAGE)) {
    return "prohibited flag in Flags";
  }

  return NULL;
}

static CHAR8 const *
MakeSectionName (
  CHAR8 const  *pProvidedName,
  CHAR8 const  *pDefaultPrefix,
  UINT32       Index,
  CHAR8        NameBuffer[],
  UINTN        NameBufferSize
  )
{
  if (pProvidedName && pProvidedName[0]) {
    return pProvidedName;
  } else {
    AsciiSPrint (NameBuffer, NameBufferSize, "%a-%03u.bin", pDefaultPrefix, Index);
    return NameBuffer;
  }
}

static OFFLINE_DUMP_PROVIDER_END_INFO
OfflineDumpWriteWithDumpInfo (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL const   *pProvider,
  IN OFFLINE_DUMP_PROVIDER_DUMP_INFO const  *pDumpInfo
  )
{
  OFFLINE_DUMP_PROVIDER_END_INFO  EndInfo      = { 0 };
  OFFLINE_DUMP_WRITER             *pDumpWriter = NULL;
  RAW_DUMP_SECTION_INFORMATION    Information;

  // Count the sections and bytes to write.

  UINT32                                      FinalSectionCount = 0;
  OFFLINE_DUMP_PROVIDER_REPORT_PROGRESS_INFO  ProgressInfo      = { 0 }; // Only for progress reporting. Doesn't include small sections.

  for (UINT32 SectionIndex = 0; SectionIndex < pDumpInfo->SectionCount; SectionIndex += 1) {
    OFFLINE_DUMP_PROVIDER_SECTION_INFO const * const  pSection = &pDumpInfo->pSections[SectionIndex];
    if (NULL != OfflineDumpSectionSkipReason (pSection)) {
      continue;
    }

    FinalSectionCount          += 1;
    ProgressInfo.ExpectedBytes += pSection->DataSize;
  }

  FinalSectionCount += 3; // Account for SYSTEM_INFORMATION, DUMP_REASON, CPU_CONTEXT.

  // Open the dump writer.
  {
    OFFLINE_DUMP_WRITER_OPTIONS  Options = {
      .DisableBlockIo2   = (BOOLEAN)pDumpInfo->Options.DisableBlockIo2,
      .ForceUnencrypted  = (BOOLEAN)pDumpInfo->Options.ForceUnencrypted,
      .BufferCount       = (UINT8)pDumpInfo->Options.BufferCount,
      .BufferMemoryLimit = pDumpInfo->Options.BufferMemoryLimit,
    };
    EndInfo.Status = OfflineDumpWriterOpen (
                                            pDumpInfo->BlockDevice,
                                            pDumpInfo->Flags,
                                            FinalSectionCount,
                                            &Options,
                                            &pDumpWriter
                                            );
    if (EFI_ERROR (EndInfo.Status)) {
      DEBUG_PRINT (DEBUG_ERROR, "OfflineDumpWriterOpen failed (%r)\n", EndInfo.Status);
      return EndInfo;
    }
  }

  EndInfo.EncryptionAlgorithm = OfflineDumpWriterEncryptionAlgorithm (pDumpWriter);
  EndInfo.SizeAvailable       = OfflineDumpWriterMediaSize (pDumpWriter);

  // SYSTEM_INFORMATION

  ZeroMem (&Information, sizeof (Information));
  AsciiStrnCpy (Information.SystemInformation.Vendor, pDumpInfo->pVendor, sizeof (Information.SystemInformation.Vendor));
  AsciiStrnCpy (Information.SystemInformation.Platform, pDumpInfo->pPlatform, sizeof (Information.SystemInformation.Platform));
  Information.SystemInformation.Architecture = pDumpInfo->Architecture;

  EndInfo.Status = OfflineDumpWriterWriteSection (
                                                  pDumpWriter,
                                                  RAW_DUMP_SECTION_HEADER_DUMP_VALID,
                                                  RAW_DUMP_SYSTEM_INFORMATION_CURRENT_MAJOR_VERSION,
                                                  RAW_DUMP_SYSTEM_INFORMATION_CURRENT_MINOR_VERSION,
                                                  RAW_DUMP_SECTION_SYSTEM_INFORMATION,
                                                  &Information,
                                                  "SystemInformation",
                                                  NULL, // Use CopyMem instead of a callback.
                                                  NULL, // No data content for this section.
                                                  0     // Size of the data in the section.
                                                  );
  if (EFI_ERROR (EndInfo.Status)) {
    DEBUG_PRINT (DEBUG_WARN, "WriteSection(SystemInformation) failed (%r)\n", EndInfo.Status);
  }

  // DUMP_REASON

  ZeroMem (&Information, sizeof (Information));
  Information.DumpReason.Parameter1 = pDumpInfo->DumpReasonParameters[0];
  Information.DumpReason.Parameter2 = pDumpInfo->DumpReasonParameters[1];
  Information.DumpReason.Parameter3 = pDumpInfo->DumpReasonParameters[2];
  Information.DumpReason.Parameter4 = pDumpInfo->DumpReasonParameters[3];

  EndInfo.Status = OfflineDumpWriterWriteSection (
                                                  pDumpWriter,
                                                  RAW_DUMP_SECTION_HEADER_DUMP_VALID,
                                                  RAW_DUMP_DUMP_REASON_CURRENT_MAJOR_VERSION,
                                                  RAW_DUMP_DUMP_REASON_CURRENT_MINOR_VERSION,
                                                  RAW_DUMP_SECTION_DUMP_REASON,
                                                  &Information,
                                                  "DumpReason",
                                                  NULL, // Use CopyMem instead of a callback.
                                                  NULL, // No data content for this section.
                                                  0     // Size of the data in the section.
                                                  );
  if (EFI_ERROR (EndInfo.Status)) {
    DEBUG_PRINT (DEBUG_WARN, "WriteSection(DumpReason) failed (%r)\n", EndInfo.Status);
  }

  // CPU_CONTEXT

  ZeroMem (&Information, sizeof (Information));

  switch (pDumpInfo->Architecture) {
    case RAW_DUMP_ARCHITECTURE_ARM64:
      Information.CpuContext.Architecture = PROCESSOR_ARCHITECTURE_ARM64;
      break;
    case RAW_DUMP_ARCHITECTURE_X64:
      Information.CpuContext.Architecture = PROCESSOR_ARCHITECTURE_AMD64;
      break;
  }

  Information.CpuContext.CoreCount   = pDumpInfo->CpuContextCount;
  Information.CpuContext.ContextSize = pDumpInfo->CpuContextSize;

  EndInfo.Status = OfflineDumpWriterWriteSection (
                                                  pDumpWriter,
                                                  RAW_DUMP_SECTION_HEADER_DUMP_VALID,
                                                  RAW_DUMP_CPU_CONTEXT_CURRENT_MAJOR_VERSION,
                                                  RAW_DUMP_CPU_CONTEXT_CURRENT_MINOR_VERSION,
                                                  RAW_DUMP_SECTION_CPU_CONTEXT,
                                                  &Information,
                                                  "CpuContext",
                                                  NULL, // Use CopyMem instead of a callback.
                                                  pDumpInfo->pCpuContexts,
                                                  pDumpInfo->CpuContextCount * (UINT64)pDumpInfo->CpuContextSize
                                                  );
  if (EFI_ERROR (EndInfo.Status)) {
    DEBUG_PRINT (DEBUG_WARN, "WriteSection(CpuContext) failed (%r)\n", EndInfo.Status);
  }

  // Other sections

  for (UINT32 SectionIndex = 0; SectionIndex < pDumpInfo->SectionCount; SectionIndex += 1) {
    OFFLINE_DUMP_PROVIDER_SECTION_INFO const * const  pSection = &pDumpInfo->pSections[SectionIndex];
    if (NULL != OfflineDumpSectionSkipReason (pSection)) {
      continue;
    }

    // TODO: Move this into OfflineDumpWriterWriteSection so that it can be called every N bytes,
    // even when the section is large.
    EndInfo.Status = pProvider->ReportProgress (
                                                (OFFLINE_DUMP_PROVIDER_PROTOCOL *)pProvider,
                                                sizeof (ProgressInfo),
                                                &ProgressInfo
                                                );
    ProgressInfo.WrittenBytes += pSection->DataSize;
    if (EFI_ERROR (EndInfo.Status)) {
      DEBUG_PRINT (DEBUG_WARN, "ReportProgress returned error (%r), stopping generation\n", EndInfo.Status);
      goto Done;
    }

    UINT16                 MajorVersion;
    UINT16                 MinorVersion;
    RAW_DUMP_SECTION_TYPE  Type;
    CHAR8 const            *pName;
    CHAR8                  NameBuffer[21];
    switch (pSection->Type) {
      case OfflineDumpProviderSectionType_DdrRange:
        MajorVersion = RAW_DUMP_DDR_RANGE_CURRENT_MAJOR_VERSION;
        MinorVersion = RAW_DUMP_DDR_RANGE_CURRENT_MINOR_VERSION;
        Type         = RAW_DUMP_SECTION_DDR_RANGE;
        pName        = MakeSectionName (pSection->pName, "DDR", SectionIndex, NameBuffer, sizeof (NameBuffer));
        break;

      case OfflineDumpProviderSectionType_SvSpecific:
        MajorVersion = RAW_DUMP_SV_SPECIFIC_CURRENT_MAJOR_VERSION;
        MinorVersion = RAW_DUMP_SV_SPECIFIC_CURRENT_MINOR_VERSION;
        Type         = RAW_DUMP_SECTION_SV_SPECIFIC;
        pName        = MakeSectionName (pSection->pName, "SV", SectionIndex, NameBuffer, sizeof (NameBuffer));
        break;

      default:
        // This should never happen because we already checked for unsupported types.
        ASSERT (FALSE);
        continue;
    }

    RAW_DUMP_SECTION_HEADER_FLAGS const  Flags = pSection->Options.ForceSectionInvalid
      ? pSection->Flags
      : pSection->Flags | RAW_DUMP_SECTION_HEADER_DUMP_VALID;
    EndInfo.Status = OfflineDumpWriterWriteSection (
                                                    pDumpWriter,
                                                    Flags,
                                                    MajorVersion,
                                                    MinorVersion,
                                                    Type,
                                                    &pSection->Information,
                                                    pName,
                                                    pSection->DataCopyCallback,
                                                    pSection->pDataStart,
                                                    pSection->DataSize
                                                    );
    if (EFI_ERROR (EndInfo.Status)) {
      DEBUG_PRINT (
                   DEBUG_WARN,
                   "WriteSection(\"%a\" %u) failed (%r)\n",
                   pName,
                   SectionIndex,
                   EndInfo.Status
                   );
    }
  }

  EndInfo.Status       = OfflineDumpWriterLastWriteError (pDumpWriter);
  EndInfo.SizeRequired = OfflineDumpWriterMediaPosition (pDumpWriter);

Done:

  EFI_STATUS const  CloseStatus = OfflineDumpWriterClose (pDumpWriter, !EFI_ERROR (EndInfo.Status));
  if (!EFI_ERROR (EndInfo.Status)) {
    EndInfo.Status = CloseStatus;
  }

  return EndInfo;
}

EFI_STATUS
OfflineDumpWrite (
  IN OFFLINE_DUMP_PROVIDER_PROTOCOL const  *pProvider
  )
{
  OFFLINE_DUMP_PROVIDER_END_INFO  EndInfo = { 0 };
  UINT64                          DdrEnd  = 0;

  // Validate pProvider

  if (pProvider->Revision < OfflineDumpProviderProtocolRevision_1_0) {
    DEBUG_PRINT (
                 DEBUG_ERROR,
                 "Unsupported protocol revision 0x%X; expected 0x%X or later\n",
                 pProvider->Revision,
                 OfflineDumpProviderProtocolRevision_1_0
                 );
    return EFI_UNSUPPORTED;
  }

  if ((pProvider->Begin == NULL) ||
      (pProvider->ReportProgress == NULL) ||
      (pProvider->End == NULL))
  {
    DEBUG_PRINT (DEBUG_ERROR, "One or more required protocol pointers is NULL.\n");
    return EFI_UNSUPPORTED;
  }

  // Validate system status

  EFI_TPL const  Tpl = gBS->RaiseTPL (TPL_CALLBACK);
  gBS->RestoreTPL (Tpl);
  if (Tpl  != TPL_APPLICATION) {
    DEBUG_PRINT (DEBUG_ERROR, "Called at unsupported TPL = %u.\n", (unsigned)Tpl);

    // Things seem to work for TPL_CALLBACK as long as we disable async I/O.
    if (Tpl != TPL_CALLBACK) {
      return EFI_UNSUPPORTED;
    }
  }

  // Call Begin to get DumpInfo.

  OFFLINE_DUMP_USE_CAPABILITY_FLAGS  UseCapabilityFlags;
  (void)GetVariableOfflineMemoryDumpUseCapability (&UseCapabilityFlags);

  OFFLINE_DUMP_PROVIDER_DUMP_INFO  DumpInfo = { 0 };

  {
    OFFLINE_DUMP_PROVIDER_BEGIN_INFO  BeginInfo = { 0 };
    BeginInfo.WriterRevision     = OfflineDumpProviderProtocolRevision_1_0;
    BeginInfo.UseCapabilityFlags = UseCapabilityFlags;

    EndInfo.Status = pProvider->Begin (
                                       (OFFLINE_DUMP_PROVIDER_PROTOCOL *)pProvider,
                                       sizeof (BeginInfo),
                                       &BeginInfo,
                                       sizeof (DumpInfo),
                                       &DumpInfo
                                       );
    if (EFI_ERROR (EndInfo.Status)) {
      DEBUG_PRINT (DEBUG_ERROR, "protocol.Begin failed (%r)\n", EndInfo.Status);
      return EndInfo.Status;
    }
  }

  // Validate DumpInfo

  if ((Tpl != TPL_APPLICATION) && !DumpInfo.Options.DisableBlockIo2) {
    // If we are not at TPL_APPLICATION then we cannot use async I/O.
    DEBUG_PRINT (DEBUG_WARN, "Forcing DisableBlockIo2 due to TPL = %u.\n", (unsigned)Tpl);
    DumpInfo.Options.DisableBlockIo2 = TRUE;
  }

  if (DumpInfo.SectionCount > 0x80000000) {
    DEBUG_PRINT (DEBUG_ERROR, "DumpInfo.SectionCount %u is too large\n", DumpInfo.SectionCount);
    EndInfo.Status = EFI_UNSUPPORTED;
    goto Done;
  }

  switch (DumpInfo.Architecture) {
    default:
      DEBUG_PRINT (DEBUG_ERROR, "Unsupported DumpInfo.Architecture %u\n", DumpInfo.Architecture);
      EndInfo.Status = EFI_UNSUPPORTED;
      goto Done;
    case RAW_DUMP_ARCHITECTURE_ARM64:
    case RAW_DUMP_ARCHITECTURE_X64:
      break;
  }

  if (DumpInfo.Flags & (RAW_DUMP_HEADER_DUMP_VALID | RAW_DUMP_HEADER_INSUFFICIENT_STORAGE | RAW_DUMP_HEADER_IS_HYPERV_DATA_PROTECTED)) {
    DEBUG_PRINT (DEBUG_ERROR, "DumpInfo.Flags 0x%X contains a prohibited flag\n", DumpInfo.Flags);
    EndInfo.Status = EFI_UNSUPPORTED;
    goto Done;
  }

  if (DumpInfo.Options.Reserved1 != 0) {
    // Not fatal.
    DEBUG_PRINT (DEBUG_WARN, "DumpInfo.Options.Reserved1 is non-zero\n");
  }

  if (DumpInfo.Reserved1) {
    DEBUG_PRINT (DEBUG_ERROR, "DumpInfo.Reserved1 is non-zero\n");
    EndInfo.Status = EFI_UNSUPPORTED;
    goto Done;
  }

  if (DumpInfo.Options.ForceUnencrypted) {
    DEBUG_PRINT (DEBUG_WARN, "Forcing unencrypted dump\n");
  }

  if (DumpInfo.Options.ForceDumpAllowed) {
    DEBUG_PRINT (DEBUG_WARN, "Forcing dump generation (ignoring SecureControl)\n");
  }

  if (DumpInfo.Options.DisableBlockIo2) {
    DEBUG_PRINT (DEBUG_WARN, "Disabling BlockIo2 (no async I/O)\n");
  }

  for (UINT32 SectionIndex = 0; SectionIndex < DumpInfo.SectionCount; SectionIndex += 1) {
    OFFLINE_DUMP_PROVIDER_SECTION_INFO const * const  pSection = &DumpInfo.pSections[SectionIndex];

    CHAR8 const  *pSkipReason = OfflineDumpSectionSkipReason (pSection);
    if (pSkipReason != NULL) {
      DEBUG_PRINT (DEBUG_WARN, "DumpInfo.Sections[%u] skipped: %a\n", SectionIndex, pSkipReason);
    }

    if (pSection->Type == OfflineDumpProviderSectionType_DdrRange) {
      if (pSection->Information.DdrRange.Base < DdrEnd) {
        DEBUG_PRINT (
                     DEBUG_ERROR,
                     "DumpInfo.Sections[%u] Base address (%llX) is less than previous DDR section's End address (%llX). DDR sections must be specified in order of their start address.\n",
                     SectionIndex,
                     (UINT64)pSection->Information.DdrRange.Base,
                     (UINT64)DdrEnd
                     );
        EndInfo.Status = EFI_INVALID_PARAMETER;
        goto Done;
      }

      DdrEnd = pSection->Information.DdrRange.Base + pSection->DataSize;
    }
  }

  // Determine dump device

  if (DumpInfo.BlockDevice != NULL) {
    // Use the device specified by the protocol.
  } else if (UseCapabilityFlags & OFFLINE_DUMP_USE_CAPABILITY_LOCATION_GPT_SCAN) {
    // Find the device via GPT scan.
    EndInfo.Status = FindOfflineDumpPartitionHandle (&DumpInfo.BlockDevice);
    if (EFI_ERROR (EndInfo.Status)) {
      DEBUG_PRINT (DEBUG_ERROR, "FindOfflineDumpPartitionHandle failed (%r)\n", EndInfo.Status);
      goto Done;
    }
  } else {
    DEBUG_PRINT (DEBUG_ERROR, "Dump disabled: OfflineMemoryDumpUseCapability = 0x%X\n", UseCapabilityFlags);
    EndInfo.Status = EFI_NOT_STARTED;
    goto Done;
  }

  // Set up redaction.

  if (!DumpInfo.Options.ForceDumpAllowed) {
    switch (DumpInfo.SecureControl) {
      case OfflineDumpProviderSecureControl_DumpAllowed:

        // Redaction not needed.
        break;

      case OfflineDumpProviderSecureControl_RedactedDumpAllowed:

        // Redaction needed. Configuration data required.
        if ((DumpInfo.pSecureConfiguration == NULL) || (DumpInfo.SecureConfigurationSize == 0)) {
          DEBUG_PRINT (DEBUG_ERROR, "Redaction required but SecureConfiguration not present. Dump cannot be written.\n");
          EndInfo.Status = EFI_INVALID_PARAMETER;
          goto Done;
        }

        DEBUG_PRINT (DEBUG_ERROR, "SecureConfiguration parsing not yet implemented. Dump cannot be written.\n");
        EndInfo.Status = EFI_UNSUPPORTED;
        goto Done;

      default:

        if (DumpInfo.SecureControl == OfflineDumpProviderSecureControl_DumpNotAllowed) {
          DEBUG_PRINT (DEBUG_ERROR, "DumpInfo.SecureControl == OfflineDumpProviderSecureControl_DumpNotAllowed\n");
        } else {
          DEBUG_PRINT (DEBUG_ERROR, "Unrecognized DumpInfo.SecureControl value %u\n", DumpInfo.SecureControl);
        }

        EndInfo.Status = EFI_INVALID_PARAMETER;
        goto Done;
    }
  }

  // Write the dump

  EndInfo = OfflineDumpWriteWithDumpInfo (pProvider, &DumpInfo);

Done:

  pProvider->End ((OFFLINE_DUMP_PROVIDER_PROTOCOL *)pProvider, sizeof (EndInfo), &EndInfo);
  return EndInfo.Status;
}

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/Encryptor.c`:

```c
#include <Library/OfflineDumpEncryptor.h>

typedef struct {
  UINT64    Lo;
  UINT64    Hi;
} AES_BLOCK;

STATIC_ASSERT (
               sizeof (AES_BLOCK) == 16,
               "AES_BLOCK expected to be 16 bytes"
               );

// Temporary to be fixed: Reach directly into OpensslLib's headers for
// functionality that is not yet supported by BaseCryptLib.
#undef _WIN32
#undef _WIN64
#include <Library/Include/CrtLibSupport.h>  // CryptoPkg/...
#include <openssl/aes.h>                    // CryptoPkg/Library/OpensslLib/openssl/include/...
#include <openssl/evp.h>                    // CryptoPkg/Library/OpensslLib/openssl/include/...
#include <openssl/x509.h>                   // CryptoPkg/Library/OpensslLib/openssl/include/...
#include <openssl/pkcs7.h>                  // CryptoPkg/Library/OpensslLib/openssl/include/...

#include <Library/BaseLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>

#include <Library/BaseCryptLib.h>

#if defined (MDE_CPU_X64)
  #include <Register/Intel/Cpuid.h>
#endif // defined (MDE_CPU_X64)

#if defined (MDE_CPU_X64) || defined (MDE_CPU_AARCH64)
#define AES_ACCELERATION_AVAILABLE  1
#else
#define AES_ACCELERATION_AVAILABLE  0
#endif

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a: " fmt, __func__, ##__VA_ARGS__)

/*
TODO: Don't depend on private headers from OpenSslLib.

Almost-useful functions from BaseCryptLib.h:

- AesInit
- AesCbcEncrypt
- RsaGetPublicKeyFromX509, RsaFree
- X509ConstructCertificate, X509Free
- X509Get***
- RsaOaepEncrypt
- RandomBytes

To be able to use BaseCryptLib.h instead of <openssl/???.h>, we would need:

- AesEcbEncrypt (for the fallback implementation).
- Pkcs7Encrypt - could be implemented using RsaOaepEncrypt + an ASN.1 writer from somewhere.
*/

enum {
  KEY_STREAM_BUFFER_SIZE        = 8 * SIZE_1KB,
  KEY_STREAM_BUFFER_BLOCK_COUNT = KEY_STREAM_BUFFER_SIZE / sizeof (AES_BLOCK),
  AES_BLOCK_MASK                = AES_BLOCK_SIZE - 1,
};

STATIC_ASSERT (
               KEY_STREAM_BUFFER_SIZE == KEY_STREAM_BUFFER_BLOCK_COUNT * sizeof (AES_BLOCK),
               "KeyStreamBufferSize must be a multiple of 16"
               );

// Function type for aes_set_encrypt_key implementations.
typedef int (EFIAPI AES_SET_ENCRYPT_KEY) (
  const unsigned char  *userKey,
  int                  bits,
  AES_KEY              *key
  );

// Function type for aes_ecb_encrypt implementations.
// Requires: size % 16 == 0.
typedef void (EFIAPI AES_ECB_ENCRYPT) (
  const unsigned char  *in,
  unsigned char        *out,
  size_t               size,
  const AES_KEY        *key
  );

typedef struct {
  AES_SET_ENCRYPT_KEY    *pSetEncryptKey;
  AES_ECB_ENCRYPT        *pEcbEncrypt;
} AES_ENCRYPTION_OPERATIONS;

struct OFFLINE_DUMP_ENCRYPTOR {
  AES_ECB_ENCRYPT       *pEcbEncrypt;
  UINT64                InitializationVector;
  ENC_DUMP_ALGORITHM    Algorithm;
  AES_KEY               Key;
  AES_BLOCK             KeyStreamBuffer[KEY_STREAM_BUFFER_BLOCK_COUNT];
};

typedef struct ALGORITHM_INFO {
  ENC_DUMP_ALGORITHM                 Algorithm;
  UINT8                              KeySize;
  AES_ENCRYPTION_OPERATIONS const    *pOperations;
} ALGORITHM_INFO;

// Used if accelerated implementation is not available.
static int EFIAPI
OD_fallback_aes_set_encrypt_key (
  const unsigned char  *userKey,
  const int            bits,
  AES_KEY              *key
  )
{
  // From openssl/aes.h
  return AES_set_encrypt_key (userKey, bits, key);
}

// Used if accelerated implementation is not available.
// Requires: size % 16 == 0.
static void EFIAPI
OD_fallback_aes_ecb_encrypt (
  const unsigned char  *in,
  unsigned char        *out,
  size_t               size,
  const AES_KEY        *key
  )
{
  ASSERT (size % AES_BLOCK_SIZE == 0);
  for (size_t i = 0; i < size; i += AES_BLOCK_SIZE) {
    // From openssl/aes.h
    AES_encrypt (in + i, out + i, key);
  }
}

static AES_ENCRYPTION_OPERATIONS const  gFallbackAesEncryptionOperations = {
  .pSetEncryptKey = OD_fallback_aes_set_encrypt_key,
  .pEcbEncrypt    = OD_fallback_aes_ecb_encrypt,
};

#if AES_ACCELERATION_AVAILABLE

// Assembly-language implementations.
AES_SET_ENCRYPT_KEY  OD_accelerated_aes_set_encrypt_key;
AES_ECB_ENCRYPT      OD_accelerated_aes_ecb_encrypt;

static AES_ENCRYPTION_OPERATIONS const  gAcceleratedAesEncryptionOperations = {
  .pSetEncryptKey = OD_accelerated_aes_set_encrypt_key,
  .pEcbEncrypt    = OD_accelerated_aes_ecb_encrypt,
};

#endif // AES_ACCELERATION_AVAILABLE

static ALGORITHM_INFO
OD_GetAlgorithmInfo (
  IN ENC_DUMP_ALGORITHM  Algorithm
  )
{
  ALGORITHM_INFO  Info;

  Info.Algorithm = Algorithm;

  switch (Algorithm) {
    default:
      Info.KeySize     = 0;
      Info.pOperations = NULL;
      goto Done;

    case ENC_DUMP_ALGORITHM_AES128_CTR:
      Info.KeySize = 16;
      break;

    case ENC_DUMP_ALGORITHM_AES192_CTR:
      Info.KeySize = 24;
      break;

    case ENC_DUMP_ALGORITHM_AES256_CTR:
      Info.KeySize = 32;
      break;
  }

 #if AES_ACCELERATION_AVAILABLE

  static BOOLEAN  CheckedAcceleratedAes = FALSE;
  static BOOLEAN  UseAcceleratedAes;

  if (!CheckedAcceleratedAes) {
 #if defined (MDE_CPU_X64)

    CPUID_VERSION_INFO_ECX  Ecx = { 0 };
    AsmCpuid (CPUID_VERSION_INFO, NULL, NULL, &Ecx.Uint32, NULL);
    UseAcceleratedAes = 0 != Ecx.Bits.AESNI;

 #elif defined (MDE_CPU_AARCH64)

    UINT64 const  Isar0 = ArmReadIdAA64Isar0Reg ();
    UseAcceleratedAes = 0 != (ARM_ID_AA64ISAR0_EL1_AES_MASK & (Isar0 >> ARM_ID_AA64ISAR0_EL1_AES_SHIFT));

 #else

    #error "OD_UseAcceleratedAes() not implemented for this architecture"

 #endif

    CheckedAcceleratedAes = TRUE;
  }

  if (UseAcceleratedAes) {
    Info.pOperations = &gAcceleratedAesEncryptionOperations;
    goto Done;
  }

 #endif // !AES_ACCELERATION_AVAILABLE

  Info.pOperations = &gFallbackAesEncryptionOperations;

Done:

  return Info;
}

// Creates a new encryptor for the specified algorithm.
// Writes key to pKeyBio.
static EFI_STATUS
OD_EncryptorNew (
  IN ALGORITHM_INFO           AlgorithmInfo,
  IN OUT BIO                  *pKeyBio,
  OUT OFFLINE_DUMP_ENCRYPTOR  **ppEncryptor
  )
{
  ASSERT (AlgorithmInfo.pOperations != NULL);
  ASSERT (pKeyBio != NULL);
  ASSERT (ppEncryptor != NULL);

  EFI_STATUS              Status;
  OFFLINE_DUMP_ENCRYPTOR  *pEncryptor = NULL;

  struct ENCRYPTOR_KEY_INFO {
    UINT64    InitializationVector;
    UINT8     Key[32];
  } CtrRandom;

  ASSERT (AlgorithmInfo.KeySize <= sizeof (CtrRandom.Key));
  if (AlgorithmInfo.KeySize > sizeof (CtrRandom.Key)) {
    DEBUG_PRINT (
                 DEBUG_ERROR,
                 "KeySize %u too large, max supported is %u\n",
                 AlgorithmInfo.KeySize,
                 (unsigned)sizeof (CtrRandom.Key)
                 );
    Status = EFI_INVALID_PARAMETER;
    goto Done;
  }

  if (!RandomBytes ((UINT8 *)&CtrRandom, sizeof (CtrRandom))) {
    DEBUG_PRINT (DEBUG_ERROR, "RandomBytes() failed\n");
    Status = EFI_NOT_READY;
    goto Done;
  }

  pEncryptor = AllocatePool (sizeof (*pEncryptor));
  if (pEncryptor == NULL) {
    DEBUG_PRINT (DEBUG_ERROR, "AllocatePool(OFFLINE_DUMP_ENCRYPTOR) failed\n");
    Status = EFI_OUT_OF_RESOURCES;
    goto Done;
  }

  DEBUG_PRINT (
               DEBUG_INFO,
               "Encryptor: Algorithm %u, KeySize %u, Accelerated %u\n",
               AlgorithmInfo.Algorithm,
               AlgorithmInfo.KeySize,
               AlgorithmInfo.pOperations != &gFallbackAesEncryptionOperations
               );

  pEncryptor->pEcbEncrypt          = AlgorithmInfo.pOperations->pEcbEncrypt;
  pEncryptor->InitializationVector = CtrRandom.InitializationVector;
  pEncryptor->Algorithm            = AlgorithmInfo.Algorithm;

  if (AlgorithmInfo.pOperations->pSetEncryptKey (CtrRandom.Key, AlgorithmInfo.KeySize * 8, &pEncryptor->Key)) {
    DEBUG_PRINT (DEBUG_ERROR, "set_encrypt_key() failed\n");
  } else if (!BIO_write (pKeyBio, CtrRandom.Key, AlgorithmInfo.KeySize)) {
    DEBUG_PRINT (DEBUG_ERROR, "BIO_write() failed\n");
  } else {
    Status = EFI_SUCCESS;
    goto Done;
  }

  OfflineDumpEncryptorDelete (pEncryptor);
  pEncryptor = NULL;
  Status     = EFI_DEVICE_ERROR;

Done:

  ASSERT (EFI_ERROR (Status) == (pEncryptor == NULL));
  ZeroMem (&CtrRandom, sizeof (CtrRandom));

  *ppEncryptor = pEncryptor;
  return Status;
}

void
OfflineDumpEncryptorDelete (
  IN OUT OFFLINE_DUMP_ENCRYPTOR  *pEncryptor
  )
{
  if (NULL != pEncryptor) {
    ZeroMem (pEncryptor, OFFSET_OF (OFFLINE_DUMP_ENCRYPTOR, KeyStreamBuffer));
    FreePool (pEncryptor);
  }
}

static void
OD_EncryptKeyStreamBuffer (
  IN OFFLINE_DUMP_ENCRYPTOR  *pEncryptor,
  IN UINT32                  BlockCount
  )
{
  pEncryptor->pEcbEncrypt (
                           (UINT8 *)pEncryptor->KeyStreamBuffer,
                           (UINT8 *)pEncryptor->KeyStreamBuffer,
                           BlockCount * sizeof (AES_BLOCK),
                           &pEncryptor->Key
                           );
}

void
OfflineDumpEncryptorEncrypt (
  IN OFFLINE_DUMP_ENCRYPTOR  *pEncryptor,
  IN UINT64                  StartingByteOffset,
  IN UINT32                  DataSize,
  IN void const              *pInputData,
  OUT void                   *pOutputData
  )
{
  ASSERT (pEncryptor != NULL);
  ASSERT (pInputData != NULL || DataSize == 0);
  ASSERT (pOutputData != NULL || DataSize == 0);
  ASSERT (0 == (StartingByteOffset & AES_BLOCK_MASK));
  ASSERT (0 == (DataSize & AES_BLOCK_MASK));

  UINT64 const      StartingBlockIndex = StartingByteOffset / AES_BLOCK_SIZE;
  AES_BLOCK *const  pInputBlocks       = (AES_BLOCK *)pInputData;
  AES_BLOCK *const  pOutputBlocks      = (AES_BLOCK *)pOutputData;
  UINT32 const      DataBlockCount     = DataSize / AES_BLOCK_SIZE;

  UINT32  ProcessedBlockCount = 0;

  while (DataBlockCount - ProcessedBlockCount >= KEY_STREAM_BUFFER_BLOCK_COUNT) {
    // Encrypt AES blocks in KeyStreamBlockCount-sized chunks.

    for (unsigned i = 0; i != KEY_STREAM_BUFFER_BLOCK_COUNT; i += 1) {
      pEncryptor->KeyStreamBuffer[i].Lo = StartingBlockIndex + ProcessedBlockCount + i;
      pEncryptor->KeyStreamBuffer[i].Hi = pEncryptor->InitializationVector;
    }

    OD_EncryptKeyStreamBuffer (pEncryptor, KEY_STREAM_BUFFER_BLOCK_COUNT);

    for (unsigned i = 0; i != KEY_STREAM_BUFFER_BLOCK_COUNT; i += 1) {
      pOutputBlocks[ProcessedBlockCount + i].Lo = pInputBlocks[ProcessedBlockCount + i].Lo ^ pEncryptor->KeyStreamBuffer[i].Lo;
      pOutputBlocks[ProcessedBlockCount + i].Hi = pInputBlocks[ProcessedBlockCount + i].Hi ^ pEncryptor->KeyStreamBuffer[i].Hi;
    }

    ProcessedBlockCount += KEY_STREAM_BUFFER_BLOCK_COUNT;
  }

  UINT32  remainingBlocks = DataBlockCount - ProcessedBlockCount;

  if (remainingBlocks > 0) {
    // Encrypt AES blocks in final chunk.

    for (unsigned i = 0; i != remainingBlocks; i += 1) {
      pEncryptor->KeyStreamBuffer[i].Lo = StartingBlockIndex + ProcessedBlockCount + i;
      pEncryptor->KeyStreamBuffer[i].Hi = pEncryptor->InitializationVector;
    }

    OD_EncryptKeyStreamBuffer (pEncryptor, remainingBlocks);

    for (unsigned i = 0; i != remainingBlocks; i += 1) {
      pOutputBlocks[ProcessedBlockCount + i].Lo = pInputBlocks[ProcessedBlockCount + i].Lo ^ pEncryptor->KeyStreamBuffer[i].Lo;
      pOutputBlocks[ProcessedBlockCount + i].Hi = pInputBlocks[ProcessedBlockCount + i].Hi ^ pEncryptor->KeyStreamBuffer[i].Hi;
    }

    ProcessedBlockCount += remainingBlocks;
  }

  return;
}

ENC_DUMP_ALGORITHM
OfflineDumpEncryptorAlgorithm (
  IN OFFLINE_DUMP_ENCRYPTOR const  *pEncryptor OPTIONAL
  )
{
  return pEncryptor ? pEncryptor->Algorithm : ENC_DUMP_ALGORITHM_NONE;
}

EFI_STATUS
OfflineDumpEncryptorNewKeyInfoBlock (
  IN ENC_DUMP_ALGORITHM       Algorithm,
  IN void const               *pRecipientCertificate,
  IN UINT32                   RecipientCertificateSize,
  OUT OFFLINE_DUMP_ENCRYPTOR  **ppEncryptor,
  OUT ENC_DUMP_KEY_INFO       **ppKeyInfo
  )
{
  EFI_STATUS  Status;

  STACK_OF (X509)* pRecipientStack = NULL;
  BIO                     *pKeyBio     = NULL;
  PKCS7                   *pPkcs7      = NULL;
  OFFLINE_DUMP_ENCRYPTOR  *pEncryptor  = NULL;
  ENC_DUMP_KEY_INFO       *pNewKeyInfo = NULL;

  ALGORITHM_INFO  const  AlgorithmInfo = OD_GetAlgorithmInfo (Algorithm);

  if (AlgorithmInfo.pOperations == NULL) {
    DEBUG_PRINT (DEBUG_ERROR, "Unsupported Algorithm %u\n", Algorithm);
    Status = EFI_UNSUPPORTED;
    goto Error;
  }

  pRecipientStack = sk_X509_new_null ();
  if (!pRecipientStack) {
    DEBUG_PRINT (DEBUG_ERROR, "sk_X509_new_null() failed\n");
    Status = EFI_OUT_OF_RESOURCES;
    goto Error;
  }

  {
    UINT8 const  *pRecipientCertificateBytes = pRecipientCertificate;
    X509         *pRecipient                 = d2i_X509 (NULL, &pRecipientCertificateBytes, RecipientCertificateSize);
    if (!pRecipient) {
      DEBUG_PRINT (DEBUG_ERROR, "d2i_X509() failed\n");
      Status = EFI_INVALID_PARAMETER;
      goto Error;
    }

    sk_X509_push (pRecipientStack, pRecipient);
  }

  pKeyBio = BIO_new (BIO_s_mem ());
  if (!pKeyBio) {
    DEBUG_PRINT (DEBUG_ERROR, "BIO_new(BIO_s_mem()) failed\n");
    Status = EFI_OUT_OF_RESOURCES;
    goto Error;
  }

  // Randomly generate a key and an initialization vector.
  // Write the key to pKeyBio.
  // Create an Encryptor with the key and IV.
  Status = OD_EncryptorNew (AlgorithmInfo, pKeyBio, &pEncryptor);
  if (EFI_ERROR (Status)) {
    goto Error;
  }

  // pKeyBio now contains the dump key. Wrap it in a CMS (PKCS7) envelope.
  // We may be wrapping a 128, 192, or 256-bit key. Key wrapping algorithm must be at
  // least as strong as the key being wrapped, so wrap using AES-256-CBC.
  pPkcs7 = PKCS7_encrypt (pRecipientStack, pKeyBio, EVP_aes_256_cbc (), PKCS7_BINARY);
  if (!pPkcs7) {
    DEBUG_PRINT (DEBUG_ERROR, "PKCS7_encrypt() failed\n");
    Status = EFI_DEVICE_ERROR;
    goto Error;
  }

  int  Pkcs7Size = i2d_PKCS7 (pPkcs7, NULL);

  if (Pkcs7Size <= 0) {
    DEBUG_PRINT (DEBUG_ERROR, "i2d_PKCS7() failed\n");
    Status = EFI_DEVICE_ERROR;
    goto Error;
  }

  UINT32  KeyInfoSize = sizeof (ENC_DUMP_KEY_INFO) + sizeof (UINT64) + Pkcs7Size;

  KeyInfoSize = (KeyInfoSize + 7u) & ~7u; // Pad to 8-byte boundary.
  pNewKeyInfo = AllocateZeroPool (KeyInfoSize);
  if (!pNewKeyInfo) {
    DEBUG_PRINT (DEBUG_ERROR, "AllocateZeroPool(KeyInfoSize = %u) failed\n", KeyInfoSize);
    Status = EFI_OUT_OF_RESOURCES;
    goto Error;
  }

  pNewKeyInfo->BlockSize                = KeyInfoSize;
  pNewKeyInfo->Algorithm                = Algorithm;
  pNewKeyInfo->InitializationVectorSize = sizeof (UINT64);
  pNewKeyInfo->EncryptedKeyCmsSize      = (UINT32)Pkcs7Size;

  UINT8  *pKeyInfoData = (UINT8 *)(pNewKeyInfo + 1);

  CopyMem (pKeyInfoData, &pEncryptor->InitializationVector, sizeof (UINT64));
  pKeyInfoData += sizeof (UINT64);
  Pkcs7Size     = i2d_PKCS7 (pPkcs7, &pKeyInfoData);
  if (pNewKeyInfo->EncryptedKeyCmsSize != (UINT32)Pkcs7Size) {
    DEBUG_PRINT (DEBUG_ERROR, "i2d_PKCS7() returned %d, expected %u\n", Pkcs7Size, pNewKeyInfo->EncryptedKeyCmsSize);
    Status = EFI_DEVICE_ERROR;
    goto Error;
  }

  Status = EFI_SUCCESS;
  goto Done;

Error:

  if (pEncryptor) {
    OfflineDumpEncryptorDelete (pEncryptor);
    pEncryptor = NULL;
  }

  if (pNewKeyInfo) {
    FreePool (pNewKeyInfo);
    pNewKeyInfo = NULL;
  }

Done:

  PKCS7_free (pPkcs7);
  BIO_free (pKeyBio);
  sk_X509_pop_free (pRecipientStack, X509_free);

  *ppEncryptor = pEncryptor;
  *ppKeyInfo   = pNewKeyInfo;
  return Status;
}

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/OfflineDumpWriterLib.inf`:

```inf
[Defines]

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpWriterLib
  VERSION_STRING                 = 0.1
  FILE_GUID                      = 600a8132-12dc-4f8b-af68-171b14a780bf
  MODULE_TYPE                    = DXE_DRIVER
  LIBRARY_CLASS                  = OfflineDumpWriterLib|DXE_DRIVER DXE_CORE UEFI_APPLICATION UEFI_DRIVER

[Sources]

  Collect.c
  Encryptor.c
  RedactionMap.c
  Writer.c

[Sources.AARCH64]

  AARCH64-GCC/aesv8-armx.S | GCC

[Sources.X64]

  X64-MSFT/aesni-x86_64.nasm | MSFT

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec
  MdePkg/MdePkg.dec
  CryptoPkg/CryptoPkg.dec

[LibraryClasses]

  BaseLib
  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  PrintLib
  SynchronizationLib
  UefiBootServicesTableLib

  BaseCryptLib
  OpensslLib

[Protocols]

  gEfiBlockIoProtocolGuid           ## CONSUMES
  gEfiBlockIo2ProtocolGuid          ## CONSUMES

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/RedactionMap.c`:

```c
#include <Library/OfflineDumpRedactionMapInternal.h>
#include <Library/OfflineDumpRedactionMap.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>

// (Value + DivisorMacro - 1) >> DivisorMacro_SHIFT
#define DIVIDE_AND_ROUND_UP(Value, DivisorMacro) \
    ((Value + DivisorMacro - 1u) >> (DivisorMacro##_SHIFT))

#define BYTES_PER_CHUNK_SHIFT  12u
#define BYTES_PER_CHUNK        (1u << BYTES_PER_CHUNK_SHIFT)

typedef UINT32 CHUNK_NUM;

typedef struct _offline_dump_redaction_map_CHUNK {
  CHUNK_NUM    Data[BYTES_PER_CHUNK / sizeof (CHUNK_NUM)];
} CHUNK;
STATIC_ASSERT (
               sizeof (CHUNK) == BYTES_PER_CHUNK,
               "sizeof(CHUNK) must be BYTES_PER_CHUNK"
               );

typedef struct {
  CHUNK_NUM    BitmapChunkNum[BITMAPS_PER_TABLE1];
} TABLE1;
STATIC_ASSERT (
               sizeof (TABLE1) % sizeof (CHUNK) == 0,
               "sizeof(TABLE1) must be a multiple of sizeof(CHUNK)"
               );

typedef UINT64 ENTRY;
STATIC_ASSERT (
               sizeof (ENTRY) * 8 == BITS_PER_ENTRY,
               "sizeof(ENTRY) must align with BITS_PER_ENTRY"
               );

typedef struct {
  ENTRY    Entry[ENTRIES_PER_BITMAP]; // Indexed by BitmapIndex
} BITMAP;
STATIC_ASSERT (
               sizeof (BITMAP) % sizeof (CHUNK) == 0,
               "sizeof(BITMAP) must be a multiple of sizeof(CHUNK)"
               );

#define CHUNKS_PER_TABLE1  (sizeof(TABLE1) / sizeof(CHUNK))
#define CHUNKS_PER_BITMAP  (sizeof(BITMAP) / sizeof(CHUNK))

// Implements BitScanForward64:
// If Value == 0, returns FALSE.
// If Value != 0, returns TRUE and sets *pTrailingZeros to the number of trailing zero bits in Value.
static BOOLEAN
CountTrailingZeros64 (
  IN UINT64  Value,
  OUT UINT8  *pTrailingZeros
  )
{
 #ifdef _MSC_VER
  unsigned long  TrailingZeros = 0;
  if (_BitScanForward64 (&TrailingZeros, Value)) {
    *pTrailingZeros = (UINT8)TrailingZeros;
    return TRUE;
  } else {
    return FALSE;
  }

 #else
  if (Value == 0) {
    return FALSE;
  } else {
    *pTrailingZeros = (UINT8)__builtin_ctzll (Value);
    return TRUE;
  }

 #endif
}

// Use result as index into Table0 to get Table1ChunkNum.
// Precondition: PageNum < 2^44
static UINT32
PageNumToToTable0Index (
  IN UINT64  PageNum
  )
{
  ASSERT (PageNum < MAX_BITS_PER_TABLE0);  // Data corruption
  return (UINT32)(PageNum >> BITS_PER_TABLE1_SHIFT) & (MAX_TABLE1S_PER_TABLE0 - 1);
}

// Use result as index into Table1 to get BitmapChunkNum.
static UINT32
PageNumToTable1Index (
  IN UINT64  PageNum
  )
{
  return (UINT32)(PageNum >> BITS_PER_BITMAP_SHIFT) & (BITMAPS_PER_TABLE1 - 1);
}

// Use result as index into Bitmap to get Entry.
static UINT32
PageNumToBitmapIndex (
  IN UINT64  PageNum
  )
{
  return (UINT32)(PageNum >> BITS_PER_ENTRY_SHIFT) & (ENTRIES_PER_BITMAP - 1);
}

// Use result as index into Entry to get Bit, i.e.
// Bit = (Entry >> EntryShift) & 1.
static UINT8
PageNumToEntryShift (
  IN UINT64  PageNum
  )
{
  return (UINT8)(PageNum & (BITS_PER_ENTRY - 1));
}

// Returns &Table0[PageNum.Table0Index].
// Precondition: PageNum < pMap->MaxPageNum
static CHUNK_NUM *
PageNumToTable1ChunkNum (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap,
  IN UINT64                            PageNum
  )
{
  ASSERT (pMap->MaxPageNum <= MAX_BITS_PER_TABLE0); // Data corruption
  ASSERT (PageNum < pMap->MaxPageNum);              // Precondition
  CHUNK_NUM  *pTable0 = pMap->pBufferChunks[0].Data;
  return &pTable0[PageNumToToTable0Index (PageNum)];
}

// Returns (TABLE1*)&pBufferChunks[ChunkNum]
// Precondition: ChunkNum < pMap->MaxBufferChunks
static TABLE1 *
GetChunkAsTable1 (
  IN OFFLINE_DUMP_REDACTION_MAP  *pMap,
  IN CHUNK_NUM                   ChunkNum
  )
{
  ASSERT (ChunkNum + (CHUNK_NUM)(sizeof (TABLE1) / sizeof (CHUNK)) > ChunkNum);
  ASSERT (ChunkNum + (CHUNK_NUM)(sizeof (TABLE1) / sizeof (CHUNK)) <= pMap->MaxBufferChunks);
  return (TABLE1 *)&pMap->pBufferChunks[ChunkNum];
}

// Returns &Table1[PageNum.Table1Index]
static CHUNK_NUM *
PageNumToBitmapChunkNum (
  IN TABLE1  *pTable1,
  IN UINT64  PageNum
  )
{
  return &pTable1->BitmapChunkNum[PageNumToTable1Index (PageNum)];
}

// Returns (BITMAP*)&pBufferChunks[ChunkNum]
// Precondition: ChunkNum < pMap->MaxBufferChunks
static BITMAP *
GetChunkAsBitmap (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap,
  IN CHUNK_NUM                         ChunkNum
  )
{
  ASSERT (ChunkNum + (CHUNK_NUM)(sizeof (BITMAP) / sizeof (CHUNK)) > ChunkNum);
  ASSERT (ChunkNum + (CHUNK_NUM)(sizeof (BITMAP) / sizeof (CHUNK)) <= pMap->MaxBufferChunks);
  return (BITMAP *)&pMap->pBufferChunks[ChunkNum];
}

static void
AssertMapValid (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap
  )
{
  ASSERT (pMap->MaxPageNum <= MAX_BITS_PER_TABLE0);
  ASSERT (0 == (UINTN)pMap->pBufferChunks % sizeof (ENTRY));
  ASSERT (pMap->MaxBufferChunks < 0x80000000);
  ASSERT (pMap->UsedBufferChunks <= pMap->MaxBufferChunks);

  if (pMap->MaxPageNum != 0) {
    ASSERT (pMap->pBufferChunks != NULL);
    ASSERT (pMap->UsedBufferChunks != 0);    // Expect TABLE0.
  }
}

EFI_STATUS
OfflineDumpRedactionMap_Init (
  OUT OFFLINE_DUMP_REDACTION_MAP  *pMap,
  IN void                         *pBuffer,
  IN UINTN                        BufferSize,
  IN UINT64                       MaxPageNum
  )
{
  UINT32 const  MaxBufferChunks =
    (BufferSize / sizeof (CHUNK)) >= ~(UINT32)0
        ? ~(UINT32)0
        : (UINT32)(BufferSize / sizeof (CHUNK));

  pMap->MaxPageNum       = 0; // If an error occurs, the resulting bitmap redacts nothing.
  pMap->pBufferChunks    = NULL;
  pMap->MaxBufferChunks  = 0;
  pMap->UsedBufferChunks = 0;   // If an error occurs, the resulting bitmap's buffer is full.

  EFI_STATUS  Status;
  if (MaxPageNum > MAX_BITS_PER_TABLE0) {
    // We can't handle page numbers 2^44 or larger.
    Status = EFI_INVALID_PARAMETER;
  } else {
    #define TABLE0ITEMS_FROM_PAGENUMBERMAX(MaxPageNum) \
        (UINT32)DIVIDE_AND_ROUND_UP(MaxPageNum, BITS_PER_TABLE1)

    // Compute the number of items needed in Table0 to reach up to MaxPageNum.
    STATIC_ASSERT (
                   0 == TABLE0ITEMS_FROM_PAGENUMBERMAX (0),
                   "Incorrect computation for Table0Items(0)"
                   );
    STATIC_ASSERT (
                   1 == TABLE0ITEMS_FROM_PAGENUMBERMAX (1),
                   "Incorrect computation for Table0Items(1)"
                   );
    STATIC_ASSERT (
                   MAX_TABLE1S_PER_TABLE0 == TABLE0ITEMS_FROM_PAGENUMBERMAX (MAX_BITS_PER_TABLE0),
                   "Incorrect computation for Table0Items(max)"
                   );
    UINT32 const  Table0Items  = TABLE0ITEMS_FROM_PAGENUMBERMAX (MaxPageNum);
    UINT32 const  Table0Bytes  = Table0Items * sizeof (CHUNK_NUM);
    UINT32 const  Table0Chunks = DIVIDE_AND_ROUND_UP (Table0Bytes, BYTES_PER_CHUNK);
    if (Table0Chunks > MaxBufferChunks) {
      Status = EFI_OUT_OF_RESOURCES;
    } else {
      // Success: redact up to MaxPageNum, bitmap contains empty Table0.
      ZeroMem (pBuffer, Table0Chunks * sizeof (CHUNK));
      pMap->MaxPageNum       = MaxPageNum;
      pMap->pBufferChunks    = (CHUNK *)pBuffer;
      pMap->MaxBufferChunks  = MaxBufferChunks;
      pMap->UsedBufferChunks = Table0Chunks;
      Status                 = EFI_SUCCESS;
    }
  }

  AssertMapValid (pMap);
  return Status;
}

EFI_STATUS
OfflineDumpRedactionMap_Mark (
  IN OUT OFFLINE_DUMP_REDACTION_MAP  *pMap,
  IN BOOLEAN                         IsRedacted,
  IN UINT64                          BeginPageNum,
  IN UINT64                          EndPageNum
  )
{
  AssertMapValid (pMap);

  if ((EndPageNum < BeginPageNum) || (EndPageNum > pMap->MaxPageNum)) {
    return EFI_INVALID_PARAMETER;
  }

  UINT64  PageNum = BeginPageNum;
  while (PageNum < EndPageNum) {
    // Each iteration of this loop will make changes to at most one BITMAP.
    //
    // 1. Find the bitmap that contains PageNum.
    //    - If IsRedacted and the bitmap is NULL, we allocate a new BITMAP.
    //    - If !IsRedacted and the bitmap is NULL, increment PageNum and loop.
    // 2. Update that bitmap as appropriate.
    // 3. If changes extend beyond the end of the current iteration's BITMAP,
    //    increment PageNum and loop.

    UINT64 const  NextBitmapPageNum =
      ((PageNum >> BITS_PER_BITMAP_SHIFT) + 1) << BITS_PER_BITMAP_SHIFT;

    CHUNK_NUM  BitmapChunkNum;
    if (IsRedacted) {
      CHUNK_NUM  Table1ChunkNum;

      // When redacting, we allocate new TABLE1/BITMAP if not already allocated.

      CHUNK_NUM * const  pTable1ChunkNum = PageNumToTable1ChunkNum (pMap, PageNum);
      Table1ChunkNum = *pTable1ChunkNum;
      if (Table1ChunkNum == 0) {
        if (pMap->MaxBufferChunks < pMap->UsedBufferChunks + CHUNKS_PER_TABLE1) {
          return EFI_OUT_OF_RESOURCES;
        }

        Table1ChunkNum          = pMap->UsedBufferChunks;
        *pTable1ChunkNum        = Table1ChunkNum;
        pMap->UsedBufferChunks += CHUNKS_PER_TABLE1;

        TABLE1 * const  pTable1 = GetChunkAsTable1 (pMap, Table1ChunkNum);
        ZeroMem (pTable1, sizeof (*pTable1));
      }

      CHUNK_NUM * const  pBitmapChunkNum = PageNumToBitmapChunkNum (GetChunkAsTable1 (pMap, Table1ChunkNum), PageNum);
      BitmapChunkNum = *pBitmapChunkNum;
      if (BitmapChunkNum == 0) {
        if (pMap->MaxBufferChunks < pMap->UsedBufferChunks + CHUNKS_PER_BITMAP) {
          return EFI_OUT_OF_RESOURCES;
        }

        BitmapChunkNum          = pMap->UsedBufferChunks;
        *pBitmapChunkNum        = BitmapChunkNum;
        pMap->UsedBufferChunks += CHUNKS_PER_BITMAP;

        BITMAP * const  pBitmap = GetChunkAsBitmap (pMap, BitmapChunkNum);
        ZeroMem (pBitmap, sizeof (*pBitmap));
      }
    } else {
      // When unredacting, we don't need to allocate any new TABLE1 or BITMAP. If the
      // TABLE1 or BITMAP is not already allocated then there are no redacted pages
      // in the corresponding address range and we can just skip it.

      CHUNK_NUM const  Table1ChunkNum = *PageNumToTable1ChunkNum (pMap, PageNum);
      if (Table1ChunkNum == 0) {
        // No redacted pages in this Table1's range. Skip to next Table1's range.
        UINT64 const  NextTable1PageNum = ((PageNum >> BITS_PER_TABLE1_SHIFT) + 1) << BITS_PER_TABLE1_SHIFT;
        PageNum = NextTable1PageNum;         // May be greater than EndPageNum.
        continue;
      }

      BitmapChunkNum = *PageNumToBitmapChunkNum (GetChunkAsTable1 (pMap, Table1ChunkNum), PageNum);
      if (BitmapChunkNum == 0) {
        // No redacted pages in this Bitmap's range. Skip to next Bitmap's range.
        PageNum = NextBitmapPageNum;         // May be greater than EndPageNum.
        continue;
      }
    }

    BITMAP * const  pBitmap          = GetChunkAsBitmap (pMap, BitmapChunkNum);
    UINT64 const    BitmapEndPageNum = MIN (EndPageNum, NextBitmapPageNum);

    // Leading partial entry?
    UINT8 const  HeadEntryShift = PageNumToEntryShift (PageNum);
    if (HeadEntryShift != 0) {
      // HeadBitCount is MIN(bits after HeadEntryShift, pages yet to be marked).
      UINT8 const  HeadBitCount = (UINT8)MIN (BITS_PER_ENTRY - HeadEntryShift, BitmapEndPageNum - PageNum);

      // Mask bits are:
      // - 0s for bits [0..HeadEntryShift)
      // - 1s for bits [HeadEntryShift..HeadEntryShift + HeadBitCount)
      // - 0s for bits [HeadEntryShift + HeadBitCount..BITS_PER_ENTRY)
      ENTRY const  Mask = ~(ENTRY)0                          // Start with all-1s.
                          >> (BITS_PER_ENTRY - HeadBitCount) // Shift right to give HeadBitCount 1s at bottom.
                          << HeadEntryShift;                 // Shift left to give HeadBitCount 1s in the middle.

      ENTRY * const  pBitmapEntry = &pBitmap->Entry[PageNumToBitmapIndex (PageNum)];
      if (IsRedacted) {
        *pBitmapEntry |= Mask;
      } else {
        *pBitmapEntry &= ~Mask;
      }

      PageNum += HeadBitCount;

      if (PageNum >= BitmapEndPageNum) {
        ASSERT (PageNum == BitmapEndPageNum);
        continue;
      }
    }

    ASSERT (PageNum <= BitmapEndPageNum);
    ASSERT (0 == PageNumToEntryShift (PageNum));

    // Full entries?
    {
      UINT32 const  FullEntryCount = (UINT32)(BitmapEndPageNum - PageNum) >> BITS_PER_ENTRY_SHIFT;
      ENTRY const   FullEntryMask  = IsRedacted ? ~(ENTRY)0 : (ENTRY)0;
      UINT32        BitmapIndex    = PageNumToBitmapIndex (PageNum);
      UINT32 const  BitmapEndIndex = BitmapIndex + FullEntryCount;
      for ( ; BitmapIndex != BitmapEndIndex; BitmapIndex += 1) {
        pBitmap->Entry[BitmapIndex] = FullEntryMask;
      }

      PageNum += (UINT64)FullEntryCount << BITS_PER_ENTRY_SHIFT;
    }

    ASSERT (PageNum <= BitmapEndPageNum);
    ASSERT (0 == PageNumToEntryShift (PageNum));

    // Trailing partial entry?
    UINT8 const  TailBitCount = (UINT8)(BitmapEndPageNum - PageNum) & (BITS_PER_ENTRY - 1);
    if (TailBitCount != 0) {
      ENTRY const  Mask = ~(ENTRY)0         // Start with all-1s.
                          << TailBitCount;  // Shift left to give TailBitCount 0s at bottom.

      ENTRY * const  pBitmapEntry = &pBitmap->Entry[PageNumToBitmapIndex (PageNum)];
      if (IsRedacted) {
        *pBitmapEntry |= ~Mask;
      } else {
        *pBitmapEntry &= Mask;
      }

      PageNum += TailBitCount;

      ASSERT (PageNum == EndPageNum);
      ASSERT (PageNum == BitmapEndPageNum);
      break;
    }
  }

  return EFI_SUCCESS;
}

BOOLEAN
OfflineDumpRedactionMap_IsRedacted (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap,
  IN UINT64                            PageNum
  )
{
  AssertMapValid (pMap);
  if (PageNum >= pMap->MaxPageNum) {
    return FALSE;
  }

  CHUNK_NUM const  Table1ChunkNum = *PageNumToTable1ChunkNum (pMap, PageNum);
  if (Table1ChunkNum == 0) {
    return FALSE;
  }

  CHUNK_NUM const  BitmapChunkNum = *PageNumToBitmapChunkNum (
                                                              GetChunkAsTable1 ((OFFLINE_DUMP_REDACTION_MAP *)pMap, Table1ChunkNum),
                                                              PageNum
                                                              );
  if (BitmapChunkNum == 0) {
    return FALSE;
  }

  BITMAP const * const  pBitmap    = GetChunkAsBitmap (pMap, BitmapChunkNum);
  ENTRY const           Entry      = pBitmap->Entry[PageNumToBitmapIndex (PageNum)];
  UINT8 const           EntryShift = PageNumToEntryShift (PageNum);
  return ((Entry >> EntryShift) & 1) != 0;
}

OFFLINE_DUMP_REDACTION_MAP_RANGE
OfflineDumpRedactionMap_GetFirstRedactedRange (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap,
  IN UINT64                            BeginPageNum,
  IN UINT64                            EndPageNum
  )
{
  OFFLINE_DUMP_REDACTION_MAP_RANGE  Result;

  AssertMapValid (pMap);
  ASSERT (BeginPageNum <= EndPageNum);

  UINT64 const  ClampedEndPageNum    = MIN (EndPageNum, pMap->MaxPageNum);
  UINT64        BeginRedactedPageNum = EndPageNum;
  BOOLEAN       IsRedacted           = FALSE;

  UINT64  PageNum = BeginPageNum;
  for ( ;;) {
    if (PageNum >= ClampedEndPageNum) {
      // If !IsRedacted: we didn't find any redacted pages, BeginRedactedPageNum == EndPageNum.
      // If IsRedacted: we didn't find any unredacted pages after BeginRedactedPageNum.
      Result.BeginRedactedPageNum = BeginRedactedPageNum;
      Result.EndRedactedPageNum   = EndPageNum;
      goto Done;
    }

    // Each iteration of this loop will scan at most one BITMAP.
    //
    // 1. Find the bitmap that contains PageNum.
    //    - If !IsRedacted and the bitmap is NULL, skip to next bitmap (restart loop).
    //    - If IsRedacted and the bitmap is NULL, stop (found 0 after finding 1).
    // 2. Scan for target within this bitmap.
    //    - If not found, skip to next bitmap (restart loop).

    UINT64 const  NextBitmapPageNum =
      ((PageNum >> BITS_PER_BITMAP_SHIFT) + 1) << BITS_PER_BITMAP_SHIFT;

    // When scanning, we don't need to allocate a new TABLE1 or BITMAP. If the
    // TABLE1 or BITMAP is not already allocated then there are no redacted pages
    // in the corresponding address range and we can just skip it.

    CHUNK_NUM const  Table1ChunkNum = *PageNumToTable1ChunkNum (pMap, PageNum);
    if (Table1ChunkNum == 0) {
      // NULL table is considered as full of 0s.

      if (IsRedacted) {
        // Scanning for 0 and found it. We're done.
        Result.BeginRedactedPageNum = BeginRedactedPageNum;
        Result.EndRedactedPageNum   = PageNum;
        goto Done;
      }

      // Skip to next Table1's range.
      UINT64 const  NextTable1PageNum = ((PageNum >> BITS_PER_TABLE1_SHIFT) + 1) << BITS_PER_TABLE1_SHIFT;
      PageNum = NextTable1PageNum;       // May be greater than ClampedEndPageNum.
      continue;
    }

    CHUNK_NUM const  BitmapChunkNum = *PageNumToBitmapChunkNum (
                                                                GetChunkAsTable1 ((OFFLINE_DUMP_REDACTION_MAP *)pMap, Table1ChunkNum),
                                                                PageNum
                                                                );
    if (BitmapChunkNum == 0) {
      // NULL bitmap is considered as full of 0s.

      if (IsRedacted) {
        // Scanning for 0 and found it. We're done.
        Result.BeginRedactedPageNum = BeginRedactedPageNum;
        Result.EndRedactedPageNum   = PageNum;
        goto Done;
      }

      // Skip to next Bitmap's range.
      PageNum = NextBitmapPageNum;       // May be greater than ClampedEndPageNum.
      continue;
    }

    static ENTRY const  AllBitsClear     = (ENTRY)0;
    static ENTRY const  AllBitsSet       = ~(ENTRY)0;
    BITMAP * const      pBitmap          = GetChunkAsBitmap (pMap, BitmapChunkNum);
    UINT64 const        BitmapEndPageNum = MIN (ClampedEndPageNum, NextBitmapPageNum);

IsRedactedSet:;

    // If scanning for 0, invert the bits before counting zeros.
    // If scanning for 1, don't invert before counting zeros.
    ENTRY const  AllBitsSetIfRedacted = IsRedacted ? AllBitsSet : AllBitsClear;

    // Leading partial entry?
    UINT8 const  HeadEntryShift = PageNumToEntryShift (PageNum);
    if (HeadEntryShift != 0) {
      UINT8 const  HeadBitCount = (UINT8)MIN (BITS_PER_ENTRY - HeadEntryShift, BitmapEndPageNum - PageNum);
      ENTRY const  ShiftedEntry = (pBitmap->Entry[PageNumToBitmapIndex (PageNum)] ^ AllBitsSetIfRedacted) >> HeadEntryShift;
      UINT8        TrailingZeros;
      if (CountTrailingZeros64 (ShiftedEntry, &TrailingZeros) &&
          (TrailingZeros < HeadBitCount))
      {
        PageNum += TrailingZeros;

        if (IsRedacted) {
          // Scanning for 0 and found it. We're done.
          Result.BeginRedactedPageNum = BeginRedactedPageNum;
          Result.EndRedactedPageNum   = PageNum;
          goto Done;
        }

        // Scanning for 1 and found it. Change modes to scan for 0.
        BeginRedactedPageNum = PageNum;
        IsRedacted           = TRUE;
        goto IsRedactedSet;
      }

      PageNum += HeadBitCount;

      if (PageNum >= BitmapEndPageNum) {
        ASSERT (PageNum == BitmapEndPageNum);
        continue;
      }
    }

    ASSERT (PageNum <= BitmapEndPageNum);
    ASSERT (0 == PageNumToEntryShift (PageNum));

    // Full entries.
    {
      UINT32 const  FullEntryCount = (UINT32)(BitmapEndPageNum - PageNum) >> BITS_PER_ENTRY_SHIFT;
      UINT32 const  BitmapIndex    = PageNumToBitmapIndex (PageNum);
      for (UINT32 FullEntryIndex = 0; FullEntryIndex != FullEntryCount; FullEntryIndex += 1) {
        ENTRY const  Entry = pBitmap->Entry[BitmapIndex + FullEntryIndex] ^ AllBitsSetIfRedacted;
        UINT8        TrailingZeros;
        if (CountTrailingZeros64 (Entry, &TrailingZeros)) {
          PageNum += (UINT64)FullEntryIndex << BITS_PER_ENTRY_SHIFT;
          PageNum += TrailingZeros;
          ASSERT (PageNum <= BitmapEndPageNum);

          if (IsRedacted) {
            // Scanning for 0 and found it. We're done.
            Result.BeginRedactedPageNum = BeginRedactedPageNum;
            Result.EndRedactedPageNum   = PageNum;
            goto Done;
          }

          // Scanning for 1 and found it. Change modes to scan for 0.
          BeginRedactedPageNum = PageNum;
          IsRedacted           = TRUE;
          goto IsRedactedSet;
        }
      }

      PageNum += (UINT64)FullEntryCount << BITS_PER_ENTRY_SHIFT;
    }

    ASSERT (PageNum <= BitmapEndPageNum);
    ASSERT (0 == PageNumToEntryShift (PageNum));

    // Trailing partial entry?
    UINT8 const  TailBitCount = (UINT8)(BitmapEndPageNum - PageNum) & (BITS_PER_ENTRY - 1);
    if (TailBitCount != 0) {
      ENTRY const  Mask = ~(ENTRY)0         // Start with all-1s.
                          << TailBitCount;  // Shift left to give TailBitCount 0s at bottom.
      ENTRY const  MaskedEntry = (pBitmap->Entry[PageNumToBitmapIndex (PageNum)] ^ AllBitsSetIfRedacted) & ~Mask;
      UINT8        TrailingZeros;
      if (CountTrailingZeros64 (MaskedEntry, &TrailingZeros) &&
          (TrailingZeros < TailBitCount))
      {
        PageNum += TrailingZeros;

        if (IsRedacted) {
          // Scanning for 0 and found it. We're done.
          Result.BeginRedactedPageNum = BeginRedactedPageNum;
          Result.EndRedactedPageNum   = PageNum;
          goto Done;
        }

        // Scanning for 1 and found it. Continue scanning for 0.
        BeginRedactedPageNum = PageNum;
        IsRedacted           = TRUE;

        ENTRY const  RemainingEntry         = ~(MaskedEntry >> TrailingZeros);
        UINT8        RemainingTrailingZeros = 0;
        ASSERT (RemainingEntry != 0);        // Bit [TailBitCount - TrailingZeros] is 1.
        CountTrailingZeros64 (RemainingEntry, &RemainingTrailingZeros);
        PageNum += RemainingTrailingZeros;

        ASSERT (PageNum <= EndPageNum);
        ASSERT (PageNum <= BitmapEndPageNum);

        Result.BeginRedactedPageNum = BeginRedactedPageNum;
        Result.EndRedactedPageNum   = PageNum;
        goto Done;
      }

      PageNum += TailBitCount;

      ASSERT (PageNum == EndPageNum);
      ASSERT (PageNum == BitmapEndPageNum);

      Result.BeginRedactedPageNum = BeginRedactedPageNum;
      Result.EndRedactedPageNum   = EndPageNum;
      goto Done;
    }
  }

Done:

  return Result;
}

UINT64
OfflineDumpRedactionMap_MaxPageNumber (
  IN OFFLINE_DUMP_REDACTION_MAP const  *pMap
  )
{
  ASSERT (pMap->MaxPageNum <= MAX_BITS_PER_TABLE0);
  return pMap->MaxPageNum;
}

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/Writer.c`:

```c
#include <Library/OfflineDumpWriter.h>
#include <Library/OfflineDumpEncryptor.h>
#include <Library/OfflineDumpVariables.h>

#include <Uefi.h>
#include <Protocol/BlockIo.h>
#include <Protocol/BlockIo2.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/SynchronizationLib.h>
#include <Library/UefiBootServicesTableLib.h>

#include <Library/UefiLib.h>

#define DEBUG_PRINT(bits, fmt, ...)  _DEBUG_PRINT(bits, "%a: " fmt, __func__, ##__VA_ARGS__)

// For use in printf format values.
typedef long long unsigned llu_t;

static const UINT8   BufferCountDefault       = 3;
static const UINT32  BufferMemoryLimitDefault = SIZE_1MB * 3; // 3 MB
static const UINT32  SectionCountMax          = (SIZE_2GB - sizeof (RAW_DUMP_HEADER)) / sizeof (RAW_DUMP_SECTION_HEADER);
static const UINT32  SectionAlign             = 16;

typedef struct ODW_BUFFER_INFO ODW_BUFFER_INFO;

struct OFFLINE_DUMP_WRITER {
  OFFLINE_DUMP_ENCRYPTOR       *pEncryptor;        // NULL if unencrypted.
  UINT8                        *pHeaders;          // HeadersSize buffer for encHdr+dumpHdr+sectionHdrs (padded to a multiple of BlockSize).
  UINT8                        *pHeadersSync;      // HeadersSyncSize buffer for writing headers. Used only when no async I/O support.
  ODW_BUFFER_INFO              *pBufferInfos;      // BufferCount buffers, each with room for BufferSize bytes.
  EFI_EVENT                    OperationCompleted; // Signaled by ODW_BufferInfoOperationComplete.

  // Above this line: Allocations that must be freed during destruction.
  // Below this line: fields that are set up during construction and never modified.

  EFI_BLOCK_IO2_PROTOCOL       *pBlockIo2;                      // Set if async IO is supported. If NULL, use pBlockIo for blocking IO.
  EFI_BLOCK_IO_PROTOCOL        *pBlockIo;                       // Set only if pBlockIo2 is NULL.
  UINT64                       MediaSize;                       // Storage size of the device in bytes.
  UINT32                       MediaID;                         // Media ID of the device (used to trigger error if media is changed).
  UINT32                       RawDumpOffset;                   // Size of encryption headers (if any). RawDumpHeader is at &pHeaders[RawDumpOffset]
  UINT32                       HeadersSize;                     // Size of pHeaders. This must be a multiple of BlockSize.
  UINT32                       HeadersSyncSize;                 // Size of pHeadersSync. This must be a multiple of BlockSize.
  UINT32                       SectionCountExpected;            // pHeaders has room for this many section headers.
  UINT32                       BufferSize;                      // Size of each pBufferInfos buffer. Multiple of MediaBlockSize, multiple of EFI_PAGE_SIZE.
  UINT8                        BufferCount;                     // Number of pBufferInfos buffers.
  UINT8                        MediaBlockShift;                 // Log2 of MediaBlockSize.

  // Above this line: fields that are set up during construction and never modified.
  // Below this line: fields that are modified during operation.

  EFI_STATUS                   LastWriteError;                   // Most recent write error. Will cause dump to be marked invalid.
  UINT32                       CurrentBufferInfoUsed;            // Bytes written to pCurrentBufferInfo's buffer.
  UINT64                       FlushedMediaPosition;             // MediaPosition = FlushedMediaPosition + CurrentBufferInfoUsed.

  // Each BufferInfo should be covered by exactly one of the following at all times:

  ODW_BUFFER_INFO              *pCurrentBufferInfo;       // Filled up to CurrentBufferInfoUsed.
  ODW_BUFFER_INFO              *pFirstFreeBufferInfo;     // Linked-list of empty buffer infos.
  UINT32 volatile              BusyBufferInfos;           // Write operations in progress.
  ODW_BUFFER_INFO *volatile    pFirstCompletedBufferInfo; // Linked-list of completed buffer infos ready to be flushed into pFirstFreeBufferInfo.
};

struct ODW_BUFFER_INFO {
  ODW_BUFFER_INFO        *pNext;       // Linked-list entry. Set to Self if in-flight.
  OFFLINE_DUMP_WRITER    *pDumpWriter; // Parent.
  UINT8                  *pBuffer;     // Size is pDumpWriter->BufferSize, which must be a multiple of BlockSize.
  EFI_BLOCK_IO2_TOKEN    Token;        // Invokes OfflineDumpWriterOperationComplete when the operation completes.
};

// Returns false for overflow.
static BOOLEAN
ODW_CheckedAdd32 (
  IN OUT UINT32  *Accumulator,
  UINT32         Addend
  )
{
  *Accumulator += Addend;
  return *Accumulator >= Addend;
}

static void
ODW_BufferListInterlockedPush (
  IN OUT ODW_BUFFER_INFO *volatile  *ppFirst,
  IN OUT ODW_BUFFER_INFO            *pItem
  )
{
  ASSERT (pItem->pNext == NULL);

  ODW_BUFFER_INFO  *pExpectedFirst = *ppFirst;

  for ( ; ;) {
    pItem->pNext = pExpectedFirst;

    // Interlocked: *ppFirst = pItem;
    ODW_BUFFER_INFO *const  pActualFirst =
      InterlockedCompareExchangePointer (
                                         (void *volatile *)ppFirst,
                                         pExpectedFirst,
                                         pItem
                                         );
    if (pActualFirst == pExpectedFirst) {
      return;
    }

    pExpectedFirst = pActualFirst;
  }
}

static ODW_BUFFER_INFO *
ODW_BufferListInterlockedFlush (
  IN OUT ODW_BUFFER_INFO *volatile  *ppFirst
  )
{
  ODW_BUFFER_INFO  *pExpectedFirst = *ppFirst;

  while (pExpectedFirst) {
    // Interlocked: *ppFirst = NULL;
    ODW_BUFFER_INFO *const  pActualFirst =
      InterlockedCompareExchangePointer (
                                         (void *volatile *)ppFirst,
                                         pExpectedFirst,
                                         NULL
                                         );
    if (pActualFirst == pExpectedFirst) {
      return pExpectedFirst;
    }

    pExpectedFirst = pActualFirst;
  }

  // Already NULL.
  return NULL;
}

static void EFIAPI
ODW_BufferInfoOperationComplete (
  IN EFI_EVENT  Event,
  IN VOID       *pContext
  )
{
  ODW_BUFFER_INFO *const  pComplete = (ODW_BUFFER_INFO *)pContext;

  ASSERT (pComplete->pNext == pComplete); // In-flight.
  pComplete->pNext = NULL;

  // Move info from BusyBufferInfos to CompletedBufferInfos.
  // In theory, the callback can't be interrupted (runs at TPL_CALLBACK) so this doesn't
  // need to be interlocked. However, it does need to be interlocked on the other end.
  OFFLINE_DUMP_WRITER *const  pDumpWriter = pComplete->pDumpWriter;

  ODW_BufferListInterlockedPush (&pDumpWriter->pFirstCompletedBufferInfo, pComplete);
  UINT32  NewBusyCount = InterlockedDecrement (&pDumpWriter->BusyBufferInfos);

  DEBUG_PRINT (DEBUG_VERBOSE, "PostDecrement BusyBufferInfos = %u\n", NewBusyCount);

  // Protected (runs at TPL_CALLBACK). If this were actually multi-threaded, the info
  // could be deleted between the InterlockedDecrement and the SignalEvent.
  DEBUG_PRINT (DEBUG_VERBOSE, "Signal FreeBuffer for %p\n", pContext);
  gBS->SignalEvent (pDumpWriter->OperationCompleted);
}

static void
ODW_BufferInfoDestruct (
  IN OUT ODW_BUFFER_INFO  *pBufferInfo
  )
{
  ASSERT (pBufferInfo->pNext != pBufferInfo); // Not in-flight.

  if (pBufferInfo->Token.Event) {
    gBS->CloseEvent (pBufferInfo->Token.Event);
    pBufferInfo->Token.Event = NULL;
  }

  if (pBufferInfo->pBuffer) {
    FreeAlignedPages (pBufferInfo->pBuffer, EFI_SIZE_TO_PAGES (pBufferInfo->pDumpWriter->BufferSize));
    pBufferInfo->pBuffer = NULL;
  }
}

static EFI_STATUS
ODW_BufferInfoConstruct (
  IN OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN UINT32               MediaIoAlign,
  IN OUT ODW_BUFFER_INFO  *pBufferInfo
  )
{
  // Caller should allocate zeroed memory.
  ASSERT (pBufferInfo->pNext == NULL);
  ASSERT (pBufferInfo->pBuffer == NULL);
  ASSERT (pBufferInfo->Token.Event == NULL);

  pBufferInfo->pDumpWriter = pDumpWriter;

  pBufferInfo->pBuffer = AllocateAlignedPages (EFI_SIZE_TO_PAGES (pDumpWriter->BufferSize), MediaIoAlign);
  if (!pBufferInfo->pBuffer) {
    DEBUG_PRINT (DEBUG_ERROR, "AllocateAlignedPages(BufferSize = %u, %u) failed\n", pDumpWriter->BufferSize, MediaIoAlign);
    return EFI_OUT_OF_RESOURCES;
  }

  EFI_STATUS  Status;

  // Signal-type event - cannot wait on it, signal triggers callback.
  Status = gBS->CreateEvent (
                             EVT_NOTIFY_SIGNAL,
                             TPL_CALLBACK,
                             ODW_BufferInfoOperationComplete,
                             pBufferInfo,
                             &pBufferInfo->Token.Event
                             );
  if (EFI_ERROR (Status)) {
    DEBUG_PRINT (DEBUG_ERROR, "CreateEvent failed (%r)\n", Status);
    FreePool (pBufferInfo->pBuffer);
    pBufferInfo->pBuffer = NULL;
    return Status;
  }

  return EFI_SUCCESS;
}

static void
ODW_PushFreeBuffer (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN OUT ODW_BUFFER_INFO      *pFreeItem
  )
{
  ASSERT (pFreeItem->pNext == NULL);
  ASSERT (pFreeItem->pDumpWriter == pDumpWriter);
  ASSERT (pFreeItem->pBuffer != NULL);
  ASSERT (pFreeItem->Token.Event != NULL);
  ASSERT (pFreeItem->Token.TransactionStatus == EFI_SUCCESS);
  pFreeItem->pNext                  = pDumpWriter->pFirstFreeBufferInfo;
  pDumpWriter->pFirstFreeBufferInfo = pFreeItem;
}

static void
ODW_WaitForFreeBuffer (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  // Loop until we flush at least one buffer from completed list to free list.
  for ( ; ;) {
    ASSERT (!pDumpWriter->pFirstFreeBufferInfo);

    // Flush the completed buffer list.
    ODW_BUFFER_INFO  *pFirstCompleted =
      ODW_BufferListInterlockedFlush (&pDumpWriter->pFirstCompletedBufferInfo);
    if (pFirstCompleted) {
      // Flushed one or more buffers from completed buffer list.
      // Add them to the free list.
      do {
        ODW_BUFFER_INFO *const  pFreeItem = pFirstCompleted;
        pFirstCompleted  = pFreeItem->pNext;
        pFreeItem->pNext = NULL;

        if (EFI_ERROR (pFreeItem->Token.TransactionStatus)) {
          // Track failed write operation.
          pDumpWriter->LastWriteError = pFreeItem->Token.TransactionStatus;
        }

        pFreeItem->Token.TransactionStatus = EFI_SUCCESS;

        ODW_PushFreeBuffer (pDumpWriter, pFreeItem);
      } while (pFirstCompleted);

      // Flushed something so we're done.
      return;
    }

    // No completed buffers. Wait for signal and try again.
    DEBUG_PRINT (DEBUG_VERBOSE, "Wait FreeBuffer - begin\n");
    gBS->WaitForEvent (1, &pDumpWriter->OperationCompleted, NULL);
    DEBUG_PRINT (DEBUG_VERBOSE, "Wait FreeBuffer - end\n");
  }
}

static ODW_BUFFER_INFO *
ODW_GetFreeBuffer (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  ODW_BUFFER_INFO  *pFreeBuffer = pDumpWriter->pFirstFreeBufferInfo;

  if (!pFreeBuffer) {
    ODW_WaitForFreeBuffer (pDumpWriter);
    pFreeBuffer = pDumpWriter->pFirstFreeBufferInfo;
  }

  pDumpWriter->pFirstFreeBufferInfo = pFreeBuffer->pNext;
  pFreeBuffer->pNext                = NULL;
  return pFreeBuffer;
}

static RAW_DUMP_HEADER *
ODW_DumpHeader (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return (RAW_DUMP_HEADER *)(pDumpWriter->pHeaders + pDumpWriter->RawDumpOffset);
}

static RAW_DUMP_SECTION_HEADER *
ODW_SectionHeaders (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return (RAW_DUMP_SECTION_HEADER *)(pDumpWriter->pHeaders + pDumpWriter->RawDumpOffset + sizeof (RAW_DUMP_HEADER));
}

static void
ODW_CurrentBufferInfoFlush (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  ASSERT (pDumpWriter->pCurrentBufferInfo);
  ASSERT (pDumpWriter->CurrentBufferInfoUsed != 0);
  ASSERT (pDumpWriter->CurrentBufferInfoUsed <= pDumpWriter->BufferSize);
  ASSERT (0 == (pDumpWriter->CurrentBufferInfoUsed & ((1u << pDumpWriter->MediaBlockShift) - 1)));
  ASSERT (0 == (pDumpWriter->FlushedMediaPosition & ((1u << pDumpWriter->MediaBlockShift) - 1)));

  if (pDumpWriter->MediaSize > pDumpWriter->FlushedMediaPosition) {
    ODW_BUFFER_INFO *const  pCurrentBufferInfo = pDumpWriter->pCurrentBufferInfo;
    UINT64 const            MediaRemaining     = pDumpWriter->MediaSize - pDumpWriter->FlushedMediaPosition;
    UINT32 const            BytesToWrite       = (UINT32)MIN (MediaRemaining, pDumpWriter->CurrentBufferInfoUsed);

    ASSERT (BytesToWrite != 0);
    ASSERT (0 == (BytesToWrite & ((1u << pDumpWriter->MediaBlockShift) - 1)));

    EFI_STATUS  Status;

    if (pDumpWriter->pBlockIo2) {
      // Send pCurrentBufferInfo into the void.
      pDumpWriter->pCurrentBufferInfo = NULL;
      pCurrentBufferInfo->pNext       = pCurrentBufferInfo; // In-flight
      UINT32  NewBusyCount = InterlockedIncrement (&pDumpWriter->BusyBufferInfos);
      DEBUG_PRINT (DEBUG_VERBOSE, "PostIncrement BusyBufferInfos = %u\n", NewBusyCount);

      EFI_BLOCK_IO2_PROTOCOL *const  pBlockIo2 = pDumpWriter->pBlockIo2;
      Status = pBlockIo2->WriteBlocksEx (
                                         pBlockIo2,
                                         pDumpWriter->MediaID,
                                         pDumpWriter->FlushedMediaPosition >> pDumpWriter->MediaBlockShift,
                                         &pCurrentBufferInfo->Token,
                                         BytesToWrite,
                                         pCurrentBufferInfo->pBuffer
                                         );
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "WriteBlocksEx failed (%r)\n", Status);
        // Didn't queue a Write, so callback won't be invoked. Put it back.
        pDumpWriter->pCurrentBufferInfo = pCurrentBufferInfo;
        pCurrentBufferInfo->pNext       = NULL; // Not in-flight
        NewBusyCount                    = InterlockedDecrement (&pDumpWriter->BusyBufferInfos);
        DEBUG_PRINT (DEBUG_VERBOSE, "PostDecrement BusyBufferInfos = %u\n", NewBusyCount);
        pDumpWriter->LastWriteError = Status;
      }
    } else {
      EFI_BLOCK_IO_PROTOCOL *const  pBlockIo = pDumpWriter->pBlockIo;
      Status = pBlockIo->WriteBlocks (
                                      pBlockIo,
                                      pDumpWriter->MediaID,
                                      pDumpWriter->FlushedMediaPosition >> pDumpWriter->MediaBlockShift,
                                      BytesToWrite,
                                      pCurrentBufferInfo->pBuffer
                                      );
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "WriteBlocks failed (%r)\n", Status);
        pDumpWriter->LastWriteError = Status;
      }
    }
  }

  pDumpWriter->FlushedMediaPosition += pDumpWriter->CurrentBufferInfoUsed;
  pDumpWriter->CurrentBufferInfoUsed = 0;
}

// pDumpWriter->CurrentBufferInfoUsed += DataSize.
// If this makes pCurrentBufferInfo full, flush it.
static void
ODW_IncrementCurrentBufferInfoUsed (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN UINT32                   DataSize
  )
{
  ASSERT (pDumpWriter->BufferSize > pDumpWriter->CurrentBufferInfoUsed);
  ASSERT (pDumpWriter->BufferSize - pDumpWriter->CurrentBufferInfoUsed >= DataSize);

  UINT32 const  NewSize = pDumpWriter->CurrentBufferInfoUsed + DataSize;

  pDumpWriter->CurrentBufferInfoUsed = NewSize;

  if (NewSize >= pDumpWriter->BufferSize) {
    ASSERT (NewSize == pDumpWriter->BufferSize);
    ODW_CurrentBufferInfoFlush (pDumpWriter);
  }
}

// If there is no current buffer, sets pCurrentBufferInfo = ODW_GetFreeBuffer().
// (Waits for a free buffer if necessary.)
//
// Returns pCurrentBufferInfo->pBuffer.
static UINT8 *
ODW_EnsureCurrentBufferInfo (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  ODW_BUFFER_INFO  *pCurrentBufferInfo = pDumpWriter->pCurrentBufferInfo;

  if (pCurrentBufferInfo) {
    ASSERT (pDumpWriter->CurrentBufferInfoUsed < pDumpWriter->BufferSize);
  } else {
    ASSERT (pDumpWriter->CurrentBufferInfoUsed == 0);
    pCurrentBufferInfo              = ODW_GetFreeBuffer (pDumpWriter);
    pDumpWriter->pCurrentBufferInfo = pCurrentBufferInfo;
  }

  return pCurrentBufferInfo->pBuffer;
}

// EncryptSize must be a multiple of SectionAlign and must fit into pCurrentBufferInfo.
// Encrypts the specified data into pCurrentBufferInfo.
// Does NOT increment CurrentBufferInfoUsed.
// On error, zeroes the corresponding part of pCurrentBufferInfo and sets LastWriteError.
static void
ODW_EncryptIntoCurrentBufferInfo (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN void const               *pInputData,
  IN UINT32                   EncryptSize
  )
{
  UINT32 const  CurrentBufferInfoUsed = pDumpWriter->CurrentBufferInfoUsed;

  ASSERT (pDumpWriter->pEncryptor != NULL);
  ASSERT (EncryptSize % SectionAlign == 0);
  ASSERT (CurrentBufferInfoUsed + EncryptSize >= EncryptSize);
  ASSERT (CurrentBufferInfoUsed + EncryptSize <= pDumpWriter->BufferSize);

  void *const   pOutputData = pDumpWriter->pCurrentBufferInfo->pBuffer + CurrentBufferInfoUsed;
  UINT64 const  Counter     = pDumpWriter->FlushedMediaPosition - pDumpWriter->RawDumpOffset + CurrentBufferInfoUsed;

  DEBUG_PRINT (
               DEBUG_VERBOSE,
               "Encrypt data CTR=0x%llX LEN=0x%X\n",
               (llu_t)(Counter),
               EncryptSize
               );
  ASSERT (EncryptSize % SectionAlign == 0);
  OfflineDumpEncryptorEncrypt (
                               pDumpWriter->pEncryptor,
                               Counter,
                               EncryptSize,
                               pInputData,
                               pOutputData
                               );
}

static void
ODW_Delete (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  ASSERT (pDumpWriter->BusyBufferInfos == 0);

  OfflineDumpEncryptorDelete (pDumpWriter->pEncryptor);
  pDumpWriter->pEncryptor = NULL;

  if (pDumpWriter->pHeaders) {
    FreeAlignedPages (pDumpWriter->pHeaders, EFI_SIZE_TO_PAGES (pDumpWriter->HeadersSize));
    pDumpWriter->pHeaders = NULL;
  }

  if (pDumpWriter->pHeadersSync) {
    FreeAlignedPages (pDumpWriter->pHeadersSync, EFI_SIZE_TO_PAGES (pDumpWriter->HeadersSyncSize));
    pDumpWriter->pHeadersSync = NULL;
  }

  if (pDumpWriter->pBufferInfos) {
    for (UINT32 i = 0; i != pDumpWriter->BufferCount; i += 1) {
      ODW_BufferInfoDestruct (&pDumpWriter->pBufferInfos[i]);
    }

    FreePool (pDumpWriter->pBufferInfos);
    pDumpWriter->pBufferInfos = NULL;
  }

  gBS->CloseEvent (pDumpWriter->OperationCompleted);

  FreePool (pDumpWriter);
}

EFI_STATUS
OfflineDumpWriterClose (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN BOOLEAN                  DumpValid
  )
{
  if (pDumpWriter->CurrentBufferInfoUsed != 0) {
    ASSERT (pDumpWriter->pCurrentBufferInfo);
    UINT8 *const  pTail    = pDumpWriter->pCurrentBufferInfo->pBuffer + pDumpWriter->CurrentBufferInfoUsed;
    UINT32 const  TailSize = ALIGN_VALUE_ADDEND (pDumpWriter->CurrentBufferInfoUsed, 1u << pDumpWriter->MediaBlockShift);
    ZeroMem (pTail, TailSize);
    if (pDumpWriter->pEncryptor) {
      // Encrypt in-place.
      ASSERT (TailSize % SectionAlign == 0);
      ODW_EncryptIntoCurrentBufferInfo (pDumpWriter, pTail, TailSize);
    }

    pDumpWriter->CurrentBufferInfoUsed += TailSize;
    ODW_CurrentBufferInfoFlush (pDumpWriter);
    ASSERT (pDumpWriter->CurrentBufferInfoUsed == 0);
  }

  // Flush the headers once without the RAW_DUMP_HEADER_DUMP_VALID bit to ensure headers
  // are fully written. This avoids the possibility of a partial write of the headers that
  // marks the dump as valid without all the headers being written.
  (void)OfflineDumpWriterFlushHeaders (pDumpWriter); // Best-effort, ignore error here.

  // Wait for all pending operations to complete.
  // No more async after this point.
  while (pDumpWriter->BusyBufferInfos != 0) {
    DEBUG_PRINT (DEBUG_INFO, "Wait BusyBufferInfos %u - begin\n", pDumpWriter->BusyBufferInfos);
    gBS->WaitForEvent (1, &pDumpWriter->OperationCompleted, NULL);
    DEBUG_PRINT (DEBUG_INFO, "Wait BusyBufferInfos %u - end\n", pDumpWriter->BusyBufferInfos);
  }

  DEBUG_PRINT (
               DEBUG_INFO,
               "Close: LastError=%u MediaSize=%llu NeededSize=%llu\n",
               pDumpWriter->LastWriteError,
               (llu_t)OfflineDumpWriterMediaSize (pDumpWriter),
               (llu_t)OfflineDumpWriterMediaPosition (pDumpWriter)
               );

  RAW_DUMP_HEADER  *pDumpHeader = ODW_DumpHeader (pDumpWriter);

  if (EFI_ERROR (pDumpWriter->LastWriteError)) {
    // Do not set any flags (dump invalid).
  } else if (OfflineDumpWriterHasInsufficientStorage (pDumpWriter)) {
    pDumpHeader->Flags |= RAW_DUMP_HEADER_INSUFFICIENT_STORAGE;
  } else if (DumpValid) {
    pDumpHeader->Flags |= RAW_DUMP_HEADER_DUMP_VALID;
  } else {
    // Do not set any flags (dump invalid).
  }

  EFI_STATUS  Status = OfflineDumpWriterFlushHeaders (pDumpWriter);

  if (!EFI_ERROR (Status)) {
    if (pDumpWriter->pBlockIo2) {
      Status = pDumpWriter->pBlockIo2->FlushBlocksEx (pDumpWriter->pBlockIo2, NULL);
    } else {
      Status = pDumpWriter->pBlockIo->FlushBlocks (pDumpWriter->pBlockIo);
    }
  }

  ODW_Delete (pDumpWriter);
  return Status;
}

EFI_STATUS
OfflineDumpWriterOpen (
  IN EFI_HANDLE                         DumpDeviceHandle,
  IN RAW_DUMP_HEADER_FLAGS              DumpHeaderFlags,
  IN UINT32                             SectionCountExpected,
  IN OFFLINE_DUMP_WRITER_OPTIONS const  *pOptions,
  OUT OFFLINE_DUMP_WRITER               **ppDumpWriter
  )
{
  static const RAW_DUMP_HEADER_FLAGS  RawDumpHeaderInvalidFlags =
    RAW_DUMP_HEADER_DUMP_VALID |
    RAW_DUMP_HEADER_INSUFFICIENT_STORAGE;

  if (!DumpDeviceHandle ||
      (0 != (DumpHeaderFlags & RawDumpHeaderInvalidFlags)) ||
      (SectionCountExpected > SectionCountMax) ||
      !ppDumpWriter)
  {
    return EFI_INVALID_PARAMETER;
  }

  EFI_STATUS           Status;
  OFFLINE_DUMP_WRITER  *pDumpWriter;
  ENC_DUMP_KEY_INFO    *pKeyInfo = NULL;
  UINT32               MediaIoAlign;

  // pDumpWriter, SectionCountExpected, OperationCompleted
  {
    pDumpWriter = AllocateZeroPool (sizeof (*pDumpWriter));
    if (!pDumpWriter) {
      DEBUG_PRINT (DEBUG_ERROR, "AllocateZeroPool(OFFLINE_DUMP_WRITER) failed\n");
      Status = EFI_OUT_OF_RESOURCES;
      goto Done;
    }

    pDumpWriter->SectionCountExpected = SectionCountExpected;

    // Simple event - can wait on it, signal unblocks wait, no callback.
    Status = gBS->CreateEvent (0, 0, NULL, NULL, &pDumpWriter->OperationCompleted);
    if (EFI_ERROR (Status)) {
      DEBUG_PRINT (DEBUG_ERROR, "CreateEvent for OperationCompleted failed (%r)\n", Status);
      goto Done;
    }
  }

  // pKeyInfo, pEncryptor
  {
    ENC_DUMP_ALGORITHM  EncDumpAlgorithm;

    if (pOptions && pOptions->ForceUnencrypted) {
      EncDumpAlgorithm = ENC_DUMP_ALGORITHM_NONE;
    } else {
      Status = GetVariableOfflineMemoryDumpEncryptionAlgorithm (&EncDumpAlgorithm);
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "GetVariable(OfflineMemoryDumpEncryptionAlgorithm) failed (%r)\n", Status);
        goto Done;
      }
    }

    if (EncDumpAlgorithm != ENC_DUMP_ALGORITHM_NONE) {
      void    *pRecipientCertificate   = NULL;
      UINT32  RecipientCertificateSize = 0;
      Status = GetVariableOfflineMemoryDumpEncryptionPublicKey (&pRecipientCertificate, &RecipientCertificateSize);
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "GetVariable(OfflineMemoryDumpEncryptionPublicKey) failed (%r)\n", Status);
        goto Done;
      }

      Status = OfflineDumpEncryptorNewKeyInfoBlock (
                                                    EncDumpAlgorithm,
                                                    pRecipientCertificate,
                                                    RecipientCertificateSize,
                                                    &pDumpWriter->pEncryptor,
                                                    &pKeyInfo
                                                    );
      FreePool (pRecipientCertificate);

      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "OfflineDumpEncryptorNewKeyInfoBlock failed (%r)\n", Status);
        goto Done;
      }

      ASSERT (pDumpWriter->pEncryptor);
      ASSERT (pKeyInfo);
    }
  }

  // pBlockIo2, pBlockIo, MediaID, MediaBlockShift, MediaSize, MediaIoAlign
  {
    EFI_BLOCK_IO_MEDIA const  *pMedia;

    if (pOptions && pOptions->DisableBlockIo2) {
      Status = EFI_UNSUPPORTED;
    } else {
      Status = gBS->OpenProtocol (
                                  DumpDeviceHandle,
                                  &gEfiBlockIo2ProtocolGuid,
                                  (VOID **)&pDumpWriter->pBlockIo2,
                                  gImageHandle,
                                  NULL,
                                  EFI_OPEN_PROTOCOL_GET_PROTOCOL
                                  );
    }

    if (!EFI_ERROR (Status)) {
      pMedia = pDumpWriter->pBlockIo2->Media;
    } else {
      Status = gBS->OpenProtocol (
                                  DumpDeviceHandle,
                                  &gEfiBlockIoProtocolGuid,
                                  (VOID **)&pDumpWriter->pBlockIo,
                                  gImageHandle,
                                  NULL,
                                  EFI_OPEN_PROTOCOL_GET_PROTOCOL
                                  );
      if (EFI_ERROR (Status)) {
        DEBUG_PRINT (DEBUG_ERROR, "OpenProtocol(BlockIo) failed (%r)\n", Status);
        goto Done;
      }

      pMedia = pDumpWriter->pBlockIo->Media;
    }

    // Sanity-check the block size: 512 or larger, and a power of 2.
    if ((pMedia->BlockSize < 512) || ((pMedia->BlockSize & (pMedia->BlockSize - 1)) != 0)) {
      DEBUG_PRINT (DEBUG_ERROR, "BlockIo device has bad block size %u\n", pMedia->BlockSize);
      Status = EFI_UNSUPPORTED;
      goto Done;
    }

    UINT64 const   LastBlockMax   = MAX_UINT64 / pMedia->BlockSize - 1;
    EFI_LBA const  MediaLastBlock = MIN (pMedia->LastBlock, LastBlockMax);

    pDumpWriter->MediaID         = pMedia->MediaId;
    pDumpWriter->MediaBlockShift = (UINT8)HighBitSet32 (pMedia->BlockSize);
    ASSERT (pMedia->BlockSize == 1u << pDumpWriter->MediaBlockShift);
    pDumpWriter->MediaSize = (MediaLastBlock + 1) * pMedia->BlockSize;
    MediaIoAlign           = pMedia->IoAlign;
  }

  UINT32 const  BufferAlignment = MAX (EFI_PAGE_SIZE, 1u << pDumpWriter->MediaBlockShift);

  DEBUG_PRINT (DEBUG_INFO, "BufferAlignment: %u\n", BufferAlignment);

  // pHeaders, HeadersSize, RawDumpOffset, FlushedMediaPosition
  {
    UINT32        HeadersSize             = 0;
    UINT32        EncHeaderPadding        = 0;
    UINT32 const  SectionHeadersByteCount = SectionCountExpected * (UINT32)sizeof (RAW_DUMP_SECTION_HEADER);

    if (pKeyInfo) {
      HeadersSize += sizeof (ENC_DUMP_HEADER);

      if (!ODW_CheckedAdd32 (&HeadersSize, pKeyInfo->BlockSize)) {
        DEBUG_PRINT (DEBUG_ERROR, "HeadersSize overflow pKeyInfo->BlockSize\n");
        Status = EFI_BAD_BUFFER_SIZE;
        goto Done;
      }

      EncHeaderPadding = ALIGN_VALUE_ADDEND (HeadersSize, SectionAlign);
      if (!ODW_CheckedAdd32 (&HeadersSize, EncHeaderPadding)) {
        DEBUG_PRINT (DEBUG_ERROR, "HeadersSize overflow EncHeaderPadding\n");
        Status = EFI_BAD_BUFFER_SIZE;
        goto Done;
      }
    }

    pDumpWriter->RawDumpOffset = HeadersSize;
    ASSERT (pDumpWriter->RawDumpOffset % SectionAlign == 0);

    if (!ODW_CheckedAdd32 (&HeadersSize, sizeof (RAW_DUMP_HEADER))) {
      DEBUG_PRINT (DEBUG_ERROR, "HeadersSize overflow RAW_DUMP_HEADER\n");
      Status = EFI_BAD_BUFFER_SIZE;
      goto Done;
    }

    if (!ODW_CheckedAdd32 (&HeadersSize, SectionHeadersByteCount)) {
      DEBUG_PRINT (DEBUG_ERROR, "HeadersSize overflow SectionHEadersByteCount %u\n", SectionHeadersByteCount);
      Status = EFI_BAD_BUFFER_SIZE;
      goto Done;
    }

    if (!ODW_CheckedAdd32 (&HeadersSize, ALIGN_VALUE_ADDEND (HeadersSize, BufferAlignment))) {
      DEBUG_PRINT (DEBUG_ERROR, "HeadersSize overflow Alignment %u\n", ALIGN_VALUE_ADDEND (HeadersSize, BufferAlignment));
      Status = EFI_BAD_BUFFER_SIZE;
      goto Done;
    }

    if (pDumpWriter->MediaSize < HeadersSize) {
      DEBUG_PRINT (
                   DEBUG_ERROR,
                   "HeaderSize %u doesn't fit in MediaSize %llu\n",
                   HeadersSize,
                   (llu_t)pDumpWriter->MediaSize
                   );
      Status = EFI_VOLUME_FULL;
      goto Done;
    }

    UINT8 *const  pHeaders = AllocateAlignedPages (EFI_SIZE_TO_PAGES (HeadersSize), MediaIoAlign);
    if (!pHeaders) {
      DEBUG_PRINT (DEBUG_ERROR, "AllocateAlignedPages(HeadersSize = %u, %u) failed\n", HeadersSize, MediaIoAlign);
      Status = EFI_OUT_OF_RESOURCES;
      goto Done;
    }

    DEBUG_PRINT (DEBUG_INFO, "HeadersSize: %u\n", HeadersSize);
    ZeroMem (pHeaders, HeadersSize);

    pDumpWriter->pHeaders             = pHeaders;
    pDumpWriter->HeadersSize          = HeadersSize;
    pDumpWriter->FlushedMediaPosition = HeadersSize;

    UINT8  *pHeadersPos = pHeaders;

    if (pKeyInfo) {
      *(ENC_DUMP_HEADER *)pHeadersPos = (ENC_DUMP_HEADER) {
        .Signature     = ENC_DUMP_HEADER_SIGNATURE,
        .HeaderSize    = sizeof (ENC_DUMP_HEADER),
        .KeyInfoOffset = sizeof (ENC_DUMP_HEADER),
        .RawDumpOffset = pDumpWriter->RawDumpOffset,
      };
      pHeadersPos += sizeof (ENC_DUMP_HEADER);

      CopyMem (pHeadersPos, pKeyInfo, pKeyInfo->BlockSize);
      pHeadersPos += pKeyInfo->BlockSize;
      pHeadersPos += EncHeaderPadding;
    }

    RAW_DUMP_HEADER  *pDumpHeader = (RAW_DUMP_HEADER *)pHeadersPos;
    *pDumpHeader = (RAW_DUMP_HEADER) {
      .Signature             = RAW_DUMP_HEADER_SIGNATURE,
      .MajorVersion          = RAW_DUMP_HEADER_CURRENT_MAJOR_VERSION,
      .MinorVersion          = RAW_DUMP_HEADER_CURRENT_MINOR_VERSION,
      .Flags                 = DumpHeaderFlags,
      .OsData                = 0,
      .CpuContext            = 0,
      .ResetTrigger          = 0,
      .DumpSize              = HeadersSize - pDumpWriter->RawDumpOffset,
      .TotalDumpSizeRequired = HeadersSize,
      .SectionsCount         = 0,
    };
    (void)GetVariableOfflineMemoryDumpOsData (&pDumpHeader->OsData);

    pHeadersPos += sizeof (RAW_DUMP_HEADER);
    pHeadersPos += SectionHeadersByteCount;
    ASSERT (pHeadersPos <= pHeaders + HeadersSize);
  }

  // BufferSize, BufferCount, pBufferInfos, pFirstFreeBufferInfo
  {
    UINT8 const  BufferCount =
      !pDumpWriter->pBlockIo2
      ? 1 // No async support, use one large block.
      : pOptions && pOptions->BufferCount != 0
      ? MAX (pOptions->BufferCount, 2) // Count specified, use it. Must be at least 2.
      : BufferCountDefault;            // Count not specified, default.
    UINT32 const  BufferMemoryLimit =
      pOptions && pOptions->BufferMemoryLimit != 0
      ? MIN (pOptions->BufferMemoryLimit, MAX_UINT32 - BufferAlignment) // Limit specified, use it.
      : BufferMemoryLimitDefault;                                       // Limit not specified, default.

    UINT32  ProposedBufferSize = BufferMemoryLimit / BufferCount;
    if (!pDumpWriter->pBlockIo2) {
      // Special case: Device only supports blocking I/O so we want to prioritize one
      // large I/O buffer, but we need a second I/O buffer to use for
      // DumpWriterFlushHeaders when the large buffer is partially filled. In this case,
      // allocate a dedicated buffer for DumpWriterFlushHeaders.
      UINT32 const  HeadersSyncSize =
        pDumpWriter->HeadersSize <= ProposedBufferSize / 2
        ? pDumpWriter->HeadersSize
        : ALIGN_VALUE (pDumpWriter->RawDumpOffset + 1, BufferAlignment);

      // Adjust the size of the primary I/O buffer down a bit to account for the dedicated buffer.
      ProposedBufferSize =
        HeadersSyncSize <= ProposedBufferSize / 2
        ? ProposedBufferSize - HeadersSyncSize
        : ProposedBufferSize / 2;

      pDumpWriter->pHeadersSync = AllocateAlignedPages (EFI_SIZE_TO_PAGES (HeadersSyncSize), MediaIoAlign);
      if (!pDumpWriter->pHeadersSync) {
        DEBUG_PRINT (DEBUG_ERROR, "AllocateAlignedPages(HeadersSyncSize = %u, %u) failed\n", HeadersSyncSize, MediaIoAlign);
        Status = EFI_OUT_OF_RESOURCES;
        goto Done;
      }

      ZeroMem (pDumpWriter->pHeadersSync, HeadersSyncSize);
      pDumpWriter->HeadersSyncSize = HeadersSyncSize;
    }

    UINT32 const  BufferSize =
      ProposedBufferSize < BufferAlignment
      ? BufferAlignment                              // Proposed size too small. Use block size.
      : ProposedBufferSize & ~(BufferAlignment - 1); // Proposed size ok, round down to block size.

    DEBUG_PRINT (DEBUG_INFO, "BufferSize: %uKB\n", BufferSize / 1024);
    DEBUG_PRINT (DEBUG_INFO, "BufferCount: %u\n", BufferCount);

    pDumpWriter->BufferSize   = BufferSize;
    pDumpWriter->BufferCount  = BufferCount;
    pDumpWriter->pBufferInfos = AllocateZeroPool (BufferCount * sizeof (ODW_BUFFER_INFO));
    if (!pDumpWriter->pBufferInfos) {
      DEBUG_PRINT (DEBUG_ERROR, "AllocateZeroPool(%u * ODW_BUFFER_INFO) failed\n", BufferCount);
      Status = EFI_OUT_OF_RESOURCES;
      goto Done;
    }

    for (unsigned i = 0; i != BufferCount; i += 1) {
      ODW_BUFFER_INFO *const  pInfo = &pDumpWriter->pBufferInfos[i];
      Status = ODW_BufferInfoConstruct (pDumpWriter, MediaIoAlign, pInfo);
      if (EFI_ERROR (Status)) {
        goto Done;
      }

      ODW_PushFreeBuffer (pDumpWriter, pInfo);
    }
  }

  Status = OfflineDumpWriterFlushHeaders (pDumpWriter);

Done:

  if (pKeyInfo) {
    FreePool (pKeyInfo);
  }

  if (EFI_ERROR (Status) && pDumpWriter) {
    ODW_Delete (pDumpWriter);
    pDumpWriter = NULL;
  }

  *ppDumpWriter = pDumpWriter;
  return Status;
}

EFI_STATUS
OfflineDumpWriterLastWriteError (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->LastWriteError;
}

UINT64
OfflineDumpWriterMediaPosition (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->FlushedMediaPosition + pDumpWriter->CurrentBufferInfoUsed;
}

UINT64
OfflineDumpWriterMediaSize (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->MediaSize;
}

// Returns the size of the I/O buffer used by the dump writer.
UINT32
OfflineDumpWriterBufferSize (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->BufferSize;
}

// Returns the number of I/O buffers used by the dump writer.
UINT8
OfflineDumpWriterBufferCount (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->BufferCount;
}

// Returns the ENC_DUMP_ALGORITHM used by the dump writer.
UINT32
OfflineDumpWriterEncryptionAlgorithm (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return OfflineDumpEncryptorAlgorithm (pDumpWriter->pEncryptor);
}

BOOLEAN
OfflineDumpWriterUsingBlockIo2 (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return pDumpWriter->pBlockIo2 != NULL;
}

BOOLEAN
OfflineDumpWriterHasInsufficientStorage (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return OfflineDumpWriterMediaSize (pDumpWriter) < OfflineDumpWriterMediaPosition (pDumpWriter);
}

RAW_DUMP_HEADER const *
OfflineDumpWriterGetDumpHeader (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  )
{
  return ODW_DumpHeader (pDumpWriter);
}

EFI_STATUS
OfflineDumpWriterFlushHeaders (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  )
{
  // Note: DumpWriterClose assumes that this does not launch any async operations.

  EFI_STATUS                     Status;
  EFI_BLOCK_IO2_PROTOCOL *const  pBlockIo2       = pDumpWriter->pBlockIo2;
  EFI_BLOCK_IO_PROTOCOL *const   pBlockIo        = pDumpWriter->pBlockIo;
  UINT32 const                   MediaID         = pDumpWriter->MediaID;
  UINT8 const                    MediaBlockShift = pDumpWriter->MediaBlockShift;

  ODW_BUFFER_INFO  *pBufferInfo;
  UINT8            *pDest;
  UINT32           DestSize;

  if (pBlockIo2) {
    // Async I/O means there's at least 2 buffers.
    // 1 may be partially-filled, so we can't use it.
    // At least one will be free or in-flight (which we will wait for).
    ASSERT (!pDumpWriter->pHeadersSync);
    ASSERT (pDumpWriter->HeadersSyncSize == 0);
    pBufferInfo = ODW_GetFreeBuffer (pDumpWriter);
    pDest       = pBufferInfo->pBuffer;
    DestSize    = pDumpWriter->BufferSize;
  } else {
    // Sync I/O means there's only 1 big buffer.
    // It may be partially-filled, so we can't use it.
    // We reserved a smaller buffer to handle this case.
    ASSERT (pDumpWriter->pHeadersSync);
    ASSERT (pDumpWriter->HeadersSyncSize >= EFI_PAGE_SIZE);
    pBufferInfo = NULL;
    pDest       = pDumpWriter->pHeadersSync;
    DestSize    = pDumpWriter->HeadersSyncSize;
  }

  UINT32 const  HeadersSize = pDumpWriter->HeadersSize;
  UINT32        Pos         = 0;

  while (Pos < HeadersSize) {
    UINT32 const  ThisBlockSize = MIN (DestSize, HeadersSize - Pos);
    UINT32 const  EndPos        = Pos + ThisBlockSize;
    CopyMem (pDest, &pDumpWriter->pHeaders[Pos], ThisBlockSize);

    if (pDumpWriter->pEncryptor && (EndPos > pDumpWriter->RawDumpOffset)) {
      UINT32 const  EncryptStart =
        Pos < pDumpWriter->RawDumpOffset
        ? pDumpWriter->RawDumpOffset - Pos
        : 0;
      UINT32 const  EncryptSize = ThisBlockSize - EncryptStart;
      UINT64 const  Counter     = Pos + EncryptStart - pDumpWriter->RawDumpOffset;
      DEBUG_PRINT (
                   DEBUG_VERBOSE,
                   "Encrypt headers CTR=0x%llX LEN=0x%X\n",
                   (llu_t)(Counter),
                   EncryptSize
                   );
      ASSERT (EncryptSize % SectionAlign == 0);
      OfflineDumpEncryptorEncrypt (
                                   pDumpWriter->pEncryptor,
                                   Counter,
                                   EncryptSize,
                                   pDest + EncryptStart,
                                   pDest + EncryptStart
                                   );
    }

    if (pBlockIo2) {
      Status = pBlockIo2->WriteBlocksEx (pBlockIo2, MediaID, Pos >> MediaBlockShift, NULL, ThisBlockSize, pDest);
    } else {
      Status = pBlockIo->WriteBlocks (pBlockIo, MediaID, Pos >> MediaBlockShift, ThisBlockSize, pDest);
    }

    if (EFI_ERROR (Status)) {
      break;
    }

    Pos += ThisBlockSize;
  }

  // Return the async buffer if we used it.
  if (pBufferInfo) {
    ODW_PushFreeBuffer (pDumpWriter, pBufferInfo);
  }

  return Status;
}

EFI_STATUS
OfflineDumpWriterWriteSection (
  IN OUT OFFLINE_DUMP_WRITER             *pDumpWriter,
  IN RAW_DUMP_SECTION_HEADER_FLAGS       SectionHeaderFlags,
  IN UINT16                              MajorVersion,
  IN UINT16                              MinorVersion,
  IN RAW_DUMP_SECTION_TYPE               Type,
  IN RAW_DUMP_SECTION_INFORMATION const  *pInformation,
  IN CHAR8 const                         *pName,
  IN DUMP_WRITER_COPY_CALLBACK           DataCallback OPTIONAL,
  IN void const                          *pDataStart,
  IN UINTN                               DataSize
  )
{
  static const RAW_DUMP_SECTION_HEADER_FLAGS  RawDumpSectionHeaderInvalidFlags =
    RAW_DUMP_SECTION_HEADER_INSUFFICIENT_STORAGE;

  RAW_DUMP_HEADER *const  pDumpHeader   = ODW_DumpHeader (pDumpWriter);
  UINT32 const            SectionsCount = pDumpHeader->SectionsCount;

  ASSERT (pDumpHeader->TotalDumpSizeRequired == OfflineDumpWriterMediaPosition (pDumpWriter));

  if ((0 != (SectionHeaderFlags & RawDumpSectionHeaderInvalidFlags)) ||
      !pInformation ||
      !pName ||
      ((DataSize != 0) && !pDataStart && !DataCallback))
  {
    return EFI_INVALID_PARAMETER;
  } else if (SectionsCount >= pDumpWriter->SectionCountExpected) {
    ASSERT (SectionsCount == pDumpWriter->SectionCountExpected);
    return EFI_BUFFER_TOO_SMALL;
  }

  RAW_DUMP_SECTION_HEADER *const  pSectionHeader = ODW_SectionHeaders (pDumpWriter) + SectionsCount;

  *pSectionHeader = (RAW_DUMP_SECTION_HEADER) {
    .Flags        = SectionHeaderFlags & ~RAW_DUMP_SECTION_HEADER_DUMP_VALID,
    .MajorVersion = MajorVersion,
    .MinorVersion = MinorVersion,
    .Type         = Type,
    .Offset       = OfflineDumpWriterMediaPosition (pDumpWriter) - pDumpWriter->RawDumpOffset,
    .Size         = 0,
    .Information  = *pInformation,
    .Name         = { 0 }
  };

  // Copy pName into pSectionHeader->Name, truncating if necessary.
  UINTN const  NameLen = AsciiStrnSizeS (pName, sizeof (pSectionHeader->Name) - 1);

  ASSERT (NameLen <= sizeof (pSectionHeader->Name));
  CopyMem (pSectionHeader->Name, pName, NameLen); // May not be null-terminated.

  // Current buffer should not be full -- it should be flushed when it becomes full.
  ASSERT (pDumpWriter->BufferSize > pDumpWriter->CurrentBufferInfoUsed);

  BOOLEAN  SectionValid = 0 != (SectionHeaderFlags & RAW_DUMP_SECTION_HEADER_DUMP_VALID);
  UINTN    Pos          = 0;

  UINTN const  DataSizeWithoutTail = DataSize & ~(UINTN)(SectionAlign - 1);

  while (DataSizeWithoutTail > Pos) {
    ASSERT (Pos % SectionAlign == 0);

    UINTN const   Remaining = DataSizeWithoutTail - Pos;
    UINT32 const  Capacity  = pDumpWriter->BufferSize - pDumpWriter->CurrentBufferInfoUsed;
    UINT32 const  ToCopy    = (UINT32)MIN (Capacity, Remaining);

    UINT8 *const  pCurrentBuffer = ODW_EnsureCurrentBufferInfo (pDumpWriter);
    if (DataCallback == NULL) {
      if (!pDumpWriter->pEncryptor) {
        CopyMem (pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed, (UINT8 const *)pDataStart + Pos, ToCopy);
      } else {
        // Optimization: copy and encrypt in one operation.
        // Encrypts into pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed.
        ASSERT (ToCopy % SectionAlign == 0);
        ODW_EncryptIntoCurrentBufferInfo (pDumpWriter, (UINT8 const *)pDataStart + Pos, ToCopy);
      }
    } else {
      if (!DataCallback (pDataStart, Pos, ToCopy, pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed)) {
        SectionValid = FALSE;
        goto CopyDone;
      }

      if (pDumpWriter->pEncryptor) {
        // Encrypt in-place.
        ASSERT (ToCopy % SectionAlign == 0);
        ODW_EncryptIntoCurrentBufferInfo (pDumpWriter, pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed, ToCopy);
      }
    }

    ODW_IncrementCurrentBufferInfoUsed (pDumpWriter, ToCopy);
    Pos += ToCopy;
  }

  ASSERT (DataSizeWithoutTail == Pos);

  UINTN const  TailSize = DataSize & (SectionAlign - 1);

  ASSERT (DataSize == DataSizeWithoutTail + TailSize);
  if (TailSize != 0) {
    UINT8 *const  pCurrentBuffer = ODW_EnsureCurrentBufferInfo (pDumpWriter);
    if (!DataCallback) {
      CopyMem (pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed, (UINT8 const *)pDataStart + Pos, TailSize);
    } else {
      if (!DataCallback (pDataStart, Pos, TailSize, pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed)) {
        SectionValid = FALSE;
        goto CopyDone;
      }
    }

    ZeroMem (pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed + TailSize, SectionAlign - TailSize);

    if (pDumpWriter->pEncryptor) {
      // Encrypt in-place. (Size must be a multiple of SectionAlign.)
      ODW_EncryptIntoCurrentBufferInfo (pDumpWriter, pCurrentBuffer + pDumpWriter->CurrentBufferInfoUsed, SectionAlign);
    }

    ODW_IncrementCurrentBufferInfoUsed (pDumpWriter, SectionAlign);
    Pos += TailSize;
  }

CopyDone:

  ASSERT (Pos == DataSize || !SectionValid);
  pSectionHeader->Size = Pos;

  if (OfflineDumpWriterHasInsufficientStorage (pDumpWriter)) {
    pSectionHeader->Flags |= RAW_DUMP_SECTION_HEADER_INSUFFICIENT_STORAGE;
  } else if (SectionValid) {
    pSectionHeader->Flags |= RAW_DUMP_SECTION_HEADER_DUMP_VALID;
  }

  UINT64 const  MediaPosition = OfflineDumpWriterMediaPosition (pDumpWriter);

  ASSERT (MediaPosition % SectionAlign == 0);
  ASSERT (
          MediaPosition ==
          pDumpWriter->RawDumpOffset + pSectionHeader->Offset + ALIGN_VALUE (pSectionHeader->Size, SectionAlign)
          );

  pDumpHeader->TotalDumpSizeRequired = MediaPosition;
  pDumpHeader->DumpSize              =
    MIN (pDumpHeader->TotalDumpSizeRequired, pDumpWriter->MediaSize) - pDumpWriter->RawDumpOffset;
  pDumpHeader->SectionsCount = SectionsCount + 1;

  return EFI_SUCCESS;
}

```

`OfflineDumpPkg/Library/OfflineDumpWriterLib/X64-MSFT/aesni-x86_64.nasm`:

```nasm
; Adapted from openssl/crypto/aes/asm/aesni-x86_64.pl

default rel
%define XMMWORD
%define YMMWORD
%define ZMMWORD
section .text code align=64

ALIGN   16
_aesni_encrypt2:

        movups  xmm0,XMMWORD[rcx]
        shl     eax,4
        movups  xmm1,XMMWORD[16+rcx]
        xorps   xmm2,xmm0
        xorps   xmm3,xmm0
        movups  xmm0,XMMWORD[32+rcx]
        lea     rcx,[32+rax*1+rcx]
        neg     rax
        add     rax,16

$L$enc_loop2:
DB      102,15,56,220,209               ;aesenc
DB      102,15,56,220,217
        movups  xmm1,XMMWORD[rax*1+rcx]
        add     rax,32
DB      102,15,56,220,208
DB      102,15,56,220,216
        movups  xmm0,XMMWORD[((-16))+rax*1+rcx]
        jnz     NEAR $L$enc_loop2

DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,221,208               ;aesenclast
DB      102,15,56,221,216
        DB      0F3h,0C3h               ;repret



ALIGN   16
_aesni_encrypt3:

        movups  xmm0,XMMWORD[rcx]
        shl     eax,4
        movups  xmm1,XMMWORD[16+rcx]
        xorps   xmm2,xmm0
        xorps   xmm3,xmm0
        xorps   xmm4,xmm0
        movups  xmm0,XMMWORD[32+rcx]
        lea     rcx,[32+rax*1+rcx]
        neg     rax
        add     rax,16

$L$enc_loop3:
DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
        movups  xmm1,XMMWORD[rax*1+rcx]
        add     rax,32
DB      102,15,56,220,208
DB      102,15,56,220,216
DB      102,15,56,220,224
        movups  xmm0,XMMWORD[((-16))+rax*1+rcx]
        jnz     NEAR $L$enc_loop3

DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
DB      102,15,56,221,208
DB      102,15,56,221,216
DB      102,15,56,221,224
        DB      0F3h,0C3h               ;repret



ALIGN   16
_aesni_encrypt4:

        movups  xmm0,XMMWORD[rcx]
        shl     eax,4
        movups  xmm1,XMMWORD[16+rcx]
        xorps   xmm2,xmm0
        xorps   xmm3,xmm0
        xorps   xmm4,xmm0
        xorps   xmm5,xmm0
        movups  xmm0,XMMWORD[32+rcx]
        lea     rcx,[32+rax*1+rcx]
        neg     rax
DB      0x0f,0x1f,0x00
        add     rax,16

$L$enc_loop4:
DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
DB      102,15,56,220,233
        movups  xmm1,XMMWORD[rax*1+rcx]
        add     rax,32
DB      102,15,56,220,208
DB      102,15,56,220,216
DB      102,15,56,220,224
DB      102,15,56,220,232
        movups  xmm0,XMMWORD[((-16))+rax*1+rcx]
        jnz     NEAR $L$enc_loop4

DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
DB      102,15,56,220,233
DB      102,15,56,221,208
DB      102,15,56,221,216
DB      102,15,56,221,224
DB      102,15,56,221,232
        DB      0F3h,0C3h               ;repret



ALIGN   16
_aesni_encrypt6:

        movups  xmm0,XMMWORD[rcx]
        shl     eax,4
        movups  xmm1,XMMWORD[16+rcx]
        xorps   xmm2,xmm0
        pxor    xmm3,xmm0
        pxor    xmm4,xmm0
DB      102,15,56,220,209
        lea     rcx,[32+rax*1+rcx]
        neg     rax
DB      102,15,56,220,217
        pxor    xmm5,xmm0
        pxor    xmm6,xmm0
DB      102,15,56,220,225
        pxor    xmm7,xmm0
        movups  xmm0,XMMWORD[rax*1+rcx]
        add     rax,16
        jmp     NEAR $L$enc_loop6_enter
ALIGN   16
$L$enc_loop6:
DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
$L$enc_loop6_enter:
DB      102,15,56,220,233
DB      102,15,56,220,241
DB      102,15,56,220,249
        movups  xmm1,XMMWORD[rax*1+rcx]
        add     rax,32
DB      102,15,56,220,208
DB      102,15,56,220,216
DB      102,15,56,220,224
DB      102,15,56,220,232
DB      102,15,56,220,240
DB      102,15,56,220,248
        movups  xmm0,XMMWORD[((-16))+rax*1+rcx]
        jnz     NEAR $L$enc_loop6

DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
DB      102,15,56,220,233
DB      102,15,56,220,241
DB      102,15,56,220,249
DB      102,15,56,221,208
DB      102,15,56,221,216
DB      102,15,56,221,224
DB      102,15,56,221,232
DB      102,15,56,221,240
DB      102,15,56,221,248
        DB      0F3h,0C3h               ;repret



ALIGN   16
_aesni_encrypt8:

        movups  xmm0,XMMWORD[rcx]
        shl     eax,4
        movups  xmm1,XMMWORD[16+rcx]
        xorps   xmm2,xmm0
        xorps   xmm3,xmm0
        pxor    xmm4,xmm0
        pxor    xmm5,xmm0
        pxor    xmm6,xmm0
        lea     rcx,[32+rax*1+rcx]
        neg     rax
DB      102,15,56,220,209
        pxor    xmm7,xmm0
        pxor    xmm8,xmm0
DB      102,15,56,220,217
        pxor    xmm9,xmm0
        movups  xmm0,XMMWORD[rax*1+rcx]
        add     rax,16
        jmp     NEAR $L$enc_loop8_inner
ALIGN   16
$L$enc_loop8:
DB      102,15,56,220,209
DB      102,15,56,220,217
$L$enc_loop8_inner:
DB      102,15,56,220,225
DB      102,15,56,220,233
DB      102,15,56,220,241
DB      102,15,56,220,249
DB      102,68,15,56,220,193
DB      102,68,15,56,220,201
$L$enc_loop8_enter:
        movups  xmm1,XMMWORD[rax*1+rcx]
        add     rax,32
DB      102,15,56,220,208
DB      102,15,56,220,216
DB      102,15,56,220,224
DB      102,15,56,220,232
DB      102,15,56,220,240
DB      102,15,56,220,248
DB      102,68,15,56,220,192
DB      102,68,15,56,220,200
        movups  xmm0,XMMWORD[((-16))+rax*1+rcx]
        jnz     NEAR $L$enc_loop8

DB      102,15,56,220,209
DB      102,15,56,220,217
DB      102,15,56,220,225
DB      102,15,56,220,233
DB      102,15,56,220,241
DB      102,15,56,220,249
DB      102,68,15,56,220,193
DB      102,68,15,56,220,201
DB      102,15,56,221,208
DB      102,15,56,221,216
DB      102,15,56,221,224
DB      102,15,56,221,232
DB      102,15,56,221,240
DB      102,15,56,221,248
DB      102,68,15,56,221,192
DB      102,68,15,56,221,200
        DB      0F3h,0C3h               ;repret



global  OD_accelerated_aes_ecb_encrypt

ALIGN   16
OD_accelerated_aes_ecb_encrypt:
        mov     QWORD[8+rsp],rdi        ;WIN64 prologue
        mov     QWORD[16+rsp],rsi
        mov     rax,rsp
$L$SEH_begin_aesni_ecb_encrypt:
        mov     rdi,rcx
        mov     rsi,rdx
        mov     rdx,r8
        mov     rcx,r9
        ;mov     r8,QWORD[40+rsp]



DB      243,15,30,250
        lea     rsp,[((-88))+rsp]
        movaps  XMMWORD[rsp],xmm6
        movaps  XMMWORD[16+rsp],xmm7
        movaps  XMMWORD[32+rsp],xmm8
        movaps  XMMWORD[48+rsp],xmm9
$L$ecb_enc_body:
        and     rdx,-16
        jz      NEAR $L$ecb_ret

        mov     eax,DWORD[240+rcx]
        movups  xmm0,XMMWORD[rcx]
        mov     r11,rcx
        mov     r10d,eax
        ;test    r8d,r8d
        ;jz      NEAR $L$ecb_decrypt

        cmp     rdx,0x80
        jb      NEAR $L$ecb_enc_tail

        movdqu  xmm2,XMMWORD[rdi]
        movdqu  xmm3,XMMWORD[16+rdi]
        movdqu  xmm4,XMMWORD[32+rdi]
        movdqu  xmm5,XMMWORD[48+rdi]
        movdqu  xmm6,XMMWORD[64+rdi]
        movdqu  xmm7,XMMWORD[80+rdi]
        movdqu  xmm8,XMMWORD[96+rdi]
        movdqu  xmm9,XMMWORD[112+rdi]
        lea     rdi,[128+rdi]
        sub     rdx,0x80
        jmp     NEAR $L$ecb_enc_loop8_enter
ALIGN   16
$L$ecb_enc_loop8:
        movups  XMMWORD[rsi],xmm2
        mov     rcx,r11
        movdqu  xmm2,XMMWORD[rdi]
        mov     eax,r10d
        movups  XMMWORD[16+rsi],xmm3
        movdqu  xmm3,XMMWORD[16+rdi]
        movups  XMMWORD[32+rsi],xmm4
        movdqu  xmm4,XMMWORD[32+rdi]
        movups  XMMWORD[48+rsi],xmm5
        movdqu  xmm5,XMMWORD[48+rdi]
        movups  XMMWORD[64+rsi],xmm6
        movdqu  xmm6,XMMWORD[64+rdi]
        movups  XMMWORD[80+rsi],xmm7
        movdqu  xmm7,XMMWORD[80+rdi]
        movups  XMMWORD[96+rsi],xmm8
        movdqu  xmm8,XMMWORD[96+rdi]
        movups  XMMWORD[112+rsi],xmm9
        lea     rsi,[128+rsi]
        movdqu  xmm9,XMMWORD[112+rdi]
        lea     rdi,[128+rdi]
$L$ecb_enc_loop8_enter:

        call    _aesni_encrypt8

        sub     rdx,0x80
        jnc     NEAR $L$ecb_enc_loop8

        movups  XMMWORD[rsi],xmm2
        mov     rcx,r11
        movups  XMMWORD[16+rsi],xmm3
        mov     eax,r10d
        movups  XMMWORD[32+rsi],xmm4
        movups  XMMWORD[48+rsi],xmm5
        movups  XMMWORD[64+rsi],xmm6
        movups  XMMWORD[80+rsi],xmm7
        movups  XMMWORD[96+rsi],xmm8
        movups  XMMWORD[112+rsi],xmm9
        lea     rsi,[128+rsi]
        add     rdx,0x80
        jz      NEAR $L$ecb_ret

$L$ecb_enc_tail:
        movups  xmm2,XMMWORD[rdi]
        cmp     rdx,0x20
        jb      NEAR $L$ecb_enc_one
        movups  xmm3,XMMWORD[16+rdi]
        je      NEAR $L$ecb_enc_two
        movups  xmm4,XMMWORD[32+rdi]
        cmp     rdx,0x40
        jb      NEAR $L$ecb_enc_three
        movups  xmm5,XMMWORD[48+rdi]
        je      NEAR $L$ecb_enc_four
        movups  xmm6,XMMWORD[64+rdi]
        cmp     rdx,0x60
        jb      NEAR $L$ecb_enc_five
        movups  xmm7,XMMWORD[80+rdi]
        je      NEAR $L$ecb_enc_six
        movdqu  xmm8,XMMWORD[96+rdi]
        xorps   xmm9,xmm9
        call    _aesni_encrypt8
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        movups  XMMWORD[32+rsi],xmm4
        movups  XMMWORD[48+rsi],xmm5
        movups  XMMWORD[64+rsi],xmm6
        movups  XMMWORD[80+rsi],xmm7
        movups  XMMWORD[96+rsi],xmm8
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_one:
        movups  xmm0,XMMWORD[rcx]
        movups  xmm1,XMMWORD[16+rcx]
        lea     rcx,[32+rcx]
        xorps   xmm2,xmm0
$L$oop_enc1_3:
DB      102,15,56,220,209
        dec     eax
        movups  xmm1,XMMWORD[rcx]
        lea     rcx,[16+rcx]
        jnz     NEAR $L$oop_enc1_3
DB      102,15,56,221,209
        movups  XMMWORD[rsi],xmm2
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_two:
        call    _aesni_encrypt2
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_three:
        call    _aesni_encrypt3
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        movups  XMMWORD[32+rsi],xmm4
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_four:
        call    _aesni_encrypt4
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        movups  XMMWORD[32+rsi],xmm4
        movups  XMMWORD[48+rsi],xmm5
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_five:
        xorps   xmm7,xmm7
        call    _aesni_encrypt6
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        movups  XMMWORD[32+rsi],xmm4
        movups  XMMWORD[48+rsi],xmm5
        movups  XMMWORD[64+rsi],xmm6
        jmp     NEAR $L$ecb_ret
ALIGN   16
$L$ecb_enc_six:
        call    _aesni_encrypt6
        movups  XMMWORD[rsi],xmm2
        movups  XMMWORD[16+rsi],xmm3
        movups  XMMWORD[32+rsi],xmm4
        movups  XMMWORD[48+rsi],xmm5
        movups  XMMWORD[64+rsi],xmm6
        movups  XMMWORD[80+rsi],xmm7
        ;jmp     NEAR $L$ecb_ret

$L$ecb_ret:
        xorps   xmm0,xmm0
        pxor    xmm1,xmm1
        movaps  xmm6,XMMWORD[rsp]
        movaps  XMMWORD[rsp],xmm0
        movaps  xmm7,XMMWORD[16+rsp]
        movaps  XMMWORD[16+rsp],xmm0
        movaps  xmm8,XMMWORD[32+rsp]
        movaps  XMMWORD[32+rsp],xmm0
        movaps  xmm9,XMMWORD[48+rsp]
        movaps  XMMWORD[48+rsp],xmm0
        lea     rsp,[88+rsp]
$L$ecb_enc_ret:
        mov     rdi,QWORD[8+rsp]        ;WIN64 epilogue
        mov     rsi,QWORD[16+rsp]
        DB      0F3h,0C3h               ;repret

$L$SEH_end_aesni_ecb_encrypt:

global  OD_accelerated_aes_set_encrypt_key

ALIGN   16
OD_accelerated_aes_set_encrypt_key:

DB      0x48,0x83,0xEC,0x08

        mov     rax,-1
        test    rcx,rcx
        jz      NEAR $L$enc_key_ret
        test    r8,r8
        jz      NEAR $L$enc_key_ret

        ;mov     r10d,268437504
        movups  xmm0,XMMWORD[rcx]
        xorps   xmm4,xmm4
        ;and     r10d,DWORD[((OPENSSL_ia32cap_P+4))]
        lea     rax,[16+r8]
        cmp     edx,256
        je      NEAR $L$14rounds
        cmp     edx,192
        je      NEAR $L$12rounds
        cmp     edx,128
        jne     NEAR $L$bad_keybits

$L$10rounds:
        mov     edx,9
        ;cmp     r10d,268435456
        ;je      NEAR $L$10rounds_alt

        movups  XMMWORD[r8],xmm0
DB      102,15,58,223,200,1             ;aeskeygenassist
        call    $L$key_expansion_128_cold
DB      102,15,58,223,200,2
        call    $L$key_expansion_128
DB      102,15,58,223,200,4
        call    $L$key_expansion_128
DB      102,15,58,223,200,8
        call    $L$key_expansion_128
DB      102,15,58,223,200,16
        call    $L$key_expansion_128
DB      102,15,58,223,200,32
        call    $L$key_expansion_128
DB      102,15,58,223,200,64
        call    $L$key_expansion_128
DB      102,15,58,223,200,128
        call    $L$key_expansion_128
DB      102,15,58,223,200,27
        call    $L$key_expansion_128
DB      102,15,58,223,200,54
        call    $L$key_expansion_128
        movups  XMMWORD[rax],xmm0
        mov     DWORD[80+rax],edx
        xor     eax,eax
        jmp     NEAR $L$enc_key_ret

ALIGN   16
$L$12rounds:
        movq    xmm2,QWORD[16+rcx]
        mov     edx,11
        ;cmp     r10d,268435456
        ;je      NEAR $L$12rounds_alt

        movups  XMMWORD[r8],xmm0
DB      102,15,58,223,202,1             ;aeskeygenassist
        call    $L$key_expansion_192a_cold
DB      102,15,58,223,202,2
        call    $L$key_expansion_192b
DB      102,15,58,223,202,4
        call    $L$key_expansion_192a
DB      102,15,58,223,202,8
        call    $L$key_expansion_192b
DB      102,15,58,223,202,16
        call    $L$key_expansion_192a
DB      102,15,58,223,202,32
        call    $L$key_expansion_192b
DB      102,15,58,223,202,64
        call    $L$key_expansion_192a
DB      102,15,58,223,202,128
        call    $L$key_expansion_192b
        movups  XMMWORD[rax],xmm0
        mov     DWORD[48+rax],edx
        xor     rax,rax
        jmp     NEAR $L$enc_key_ret

ALIGN   16
$L$14rounds:
        movups  xmm2,XMMWORD[16+rcx]
        mov     edx,13
        lea     rax,[16+rax]
        ;cmp     r10d,268435456
        ;je      NEAR $L$14rounds_alt

        movups  XMMWORD[r8],xmm0
        movups  XMMWORD[16+r8],xmm2
DB      102,15,58,223,202,1             ;aeskeygenassist
        call    $L$key_expansion_256a_cold
DB      102,15,58,223,200,1
        call    $L$key_expansion_256b
DB      102,15,58,223,202,2
        call    $L$key_expansion_256a
DB      102,15,58,223,200,2
        call    $L$key_expansion_256b
DB      102,15,58,223,202,4
        call    $L$key_expansion_256a
DB      102,15,58,223,200,4
        call    $L$key_expansion_256b
DB      102,15,58,223,202,8
        call    $L$key_expansion_256a
DB      102,15,58,223,200,8
        call    $L$key_expansion_256b
DB      102,15,58,223,202,16
        call    $L$key_expansion_256a
DB      102,15,58,223,200,16
        call    $L$key_expansion_256b
DB      102,15,58,223,202,32
        call    $L$key_expansion_256a
DB      102,15,58,223,200,32
        call    $L$key_expansion_256b
DB      102,15,58,223,202,64
        call    $L$key_expansion_256a
        movups  XMMWORD[rax],xmm0
        mov     DWORD[16+rax],edx
        xor     rax,rax
        jmp     NEAR $L$enc_key_ret

ALIGN   16
$L$bad_keybits:
        mov     rax,-2
$L$enc_key_ret:
        pxor    xmm0,xmm0
        pxor    xmm1,xmm1
        pxor    xmm2,xmm2
        pxor    xmm3,xmm3
        pxor    xmm4,xmm4
        pxor    xmm5,xmm5
        add     rsp,8

        DB      0F3h,0C3h               ;repret
$L$SEH_end_set_encrypt_key:

ALIGN   16
$L$key_expansion_128:
        movups  XMMWORD[rax],xmm0
        lea     rax,[16+rax]
$L$key_expansion_128_cold:
        shufps  xmm4,xmm0,16
        xorps   xmm0,xmm4
        shufps  xmm4,xmm0,140
        xorps   xmm0,xmm4
        shufps  xmm1,xmm1,255
        xorps   xmm0,xmm1
        DB      0F3h,0C3h               ;repret

ALIGN   16
$L$key_expansion_192a:
        movups  XMMWORD[rax],xmm0
        lea     rax,[16+rax]
$L$key_expansion_192a_cold:
        movaps  xmm5,xmm2
$L$key_expansion_192b_warm:
        shufps  xmm4,xmm0,16
        movdqa  xmm3,xmm2
        xorps   xmm0,xmm4
        shufps  xmm4,xmm0,140
        pslldq  xmm3,4
        xorps   xmm0,xmm4
        pshufd  xmm1,xmm1,85
        pxor    xmm2,xmm3
        pxor    xmm0,xmm1
        pshufd  xmm3,xmm0,255
        pxor    xmm2,xmm3
        DB      0F3h,0C3h               ;repret

ALIGN   16
$L$key_expansion_192b:
        movaps  xmm3,xmm0
        shufps  xmm5,xmm0,68
        movups  XMMWORD[rax],xmm5
        shufps  xmm3,xmm2,78
        movups  XMMWORD[16+rax],xmm3
        lea     rax,[32+rax]
        jmp     NEAR $L$key_expansion_192b_warm

ALIGN   16
$L$key_expansion_256a:
        movups  XMMWORD[rax],xmm2
        lea     rax,[16+rax]
$L$key_expansion_256a_cold:
        shufps  xmm4,xmm0,16
        xorps   xmm0,xmm4
        shufps  xmm4,xmm0,140
        xorps   xmm0,xmm4
        shufps  xmm1,xmm1,255
        xorps   xmm0,xmm1
        DB      0F3h,0C3h               ;repret

ALIGN   16
$L$key_expansion_256b:
        movups  XMMWORD[rax],xmm0
        lea     rax,[16+rax]

        shufps  xmm4,xmm2,16
        xorps   xmm2,xmm4
        shufps  xmm4,xmm2,140
        xorps   xmm2,xmm4
        shufps  xmm1,xmm1,170
        xorps   xmm2,xmm1
        DB      0F3h,0C3h               ;repret



ALIGN   16
ecb_ccm64_se_handler:
        push    rsi
        push    rdi
        push    rbx
        push    rbp
        push    r12
        push    r13
        push    r14
        push    r15
        pushfq
        sub     rsp,64

        mov     rax,QWORD[120+r8]
        mov     rbx,QWORD[248+r8]

        mov     rsi,QWORD[8+r9]
        mov     r11,QWORD[56+r9]

        mov     r10d,DWORD[r11]
        lea     r10,[r10*1+rsi]
        cmp     rbx,r10
        jb      NEAR $L$common_seh_tail

        mov     rax,QWORD[152+r8]

        mov     r10d,DWORD[4+r11]
        lea     r10,[r10*1+rsi]
        cmp     rbx,r10
        jae     NEAR $L$common_seh_tail

        lea     rsi,[rax]
        lea     rdi,[512+r8]
        mov     ecx,8
        DD      0xa548f3fc
        lea     rax,[88+rax]

        jmp     NEAR $L$common_seh_tail



ALIGN   16
ocb_se_handler:
        push    rsi
        push    rdi
        push    rbx
        push    rbp
        push    r12
        push    r13
        push    r14
        push    r15
        pushfq
        sub     rsp,64

        mov     rax,QWORD[120+r8]
        mov     rbx,QWORD[248+r8]

        mov     rsi,QWORD[8+r9]
        mov     r11,QWORD[56+r9]

        mov     r10d,DWORD[r11]
        lea     r10,[r10*1+rsi]
        cmp     rbx,r10
        jb      NEAR $L$common_seh_tail

        mov     r10d,DWORD[4+r11]
        lea     r10,[r10*1+rsi]
        cmp     rbx,r10
        jae     NEAR $L$common_seh_tail

        mov     r10d,DWORD[8+r11]
        lea     r10,[r10*1+rsi]
        cmp     rbx,r10
        jae     NEAR $L$ocb_no_xmm

        mov     rax,QWORD[152+r8]

        lea     rsi,[rax]
        lea     rdi,[512+r8]
        mov     ecx,20
        DD      0xa548f3fc
        lea     rax,[((160+40))+rax]

$L$ocb_no_xmm:
        mov     rbx,QWORD[((-8))+rax]
        mov     rbp,QWORD[((-16))+rax]
        mov     r12,QWORD[((-24))+rax]
        mov     r13,QWORD[((-32))+rax]
        mov     r14,QWORD[((-40))+rax]

        mov     QWORD[144+r8],rbx
        mov     QWORD[160+r8],rbp
        mov     QWORD[216+r8],r12
        mov     QWORD[224+r8],r13
        mov     QWORD[232+r8],r14

        jmp     NEAR $L$common_seh_tail


$L$common_seh_tail:
        mov     rdi,QWORD[8+rax]
        mov     rsi,QWORD[16+rax]
        mov     QWORD[152+r8],rax
        mov     QWORD[168+r8],rsi
        mov     QWORD[176+r8],rdi

        mov     rdi,QWORD[40+r9]
        mov     rsi,r8
        mov     ecx,154
        DD      0xa548f3fc

        mov     rsi,r9
        xor     rcx,rcx
        mov     rdx,QWORD[8+rsi]
        mov     r8,QWORD[rsi]
        mov     r9,QWORD[16+rsi]
        mov     r10,QWORD[40+rsi]
        lea     r11,[56+rsi]
        lea     r12,[24+rsi]
        mov     QWORD[32+rsp],r10
        mov     QWORD[40+rsp],r11
        mov     QWORD[48+rsp],r12
        mov     QWORD[56+rsp],rcx
        ;call    QWORD[__imp_RtlVirtualUnwind]

        mov     eax,1
        add     rsp,64
        popfq
        pop     r15
        pop     r14
        pop     r13
        pop     r12
        pop     rbp
        pop     rbx
        pop     rdi
        pop     rsi
        DB      0F3h,0C3h               ;repret


section .pdata rdata align=4
ALIGN   4
        DD      $L$SEH_begin_aesni_ecb_encrypt wrt ..imagebase
        DD      $L$SEH_end_aesni_ecb_encrypt wrt ..imagebase
        DD      $L$SEH_info_ecb wrt ..imagebase

        DD      OD_accelerated_aes_set_encrypt_key wrt ..imagebase
        DD      $L$SEH_end_set_encrypt_key wrt ..imagebase
        DD      $L$SEH_info_key wrt ..imagebase
section .xdata rdata align=8
ALIGN   8
$L$SEH_info_ecb:
DB      9,0,0,0
        DD      ecb_ccm64_se_handler wrt ..imagebase
        DD      $L$ecb_enc_body wrt ..imagebase,$L$ecb_enc_ret wrt ..imagebase
$L$SEH_info_key:
DB      0x01,0x04,0x01,0x00
DB      0x04,0x02,0x00,0x00

```

`OfflineDumpPkg/OfflineDumpPkg.dec`:

```dec
[Defines]

  DEC_SPECIFICATION = 0x00010005
  PACKAGE_NAME      = OfflineDumpPkg
  PACKAGE_GUID      = 15527d2d-3f0a-4ca4-9d0b-986c084e20b0
  PACKAGE_VERSION   = 0.1

[Includes]

  Include

[Includes.Common.Private]

  Private
  Include/Library

[LibraryClasses]

  OfflineDumpLib|Include/Library/OfflineDumpLib.h
  OfflineDumpWriterLib|Include/Library/OfflineDumpWriterLib.h

[Guids]

  ## Include/Guid/OfflineDumpConfig.h
  ## Table used to pass information from the firmware to the OS. {3804CF02-8538-11E2-8847-8DF16088709B}
  gOfflineDumpConfigurationTableGuid  = { 0x3804CF02, 0x8538, 0x11E2, { 0x88, 0x47, 0x8D, 0xF1, 0x60, 0x88, 0x70, 0x9B }}

  ## Include/Guid/OfflineDumpConfig.h
  ## Vendor for firmware variables set by the OS. {77fa9abd-0359-4d32-bd60-28f4e78f784b}
  gOfflineDumpVariableGuid            = { 0x77fa9abd, 0x0359, 0x4d32, { 0xBD, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b }}

  ## Include/Guid/OfflineDumpConfig.h
  ## Partition type GUID for the offline dump partition. {66C9B323-F7FC-48B6-BF96-6F32E335A428}
  gOfflineDumpPartitionTypeGuid       = { 0x66C9B323, 0xF7FC, 0x48B6, { 0xBF, 0x96, 0x6F, 0x32, 0xE3, 0x35, 0xA4, 0x28 }}

  ## Offline dump package token space GUID. {8CF239A2-DEC2-458C-A641-6AED5EDE406B}
  gOfflineDumpTokenSpaceGuid          = { 0x8cf239a2, 0xdec2, 0x458c, { 0xa6, 0x41, 0x6a, 0xed, 0x5e, 0xde, 0x40, 0x6b }}

[PcdsFixedAtBuild]

  ## Block device identification strategy used by sample app:
  ## FALSE: Expect 1 raw block device and use it. (Good for testing in emulator.)
  ## TRUE: Expect 1 GPT partition with Type = OffDmp. (Good for normal usage.)
  gOfflineDumpTokenSpaceGuid.PcdOfflineDumpUsePartition|TRUE|BOOLEAN|0x00001001

[Protocols]

  ## Include/Protocol/OfflineDumpProvider.h
  ## {56B79CF2-9D1F-42fc-B45A-16BBBA5C623A}
  gOfflineDumpProviderProtocolGuid = { 0x56b79cf2, 0x9d1f, 0x42fc, { 0xb4, 0x5a, 0x16, 0xbb, 0xba, 0x5c, 0x62, 0x3a }}

```

`OfflineDumpPkg/OfflineDumpPkg.dsc`:

```dsc
[Defines]

  DSC_SPECIFICATION              = 0x00010005
  PLATFORM_NAME                  = OfflineDumpPkg
  PLATFORM_GUID                  = 31d0a291-66bb-48ec-98cf-821d66e2cb0a
  PLATFORM_VERSION               = 0.1
  SUPPORTED_ARCHITECTURES        = IA32|X64|AARCH64
  BUILD_TARGETS                  = DEBUG|RELEASE|NOOPT
  SKUID_IDENTIFIER               = DEFAULT
  OUTPUT_DIRECTORY               = Build/OfflineDumpPkg

!include MdePkg/MdeLibs.dsc.inc

[LibraryClasses]

  # OfflineDumpPkg

  OfflineDumpLib              |OfflineDumpPkg/Library/OfflineDumpLib/OfflineDumpLib.inf
  OfflineDumpWriterLib        |OfflineDumpPkg/Library/OfflineDumpWriterLib/OfflineDumpWriterLib.inf

  # CryptoPkg

  BaseCryptLib                |CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf
  OpensslLib                  |CryptoPkg/Library/OpensslLib/OpensslLib.inf
  IntrinsicLib                |CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf

  # MdeModulePkg

  ReportStatusCodeLib         |MdeModulePkg/Library/DxeReportStatusCodeLib/DxeReportStatusCodeLib.inf

  # MdePkg

  BaseLib                     |MdePkg/Library/BaseLib/BaseLib.inf
  BaseMemoryLib               |MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
  DebugLib                    |MdePkg/Library/UefiDebugLibStdErr/UefiDebugLibStdErr.inf
  DebugPrintErrorLevelLib     |MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
  DevicePathLib               |MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
  MemoryAllocationLib         |MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
  PcdLib                      |MdePkg/Library/DxePcdLib/DxePcdLib.inf
  PrintLib                    |MdePkg/Library/BasePrintLib/BasePrintLib.inf
  RngLib                      |MdePkg/Library/DxeRngLib/DxeRngLib.inf
  UefiLib                     |MdePkg/Library/UefiLib/UefiLib.inf
  UefiApplicationEntryPoint   |MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
  UefiBootServicesTableLib    |MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
  UefiDriverEntryPoint        |MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
  UefiRuntimeServicesTableLib |MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf

[LibraryClasses.X64]

  TimerLib                    |UefiCpuPkg/Library/CpuTimerLib/BaseCpuTimerLib.inf

[LibraryClasses.AARCH64]

  ArmGenericTimerCounterLib   |ArmPkg/Library/ArmGenericTimerPhyCounterLib/ArmGenericTimerPhyCounterLib.inf
  ArmLib                      |ArmPkg/Library/ArmLib/ArmBaseLib.inf
  TimerLib                    |ArmPkg/Library/ArmArchTimerLib/ArmArchTimerLib.inf

[Components]

  OfflineDumpPkg/Library/OfflineDumpLib/OfflineDumpLib.inf
  OfflineDumpPkg/Library/OfflineDumpWriterLib/OfflineDumpWriterLib.inf

  OfflineDumpPkg/Application/OfflineDumpSampleApp.inf
  OfflineDumpPkg/Application/OfflineDumpWrite.inf
  OfflineDumpPkg/Application/OfflineDumpBench.inf

  OfflineDumpPkg/Test/OfflineDumpTest.inf

[PcdsFixedAtBuild]

  # DEBUG_PRINT() filter mask (consumed by DebugLib).
  # - The DebugLib implementation of DebugPrintLevelEnabled(Level) returns 0 != (PcdFixedDebugPrintErrorLevel & Level).
  # - The DEBUG_PRINT() macro in DebugLib.h uses DebugPrintLevelEnabled(Level) to filter output before evaluating
  #   the expression or calling the DebugPrint() function.
  # 0x8000004F = INIT, WARN, LOAD, FS, INFO, ERROR
  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel |0x8000004F

  # DebugPrint() filter mask (consumed by DebugPrintErrorLevelLib).
  # 0x8000004F = INIT, WARN, LOAD, FS, INFO, ERROR
  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel      |0x8000004F

  # ASSERT(), DEBUG, DEBUG_CODE(), DEBUG_CLEAR_MEMORY() filter mask (consumed by DebugLib).
  # 0x11 = ASSERT_BREAKPOINT_ENABLED + ASSERT
  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask         |0x11

```

`OfflineDumpPkg/Private/Library/OfflineDumpEncryptor.h`:

```h
/*
Microsoft Offline Dump - Functions for encrypting data for an Offline Dump.

Consumes:
  MemoryAllocationLib
  BaseCryptLib
  OpensslLib
*/

#ifndef _included_OfflineDumpEncryptor_h
#define _included_OfflineDumpEncryptor_h

#include <Uefi/UefiBaseType.h>
#include <Guid/OfflineDumpEncryption.h>

// Forward decaration of the opaque OFFLINE_DUMP_ENCRYPTOR object.
typedef struct OFFLINE_DUMP_ENCRYPTOR OFFLINE_DUMP_ENCRYPTOR;

// Destroys and frees an Encryptor object.
void
OfflineDumpEncryptorDelete (
  IN OUT OFFLINE_DUMP_ENCRYPTOR  *pEncryptor
  );

// Creates an OFFLINE_DUMP_ENCRYPTOR and a ENC_DUMP_KEY_INFO block for the specified
// algorithm and recipient. Algorithm will typically come from the
// OfflineMemoryDumpEncryptionAlgorithm variable. pRecipientCertificate will typically
// come from the OfflineMemoryDumpEncryptionPublicKey variable.
//
// This function will do the following:
//
// 1. Validate the Algorithm and RecipientCertificate.
// 2. Create a random AES key and IV.
// 3. Create an Encryptor with the key and IV.
// 4. Create a ENC_DUMP_KEY_INFO block with the algorithm, IV, and an encrypted key that
//    can be decrypted with the private key specified in the certificate.
// 5. Return the Encryptor and KeyInfo block. The caller must free these via
//    OfflineDumpEncryptorDelete(*ppEncryptor) and FreePool(*ppKeyInfoBlock).
EFI_STATUS
OfflineDumpEncryptorNewKeyInfoBlock (
  IN ENC_DUMP_ALGORITHM       Algorithm,
  IN void const               *pRecipientCertificate,
  IN UINT32                   RecipientCertificateSize,
  OUT OFFLINE_DUMP_ENCRYPTOR  **ppEncryptor,
  OUT ENC_DUMP_KEY_INFO       **ppKeyInfoBlock
  );

// Converts DataSize bytes of plaintext InputData into encrypted OutputData.
// DataSize and StartingByteOffset must be multiples of 16.
//
// StartingByteOffset is NOT an offset into pInputData or  pOutputData. It is the output
// offset (in bytes) of pInputData[0] relative to the start of the encrypted data. This
// value is used as input to the encryption process (incorrect offset will result in
// garbage output). For example, if encrypting the dump and pInputData points at the
// RAW_DUMP_HEADER, the StartingByteOffset should be 0, and if encrypting dump section
// data for a section starting at offset N, the StartingByteOffset should be N.
//
// In-place operation is supported, i.e. pInputData and pOutputData may point to the same
// place. Other kinds of overlap between the buffers may have unpredictable results.
void
OfflineDumpEncryptorEncrypt (
  IN OFFLINE_DUMP_ENCRYPTOR  *pEncryptor,
  IN UINT64                  StartingByteOffset,
  IN UINT32                  DataSize,
  IN void const              *pInputData,
  OUT void                   *pOutputData
  );

// Returns the ENC_DUMP_ALGORITHM used by the Encryptor.
ENC_DUMP_ALGORITHM
OfflineDumpEncryptorAlgorithm (
  IN OFFLINE_DUMP_ENCRYPTOR const  *pEncryptor OPTIONAL
  );

#endif // _included_OfflineDumpEncryptor_h

```

`OfflineDumpPkg/Private/Library/OfflineDumpRedactionMap.h`:

```h
/*
Microsoft Offline Dump - Redaction tracking for Offline Dump page bitmap.

Maps PageNum (UINT64) to IsRedacted (BOOLEAN) via sparse bitmap.

*** Assumes ***

- Caller provides/owns the memory.
- Page numbers are limited to 44-bits. Assuming a 4KB page, that provides access to a
  56-bit physical address space.

*** Computing the amount of memory to reserve ***

With the current implementation, the exact memory needed for redaction is
Table0 usage + Table1 usage + Bitmap usage:

- Table0 usage = (Highest used physical address) / 2^40, rounded up to multiple of 4KB.
  For a full 56-bit address space, this is 2^56 / 2^40 = 64KB.
- Table1 usage = (Number of 4TB regions touched in your memory map) * 4KB.
  For a full 56-bit address space, this is 16K * 4KB = 64MB.
- Bitmap usage = (Number of 4GB regions touched in your memory map) * 128KB.
  For a full 56-bit address space, this is 16M * 128KB = 2TB.

If physical addresses are all below 4TB then Table0 will be 4KB, there will be one 4KB
Table1, and we can conservatively assume that every 4GB region needs a 128KB bitmap, so
we can conservatively estimate redaction memory usage as 8KB + (highest physical address,
rounded up to a multiple of 2^32, divided by 2^15) bytes. For example, for a system where
the highest physical address is 129G, you can estimate the memory needed as:

1. Round 129G up to a multiple of 4G to get 132G, which is 132 * 2^30.
2. We'll need: 8KB + (132 * 2^30 / 2^15) bytes.
3. We'll need: 8KB + (132 * 2^30 / 2^15 / 2^10) KB.
4. We'll need: 8KB + (132 * 2^5) KB.
5. We'll need: 8KB + 4224KB = 4232KB.

*** Implementation details ***

PageNum bits are used to perform a lookup as follows:

- 30..43: Root Table0 contains up to 16K (2^14) UINT32 elements = up to 64KB. Each
  element is the ChunkNum of the start of the corresponding Table1, or 0 for NULL.
- 20..29: Each Table1 contains 1K (2^10) UINT32 elements = 4KB. Each element is the
  ChunkNum of the start of the corresponding Bitmap, or 0 for NULL.
- 6..19: Each Bitmap is 16K (2^14) UINT64 entries = 128KB.
- 0..5: Each UINT64 entry contains 64 bits (2^6). Each bit represents a page's redaction.

As described above, a bitmap covering the full 44-bit page space would require a little
more than 2TB. ChunkNum is UINT32. Using 4KB chunks, 2TB / 4KB per chunk = 2^29 chunks.
Maximum ChunkNum will therefore fit in 30 bits.
*/

#ifndef _included_OfflineDumpRedactionMap_h
#define _included_OfflineDumpRedactionMap_h

#include <Uefi/UefiBaseType.h>

// Implementation detail.
struct _offline_dump_redaction_map_CHUNK;

// Redaction map structure. Treat as opaque.
typedef struct {
    UINT64 MaxPageNum;   // Page numbers with this value or higher are not redacted.
    struct _offline_dump_redaction_map_CHUNK* pBufferChunks; // Table0 starts at pBufferChunks[0].
    UINT32 MaxBufferChunks; // pBufferChunks is OFFLINE_DUMP_REDACTION_MAP_CHUNK[MaxBufferChunks].
    UINT32 UsedBufferChunks;// Next unused chunk is pBufferChunks[UsedBufferChunks].
} OFFLINE_DUMP_REDACTION_MAP;

// Returned by OfflineDumpRedactionMap_GetFirstRedactedRange(pMap, BeginPageNum, EndPageNum).
typedef struct {
    UINT64 BeginRedactedPageNum;
    UINT64 EndRedactedPageNum;
} OFFLINE_DUMP_REDACTION_MAP_RANGE;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
Initializes the redaction map.

pMap: Pointer to the redaction map to initialize.
pBuffer: Pointer to the buffer to use for page tracking. Must be UINT64-aligned.
BufferSize: Size of the buffer in bytes.
MaxPageNum: 1 + highest PageNum that could possibly be redacted, e.g. 0x1000000000
            for a 36-bit PageNum (a 48-bit physical address space). This value
            determines the size of the root table (Table0). Pages above this value
            cannot be redacted. This value must not be larger than 2^44 (max 56-bit
            physical address space).
*/
EFI_STATUS
OfflineDumpRedactionMap_Init(
    OUT OFFLINE_DUMP_REDACTION_MAP* pMap,
    IN void* pBuffer,
    IN UINTN BufferSize,
    IN UINT64 MaxPageNum
);

/*
Marks the specified pages as redacted or exposed.

Fails if FirstPageNum >= OfflineDumpRedactionMapMaxPageNumber(pMap)
or if IsRedacted and map is out of buffer space.
*/
EFI_STATUS
OfflineDumpRedactionMap_Mark(
    IN OUT OFFLINE_DUMP_REDACTION_MAP* pMap,
    IN BOOLEAN IsRedacted,
    IN UINT64 BeginPageNum,
    IN UINT64 EndPageNum
);

/*
Returns TRUE if the specified page is redacted, FALSE otherwise.
Any page not covered by the map is considered not redacted.

This function is for testing a single page. Use
OfflineDumpRedactionMap_GetFirstRedactedRange to test a range of pages.
*/
BOOLEAN
OfflineDumpRedactionMap_IsRedacted(
    IN OFFLINE_DUMP_REDACTION_MAP const* pMap,
    IN UINT64 PageNum
);

/*
Finds the first redacted range in the specified page range.

Requires: BeginPageNum <= EndPageNum.

Returns: { BeginRedactedPageNum, EndRedactedPageNum }.

Partitions the provided page range BeginPageNum..EndPageNum into three ranges:

- BeginPageNum..BeginRedactedPageNum is exposed (may be written to the dump).
- BeginRedactedPageNum..EndRedactedPageNum is redacted (must be omitted, zeroed,
  or encrypted).
- EndRedactedPageNum..EndPageNum remains unprocessed (call
  OfflineDumpRedactionMap_GetFirstRedactedRange again if this range is not empty).
*/
OFFLINE_DUMP_REDACTION_MAP_RANGE
OfflineDumpRedactionMap_GetFirstRedactedRange(
    IN OFFLINE_DUMP_REDACTION_MAP const* pMap,
    IN UINT64 BeginPageNum,
    IN UINT64 EndPageNum
);

/*
Returns the value of MaxPageNum that was passed to OfflineDumpRedactionMapInit, or 0
if OfflineDumpRedactionMapInit failed.
*/
UINT64
OfflineDumpRedactionMap_MaxPageNumber(
    IN OFFLINE_DUMP_REDACTION_MAP const* pMap
);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif // _included_OfflineDumpRedactionMap_h

```

`OfflineDumpPkg/Private/Library/OfflineDumpRedactionMapInternal.h`:

```h
/*
Microsoft Offline Dump - Internal details of OfflineDumpRedactionMap.

For use by tests and tools.
*/

#ifndef _included_OfflineDumpRedactionMapInternal_h
#define _included_OfflineDumpRedactionMapInternal_h

#include "OfflineDumpRedactionMap.h"

// Each ENTRY contains 2^6 == 64 bits, covering 2^18 == 256KB.
#define BITS_PER_ENTRY_SHIFT         6u
// Each ENTRY contains 2^6 == 64 bits, covering 2^18 == 256KB.
#define BITS_PER_ENTRY               (1u << BITS_PER_ENTRY_SHIFT)

// Each BITMAP contains 2^14 == 16K ENTRYs, covering 2^32 == 4GB.
#define ENTRIES_PER_BITMAP_SHIFT     14u
// Each BITMAP contains 2^14 == 16K ENTRYs, covering 2^32 == 4GB.
#define ENTRIES_PER_BITMAP           (1u << ENTRIES_PER_BITMAP_SHIFT)

// Each BITMAP contains 2^20 = 1M bits, covering 2^32 == 4GB.
#define BITS_PER_BITMAP_SHIFT        (BITS_PER_ENTRY_SHIFT + ENTRIES_PER_BITMAP_SHIFT)
// Each BITMAP contains 2^20 = 1M bits, covering 2^32 == 4GB.
#define BITS_PER_BITMAP              (1u << BITS_PER_BITMAP_SHIFT)

// Each TABLE1 contains 2^10 == 1K BITMAP INDEXs, covering 2^42 == 4TB.
#define BITMAPS_PER_TABLE1_SHIFT     10u
// Each TABLE1 contains 2^10 == 1K BITMAP INDEXs, covering 2^42 == 4TB.
#define BITMAPS_PER_TABLE1           (1u << BITMAPS_PER_TABLE1_SHIFT)

// Each TABLE1 contains 2^30 = 1G bits, covering 2^42 = 4TB.
#define BITS_PER_TABLE1_SHIFT        (BITS_PER_BITMAP_SHIFT + BITMAPS_PER_TABLE1_SHIFT)
// Each TABLE1 contains 2^30 = 1G bits, covering 2^42 = 4TB.
#define BITS_PER_TABLE1              (1u << BITS_PER_TABLE1_SHIFT)

// Each TABLE0 contains up to 2^14 == 16K TABLE1 INDEXs, covering 2^56 bytes.
#define MAX_TABLE1S_PER_TABLE0_SHIFT 14u
// Each TABLE0 contains up to 2^14 == 16K TABLE1 INDEXs, covering 2^56 bytes.
#define MAX_TABLE1S_PER_TABLE0       (1u << MAX_TABLE1S_PER_TABLE0_SHIFT)

// Each TABLE0 contains up to 2^44 bits, covering 2^56 bytes.
#define MAX_BITS_PER_TABLE0_SHIFT    (BITS_PER_TABLE1_SHIFT + MAX_TABLE1S_PER_TABLE0_SHIFT)
// Each TABLE0 contains up to 2^44 bits, covering 2^56 bytes.
#define MAX_BITS_PER_TABLE0          (1ull << MAX_BITS_PER_TABLE0_SHIFT)

STATIC_ASSERT(
    MAX_BITS_PER_TABLE0_SHIFT == 44,
    "TABLE0 must cover a 44-bit page#.");

#endif // _included_OfflineDumpRedactionMapInternal_h

```

`OfflineDumpPkg/Private/Library/OfflineDumpVariables.h`:

```h
/*
Microsoft Offline Dump - Functions for reading Offline Dump firmware variables.

Consumes:
  MemoryAllocationLib       (AllocatePool)
  UefiBootServicesTableLib  (gST->RuntimeServices->GetVariable)
*/

#ifndef _included_OfflineDumpVariables_h
#define _included_OfflineDumpVariables_h

#include <Uefi/UefiBaseType.h>
#include <Guid/OfflineDumpConfig.h>
#include <Guid/OfflineDumpEncryption.h>

// Returns the value of the OfflineMemoryDumpUseCapability firmware variable.
EFI_STATUS
GetVariableOfflineMemoryDumpUseCapability (
  OUT OFFLINE_DUMP_USE_CAPABILITY_FLAGS  *pFlags
  );

// Returns the value of the OfflineMemoryDumpOsData firmware variable.
EFI_STATUS
GetVariableOfflineMemoryDumpOsData (
  OUT UINT64  *pOsData
  );

// Returns the value of the OfflineMemoryDumpEncryptionAlgorithm firmware variable.
EFI_STATUS
GetVariableOfflineMemoryDumpEncryptionAlgorithm (
  OUT ENC_DUMP_ALGORITHM  *pAlgorithm
  );

// Returns the value of the OfflineMemoryDumpEncryptionPublicKey firmware variable.
// The caller is responsible for freeing the RecipientCertificate via
// FreePool(*ppRecipientCertificate).
EFI_STATUS
GetVariableOfflineMemoryDumpEncryptionPublicKey (
  OUT void    **ppRecipientCertificate,
  OUT UINT32  *pRecipientCertificateSize
  );

#endif // _included_OfflineDumpVariables_h

```

`OfflineDumpPkg/Private/Library/OfflineDumpWriter.h`:

```h
/*
Microsoft Offline Dump - Functions for writing dump data to a block device.

PRELIMINARY DESIGN:

The DUMP_WRITER object implements writing section data to a block device, handling
block I/O and full-dump encryption. It does not handle memory/CPU redaction, memory
region encryption, or other aspects of the dump process.

This is not the intended final interface. Current interface is intended to simplify
development and testing. Intended final interface will handle higher-level operations
like memory redaction and encryption. The final interface will likely be a single
WriteDump function that accepts a pDumpConfigurationProtocol pointer.

Consumes:

  BaseLib
  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  SynchronizationLib
  UefiBootServicesTableLib

  BaseCryptLib
  OpensslLib
*/

#ifndef _included_OfflineDumpWriter_h
#define _included_OfflineDumpWriter_h

#include <Uefi/UefiBaseType.h>
#include <Guid/OfflineDumpHeaders.h>

// Forward decaration of the opaque OFFLINE_DUMP_WRITER object.
typedef struct OFFLINE_DUMP_WRITER OFFLINE_DUMP_WRITER;

// Options for adjusting the behavior of a DumpWriter.
typedef struct OFFLINE_DUMP_WRITER_OPTIONS {
  // If false, use BLOCK_IO_PROTOCOL only if BLOCK_IO2_PROTOCOL is not supported.
  // If true, always use BLOCK_IO_PROTOCOL.
  //
  // Set this to true if the underlying device supports BLOCK_IO2_PROTOCOL but doesn't
  // support efficient async I/O. This will cause the writer to use BLOCK_IO_PROTOCOL and
  // synchronous I/O instead of BLOCK_IO2_PROTOCOL with async I/O. On devices that support
  // BLOCK_IO2_PROTOCOL but don't fully support async I/O, this can improve performance.
  // For example, the current EDK2 implementation of the AHCI driver supports BLOCK_IO2
  // but always completes the I/O synchonously, so it would be more efficient to use
  // BLOCK_IO for AHCI devices.
  //
  // May also be useful for testing or debugging.
  BOOLEAN    DisableBlockIo2;

  // If false, use OfflineMemoryDumpEncryptionAlgorithm variable to determine encryption.
  // If true, ignore OfflineMemoryDumpEncryptionAlgorithm and always write an unencrypted
  // dump.
  //
  // This is useful for testing or debugging. This flag must not be set for production
  // builds.
  BOOLEAN    ForceUnencrypted;

  // Number of buffers to use for async I/O. Significant only if the device supports
  // async I/O (EFI_BLOCK_IO2_PROTOCOL).
  //
  // - If this is 0, a default value will be selected.
  // - If this is 1, it will be set to 2.
  // - If EFI_BLOCK_IO2_PROTOCOL is not supported by the device or if the DisableBlockIo2
  //   flag is set, this value will be ignored. In this case, the writer always use one
  //   large buffer for writing data and one small buffer for writing headers.
  UINT8    BufferCount;

  // Maximum total bytes to allocate for the dump writer's I/O buffers (soft limit).
  //
  // This is used to determine
  //
  //   BufferSize = RoundDownToBlockSize(BufferMemoryLimit / BufferCount).
  //
  // - If this is 0, a default value will be selected.
  // - If this is less than BlockSize * BufferCount, it will be set to
  //   BlockSize * BufferCount.
  //
  // Note this does not cap total memory usage of the writer. The dump writer also
  // allocates other memory, e.g. it allocates SectionCountExpected * 64 bytes to track
  // section headers.
  UINT32    BufferMemoryLimit;
} OFFLINE_DUMP_WRITER_OPTIONS;

// Finalizes the dump and deletes the dump writer.
// May block on write operations (writing headers, flushing blocks).
//
// This method does the following:
//
// 1. Flushes any pending data.
// 2. Waits for all pending I/O operations to complete.
// 3. Updates dump header Flags field:
//    - If OfflineDumpWriterLastError() != 0, does not modify the header flags (dump
//      invalid).
//    - Else if OfflineDumpWriterHasInsufficientStorage(), sets the INSUFFICIENT_STORAGE
//      flag.
//    - Else if DumpValid, sets the DUMP_VALID flag.
//    - Else does not modify the header flags (dump invalid).
// 4. Status = FlushHeaders() && pBlockIo->FlushBlocks().
// 5. Deletes pDumpWriter.
// 6. Returns Status.
EFI_STATUS
OfflineDumpWriterClose (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter,
  IN BOOLEAN                  DumpValid
  );

// Creates a new OFFLINE_DUMP_WRITER object for writing a dump to the specified device.
// May block on a write operation (writing headers).
//
// DumpDeviceHandle: must support either EFI_BLOCK_IO_PROTOCOL or EFI_BLOCK_IO2_PROTOCOL.
//      EFI_BLOCK_IO2_PROTOCOL is preferred (supports async I/O, improves performance).
//      This device will usually be a partition handle.
//
// DumpHeaderFlags: flags for the dump header. This must not include the DUMP_VALID or
//      INSUFFICIENT_STORAGE flags (they are managed automatically by the writer).
//
// SectionCountExpected: the maximum number of sections that can be written to the dump.
//      This is used to pre-allocate space for the section headers. It is ok if the
//      actual number of sections written is less than this.
//
// This method does the following:
//
// 1. Reads dump settings from UEFI variables: OfflineMemoryDumpOsData,
//    OfflineMemoryDumpEncryptionAlgorithm, OfflineMemoryDumpEncryptionPublicKey.
// 2. Validate settings (i.e. fail if encryption algorithm is not supported or if
//    certificate cannot be parsed).
// 3. Verifies that the device supports EFI_BLOCK_IO2_PROTOCOL or EFI_BLOCK_IO_PROTOCOL.
// 4. Allocates buffers.
// 5. Writes initial dump headers to dump device (DUMP_VALID flag not set).
//
// If an error is encountered, sets *ppDumpWriter == NULL and returns an error status.
// Otherwise, sets *ppDumpWriter to the new OFFLINE_DUMP_WRITER object and returns
// success.
EFI_STATUS
OfflineDumpWriterOpen (
  IN EFI_HANDLE                         DumpDeviceHandle,
  IN RAW_DUMP_HEADER_FLAGS              DumpHeaderFlags,
  IN UINT32                             SectionCountExpected,
  IN OFFLINE_DUMP_WRITER_OPTIONS const  *pOptions OPTIONAL,
  OUT OFFLINE_DUMP_WRITER               **ppDumpWriter
  );

// If any block write operations have failed, returns the error status of the most
// recent failure. Otherwise, returns EFI_SUCCESS.
//
// Note that OfflineDumpWriterClose() will automatically mark the dump as "invalid" if
// any block write operations fail.
EFI_STATUS
OfflineDumpWriterLastWriteError (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns the device position to which the next OfflineDumpWriterWriteSectionData() will
// write.
//
// This is not the same as the raw dump offset -- this value includes the size of the
// encryption header (if any). This may be larger than OfflineDumpWriterMediaSize() if
// the device is too small for the written data.
UINT64
OfflineDumpWriterMediaPosition (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns the size of the device.
UINT64
OfflineDumpWriterMediaSize (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns the size of the I/O buffer used by the dump writer.
UINT32
OfflineDumpWriterBufferSize (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns the number of I/O buffers used by the dump writer.
UINT8
OfflineDumpWriterBufferCount (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns the ENC_DUMP_ALGORITHM used by the dump writer.
UINT32
OfflineDumpWriterEncryptionAlgorithm (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns true if the dump writer is using EFI_BLOCK_IO2_PROTOCOL for async I/O.
BOOLEAN
OfflineDumpWriterUsingBlockIo2 (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Returns true if the dump writer has run out of storage space, i.e. returns
// OfflineDumpWriterMediaSize() < OfflineDumpWriterMediaPosition().
//
// Note that OfflineDumpWriterClose() will automatically mark the dump as "insufficient
// storage" if this is true.
//
// Note that caller should still write the rest of the sections to the dump so that the
// TotalDumpSizeRequired field can be calculated correctly.
BOOLEAN
OfflineDumpWriterHasInsufficientStorage (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Gets the dump header.
// Caller should not modify the header. The header fields are managed automatically by
// the writer.
RAW_DUMP_HEADER const *
OfflineDumpWriterGetDumpHeader (
  IN OFFLINE_DUMP_WRITER const  *pDumpWriter
  );

// Flushes the current dump headers to the dump device.
// May block on a write operation.
//
// Headers will be written automatically as part of OfflineDumpWriterClose(), but you may
// call this method at other times to save progress in case dump is interrupted.
//
// This is a best-effort method because the headers will be written again as part of
// OfflineDumpWriterClose(). An error in OfflineDumpWriterFlushHeaders() will not affect
// OfflineDumpWriterLastWriteError() and will not invalidate the dump.
//
// Returns a status code indicating whether the headers were flushed.
EFI_STATUS
OfflineDumpWriterFlushHeaders (
  IN OUT OFFLINE_DUMP_WRITER  *pDumpWriter
  );

// Callback to use for reading the section data, e.g. to access fenced memory regions.
//
// pDataStart: The value of the pDataStart parameter that was passed to
//     OfflineDumpWriterWriteSection.
//
// Offset: offset into the section. This will always be less than the DataSize parameter
//     that was passed to OfflineDumpWriterWriteSection. This will always be a multiple
//     of 16.
//
// Size: number of bytes to read. Offset + Size will always be less than or equal to the
//     DataSize parameter that was passed to OfflineDumpWriterWriteSection. Size will
//     always be a multiple of 16 unless DataSize was not, in which case the final call
//     to this callback will have a Size that is not a multiple of 16 (to read the last
//     bytes).
//
// pDestinationPos: destination buffer for the data. Buffer has room for Size bytes.
//     Important: Copy to pDestinationPos[0..Size]. Do not add Offset to this pointer.
//
// Returns: TRUE on success, FALSE if copy failed. FALSE will cause the section to be
//          trucated to the last successfully-copied offset and the section to be
//          marked as invalid (the dump will not be marked as invalid).
//
// Section data will be copied by code that looks approximately like this:
//
// UINT8 DestinationBuffer[SomeMultipleOf16];
// for (UINT64 Offset = 0; Offset < DataSize; Offset += sizeof(DestinationBuffer)) {
//   UINTN Size = (UINTN)MIN(DataSize - Offset, sizeof(DestinationBuffer));
//   if (DataCallback == NULL) {
//      CopyMem(DestinationBuffer, pDataStart + Offset, Size);
//   } else if (!DataCallback(pDataStart, Offset, Size, DestinationBuffer)) {
//      Section->Flags &= ~RAW_DUMP_SECTION_HEADER_DUMP_VALID; // Mark section as invalid.
//      Section->Size = Offset; // Truncate section size to the last successfully-copied offset.
//      break; // Stop copying data for this section (continue to other sections).
//   }
//   AppendToDump(DestinationBuffer, Size);
// }
//
typedef
  BOOLEAN
(EFIAPI *DUMP_WRITER_COPY_CALLBACK)(
                                    IN VOID const *pDataStart,
                                    IN UINTN      Offset,
                                    IN UINTN      Size,
                                    OUT UINT8     *pDestinationPos
                                    );

// Fills in the header and writes the data for the next section.
// May block on a write operation (writing section data).
//
// Flags: flags for the section header.
//
//   - This MUST NOT include the INSUFFICIENT_STORAGE flag because that flag is managed
//     automatically by the writer.
//   - This should usually include the DUMP_VALID flag to mark the section as valid. (The
//     dump writer may remove the DUMP_VALID flag if an error occurs while copying the
//     section data.)
//
// MajorVersion, MinorVersion: version of the section data structure, usually { 1, 0 }.
//
// Type: type of the section.
//
// pInformation: information for the section header. The active field is selected by
//      Type.
//
// pName: name of the section. Must be a null-terminated string. If the name is longer
//      than 20 characters, it will be truncated.
//
// DataCallback: Callback to use for reading the section data. If NULL, the section data
//      will be copied directly. If non-NULL, the callback will be invoked as:
//
//      Ok = DataCallback(pDataStart, Offset, Size, pDestinationPos);
//
// pDataStart: start of the section data. If DataCallback is NULL, this is a pointer to
//      the section data. If DataCallback is non-NULL, this is an opaque value that will
//      be passed to the callback (when using a callback, the pDataStart parameter is
//      just a context value and does not need to be a real pointer).
//
// DataSize: size of the section data in bytes.
//
// Returns:
//
//   - error for invalid parameter or if SectionCountExpected sections have already
//     been written.
//   - success otherwise. Returns success even if there is insufficient storage to write
//     the data or if an error occurs while copying or writing the data. Check
//     OfflineDumpWriterLastWriteError() and OfflineDumpWriterHasInsufficientStorage() to
//     determine whether one of those conditions occurred.
//
// This method does the following:
//
// 1. Fills in the section header as described by the parameters.
// 2. Writes the section data to the dump device.
// 3. If there was not enough space to write the section data, sets the
//    INSUFFICIENT_STORAGE flag in the dump header and clears the DUMP_VALID flag.
// 4. If an error was returned by the callback while copying section data, clears the
//    DUMP_VALID flags in the section header and dump header.
// 5. Updates the dump header TotalDumpSizeRequired, DumpSize, SectionsCount fields.
//
// This does not flush the updated headers to disk. Headers will be flushed to disk as
// part of OfflineDumpWriterClose(), or you may call OfflineDumpWriterFlushHeaders() to
// save progress in case the dump is interrupted.
EFI_STATUS
OfflineDumpWriterWriteSection (
  IN OUT OFFLINE_DUMP_WRITER             *pDumpWriter,
  IN RAW_DUMP_SECTION_HEADER_FLAGS       SectionHeaderFlags,
  IN UINT16                              MajorVersion,
  IN UINT16                              MinorVersion,
  IN RAW_DUMP_SECTION_TYPE               Type,
  IN RAW_DUMP_SECTION_INFORMATION const  *pInformation,
  IN CHAR8 const                         *pName,
  IN DUMP_WRITER_COPY_CALLBACK           DataCallback OPTIONAL,
  IN void const                          *pDataStart,
  IN UINTN                               DataSize
  );

#endif // _included_OfflineDumpWriter_h

```

`OfflineDumpPkg/Private/Readme.md`:

```md
# OpenSSL Redirection Headers

At present, we need OpenSSL functionality that is not exposed by BaseCryptLib.

- AES-ECB (used as a step in implementing AES-CTR).
- Enveloped-message CMS (encrypted key transport).

At present, we are leveraging BaseCryptLib's port of OpenSSL. To do this, we need to redirect `#include <openssl/FILE.h>` to the appropriate full path. Since EDK2's build system doesn't allow direct manipulation of the include paths, we use stub headers to perform this redirection.

This isn't ideal. The long-term solution would be to update BaseCryptLib to support the necessary APIs.

```

`OfflineDumpPkg/Private/openssl/add_OpensslGen.bat`:

```bat
@echo off
REM Redirects <openssl/FILE.h> to openssl generated include path.
for %%a in (%*) do echo #include ^<Library/OpensslLib/OpensslGen/include/openssl/%%a.h^>>%~dp0%%a.h

```

`OfflineDumpPkg/Private/openssl/add_openssl.bat`:

```bat
@echo off
REM Redirects <openssl/FILE.h> to openssl static include path.
for %%a in (%*) do echo #include ^<Library/OpensslLib/openssl/include/openssl/%%a.h^>>%~dp0%%a.h

```

`OfflineDumpPkg/Private/openssl/aes.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/aes.h>

```

`OfflineDumpPkg/Private/openssl/asn1.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/asn1.h>

```

`OfflineDumpPkg/Private/openssl/asn1err.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/asn1err.h>

```

`OfflineDumpPkg/Private/openssl/bio.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/bio.h>

```

`OfflineDumpPkg/Private/openssl/bioerr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/bioerr.h>

```

`OfflineDumpPkg/Private/openssl/bn.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/bn.h>

```

`OfflineDumpPkg/Private/openssl/bnerr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/bnerr.h>

```

`OfflineDumpPkg/Private/openssl/buffer.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/buffer.h>

```

`OfflineDumpPkg/Private/openssl/buffererr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/buffererr.h>

```

`OfflineDumpPkg/Private/openssl/cms.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/cms.h>

```

`OfflineDumpPkg/Private/openssl/conf.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/conf.h>

```

`OfflineDumpPkg/Private/openssl/conferr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/conferr.h>

```

`OfflineDumpPkg/Private/openssl/configuration.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/configuration.h>

```

`OfflineDumpPkg/Private/openssl/conftypes.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/conftypes.h>

```

`OfflineDumpPkg/Private/openssl/core.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/core.h>

```

`OfflineDumpPkg/Private/openssl/core_dispatch.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/core_dispatch.h>

```

`OfflineDumpPkg/Private/openssl/crypto.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/crypto.h>

```

`OfflineDumpPkg/Private/openssl/cryptoerr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/cryptoerr.h>

```

`OfflineDumpPkg/Private/openssl/cryptoerr_legacy.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/cryptoerr_legacy.h>

```

`OfflineDumpPkg/Private/openssl/e_os2.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/e_os2.h>

```

`OfflineDumpPkg/Private/openssl/ec.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/ec.h>

```

`OfflineDumpPkg/Private/openssl/ecerr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/ecerr.h>

```

`OfflineDumpPkg/Private/openssl/evp.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/evp.h>

```

`OfflineDumpPkg/Private/openssl/evperr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/evperr.h>

```

`OfflineDumpPkg/Private/openssl/http.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/http.h>

```

`OfflineDumpPkg/Private/openssl/indicator.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/indicator.h>

```

`OfflineDumpPkg/Private/openssl/lhash.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/lhash.h>

```

`OfflineDumpPkg/Private/openssl/macros.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/macros.h>

```

`OfflineDumpPkg/Private/openssl/obj_mac.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/obj_mac.h>

```

`OfflineDumpPkg/Private/openssl/objects.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/objects.h>

```

`OfflineDumpPkg/Private/openssl/objectserr.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/objectserr.h>

```

`OfflineDumpPkg/Private/openssl/opensslconf.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/opensslconf.h>

```

`OfflineDumpPkg/Private/openssl/opensslv.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/opensslv.h>

```

`OfflineDumpPkg/Private/openssl/params.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/params.h>

```

`OfflineDumpPkg/Private/openssl/pkcs7.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/pkcs7.h>

```

`OfflineDumpPkg/Private/openssl/pkcs7err.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/pkcs7err.h>

```

`OfflineDumpPkg/Private/openssl/safestack.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/safestack.h>

```

`OfflineDumpPkg/Private/openssl/sha.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/sha.h>

```

`OfflineDumpPkg/Private/openssl/stack.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/stack.h>

```

`OfflineDumpPkg/Private/openssl/symhacks.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/symhacks.h>

```

`OfflineDumpPkg/Private/openssl/types.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/types.h>

```

`OfflineDumpPkg/Private/openssl/x509.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/x509.h>

```

`OfflineDumpPkg/Private/openssl/x509_vfy.h`:

```h
#include <Library/OpensslLib/OpensslGen/include/openssl/x509_vfy.h>

```

`OfflineDumpPkg/Private/openssl/x509err.h`:

```h
#include <Library/OpensslLib/openssl/include/openssl/x509err.h>

```

`OfflineDumpPkg/Test/OfflineDumpTest.cpp`:

```cpp
#include "OfflineDumpTest.h"

extern "C" {
 
    #include <Uefi.h>
    #include <Library/BaseMemoryLib.h>
    #include <Library/DebugLib.h>
    #include <Library/PrintLib.h>
    #include <Library/UefiBootServicesTableLib.h>
    #include <Library/UefiLib.h>
}

static unsigned s_errorCount = 0;

static void
TestPrintLnV(wchar_t const* Prefix, char const* Format, VA_LIST Args)
{
    static CHAR16 Buffer[256];
    EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL* const ConOut = gST->ConOut;

    Buffer[0] = 0;
    UnicodeVSPrintAsciiFormat (Buffer, sizeof(Buffer), Format, Args);

    if (ConOut)
    {
        ConOut->OutputString (ConOut, (CHAR16*)Prefix);
        ConOut->OutputString (ConOut, Buffer);
        ConOut->OutputString (ConOut, (CHAR16*)L"\r\n");
    }
}

void
TestPrintLn(wchar_t const* Prefix, char const* Format, ...)
{
    VA_LIST Args;
    VA_START(Args, Format);
    TestPrintLnV(Prefix, Format, Args);
    VA_END(Args);
}

void
TestMsg(char const* Format, ...)
{
    VA_LIST Args;
    VA_START(Args, Format);
    TestPrintLnV(L"msg: ", Format, Args);
    VA_END(Args);
}

void
TestErr(char const* Format, ...)
{
    s_errorCount += 1;

    VA_LIST Args;
    VA_START(Args, Format);
    TestPrintLnV(L"ERR: ", Format, Args);
    VA_END(Args);
}

static void
RunOneTest(char const* Name, void (*TestFunc)(void))
{
    TestPrintLn(L"TEST: ", "%a", Name);
    TestFunc();
}

extern "C" EFI_STATUS EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
    #define RUN_TEST(TestName) RunOneTest(#TestName, TestName);
    ALL_TESTS(RUN_TEST)
    #undef RUN_TEST    

    if (s_errorCount != 0)
    {
        TestPrintLn(L"", "\r\nFAIL: %u error(s)", s_errorCount);
        return EFI_DEVICE_ERROR;
    }
    else
    {
        TestPrintLn(L"", "PASS");
        return EFI_SUCCESS;
    }
}

```

`OfflineDumpPkg/Test/OfflineDumpTest.h`:

```h
#ifndef __included_OfflineDumpTest_h
#define __included_OfflineDumpTest_h

#define ALL_TESTS(x) \
    x(RedactionScratchBufferLengthTest) \
    x(SparseBitmapTest) \

#define TestAssert(   condition)            ((condition) \
    ? (void)0    \
    : TestErr("%a(%u) : ASSERT(%a)",       __FILE__, __LINE__, #condition))

#define TestAssertFmt(condition, fmt, ...)  ((condition) \
    ? (void)0    \
    : TestErr("%a(%u) : ASSERT(%a): " fmt, __FILE__, __LINE__, #condition, __VA_ARGS__))

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void
TestMsg(char const* fmt, ...);

void
TestErr(char const* fmt, ...);

#define DECLARE_TEST(TestName) void TestName(void);
ALL_TESTS(DECLARE_TEST)
#undef DECLARE_TEST

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif // __included_OfflineDumpTest_h

```

`OfflineDumpPkg/Test/OfflineDumpTest.inf`:

```inf
[Defines] 

  INF_VERSION                    = 0x00010005
  UEFI_SPECIFICATION_VERSION     = 0x0002001E
  BASE_NAME                      = OfflineDumpTest
  VERSION_STRING                 = 0.1
  FILE_GUID                      = b133b1b0-eba9-4f6f-973f-621652c28d22
  MODULE_TYPE                    = UEFI_APPLICATION
  ENTRY_POINT                    = UefiMain

[Sources]

  OfflineDumpTest.cpp
  RedactionScratchBufferLengthTest.cpp
  SparseBitmapTest.cpp

[Packages]

  OfflineDumpPkg/OfflineDumpPkg.dec

  MdePkg/MdePkg.dec

[LibraryClasses]

  OfflineDumpLib
  OfflineDumpWriterLib

  BaseMemoryLib
  DebugLib
  MemoryAllocationLib
  TimerLib
  UefiBootServicesTableLib
  UefiLib

  UefiApplicationEntryPoint

```

`OfflineDumpPkg/Test/RedactionScratchBufferLengthTest.cpp`:

```cpp
#include "OfflineDumpTest.h"

extern "C" {
    #include <Library/OfflineDumpLib.h>
}

static void
TestSimple(UINT64 highestPhysicalAddress, unsigned table1s, unsigned bitmaps)
{
    UINT32 expectedSize = 4 * 1024 + (table1s * 4 * 1024) + (bitmaps * 128 * 1024);
    UINT32 size;
    TestAssert(EFI_SUCCESS == GetOfflineDumpRedactionScratchBufferLength(highestPhysicalAddress, &size));
    if (size != expectedSize) {
        TestErr("RedactionScratchBufferLength: address 0x%llX, expected 0x%X, actual 0x%X",
             (unsigned long long)highestPhysicalAddress, expectedSize, size);
    }
}

void
RedactionScratchBufferLengthTest()
{
    static UINT64 const MaxAddress = 0x7FFDFFFFFFFF;
    UINT32 size;
    
    // Test error cases (size can't fit in UINT32)
    size = 0;
    TestAssert(EFI_INVALID_PARAMETER == GetOfflineDumpRedactionScratchBufferLength(~(UINT64)0, &size));
    TestAssert(size == 0xFFFFF000);
    size = 0;
    TestAssert(EFI_INVALID_PARAMETER == GetOfflineDumpRedactionScratchBufferLength(MaxAddress + 1, &size));
    TestAssert(size == 0xFFFFF000);

    TestSimple(0, 1, 1); // Minimum.
    TestSimple(0x20BFFFFFFF, 1, 33); // 131GB
    TestSimple(MaxAddress, 32, 32766); // 127.9TB
}

```

`OfflineDumpPkg/Test/SparseBitmapTest.cpp`:

```cpp
#include "OfflineDumpTest.h"
#include <Library/OfflineDumpRedactionMap.h>
#include <Library/OfflineDumpRedactionMapInternal.h>

static UINT64 g_mapBuf[1024 * 1024 / sizeof(UINT64)]; // 1MB

void
OfflineDumpRedactionMap_Init_Test()
{
    OFFLINE_DUMP_REDACTION_MAP map;
    TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, sizeof(g_mapBuf), MAX_BITS_PER_TABLE0 + 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 - 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 1));
    TestAssert(EFI_OUT_OF_RESOURCES == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, 64 * 1024 - 1, MAX_BITS_PER_TABLE0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 - 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 1));
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, 64 * 1024, MAX_BITS_PER_TABLE0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 - 1));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 0));
    TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, MAX_BITS_PER_TABLE0 + 1));
}

static void
ClearAndCheck(OFFLINE_DUMP_REDACTION_MAP& map, UINT64 beginPageNum, UINT64 endPageNum)
{
    TestAssert(beginPageNum <= endPageNum);
    auto const beforeWasSet = OfflineDumpRedactionMap_IsRedacted(&map, beginPageNum - 1);
    auto const afterWasSet = OfflineDumpRedactionMap_IsRedacted(&map, endPageNum);
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, beginPageNum, endPageNum));
    TestAssert(beforeWasSet == OfflineDumpRedactionMap_IsRedacted(&map, beginPageNum - 1));
    TestAssert(afterWasSet == OfflineDumpRedactionMap_IsRedacted(&map, endPageNum));

    auto range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum, endPageNum);
    TestAssert(range.BeginRedactedPageNum == endPageNum);
    TestAssert(range.EndRedactedPageNum == endPageNum);

    if (beginPageNum - 1 < beginPageNum)
    {
        range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum - 1, endPageNum);
        TestAssert(range.BeginRedactedPageNum == beforeWasSet ? beginPageNum - 1 : endPageNum);
        TestAssert(range.EndRedactedPageNum == beforeWasSet ? beginPageNum : endPageNum);
    }

    if (endPageNum < endPageNum + 1)
    {
        range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum, endPageNum + 1);
        TestAssert(range.BeginRedactedPageNum == afterWasSet ? endPageNum : endPageNum);
        TestAssert(range.EndRedactedPageNum == afterWasSet ? endPageNum + 1 : endPageNum);
    }


    if (endPageNum - beginPageNum < 256)
    {
        for (UINT64 pageNum = beginPageNum; pageNum != endPageNum; pageNum += 1)
        {
            TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
    }
    else
    {
        for (UINT64 pageNum = beginPageNum; pageNum != beginPageNum + 128; pageNum += 1)
        {
            TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
        for (UINT64 pageNum = endPageNum - 128; pageNum != endPageNum; pageNum += 1)
        {
            TestAssert(!OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
    }
}

static void
SetAndCheck(OFFLINE_DUMP_REDACTION_MAP& map, UINT64 beginPageNum, UINT64 endPageNum)
{
    TestAssert(beginPageNum <= endPageNum);
    auto const beforeWasSet = OfflineDumpRedactionMap_IsRedacted(&map, beginPageNum - 1);
    auto const afterWasSet = OfflineDumpRedactionMap_IsRedacted(&map, endPageNum);
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, beginPageNum, endPageNum));
    TestAssert(beforeWasSet == OfflineDumpRedactionMap_IsRedacted(&map, beginPageNum - 1));
    TestAssert(afterWasSet == OfflineDumpRedactionMap_IsRedacted(&map, endPageNum));

    auto range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum, endPageNum);
    TestAssert(range.BeginRedactedPageNum == beginPageNum);
    TestAssert(range.EndRedactedPageNum == endPageNum);

    if (beginPageNum - 1 < beginPageNum)
    {
        range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum - 1, endPageNum);
        TestAssert(range.BeginRedactedPageNum == beforeWasSet ? beginPageNum - 1 : beginPageNum);
        TestAssert(range.EndRedactedPageNum == endPageNum);
    }

    if (endPageNum < endPageNum + 1)
    {
        range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, beginPageNum, endPageNum + 1);
        TestAssert(range.BeginRedactedPageNum == beginPageNum);
        TestAssert(range.EndRedactedPageNum == afterWasSet ? endPageNum + 1 : endPageNum);
    }

    if (endPageNum - beginPageNum < 256)
    {
        for (UINT64 pageNum = beginPageNum; pageNum != endPageNum; pageNum += 1)
        {
            TestAssert(OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
    }
    else
    {
        for (UINT64 pageNum = beginPageNum; pageNum != beginPageNum + 128; pageNum += 1)
        {
            TestAssert(OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
        for (UINT64 pageNum = endPageNum - 128; pageNum != endPageNum; pageNum += 1)
        {
            TestAssert(OfflineDumpRedactionMap_IsRedacted(&map, pageNum));
        }
    }
}

static void
ValidateMap(OFFLINE_DUMP_REDACTION_MAP const& map, UINT64 const* ranges, unsigned pairs)
{
    OFFLINE_DUMP_REDACTION_MAP_RANGE range;
    UINT64 pos = 0;
    UINT64 const end = pairs ? ranges[pairs * 2 - 1] : 0;
    for (unsigned i = 0; i != pairs * 2; i += 2)
    {
        range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, pos, end);
        TestAssert(range.BeginRedactedPageNum == ranges[i]);
        TestAssert(range.EndRedactedPageNum == ranges[i + 1]);
        pos = range.EndRedactedPageNum;
    }

    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, pos, end + 1);
    TestAssert(range.BeginRedactedPageNum == end + 1);
    TestAssert(range.EndRedactedPageNum == end + 1);
}

template<unsigned N>
static void
ValidateMap(OFFLINE_DUMP_REDACTION_MAP const& map, UINT64 const (&ranges)[N])
{
    static_assert(N % 2 == 0, "ranges must be even");
    ValidateMap(map, ranges, N / 2);
}

static void
InitAndValidateMap(UINT64 const* ranges, unsigned pairs)
{
    OFFLINE_DUMP_REDACTION_MAP map;
    auto const MaxPageNo = MAX_BITS_PER_TABLE0;
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, sizeof(g_mapBuf), MaxPageNo));

    for (unsigned i = 0; i != pairs * 2; i += 2)
    {
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, ranges[i], ranges[i + 1]));
    }

    ValidateMap(map, ranges, pairs);
}

template<unsigned N>
static void
InitAndValidateMap(UINT64 const (&ranges)[N])
{
    static_assert(N % 2 == 0, "ranges must be even");
    InitAndValidateMap(ranges, N / 2);
}

static void
OfflineDumpRedactionMap_GetFirstRedactedRange_Test()
{
    OFFLINE_DUMP_REDACTION_MAP map;
    auto const MaxPageNo = MAX_BITS_PER_TABLE0;

    // Initialize the map with enough space for bitmaps.
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, sizeof(g_mapBuf), MaxPageNo));
    ValidateMap(map, nullptr, 0);

    // Test case: Empty map (no redacted ranges)
    auto range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == MaxPageNo);
    TestAssert(range.EndRedactedPageNum == MaxPageNo);

    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 10, 20));
    ValidateMap(map, { 10, 20 });

    // Test case: Single redacted range
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 20);
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 9, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 20);
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 10, 20);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 20);
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 11, 19);
    TestAssert(range.BeginRedactedPageNum == 11);
    TestAssert(range.EndRedactedPageNum == 19);

    // map = [10..20], [30..70]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 30, 70));
    ValidateMap(map, { 10, 20, 30, 70 });
    // Test case: Multiple redacted ranges
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 20);

    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 20, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == 30);
    TestAssert(range.EndRedactedPageNum == 70);

    // Test case: Query range within a redacted range
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 15, 25);
    TestAssert(range.BeginRedactedPageNum == 15);
    TestAssert(range.EndRedactedPageNum == 20);

    // Test case: Query range partially overlapping a redacted range
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 5, 15);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 15);

    // Test case: Query range after all redacted ranges
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 70, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == MaxPageNo);
    TestAssert(range.EndRedactedPageNum == MaxPageNo);

    // Test case: Query range before all redacted ranges
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, 5);
    TestAssert(range.BeginRedactedPageNum == 5);
    TestAssert(range.EndRedactedPageNum == 5);

    // Test case: Query range exactly matching a redacted range
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 10, 20);
    TestAssert(range.BeginRedactedPageNum == 10);
    TestAssert(range.EndRedactedPageNum == 20);

    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 10, 15));
    ValidateMap(map, { 15, 20, 30, 70 });
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 10, 20));
    ValidateMap(map, { 30, 70 });
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 30, 70));
    ValidateMap(map, nullptr, 0);

    // Test case: Clear all redacted ranges and check again
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == MaxPageNo);
    TestAssert(range.EndRedactedPageNum == MaxPageNo);

    // map = [0..5]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 0, 5));
    ValidateMap(map, { 0, 5 });

    // Test case: Boundary conditions at the start of the map
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 0, 5);
    TestAssert(range.BeginRedactedPageNum == 0);
    TestAssert(range.EndRedactedPageNum == 5);

    // map = [0..5], [Max - 5..Max]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo - 5, MaxPageNo));
    ValidateMap(map, { 0, 5, MaxPageNo - 5, MaxPageNo });

    // Test case: Boundary conditions at the end of the map
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, MaxPageNo - 5, MaxPageNo);
    TestAssert(range.BeginRedactedPageNum == MaxPageNo - 5);
    TestAssert(range.EndRedactedPageNum == MaxPageNo);

    // map = [0..5] [15..25] [Max - 5..Max]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 15, 25));
    ValidateMap(map, { 0, 5, 15, 25, MaxPageNo - 5, MaxPageNo });

    // Test case: Overlapping redacted ranges
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 10, 30);
    TestAssert(range.BeginRedactedPageNum == 15);
    TestAssert(range.EndRedactedPageNum == 25);

    // map = [0..5] [15..25] [Max - 5..Max]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 50, 50));
    ValidateMap(map, { 0, 5, 15, 25, MaxPageNo - 5, MaxPageNo});

    // Test case: 0 page range
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 49, 49);
    TestAssert(range.BeginRedactedPageNum == 49);
    TestAssert(range.EndRedactedPageNum == 49);
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 50, 50);
    TestAssert(range.BeginRedactedPageNum == 50);
    TestAssert(range.EndRedactedPageNum == 50);

    // map = [0..5] [15..25] [Max - 5..Max]
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 60, 70));
    ValidateMap(map, { 0, 5, 15, 25, 60, 70, MaxPageNo - 5, MaxPageNo });
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 80, 90));
    ValidateMap(map, { 0, 5, 15, 25, 60, 70, 80, 90, MaxPageNo - 5, MaxPageNo });

    // Test case: Non-redacted pages in between redacted ranges
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 60, 90);
    TestAssert(range.BeginRedactedPageNum == 60);
    TestAssert(range.EndRedactedPageNum == 70);

    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 70, 90);
    TestAssert(range.BeginRedactedPageNum == 80);
    TestAssert(range.EndRedactedPageNum == 90);

    // Test case: Large ranges
    TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 100, 1000));
    ValidateMap(map, { 0, 5, 15, 25, 60, 70, 80, 90, 100, 1000, MaxPageNo - 5, MaxPageNo });
    range = OfflineDumpRedactionMap_GetFirstRedactedRange(&map, 100, 1000);
    TestAssert(range.BeginRedactedPageNum == 100);
    TestAssert(range.EndRedactedPageNum == 1000);
}

void
OfflineDumpRedactionMap_Mark_Test()
{
    {
        OFFLINE_DUMP_REDACTION_MAP map;
        auto const MaxPageNo = MAX_BITS_PER_TABLE0;

        // Full address space but no room for bitmaps.
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, 64 * 1024, MaxPageNo));

        // Clearing should succeed as long as begin <= end && end <= MaxPageNo.

        // Check begin <= end.
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, 0, 1) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, 1, 1) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, 2, 1) == EFI_INVALID_PARAMETER);

        // Check end <= MaxPageNo.
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo - 1, MaxPageNo - 1) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo - 1, MaxPageNo + 0) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo - 1, MaxPageNo + 1) == EFI_INVALID_PARAMETER);


        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo + 1, MaxPageNo + 1));
        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo, MaxPageNo + 1));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 0, 0));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo, MaxPageNo));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 0, 1));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo - 1, MaxPageNo));

        // Setting should fail because there is no room for bitmaps (unless it's a no-op).

        // Check begin <= end.
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, 0, 1) == EFI_OUT_OF_RESOURCES);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, 1, 1) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, 2, 1) == EFI_INVALID_PARAMETER);

        // Check end <= MaxPageNo.
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo - 1, MaxPageNo - 1) == EFI_SUCCESS);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo - 1, MaxPageNo + 0) == EFI_OUT_OF_RESOURCES);
        TestAssert(OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo - 1, MaxPageNo + 1) == EFI_INVALID_PARAMETER);
    }

    {
        OFFLINE_DUMP_REDACTION_MAP map;
        auto const MaxPageNo = MAX_BITS_PER_TABLE0 / 2;

        // Large but not complete address space. Room for several bitmaps.
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, sizeof(g_mapBuf), MaxPageNo));

        // Clearing should succeed as long as the ending page# is less than MaxPageNo.
        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo + 1, MaxPageNo + 1));
        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo, MaxPageNo + 1));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, 0, 0));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, FALSE, MaxPageNo, MaxPageNo));

        // Setting should succeed because there is room for bitmaps.
        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo + 1, MaxPageNo + 1));
        TestAssert(EFI_INVALID_PARAMETER == OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo, MaxPageNo + 1));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, 0, 0));
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Mark(&map, TRUE, MaxPageNo, MaxPageNo));

        // Within the same bitmap, start of address range.

        SetAndCheck(map, 0, 513);
        ClearAndCheck(map, 0, 1); // Start to middle.
        ClearAndCheck(map, 2, 4); // Middle to middle.
        ClearAndCheck(map, 10, 64); // Middle to end.
        ClearAndCheck(map, 128, 192); // Start to end.
        ClearAndCheck(map, 256, 330); // Start to next middle.
        ClearAndCheck(map, 332, 385); // Middle to next middle.
        ClearAndCheck(map, 400, 512); // Middle to next end.

        ClearAndCheck(map, 0, 513);
        SetAndCheck(map, 0, 1); // Start to middle.
        SetAndCheck(map, 2, 4); // Middle to middle.
        SetAndCheck(map, 10, 64); // Middle to end.
        SetAndCheck(map, 128, 192); // Start to end.
        SetAndCheck(map, 256, 330); // Start to next middle.
        SetAndCheck(map, 332, 385); // Middle to next middle.
        SetAndCheck(map, 400, 512); // Middle to next end.

        // Within the same bitmap, end of address range.

        SetAndCheck(map, MaxPageNo - 16, MaxPageNo);
        ClearAndCheck(map, MaxPageNo - 16, MaxPageNo - 15);
        ClearAndCheck(map, MaxPageNo - 14, MaxPageNo - 12);
        ClearAndCheck(map, MaxPageNo - 11, MaxPageNo - 7);
        ClearAndCheck(map, MaxPageNo - 6, MaxPageNo - 2);

        ClearAndCheck(map, MaxPageNo - 16, MaxPageNo);
        SetAndCheck(map, MaxPageNo - 16, MaxPageNo - 15);
        SetAndCheck(map, MaxPageNo - 14, MaxPageNo - 12);
        SetAndCheck(map, MaxPageNo - 11, MaxPageNo - 7);
        SetAndCheck(map, MaxPageNo - 6, MaxPageNo - 2);

        // Crossing through three real bitmaps.

        // This will cause bitmaps 0, 1, and 2 to be allocated.
        ClearAndCheck(map, BITS_PER_BITMAP - 16, BITS_PER_BITMAP * 2 + 16);   // Clear bits from bitmap[0] to bitmap[2].
        SetAndCheck(map, BITS_PER_BITMAP - 15, BITS_PER_BITMAP * 2 + 15);   // Set bits from bitmap[0] to bitmap[2].

        // Bitmaps 0, 1, and 2 are already allocated.
        SetAndCheck(map, BITS_PER_BITMAP - 16, BITS_PER_BITMAP * 2 + 16);   // Set bits from bitmap[0] to bitmap[2].
        ClearAndCheck(map, BITS_PER_BITMAP - 15, BITS_PER_BITMAP * 2 + 15); // Clear bits from bitmap[0] to bitmap[2].

        // Crossing from real bitmap into fake (zeroed) bitmap and back into real bitmap.

        // Deallocate all bitmaps, then allocate 0 and 2. bitmap[1] remains unallocated.
        TestAssert(EFI_SUCCESS == OfflineDumpRedactionMap_Init(&map, &g_mapBuf, sizeof(g_mapBuf), MaxPageNo));
        SetAndCheck(map, BITS_PER_BITMAP - 16, BITS_PER_BITMAP);              // Allocate bitmap[0], set bits at the end.
        SetAndCheck(map, BITS_PER_BITMAP * 2, BITS_PER_BITMAP * 2 + 16);      // Allocate bitmap[1], set bits at the start.
        ClearAndCheck(map, BITS_PER_BITMAP - 15, BITS_PER_BITMAP * 2 + 15);   // Clear bits from bitmap[0] to bitmap[2].
    }

    InitAndValidateMap({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });

    InitAndValidateMap({ 0, 63 });
    InitAndValidateMap({ 0, 64 });
    InitAndValidateMap({ 0, 65 });

    InitAndValidateMap({ 1, 63 });
    InitAndValidateMap({ 63, 64 });
    InitAndValidateMap({ 64, 65 });

    InitAndValidateMap({ 0, 255 });
    InitAndValidateMap({ 0, 256 });
    InitAndValidateMap({ 0, 257 });

    InitAndValidateMap({ 1, 255 });
    InitAndValidateMap({ 63, 256 });
    InitAndValidateMap({ 64, 257 });

    InitAndValidateMap({ BITS_PER_BITMAP - 65, BITS_PER_BITMAP });
    InitAndValidateMap({ BITS_PER_BITMAP - 64, BITS_PER_BITMAP });
    InitAndValidateMap({ BITS_PER_BITMAP - 63, BITS_PER_BITMAP });
    InitAndValidateMap({ BITS_PER_BITMAP - 1,  BITS_PER_BITMAP });

    InitAndValidateMap({ BITS_PER_BITMAP - 65, BITS_PER_BITMAP + 1 });
    InitAndValidateMap({ BITS_PER_BITMAP - 64, BITS_PER_BITMAP + 63 });
    InitAndValidateMap({ BITS_PER_BITMAP - 63, BITS_PER_BITMAP + 64 });
    InitAndValidateMap({ BITS_PER_BITMAP - 1,  BITS_PER_BITMAP + 65 });

    InitAndValidateMap({ BITS_PER_BITMAP - 65, BITS_PER_BITMAP + BITS_PER_BITMAP + 1});
    InitAndValidateMap({ BITS_PER_BITMAP - 64, BITS_PER_BITMAP + BITS_PER_BITMAP + 63 });
    InitAndValidateMap({ BITS_PER_BITMAP - 63, BITS_PER_BITMAP + BITS_PER_BITMAP + 64 });
    InitAndValidateMap({ BITS_PER_BITMAP - 1,  BITS_PER_BITMAP + BITS_PER_BITMAP + 65 });

    InitAndValidateMap({ BITS_PER_TABLE1 - 65, BITS_PER_TABLE1 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 64, BITS_PER_TABLE1 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 63, BITS_PER_TABLE1 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 1,  BITS_PER_TABLE1 });

    InitAndValidateMap({ BITS_PER_TABLE1 - 65, BITS_PER_TABLE1 + BITS_PER_BITMAP + 1 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 64, BITS_PER_TABLE1 + BITS_PER_BITMAP + 63 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 63, BITS_PER_TABLE1 + BITS_PER_BITMAP + 64 });
    InitAndValidateMap({ BITS_PER_TABLE1 - 1,  BITS_PER_TABLE1 + BITS_PER_BITMAP + 65 });
}

void
SparseBitmapTest()
{
    OfflineDumpRedactionMap_Init_Test();
    OfflineDumpRedactionMap_Mark_Test();
    OfflineDumpRedactionMap_GetFirstRedactedRange_Test();
}

```

`OfflineDumpPkg/dumpvars.nsh`:

```nsh
@echo -off

if "%1" == "" or "%1" == "0" then
  echo UNENCRYPTED
  setvar OfflineMemoryDumpEncryptionAlgorithm -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =00000000
  goto GoodArgs
endif
if "%1" == "1" then
  echo AES128_CTR
  setvar OfflineMemoryDumpEncryptionAlgorithm -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =01000000
  goto GoodArgs
endif
if "%1" == "2" then
  echo AES192_CTR
  setvar OfflineMemoryDumpEncryptionAlgorithm -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =02000000
  goto GoodArgs
endif
if "%1" == "3" then
  echo AES256_CTR
  setvar OfflineMemoryDumpEncryptionAlgorithm -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =03000000
  goto GoodArgs
endif

echo Unrecognized ALG_ID %1.
echo This command sets the firmware variables needed for offline crash dump.
echo Usage: dumpvars ALG_ID
echo ALG_ID can be: 0 (UNENCRYPTED), 1 (AES128_CTR), 2 (AES192_CTR), 3 (AES256_CTR)
goto Done

:GoodArgs
setvar OfflineMemoryDumpUseCapability -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =01
setvar OfflineMemoryDumpEncryptionPublicKey -guid 77fa9abd-0359-4d32-bd60-28f4e78f784b -bs -rt -nv =H308204be308202a6a003020102021014a4cc4e395de48c4df31edacf3c0206300d06092a864886f70d0101050500301b31193017060355040313104f66666c696e65437261736844756d70301e170d3235303232313231333533395a170d3430303130313030303030305a301b31193017060355040313104f66666c696e65437261736844756d7030820222300d06092a864886f70d01010105000382020f003082020a0282020100b5b8bbd6ce64bea03f4c80635a5240f2db6d18246cc7d77d921d277ec7f3072d1d46f69f7f10e822f402d10fb211d866a8a8e43c5d9baac3ef9e2d7802e751cd7357c50a369ce4cb6241dbaa9cdcd7e0aea08dc3e211292418073fb3fe2794532e0a0138d477ef2ebe5742712f18932773ea5763db08c57b3b315bf6af7b3c77ffbad51fa7a38fa873318c7148678da7f9ec3d058ce3688c50e6809ffc3d8fbdfc60405d7424de9d83b71c6f97e4e0d91392a7b9a9ab3e87d803f59b5d1b31077d2c51ca3dff8e0e4c7ef2b7907097063466ab9d182255e5605beaf5eccd979db4f64a62170bae7546de47dddc44a0545e4f728726271f2f346292cc26b6dd8c7c034946cdc81fa4f0145fe83f6ebe096ff01db98076dbdd593a73e89adf4c12fb62d04fe924bc2ae516cdbfdc2f994a9fa30a04e9cb9e7091767e241cd9cc3fdeec5f3613da81dd29ef429d6031d4f46d53b5a8b6d59ef2a321c69654f90d3ab2b9bd275b6a8d2934ef20a21648f67a951b69bad3bef5d05bd5420f54f2b8b9468bc5011b3e81a60781fb579a00175c01d608c1bf681b0af5e9d7d9656c63556783fb9cc4ca058b021260a702ed66b64790593d9873322577118d39971275acbc15cc83a43e49dcf3d388290849c68023669aede05ba136223c8c34dece1de4373f085673328fdbae83ffd3f148917e76bc0388a532ef57cd0a2c7324c5d38d0203010001300d06092a864886f70d0101050500038202010041b58c8a4d72dbfb90936975e376e2cda3905a1adea82d485f307892af874db442dbbc580afc8875927dfdf76d70d9215ce71eb287ffcfd20afac2a11664044ef0467dcd1235ea793824769f305956fed20af7f59d2f2f5b28401d690aee066f6c86c59979683b2b7e711cbe8c2ba4af92afbb21317b9804ac3c23d398038b0d9654ff8bfc8e4b861687b1834cdb9edeec19b211aa64e2fe08db6e47385a21333e938ad40a17021a3c8d773bc4ec92d8aa76e24b85438f8c77433ffc106291a5278d0ca28f5c0a7a965a4ed6b6de54dec5968b9e770df9299c1bde4775b7e72772f37ccb3cf55d50fecd8e724bb5d98b1f9c1e0f7468d71cc62df3b44cd15f38cad6d4340d2abaec48b1382fac40aebc7d6b51c80990a2db0cc543098e74077a00082ae26c13d6809f6399f5813f9228bbe8430af034c2bcc6031df5db48b3a89198f55c6f227d8aec2c21f52967e75738a7d6e6c6aa209e6c87a7f9c4999250069d4bcf82bc37e0ab038c511b4f63c037f2010274270e57f06d759d41d376e61b88192d4d0fba5bfbf62b482ba9ca9bf1eccc5133f58ba82dfb27aba588fef5c7f152938e34cf3452f1d30dadc0520e98026be17a261ee8460414567ec4d6ed6cafe646bdd28efc2b6fe592d681018557b95a189001ba32ea9b262b659c39873f7cf367efb1cde594f1b08705e14dbacf98e40377831f7779457db20142640e

if not %lasterror% == 0 then
  echo .
  echo Failed to set OfflineMemoryDumpEncryptionPublicKey (error %lasterror%). This
  echo may be due to the variable size limit. You may need to increase
  echo PcdMaxVariableSize, e.g. you may need to add
  echo "  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x800"
  echo to the [PcdsFixedAtBuild] section of the platform's .dsc file.
  echo .
endif

:Done

```

`OfflineDumpPkg/sample_keys.txt`:

```txt
sample_keys.cer contains a sample self-signed certificate (public key).

sample_keys.pfx contains the corresponding private key (password abc123).

dumpvars.nsh will install the sample certificate and will configure the system
to generate encrypted dumps using that certificate. The resulting dumps can
be decrypted using the sample_keys.pfx private key.

```

`README.md`:

```md
# Offline Crash Dump UEFI

This project contains definitions and code to aid firmware developers in their implementation of
[Offline Crash Dump](#background) (OffCD).

The provided definitions (constants and data structures) may be useful for any build or execution
environment.

- **[Constants and data structures](OfflineDumpPkg/Include/Guid/)** - headers with GUIDs, enums, and
  structs used in offline crash dumps.

The provided code is intended to build in EDK2 and execute in a UEFI-DXE environment. For those using other
build or execution environments, the code may still be useful as a reference.

- **[OfflineDumpLib](OfflineDumpPkg/Include/Library/OfflineDumpLib.h)** --
  support code for writing offline crash dumps.

  - Helpers for locating the partition where the dump should be written.
  - Helpers for executing the "OfflineDumpWrite.efi" application.
  - Helpers for reading Windows-defined UEFI variables related to offline crash dumps.

- **[OfflineDumpWriterLib](OfflineDumpPkg/Include/Library/OfflineDumpWriterLib.h)** --
  static library that implements crash dump generation.

- **[Redistributable](OfflineDumpPkg/Application/OfflineDumpWrite.inf)** --
  application binary "OfflineDumpWrite.efi" that implements crash dump generation.

- **[Sample](OfflineDumpPkg/Application/OfflineDumpSampleApp.c)** -- sample shows how to generate an offline
  crash dump using `OfflineDumpWrite.efi`.

## Background

An **Online** Crash Dump is a system memory dump written by a high-level operating system (HLOS)
like Windows or Linux. An **Offline** Crash Dump (OffCD) is a system memory dump written by firmware.

Online dumps are preferable in most scenarios because they can integrate more closely with the HLOS,
its device drivers, its configuration, and its security/privacy posture.

Offline dumps are useful for cases where online dumps don't work. These may include:

- Getting data from crashes that occur before the HLOS has started.
- Getting data after the system has become unstable, i.e. when a system reset is required to
  restore system stability.
- Getting data from HLOS hangs.

Offline dumps should only be used in device development scenarios (e.g. bring-up, stabilization, or
debugging). Offline dumps should not be used in retail, production, or mission-mode scenarios.
Firmware developers should enforce this by allowing offline dump collection only when the device
is configured for debugging as determined by one of the following:

- The device is debug-fused.
- The device has a device-id-specific certificate installed that enables debugging features.

The offline dump functionality may be invoked by many different triggers, including (but not
limited to):

- Watchdog timeout indicating the HLOS is hung.
- Firmware-detected error condition.
- Long power-button press that is not handled by the HLOS.

If any of these triggers are encountered while the device is not configured to collect offline
dumps, the device should instead record basic information about the problem and report the
information via
[BERT](https://uefi.org/specs/ACPI/6.5/18_Platform_Error_Interfaces.html#boot-error-record-table-bert).

Some hardware/firmware-detected errors may be recoverable or may be reportable via
HLOS-provided facilities such as [WHEA](https://learn.microsoft.com/en-us/windows-hardware/drivers/whea/).

Both online and offline dumps include facilities for attaching extra information to the dump, e.g.
the contents of a subsystem's registers or SRAM.

- For an online dump, a device driver associated with the subsystem can register a
  [Bug Check Reason Callback Routine](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/writing-a-bug-check-callback-routine).
  This callback can gather subsystem state and add it to the dump.
- For an offline dump, the failure handler can copy subsystem state into a reserved region of
  memory before the reset. After the reset, the dump writer can include the data from these reserved
  regions into the dump as SV-specific sections.

## Boot procedures

To support offline dump, the firmware vendor must alter the normal boot flow to prepare for the
possibility of an offline dump and must add an alternative boot flow to write the dump.

Early in the boot sequence, the bootloader determines whether the system is
[booting normally](#booting-normally) or is
[rebooting due to an offline dump trigger](#rebooting-due-to-an-offline-dump-trigger).
It selects the appropriate boot flow based on this determination.

### Booting normally

The following steps occur if the system is booting normally (not rebooting due to an offline dump trigger).

1. During early boot (before UEFI), trusted firmware determines whether the device is in a retail or
   debug configuration based on fuse state and/or per-device-ID debug-enablement certificate.

   This value (retail or debug configuration) is recorded for use in case of a
   hardware/firmware-detected error.

2. Firmware configures watchdogs as appropriate to fire in cases of system stability issues.

3. Firmware
   [installs](https://tianocore-docs.github.io/edk2-UefiDriverWritersGuide/draft/5_uefi_services/52_services_that_uefi_drivers_rarely_use/5210_installconfigurationtable.html)
   the [Offline Dump Configuration table](OfflineDumpPkg/Include/Guid/OfflineDumpConfig.h) to
   indicate offline dump support and status to the HLOS.

4. Firmware checks the `OfflineMemoryDumpUseCapability` firmware environment variable to determine
   whether the HLOS has enabled offline dumps. This value is recorded for use in case of a
   hardware/firmware-detected error.

   If an error occurs before this value is checked, the firmware may assume that the HLOS has
   enabled offline dumps.

5. If the device is in a debug state and the HLOS has enabled offline dumps, the firmware reserves
   extra memory to support offline dump (the memory will not be available to the HLOS).

   - Memory is reserved for recording diagnostic information, e.g. to store CPU contexts.
   - Memory is reserved for use when
     [rebooting due to an offline dump trigger](#rebooting-due-to-an-offline-dump-trigger) so that
     the reboot does not overwrite memory that should be captured in the dump.

6. If the device is in a debug state and the HLOS has enabled offline dumps, the firmware should
   configure a watchdog to trigger if the power button is held for a long time (e.g. 10 seconds) so
   that the user can manually trigger an offline dump if the HLOS becomes unresponsive.

7. If a prior reset was due to a hardware/firmware-detected error, the firmware may publish tables
   for a BERT report.

At any point after step 1, a hardware/firmware-detected error may trigger the following sequence:

- If the device is not in a debug configuration (as determined in step 1) the device must not proceed
  with the remaining sequence. Instead, it must perform a cold reset (wiping memory) after optionally
  saving data for BERT or other error reports.
- If firmware has determined that the HLOS has not enabled offline dumps (as determined in step 4),
  the device should not proceed with the remaining sequence. Instead, it should perform a cold reset
  (wiping memory) after optionally saving data for BERT or other error reports.
  - If the hardware/firmware-detected error occurs prior to step 4, the firmware may proceed with the
    remaining sequence.
- The device attempts to flush CPU cache to DRAM.
- The device records diagnostic information into the memory that was reserved in step 5. This
  should include the following:
  - Information about the cause of the dump, e.g. which watchdog fired or which subsystem's
    firmware encoutered an error.
  - CPU (application processor) context information (the registers of each CPU).
  - Whether the firmware successfully flushed CPU cache to memory.
  - Registers and/or SRAM state from other subsystems.
- The device configures DRAM for self-refresh and performs any other necessary proceduress so that DRAM
  contents will be available after warm reset (e.g. saving DRAM encryption keys).
- The device saves information so that on subsequent boot, the bootloader can determine that the
  reset is due to an offline dump trigger.
- The device performs a warm reset (preserving memory). The system reboots for an
  [offline dump trigger](#rebooting-due-to-an-offline-dump-trigger).

### Rebooting due to an offline dump trigger

The following steps occur if the system is rebooting due to an offline dump trigger, not booting normally.

1. During early boot (before UEFI), trusted firmware determines whether the device is in a retail or
   debug configuration based on fuse state and/or per-device-ID debug-enablement certificate.

   If the device is in a retail configuration, it must not proceed with the remaining steps and must
   perform a cold reset (wiping memory) after optionally saving data for BERT or other error reports.

   If the necessary fuse state or certificate information is not available due to restrictions on the
   special offline-dump boot session, the firmware may use fuse/certificate state determined during
   the previous (normal) boot session so long as that value was determined by trusted firmware and
   was recorded in trusted (secured/fenced) memory.

2. To avoid overwriting memory that needs to be recorded in the dump, the firmware restricts itself to
   using only the memory that was reserved for this case (reserved by step 5 of the
   [Booting normally](#booting-normally) sequence).

3. To ensure security, the firmware only loads trusted modules and only the minimum set of modules
   needed to perform offline dump.

4. The firmware disables any functionality other than offline dump.

   - No configuration menu.
   - No shell.
   - No boot menu.
   - No boot to high-level OS.

5. The firmware checks firmware environment variables to determine dump configuration.

   - If the system is not configured to enable offline dump (e.g. if the `OfflineMemoryDumpUseCapability`
     variable is missing or 0), the device should not proceed with the remaining steps and should perform
     a cold reset after optionally saving data for BERT or other error reports.

     If the variable value is not available due to restrictions on the special offline-dump boot session,
     the firmware may use the value determined during the previous (normal) boot session.

6. The firmware displays UI indicating that a dump is in progress, e.g. "Offline dump in progress.
   Please release the power button. This should complete in 5-10 minutes."

7. The firmware writes the dump to a storage device, respecting the dump configuration specified by
   firmware environment variables `OfflineMemoryDumpUseCapability`, `OfflineMemoryDumpOsData`,
   `OfflineMemoryDumpEncryptionAlgorithm`, and `OfflineMemoryDumpEncryptionPublicKey`.

   If the variable values are not available, the firmware may use the values determined during the
   previous (normal) boot session.

   This step may be implemented using the `OfflineDumpWrite` helpers provided by this project:

   - Firmware implements the
     [OfflineDumpProvider](OfflineDumpPkg/Include/Protocol/OfflineDumpProvider.h) protocol and
     passes the protocol pointer to an `OfflineDumpWrite` function.
   - `OfflineDumpWrite` implementation configures itself based on the provided protocol and the
     relevant firmware environment variables.
   - `OfflineDumpWrite` implementation writes dump data to storage device, periodically invoking
     the protocol's ReportProgress callback.
     - The ReportProgress callback should update the UI to provide feedback to the user.

8. The firmware records offline dump status so that it can be reported in the
   [Offline Dump Configuration table](OfflineDumpPkg/Include/Guid/OfflineDumpConfig.h) provided
   in the subsequent normal boot.

9. The firmware records diagnostic data for use in a BERT report in the subsequent normal boot.

10. The firmware performs a cold reset (wiping memory). The system reboots for a
    [normal boot](#booting-normally).

## EDK2 build environment (Windows)

### EDK2 first-time setup (Windows)

- As necessary, install Visual Studio compiler tools.
- As necessary, install Python 3. `python.exe` should be on your PATH.
- Get IASL and NASM. Add to the PATH as appropriate.
  - Alternative: Ensure NuGet.exe is on your path, then run `get-iasl.cmd` and `get-nasm.cmd` scripts
    to download these binaries from the Project Mu NuGet feed into a repo-local directory.
- Init submodules in repo root and in edk2.
  - CD to repo root and run: `git submodule update --init`
  - CD to root\edk2 and run: `git submodule update --init`
- Build the tools: `wsetup rebuild`
- Update `workspace\Conf\target.txt` as appropriate.
  - Update `TOOL_CHAIN_TAG` to match the version of Visual Studio that is installed, e.g. `VS2022`.
  - Update `TARGET_ARCH` as appropriate for your default target, e.g. `X64`.
  - As appropriate, set `ACTIVE_PLATFORM` to the platform you want to have as your default.
    - If you usually want to work in the Emulator, leave it set to `EmulatorPkg/EmulatorPkg.dsc`.
    - If you usually want to build a standalone OfflineDumpSampleApp.efi module, set it to `OfflineDumpPkg/OfflineDumpPkg.dsc`.

### EDK2 each-time setup (Windows)

- Run `wsetup` to set up the environment.
- Run `build` to build the active platform.
- Run `build (options)` to build other platforms.

## EDK2 build environment (Linux)

### EDK2 first-time setup (Linux)

- As necessary, install basic build stuff: `apt install build-essential uuid-dev iasl nasm git python3 python-is-python3`
- As necessary, install cross-compiler: `apt install gcc-aarch64-linux-gnu`
- Init submodules in repo root and in edk2.
  - CD to repo root and run: `git submodule update --init`
  - CD to root/edk2 and run: `git submodule update --init`
- Build BaseTools: CD to repo root and run: `make -C edk2/BaseTools`
- CD to repo root and source (not run!) the environment setup script: `. usetup.sh`
  - Not `./usetup.sh`
- Update `workspace/Conf/target.txt` as appropriate.
  - Update `TOOL_CHAIN_TAG` to `GCC`
  - Update `TARGET_ARCH` as appropriate for your default target, e.g. `X64` or `AARCH64`.
  - As appropriate, set `ACTIVE_PLATFORM` to the platform you want to have as your default.
    - If you usually want to work in the Emulator, leave it set to `EmulatorPkg/EmulatorPkg.dsc`.
    - If you usually want to build a standalone OfflineDumpSampleApp.efi module, set it to `OfflineDumpPkg/OfflineDumpPkg.dsc`.

### EDK2 each-time setup (Linux)

- Source `. usetup.sh` to set up the environment (use `. usetup.sh`, not `./usetup.sh`).
- Run `build` to build the active platform.
- Run `build (options)` to build other platforms.

## Application behavior

OfflineDump is configured using some firmware variables. For testing purposes, you will need to set
these variables before running the sample app.

- Use the [dumpvars.nsh](OfflineDumpPkg/dumpvars.nsh) script to configure the device.
  - This sets OfflineMemoryDumpUseCapability = 1 (enable dumps).
  - This sets OfflineMemoryDumpEncryptionAlgorithm to 0 (no encryption), 1 (AES128), 2 (AES192), or 3 (AES256).
  - This sets OfflineMemoryDumpEncryptionPublicKey to the certificate from `sample_keys.cer`.
  - The private key corresponding to `sample_keys.cer` is provided in `sample_keys.pfx` (password `abc123`).

The `OfflineDumpSampleApp.efi` sample app will do the following:

- Look for an appropriate target for the dump, e.g. GPT partition with Type = SVRawDump.
- If a target is found, look for the necessary UEFI variables that control dump enablement and encryption.
- If the variables are found, write a "sample" dump to the partition.

## Configuring EmulatorPkg on Windows

If using EmulatorPkg to test the application, you'll probably want to configure the Emulator as follows:

Edit `edk2\EmulatorPkg\EmulatorPkg.dsc` to build the OfflineDump library and sample application.

- Under `[LibraryClasses]`, add: `OfflineDumpLib|OfflineDumpPkg/Library/OfflineDumpLib/OfflineDumpLib.inf`
- Under `[LibraryClasses]`, add: `OfflineDumpWriterLib|OfflineDumpPkg/Library/OfflineDumpWriterLib/OfflineDumpWriterLib.inf`
- Under `[Components]`, add: `OfflineDumpPkg/Application/OfflineDumpSampleApp.inf`
- Under `[Components]`, add: `OfflineDumpPkg/Application/OfflineDumpWrite.inf`
- Optional: Under `[PcdsFixedAtBuild]`, add: `gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x800`
  - This allows storing larger UEFI variables, which is required to support dump encryption certificates
    with larger public keys. The default value (0x400) is too small for RSA-3072 and RSA-4096.
- Optional: Under `[PcdsFixedAtBuild]`, add: `gOfflineDumpTokenSpaceGuid.PcdOfflineDumpUsePartition|FALSE`
  - This makes the application write directly to `disk.dmg` rather than looking for a GPT partition within `disk.dmg`.
    This allows you to treat `disk.dmg` directly as a `rawdump.bin` file without any kind of extraction step.

You may then run `build -p EmulatorPkg/EmulatorPkg.dsc` to build the EmulatorPkg platform, resulting in
platform files in a directory like `ROOT\workspace\Build\EmulatorX64\DEBUG_VS2022\X64`.

You will need to create a `workspace\Build\EmulatorX64\DEBUG_VS2022\X64\disk.dmg` file that will act as
the partition to receive the dump file. Use any tool (e.g. hex editor or dd) to create a zero-filled
file large enough to contain the dump (generally a little bit larger than the emulator's physical memory,
e.g. 129MB if the emulator is configured for 128MB of memory), e.g.
`dd if=/dev/zero of=disk.dmg bs=1M count=129`

You may want to copy the firmware variables setup script to that directory, i.e. from repo root, run:
`copy OfflineDumpPkg\dumpvars.nsh workspace\Build\EmulatorX64\DEBUG_VS2022\X64`

You can then run the resulting WinHost.exe to launch the emulator, and then in the shell, run the app:

- In the UEFI shell, change to the FS0 drive: `FS0:`
- If needed, set up the UEFI variables by running `.\dumpvars.nsh`.
- Run the sample application: `.\OfflineDumpSampleApp.efi`
  - Note that diagnostic output goes to the debug console instead of the shell console.
  - If the output says `Dump disabled`, run the `dumpvars.nsh` script to set up the variables
    and then try again.
- Close the emulator.
- The dump will be present in the disk image file, e.g. `workspace\Build\EmulatorX64\DEBUG_VS2022\X64\disk.dmg`.
  - If encrypted, you can decrypt using the sample private key from `sample_keys.pfx` (password `abc123`).

Note that there have been several recent bug fixes in EmulatorPkg. The OfflineDump code assumes that
these bugs have been fixed. You may encounter hangs or errors if using an old version of EmulatorPkg.

## Integrating this package into an existing EDK2 build environment

There are currently two supported methods for integrating this package into your build
environment:

- Directly-link your dump-writer driver/application with `OfflineDumpLib` and use
  `OfflineDumpWrite.efi` as a separately-compiled binary (recommended).
- Directly-link your dump-writer driver/application with `OfflineDumpLib` and `OfflineDumpWriterLib`
  (deprecated; will be unsupported in the future).

Procedure:

1. Copy the `OfflineDumpPkg` folder to an appropriate location in your project.
   - If the location is not directly listed in `PACKAGES_PATH`, you may need to update paths
     in the INF files to refer to the actual location of `OfflineDumpPkg.dec` relative to
     the nearest directory in `PACKAGES_PATH`.
2. Create your own application or driver that will reference `OfflineDumpPkg`. Use
   `OfflineDumpPkg/Application/OfflineDumpSampleApp.c` as a reference.
   
    In the `.inf` file of your application or driver:
   - Add the path to `OfflineDumpPkg.dec` under `[Packages]`.
   - Add `OfflineDumpLib` under `[LibraryClasses]`.
   - If you will be directly-linking to `OfflineDumpWriterLib`, add `OfflineDumpWriterLib` under
     `[LibraryClasses]`.
3. In your project's `.dsc` file:
   - Add the paths to `OfflineDumpLib.inf` and `OfflineDumpWriterLib.inf` in the appropriate
     `[LibraryClasses]` section.
   - If using `OfflineDumpWrite.efi` as a separately-compiled binary, add
     the path to `OfflineDumpWrite.inf` under `[Components]`.

## Future Directions

At present, `OfflineDumpWrite` is available as a function in
OfflineDumpWriterLib or as the binary application `OfflineDumpWrite.efi`. In
the future, OfflineDumpWriterLib will no longer be available. Users should
transition to using the `OfflineDumpWrite.efi` binary application and invoking
it using an `OfflineDumpWriteExecute` helper function.

## Contributing

This project welcomes contributions and suggestions. Most contributions require you to agree to a
Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us
the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.

When you submit a pull request, a CLA bot will automatically determine whether you need to provide
a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions
provided by the bot. You will only need to do this once across all repos using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

## Trademarks

This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft
trademarks or logos is subject to and must follow
[Microsoft's Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general).
Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.
Any use of third-party trademarks or logos are subject to those third-party's policies.

```

`SECURITY.md`:

```md
<!-- BEGIN MICROSOFT SECURITY.MD V0.0.9 BLOCK -->

## Security

Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet) and [Xamarin](https://github.com/xamarin).

If you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/security.md/definition), please report it to us as described below.

## Reporting Security Issues

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/security.md/msrc/create-report).

If you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/security.md/msrc/pgp).

You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://www.microsoft.com/msrc). 

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:

  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)
  * Full paths of source file(s) related to the manifestation of the issue
  * The location of the affected source code (tag/branch/commit or direct URL)
  * Any special configuration required to reproduce the issue
  * Step-by-step instructions to reproduce the issue
  * Proof-of-concept or exploit code (if possible)
  * Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/security.md/msrc/bounty) page for more details about our active programs.

## Preferred Languages

We prefer all communications to be in English.

## Policy

Microsoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/security.md/cvd).

<!-- END MICROSOFT SECURITY.MD BLOCK -->

```

`SUPPORT.md`:

```md
# Support

## How to file issues and get help  

This project uses GitHub Issues to track bugs and feature requests. Please search the existing 
issues before filing new issues to avoid duplicates.  For new issues, file your bug or 
feature request as a new Issue.

## Microsoft Support Policy  

Support for this **PROJECT or PRODUCT** is limited to the resources listed above.

```

`get-iasl.cmd`:

```cmd
@echo off
setlocal
set BIN=%~dp0edk2\BaseTools\Bin\Win32
set SOURCE=https://pkgs.dev.azure.com/projectmu/acpica/_packaging/mu_iasl/nuget/v3/index.json
set NAME=edk2-acpica-iasl
set VERSION=20200717.0.0

if not exist %BIN% mkdir %BIN%

nuget install %NAME% -Version %VERSION% -Source %SOURCE% -OutputDirectory %BIN% || (
    echo Failed to download iasl nuget to %BIN%.
    goto :eof
)

move /y "%BIN%\%NAME%.%VERSION%\%NAME%\Windows-x86\*.exe" "%BIN%" || (
    echo Failed to copy iasl to %BIN%.
    goto :eof
)

move /y "%BIN%\%NAME%.%VERSION%\%NAME%\Windows-x86\*.pdb" "%BIN%"

rd /s /q %BIN%\%NAME%.%VERSION%
dir %BIN%\iasl.exe

```

`get-nasm.cmd`:

```cmd
@echo off
setlocal
set BIN=%~dp0edk2\BaseTools\Bin\Win32
set SOURCE=https://api.nuget.org/v3/index.json
set NAME=mu_nasm
set VERSION=2.15.5

if not exist %BIN% mkdir %BIN%

nuget install %NAME% -Version %VERSION% -Source %SOURCE% -OutputDirectory %BIN% || (
    echo Failed to download nasm nuget to %BIN%.
    goto :eof
)

move /y "%BIN%\%NAME%.%VERSION%\%NAME%\Windows-x86-64\*.exe" "%BIN%" || (
    echo Failed to copy nasm to %BIN%.
    goto :eof
)

rd /s /q "%BIN%\%NAME%.%VERSION%"
dir %BIN%\nasm.exe

```

`usetup.sh`:

```sh
#
# This script should be sourced from repo root, not executed.
# Run: . usetup.sh
# Not: ./usetup.sh`
#

if [ ! -f "./usetup.sh" ]
then
        echo This file should be sourced from the repo root, ". usetup.sh".
        return 1
fi

if [ ! -f "edk2/edksetup.sh" ]
then
        echo git submodules not updated in ROOT.
        echo In ROOT and in ROOT/edk2, run: git submodule update --init
        return 1
fi

if [ ! -f "edk2/BaseTools/Source/C/BrotliCompress/brotli/c/common/constants.h" ]
then
        echo git submodules not updated in EDK2.
        echo In ROOT/edk2, run: git submodule update --init
        return 1
fi

export GCC_AARCH64_PREFIX=aarch64-linux-gnu-
export WORKSPACE=$PWD/workspace
export PACKAGES_PATH=$PWD/edk2:$PWD
mkdir -v -p "$WORKSPACE/Conf"

pushd edk2
. edksetup.sh $*
popd

return 0

```

`wsetup.cmd`:

```cmd
@echo off
pushd %~dp0

set PYTHON_COMMAND=python.exe

if not exist edk2\edksetup.bat (
    echo git submodules not updated in ROOT. Run: "git submodule update --init" in ROOT and in ROOT\edk2.
    goto :exit
)

if not exist edk2\BaseTools\Source\C\BrotliCompress\brotli\c\common\constants.h (
    echo git submodules not updated in EDK2. Run: "git submodule update --init" in ROOT\edk2.
    goto :exit
)

set WORKSPACE=%CD%\workspace
set PACKAGES_PATH=%CD%\edk2;%CD%
if not exist %WORKSPACE%\Conf mkdir %WORKSPACE%\Conf

if defined NASM_PREFIX (
    if not exist "%NASM_PREFIX%nasm.exe" (
        echo "NASM_PREFIX\nasm.exe" not found, unsetting NASM_PREFIX.
        set NASM_PREFIX=
    )
)

if defined IASL_PREFIX (
    if not exist "%IASL_PREFIX%iasl.exe" (
        echo "IASL_PREFIX\iasl.exe" not found, unsetting IASL_PREFIX.
        set IASL_PREFIX=
    )
)

if not defined NASM_PREFIX (
    if exist %CD%\edk2\BaseTools\Bin\Win32\nasm.exe (
        echo "%CD%\edk2\BaseTools\Bin\Win32\nasm.exe" found, setting NASM_PREFIX.
        set NASM_PREFIX=%CD%\edk2\BaseTools\Bin\Win32\
    )
)

if not defined IASL_PREFIX (
    if exist %CD%\edk2\BaseTools\Bin\Win32\iasl.exe (
        echo "%CD%\edk2\BaseTools\Bin\Win32\iasl.exe" found, setting IASL_PREFIX.
        set IASL_PREFIX=%CD%\edk2\BaseTools\Bin\Win32\
    )
)

call edk2\edksetup.bat %*

if not exist %EDK_TOOLS_BIN% (
    echo Tools not found. Run "%0 rebuild" to build them.
)

if not exist "%NASM_PREFIX%nasm.exe" (
    echo.
    echo NASM not found. Set NASM_PREFIX or use get-nasm.cmd to download a
    echo copy to .\BaseTools\Bin\Win32.
)

if not exist "%IASL_PREFIX%iasl.exe" (
    echo.
    echo IASL not found. Set IASL_PREFIX or use get-iasl.cmd to download a
    echo copy to .\edk2\BaseTools\Bin\Win32.
)

title EDK2-OffCD %CD%

:exit
popd

```