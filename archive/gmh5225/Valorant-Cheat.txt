Project Path: arc_gmh5225_Valorant-Cheat_j230117n

Source Tree:

```txt
arc_gmh5225_Valorant-Cheat_j230117n
├── Base.cpp
├── Color.h
├── Draw.h
├── Font.cpp
├── Font.h
├── MainHide.h
├── Menu.h
├── README.md
├── Structur.h
├── ValoAgentPublic.vcxproj
├── ValoAgentPublic.vcxproj.filters
├── ValoAgentPublic.vcxproj.user
├── defs.h
├── stdafx.h
└── xorstr.h

```

`Base.cpp`:

```cpp
//=============================================//
#include <stdio.h>
#include <Windows.h>
#include <DbgHelp.h>
#include <dwmapi.h>
#pragma comment(lib, "dwmapi")


#include "xorstr.h"
#include "defs.h"
#include "Menu.h"
#include "Color.h"

#define D3DparamX		, UINT paramx
#define D3DparamvalX	, paramx
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

cFun Fun;
bool Create=true;

auto WINAPI DllMain(const HINSTANCE instance, const DWORD reason, LPVOID reserved) -> bool
{
    //DisableThreadLibraryCalls(hModule);
    if (reason == DLL_PROCESS_ATTACH) {
        if (instance)
            DisableThreadLibraryCalls(instance);
       // AllocConsole();   
       // freopen(xorstr_("CONOUT$"), xorstr_("w"), stdout);
        UWorld = ReadWorld();
        
        /*ULevel = read<uintptr_t>(UWorld + Offsets::oLevel);//page guard

        GameInstance = read<uintptr_t>(UWorld + Offsets::oGameInstance);
        LocalPlayer = read<uintptr_t>(read<uintptr_t>(GameInstance + Offsets::oLocalPlayers));
        PlayerController = read<uintptr_t>(LocalPlayer + Offsets::oPlayerController);

        CameraCache = read<uint64_t>(PlayerController + Offsets::oCameraManager);
        AcknowledgedPawn = read<uintptr_t>(PlayerController + Offsets::oLocalPawn);
        uintptr_t DmgHandlerLocal = read<uintptr_t>(AcknowledgedPawn + Offsets::DamageHandler);
        LocalPlayerState = read<uintptr_t>(AcknowledgedPawn + Offsets::PlayerState);
        auto ActorArray = read<uintptr_t>(ULevel + 0xA0);

        printf("UWorld %p\n", UWorld);
        printf("ULevel %p\n", ULevel);
        printf("GameInstance %p\n", GameInstance);
        printf("LocalPlayer %p\n", LocalPlayer);
        printf("PlayerController %p\n", PlayerController);
        printf("CameraCache %p\n", CameraCache);
        printf("AcknowledgedPawn %p\n", AcknowledgedPawn);
        printf("ActorArray %p\n", ActorArray);
        printf("DmgHandlerLocal %p\n", DmgHandlerLocal);
        printf("LocalPlayerState %p\n", LocalPlayerStat);*/
        SetupDX();
    }
    return 1;
}

```

`Color.h`:

```h

#define WHITE			D3DCOLOR_ARGB(255, 255, 255, 255)//
#define RED				D3DCOLOR_ARGB(255, 255, 000, 000)//
#define GREEN			D3DCOLOR_ARGB(255, 000, 255, 000)//
#define BLUE			D3DCOLOR_ARGB(255, 000, 000, 255)//
#define BLACK			D3DCOLOR_ARGB(200, 000, 000, 000)//
#define PURPLE			D3DCOLOR_ARGB(255, 125, 000, 255)//
#define GREY			D3DCOLOR_ARGB(255, 44,44, 46)    //
#define YELLOW			D3DCOLOR_ARGB(255, 255, 255, 000)//
#define ORANGE          D3DCOLOR_ARGB(255, 255, 165, 000)//
#define DEEPSKYBLUE     D3DCOLOR_ARGB(255, 30, 144, 255) //
#define CHOCOLATE2      D3DCOLOR_ARGB(255, 238, 118, 33) //
#define GOLD2			D3DCOLOR_ARGB(255, 238, 201, 0)  //
#define SQUA			D3DCOLOR_ARGB(255, 0, 255, 255)  //
#define DARKGREY        D3DCOLOR_ARGB(255,60,60,60)      //
#define Functions       D3DCOLOR_ARGB(79,101,101,101)//
#define MenuGreen       D3DCOLOR_ARGB(255,43,119,64) //
#define MenuGREY        D3DCOLOR_ARGB(255,30,30,30)  //
#define FUCK_ON			D3DCOLOR_ARGB(254,14,159,47) //
#define FUCK_OFF		D3DCOLOR_ARGB(254,62,120,167)//
///////////////////////////////////////////////////////
#define TxtON           D3DCOLOR_ARGB(255, 000, 000, 000)
#define TxtOFF          D3DCOLOR_ARGB(120, 000, 000, 000)
#define GreenButton     D3DCOLOR_ARGB(255, 7,165, 15)
#define BorderWhite		D3DCOLOR_ARGB(255, 120,120, 120)
#define GREEN_1			D3DCOLOR_ARGB(255, 73,118,69)
#define REDD			D3DCOLOR_ARGB(255, 216,0,0)
#define DARK            D3DCOLOR_ARGB(221, 31, 31, 31)
#define DARK_Menu       D3DCOLOR_ARGB(231, 31, 31, 31)
#define Silver_Menu       D3DCOLOR_ARGB(255, 201, 201, 201)
```

`Draw.h`:

```h
#include "Font.h"
#include "Color.h"
#include "Structur.h"
#include <time.h>
int H_m,w,h;
FILE *LOG;
int WHID=161;
D3DCOLOR text;
LPD3DXFONT pFont;
int  BTEX,BDIR;
CD3DFont *font;
char*	fps[5];
char dllpath[255];
char logfile[255];
char*	TIME(void);
int Ch,Ch1,Ch2,Ch3,Ch4,Ch5;
//=============================================//
void  PostReset(LPDIRECT3DDEVICE9 pDevice)
{
font = new CD3DFont("Arial", 8);
font->InitDeviceObjects(pDevice);
font->RestoreDeviceObjects();	
}
//=============================================//
void  PreReset(void)
{
font->InvalidateDeviceObjects();
font->DeleteDeviceObjects();
delete font;
font = NULL;
}
//=============================================//
char* FPS(void)
{

static int	 FPScounter = 0;
static float FPSfLastTickCount = 0.0f;
static float FPSfCurrentTickCount;
static char  cfps[6] = "";

FPSfCurrentTickCount = clock() * 0.001f;
FPScounter++;
if((FPSfCurrentTickCount - FPSfLastTickCount) > 1.0f)
{
   FPSfLastTickCount = FPSfCurrentTickCount;
   sprintf(cfps,"[%d]",FPScounter);
   FPScounter = 0;
}
return cfps;
}
//=============================================//
void  DrawBox( int x, int y, int w, int h, D3DCOLOR Color, LPDIRECT3DDEVICE9 pDevice)
{
	 struct Vertex 
{
 float x,y,z,ht;
 DWORD Color;
}
V[4] ={{x,y+h, 0.0f, 0.0f, Color}, {x,y, 0.0f, 0.0f, Color},{x+w,y+h, 0.0f, 0.0f, Color},{x+w,y, 0.0f, 0.0f, Color}};
 pDevice->SetTexture(0, NULL);
 pDevice->SetPixelShader( 0 );
 pDevice->SetFVF(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
 pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,true);
 pDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);
 pDevice->SetRenderState(D3DRS_ZENABLE , FALSE);
 pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
 pDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,V,sizeof(Vertex));
 return;
}
/*void DrawBox(int x, int y, int w, int h, D3DCOLOR color, LPDIRECT3DDEVICE9 pDevice)
{
	D3DRECT rec = { x, y, x + w, y + h };
	pDevice->Clear(1, &rec, D3DCLEAR_TARGET, color, 0, 0);
}*/
//=============================================//
void  DrawBorder(int x, int y, int w, int h, D3DCOLOR Color,IDirect3DDevice9* pDevice)
{
	DrawBox(x,  y, 1,  h,Color,pDevice);
	DrawBox(x,y+h, w,  1,Color,pDevice);
	DrawBox(x,  y, w,  1,Color,pDevice);
	DrawBox(x+w,y, 1,h+1,Color,pDevice);
}

/*void DrawBorder(int x, int y, int w, int h, int px, D3DCOLOR BorderColor, IDirect3DDevice9* pDevice)
{
	DrawRect(x, (y + h - px), w, px, BorderColor, pDevice);
	DrawRect(x, y, px, h, BorderColor, pDevice);
	DrawRect(x, y, w, px, BorderColor, pDevice);
	DrawRect((x + w - px), y, px, h, BorderColor, pDevice);
}*/
//=============================================//
void Draw_Text(int x,int y,DWORD color,LPSTR text, const char *fmt)
{
	RECT rect, rect2;
	SetRect( &rect, x, y, x, y );
	SetRect( &rect2, x - 0.1, y + 0.2, x - 0.1, y + 0. );
	pFont->DrawTextA(NULL,text,-1,&rect2, DT_LEFT|DT_NOCLIP, 0x00000000 );
	pFont->DrawTextA(NULL,text,-1,&rect, DT_LEFT|DT_NOCLIP, color );
}
//=============================================//
BOOL IsInBox(int x,int y,int w,int h)
{
	POINT MousePosition; 
	GetCursorPos(&MousePosition); 
	ScreenToClient(GetForegroundWindow(),&MousePosition);
	return(MousePosition.x >= x && MousePosition.x <= x + w && MousePosition.y >= y && MousePosition.y <= y + h);
}
//=============================================//
void  Draw_Menu(int w, int h, char *Text, IDirect3DDevice9* pDevice)
{
    DrawBox(X+130,Y+26,184,20, Silver_Menu,pDevice);//üst
	DrawBox(X+132,Y+48,180,h,DARK_Menu,pDevice);
	DrawBorder(X+130,Y+26,184,20,BorderWhite,pDevice);
	DrawBorder(X+132,Y+48,180,h,BorderWhite,pDevice);
	font->DrawTextX(X+190,Y+30, BLACK,Text,DT_LEFT);
}
//=============================================//
void DrawBorderMenu(int x, int y, int w, int h, D3DCOLOR Color,IDirect3DDevice9* pDevice)
{
if(Ch3!=20){Ch3++;}
DrawBorder(x-2 ,y, w+1, Ch3 , BorderWhite	 , pDevice);
DrawBorder(x-2 ,y+20, w+1, Ch3 , BorderWhite	 , pDevice);
/*DrawBorder(x-2 ,y+40, w+1, Ch3 , BorderWhite	 , pDevice);
DrawBorder(x-2 ,y+60, w+1, Ch3 , BorderWhite	 , pDevice);
DrawBorder(x-2 ,y+80, w+1, Ch3 , BorderWhite	 , pDevice);
DrawBorder(x-2 ,y+100, w+1, Ch3 , BorderWhite	 , pDevice);
DrawBorder(x-2 ,y+120, w+1, Ch3 , BorderWhite	 , pDevice);*/
}
//=============================================//
void  Draw_Menu_1(int w, int h,char *Text,  LPDIRECT3DDEVICE9 pDevice)
{
if(Ch2!=40){Ch2++;}
DrawBox(X+6,Y+26, 105+w,20, Silver_Menu, pDevice);//üst
DrawBox(X+9,Y+48, 100+w,Ch2,DARK, pDevice);
DrawBorder(X+6,Y+26,105+w,20,BorderWhite,pDevice);
font->DrawTextX(X+28,Y+30,BLACK,Text,DT_LEFT);
//RtlSecureZeroMemory(Text, sizeof(Text));

}
void XVPVQW_Menu(int x, int ye, int w, int h, char* Button_Text, int& Var, LPDIRECT3DDEVICE9 pDevice)
{
	int y = Y + ye;
	if (IsInBox(x, y, w, h)) {
		if (GetAsyncKeyState(VK_LBUTTON) & 1)
		{
			if (Var == 1 && Var != 0)
			{
				Var = 0;
			}
			else if (Var == 0)
			{
				if (Var == 0)
				{
					Fun.Menu1 = Fun.Menu2 = 0; Var = 1;
				}
			}
		}
	}
	if (Var == 0) {
		font->DrawTextX(X + 15, y + 3, WHITE, Button_Text, DT_LEFT);
	}
	if (Var == 1) {
		DrawBox(X + 10, y + 1, w, 20, DARKGREY, pDevice);
		font->DrawTextX(X + 15, y + 3, WHITE, Button_Text, DT_LEFT);
	}
	//RtlSecureZeroMemory(Button_Text, sizeof(Button_Text));
}
//=============================================//
void XVPVQW(int x, int y, int w, int h, int& Var, const char* Button_Text, LPDIRECT3DDEVICE9 pDevice)
{
	int y_ = (y)+(h / 2) - 7;
	int x_ = x + w + 2;
	if (IsInBox(x, y - 5, w + 161, h))
	{
		DrawBox(x, y, w, h, GreenButton, pDevice);
		DrawBox(x + 15, y - 2, w + 141, h + 3, Functions, pDevice);
		if (GetAsyncKeyState(VK_LBUTTON) & 1)
		{
			DrawBorder(x - 1, y - 1, w, h, GREEN, pDevice);
			if (Var == 1 && Var != 0) { Var = 0; }
			else
				if (Var == 0) { Var = 1; }
		}
	}
	if (Var == 0) {
		DrawBox(x, y, w, h, TxtOFF, pDevice);
		font->DrawTextX(x_, y_, WHITE, Button_Text, DT_LEFT);
		DrawBorder(x - 1, y - 1, w, h, DARKGREY, pDevice);
	}
	if (Var == 1) {
		DrawBox(x + 1, y + 1, w - 3, h - 3, MenuGreen, pDevice);
		font->DrawTextX(x_, y_, WHITE, Button_Text, DT_LEFT);
		DrawBorder(x - 1, y - 1, w, h, DARKGREY, pDevice);
	}

	//RtlSecureZeroMemory(Button_Text, sizeof(Button_Text));
}
//=============================================//
void Draw_Chams(int x, int ye, char* Text, int& Var, DWORD CoLoR1, DWORD CoLoR2, DWORD CoLoR3, DWORD CoLoR4, LPDIRECT3DDEVICE9 pDevice)
{
	int y = Y + ye;
	DWORD CoL;
	DWORD R_COL = DARKGREY;
	if (IsInBox(X + 115, y, WHID - 9, 15))
	{
		R_COL = WHITE; DrawBox(x + 40, y, 140, 16, Functions, pDevice);
		if (lm1)
		{
			if (Var >= 0) { Var++; }
		}
		if (rm1)
		{
			if (Var != 0) { Var--; }
		}
	}
	switch (Var)
	{
	case 1: CoL = CoLoR1;      break;
	case 2: CoL = CoLoR2;      break;
	case 3: CoL = CoLoR3;      break;
	case 4: CoL = CoLoR4;      break;
	case 5:                Var = 0;    break;
	}
	if (Var > 0)
	{
		DrawBox(x + 12, y + 2, 22, 12, CoL, pDevice);
	}
	font->DrawTextX(x + 35, y, WHITE, Text, DT_LEFT);
	DrawBorder(x + 10, y, 25, 15, R_COL, pDevice);
}

//=============================================//
void Scrol(int x, int y, int& Var, char** typ, int max, char* text, LPDIRECT3DDEVICE9 pDevice) {
	DrawBox(x - 1, y, 12, 12, DARKGREY, pDevice);
	DrawBorder(x - 1, y, 12, 12, DARKGREY, pDevice);
	font->DrawTextX(x + 6, y - 1, WHITE, "<", DT_CENTER);
	DrawBox(x + 73, y, 12, 12, DARKGREY, pDevice);
	DrawBorder(x + 73, y, 12, 12, DARKGREY, pDevice);
	font->DrawTextX(x + 80, y - 1, WHITE, ">", DT_CENTER);

	if (IsInBox(x, y - 4, 12, 12)) {
		DrawBorder(x - 1, y - 1, 12, 12, MenuGreen, pDevice);
		if (GetAsyncKeyState(VK_LBUTTON)) {
			if (Var != 0) {
				Var--;
				Sleep(100);
			}
		}
	}
	if (IsInBox(x + 73, y - 4, 12, 12)) {
		DrawBorder(x + 73, y - 1, 12, 12, MenuGreen, pDevice);
		if (GetAsyncKeyState(VK_LBUTTON)) {
			if (Var >= 0 && Var < max) {
				Var++;
				Sleep(100);
			}
		}
	}
	font->DrawTextX(x + 18, y - 1, ORANGE, typ[Var], DT_SHADOW);
	font->DrawTextX(x + 84, y - 1, FUCK_ON, text, DT_SHADOW);

	//RtlSecureZeroMemory(text, sizeof(text));
}
LPD3DXLINE S_Line;
void DrawLine(LONG Xa, LONG Ya, LONG Xb, LONG Yb, DWORD dwWidth, D3DCOLOR Color)
{
	D3DXVECTOR2 vLine[2];
	S_Line->SetAntialias(0);

	S_Line->SetWidth(dwWidth);
	S_Line->Begin();

	vLine[0][0] = Xa;
	vLine[0][1] = Ya;
	vLine[1][0] = Xb;
	vLine[1][1] = Yb;

	S_Line->Draw(vLine, 2, Color);
	S_Line->End();
}






```

`Font.cpp`:

```cpp

#define STRICT
#include <stdio.h>
#include <tchar.h>
#include <d3dx9.h>
#include "Font.h"

#define MAX_NUM_VERTICES 50*6

struct FONT2DVERTEX { D3DXVECTOR4 p;   DWORD color;     FLOAT tu, tv; };
struct FONT3DVERTEX { D3DXVECTOR3 p;   D3DXVECTOR3 n;   FLOAT tu, tv; };

#define D3DFVF_FONT2DVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define D3DFVF_FONT3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

inline FONT2DVERTEX InitFont2DVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                      FLOAT tu, FLOAT tv )
{
    FONT2DVERTEX v;   v.p = p;   v.color = color;   v.tu = tu;   v.tv = tv;
    return v;
}

inline FONT3DVERTEX InitFont3DVertex( const D3DXVECTOR3& p, const D3DXVECTOR3& n,
                                      FLOAT tu, FLOAT tv )
{
    FONT3DVERTEX v;   v.p = p;   v.n = n;   v.tu = tu;   v.tv = tv;
    return v;
}

CD3DFont::CD3DFont( const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags )
{
    _tcsncpy( m_strFontName, strFontName, sizeof(m_strFontName) / sizeof(TCHAR) );
    m_strFontName[sizeof(m_strFontName) / sizeof(TCHAR) - 1] = _T('\0');
    m_dwFontHeight         = dwHeight;
    m_dwFontFlags          = dwFlags;

    m_pd3dDevice           = NULL;
    m_pTexture             = NULL;
    m_pVB                  = NULL;

    m_pStateBlockSaved     = NULL;
    m_pStateBlockDrawTextX  = NULL;
}


CD3DFont::~CD3DFont()
{
    InvalidateDeviceObjects();
    DeleteDeviceObjects();
}

HRESULT CD3DFont::InitDeviceObjects( LPDIRECT3DDEVICE9 pd3dDevice )
{
    HRESULT hr;
    m_pd3dDevice = pd3dDevice;
    m_fTextScale  = 1.0f; // Draw fonts into texture without scaling
    if( m_dwFontHeight > 40 )
        m_dwTexWidth = m_dwTexHeight = 1024;
    else if( m_dwFontHeight > 20 )
        m_dwTexWidth = m_dwTexHeight = 512;
    else
        m_dwTexWidth  = m_dwTexHeight = 256;

    // If requested texture is too big, use a smaller texture and smaller font,
    // and scale up when rendering.
    D3DCAPS9 d3dCaps;
    m_pd3dDevice->GetDeviceCaps( &d3dCaps );

    if( m_dwTexWidth > d3dCaps.MaxTextureWidth )
    {
        m_fTextScale = (FLOAT)d3dCaps.MaxTextureWidth / (FLOAT)m_dwTexWidth;
        m_dwTexWidth = m_dwTexHeight = d3dCaps.MaxTextureWidth;
    }

    // Create a new texture for the font
    hr = m_pd3dDevice->CreateTexture( m_dwTexWidth, m_dwTexHeight, 1,
                                      0, D3DFMT_A4R4G4B4,
                                      D3DPOOL_MANAGED, &m_pTexture, 0 );
    if( FAILED(hr) )
        return hr;

    // Prepare to create a bitmap
    DWORD*      pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader,  sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)m_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)m_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a DC and a bitmap for the font
    HDC     hDC       = CreateCompatibleDC( NULL );
    HBITMAP hbmBitmap = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS,(void**)&pBitmapBits, NULL, 0 );
    SetMapMode( hDC, MM_TEXT );

    INT nHeight    = -MulDiv( m_dwFontHeight, (INT)(GetDeviceCaps(hDC, LOGPIXELSY) * m_fTextScale), 72 );
    DWORD dwBold   = (m_dwFontFlags&D3DFONT_BOLD)   ? FW_EXTRABOLD : FW_EXTRABOLD;
    DWORD dwItalic = (m_dwFontFlags&D3DFONT_ITALIC) ? TRUE    : FALSE;
    HFONT hFont    = CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                          VARIABLE_PITCH, m_strFontName );
    if( NULL==hFont )
        return E_FAIL;

    HGDIOBJ hPrevBitmap = SelectObject( hDC, hbmBitmap );
    HGDIOBJ hPrevFont = SelectObject( hDC, hFont );
    SetTextColor( hDC, RGB(255,255,255) );
    SetBkColor(   hDC, 0x00000000 );
    SetTextAlign( hDC, TA_TOP );
    DWORD x = 0;
    DWORD y = 0;
    char str[2] = "x";
    SIZE size;

    for( int c=32; c <= MAX_CHAR_INDEX; c++ )
    {
        str[0] = c;
        GetTextExtentPoint32A( hDC, str, 1, &size );

        if( (DWORD)(x+size.cx+1) > m_dwTexWidth )
        {
            x  = 0;
            y += size.cy+1;
        }

        ExtTextOutA( hDC, x+0, y+0, ETO_OPAQUE, NULL, str, 1, NULL );

        m_fTexCoords[c-32][0] = ((FLOAT)(x+0))/m_dwTexWidth;
        m_fTexCoords[c-32][1] = ((FLOAT)(y+0))/m_dwTexHeight;
        m_fTexCoords[c-32][2] = ((FLOAT)(x+0+size.cx))/m_dwTexWidth;
        m_fTexCoords[c-32][3] = ((FLOAT)(y+0+size.cy))/m_dwTexHeight;

        x += size.cx+1;
    }

    // Lock the surface and write the alpha values for the set pixels
    D3DLOCKED_RECT d3dlr;
    m_pTexture->LockRect( 0, &d3dlr, 0, 0 );
    BYTE* pDstRow = (BYTE*)d3dlr.pBits;
    WORD* pDst16;
    BYTE bAlpha; // 4-bit measure of pixel intensity

    for( y=0; y < m_dwTexHeight; y++ )
    {
        pDst16 = (WORD*)pDstRow;
        for( x=0; x < m_dwTexWidth; x++ )
        {
            bAlpha = (BYTE)((pBitmapBits[m_dwTexWidth*y + x] & 0xff) >> 4);
            if (bAlpha > 0)
            {
                *pDst16++ = (bAlpha << 12) | 0x0fff;
            }
            else
            {
                *pDst16++ = 0x0000;
            }
        }
        pDstRow += d3dlr.Pitch;
    }
    m_pTexture->UnlockRect(0);

    //Необходимо установить первоначальные объекты перед удалением
    SelectObject( hDC, hPrevBitmap );
    SelectObject( hDC, hPrevFont );

    DeleteObject( hbmBitmap );
    DeleteDC( hDC );
    DeleteObject( hFont );

    return S_OK;
}


HRESULT CD3DFont::RestoreDeviceObjects()
{
    HRESULT hr;

    int vertexSize = max( sizeof(FONT2DVERTEX), sizeof(FONT3DVERTEX ) );
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( MAX_NUM_VERTICES * vertexSize,
                                                       D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0,
                                                       D3DPOOL_DEFAULT, &m_pVB, 0 ) ) )
    {
        return hr;
    }

    // Create the state blocks for rendering text
    for( UINT which=0; which<2; which++ )
    {
        m_pd3dDevice->BeginStateBlock();
        m_pd3dDevice->SetTexture( 0, m_pTexture );

        if ( D3DFONT_ZENABLE & m_dwFontFlags )
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        else
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,  D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,   D3DFILL_SOLID );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_CCW );
        m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPING,         TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPLANEENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_VERTEXBLEND,      D3DVBF_DISABLE );
        m_pd3dDevice->SetRenderState( D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE,
            D3DCOLORWRITEENABLE_RED  | D3DCOLORWRITEENABLE_GREEN |
            D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_NONE );

        if( which==0 )
            m_pd3dDevice->EndStateBlock( &m_pStateBlockSaved );
        else
            m_pd3dDevice->EndStateBlock( &m_pStateBlockDrawTextX );
    }

    return S_OK;
}

HRESULT CD3DFont::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pVB );
    SAFE_RELEASE( m_pStateBlockSaved );
    SAFE_RELEASE( m_pStateBlockDrawTextX );

    return S_OK;
}


HRESULT CD3DFont::DeleteDeviceObjects()
{
    SAFE_RELEASE( m_pTexture );
    m_pd3dDevice = NULL;

    return S_OK;
}

HRESULT CD3DFont::GetTextExtent( const char* strText, SIZE* pSize )
{
    if( NULL==strText || NULL==pSize )
        return E_FAIL;

    FLOAT fRowWidth  = 0.0f;
    FLOAT fRowHeight = (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
    FLOAT fWidth     = 0.0f;
    FLOAT fHeight    = fRowHeight;

    while( *strText )
    {
        unsigned char c = *strText++;

        if( c == '\n' )
        {
            fRowWidth = 0.0f;
            fHeight  += fRowHeight;
        }

        if( CheckChar(c) )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT tx2 = m_fTexCoords[c-32][2];

        fRowWidth += (tx2-tx1)*m_dwTexWidth;

        if( fRowWidth > fWidth )
            fWidth = fRowWidth;
    }

    pSize->cx = (int)fWidth;
    pSize->cy = (int)fHeight;

    return S_OK;
}


HRESULT CD3DFont::DrawTextXScaled( FLOAT x, FLOAT y, FLOAT z,
                                  FLOAT fXScale, FLOAT fYScale, DWORD dwColor,
                                  const char* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawTextX->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT2DVERTEX) );
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }
	   if( dwFlags & DT_RIGHT )
   { 
   SIZE sz;
   GetTextExtent( strText, &sz ); x -= (FLOAT)sz.cx;
   }
   if( dwFlags & DT_CENTER )
   { 
   SIZE sz; 
   GetTextExtent( strText, &sz ); x -= (FLOAT)(sz.cx / 2.0); 
   } 
    D3DVIEWPORT9 vp;
    m_pd3dDevice->GetViewport( &vp );
    FLOAT sx  = (x+1.0f)*vp.Width/2;
    FLOAT sy  = (y-1.0f)*vp.Height/2;
    FLOAT sz  = z;
    FLOAT rhw = 1.0f;
    FLOAT fStartX = sx;
    FLOAT fLineHeight = ( m_fTexCoords[0][3] - m_fTexCoords[0][1] ) * m_dwTexHeight;
    FONT2DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        unsigned char c = *strText++;

        if( c == '\n' )
        {
            sx  = fStartX;
            sy += fYScale*vp.Height;
        }

        if( CheckChar(c) )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1)*m_dwTexWidth;
        FLOAT h = (ty2-ty1)*m_dwTexHeight;

        w *= (fXScale*vp.Height)/fLineHeight;
        h *= (fYScale*vp.Height)/fLineHeight;

        if( c != ' ' )
        {
			if( dwFlags & DT_SHADOW ) {
            float sxa,sya;
            sxa = sx;
            sya = sy;
            sxa=sx+1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
              *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );

            sxa=sx-1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );

            sya=sy-1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );

            sya=sy+1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               dwNumTriangles += 8;
         }
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }
        sx += w;
    }
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
    m_pStateBlockSaved->Apply();

    return S_OK;
}

HRESULT CD3DFont::DrawTextX( FLOAT sx, FLOAT sy, DWORD dwColor,
                            const char* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawTextX->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT2DVERTEX) );
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }
	  if( dwFlags & DT_RIGHT )
   { 
   SIZE sz;
   GetTextExtent( strText, &sz ); sx -= (FLOAT)sz.cx;
   }
   if( dwFlags & DT_CENTER )
   { 
   SIZE sz; 
   GetTextExtent( strText, &sz ); sx -= (FLOAT)(sz.cx / 2.0); 
   } 
    FLOAT fStartX = sx;
    FONT2DVERTEX* pVertices = NULL;
    DWORD         dwNumTriangles = 0;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
    while( *strText )
    {
        unsigned char c = *strText++;
        if( c == '\n' )
        {
            sx = fStartX;
            sy += (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
        }
        if( CheckChar(c) )
            continue;
        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
        FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

        if( c != ' ' )
        {
           if( dwFlags & DT_SHADOW ) {
            float sxa,sya;
            sxa = sx;
            sya = sy;
            sxa=sx+1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
              *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );

            sxa=sx-1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+w-0.5f,sy+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sxa+0-0.5f,sy+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );

            sya=sy-1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
            sya=sy+1.0f;
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx1, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx2, ty1 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sya+h-0.5f,0.9f,1.0f), 0xff000000, tx2, ty2 );
               *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sya+0-0.5f,0.9f,1.0f), 0xff000000, tx1, ty1 );
               dwNumTriangles += 8;
         }
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            dwNumTriangles += 2;
            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                pVertices = NULL;
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }
        sx += w;
    }
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
    m_pStateBlockSaved->Apply();

    return S_OK;
}


HRESULT CD3DFont::Render3DText( const char* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawTextX->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT3DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT3DVERTEX) );
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }
    FLOAT x = 0.0f;
    FLOAT y = 0.0f;
    if( dwFlags & D3DFONT_CENTERED )
    {
        SIZE sz;
        GetTextExtent( strText, &sz );
        x = -(((FLOAT)sz.cx)/10.0f)/2.0f;
        y = -(((FLOAT)sz.cy)/10.0f)/2.0f;
    }
    if( dwFlags & D3DFONT_TWOSIDED )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    FLOAT fStartX = x;
    unsigned char c;
    FONT3DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
    while( (c = *strText++) != 0 )
    {
        if( c == '\n' )
        {
            x = fStartX;
            y -= (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight/10.0f;
        }

        if( CheckChar(c) )
            continue;
        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];
        FLOAT w = (tx2-tx1) * m_dwTexWidth  / ( 10.0f * m_fTextScale );
        FLOAT h = (ty2-ty1) * m_dwTexHeight / ( 10.0f * m_fTextScale );

        if( c != ' ' )
        {
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+0,0), D3DXVECTOR3(0,0,-1), tx1, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+h,0), D3DXVECTOR3(0,0,-1), tx2, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }
        x += w;
    }
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
    m_pStateBlockSaved->Apply();

    return S_OK;
}





```

`Font.h`:

```h


#include <tchar.h>
#include <D3DX9.h>


#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

#define D3DFONT_BOLD        0x0001
#define D3DFONT_ITALIC      0x0002
#define D3DFONT_ZENABLE     0x0004
#define D3DFONT_CENTERED    0x0001
#define D3DFONT_TWOSIDED    0x0002
#define D3DFONT_FILTERED    0x0004
#define DT_SHADOW           0x0040      // non standard

class CD3DFont
{
    static const int MAX_CHAR_INDEX = 255;
    TCHAR   m_strFontName[80];            
    DWORD   m_dwFontHeight;
    DWORD   m_dwFontFlags;
    LPDIRECT3DDEVICE9       m_pd3dDevice; // A D3DDevice used for rendering
    LPDIRECT3DTEXTURE9      m_pTexture;   // The d3d texture for this font
    LPDIRECT3DVERTEXBUFFER9 m_pVB;        // VertexBuffer for rendering text
    DWORD   m_dwTexWidth;                 // Texture dimensions
    DWORD   m_dwTexHeight;
    FLOAT   m_fTextScale;
    FLOAT   m_fTexCoords[MAX_CHAR_INDEX + 1 - 32][4];
    LPDIRECT3DSTATEBLOCK9 m_pStateBlockSaved;
    LPDIRECT3DSTATEBLOCK9 m_pStateBlockDrawTextX;

public:
    HRESULT DrawTextX( FLOAT x, FLOAT y, DWORD dwColor, const char* strText, DWORD dwFlags=0L );
    HRESULT DrawTextXScaled( FLOAT x, FLOAT y, FLOAT z, FLOAT fXScale,FLOAT fYScale,DWORD dwColor,const char* strText, DWORD dwFlags=0L );
    HRESULT Render3DText( const char* strText, DWORD dwFlags=0L );
    HRESULT GetTextExtent( const char* strText, SIZE* pSize );
    HRESULT InitDeviceObjects( LPDIRECT3DDEVICE9 pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();
    CD3DFont( const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L );
    ~CD3DFont();

private:
   bool CheckChar( unsigned char c) { return c < 32 || c > MAX_CHAR_INDEX; }
};








```

`MainHide.h`:

```h
void  EraseHeaders(HINSTANCE hModule1)
{

	PIMAGE_DOS_HEADER pDoH; 
	PIMAGE_NT_HEADERS pNtH;
	DWORD i, ersize, protect;

	if (!hModule1) return;

	pDoH = (PIMAGE_DOS_HEADER)(hModule1);

	pNtH = (PIMAGE_NT_HEADERS)((LONG)hModule1 + ((PIMAGE_DOS_HEADER)hModule1)->e_lfanew);

	ersize = sizeof(IMAGE_DOS_HEADER);
	if ( VirtualProtect(pDoH, ersize, PAGE_READWRITE, &protect) )
	{
		for ( i=0; i < ersize; i++ )
				*(BYTE*)((BYTE*)pDoH + i) = 0;
	}

	ersize = sizeof(IMAGE_NT_HEADERS);
	if ( pNtH && VirtualProtect(pNtH, ersize, PAGE_READWRITE, &protect) )
	{
		for ( i=0; i < ersize; i++ )
				*(BYTE*)((BYTE*)pNtH + i) = 0;
	}
	return;
}

typedef struct offsets_ 
{
	std::ptrdiff_t bone_component = 0x548;
	std::ptrdiff_t mesh_component = 0x410;
	std::ptrdiff_t root_component = 0x210;
	std::ptrdiff_t persistent_level = 0x38;
	std::ptrdiff_t owning_game_instance = 0x1a8;
	std::ptrdiff_t player_state = 0x3d0;
	std::ptrdiff_t team_component = 0x580;
	std::ptrdiff_t team = 0xf8;
	std::ptrdiff_t damage_handler = 0x978;
	std::ptrdiff_t cached_life = 0x1b0;
	std::ptrdiff_t relative_location = 0x164;
	std::ptrdiff_t relative_rotation = 0x170;
	std::ptrdiff_t player_controller = 0x38;
	std::ptrdiff_t acknowledged_pawn = 0x440;
	std::ptrdiff_t player_camera_manager = 0x458;
	std::ptrdiff_t camera_cache_private = 0x1f80;
	std::ptrdiff_t control_rotation = 0x420;
}

typedef struct _UNICODE_STRING 
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _ModuleInfoNode
{
	LIST_ENTRY LoadOrder;
	LIST_ENTRY InitOrder;
	LIST_ENTRY MemoryOrder;
	HMODULE baseAddress;
	unsigned long entryPoint;
	unsigned int size;
	UNICODE_STRING fullPath;
	UNICODE_STRING name;
	unsigned long flags;
	unsigned short LoadCount;
	unsigned short TlsIndex;
	LIST_ENTRY HashTable;
	unsigned long timestamp;
} ModuleInfoNode, *pModuleInfoNode;

typedef struct _ProcessModuleInfo
{
	unsigned int size;
	unsigned int initialized;
	HANDLE SsHandle;
	LIST_ENTRY LoadOrder;
	LIST_ENTRY InitOrder;
	LIST_ENTRY MemoryOrder;
} ProcessModuleInfo, *pProcessModuleInfo;

#define UNLINK(x) (x).Blink->Flink = (x).Flink; \
	(x).Flink->Blink = (x).Blink;

int HideModule( HMODULE hMod )
{
	ProcessModuleInfo *pmInfo;
	ModuleInfoNode *module;

	_asm
	{
		mov eax, fs:[18h]
		mov eax, [eax + 30h]
		mov eax, [eax + 0Ch] 
		mov pmInfo, eax
	}

	module = (ModuleInfoNode *)(pmInfo->LoadOrder.Flink);

	while(module->baseAddress && module->baseAddress != hMod){
		module = (ModuleInfoNode *)(module->LoadOrder.Flink);}

	if(!module->baseAddress){
		return 0;}

	UNLINK(module->LoadOrder);
	UNLINK(module->InitOrder);
	UNLINK(module->MemoryOrder);
	UNLINK(module->HashTable);
	memset(module->fullPath.Buffer, 0, module->fullPath.Length);
	memset(module, 0, sizeof(ModuleInfoNode));

	return 1;
}

```

`Menu.h`:

```h
#include "Draw.h"
#include <iostream>

#include <algorithm>
#include <intrin.h>
#include <vector>
#include <string>
using namespace std;


#define j_junk() UsefulFuntion(25415, 75242, 2451, 7897);
inline int UsefulFuntion(int x, int y, int z, int r)
{
    for (int i = 2; i < 8; i++)
    {
        z += 456;
        r -= 55;
        x++;
        y--;

    }
    for (int i = 0; i < 2; i++)
    {
        x++;
        y += 234;
        z -= 23;
        r += 634;
    }
    return x + z + r + y;
}

bool SHOW = true;

LPDIRECT3D9 d3d;    // the pointer to our Direct3D interface
LPDIRECT3DDEVICE9 d3ddev;
int Width = GetSystemMetrics(SM_CXSCREEN);
int Height = GetSystemMetrics(SM_CYSCREEN);
RECT GameRect = { NULL };
HWND GameWnd = NULL;
float ScreenCenterX;
float ScreenCenterY;
HWND MyWnd = NULL;
const MARGINS Margin = { -1 ,-1, -1, -1 };
MSG Message = { NULL };

#define M_PI                       3.14159265358979323846f
#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.

struct FVector
{
    float                                              X;                                                        // 0x0000(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Y;                                                        // 0x0004(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Z;                                                        // 0x0008(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)

    inline FVector()
        : X(0), Y(0), Z(0) {
    }

    inline FVector(float x, float y, float z) : X(x), Y(y), Z(z) {}

    __forceinline FVector operator-(const FVector& V) {
        return FVector(X - V.X, Y - V.Y, Z - V.Z);
    }

    __forceinline FVector operator+(const FVector& V) {
        return FVector(X + V.X, Y + V.Y, Z + V.Z);
    }

    __forceinline FVector operator*(float Scale) const {
        return FVector(X * Scale, Y * Scale, Z * Scale);
    }

    __forceinline FVector operator/(float Scale) const {
        const float RScale = 1.f / Scale;
        return FVector(X * RScale, Y * RScale, Z * RScale);
    }

    __forceinline FVector operator+(float A) const {
        return FVector(X + A, Y + A, Z + A);
    }

    __forceinline FVector operator-(float A) const {
        return FVector(X - A, Y - A, Z - A);
    }

    __forceinline FVector operator*(const FVector& V) const {
        return FVector(X * V.X, Y * V.Y, Z * V.Z);
    }

    __forceinline FVector operator/(const FVector& V) const {
        return FVector(X / V.X, Y / V.Y, Z / V.Z);
    }

    __forceinline float operator|(const FVector& V) const {
        return X * V.X + Y * V.Y + Z * V.Z;
    }

    __forceinline float operator^(const FVector& V) const {
        return X * V.Y - Y * V.X - Z * V.Z;
    }

    __forceinline FVector& operator+=(const FVector& v) {
        X += v.X;
        Y += v.Y;
        Z += v.Z;
        return *this;
    }

    __forceinline FVector& operator-=(const FVector& v) {
        X -= v.X;
        Y -= v.Y;
        Z -= v.Z;
        return *this;
    }

    __forceinline FVector& operator*=(const FVector& v) {
        X *= v.X;
        Y *= v.Y;
        Z *= v.Z;
        return *this;
    }

    __forceinline FVector& operator/=(const FVector& v) {
        X /= v.X;
        Y /= v.Y;
        Z /= v.Z;
        return *this;
    }

    __forceinline bool operator==(const FVector& src) const {
        return (src.X == X) && (src.Y == Y) && (src.Z == Z);
    }

    __forceinline bool operator!=(const FVector& src) const {
        return (src.X != X) || (src.Y != Y) || (src.Z != Z);
    }

    __forceinline float Size() const {
        return sqrt(X * X + Y * Y + Z * Z);
    }

    __forceinline float Distance(const FVector& v)
    {

        return float(sqrtf(powf(v.X - X, 2.0) + powf(v.Y - Y, 2.0) + powf(v.Z - Z, 2.0)));
    }

    __forceinline float Size2D() const {
        return sqrt(X * X + Y * Y);
    }

    __forceinline float SizeSquared() const {
        return X * X + Y * Y + Z * Z;
    }

    __forceinline float SizeSquared2D() const {
        return X * X + Y * Y;
    }

    __forceinline float Dot(const FVector& vOther) const {
        const FVector& a = *this;
        return (a.X * vOther.X + a.Y * vOther.Y + a.Z * vOther.Z);
    }

    __forceinline FVector Normalize() {
        FVector vector;
        float length = this->Size();

        if (length != 0) {
            vector.X = X / length;
            vector.Y = Y / length;
            vector.Z = Z / length;
        }
        else
            vector.X = vector.Y = 0.0f;
        vector.Z = 1.0f;

        return vector;
    }

    __forceinline FVector ToRotator() {
        FVector rotator;
        rotator.X = -(float)atan(Z / Size2D()) * (float)(180.0f / M_PI);
        rotator.Y = (float)atan(Y / X) * (float)(180.0f / M_PI);
        rotator.Z = (float)0.f;
        if (X >= 0.f)
            rotator.Y += 180.0f;
        return rotator;
    }

    __forceinline FVector Clamp()
    {
        FVector clamped;
        while (clamped.Y < -180.0f)
            clamped.Y += 360.0f;
        while (clamped.Y > 180.0f)
            clamped.Y -= 360.0f;

        if (clamped.X < -74.0f)
            clamped.X = -74.0f;
        if (clamped.X > 74.0f)
            clamped.X = 74.0f;
        return clamped;
    }
};

struct color {
    int a, r, g, b;
    color() = default;

    color(const int r, const int g, const int b, const int a = 255) : _color{ } {
        this->r = r;
        this->g = g;
        this->b = b;
        this->a = a;
    }

    explicit color(const uint32_t color) : _color{ } {
        this->a = color >> 24 & 0xff;
        this->r = color >> 16 & 0xff;
        this->g = color >> 8 & 0xff;
        this->b = color & 0xff;
    }

    static color from_uint(const uint32_t uint) {
        return color(uint);
    }

    unsigned char& operator[ ](const int index) {
        return _color[index];
    }

    template <typename T>
    color hsv_to_rgb(T h, T s, T v, const float alpha) const {
        int _r, _g, _b;

        if (s != 0) {

            h == 360 ? h = 0 : h = h / 60;
            auto i = static_cast<int>(trunc(h));
            int f = h - i;

            const int p = v * (1 - s);
            const int q = v * (1 - s * f);
            const int t = v * (1 - s * (1 - f));

            switch (i) {
            case 0:
                _r = v;
                _g = t;
                _b = p;
                break;

            case 1:
                _r = q;
                _g = v;
                _b = p;
                break;

            case 2:
                _r = p;
                _g = v;
                _b = t;
                break;

            case 3:
                _r = p;
                _g = q;
                _b = v;
                break;

            case 4:
                _r = t;
                _g = p;
                _b = v;
                break;

            default:
                _r = v;
                _g = p;
                _b = q;
                break;
            }
        }
        else {
            _r = v;
            _g = v;
            _b = v;
        }

        return color(static_cast<uint8_t>(_r * 255), static_cast<uint8_t>(_g * 255),
            static_cast<uint8_t>(_b * 255), alpha);
    }

    unsigned char _color[4];
};

void DrawBorder(int x, int y, int w, int h, int px, D3DCOLOR BorderColor, IDirect3DDevice9* pDevice)
{

    DrawBox(x, (y + h - px), w, px, BorderColor, pDevice);
    DrawBox(x, y, px, h, BorderColor, pDevice);
    DrawBox(x, y, w, px, BorderColor, pDevice);
    DrawBox((x + w - px), y, px, h, BorderColor, pDevice);

}

void DrawESPBox(FVector Head, FVector Foot, DWORD dwColor, int rectAlpha, LPDIRECT3DDEVICE9 pDevice)
{
    FVector Box = Head - Foot;

    if (Box.Y < 0)
        Box.Y *= -1;

    int BoxWidth = (int)Box.Y / 2;
    int BoxHeight = (int)Box.Y / 2;
    int DrawX = (int)Head.X - (BoxWidth / 2);
    int DrawY = (int)Head.Y;

    DrawBorder(DrawX, DrawY, BoxWidth, (int)Box.Y, 1, dwColor, pDevice);
}

template <typename T>
T read(uintptr_t address)
{
    T buffer{ };
    ReadProcessMemory(GetCurrentProcess(), (LPVOID)address, &buffer, sizeof(T), 0);
    return buffer;
}

template<typename T>
bool write(uintptr_t address, T* buffer, SIZE_T sizeh)
{
    if (address > 0x7FFFFFFFFFFF || address < 1) return 0;
    WriteProcessMemory(GetCurrentProcess(), (LPVOID)address, buffer, sizeh, 0);
}

__forceinline __int64 decrypt_uworld(const uint32_t key, const uintptr_t* state)
{
    unsigned __int64 v19; // r11
    unsigned __int64 v20; // r8
    unsigned __int64 v21; // r9
    unsigned int v22; // er10
    unsigned __int64 v23; // rcx
    unsigned __int64 v24; // rdx
    unsigned __int64 v25; // rcx
    int v26; // ebx
    unsigned int v27; // ecx
    __int64 v28; // rax
    unsigned __int64 v29; // r8
    unsigned __int64 v30; // r8
    unsigned __int64 v31; // rcx
    unsigned __int64 v32; // rdx
    unsigned __int64 v33; // rcx

    v19 = 2685821657736338717i64 * ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12)) % 7 % 7;
    v20 = state[v19];
    v21 = (2685821657736338717i64 * ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
    v22 = (unsigned int)v19;
    if (!v19)
    {
        v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20 - (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
        v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
        v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
        v20 = rol8((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
    LABEL_26:
        v26 = 2 * v19;
        goto LABEL_27;
    }
    if (v22 != 1)
        goto LABEL_26;
    v26 = 2 * v19;
    v20 = rol8(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
LABEL_27:
    v27 = v26 + v21;
    if (v22 == 2)
        v20 = ~(v20 - v27);
    switch (v22)
    {
    case 3u:
        v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
        v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
        break;
    case 4u:
        v29 = ror8(v20, (unsigned __int8)(v27 % 0x3F) + 1);
        v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
        break;
    case 5u:
        v30 = ror8(v20, (unsigned __int8)(v27 % 0x3F) + 1);
        v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
        v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
        v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
        v20 = rol8((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
        break;
    case 6u:
        v20 = ~v20 - (unsigned int)(v21 + v19);
        break;
    }
    return v20 ^ (unsigned int)key;
}

uint64_t valBase = (uintptr_t)GetModuleHandleA(0);

uint64_t UWorld = 0;

uint64_t ReadWorld()
{
    uint64_t key = read<uint64_t>(valBase + 0x75CF2B8);
#pragma pack(push, 1)
    struct State
    {
        uint64_t Keys[7];
    };
#pragma pack(pop)
    const auto state = read<State>(valBase + 0x75CF280);

    return read<uint64_t>(decrypt_uworld(key, (uint64_t*)&state));
}

struct alignas(16) FQuat
{
    float                                              X;                                                        // 0x0000(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Y;                                                        // 0x0004(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Z;                                                        // 0x0008(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              W;                                                        // 0x000C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
};

struct alignas(16) FPlane : public FVector
{
    float                                              W;                                                        // 0x000C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
};

struct FMatrix
{
    struct FPlane                                      XPlane;                                                   // 0x0000(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      YPlane;                                                   // 0x0010(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      ZPlane;                                                   // 0x0020(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      WPlane;                                                   // 0x0030(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)

    FMatrix operator*(const FMatrix& pM2)
    {
        FMatrix pOut;
        pOut.XPlane.X = XPlane.X * pM2.XPlane.X + XPlane.Y * pM2.YPlane.X + XPlane.Z * pM2.ZPlane.X + XPlane.W * pM2.WPlane.X;
        pOut.XPlane.Y = XPlane.X * pM2.XPlane.Y + XPlane.Y * pM2.YPlane.Y + XPlane.Z * pM2.ZPlane.Y + XPlane.W * pM2.WPlane.Y;
        pOut.XPlane.Z = XPlane.X * pM2.XPlane.Z + XPlane.Y * pM2.YPlane.Z + XPlane.Z * pM2.ZPlane.Z + XPlane.W * pM2.WPlane.Z;
        pOut.XPlane.W = XPlane.X * pM2.XPlane.W + XPlane.Y * pM2.YPlane.W + XPlane.Z * pM2.ZPlane.W + XPlane.W * pM2.WPlane.W;
        pOut.YPlane.X = YPlane.X * pM2.XPlane.X + YPlane.Y * pM2.YPlane.X + YPlane.Z * pM2.ZPlane.X + YPlane.W * pM2.WPlane.X;
        pOut.YPlane.Y = YPlane.X * pM2.XPlane.Y + YPlane.Y * pM2.YPlane.Y + YPlane.Z * pM2.ZPlane.Y + YPlane.W * pM2.WPlane.Y;
        pOut.YPlane.Z = YPlane.X * pM2.XPlane.Z + YPlane.Y * pM2.YPlane.Z + YPlane.Z * pM2.ZPlane.Z + YPlane.W * pM2.WPlane.Z;
        pOut.YPlane.W = YPlane.X * pM2.XPlane.W + YPlane.Y * pM2.YPlane.W + YPlane.Z * pM2.ZPlane.W + YPlane.W * pM2.WPlane.W;
        pOut.ZPlane.X = ZPlane.X * pM2.XPlane.X + ZPlane.Y * pM2.YPlane.X + ZPlane.Z * pM2.ZPlane.X + ZPlane.W * pM2.WPlane.X;
        pOut.ZPlane.Y = ZPlane.X * pM2.XPlane.Y + ZPlane.Y * pM2.YPlane.Y + ZPlane.Z * pM2.ZPlane.Y + ZPlane.W * pM2.WPlane.Y;
        pOut.ZPlane.Z = ZPlane.X * pM2.XPlane.Z + ZPlane.Y * pM2.YPlane.Z + ZPlane.Z * pM2.ZPlane.Z + ZPlane.W * pM2.WPlane.Z;
        pOut.ZPlane.W = ZPlane.X * pM2.XPlane.W + ZPlane.Y * pM2.YPlane.W + ZPlane.Z * pM2.ZPlane.W + ZPlane.W * pM2.WPlane.W;
        pOut.WPlane.X = WPlane.X * pM2.XPlane.X + WPlane.Y * pM2.YPlane.X + WPlane.Z * pM2.ZPlane.X + WPlane.W * pM2.WPlane.X;
        pOut.WPlane.Y = WPlane.X * pM2.XPlane.Y + WPlane.Y * pM2.YPlane.Y + WPlane.Z * pM2.ZPlane.Y + WPlane.W * pM2.WPlane.Y;
        pOut.WPlane.Z = WPlane.X * pM2.XPlane.Z + WPlane.Y * pM2.YPlane.Z + WPlane.Z * pM2.ZPlane.Z + WPlane.W * pM2.WPlane.Z;
        pOut.WPlane.W = WPlane.X * pM2.XPlane.W + WPlane.Y * pM2.YPlane.W + WPlane.Z * pM2.ZPlane.W + WPlane.W * pM2.WPlane.W;
        return pOut;
    }
};

struct alignas(16) FTransform
{
    struct FQuat                                       Rotation;                                                 // 0x0000(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FVector                                     Translation;                                              // 0x0010(0x000C) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    unsigned char                                      UnknownData00[0x4];                                       // 0x001C(0x0004) MISSED OFFSET
    struct FVector                                     Scale3D;                                                  // 0x0020(0x000C) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    unsigned char                                      UnknownData01[0x4];                                       // 0x002C(0x0004) MISSED OFFSET

    FMatrix ToMatrixWithScale()
    {
        FMatrix m;
        m.WPlane.X = Translation.X;
        m.WPlane.Y = Translation.Y;
        m.WPlane.Z = Translation.Z;

        float x2 = Rotation.X + Rotation.X;
        float y2 = Rotation.Y + Rotation.Y;
        float z2 = Rotation.Z + Rotation.Z;

        float xx2 = Rotation.X * x2;
        float yy2 = Rotation.Y * y2;
        float zz2 = Rotation.Z * z2;
        m.XPlane.X = (1.0f - (yy2 + zz2)) * Scale3D.X;
        m.YPlane.Y = (1.0f - (xx2 + zz2)) * Scale3D.Y;
        m.ZPlane.Z = (1.0f - (xx2 + yy2)) * Scale3D.Z;

        float yz2 = Rotation.Y * z2;
        float wx2 = Rotation.W * x2;
        m.ZPlane.Y = (yz2 - wx2) * Scale3D.Z;
        m.YPlane.Z = (yz2 + wx2) * Scale3D.Y;

        float xy2 = Rotation.X * y2;
        float wz2 = Rotation.W * z2;
        m.YPlane.X = (xy2 - wz2) * Scale3D.Y;
        m.XPlane.Y = (xy2 + wz2) * Scale3D.X;

        float xz2 = Rotation.X * z2;
        float wy2 = Rotation.W * y2;
        m.ZPlane.X = (xz2 + wy2) * Scale3D.Z;
        m.XPlane.Z = (xz2 - wy2) * Scale3D.X;

        m.XPlane.W = 0.0f;
        m.YPlane.W = 0.0f;
        m.ZPlane.W = 0.0f;
        m.WPlane.W = 1.0f;

        return m;
    }
};

class CameraStruct
{
public:
    FVector Position; //0x11B0 
    FVector Rotation; //0x11BC 
    float Fov; //0x11C8 
}; //Size=0x11CC

namespace Offsets
{
    uintptr_t oLevel = 0x38;
    uintptr_t oGameInstance = 0x1A8;
    uintptr_t oLocalPlayers = 0x40;
    uintptr_t oPlayerController = 0x38;
    uintptr_t oLocalPawn = 0x440;
    uintptr_t RootComp = 0x210;
    uintptr_t oCameraManager = 0x458;
    uintptr_t oCameraCache = 0x1220;
    uintptr_t ObjID = 0x18;

    uintptr_t Dormant = 0xD8;
    uintptr_t RelativeLocation = 0x15C;
    uintptr_t RelativeRotation = 0x168;
    uintptr_t PlayerState = 0x3C8;
    uintptr_t Ping = 0x3B8;

    uintptr_t TeamComponent = 0x598;
    uintptr_t Team = 0xF8;
    uintptr_t DamageHandler = 0x968;
    uintptr_t Health = 0x188;
    uintptr_t HealthMax = 0x198;

    uintptr_t Mesh = 0x408;
    uintptr_t StaticMesh = 0x518;
    uintptr_t StaticMesh_Cached = 0x528;

    uintptr_t ComponentToWorld = 0x250;
    uintptr_t UniqueID = 0x38;

    uintptr_t ControlRotation = 0x418;

    uintptr_t PlayerName = 0x3A8;
};

uint64_t PlayerController = 0;

uint64_t CameraCache = 0;

CameraStruct GetCameraCache()
{
    CameraStruct Camera = read<CameraStruct>(CameraCache + Offsets::oCameraCache);
    return Camera;
}

D3DMATRIX to_matrix(const FVector& rotation, const FVector& origin) {

    const auto pitch = rotation.X * float(3.14159265358979323846f) / 180.f;
    const auto yaw = rotation.Y * float(3.14159265358979323846f) / 180.f;
    const auto roll = rotation.Z * float(3.14159265358979323846f) / 180.f;

    const auto SP = sinf(pitch);
    const auto CP = cosf(pitch);
    const auto SY = sinf(yaw);
    const auto CY = cosf(yaw);
    const auto SR = sinf(roll);
    const auto CR = cosf(roll);

    D3DMATRIX matrix;
    matrix._11 = CP * CY;
    matrix._12 = CP * SY;
    matrix._13 = SP;
    matrix._14 = 0.f;

    matrix._21 = SR * SP * CY - CR * SY;
    matrix._22 = SR * SP * SY + CR * CY;
    matrix._23 = -SR * CP;
    matrix._24 = 0.f;

    matrix._31 = -(CR * SP * CY + SR * SY);
    matrix._32 = CY * SR - CR * SP * SY;
    matrix._33 = CR * CP;
    matrix._34 = 0.f;

    matrix._41 = origin.X;
    matrix._42 = origin.Y;
    matrix._43 = origin.Z;
    matrix._44 = 1.f;

    return matrix;

}

FVector WorldToScreen(FVector& world_loc) {

    auto CamCache = GetCameraCache();
    const auto matrix = to_matrix(CamCache.Rotation, FVector());
    const auto axisx = FVector(matrix.m[0][0], matrix.m[0][1], matrix.m[0][2]);
    const auto axisy = FVector(matrix.m[1][0], matrix.m[1][1], matrix.m[1][2]);
    const auto axisz = FVector(matrix.m[2][0], matrix.m[2][1], matrix.m[2][2]);

    const auto delta = world_loc - CamCache.Position;
    auto transformed = FVector(delta.Dot(axisy), delta.Dot(axisz), delta.Dot(axisx));

    if (transformed.Z < 0.001f)
        transformed.Z = 0.001f;

    const auto fov_angle = CamCache.Fov;
    const float center = Width / 2.f;
    const float centery = Height / 2.f;
    return FVector(center + transformed.X * (center / static_cast<float>(tan(fov_angle * M_PI / 360))) / transformed.Z, centery - transformed.Y * (center / static_cast<float>(tan(fov_angle * M_PI / 360))) / transformed.Z, 0.f);

}

bool WorldToScreen2(FVector& world_loc, FVector& screenLoc) {

    auto CamCache = GetCameraCache();
    const auto matrix = to_matrix(CamCache.Rotation, FVector());
    const auto axisx = FVector(matrix.m[0][0], matrix.m[0][1], matrix.m[0][2]);
    const auto axisy = FVector(matrix.m[1][0], matrix.m[1][1], matrix.m[1][2]);
    const auto axisz = FVector(matrix.m[2][0], matrix.m[2][1], matrix.m[2][2]);

    const auto delta = world_loc - CamCache.Position;
    auto transformed = FVector(delta.Dot(axisy), delta.Dot(axisz), delta.Dot(axisx));

    if (transformed.Z < 0.001f)
        transformed.Z = 0.001f;

    const auto fov_angle = CamCache.Fov;
    const float screenCenterX = Width / 2.f;
    const float screenCenterY = Height / 2.f;

    screenLoc.X = screenCenterX + transformed.X * (screenCenterX / (float)tan(fov_angle * M_PI / 360)) / transformed.Z;
    screenLoc.Y = screenCenterY - transformed.Y * (screenCenterX / (float)tan(fov_angle * M_PI / 360)) / transformed.Z;

    return ((screenLoc.X >= 0.0f) && (screenLoc.X <= Width) && (screenLoc.Y >= 0.0f) && (screenLoc.Y <= Height));
}


#define URotationToRadians(URotation)		((URotation)* (M_PI / 32768.0f))
#define URotationToDegree( URotation )		( ( URotation ) * ( 360.0f / 65536.0f ) ) 

#define DegreeToURotation( Degree )			( ( Degree ) * ( 65536.0f / 360.0f ) )
#define DegreeToRadian( Degree )			( ( Degree ) * ( M_PI / 180.0f ) )

#define RadianToURotation( URotation )		( ( URotation ) * ( 32768.0f / M_PI ) ) 
#define RadianToDegree( Radian )			( ( Radian ) * ( 180.0f / M_PI ) )

#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )

bool bumbum = true;
__forceinline void Clamp(FVector& Ang) {
    if (Ang.X < 0.f)
        Ang.X += 360.f;

    if (Ang.X > 360.f)
        Ang.X -= 360.f;

    if (Ang.Y < 0.f) Ang.Y += 360.f;
    if (Ang.Y > 360.f) Ang.Y -= 360.f;
    Ang.Z = 0.f;
}

__forceinline FVector CalcAngle(FVector Src, FVector& Dst) {
    FVector Delta = Src - Dst;
    const auto sqrtss = [](float in) {
        __m128 reg = _mm_load_ss(&in);
        return _mm_mul_ss(reg, _mm_rsqrt_ss(reg)).m128_f32[0];
    };

    float hyp = sqrtss(Delta.X * Delta.X + Delta.Y * Delta.Y + Delta.Z * Delta.Z);

    FVector Rotation{};
    Rotation.X = RadianToDegree(acosf(Delta.Z / hyp));
    Rotation.Y = RadianToDegree(atanf(Delta.Y / Delta.X));
    Rotation.Z = 0;
    if (Delta.X >= 0.0f) Rotation.Y += 180.0f;
    Rotation.X += 270.f;
    return Rotation;
}


//pcontroller + ProjectW2S = 0x828
void ClientSetRotation(FVector NewRotation)
{
    auto ClientSetRotationAddr = read<uintptr_t>(PlayerController) + 0x658;
    auto fClientSetRotation = *((void(__fastcall**)(uintptr_t AController, FVector NewRotation, bool bResetCamera))(ClientSetRotationAddr));
    fClientSetRotation(PlayerController, NewRotation, true);
}

bool is_visible(uint64_t mesh)
{
    bool bVisible;

    float fLastSubmitTime = read<float>(mesh + 0x340);
    float fLastRenderTimeOnScreen = read<float>(mesh + 0x340 + 8);
    const float fVisionTick = 0.06f;
    bVisible = fLastRenderTimeOnScreen + fVisionTick >= fLastSubmitTime;
    return bVisible;
}
/*
48 8B C4 55 56 57 41 56 41 57 48 8D 68 C8 > LineOfSightTo
48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 81 EC ? ? ? ? 41 0F B6 E9 > WorldToScreen
48 89 5C 24 ?? 48 89 74 24 ?? 57 48 81 EC ?? ?? ?? ?? F6 81 > GetBoneMatrix
*/
#define line_of_sight 0x37A2210//0x357F248//0x357F250
#define get_bone_matrix 0x357DDD0
#define project_w2s 0x389FB40

FTransform GetBoneIndex(uintptr_t mesh, int index)
{
    uintptr_t bonearray = read<uintptr_t>(mesh + Offsets::StaticMesh);
    if (bonearray == 0)
        bonearray = read<uintptr_t>(mesh + Offsets::StaticMesh_Cached);

    return read<FTransform>(bonearray + (index * 0x30));
}

FVector GetBoneWithRotation(uintptr_t mesh, int id)
{
    FTransform Bone = GetBoneIndex(mesh, id);
    if (Bone.Scale3D.Z > 0.f && Bone.Scale3D.Y > 0.f && Bone.Scale3D.Z > 0.f)
    {
        FTransform ComponentToWorld = read<FTransform>(mesh + Offsets::ComponentToWorld);
        FMatrix Matrix = Bone.ToMatrixWithScale() * ComponentToWorld.ToMatrixWithScale();
        return FVector{ Matrix.WPlane.X, Matrix.WPlane.Y, Matrix.WPlane.Z };
    }
}

void DrawSkeleton(uintptr_t Mesh, bool IsMale, DWORD col)
{
    __try
    {
        int skeleton[][4] = {
            { 7, 8, 0, 0},
            { 7, IsMale ? 47 : 46, IsMale ? 48 : 47, IsMale ? 49 : 48 },
            { 7, 21, 22, 23 },
            { 7, 5, 4, 3 },
            { 3, IsMale ? 82 : 80, IsMale ? 83 : 81, IsMale ? 85 : 83 },
            { 3, IsMale ? 75 : 73, IsMale ? 76 : 74, IsMale ? 78 : 76 }
        };
        for (auto part : skeleton)
        {
            FVector previous{};
            for (int i = 0; i < 4; i++)
            {
                if (!part[i]) break;

                FVector current = GetBoneWithRotation(Mesh, part[i]);
                if (previous.X == 0.f)
                {
                    previous = current;
                    continue;
                }
                FVector p1{}, c1{};
                p1 = WorldToScreen(previous);
                c1 = WorldToScreen(current);
                DrawLine(p1.X, p1.Y, c1.X, c1.Y, col, 1.0f);
                previous = current;
            }
        }
    }
    __except (1) {}
}


bool isaimbotting;
//#define BIT_CHECK(a,b) (!!((a) & (1ULL<<(b))))
/*
bool isVisible(uintptr_t de_mesh)
{
    bool bVisible;
    float fLastSubmitTime = read<float>(de_mesh + 0x0340);
    float fLastRenderTimeOnScreen = read<float>(de_mesh + 0x0344);
    const float fVisionTick = 0.04f;
    bVisible = fLastRenderTimeOnScreen + fVisionTick >= fLastSubmitTime;
    return bVisible;
}*/

uintptr_t ULevel;
uintptr_t GameInstance;
uintptr_t LocalPlayer;
uintptr_t AcknowledgedPawn;
uintptr_t LocalPlayerState;

uintptr_t entityx = 0;

float DistanceBetweenCross(float X, float Y)
{
    float ydist = (Y - (ScreenCenterY));
    float xdist = (X - (ScreenCenterX));
    float Hypotenuse = sqrt(pow(ydist, 2) + pow(xdist, 2));
    return Hypotenuse;
}

void Circle(int X, int Y, int radius, int numSides, DWORD Color)
{
    D3DXVECTOR2 Line[128];
    float Step = M_PI * 2.0 / numSides;
    int Count = 0;
    for (float a = 0; a < M_PI * 2.0; a += Step)
    {
        float X1 = radius * cos(a) + X;
        float Y1 = radius * sin(a) + Y;
        float X2 = radius * cos(a + Step) + X;
        float Y2 = radius * sin(a + Step) + Y;
        Line[Count].x = X1;
        Line[Count].y = Y1;
        Line[Count + 1].x = X2;
        Line[Count + 1].y = Y2;
        Count += 2;
    }
    S_Line->Begin();
    S_Line->Draw(Line, Count, Color);
    S_Line->End();
}

struct D3DTLVERTEX
{
    float fX;
    float fY;
    float fZ;
    float fRHW;
    D3DCOLOR Color;
    float fU;
    float fV;
};


D3DTLVERTEX CreateD3DTLVERTEX(float X, float Y, float Z, float RHW, D3DCOLOR color, float U, float V)
{
    D3DTLVERTEX v =
    {
        X,
        Y,
        Z,
        RHW,
        color,
        U,
        V
    };

    return v;
}

void DrawFilledCircle(int xPos, int yPos, int Radius, D3DCOLOR color)
{
    const DWORD D3DFVF_TL = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    D3DTLVERTEX Vtex[400];

    float x1 = xPos;
    float y1 = yPos;

    for (int i = 0; i <= 363; i += 3)
    {
        float angle = (i / 56.3f);
        float x2 = xPos + (Radius * sin(angle));
        float y2 = yPos + (Radius * cos(angle));
        Vtex[i] = CreateD3DTLVERTEX(xPos, yPos, 0, 1, color, 0, 0);
        Vtex[i + 1] = CreateD3DTLVERTEX(x1, y1, 0, 1, color, 0, 0);
        Vtex[i + 2] = CreateD3DTLVERTEX(x2, y2, 0, 1, color, 0, 0);

        y1 = y2;
        x1 = x2;
    }

    d3ddev->SetFVF(D3DFVF_TL);
    d3ddev->SetTexture(0, NULL);
    d3ddev->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 363, Vtex, sizeof(D3DTLVERTEX));
}
float AimFOV = 30.f;
bool GetClosestPlayerToCrossHair(FVector Pos, float& max, float aimfov)
{
    float Dist = DistanceBetweenCross(Pos.X, Pos.Y);
    if (Dist < max)
    {
        max = Dist;
        AimFOV = aimfov;
        return true;
    }
    return false;
}

void AIms(uintptr_t ent)
{
    float max = AimFOV / 2;
    FVector rootHeadOut = FVector();

    uintptr_t Mesh = read<uintptr_t>(ent + Offsets::Mesh);
    FVector rootHead = GetBoneWithRotation(Mesh, 7);
    rootHeadOut = WorldToScreen(rootHead);

    if (GetClosestPlayerToCrossHair(rootHeadOut, max, AimFOV))
        entityx = ent;
    return;
}

static bool InsideCircle(float xc, float yc, float r, float x, float y)
{

    float dx = xc - x;
    float dy = yc - y;
    return dx * dx + dy * dy <= r * r;
}

FVector LGetViewAngles()
{
    FVector ViewAngle = read<FVector>(PlayerController + Offsets::ControlRotation);
    return ViewAngle;
}

void normalize(FVector& in)
{
    if (in.X > 89.f) in.X -= 360.f;
    else if (in.X < -89.f) in.X += 360.f;

    // in.Y = fmodf(in.Y, 360.0f);
    while (in.Y > 180)in.Y -= 360;
    while (in.Y < -180)in.Y += 360;
    in.Z = 0;
}

FVector SmoothAim(FVector Camera_rotation, FVector Target, float SmoothFactor)
{
    FVector diff = Target - Camera_rotation;
    normalize(diff);
    return Camera_rotation + diff / SmoothFactor;
}


void RCS(FVector Target, FVector Camera_rotation, float SmoothFactor) {

    // Camera 2 Control space
    FVector ConvertRotation = Camera_rotation;
    normalize(ConvertRotation);

    // Calculate recoil/aimpunch
    auto ControlRotation = read<FVector>(PlayerController + Offsets::ControlRotation);
    FVector DeltaRotation = ConvertRotation - ControlRotation;
    normalize(DeltaRotation);

    // Remove aimpunch from CameraRotation
    ConvertRotation = Target - (DeltaRotation * SmoothFactor);
    normalize(ConvertRotation);

    //Smooth the whole thing
    FVector Smoothed = SmoothAim(Camera_rotation, ConvertRotation, SmoothFactor);
    Smoothed -= (DeltaRotation / SmoothFactor);
    Clamp(Smoothed);
    // normalize(Smoothed);
    *(float*)(PlayerController + 0x418) = Smoothed.X;
    *(float*)(PlayerController + 0x41C) = Smoothed.Y;

    return;
}

bool LineOfSightTo(uint64_t thiz, uint64_t Other, FVector* ViewPoint)
{
    __try {
        static DWORD_PTR funcAddress = 0;
        if (!funcAddress)funcAddress = valBase + line_of_sight;
        if (funcAddress)
        {
            return reinterpret_cast<int(__fastcall*)(uint64_t thiz, uint64_t Other, FVector * ViewPoint)>(funcAddress)(thiz, Other, ViewPoint);
        }
        else return false;
    }
    __except (1) { return false; }
}
float HealthLocal;
float Smooth = 1.f;
void xasdasdascsa()
{
    
    //(LocalPawn + 0xF28) + 0x210 = Matrix
    //(LocalPawn + 0xF28) + 0x240 = Pitch & Yaw
    bool IsDormant = read<bool>(entityx + Offsets::Dormant);
    uintptr_t Mesh = read<uintptr_t>(entityx + Offsets::Mesh);
    
    if (AcknowledgedPawn != 0)
    {
        uintptr_t DmgHandler = read<uintptr_t>(entityx + Offsets::DamageHandler);
        float Health = read<float>(DmgHandler + Offsets::Health);
        
        FVector aim_bone = GetBoneWithRotation(Mesh, (Fun.Scroll_Function1 == 0 ? 8 : Fun.Scroll_Function1 == 1 ? 7 : 5));
        FVector vHead = WorldToScreen(aim_bone);
        if (entityx != 0) {
            
            if ((Health > 0.f && Health < 200.f) && !IsDormant)
            {
                bool IsVisible = is_visible(Mesh);

                if (IsVisible)
                {
                    if (vHead.X != 0.f && vHead.Y != 0.f &&
                        aim_bone.X != 0.f && aim_bone.Y != 0.f && aim_bone.Z != 0.f)
                    {
                        if (GetAsyncKeyState(VK_LBUTTON) ?
                            InsideCircle(ScreenCenterX, ScreenCenterY, 180.f, vHead.X, vHead.Y) :
                            InsideCircle(ScreenCenterX, ScreenCenterY, AimFOV, vHead.X, vHead.Y))
                        {
                            if (DistanceBetweenCross(vHead.X, vHead.Y))
                            {
                                FVector AimAngles = CalcAngle(GetCameraCache().Position, aim_bone);
                                Clamp(AimAngles);
                                if (Fun.cRCS > 0)
                                {
                                    RCS(AimAngles, GetCameraCache().Rotation, Smooth + 3.f);
                                }
                                else
                                {
                                    if (Fun.Scroll_Function4 > 0) { // smooth açık
                                        AimAngles = SmoothAim(GetCameraCache().Rotation, AimAngles, Smooth);
                                        Clamp(AimAngles);
                                    }
                                    *(float*)(PlayerController + 0x418) = AimAngles.X;
                                    *(float*)(PlayerController + 0x41C) = AimAngles.Y;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


DWORD Aimkey = NULL;
bool GetHead()
{
    
    if (Aimkey != NULL)
        return (GetAsyncKeyState(Aimkey));
    else
        return true;
}

void Aimbot()
{
    if (entityx)
    {
        if (GetHead())
        {
            isaimbotting = true;
            xasdasdascsa();
        }
        else
        {
            isaimbotting = false;
        }
    }
    else
    {
        isaimbotting = false;
    }
    
}

void bar_hp(int x, int y, int width, int height, int hp, int Alpha)
{
    DWORD backcolor = D3DCOLOR_RGBA(0, 0, 0, 255);
    DWORD color = D3DCOLOR_RGBA(6, 220, 0, 255);

    int healthPercentage = hp * 100 / 100;
    if (healthPercentage <= 80 && healthPercentage >= 60) { color = D3DCOLOR_RGBA(255, 255, 0, Alpha); }
    else if (healthPercentage <= 60 && healthPercentage >= 40) { color = D3DCOLOR_RGBA(255, 200, 0, Alpha); }
    else if (healthPercentage <= 40 && healthPercentage >= 20) { color = D3DCOLOR_RGBA(255, 120, 0, Alpha); }
    else if (healthPercentage <= 20 && healthPercentage >= 0) { color = D3DCOLOR_RGBA(255, 24, 101, Alpha); }

    DrawBox(x, y, width, (hp * height / 100), color, d3ddev);
}

/* Male's */
/* 10475983 = Breach
 * 10486177 = Brimstone
 * 10480426 = Cypher
 * 10490019 = Omen
 * 10485211 = Phoenix
 * 10481647 = Sova
 * 10487634 = YORU
 */

 /* Female's */
 /* 10490894 = Jett
  * 10482853 = Killjoy
  * 10476549 = Raze
  * 10489239 = Reyna
  * 10488471 = Sage
  * 10479233 = Skye
  * 10484198 = Viper
  */
  //Bot = 10477073

int Aimbonz = 8;

typedef struct _ValEntity
{
    uintptr_t Addr;
    uintptr_t Mesh;
    int Type;
    int ObjectID;

}ValEntity;
vector<ValEntity> entityList;

#define Player 0
#define Bot 1
#define SpikeTimer 2

bool ol = true;



/* Ulti's */
/* Skye Wolf      = 10678150 //ok
 * Skye Bird      = 10677811 //ok
 * Skye Ult.      = 10478935
 * Sova Arrow     = 10680502 //ok
 * Cypher Camera  = 10679492 //ok
 * Cypher Trap    = 10678701 //ok
 * Killjoy Turret = 10681574 //ok
 * Killjoy Alarm Bot  = 10681975 //ok
 * Killjoy Bomb Trap  = 10681307 //ok
 * Killjoy Ulti       = 10682227 //ok
 * Raze Bot           = 10675151 //ok
*/

// Spike Esp = 10769634

string GetAbilities(int id)
{
    switch (id)
    {
    case 10678150: return ("Skye Wolf");
        break;
    case 10677811: return ("Skye Bird");
        break;
    case 10478935: return ("Skye Ulti");
        break;
    case 10680502: return ("Sova Arrow");//ok
        break;
    case 10679492: return ("Cypher Camera");//ok
        break;
    case 10678701: return ("Cypher Trap");//ok
        break;
    case 10681574: return ("Killjoy Turret");//ok
        break;
    case 10681975: return ("Killjoy Alarm Bot");//ok
        break;
    case 10681307: return ("Killjoy Bomb Trap");//ok
        break;
    case 10682227: return ("Killjoy Ulti");//ok
        break;
    case 10675151: return ("Raze Bot");//ok
        break;
    case 10686257: return ("Yoru TP");
        break;
    case 10685993: return ("Yoru FAKEOUT");
        break;
    case 10769634: return ("Spike");
        break;
    default:
        return ("NULL");
        break;
    }
}


/* Male's */
/* 10674110 = Breach ok
 * 10684347 = Brimstone ok
 * 10678577 = Cypher ok
 * 10688224 = Omen ok
 * 10683381 = Phoenix ok
 * 10679798 = Sova ok
 * 10685839 = YORU ok
 */

 /* Female's */
 /* 10689099 = Jett ok
  * 10681004 = Killjoy ok
  * 10674676 = Raze ok
  * 10687444 = Reyna ok
  * 10686676 = Sage ok
  * 10677384 = Skye ok
  * 10682349 = Viper ok
  */
  //Bot = 10477073
#define isMale (ObjID == 11371326 || ObjID == 11382997 || ObjID == 11375864 || ObjID == 11386956 || ObjID == 11380680 || ObjID == 11377095 || ObjID == 11384528)
#define isFemale (ObjID == 11381645 || ObjID == 11387840 || ObjID == 11378301 || ObjID == 11371901 || ObjID == 11386165 || ObjID == 11385388 || ObjID == 11374667 || ObjID == 11379638)

#define isBot (ObjID == 10732217)

string GetCharacterName(int id)
{

    switch (id)
    {
        /*Female's*/
    case 11381645:   return xorstr_("Astra");//ok
        break;
    case 11387840:   return xorstr_("Jett");//ok
        break;
    case 11378301:   return xorstr_("Killjoy");//ok
        break;
    case 11371901:   return xorstr_("Raze");//ok
        break;
    case 11386165:   return xorstr_("Reyna");//ok
        break;
    case 11385388:   return xorstr_("Sage");//ok
        break;
    case 11374667:   return xorstr_("Skye");//ok
        break;
    case 11379638:   return xorstr_("Viper");//ok
        break;

        /*Male's*/
    case 11371326:   return xorstr_("Breach");//ok
        break;
    case 11382997:   return xorstr_("Brimstone");//ok
        break;
    case 11375864:   return xorstr_("Cypher");//ok
        break;
    case 11386956:   return xorstr_("Omen");//ok
        break;
    case 11380680:   return xorstr_("Phoenix");//ok
        break;
    case 11377095:   return xorstr_("Sova");//ok
        break;
    case 11384528:   return xorstr_("Yoru");//ok
        break;

        /*Bot*/
    //case 10732217:  return  xorstr_("Bot");
    //    break;
    default:

        return ("");
        break;
    }
}


void cache()
{
    
    while (true)
    {
        vector<ValEntity> TempList;
        ULevel = read<uintptr_t>(UWorld + Offsets::oLevel);//page guard
        if (ULevel == NULL || GameInstance == NULL || LocalPlayer == NULL || PlayerController == NULL)
            UWorld = ReadWorld();  //page guard
        GameInstance = read<uintptr_t>(UWorld + Offsets::oGameInstance);
        if (GameInstance == 0) continue;
        LocalPlayer = read<uintptr_t>(read<uintptr_t>(GameInstance + Offsets::oLocalPlayers));
        if (LocalPlayer == 0) continue;
        PlayerController = read<uintptr_t>(LocalPlayer + Offsets::oPlayerController);
        if (PlayerController == 0) continue;
        CameraCache = read<uint64_t>(PlayerController + Offsets::oCameraManager);
        if (CameraCache == 0) continue;
        AcknowledgedPawn = read<uintptr_t>(PlayerController + Offsets::oLocalPawn);
        if (AcknowledgedPawn == 0) continue;
        uintptr_t DmgHandlerLocal = read<uintptr_t>(AcknowledgedPawn + Offsets::DamageHandler);
        if (DmgHandlerLocal == 0) continue;
        LocalPlayerState = read<uintptr_t>(AcknowledgedPawn + Offsets::PlayerState);
        if (LocalPlayerState == 0) continue;
        auto ActorArray = read<uintptr_t>(ULevel + 0xA0);
        if (ActorArray == 0) continue;
        
        HealthLocal = read<float>(DmgHandlerLocal + Offsets::Health);

        int ActorCount = read<int>(ULevel + 0xA8);
        for (int i = 0; i < ActorCount; i++)
        {
            
            uintptr_t Actor = read<uintptr_t>(ActorArray + (i * 0x8));

            if (Actor != 0)
            {
                uintptr_t Mesh = read<uintptr_t>(Actor + Offsets::Mesh);
                int UniqueId = read<int>(Actor + Offsets::UniqueID);

                ValEntity valEntity{ };
                valEntity.Addr = Actor;

                int ObjID = read<int>(Actor + Offsets::ObjID);

                if (isMale || isFemale)
                {
                    if (Mesh != NULL)
                    {
                        
                        valEntity.ObjectID = ObjID;
                        valEntity.Mesh = Mesh;
                        valEntity.Type = Player;
                        TempList.push_back(valEntity);
                    }
                }
            }
        }
        entityList = TempList;
        Sleep(2);
    }   
}


D3DXVECTOR2 WorldRadar(FVector srcPos, FVector distPos, float yaw, float radarX, float radarY, float size)
{
    
    auto cosYaw = cos(DegreeToRadian(yaw));
    auto sinYaw = sin(DegreeToRadian(yaw));

    auto deltaX = srcPos.X - distPos.X;
    auto deltaY = srcPos.Y - distPos.Y;

    auto locationX = (float)(deltaY * cosYaw - deltaX * sinYaw) / 45.f;
    auto locationY = (float)(deltaX * cosYaw + deltaY * sinYaw) / 45.f;

    if (locationX > (size - 2.f))
        locationX = (size - 2.f);
    else if (locationX < -(size - 2.f))
        locationX = -(size - 2.f);

    if (locationY > (size - 6.f))
        locationY = (size - 6.f);
    else if (locationY < -(size - 6.f))
        locationY = -(size - 6.f);

    return D3DXVECTOR2((int)(-locationX + radarX), (int)(locationY + radarY));
    
}
static FVector pRadar;

static int enemy_size = 3;


void DrawRadar(FVector EntityPos, DWORD EntityColor)
{
    auto radar_posX = pRadar.X + 135;
    auto radar_posY = pRadar.Y + 135;
    if (AcknowledgedPawn == 0) return;
    uint64_t LocalRootComp = read<uint64_t>(AcknowledgedPawn + Offsets::RootComp);
    FVector LocalPos = read<FVector>(LocalRootComp + Offsets::RelativeLocation);
    auto Radar2D = WorldRadar(LocalPos, EntityPos, LGetViewAngles().Y, radar_posX, radar_posY, 135.f);// radar pos

    DrawBox(Radar2D.x, Radar2D.y, 4, 4, EntityColor, d3ddev);
    
}

void EspLoop()
{
    UsefulFuntion(156, 155, 321, 551);
    std::vector<ValEntity> vEntityList = entityList;
    
    if (vEntityList.empty())
        return;
    
    for (int i = 0; i < vEntityList.size(); i++)
    {
        ValEntity pEntity = vEntityList[i];
        if (AcknowledgedPawn != NULL &&
            pEntity.Addr != NULL &&
            pEntity.Addr != AcknowledgedPawn)
        {
            UsefulFuntion(412, 123, 421, 512);
            uintptr_t Mesh = pEntity.Mesh;
            uintptr_t bonearray = read<uintptr_t>(Mesh + Offsets::StaticMesh);

            uintptr_t RootComp = read<uintptr_t>(pEntity.Addr + Offsets::RootComp);
            FVector RootPos = read<FVector>(RootComp + Offsets::RelativeLocation);
            FVector vScreen = WorldToScreen(RootPos);

            uintptr_t LocalRootComp = read<uintptr_t>(AcknowledgedPawn + Offsets::RootComp);
            FVector LocalPos = read<FVector>(LocalRootComp + Offsets::RelativeLocation);
            float fDistance = LocalPos.Distance(RootPos) / 100.f;

            int ObjID = pEntity.ObjectID;

            if (pEntity.Type == Player)
            {
                int unique_id = read<int>(pEntity.Addr + Offsets::UniqueID);
                if (unique_id != 18743553)
                    continue;

                uintptr_t DmgHandler = read<uintptr_t>(pEntity.Addr + Offsets::DamageHandler);

                float Health = read<float>(DmgHandler + Offsets::Health);

                if (Health > 0.f && Health < 200.f)
                {
                    char dist_char[64];
                    string CharacterName = GetCharacterName(pEntity.ObjectID);
                    sprintf(dist_char, CharacterName.c_str());

                    char dist_[64];
                    sprintf(dist_, ("%.f"), fDistance);

                    bool IsDormant = read<bool>(pEntity.Addr + Offsets::Dormant);

                    uintptr_t ePlayerState = read<uintptr_t>(pEntity.Addr + Offsets::PlayerState);

                    int EnemyTeam = read<int>(read<uintptr_t>(read<uintptr_t>(pEntity.Addr + Offsets::PlayerState) + Offsets::TeamComponent) + Offsets::Team);
                    int LocalTeam = read<int>(read<uintptr_t>(read<uintptr_t>(AcknowledgedPawn + Offsets::PlayerState) + Offsets::TeamComponent) + Offsets::Team);

                    if (fDistance > 1.f)
                    {
                        FVector Head = GetBoneWithRotation(Mesh, 8);
                        FVector Foot = GetBoneWithRotation(Mesh, 0);

                        FVector vHead = WorldToScreen(Head);
                        FVector vFoot = WorldToScreen(Foot);
                        float BoxHeight = vHead.Y - vFoot.Y;


                        FVector vHead2;
                        bool fuckk = WorldToScreen2(Head, vHead2);

                        FVector vFoot2;
                        bool fuckk2 = WorldToScreen2(Foot, vFoot2);

                        FVector vPoint(0, 0, 0);
                        bool IsVisible = is_visible(Mesh);

                        DWORD vis_col = IsDormant ? Silver_Menu : IsVisible ? GREEN : RED;

                        if (EnemyTeam != LocalTeam)
                        {
                           // AIms(pEntity.Addr);

                            if (Fun.cRadar == 1)
                                DrawRadar(RootPos, vis_col);

                            if (fuckk && fuckk2) 
                            {
                                if (Fun.cHealthbar == 1) {

                                    const int middle = vFoot2.Y - vHead2.Y;
                                    const auto width = middle / 4;
                                    const auto health_calc = std::clamp(static_cast<int>(Health) * middle / 100, 0, middle);
                                    const auto health_color = color().hsv_to_rgb(int(Health) + 25, 1, 1, 255);
                                    font->DrawTextX(vFoot2.X - (strlen(string(std::to_string((int)Health) + (" HP")).c_str()) * 7 / 2) + 5, vFoot2.Y + 5, IsDormant ? D3DCOLOR_RGBA(236, 236, 236, 255) : D3DCOLOR_RGBA(health_color.r, health_color.g, health_color.b, 255), string(std::to_string((int)Health) + " HP").c_str());

                                    DrawBox(vHead2.X + width, vHead2.Y + middle - health_calc, 4, health_calc, D3DCOLOR_RGBA(health_color.r, health_color.g, health_color.b, 255), d3ddev);
                                }

                                if (Fun.cBox == 1)
                                    DrawESPBox(vHead2, vFoot2, vis_col, IsDormant ? 40 : 100, d3ddev);
                            }

                            if (Fun.cCharacter == 1) {
                                DrawBox(vHead.X - (strlen(dist_char) * 7 / 2) - 27, vHead.Y - 25, (3 * 7 / 2) + 16, 16, RED, d3ddev);
                                DrawBox(vHead.X - (strlen(dist_char) * 7 / 2) - 1, vHead.Y - 25, strlen(dist_char) * 7 + 14, 16, BLACK, d3ddev);
                                font->DrawTextX(vHead.X - (strlen(dist_char) * 7 / 2) - (fDistance < 10.f ? 17 : 21), vHead.Y - 25, Silver_Menu, dist_);
                                font->DrawTextX(vHead.X - (strlen(dist_char) * 7 / 2) + 7, vHead.Y - 25, vis_col, dist_char);
                            }

                            if (Fun.cHead == 1) {
                                if (fuckk) {
                                    DrawFilledCircle(vHead2.X, vHead2.Y, BoxHeight / 8, YELLOW);
                                }
                            }
                        }
                    }
                }
            }
        }     
    }
}
#define SilverWhite2       D3DCOLOR_RGBA(200, 200, 200, 200)
#define TBlack2     D3DCOLOR_ARGB(100, 000, 000, 000)
void Menu(LPDIRECT3DDEVICE9 pDevice)
{
    
    pRadar.X = Width - 450;
    pRadar.Y = ScreenCenterY - ScreenCenterY + 300;
    
    if (Fun.cRadar == 1)
    {      
        DrawBorder(pRadar.X, pRadar.Y, 270, 270, 1, RED, d3ddev);       
        auto radar_posX = pRadar.X + 135;//155
        auto radar_posY = pRadar.Y + 135;//165
        DrawBox(pRadar.X, pRadar.Y, 270, 270, TBlack2, d3ddev);
        DrawBox(radar_posX - 0.5f, radar_posY - 0.5f, 3, 3, YELLOW, d3ddev);
    }
    

	if (GetAsyncKeyState(VK_DELETE) & 1) SHOW = (!SHOW);
	if (SHOW)
	{

        //font->DrawTextX(10, 5, GREEN, xorstr_("UC ESP ~ Public"));
		X = 0;
		Y = 0;
		Draw_Menu_1(X + 1, 5, xorstr_("StuzziKLL UC INTERNAL"), pDevice);
		DrawBorderMenu(11, 48, 99, 29, BorderWhite, pDevice);
		XVPVQW_Menu(X + 20, Y + 48, 99, 27, xorstr_("StuzziKLL UC ESP"), Fun.Menu1, pDevice);
		//XVPVQW_Menu(X + 20, Y + 48 + 20, 99, 27, xorstr_("Aimbot"), Fun.Menu2, pDevice);

        Fun.cLine = 0;
        Fun.cSkeleton = 0;
        Fun.cAbility = 0;
        Fun.cSpike = 0;
		if (Fun.Menu1)
		{
			Draw_Menu(131, 212, xorstr_("Esp Settings"), pDevice);
			XVPVQW(X + 138, 55, 12, 12, Fun.cBox, xorstr_("  Esp Box"), pDevice);
			XVPVQW(X + 138, 55 + 15, 12, 12, Fun.cHead, xorstr_("  Esp Head"), pDevice);
			XVPVQW(X + 138, 55 + 15 * 2, 12, 12, Fun.cHealthbar, xorstr_("  Esp Healthbar"), pDevice);
			XVPVQW(X + 138, 55 + 15 * 3, 12, 12, Fun.cDistance, xorstr_("  Esp Distance"), pDevice);
			XVPVQW(X + 138, 55 + 15 * 4, 12, 12, Fun.cCharacter, xorstr_("  Esp Player"), pDevice);
            XVPVQW(X + 138, 55 + 15 * 5, 12, 12, Fun.cRadar, xorstr_("  Draw Radar"), pDevice);
		}
		if (Fun.Menu2)
		{
			Draw_Menu(161, 305, xorstr_("Aimbot Settings"), pDevice);
			XVPVQW(X + 138, 55, 12, 12, Fun.cAim, xorstr_("  Aimbot"), pDevice);
			XVPVQW(X + 138, 55 + 15, 12, 12, Fun.cAimDrone, xorstr_("  Aimbot Drone & Camera"), pDevice);
			XVPVQW(X + 138, 55 + 15 * 2, 12, 12, Fun.cRCS, xorstr_("  Recoil Compensation"), pDevice);

			Scrol(X + 145, 55 + 15 * 4, Fun.Scroll_Function1, optBone, 2, xorstr_("  Bone"), pDevice);
			Scrol(X + 145, 55 + 15 * 5, Fun.Scroll_Function2, optKey, 10, xorstr_("  Key"), pDevice);
			Scrol(X + 145, 55 + 15 * 6, Fun.Scroll_Function3, optFov, 8, xorstr_("  Fov"), pDevice);
			Scrol(X + 145, 55 + 15 * 7, Fun.Scroll_Function4, optSmooth, 10, xorstr_("  Smooth"), pDevice);
		}
	}
}

void SetWindowToTarget()
{
	std::string c1 = ("lWi");
	std::string c2 = ("ndow");
	std::string c3 = ("Unrea") + c1 + c2;
    GameWnd = FindWindow(c3.c_str(), 0);
    RtlSecureZeroMemory(&c3, sizeof(c3));
    
    ZeroMemory(&GameRect, sizeof(GameRect));
    GetWindowRect(GameWnd, &GameRect);
    Width = GameRect.right - GameRect.left;
    Height = GameRect.bottom - GameRect.top;
    
    DWORD dwStyle = GetWindowLong(GameWnd, GWL_STYLE);
    if (dwStyle & WS_BORDER)
    {
        GameRect.top += 34;
        Height -= 37;
    }
    
    ScreenCenterX = Width / 2;
    ScreenCenterY = Height / 2;
    
}

void abc() {
    int xsd = 441;
}
D3DPRESENT_PARAMETERS d3dpp;
void render()
{
    abc();
    d3ddev->Clear(NULL, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, NULL);
    d3ddev->BeginScene();
    // RtlSecureZeroMemory(&wnd_str, sizeof(wnd_str));

    if (GameWnd == GetForegroundWindow() || GetActiveWindow() == GetForegroundWindow())
    {
        abc(); abc();
        Menu(d3ddev); abc(); abc();
        EspLoop(); abc(); abc();
    }
    abc();
    d3ddev->EndScene();
    HRESULT c3 = d3ddev->Present(NULL, NULL, NULL, NULL);


    if (c3 != 0)
    {
        d3d->CreateDevice(D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            MyWnd,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &d3ddev);

        D3DXCreateLine(d3ddev, &S_Line);
        PostReset(d3ddev);
        d3d->Release();//discharge
    }
}
void CleanuoD3D()
{
    if (d3ddev != NULL)
    {
        d3ddev->EndScene();
        d3ddev->Release();
    }
    if (d3d != NULL)
    {
        d3d->Release();
    }
}
WPARAM MainLoop()
{
    
    static RECT old_rc;
    ZeroMemory(&Message, sizeof(MSG));
    while (Message.message != WM_QUIT)
    {
        
        render();
        if (PeekMessage(&Message, MyWnd, 0, 0, PM_REMOVE))
        {
            
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        
       /* HWND hwnd_active = GetForegroundWindow();
        
        if (GetAsyncKeyState(0x23) & 1)
            exit(8);
        
        if (hwnd_active == GameWnd) {
            HWND hwndtest = GetWindow(hwnd_active, GW_HWNDPREV);
            SetWindowPos(MyWnd, hwndtest, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        }*/
        
    }
    
    CleanuoD3D();
    DestroyWindow(MyWnd);
    ExitProcess(0);
    return Message.wParam;
    
}

bool initD3D(HWND hWnd)
{
    
    d3d = Direct3DCreate9(D3D_SDK_VERSION);
    ZeroMemory(&d3dpp, sizeof(d3dpp));
    
    d3dpp.hDeviceWindow = hWnd; 
    d3dpp.MultiSampleQuality = D3DMULTISAMPLE_NONE; 
    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; 
    d3dpp.BackBufferCount = 1; 
    d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; 
    d3dpp.BackBufferWidth = 0; 
    d3dpp.BackBufferHeight = 0; 
    d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE; 
    d3dpp.Windowed = true; 
    d3dpp.EnableAutoDepthStencil = TRUE; 
    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    
    d3d->CreateDevice(D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &d3ddev);

    D3DXCreateLine(d3ddev, &S_Line);
    PostReset(d3ddev);
    d3d->Release();//discharge
    
    return true;
    
}


void SetupDX()
{   
    auto ahpxp = xorstr_("d3d9.dll");
    while (!GetModuleHandleA(ahpxp)) {
        Sleep(1);
    }   
    RtlSecureZeroMemory(&ahpxp, sizeof(ahpxp));

    const char* wnd_str2 = xorstr_("UCVALO");
    WNDCLASSEX wc;
    HWND hwnd;
    MSG Msg;
    
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = 0;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(RGB(0, 0, 0));
    wc.lpszMenuName = NULL;
    wc.lpszClassName = wnd_str2;
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    
    RegisterClassEx(&wc);
    
    SetWindowToTarget();
  

    MyWnd = CreateWindowEx(
        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        wnd_str2,
        "",
        WS_POPUP | WS_VISIBLE,
        GameRect.left, GameRect.top, Width, Height,
        NULL, NULL, 0, NULL);

    RtlSecureZeroMemory(&wnd_str2, sizeof(wnd_str2));

    SetLayeredWindowAttributes(MyWnd, RGB(0, 0, 0), 255, LWA_ALPHA);

    DwmExtendFrameIntoClientArea(MyWnd, &Margin);
    HANDLE pp = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)cache, 0, 0, 0);
    CloseHandle(pp);
    
    if (initD3D(MyWnd))
    {
        HANDLE pp2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MainLoop, 0, 0, 0);
        CloseHandle(pp2);

    }
    
}

LRESULT CALLBACK WinProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    
    switch (message)
    {
    case WM_PAINT:
    {
    DwmExtendFrameIntoClientArea(hWnd, &Margin);
    }
    break;

    case WM_DESTROY:
    {
        CleanuoD3D();
        PostQuitMessage(0);
        exit(4);
        return 0;
    }
    break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    
    return 0;
}



```

`README.md`:

```md
# Valorant Internal Cheat

A Valorant Internal Cheat by StuzziKLL's source and given some small adjustments by me.

Picture of the menu:

![unknown](https://user-images.githubusercontent.com/66092976/133507898-5ee16496-998c-47e3-8caf-e724bdbc8b96.png)


***

#### How to use the Valorant Internal

[+] - Download it, then compile the cheat

[+] - Put both the loader.exe and the .dll in the same folder and open the loader

[+] - This will both load the driver and then after you opened Valorant, inject the .dll

***

Recommended Injector: https://www.unknowncheats.me/forum/anti-cheat-bypass/426893-injector-v2-version-eac-vanguard.html



```

`Structur.h`:

```h
#pragma once

int  X,Y;
#define	lm1	   GetAsyncKeyState(VK_LBUTTON)&1
#define	rm1    GetAsyncKeyState(VK_RBUTTON)&1

// bone - key - fov - smooth - visMode
char* optTeamSelect[3] = { " Enemy"," Both"," Bot" };
char *optBone     [3] = { " Head"," Neck"," Body" };
char *optKey     [11] = { " CapsLock"," CTRL"," ALT"," LShift"," Fire"," E"," F"," T", " V"," C"," X" };
char *optFov     [9] = { " 5"," 10"," 15"," 20"," 25"," 30"," 60"," 90"," 120"};
char *optSmooth     [11] = { " 0"," 1"," 2"," 3"," 4"," 5"," 6"," 7"," 8" ," 9" ," 10" };
char *optVisMode     [3] = { " NoVisible"," LastRenderTime"," LineOfSight" };
struct cFun
{
/*Main*/
	int Menu1 = 1;
	int Menu2;

/*Function*/
int Scroll_Function1, Scroll_Function2, Scroll_Function3, Scroll_Function4, Scroll_Function5, Scroll_Function6, Scroll_Function7, Scroll_Function8, Scroll_Function9;
int cBox, cLine, cCharacter, cRadar, cHealthbar, cSkeleton, cHead, cDistance, cAbility, cSpike;
int cAim, cAimDrone, cDrawFov, cRCS;
};
extern cFun Fun;
```

`ValoAgentPublic.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9CC33B06-3E96-405B-B8E6-BBD0465423D5}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VVWQWWW</RootNamespace>
    <ProjectName>VVWQWWW</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>D:\KoZaK\WallHack\SKD\Lib\Include;D:\Проги\WallHack\SKD\Include;C:\Users\Den\Desktop\эдлдж\SDK\Include;C:\Documents and Settings\Admin\Мои документы\Создание ПО\SDK\Include;$(IncludePath)</IncludePath>
    <LibraryPath>D:\KoZaK\WallHack\SKD\Lib\x86;D:\Проги\WallHack\SKD\Lib\x86;C:\Users\Den\Desktop\эдлдж\SDK\Lib\x86;C:\Documents and Settings\Admin\Мои документы\Создание ПО\SDK\Lib\x86;$(LibraryPath)</LibraryPath>
    <ExecutablePath>D:\KoZaK\WallHack\SKD\Lib\Include;D:\KoZaK\WallHack\SKD\Include;D:\Проги\WallHack\SKD\Include;C:\Users\Den\Desktop\эдлдж\SDK\Include;$(ExecutablePath)</ExecutablePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CD3D_HACK_SOURCE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CD3D_HACK_SOURCE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <OutputFile>$(OutDir)ReMbO_Menu.dll</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>MinSpace</Optimization>
      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <IntrinsicFunctions>false</IntrinsicFunctions>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Base.cpp" />
    <ClCompile Include="Font.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Color.h" />
    <ClInclude Include="defs.h" />
    <ClInclude Include="Font.h" />
    <ClInclude Include="Menu.h" />
    <ClInclude Include="Draw.h" />
    <ClInclude Include="Structur.h" />
    <ClInclude Include="xorstr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ValoAgentPublic.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Font">
      <UniqueIdentifier>{3ed86aa4-b729-497e-af22-c10a66830105}</UniqueIdentifier>
    </Filter>
    <Filter Include="Main">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Otfer">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Base.cpp">
      <Filter>Main</Filter>
    </ClCompile>
    <ClCompile Include="Font.cpp">
      <Filter>Font</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Color.h">
      <Filter>Otfer</Filter>
    </ClInclude>
    <ClInclude Include="Structur.h">
      <Filter>Otfer</Filter>
    </ClInclude>
    <ClInclude Include="Font.h">
      <Filter>Font</Filter>
    </ClInclude>
    <ClInclude Include="Draw.h">
      <Filter>Otfer</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Main</Filter>
    </ClInclude>
    <ClInclude Include="defs.h">
      <Filter>Main</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.h">
      <Filter>Main</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ValoAgentPublic.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`defs.h`:

```h
#include <cstdint>

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
//typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types:
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

						// Some convenience macros to make partial accesses nicer
						// first unsigned macros:
#define LOBYTE(x)   (*((_BYTE*)&(x)))   // low byte
#define LOWORD(x)   (*((_WORD*)&(x)))   // low word
#define LODWORD(x)  (*((_DWORD*)&(x)))  // low dword
#define HIBYTE(x)   (*((_BYTE*)&(x)+1))
#define HIWORD(x)   (*((_WORD*)&(x)+1))
#define HIDWORD(x)  (*((_DWORD*)&(x)+1))
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

						// now signed macros (the same but with sign extension)
#define SLOBYTE(x)   (*((int8*)&(x)))
#define SLOWORD(x)   (*((int16*)&(x)))
#define SLODWORD(x)  (*((int32*)&(x)))
#define SHIBYTE(x)   (*((int8*)&(x)+1))
#define SHIWORD(x)   (*((int16*)&(x)+1))
#define SHIDWORD(x)  (*((int32*)&(x)+1))
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)


						// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

						// Fill memory block with an integer value
inline void memset32(void* ptr, uint32 value, int count)
{
	uint32* p = (uint32*)ptr;
	for (int i = 0; i < count; i++)
		*p++ = value;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	T high = value >> (nbits - count);
	value <<= count;
	value |= high;
	return value;
}

// rotate right
template<class T> T __ROR__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	T low = value << (nbits - count);
	value >>= count;
	value |= low;
	return value;
}

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
	return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
	if (sizeof(T) == 1)
		return int8(x) < 0;
	if (sizeof(T) == 2)
		return int16(x) < 0;
	if (sizeof(T) == 4)
		return int32(x) < 0;
	return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
	}
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
	}
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) < uint8(y);
	if (size == 2)
		return uint16(x) < uint16(y);
	if (size == 4)
		return uint32(x) < uint32(y);
	return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) > uint8(x + y);
	if (size == 2)
		return uint16(x) > uint16(x + y);
	if (size == 4)
		return uint32(x) > uint32(x + y);
	return uint64(x) > uint64(x + y);
}

#else
						// The following definition is not quite correct because it always returns
						// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
						// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

						// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

						// In the decompilation listing there are some objects declarared as _UNKNOWN
						// because we could not determine their types. Since the C compiler does not
						// accept void item declarations, we replace them by anything of our choice,
						// for example a char:

#define _UNKNOWN char
struct uint128_t {
	uint64_t low;
	uint64_t high;
};
static uint8_t rol1(uint8_t x, unsigned int count) {
	count %= 8;
	return (x << count) | (x >> (8 - count));
}
static uint16_t __ROL2__(uint16_t x, unsigned int count) {
	count %= 16;
	return (x << count) | (x >> (16 - count));
}
static uint32_t __ROL4__(uint32_t x, unsigned int count) {
	count %= 32;
	return (x << count) | (x >> (32 - count));
}
static uint64_t rol8(uint64_t x, unsigned int count) {
	count %= 64;
	return (x << count) | (x >> (64 - count));
}
static uint8_t ror1(uint8_t x, unsigned int count) {
	count %= 8;
	return (x << (8 - count)) | (x >> count);
}
static uint16_t __ROR2__(uint16_t x, unsigned int count) {
	count %= 16;
	return (x << (16 - count)) | (x >> count);
}
static uint32_t __ROR4__(uint32_t x, unsigned int count) {
	count %= 32;
	return (x << (32 - count)) | (x >> count);
}
static uint64_t ror8(uint64_t x, unsigned int count) {
	count %= 64;
	return (x << (64 - count)) | (x >> count);
}
#ifdef _MSC_VER
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

```

`stdafx.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN
#define WIN32_EXTRA_LEAN

//define SETTEXTURE  65
//#define SETTEXTURESTAGESTATE  67

#include <windows.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <d3d9.h>
#include <d3dx9.h>


```

`xorstr.h`:

```h

#pragma once

template <int X> struct EnsureCompileTime {
	enum : int {
		Value = X
	};
};
#define Seed ((__TIME__[7] - '0') * 1  + (__TIME__[6] - '0') * 10  + \
	(__TIME__[4] - '0') * 60 + (__TIME__[3] - '0') * 600 + \
	(__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)

__forceinline constexpr int LinearCongruentGenerator(int Rounds) {
	return 2013904223 + 2664525 * ((Rounds > 0) ? LinearCongruentGenerator(Rounds - 1) : Seed & 0xFFFFFFFF);
}
#define Random() EnsureCompileTime<LinearCongruentGenerator(15)>::Value 
#define RandomNumber(Min, Max) (Min + (Random() % (Max - Min + 1)))
template <int... Pack> struct IndexList {};
template <typename IndexList, int Right> struct Append;
template <int... Left, int Right> struct Append<IndexList<Left...>, Right> {
	typedef IndexList<Left..., Right> Result;
};
template <int N> struct ConstructIndexList {
	typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <> struct ConstructIndexList<0> {
	typedef IndexList<> Result;
};
const char XORKEY_A = static_cast<char>(0x87);
const wchar_t XORKEY_W = static_cast<wchar_t>(0x531);
__declspec(noinline)  constexpr char EncryptCharacterA(const char Character, int Index) {
	return Character ^ (XORKEY_A + Index);
}
template <typename IndexList> class CingA;
template <int... Index> class CingA<IndexList<Index...> > {
private:
	char Value[sizeof...(Index) + 1];
public:
	__forceinline constexpr CingA(const char* const String)
		: Value{ EncryptCharacterA(String[Index], Index)... } {}

	__forceinline char* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEY_A + t);
		}
		Value[sizeof...(Index)] = '\0';
		return Value;
	}

	__forceinline char* get() {
		return Value;
	}
};
__declspec(noinline) constexpr wchar_t EncryptCharacterW(const wchar_t Character, int Index) {
	return Character ^ (XORKEY_W + Index);
}
template <typename IndexList> class CingW;
template <int... Index> class CingW<IndexList<Index...> > {
private:
	wchar_t Value[sizeof...(Index) + 1];
public:
	__forceinline constexpr CingW(const wchar_t* const String)
		: Value{ EncryptCharacterW(String[Index], Index)... } {}

	__forceinline wchar_t* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEY_W + t);
		}
		Value[sizeof...(Index)] = '\0\0';
		return Value;
	}

	__forceinline wchar_t* get() {
		return Value;
	}
};

#define xorstr_( String ) ( CingA<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )  
#define wxorstr_( String ) ( CingW<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )  

```