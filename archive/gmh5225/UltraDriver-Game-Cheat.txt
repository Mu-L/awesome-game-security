Project Path: arc_gmh5225_UltraDriver-Game-Cheat_w4slh7gl

Source Tree:

```txt
arc_gmh5225_UltraDriver-Game-Cheat_w4slh7gl
├── README.md
├── UltraDrv.sln
└── driver
    ├── comms.cpp
    ├── comms.hpp
    ├── driver.filters
    ├── driver.user
    ├── driver.vcxproj
    ├── driver.vcxproj.user
    ├── funcs.hpp
    ├── hash.hpp
    ├── hiding.hpp
    ├── hooks.cpp
    ├── hooks.hpp
    ├── ice.cpp
    ├── ice.h
    ├── includes.hpp
    ├── kaspersky.cpp
    ├── kaspersky.hpp
    ├── main.cpp
    ├── native.hpp
    ├── old_comms.cpp
    ├── old_comms.hpp
    ├── process.hpp
    ├── structs.hpp
    ├── utils.hpp
    └── xorstr.hpp

```

`README.md`:

```md
# UltraDriver GameCheat Driver


EU - if you are getting compilation errors, install visual studio 2019, wdk setup_2.exe install this. Make sure you download and run it afterwards.

TR - Derleme hataları alıyorsanız, visual studio 2019 kurun, wdk setup_2.exe bunu kurun. sonrasın da indirip çalıştırdığınızdan emin olun.


```

`UltraDrv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "test", "..\test\test.vcxproj", "{1EB20241-5827-46A9-B6AE-24EBA5209E5C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "driver\driver.vcxproj", "{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		release2|ARM = release2|ARM
		release2|ARM64 = release2|ARM64
		release2|x64 = release2|x64
		release2|x86 = release2|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|ARM.ActiveCfg = Debug|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|ARM64.ActiveCfg = Debug|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|x64.ActiveCfg = Debug|x64
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|x64.Build.0 = Debug|x64
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|x86.ActiveCfg = Debug|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Debug|x86.Build.0 = Debug|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|ARM.ActiveCfg = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|ARM64.ActiveCfg = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|x64.ActiveCfg = Release|x64
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|x64.Build.0 = Release|x64
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|x86.ActiveCfg = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.Release|x86.Build.0 = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.release2|ARM.ActiveCfg = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.release2|ARM64.ActiveCfg = Release|Win32
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.release2|x64.ActiveCfg = Release|x64
		{1EB20241-5827-46A9-B6AE-24EBA5209E5C}.release2|x86.ActiveCfg = Release|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM.ActiveCfg = Debug|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM.Build.0 = Debug|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM.Deploy.0 = Debug|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM64.Build.0 = Debug|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x64.ActiveCfg = Debug|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x64.Build.0 = Debug|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x64.Deploy.0 = Debug|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x86.ActiveCfg = Debug|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x86.Build.0 = Debug|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Debug|x86.Deploy.0 = Debug|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM.ActiveCfg = Release|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM.Build.0 = Release|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM.Deploy.0 = Release|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM64.ActiveCfg = Release|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM64.Build.0 = Release|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|ARM64.Deploy.0 = Release|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x64.ActiveCfg = Release|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x64.Build.0 = Release|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x64.Deploy.0 = Release|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x86.ActiveCfg = Release|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x86.Build.0 = Release|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.Release|x86.Deploy.0 = Release|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM.ActiveCfg = release2|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM.Build.0 = release2|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM.Deploy.0 = release2|ARM
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM64.ActiveCfg = release2|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM64.Build.0 = release2|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|ARM64.Deploy.0 = release2|ARM64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x64.ActiveCfg = release2|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x64.Build.0 = release2|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x64.Deploy.0 = release2|x64
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x86.ActiveCfg = release2|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x86.Build.0 = release2|Win32
		{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}.release2|x86.Deploy.0 = release2|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ABB679FD-6314-4A4C-8CEA-1F0C2A28B566}
	EndGlobalSection
EndGlobal

```

`driver/comms.cpp`:

```cpp
#include "includes.hpp"

namespace comms
{
	PEPROCESS process = nullptr;
	uintptr_t local_pid;
	void ProcessRequest(const comms::PMEMORY_OPERATION& pData )
	{
		switch ( pData->control_code )
		{

		case comms::control_codes::status:
		{
			pData->status = STATUS_SUCCESS;
			break;
		}

		case comms::control_codes::hide_window:
		{
			auto Ptr = reinterpret_cast< c_hide_window_request* >( pData->Data );
			if ( Ptr )
			{
				hooks::hMyHwndPid = Ptr->pid;
				hooks::hMyHwnd = Ptr->hwnd;

				/*if ( hooks::hMyHwnd )
				{
					const auto wnd = ValidateHwnd( reinterpret_cast< uintptr_t >( hooks::hMyHwnd ) );
					if ( wnd )
						*reinterpret_cast< uintptr_t* >( wnd + 0x68 ) = 0;
				}*/
				pData->status = STATUS_SUCCESS;
			}
			break;
		}

		case comms::control_codes::attach_process:
		{
			auto pAttachProcess = reinterpret_cast< comms::c_attach_process_request* >( pData->Data );
			if ( pAttachProcess )
			{
				DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "c_attach_process_request->processhash %lu\n", pAttachProcess->hash);
				process = process::find(pAttachProcess->hash);
				local_pid = FindProcess(L"RustClient.exe");
				pData->status = STATUS_SUCCESS;
			}
			break;
		}

		case comms::control_codes::detach_process:
		{
			process = nullptr;
			pData->status = STATUS_SUCCESS;
			break;
		}

		case comms::control_codes::find_module:
		{
			auto pFindModule = reinterpret_cast< comms::c_find_module_request* >( pData->Data );
			if (!pFindModule)
				DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "pFindModule = he is the nigger \n");

			if (!(process = process::find(h("RustClient.exe"))))
				DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Invalid Process.\n");
			
			if ( process && pFindModule )
			{
				const auto peb = PsGetProcessPeb( process );

				if (process::is_x86(process))
				{
					pFindModule->res = process::find_module_x86(process, peb, pFindModule->hash);
					DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "pFindModule->res %X\n", pFindModule->res);
				}
				else
				{
					pFindModule->res = process::find_module_x64(process, peb, pFindModule->hash);
					DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "pFindModule->res %X\n", pFindModule->res);
					
				}
			}
			else
			{
				DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "pFindModule = nigger \n");
			}
			break;
		}

		case comms::control_codes::key_state:
		{
			auto pGetKey = reinterpret_cast< comms::c_key_state_request* >( pData->Data );
			if ( pGetKey )
			{
				bool res = false;
				auto key = pGetKey->key;

				PEPROCESS Proc = nullptr;
				if ( NT_SUCCESS( PsLookupProcessByProcessId( HANDLE(local_pid), &Proc ) ) )
				{
					KAPC_STATE apc{ };
					KeStackAttachProcess( Proc, &apc );
					{
						res = NtGetAsyncKeyState( key );
					}
					KeUnstackDetachProcess( &apc );
					ObDereferenceObject( Proc );
				}

				pGetKey->res = res;
			}
			break;
		}

		case comms::control_codes::read:
		{
			auto pRead = reinterpret_cast< comms::c_read_write_request* >( pData->Data );
			if ( pRead )
			{
				pData->status = process::Read(local_pid, process, pRead->address, pRead->buffer, pRead->size);
			}
			break;
		}

		case comms::control_codes::write:
		{
			auto pWrite = reinterpret_cast< comms::c_read_write_request* >( pData->Data );
			if ( pWrite )
			{
				pData->status = process::Write(local_pid, process, pWrite->address, pWrite->buffer, pWrite->size );
			}
			break;
		}

		case comms::control_codes::read_injected:
		{
			auto pRead = reinterpret_cast< comms::c_read_write_request* >( pData->Data );
			if ( pRead )
			{
				pData->status = process::ReadInjected(local_pid, process, reinterpret_cast< uintptr_t >( pRead->address ), pRead->buffer );
			}
			break;
		}

		/*case comms::control_codes::write_read_only:
		{
			const auto request = reinterpret_cast < comms::c_change_prot_request* >( pData->Data );
			if ( request )
			{
				pData->status = process::ProtectVirtualMemory( reinterpret_cast< UINT_PTR >(process::find(h("RustClient.exe")), ( PVOID )request->address, sizeof( uintptr_t ), 0 );
			}
			break;
		}*/
		}
	}
}
```

`driver/comms.hpp`:

```hpp
#pragma once

namespace comms
{
	enum class control_codes : uint8_t
	{
		none,
		status,
		attach_process,
		detach_process,
		get_window_thread,
		set_window_thread,
		find_module,
		key_state,
		read,
		write,
		read_injected,
		hide_window,
		write_read_only
	};

	typedef struct _INOUT_SHAREDDATA
	{
		HANDLE ProcessId;
		HANDLE hEventUser;
		HANDLE hEventDriver;
		bool   Finish;
		bool   DataWritten;
	} INOUT_SHAREDDATA, * PINOUT_SHAREDDATA;

	typedef struct _MEMORY_OPERATION
	{
		uint32_t			  cookie;
		control_codes		  control_code;
		NTSTATUS              status;
		char                  Data[0x1000];
	} MEMORY_OPERATION, * PMEMORY_OPERATION;

	struct c_hide_window_request
	{
		HANDLE pid;
		HWND hwnd;

		c_hide_window_request()
		{
			this->pid = nullptr;
			this->hwnd = nullptr;
		}
	};

	struct c_attach_process_request
	{
		uint32_t hash;

		c_attach_process_request( const uint32_t hash ) : c_attach_process_request()
		{
			this->hash = hash;
		}
		c_attach_process_request()
		{
			this->hash = 0;
		}
	};

	struct c_detach_process_request
	{
		c_detach_process_request() = default;
	};

	struct c_get_window_thread_request
	{
		uintptr_t window_handle;
		uintptr_t res;

		c_get_window_thread_request( const uintptr_t window_handle ) : c_get_window_thread_request()
		{
			this->window_handle = window_handle;
		}
		c_get_window_thread_request()
		{
			this->window_handle = 0;
			this->res = 0;
		}
	};

	struct c_set_window_thread_request
	{
		uintptr_t target_window_handle;
		uintptr_t thread_pointer;

		c_set_window_thread_request( const uintptr_t window_handle, const uintptr_t thread_pointer ) : c_set_window_thread_request()
		{
			this->target_window_handle = window_handle;
			this->thread_pointer = thread_pointer;
		}
		c_set_window_thread_request()
		{
			this->target_window_handle = 0;
			this->thread_pointer = 0;
		}
	};

	struct c_find_module_request
	{
		uint32_t hash;
		uintptr_t res;

		c_find_module_request( const uint32_t hash ) : c_find_module_request()
		{
			this->hash = hash;
		}
		c_find_module_request()
		{
			this->hash = 0;
			this->res = 0;
		}
	};

	struct c_key_state_request
	{
		int key;
		bool res;

		c_key_state_request( const int key ) : c_key_state_request()
		{
			this->key = key;
		}

		c_key_state_request()
		{
			this->key = 0;
			this->res = false;
		}
	};

	struct c_read_write_request
	{
		void* address;
		void* buffer;
		size_t size;

		c_read_write_request(
			void* address,
			void* buffer,
			const size_t size ) : c_read_write_request()
		{
			this->address = address;
			this->buffer = buffer;
			this->size = size;
		}

		c_read_write_request()
		{
			this->address = 0;
			this->buffer = 0;
			this->size = 0;
		}
	};

	struct c_change_prot_request
	{
		uintptr_t address;

		c_change_prot_request(
			uintptr_t address
		) : c_change_prot_request()
		{
			this->address = address;
		}

		c_change_prot_request()
		{
			this->address = 0;
		}
	};

	extern void ProcessRequest(const comms::PMEMORY_OPERATION& pData );
}
```

`driver/driver.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="sex_rust.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imports.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt_structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`driver/driver.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>

```

`driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="release2|ARM">
      <Configuration>release2</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="release2|ARM64">
      <Configuration>release2</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="release2|Win32">
      <Configuration>release2</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="release2|x64">
      <Configuration>release2</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E0056B82-8322-45E8-94CF-8D2AAA3DA55C}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>
    </TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>sex_rust</RootNamespace>
    <ProjectName>driver</ProjectName>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet>
    </CharacterSet>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <OverrideTargetVersionDefines>
    </OverrideTargetVersionDefines>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|x64'" Label="Configuration">
    <TargetVersion />
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet />
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <OverrideTargetVersionDefines />
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)release\</OutDir>
    <TargetName>driver</TargetName>
    <TimeStampServer />
    <IntDir>$(SolutionDir)release\config\driver\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)\release\</OutDir>
    <TargetName>ricochet</TargetName>
    <TimeStampServer />
    <IntDir>$(SolutionDir)\release\config\driver\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
      <AdditionalDependencies>ntoskrnl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SetChecksum>false</SetChecksum>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <FixedBaseAddress>false</FixedBaseAddress>
      <TurnOffAssemblyGeneration>
      </TurnOffAssemblyGeneration>
      <SupportUnloadOfDelayLoadedDLL>
      </SupportUnloadOfDelayLoadedDLL>
      <SupportNobindOfDelayLoadedDLL>
      </SupportNobindOfDelayLoadedDLL>
      <StackReserveSize>
      </StackReserveSize>
      <StackCommitSize>
      </StackCommitSize>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ControlFlowGuard>false</ControlFlowGuard>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <Optimization>MaxSpeed</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
      <CallingConvention>Cdecl</CallingConvention>
      <TreatWarningAsError>false</TreatWarningAsError>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;_NO_CRT_STDIO_INLINE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <EnableModules>false</EnableModules>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <RemoveUnreferencedCodeData>true</RemoveUnreferencedCodeData>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='release2|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
      <AdditionalDependencies>ntoskrnl.lib;Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SetChecksum>false</SetChecksum>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <FixedBaseAddress>false</FixedBaseAddress>
      <TurnOffAssemblyGeneration>
      </TurnOffAssemblyGeneration>
      <SupportUnloadOfDelayLoadedDLL>
      </SupportUnloadOfDelayLoadedDLL>
      <SupportNobindOfDelayLoadedDLL>
      </SupportNobindOfDelayLoadedDLL>
      <StackReserveSize>
      </StackReserveSize>
      <StackCommitSize>
      </StackCommitSize>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ControlFlowGuard>false</ControlFlowGuard>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <Optimization>MaxSpeed</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
      <CallingConvention>Cdecl</CallingConvention>
      <TreatWarningAsError>false</TreatWarningAsError>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PreprocessorDefinitions>RICOCHET_DEBUG;_WIN64;_AMD64_;AMD64;_NO_CRT_STDIO_INLINE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>None</DebugInformationFormat>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <EnableModules>false</EnableModules>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <DisableSpecificWarnings>4201;4603;4627;4986;4987;4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <RemoveUnreferencedCodeData>true</RemoveUnreferencedCodeData>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <PrecompiledHeaderFile>stdafx.hpp</PrecompiledHeaderFile>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ClCompile>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="comms.hpp" />
    <ClInclude Include="engine\kernel.hpp" />
    <ClInclude Include="funcs.hpp" />
    <ClInclude Include="hash.hpp" />
    <ClInclude Include="hiding.hpp" />
    <ClInclude Include="hooks.hpp" />
    <ClInclude Include="ice.h" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="kaspersky.hpp" />
    <ClInclude Include="native.hpp" />
    <ClInclude Include="old_comms.hpp" />
    <ClInclude Include="process.hpp" />
    <ClInclude Include="structs.hpp" />
    <ClInclude Include="utils.hpp" />
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="comms.cpp" />
    <ClCompile Include="hooks.cpp" />
    <ClCompile Include="ice.cpp" />
    <ClCompile Include="kaspersky.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="old_comms.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`driver/driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
    <TestCertificate>
    </TestCertificate>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='release2|x64'">
    <SignMode>TestSign</SignMode>
    <TestCertificate />
  </PropertyGroup>
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`driver/funcs.hpp`:

```hpp
#pragma once

using EtwpIsProcessZombie_ = bool( NTAPI* )( PEPROCESS );
inline EtwpIsProcessZombie_ EtwpIsProcessZombie = NULL;

using PsGetNextProcess_ = PEPROCESS( NTAPI* )( PEPROCESS );
inline PsGetNextProcess_ PsGetNextProcess = NULL;

using NtGetAsyncKeyState_ = SHORT( NTAPI* )( INT );
inline NtGetAsyncKeyState_ NtGetAsyncKeyState = NULL;

using ValidateHwnd_ = uintptr_t( __stdcall* )( uintptr_t );
inline ValidateHwnd_ ValidateHwnd = NULL;

//using MiGetPteAddress_ = PMMPTE( NTAPI* )( PVOID );
//inline MiGetPteAddress_ MiGetPteAddress = NULL;

using PspThreadDelete_ = void ( NTAPI* )( void* );
inline PspThreadDelete_ PspThreadDelete = NULL;

inline RTL_AVL_TABLE* PiDDBCacheTbl = nullptr;

namespace funcs
{
	inline BOOLEAN SetupFunctions()
	{
		const auto PiDDBCacheTbl_rel = reinterpret_cast< uint8_t* >(
			utils::FindPattern( XS( "ntoskrnl.exe" ),
				XS( "PAGE" ),
				PUCHAR( "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x3D\x00\x00\x00\x00\x0F\x83" ),
				XS( "xxx????x????x????xx" ) ) );

		if ( !PiDDBCacheTbl_rel )
		{
			DbgOut( "PiDDBCacheTbl sig not found!" );
			return FALSE;
		}

		PiDDBCacheTbl = utils::resolve_mov< RTL_AVL_TABLE* >( PiDDBCacheTbl_rel );
		if ( !PiDDBCacheTbl )
		{
			DbgOut( "PiDDBCacheTbl sig not found!" );
			return FALSE;
		}

		PspThreadDelete = reinterpret_cast< PspThreadDelete_ >( utils::FindPattern( XS( "ntoskrnl.exe" ),
			XS( "PAGE" ),
			PUCHAR( "\x48\x89\x5C\x24\x00\x48\x89\x6C\x24\x00\x56\x57\x41\x54\x41\x56\x41\x57\x48\x83\xEC\x40\x48\x8B\xF9" ),
			XS( "xxxx?xxxx?xxxxxxxxxxxxxxx" ) ) );

		if ( !PspThreadDelete )
		{
			DbgOut( "PspThreadDelete sig not found!" );
			return FALSE;
		}

		/*MiGetPteAddress = reinterpret_cast< MiGetPteAddress_ >( utils::FindPattern( XS( "ntoskrnl.exe" ),
				XS( ".text" ),
				PUCHAR( "\x48\xC1\xE9\x09\x48\xB8\xF8\xFF\xFF\xFF\x7F\x00\x00\x00\x48\x23\xC8\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x03\xC1\xC3" ),
				XS( "xxxxxxxxxxxxxxxxxxx????????xxxx" ) ) );

		if ( !MiGetPteAddress )
		{
			DbgOut( "MiGetPteAddress sig not found!" );
			return FALSE;
		}*/

		EtwpIsProcessZombie = reinterpret_cast< EtwpIsProcessZombie_ >( utils::FindPattern( XS( "ntoskrnl.exe" ), XS( "PAGE" ), PUCHAR( "\x8B\x81\x00\x00\x00\x00\xA8\x04\x75\x00\x33\xC0" ), XS( "xx????xxx?xx" ) ) );
		if ( !EtwpIsProcessZombie )
		{
			DbgOut( "EtwpIsProcessZombie sig not found!" );
			return FALSE;
		}

		const auto PsGetNextProcess_rel = reinterpret_cast< uint8_t* >( utils::FindPattern( XS( "ntoskrnl.exe" ), XS( "PAGE" ), PUCHAR( "\x79\xDC\xE9" ), XS( "xxx" ) ) );
		if ( !PsGetNextProcess_rel )
		{
			DbgOut( "PsGetNextProcess sig not found!" );
			return FALSE;
		}

		PsGetNextProcess = utils::resolve_call< PsGetNextProcess_ >( utils::resolve_jxx( PsGetNextProcess_rel ) );
		if ( !PsGetNextProcess )
		{
			DbgOut( "PsGetNextProcess sig not found!" );
			return FALSE;
		}

		if ( auto win32k = utils::GetWinlogon() )
		{
			KAPC_STATE apc{ };
			KeStackAttachProcess( win32k, &apc );

			ValidateHwnd = reinterpret_cast< ValidateHwnd_ >( utils::FindExport( XS( "win32kbase.sys" ), XS( "ValidateHwnd" ) ) );
			if ( !ValidateHwnd )
			{
				DbgOut( "ValidateHwnd sig not found!" );
				return FALSE;
			}

			NtGetAsyncKeyState = reinterpret_cast< NtGetAsyncKeyState_ >( utils::FindExport( XS( "win32kbase.sys" ), XS( "_GetAsyncKeyState" ) ) );
			if ( !NtGetAsyncKeyState )
			{
				DbgOut( "NtGetAsyncKeyState sig not found!" );
				return FALSE;
			}

			KeUnstackDetachProcess( &apc );
			ObDereferenceObject( win32k );
		}

		//DbgOut( "MiGetPteAddress = 0x%p", MiGetPteAddress );
		DbgOut( "PspThreadDelete = 0x%p", PspThreadDelete );
		DbgOut( "PiDDBCacheTbl = 0x%p", PiDDBCacheTbl );
		DbgOut( "EtwpIsProcessZombie = 0x%p", EtwpIsProcessZombie );
		DbgOut( "PsGetNextProcess = 0x%p", PsGetNextProcess );
		DbgOut( "ValidateHwnd = 0x%p", ValidateHwnd );
		DbgOut( "NtGetAsyncKeyState = 0x%p", NtGetAsyncKeyState );
		return TRUE;
	}
}
```

`driver/hash.hpp`:

```hpp
#pragma once

template <unsigned int x> struct compile_time {
	enum : unsigned int {
		value = x
	};
};
#define h(str) compile_time<crypto::hash(str)>::value

namespace crypto
{
	template <typename t>
	constexpr unsigned int hash( const t string )
	{
		auto hash = 0xffffffff;
		auto pointer = string;
		while ( *pointer != '\0' )
		{
			hash ^= *pointer++;
			hash ^= 0x4447bbee;
			hash = ( hash >> 1 );
			hash ^= 0x092cd4af;
			hash += ( hash << 5 );
		}
		return hash;
	}
}
```

`driver/hiding.hpp`:

```hpp
#pragma once

inline ULONG_PTR DYN_PTE_BASE = 0;
inline ULONG_PTR DYN_PDE_BASE = 0;


inline PHANDLE_TABLE* pPspCidTable = nullptr;
inline f_ExpLookupHandleTableEntry ExpLookupHandleTableEntry = nullptr;

namespace hide
{
	inline void UnlinkFromListEntry(LIST_ENTRY* entry)
	{
		const auto prev = entry->Blink;
		const auto next = entry->Flink;
		prev->Flink = next;
		next->Blink = prev;

		entry->Flink = 0;
		entry->Blink = 0;
	}

	inline PMMPTE GetPTEForVA(IN PVOID pAddress)
	{
		PMMPTE pPDE = (PMMPTE)(((((ULONG_PTR)pAddress >> PDI_SHIFT) << PTE_SHIFT) & 0x3FFFFFF8ull) + DYN_PDE_BASE);
		if (pPDE->u.Hard.LargePage)
			return pPDE;

		return (PMMPTE)(((((ULONG_PTR)pAddress >> PTI_SHIFT) << PTE_SHIFT) & 0x7FFFFFFFF8ull) + DYN_PTE_BASE);
	}

	inline bool ClearPiDDBCache(const ULONG dwTimeDateStamp)
	{
		if (!PiDDBCacheTbl)
			return false;

		auto entry = PIDBB_CACHE_ENTRY{};
		entry.TimeDateStamp = dwTimeDateStamp;

		const auto list_entry = reinterpret_cast<PIDBB_CACHE_ENTRY*>(RtlLookupElementGenericTableAvl(PiDDBCacheTbl, &entry));
		if (!list_entry)
			return false;

		UnlinkFromListEntry(&list_entry->List);
		return (RtlDeleteElementGenericTableAvl(PiDDBCacheTbl, list_entry) == TRUE);
	}

	inline bool NullPFN(uintptr_t address, ULONG size)
	{
		PMDL pMDL = IoAllocateMdl((PVOID)address, size, FALSE, FALSE, NULL);

		if (!pMDL)
		{
			return false;
		}

		PPFN_NUMBER mdlPages = MmGetMdlPfnArray(pMDL);
		if (!mdlPages)
		{
			return false;
		}

		ULONG mdlPageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(pMDL), MmGetMdlByteCount(pMDL));

		ULONG nullPfn = 0x0;
		MM_COPY_ADDRESS sourceAddress = { 0 };
		sourceAddress.VirtualAddress = &nullPfn;

		for (ULONG i = 0; i < mdlPageCount; i++)
		{
			size_t bytes = 0;
			MmCopyMemory(&mdlPages[i], sourceAddress, sizeof(ULONG), MM_COPY_MEMORY_VIRTUAL, &bytes);
		}
		return true;
	}

	inline void NTAPI UInitialize()
	{
		KDDEBUGGER_DATA64 debuggerDataBlock = { 0 };
		KDDEBUGGER_DATA_ADDITION64 debuggerDataAddBlock = { 0 };

		CONTEXT Context = { 0 };
		PDUMP_HEADER DumpHeader = NULL;
		PKDDEBUGGER_DATA64 KdDebuggerDataBlock = NULL;
		PKDDEBUGGER_DATA_ADDITION64 KdDebuggerDataAdditionBlock = NULL;

		Context.ContextFlags = CONTEXT_FULL;
		RtlCaptureContext(&Context);
		DumpHeader = (PDUMP_HEADER)ExAllocatePool(NonPagedPool, DUMP_BLOCK_SIZE);
		if (NULL != DumpHeader)
		{
			KeCapturePersistentThreadState(&Context, NULL, 0, 0, 0, 0, 0, DumpHeader);
			KdDebuggerDataBlock = (PKDDEBUGGER_DATA64)((PUCHAR)DumpHeader + KDDEBUGGER_DATA_OFFSET);
			RtlCopyMemory(&debuggerDataBlock, KdDebuggerDataBlock, sizeof(KDDEBUGGER_DATA64));
			KdDebuggerDataAdditionBlock = (PKDDEBUGGER_DATA_ADDITION64)(KdDebuggerDataBlock + 1);
			RtlCopyMemory(&debuggerDataAddBlock, KdDebuggerDataAdditionBlock, sizeof(KDDEBUGGER_DATA_ADDITION64));

			ExFreePool(DumpHeader);
		}

		ULONGLONG mask = (1ll << (PHYSICAL_ADDRESS_BITS - 1)) - 1;
		DYN_PTE_BASE = (ULONG_PTR)debuggerDataAddBlock.PteBase;
		DYN_PDE_BASE = (ULONG_PTR)((debuggerDataAddBlock.PteBase & ~mask) | ((debuggerDataAddBlock.PteBase >> 9) & mask));
	}

	inline SIZE_T StartAddress = NULL;

	inline HANDLE CreateThread(PKSTART_ROUTINE Routine, PVOID Param = nullptr)
	{
		HANDLE hThread = nullptr;
		PsCreateSystemThread(&hThread, GENERIC_ALL, nullptr, nullptr, nullptr, PKSTART_ROUTINE(Routine), Param);

		return hThread;
	}

	inline HANDLE CreateThreadSpoofed(PVOID StartRoutine)
	{
		if (!StartRoutine)
			return NULL;

		if (!StartAddress)
		{
			LARGE_INTEGER li{ };
			KeQueryTickCount(&li);
			const auto val = 1 + (RtlRandomEx(&li.LowPart) % INT_MAX);

			if (val % 2)
				StartAddress = utils::FindPattern(XS("ntoskrnl.exe"), XS("PAGE"), PBYTE("\xFF\xE1"), XS("xx"));
			else
				StartAddress = utils::FindPattern(XS("ntoskrnl.exe"), XS(".text"), PBYTE("\xFF\xE1"), XS("xx"));
		}

		if (!StartAddress)
		{
			DbgOut("Failed to find a address to spoof thread!");
			return NULL;
		}

		HANDLE hThread = nullptr;
		auto status = PsCreateSystemThread(&hThread, GENERIC_ALL, nullptr, nullptr, nullptr, PKSTART_ROUTINE(StartAddress), StartRoutine);
		return status ? hThread : NULL;
	}

	inline UCHAR GetMiscFlagsOffset()
	{
		static UCHAR offset = 0;

		if (!offset)
		{
			auto addr = PUCHAR(&PsIsSystemThread);

			offset = *reinterpret_cast<PUCHAR>(addr + 2);
		}
		return offset;
	}
	inline bool HideThreadPspCidTable(HANDLE Handle, PCID_TABLE_HIDDEN_THREAD Data)
	{
		if (!pPspCidTable || !ExpLookupHandleTableEntry || !Data)
			return false;

		auto Entry = ExpLookupHandleTableEntry(*pPspCidTable, Handle);

		if (!Entry)
			return false;

		PETHREAD dummyThread = nullptr;
		HANDLE DummyThreadId = nullptr;

		for (uintptr_t i = 0x100; i < 0x3000; i += 4)
		{
			if (NT_SUCCESS(PsLookupThreadByThreadId(reinterpret_cast<HANDLE>(i), &dummyThread)))
			{
				ObDereferenceObject(dummyThread);

				if (reinterpret_cast<HANDLE>(i) != reinterpret_cast<HANDLE>(Handle) && PsIsSystemThread(dummyThread))
				{
					DummyThreadId = reinterpret_cast<HANDLE>(i);
					break;
				}
			}

		}

		if (!DummyThreadId)
			return false;

		auto pobject_header = reinterpret_cast<POBJECT_HEADER>(reinterpret_cast<uintptr_t>(dummyThread) - sizeof(OBJECT_HEADER));

		auto pdummy_thread = reinterpret_cast<POBJECT_HEADER>(ExAllocatePoolWithTag(NonPagedPoolNx, 0x1000, 0x65726854));

		if (!pdummy_thread)
			return false;

		memcpy(pdummy_thread, pobject_header, 0x1000);

		pdummy_thread->HandleCount = 6334;
		pdummy_thread->PointerCount = 6334;

		auto Entry2 = ExpLookupHandleTableEntry(*pPspCidTable, DummyThreadId);

		if (!Entry2)
		{
			ExFreePoolWithTag(pdummy_thread, 0x65726854);
			return false;
		}

		HANDLE_TABLE_ENTRY entry = { 0 };

		memcpy(&Data->OldEntry, Entry, sizeof(HANDLE_TABLE_ENTRY));
		memcpy(&entry, Entry2, sizeof(HANDLE_TABLE_ENTRY));

		entry.ObjectPointerBits = (reinterpret_cast<INT64>(pdummy_thread) + sizeof(OBJECT_HEADER)) >> 4;

		// PsIsSystemThread will fail
		{
			auto BitFlag = reinterpret_cast<PDWORD>(PUCHAR(PsGetCurrentThread()) + GetMiscFlagsOffset());
			*BitFlag &= ~(1 << 10);
		}

		memcpy(Entry, &entry, sizeof(HANDLE_TABLE_ENTRY));

		Data->DummyEThread = pdummy_thread;

		return true;
	}

	inline void RestoreThreadHandlePspCidTable(HANDLE Handle, PCID_TABLE_HIDDEN_THREAD Data)
	{
		if (!pPspCidTable || !ExpLookupHandleTableEntry || !Data)
			return;

		auto Entry = ExpLookupHandleTableEntry(*pPspCidTable, Handle);

		if (!Entry)
			return;

		memcpy(Entry, &Data->OldEntry, sizeof(HANDLE_TABLE_ENTRY));

		ExFreePoolWithTag(Data->DummyEThread, 0x65726854);
	}
}
```

`driver/hooks.cpp`:

```cpp
#include "includes.hpp"

```

`driver/hooks.hpp`:

```hpp
#pragma once

namespace hooks
{
	using NtUserWindowFromPoint_ = HWND( NTAPI* )( LONG, LONG );
	extern NtUserWindowFromPoint_ oNtUserWindowFromPoint;
	extern HWND NTAPI hkNtUserWindowFromPoint( LONG x, LONG y );

	using NtUserQueryWindow_ = HANDLE( NTAPI* )( HWND, WINDOWINFOCLASS );
	extern NtUserQueryWindow_ oNtUserQueryWindow;
	extern HANDLE NTAPI hkNtUserQueryWindow( HWND WindowHandle, WINDOWINFOCLASS WindowInfo );

	using NtUserFindWindowEx_ = HWND( NTAPI* )( HWND, HWND, PUNICODE_STRING, PUNICODE_STRING, DWORD );
	extern NtUserFindWindowEx_ oNtUserFindWindowEx;
	extern HWND NTAPI hkNtUserFindWindowEx( HWND hWndParent, HWND hWndChildAfter, PUNICODE_STRING lpszClass, PUNICODE_STRING lpszWindow, DWORD dwType );

	using NtUserBuildHwndList_ = NTSTATUS( NTAPI* )( HDESK, HWND, BOOLEAN, BOOLEAN, ULONG, ULONG, HWND*, PULONG );
	extern NtUserBuildHwndList_ oNtUserBuildHwndList;
	extern NTSTATUS NTAPI hkNtUserBuildHwndList( HDESK hDesktop, HWND hwndParent, BOOLEAN bChildren, BOOLEAN bUnknownFlag, ULONG dwThreadId, ULONG lParam, HWND* pWnd, PULONG pBufSize );

	using NtUserGetForegroundWindow_ = HWND( NTAPI* )( );
	extern NtUserGetForegroundWindow_ oNtUserGetForegroundWindow;
	extern HWND NTAPI hkNtUserGetForegroundWindow( );

	using NtQueryInformationAtom_ = NTSTATUS( NTAPI* )( IN RTL_ATOM, IN ATOM_INFORMATION_CLASS, OUT PVOID, IN ULONG, OUT PULONG OPTIONAL );
	extern NtQueryInformationAtom_ oNtQueryInformationAtom;
	extern NTSTATUS NTAPI hkNtQueryInformationAtom( IN RTL_ATOM Atom, IN ATOM_INFORMATION_CLASS AtomInformationClass, OUT PVOID AtomInformation, IN ULONG AtomInformationLength, OUT PULONG ReturnLength OPTIONAL );

	inline HANDLE hMyHwndPid = nullptr;
	inline HWND hMyHwnd = nullptr;
}
```

`driver/ice.cpp`:

```cpp
#include "ice.h"

/* Structure of a single round subkey */
class IceSubkey {
public:
	unsigned long	val[ 3 ];
};

namespace {
	/* The S-boxes */
	unsigned long ice_sbox[ 4 ][ 1024 ];
	int ice_sboxes_initialised = 0;


	/* Modulo values for the S-boxes */
	const int ice_smod[ 4 ][ 4 ] = {
		{333, 313, 505, 369},
		{379, 375, 319, 391},
		{361, 445, 451, 397},
		{397, 425, 395, 505}
	};

	/* XOR values for the S-boxes */
	const int ice_sxor[ 4 ][ 4 ] = {
		{0x83, 0x85, 0x9b, 0xcd},
		{0xcc, 0xa7, 0xad, 0x41},
		{0x4b, 0x2e, 0xd4, 0x33},
		{0xea, 0xcb, 0x2e, 0x04}
	};

	/* Permutation values for the P-box */
	const unsigned long ice_pbox[ 32 ] = {
		0x00000001, 0x00000080, 0x00000400, 0x00002000,
		0x00080000, 0x00200000, 0x01000000, 0x40000000,
		0x00000008, 0x00000020, 0x00000100, 0x00004000,
		0x00010000, 0x00800000, 0x04000000, 0x20000000,
		0x00000004, 0x00000010, 0x00000200, 0x00008000,
		0x00020000, 0x00400000, 0x08000000, 0x10000000,
		0x00000002, 0x00000040, 0x00000800, 0x00001000,
		0x00040000, 0x00100000, 0x02000000, 0x80000000
	};

	/* The key rotation schedule */
	const int ice_keyrot[ 16 ] = {
		0, 1, 2, 3, 2, 1, 3, 0,
		1, 3, 2, 0, 3, 1, 0, 2
	};


	/*
	 * 8-bit Galois Field multiplication of a by b, modulo m.
	 * Just like arithmetic multiplication, except that additions and
	 * subtractions are replaced by XOR.
	 */

	unsigned int gf_mult( unsigned int a, unsigned int b, unsigned int m )
	{
		unsigned int res = 0;

		while ( b ) {
			if ( b & 1 )
				res ^= a;

			a <<= 1;
			b >>= 1;

			if ( a >= 256 )
				a ^= m;
		}

		return ( res );
	}


	/*
	 * Galois Field exponentiation.
	 * Raise the base to the power of 7, modulo m.
	 */

	unsigned long gf_exp7( unsigned int b, unsigned int m )
	{
		unsigned int x;

		if ( b == 0 )
			return ( 0 );

		x = gf_mult( b, b, m );
		x = gf_mult( b, x, m );
		x = gf_mult( x, x, m );
		return ( gf_mult( b, x, m ) );
	}


	/*
	 * Carry out the ICE 32-bit P-box permutation.
	 */

	unsigned long ice_perm32( unsigned long	x )
	{
		unsigned long res = 0;
		const unsigned long* pbox = ice_pbox;

		while ( x ) {
			if ( x & 1 )
				res |= *pbox;
			pbox++;
			x >>= 1;
		}

		return ( res );
	}


	/*
	 * Initialise the ICE S-boxes.
	 * This only has to be done once.
	 */

	void ice_sboxes_init()
	{
		int i;

		for ( i = 0; i < 1024; i++ ) {
			int col = ( i >> 1 ) & 0xff;
			int row = ( i & 0x1 ) | ( ( i & 0x200 ) >> 8 );
			unsigned long x;

			x = gf_exp7( col ^ ice_sxor[ 0 ][ row ], ice_smod[ 0 ][ row ] ) << 24;
			ice_sbox[ 0 ][ i ] = ice_perm32( x );

			x = gf_exp7( col ^ ice_sxor[ 1 ][ row ], ice_smod[ 1 ][ row ] ) << 16;
			ice_sbox[ 1 ][ i ] = ice_perm32( x );

			x = gf_exp7( col ^ ice_sxor[ 2 ][ row ], ice_smod[ 2 ][ row ] ) << 8;
			ice_sbox[ 2 ][ i ] = ice_perm32( x );

			x = gf_exp7( col ^ ice_sxor[ 3 ][ row ], ice_smod[ 3 ][ row ] );
			ice_sbox[ 3 ][ i ] = ice_perm32( x );
		}
	}
}

/*
 * Create a new ICE key.
 */

IceKey::IceKey( int n )
{
	if ( !ice_sboxes_initialised ) {
		ice_sboxes_init();
		ice_sboxes_initialised = 1;
	}

	if ( n < 1 ) {
		_size = 1;
		_rounds = 8;
	}
	else {
		_size = n;
		_rounds = n * 16;
	}

	_keysched = reinterpret_cast< IceSubkey* >( ExAllocatePool( NonPagedPool, _rounds ) );
	
	const unsigned char decrypction_key[ 8 ] = { 0x51, 0xF3, 0x0F, 0x11, 0x04, 0x24, 0x6A, 0x00 };
	this->set( decrypction_key );
}

/*
 * Destroy an ICE key.
 */

IceKey::~IceKey()
{
	int	i, j;

	for ( i = 0; i < _rounds; i++ )
		for ( j = 0; j < 3; j++ )
			_keysched[ i ].val[ j ] = 0;

	_rounds = _size = 0;

	ExFreePool( _keysched );
}


/*
 * The single round ICE f function.
 */
namespace {
	unsigned long ice_f( unsigned long p, const IceSubkey* sk )
	{
		unsigned long tl, tr;		/* Expanded 40-bit values */
		unsigned long al, ar;		/* Salted expanded 40-bit values */

		/* Left half expansion */
		tl = ( ( p >> 16 ) & 0x3ff ) | ( ( ( p >> 14 ) | ( p << 18 ) ) & 0xffc00 );

		/* Right half expansion */
		tr = ( p & 0x3ff ) | ( ( p << 2 ) & 0xffc00 );

		/* Perform the salt permutation */
		// al = (tr & sk->val[2]) | (tl & ~sk->val[2]);
		// ar = (tl & sk->val[2]) | (tr & ~sk->val[2]);
		al = sk->val[ 2 ] & ( tl ^ tr );
		ar = al ^ tr;
		al ^= tl;

		al ^= sk->val[ 0 ];		/* XOR with the subkey */
		ar ^= sk->val[ 1 ];

		/* S-box lookup and permutation */
		return ( ice_sbox[ 0 ][ al >> 10 ] | ice_sbox[ 1 ][ al & 0x3ff ] | ice_sbox[ 2 ][ ar >> 10 ] | ice_sbox[ 3 ][ ar & 0x3ff ] );
	}
}

/*
 * Encrypt a block of 8 bytes of data with the given ICE key.
 */

void IceKey::encrypt( const unsigned char* ptext, unsigned char* ctext ) const
{
	int i;
	unsigned long l, r;

	l = ( ( ( unsigned long )ptext[ 0 ] ) << 24 )
		| ( ( ( unsigned long )ptext[ 1 ] ) << 16 )
		| ( ( ( unsigned long )ptext[ 2 ] ) << 8 )
		| ptext[ 3 ];
	r = ( ( ( unsigned long )ptext[ 4 ] ) << 24 )
		| ( ( ( unsigned long )ptext[ 5 ] ) << 16 )
		| ( ( ( unsigned long )ptext[ 6 ] ) << 8 )
		| ptext[ 7 ];

	for ( i = 0; i < _rounds; i += 2 ) {
		l ^= ice_f( r, &_keysched[ i ] );
		r ^= ice_f( l, &_keysched[ i + 1 ] );
	}

	for ( i = 0; i < 4; i++ ) {
		ctext[ 3 - i ] = r & 0xff;
		ctext[ 7 - i ] = l & 0xff;

		r >>= 8;
		l >>= 8;
	}
}


/*
 * Decrypt a block of 8 bytes of data with the given ICE key.
 */

void IceKey::decrypt( const unsigned char* ctext, unsigned char* ptext ) const
{
	int i;
	unsigned long l, r;

	l = ( ( ( unsigned long )ctext[ 0 ] ) << 24 )
		| ( ( ( unsigned long )ctext[ 1 ] ) << 16 )
		| ( ( ( unsigned long )ctext[ 2 ] ) << 8 )
		| ctext[ 3 ];
	r = ( ( ( unsigned long )ctext[ 4 ] ) << 24 )
		| ( ( ( unsigned long )ctext[ 5 ] ) << 16 )
		| ( ( ( unsigned long )ctext[ 6 ] ) << 8 )
		| ctext[ 7 ];

	for ( i = _rounds - 1; i > 0; i -= 2 ) {
		l ^= ice_f( r, &_keysched[ i ] );
		r ^= ice_f( l, &_keysched[ i - 1 ] );
	}

	for ( i = 0; i < 4; i++ ) {
		ptext[ 3 - i ] = r & 0xff;
		ptext[ 7 - i ] = l & 0xff;

		r >>= 8;
		l >>= 8;
	}
}


/*
 * Set 8 rounds [n, n+7] of the key schedule of an ICE key.
 */

void IceKey::scheduleBuild( unsigned short* kb, int n, const int* keyrot )
{
	int i;

	for ( i = 0; i < 8; i++ ) {
		int j;
		int kr = keyrot[ i ];
		IceSubkey* isk = &_keysched[ n + i ];

		for ( j = 0; j < 3; j++ )
			isk->val[ j ] = 0;

		for ( j = 0; j < 15; j++ ) {
			int k;
			unsigned long* curr_sk = &isk->val[ j % 3 ];

			for ( k = 0; k < 4; k++ ) {
				unsigned short* curr_kb = &kb[ ( kr + k ) & 3 ];
				auto bit = *curr_kb & 1;

				*curr_sk = ( *curr_sk << 1 ) | bit;
				*curr_kb = static_cast< unsigned short >( ( *curr_kb >> 1 ) | ( ( bit ^ 1 ) << 15 ) );
			}
		}
	}
}


/*
 * Set the key schedule of an ICE key.
 */

void IceKey::set( const unsigned char* key )
{
	int i;

	if ( _rounds == 8 ) {
		unsigned short kb[ 4 ];

		for ( i = 0; i < 4; i++ )
			kb[ 3 - i ] = ( key[ i * 2 ] << 8 ) | key[ i * 2 + 1 ];

		scheduleBuild( kb, 0, ice_keyrot );
		return;
	}

	for ( i = 0; i < _size; i++ ) {
		int j;
		unsigned short kb[ 4 ];

		for ( j = 0; j < 4; j++ )
			kb[ 3 - j ] = ( key[ i * 8 + j * 2 ] << 8 ) | key[ i * 8 + j * 2 + 1 ];

		scheduleBuild( kb, i * 8, ice_keyrot );
		scheduleBuild( kb, _rounds - 8 - i * 8, &ice_keyrot[ 8 ] );
	}
}


/*
 * Return the key size, in bytes.
 */

int IceKey::keySize() const
{
	return ( _size * 8 );
}


/*
 * Return the block size, in bytes.
 */

int IceKey::blockSize() const
{
	return ( 8 );
}
```

`driver/ice.h`:

```h
#pragma once

#include <ntifs.h>
class IceSubkey;

class IceKey 
{
public:
	IceKey( int n );
	~IceKey();

	void set( const unsigned char* key );
	void encrypt( const unsigned char* plaintext, unsigned char* ciphertext ) const;
	void decrypt( const unsigned char* ciphertext, unsigned char* plaintext ) const;
	int keySize() const;
	int blockSize() const;

private:
	void scheduleBuild( unsigned short* k, int n, const int* keyrot );

	int _size;
	int _rounds;
	IceSubkey* _keysched;
};
```

`driver/includes.hpp`:

```hpp
#pragma once

#ifdef DRIVER_DEBUG_MODE
#define DbgOut(x, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[UltraDrv] " x "\n", __VA_ARGS__)
#else
#define DbgOut(x, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[RUST] " x "\n", __VA_ARGS__) //
#endif

#include <ntifs.h>
#include <ntimage.h>
#include <windef.h>

//inline unsigned char jmp_cave[] = { 0x50, 0x48, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0xEF, 0xBE, 0xAD, 0xDE, 0x48, 0x87, 0x04, 0x24, 0xC3 };

#include "native.hpp"
#include "xorstr.hpp"

#include "utils.hpp"
#include "funcs.hpp"

//#include "kaspersky.hpp"
#include "process.hpp"
#include "comms.hpp"
#include "hooks.hpp"

#include "hiding.hpp"
typedef struct _PORT_INFORMATION
{
	ULONG64		MagicValue;		// 0x0000 
	ULONG64		Lock;			// 0x0008
	PVOID		BufferStruct;	// 0x0010
} PORT_INFORMATION, * PPORT_INFORMATION;
```

`driver/kaspersky.hpp`:

```hpp
#pragma once

using f_SetHvmEvent = NTSTATUS( * )( );

namespace kaspersky
{
	extern PVOID	GetNtRoutineByIndex		( UINT Index );
	extern PVOID	GetWin32kRoutineByIndex	( UINT Index );
	extern BOOLEAN	HookNtRoutine			( UINT Index, LPVOID lpDest, LPVOID* lpOriginal );
	extern BOOLEAN	HookWin32kRoutine		( UINT Index, LPVOID lpDest, LPVOID* lpOriginal );
	extern BOOLEAN	SetupKaspersky			( );
	extern BOOLEAN  IsKasperskyHooked		( );
}
```

`driver/main.cpp`:

```cpp
#include "includes.hpp"
#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))
EXTERN_C int _fltused = 0;




UINT NtUserQueryWindow_idx = 0, NtUserFindWindowEx_idx = 0, NtUserWindowFromPoint_idx = 0, NtUserBuildHwndList_idx = 0, NtUserGetForegroundWindow_idx = 0;
UINT NtQueryInformationAtom_idx = 0;

#define DebugPrint( X, ... ) DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, X, __VA_ARGS__ )




/*
 * This checks your usermode process' PEB for an available msg
 * this function will call your existing drv control function
 */

const ULONG PebPortOffset = 0x900;
const ULONG64 MagicValue = 0x123456789;
VOID ProcessPort(PEPROCESS Process)
{
	KAPC_STATE State;
	KeStackAttachProcess(Process, &State);

	// Get process port information
	ULONG_PTR Peb = PsGetProcessPeb(Process);
	PPORT_INFORMATION PortInformation = PPORT_INFORMATION(ULONG_PTR(Peb) + PebPortOffset);

	// Has a port been built in this process?

	const ULONG64 MagicValue = 0x123456789;

	// Is there a msg available for reading?

	if (PortInformation->Lock == 0)
	{
		KeUnstackDetachProcess(&State);
		return;
	}

	// Does struct ptr exist?

	if (PortInformation->BufferStruct == nullptr)
	{
		KeUnstackDetachProcess(&State);
		return;
	}



	auto pData = reinterpret_cast<comms::PMEMORY_OPERATION>(reinterpret_cast<comms::PINOUT_SHAREDDATA>(PortInformation->BufferStruct));
	
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "c_base_request->cookie %lu\n", pData->cookie);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "c_base_request->control_code %lu\n", pData->control_code);

	PortInformation->Lock = 0;
	comms::ProcessRequest(pData);
	


	KeUnstackDetachProcess(&State);

	return;
}

/*
 * Uncomment the hidden thread call
 * Replace util_client.exe with whatever you're injecting into
 */

 VOID PortThread(PVOID Context)
{
	UNREFERENCED_PARAMETER(Context);
	CID_TABLE_HIDDEN_THREAD Entry = { 0 };
	if (!hide::HideThreadPspCidTable(PsGetCurrentThreadId(), &Entry))
		return;
	DebugPrint("[-] PortThread\n");
	ULONG Counter = 0;


	//rustclient.exe //notepad.exe, 27420, , , 3.01 MB, DESKTOP-28394\Jordan, Notepad

	ULONG UniqueProcessId = FindProcess(L"RustClient.exe");
	if (!UniqueProcessId)
		return;

	PEPROCESS Process = NULL;
	NTSTATUS  Status = PsLookupProcessByProcessId(HANDLE(UniqueProcessId), &Process);

	if (!NT_SUCCESS(Status))
		return;

	while (1)
	{
		

	
		DebugPrint( "[-] Kernel thread tick %lu \n",Counter );
		
		if (!UniqueProcessId)
		{
			ULONG UniqueProcessId = FindProcess(L"RustClient.exe");
			return;
		}

		if (!NT_SUCCESS(Status))
		{
			 Status = PsLookupProcessByProcessId(HANDLE(UniqueProcessId), &Process);
			return;
		}
			
	
	
		// Main routine that parses the message

		ProcessPort(Process);
		Counter++;
		hide::RestoreThreadHandlePspCidTable(PsGetCurrentThreadId(), &Entry);
	}
	hide::RestoreThreadHandlePspCidTable(PsGetCurrentThreadId(), &Entry);
	PsTerminateSystemThread(STATUS_SUCCESS);
}

/*
 * Call this in driver entry
 *
 */

NTSTATUS CreatePortThread()
{
	HANDLE hThread = NULL;

	NTSTATUS Status = PsCreateSystemThread(
		&hThread,
		THREAD_ALL_ACCESS,
		NULL,
		NULL,
		NULL,
		PortThread,
		NULL
	);

	if (!NT_SUCCESS(Status))
	{
		DebugPrint("[!] Failed to start thread\n");
		return NULL;
	}

	return STATUS_SUCCESS;
}


EXTERN_C NTSTATUS DriverEntry( PVOID pArgs )
{
	UNREFERENCED_PARAMETER( pArgs );

	if ( !funcs::SetupFunctions() )
		return STATUS_FAILED_DRIVER_ENTRY;

	/*
	if ( !kaspersky::SetupKaspersky() )
		return STATUS_FAILED_DRIVER_ENTRY;

	DbgOut( "Kaspersky was correctly set-up!" );

	DbgOut( "Trying to hook syscalls" );
	Get_SSDTIndexes();
	Setup_ShadowSSDT();
	*/
	
	hide::CreateThreadSpoofed(CreatePortThread);
	

#if DRIVER_DEBUG_MODE
	const auto DriverObject = PDRIVER_OBJECT( pArgs );
	DriverObject->DriverUnload = DriverUnload;
#else


	hide::UInitialize();
	//hide::ClearPiDDBCache( pData->ToCleanTimeStamp );
	//hide::NullPFN( pData->BaseAddress, pData->ModuleSize );

	//memset( pData, 0, sizeof( MAPPED_DRIVER_DATA ) );
	//ExFreePool( pData );
#endif

	return STATUS_SUCCESS;
}
```

`driver/native.hpp`:

```hpp
#pragma once

#include "structs.hpp"

EXTERN_C_START

	NTSYSAPI ERESOURCE PsLoadedModuleResource;
	NTSYSAPI POBJECT_TYPE* IoDriverObjectType;
	NTSYSAPI POBJECT_TYPE* IoDeviceObjectType;
	NTSYSAPI KLDR_DATA_TABLE_ENTRY* PsLoadedModuleList;

	NTSYSAPI NTSTATUS			NTAPI ZwQuerySystemInformation( SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG );
	NTSYSAPI PCHAR				NTAPI PsGetProcessImageFileName( PEPROCESS );
	NTSYSAPI ULONG_PTR			NTAPI PsGetProcessPeb( PEPROCESS );
	NTSYSAPI NTSTATUS			NTAPI MmCopyVirtualMemory( PEPROCESS, PVOID, PEPROCESS, PVOID, SIZE_T, KPROCESSOR_MODE, PSIZE_T );
	NTSYSAPI NTSTATUS			NTAPI ObReferenceObjectByName( UNICODE_STRING*, ULONG, PACCESS_STATE, ACCESS_MASK, POBJECT_TYPE, KPROCESSOR_MODE, PVOID, PVOID* );
	NTSYSAPI PVOID				NTAPI RtlFindExportedRoutineByName( PVOID, LPCSTR );
	NTSYSAPI PVOID				NTAPI PsGetProcessWow64Process( PEPROCESS );
	NTSYSAPI PIMAGE_NT_HEADERS	NTAPI RtlImageNtHeader( PVOID );
	NTSYSAPI NTSTATUS			NTAPI ZwProtectVirtualMemory( HANDLE, PVOID*, PSIZE_T, ULONG, PULONG );
	NTSYSAPI PVOID				NTAPI PsGetProcessSectionBaseAddress( PEPROCESS );
	NTSYSAPI ULONG				NTAPI KeCapturePersistentThreadState( PCONTEXT Context, PKTHREAD Thread, ULONG BugCheckCode, ULONG BugCheckParameter1, ULONG BugCheckParameter2, ULONG BugCheckParameter3, ULONG BugCheckParameter4, PVOID VirtualAddress );

EXTERN_C_END;
```

`driver/old_comms.cpp`:

```cpp
//#include "includes.hpp"
//
////using FastIoDispatcher_ = BOOLEAN( NTAPI* )( struct _FILE_OBJECT*, BOOLEAN, PVOID, ULONG, PVOID, ULONG, ULONG, PIO_STATUS_BLOCK, struct _DEVICE_OBJECT* );
////FastIoDispatcher_ oFastIoDispatcher = NULL;
////
////BOOLEAN IoDispatcher( struct _FILE_OBJECT* FileObject, BOOLEAN Wait, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLenght, ULONG IoControlCode, PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT* DeviceObject );
//
//namespace comms
//{
//	static PEPROCESS process = nullptr;
//
//	BOOLEAN HandleRequest( const PSEND_DATA_INFO& pBuf )
//	{
//		DbgOut( "HandleRequest - given id = %d", pBuf->id );
//
//		BOOLEAN bResult = FALSE;
//
//		switch ( pBuf->id )
//		{
//		case SendDataIds::HideWindow:
//		{
//			auto Ptr = reinterpret_cast< CHideWindowRequest* >( pBuf->Buffer );
//			if ( Ptr )
//			{
//				hooks::hMyHwndPid = Ptr->pid;
//				hooks::hMyHwnd = Ptr->hwnd;
//
//				/*if ( hooks::hMyHwnd )
//				{
//					const auto wnd = ValidateHwnd( reinterpret_cast< uintptr_t >( hooks::hMyHwnd ) );
//					if ( wnd )
//						*reinterpret_cast< uintptr_t* >( wnd + 0x68 ) = 0;
//				}*/
//
//				DbgOut( "HandleRequest - HideWindow pid = 0x%p, hwnd = 0x%p", hooks::hMyHwndPid, hooks::hMyHwnd );
//				bResult = TRUE;
//			}
//			break;
//		}
//
//		case SendDataIds::Attach:
//		{
//			auto pAttachProcess = reinterpret_cast< CAttachProcessRequest* >( pBuf->Buffer );
//			if ( pAttachProcess )
//			{
//				DbgOut( "HandleRequest - Attach with hash = 0x%X", pAttachProcess->hash );
//
//				process = process::find( pAttachProcess->hash );
//				if ( process )
//					bResult = TRUE;
//			}
//			break;
//		}
//
//		case SendDataIds::Detach:
//		{
//			if ( process )
//			{
//				DbgOut( "HandleRequest - Detach" );
//				process = nullptr;
//				bResult = TRUE;
//			}
//			break;
//		}
//
//		case SendDataIds::FindModule:
//		{
//			auto pFindModule = reinterpret_cast< CFindModuleRequest* >( pBuf->Buffer );
//			if ( process && pFindModule )
//			{
//				const auto peb = PsGetProcessPeb( process );
//				if ( process::is_x86( process ) )
//					*pFindModule->res = process::find_module_x86( process, peb, pFindModule->hash );
//				else
//					*pFindModule->res = process::find_module_x64( process, peb, pFindModule->hash );
//
//				DbgOut( "HandleRequest - FindModule with hash = 0x%X, res = 0x%llX", pFindModule->hash, *pFindModule->res );
//				bResult = TRUE;
//			}
//			break;
//		}
//
//		case SendDataIds::KeyState:
//		{
//			auto pGetKey = reinterpret_cast< CGetKeyStateRequest* >( pBuf->Buffer );
//			if ( pGetKey )
//			{
//				bool res = false;
//				auto key = pGetKey->key;
//
//				//KAPC_STATE apc{ };
//				//KeStackAttachProcess( process, &apc );
//				{
//					res = NtGetAsyncKeyState( key );
//				}
//				//KeUnstackDetachProcess( &apc );
//
//				*pGetKey->res = res;
//				bResult = TRUE;
//			}
//			break;
//		}
//
//		case SendDataIds::Read:
//		{
//			auto pRead = reinterpret_cast< CReadWriteRequest* >( pBuf->Buffer );
//			if ( pRead )
//			{
//				DbgOut( "HandleRequest - Read address = 0x%p, buffer = 0x%p, size = 0x%llX", pRead->address, pRead->buffer, pRead->size );
//				bResult = process::Read( uintptr_t( pBuf->sender_pid ), process, pRead->address, pRead->buffer, pRead->size );
//			}
//			break;
//		}
//
//		case SendDataIds::Write:
//		{
//			auto pWrite = reinterpret_cast< CReadWriteRequest* >( pBuf->Buffer );
//			if ( pWrite )
//			{
//				DbgOut( "HandleRequest - Write address = 0x%p, buffer = 0x%p, size = 0x%llX", pWrite->address, pWrite->buffer, pWrite->size );
//				bResult = process::Write( uintptr_t( pBuf->sender_pid ), process, pWrite->address, pWrite->buffer, pWrite->size );
//			}
//			break;
//		}
//
//		case SendDataIds::ReadInjected:
//		{
//			auto pRead = reinterpret_cast< CReadWriteRequest* >( pBuf->Buffer );
//			if ( pRead )
//			{
//				DbgOut( "HandleRequest - ReadInjected address = 0x%p, buffer = 0x%p, size = 0x%llX", pRead->address, pRead->buffer, pRead->size );
//				bResult = process::ReadInjected( uintptr_t( pBuf->sender_pid ), process, reinterpret_cast< uintptr_t >( pRead->address ), pRead->buffer );
//			}
//			break;
//		}
//
//		case SendDataIds::Status:
//		{
//			DbgOut( "HandleRequest - Status" );
//			bResult = TRUE;
//			break;
//		}
//		}
//
//		DbgOut( "HandleRequest - result = %d", bResult );
//		return bResult;
//	}
//
//	/*void HijackDispatcher()
//	{
//		UNICODE_STRING driver_name = RTL_CONSTANT_STRING( L"\\Driver\\klhk" );
//		PDRIVER_OBJECT driver_object = nullptr;
//
//		auto status = ObReferenceObjectByName(
//			&driver_name,
//			OBJ_CASE_INSENSITIVE,
//			nullptr,
//			0,
//			*IoDriverObjectType,
//			KernelMode,
//			nullptr,
//			( PVOID* )&driver_object
//		);
//
//		if ( !driver_object || !NT_SUCCESS( status ) )
//		{
//			DbgOut( "ObReferenceObjectByName returned 0x%08X driver_object: 0x%016X\n", status, driver_object );
//			return;
//		}
//
//		auto& device_control = driver_object->FastIoDispatch;
//		if ( device_control )
//		{
//			*( PVOID* )( jmp_rax + 2 ) = &IoDispatcher;
//			const auto pCave = utils::FindCodeCave( XS( "klhk.sys" ), XS( "_hvmcode" ), sizeof( jmp_rax ) );
//			if ( pCave )
//			{
//				utils::SuperCopyMemory( PVOID( pCave ), jmp_rax, sizeof( jmp_rax ) );
//				DbgOut( "Found and write cave at = 0x%llX", pCave );
//
//				oFastIoDispatcher = device_control->FastIoDeviceControl;
//				device_control->FastIoDeviceControl = PFAST_IO_DEVICE_CONTROL( pCave );
//
//				DbgOut( "Hijacked FastIoDispatch from = 0x%p, to = 0x%llX", oFastIoDispatcher, pCave );
//			}
//		}
//
//		ObDereferenceObject( driver_object );
//	}*/
//}

//BOOLEAN IoDispatcher( struct _FILE_OBJECT* FileObject, BOOLEAN Wait, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLenght, ULONG IoControlCode, PIO_STATUS_BLOCK IoStatus, struct _DEVICE_OBJECT* DeviceObject )
//{
//	DbgOut( "FastIoCtrl called cmd = 0x%X, input = 0x%p, in_len = 0x%X, output = 0x%p, out_len = 0x%X", IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLenght );
//
//	switch ( IoControlCode )
//	{
//	case IOCTL_ULTRADRV:
//	{
//		const auto pBuf = PSEND_DATA_INFO( InputBuffer );
//
//		if ( InputBufferLength >= sizeof( SEND_DATA_INFO ) )
//		{
//			utils::XorBuffer( PUCHAR( pBuf ), sizeof( SEND_DATA_INFO ) );
//			return comms::HandleRequest( pBuf );
//		}
//
//		DbgOut( "FastIoCtrl - invalid request given" );
//		return FALSE;
//	}
//	}
//
//	return oFastIoDispatcher( FileObject, Wait, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLenght, IoControlCode, IoStatus, DeviceObject );
//}

```

`driver/old_comms.hpp`:

```hpp
#pragma once

#define IOCTL_ULTRADRV	0x200C1

enum class SendDataIds : unsigned char
{
	Status,
	HideWindow,
	Attach,
	Detach,
	FindModule,
	KeyState,
	Read,
	Write,
	ReadInjected,
	WriteReadOnly
};

typedef struct _SEND_DATA_INFO
{
	SendDataIds id;
	HANDLE sender_pid;
	unsigned char Buffer[ 4096 ];
} SEND_DATA_INFO, * PSEND_DATA_INFO;

struct CHideWindowRequest
{
	HANDLE pid;
	HWND hwnd;

	CHideWindowRequest()
	{
		this->pid = 0;
		this->hwnd = 0;
	}
};

struct CAttachProcessRequest
{
	uint32_t hash;

	CAttachProcessRequest( const uint32_t hash ) : CAttachProcessRequest()
	{
		this->hash = hash;
	}
	CAttachProcessRequest()
	{
		this->hash = 0;
	}
};

struct CDetachProcessRequest
{
	CDetachProcessRequest() = default;
};

struct CGetWindowThreadRequest
{
	uintptr_t window_handle;
	uintptr_t res;

	CGetWindowThreadRequest( const uintptr_t window_handle ) : CGetWindowThreadRequest()
	{
		this->window_handle = window_handle;
	}
	CGetWindowThreadRequest()
	{
		this->window_handle = 0;
		this->res = 0;
	}
};

struct CSetWindowThreadRequest
{
	uintptr_t target_window_handle;
	uintptr_t thread_pointer;

	CSetWindowThreadRequest( const uintptr_t window_handle, const uintptr_t thread_pointer ) : CSetWindowThreadRequest()
	{
		this->target_window_handle = window_handle;
		this->thread_pointer = thread_pointer;
	}
	CSetWindowThreadRequest()
	{
		this->target_window_handle = 0;
		this->thread_pointer = 0;
	}
};

struct CFindModuleRequest
{
	uint32_t hash;
	uintptr_t* res;

	CFindModuleRequest( const uint32_t hash ) : CFindModuleRequest()
	{
		this->hash = hash;
	}
	CFindModuleRequest()
	{
		this->hash = 0;
		this->res = 0;
	}
};

struct CGetKeyStateRequest
{
	int key;
	bool* res;

	CGetKeyStateRequest( const int key ) : CGetKeyStateRequest()
	{
		this->key = key;
	}

	CGetKeyStateRequest()
	{
		this->key = 0;
		this->res = nullptr;
	}
};

struct CReadWriteRequest
{
	void* address;
	void* buffer;
	size_t size;

	CReadWriteRequest(
		void* address,
		void* buffer,
		const size_t size ) : CReadWriteRequest()
	{
		this->address = address;
		this->buffer = buffer;
		this->size = size;
	}

	CReadWriteRequest()
	{
		this->address = 0;
		this->buffer = 0;
		this->size = 0;
	}
};

struct CChangeProtRequest
{
	uintptr_t address;

	CChangeProtRequest(
		uintptr_t address
	) : CChangeProtRequest()
	{
		this->address = address;
	}

	CChangeProtRequest()
	{
		this->address = 0;
	}
};

namespace comms
{
	extern BOOLEAN HandleRequest( const PSEND_DATA_INFO& pBuf );
}
```

`driver/process.hpp`:

```hpp
#pragma once

struct Vector3
{
	float x, y, z;
};

struct Vector4
{
	float x, y, z, w;
};

struct TransformAccessReadOnly
{
	ULONGLONG pTransformData;
	int index;
};

struct TransformData
{
	ULONGLONG pTransformArray;
	ULONGLONG pTransformIndices;
};

struct Matrix34
{
	Vector4 vec0;
	Vector4 vec1;
	Vector4 vec2;
};

namespace process
{
	inline bool is_x86( const PEPROCESS process )
	{
		return ( PsGetProcessWow64Process( process ) != nullptr );
	}

	inline bool Read( const uintptr_t local_pid, const PEPROCESS kprocess, void* address, void* buffer, const size_t size )
	{

		if (local_pid == -1 || !kprocess || (EtwpIsProcessZombie && EtwpIsProcessZombie(kprocess)))
		{
			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "if condition not met : %lu   %lu    \n", local_pid,kprocess);
			return false;
		}
		PEPROCESS lprocess{ };
		if ( !NT_SUCCESS( PsLookupProcessByProcessId( HANDLE( local_pid ), &lprocess ) ) )
			return false;

		unsigned __int64 out;
		//DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Reading : %X   %lu  %zu    \n", address, buffer, size);
		const auto res = MmCopyVirtualMemory( kprocess, address, lprocess, buffer, size, KernelMode, &out );
		ObDereferenceObject( lprocess );

		return NT_SUCCESS( res );
	}

	inline bool Write( const uintptr_t local_pid, const PEPROCESS kprocess, void* address, void* buffer, const size_t size )
	{
		if ( local_pid == -1 || !kprocess || ( EtwpIsProcessZombie && EtwpIsProcessZombie( kprocess ) ) || !MmIsAddressValid( kprocess ) )
			return false;

		PEPROCESS lprocess{ };
		if ( !NT_SUCCESS( PsLookupProcessByProcessId( HANDLE( local_pid ), &lprocess ) ) )
			return false;

		unsigned __int64 out;
		const auto res = MmCopyVirtualMemory( lprocess, buffer, kprocess, address, size, KernelMode, &out );
		ObDereferenceObject( lprocess );

		return NT_SUCCESS( res );
	}

	template <typename t>
	inline t Read( const uintptr_t local_pid, const PEPROCESS kprocess, const uintptr_t address )
	{
		t result = t();
		Read( local_pid, kprocess, reinterpret_cast< void* >( address ), &result, sizeof( t ) );
		return result;
	}

	template <typename t>
	inline bool Read( const uintptr_t local_pid, const PEPROCESS kprocess, const uintptr_t address, t buffer, const size_t size )
	{
		return Read( local_pid, kprocess, reinterpret_cast< void* >( address ), buffer, size );
	}

	inline bool ReadInjected( const uintptr_t local_pid, const PEPROCESS kprocess, uintptr_t transform, void* buffer )
	{
		__m128 result;

		const __m128 mulVec0 = { -2.000, 2.000, -2.000, 0.000 };
		const __m128 mulVec1 = { 2.000, -2.000, -2.000, 0.000 };
		const __m128 mulVec2 = { -2.000, -2.000, 2.000, 0.000 };

		TransformAccessReadOnly pTransformAccessReadOnly{ };
		pTransformAccessReadOnly = Read< TransformAccessReadOnly >( uintptr_t( PsGetCurrentProcessId() ), kprocess, uintptr_t( transform + 0x38 ) );

		TransformData transformData{ };
		transformData = Read< TransformData >( uintptr_t( PsGetCurrentProcessId() ), kprocess, uintptr_t( pTransformAccessReadOnly.pTransformData + 0x18 ) );

		size_t sizeMatriciesBuf = sizeof( Matrix34 ) * pTransformAccessReadOnly.index + sizeof( Matrix34 );
		size_t sizeIndicesBuf = sizeof( int ) * pTransformAccessReadOnly.index + sizeof( int );

		// Allocate memory for storing large amounts of data (matricies and indicies)
		PVOID pMatriciesBuf = ExAllocatePool( NonPagedPool, sizeof( ULONG_PTR ) + sizeMatriciesBuf );
		if ( !pMatriciesBuf )
			return false;

		PVOID pIndicesBuf = ExAllocatePool( NonPagedPool, sizeof( ULONG_PTR ) + sizeIndicesBuf );
		if ( !pIndicesBuf )
		{
			ExFreePool( pMatriciesBuf );
			return false;
		}

		if ( pMatriciesBuf && pIndicesBuf )
		{
			if ( !Read( uintptr_t( PsGetCurrentProcessId() ), kprocess, PVOID( transformData.pTransformArray ), pMatriciesBuf, sizeMatriciesBuf ) )
			{
				ExFreePool( pMatriciesBuf );
				ExFreePool( pIndicesBuf );
				return false;
			}

			if ( !Read( uintptr_t( PsGetCurrentProcessId() ), kprocess, PVOID( transformData.pTransformIndices ), pIndicesBuf, sizeIndicesBuf ) )
			{
				ExFreePool( pMatriciesBuf );
				ExFreePool( pIndicesBuf );
				return false;
			}

			result = *( __m128* )( ( ULONGLONG )pMatriciesBuf + 0x30 * pTransformAccessReadOnly.index );
			int transformIndex = *( int* )( ( ULONGLONG )pIndicesBuf + 0x4 * pTransformAccessReadOnly.index );

			while ( transformIndex >= 0 )
			{
				Matrix34 matrix34 = *( Matrix34* )( ( ULONGLONG )pMatriciesBuf + 0x30 * transformIndex );

				__m128 xxxx = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0x00 ) );	// xxxx
				__m128 yyyy = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0x55 ) );	// yyyy
				__m128 zwxy = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0x8E ) );	// zwxy
				__m128 wzyw = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0xDB ) );	// wzyw
				__m128 zzzz = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0xAA ) );	// zzzz
				__m128 yxwy = _mm_castsi128_ps( _mm_shuffle_epi32( *( __m128i* )( &matrix34.vec1 ), 0x71 ) );	// yxwy
				__m128 tmp7 = _mm_mul_ps( *( __m128* )( &matrix34.vec2 ), result );

				result = _mm_add_ps(
					_mm_add_ps(
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps( _mm_mul_ps( xxxx, mulVec1 ), zwxy ),
									_mm_mul_ps( _mm_mul_ps( yyyy, mulVec2 ), wzyw ) ),
								_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( tmp7 ), 0xAA ) ) ),
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps( _mm_mul_ps( zzzz, mulVec2 ), wzyw ),
									_mm_mul_ps( _mm_mul_ps( xxxx, mulVec0 ), yxwy ) ),
								_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( tmp7 ), 0x55 ) ) ) ),
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps( _mm_mul_ps( yyyy, mulVec0 ), yxwy ),
									_mm_mul_ps( _mm_mul_ps( zzzz, mulVec1 ), zwxy ) ),
								_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( tmp7 ), 0x00 ) ) ),
							tmp7 ) ), *( __m128* )( &matrix34.vec0 ) );

				transformIndex = *( int* )( ( ULONGLONG )pIndicesBuf + 0x4 * transformIndex );
			}

			ExFreePool( pMatriciesBuf );
			ExFreePool( pIndicesBuf );
		}

		PEPROCESS lprocess{ };
		if ( !NT_SUCCESS( PsLookupProcessByProcessId( HANDLE( local_pid ), &lprocess ) ) )
			return false;

		SIZE_T out{ };
		const auto res = MmCopyVirtualMemory( IoGetCurrentProcess(), &result.m128_f32[ 0 ], lprocess, buffer, sizeof( float ) * 3, KernelMode, &out );
		ObDereferenceObject( lprocess );

		//RtlCopyMemory( buffer, &result.m128_f32[ 0 ], sizeof( float ) * 3 );
		return res;
	}

	inline NTSTATUS ProtectVirtualMemory( UINT_PTR kprocess, PVOID address, SIZE_T size, ULONG protection_old )
	{
		NTSTATUS status1 = STATUS_SUCCESS;
		PEPROCESS target_process = nullptr;
		if ( !NT_SUCCESS( PsLookupProcessByProcessId( reinterpret_cast< HANDLE >( kprocess ), &target_process ) ) )
		{
			//DebugPrint("Process not found \n");
			return STATUS_NOT_FOUND;
		}

		KAPC_STATE state;
		KeStackAttachProcess( target_process, &state );
		status1 = ZwProtectVirtualMemory( NtCurrentProcess(), &address, &size, PAGE_EXECUTE_READWRITE, 0 );
		KeUnstackDetachProcess( &state );

		if ( NT_SUCCESS( status1 ) )
			protection_old = protection_old;

		ObDereferenceObject( target_process );
		//DebugPrint("Ntstatus return : %x\n", status1);
		return status1;
	}

	inline PEPROCESS find( const uint32_t hash )
	{
		if ( !PsGetNextProcess )
			return nullptr;

		PEPROCESS proc = nullptr;

		for (
			auto current_process = PsGetNextProcess( nullptr );
			current_process != nullptr;
			current_process = PsGetNextProcess( current_process ) )
		{
			if ( EtwpIsProcessZombie( current_process ) )
				continue;

			ANSI_STRING ProcName{ };
			if ( utils::GetProcessBaseName( current_process, &ProcName ) )
			{
				auto szExeName = strrchr( ProcName.Buffer, '\\' );
				if ( szExeName )
				{
					++szExeName;
					const auto Hash = crypto::hash( szExeName );

					if ( Hash == hash )
						proc = current_process;
				}
				RtlFreeAnsiString( &ProcName );
			}

			if ( proc )
				break;
		}
		return proc;
	}

	inline uintptr_t find_module_x86( const PEPROCESS kprocess, const uintptr_t peb, const uint32_t hash )
	{
		if ( !utils::valid_x86( static_cast< uint32_t >( peb ) ) )
			return 0;

		const auto peb_32 = ( peb + 0x1000 );
		const auto peb_ldr = Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, peb_32 + 0xc );

		if ( !utils::valid_x86( peb_ldr ) )
			return 0;

		const auto flink = Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, static_cast< uintptr_t >( peb_ldr ) + 0xc );
		if ( !utils::valid_x86( flink ) )
			return 0;

		auto current_module = flink;
		do
		{
			const auto name_ptr = Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, static_cast< uintptr_t >( current_module ) + 0x30 );
			if ( utils::valid_x86( name_ptr ) )
			{
				wchar_t name[ 256 ] = {};
				Read( uintptr_t( PsGetCurrentProcessId() ), kprocess, name_ptr, &name, sizeof( name ) );

				if ( crypto::hash( name ) == hash )
					return Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, static_cast< uintptr_t >( current_module ) + 0x18 );
			}
			current_module = Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, current_module );
		} while ( Read<uint32_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, static_cast< uintptr_t >( current_module ) + 0x18 ) != 0 );
		return 0;
	}

	inline uintptr_t find_module_x64( const PEPROCESS kprocess, const uintptr_t peb, const uint32_t hash )
	{
		if (!utils::valid(peb))
		{
			DbgOut("Fail 1\n");
			return 0;
		}


		const auto ldr = Read<uintptr_t>(uintptr_t(PsGetCurrentProcessId()), kprocess, peb + 0x18);
		if (!utils::valid(ldr))
		{
			DbgOut("Fail 2\n");
			return 0;
		}

		const auto flink = Read<uintptr_t>(uintptr_t(PsGetCurrentProcessId()), kprocess, ldr + 0x10);
		if (!utils::valid(flink))
		{
			DbgOut("Fail 3\n");
			return 0;
		}

		auto current_module = flink;
		do
		{
			const auto name_ptr = Read<uintptr_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, current_module + 0x60 );
			if ( utils::valid( name_ptr ) )
			{
				wchar_t name[ 256 ] = {};
				Read( uintptr_t( PsGetCurrentProcessId() ), kprocess, name_ptr, &name, sizeof( name ) );

				DbgOut( "FindModule module = %S, hash = 0x%X", name, crypto::hash( name ) );
				

				if ( crypto::hash( name ) == hash )
					return Read<uintptr_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, current_module + 0x30 );
			}
			current_module = Read<uintptr_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, current_module );
		} while ( Read<uintptr_t>( uintptr_t( PsGetCurrentProcessId() ), kprocess, current_module + 0x30 ) != 0 );
		return 0;
	}
}
```

`driver/structs.hpp`:

```hpp
#pragma once

typedef enum _WINDOWINFOCLASS
{
	WindowProcess = 0,	// HANDLE
	WindowRealWindowOwner = 1,
	WindowThread = 2,	// HANDLE
	WindowIsHung = 5		// BOOL
} WINDOWINFOCLASS;

typedef USHORT RTL_ATOM, * PRTL_ATOM;

typedef enum _ATOM_INFORMATION_CLASS
{
	AtomBasicInformation,
	AtomTableInformation,
	HookMessage = 69,
} ATOM_INFORMATION_CLASS;

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation = 0x0,
    SystemProcessorInformation = 0x1,
    SystemPerformanceInformation = 0x2,
    SystemTimeOfDayInformation = 0x3,
    SystemPathInformation = 0x4,
    SystemProcessInformation = 0x5,
    SystemCallCountInformation = 0x6,
    SystemDeviceInformation = 0x7,
    SystemProcessorPerformanceInformation = 0x8,
    SystemFlagsInformation = 0x9,
    SystemCallTimeInformation = 0xa,
    SystemModuleInformation = 0xb,
    SystemLocksInformation = 0xc,
    SystemStackTraceInformation = 0xd,
    SystemPagedPoolInformation = 0xe,
    SystemNonPagedPoolInformation = 0xf,
    SystemHandleInformation = 0x10,
    SystemObjectInformation = 0x11,
    SystemPageFileInformation = 0x12,
    SystemVdmInstemulInformation = 0x13,
    SystemVdmBopInformation = 0x14,
    SystemFileCacheInformation = 0x15,
    SystemPoolTagInformation = 0x16,
    SystemInterruptInformation = 0x17,
    SystemDpcBehaviorInformation = 0x18,
    SystemFullMemoryInformation = 0x19,
    SystemLoadGdiDriverInformation = 0x1a,
    SystemUnloadGdiDriverInformation = 0x1b,
    SystemTimeAdjustmentInformation = 0x1c,
    SystemSummaryMemoryInformation = 0x1d,
    SystemMirrorMemoryInformation = 0x1e,
    SystemPerformanceTraceInformation = 0x1f,
    SystemObsolete0 = 0x20,
    SystemExceptionInformation = 0x21,
    SystemCrashDumpStateInformation = 0x22,
    SystemKernelDebuggerInformation = 0x23,
    SystemContextSwitchInformation = 0x24,
    SystemRegistryQuotaInformation = 0x25,
    SystemExtendServiceTableInformation = 0x26,
    SystemPrioritySeperation = 0x27,
    SystemVerifierAddDriverInformation = 0x28,
    SystemVerifierRemoveDriverInformation = 0x29,
    SystemProcessorIdleInformation = 0x2a,
    SystemLegacyDriverInformation = 0x2b,
    SystemCurrentTimeZoneInformation = 0x2c,
    SystemLookasideInformation = 0x2d,
    SystemTimeSlipNotification = 0x2e,
    SystemSessionCreate = 0x2f,
    SystemSessionDetach = 0x30,
    SystemSessionInformation = 0x31,
    SystemRangeStartInformation = 0x32,
    SystemVerifierInformation = 0x33,
    SystemVerifierThunkExtend = 0x34,
    SystemSessionProcessInformation = 0x35,
    SystemLoadGdiDriverInSystemSpace = 0x36,
    SystemNumaProcessorMap = 0x37,
    SystemPrefetcherInformation = 0x38,
    SystemExtendedProcessInformation = 0x39,
    SystemRecommendedSharedDataAlignment = 0x3a,
    SystemComPlusPackage = 0x3b,
    SystemNumaAvailableMemory = 0x3c,
    SystemProcessorPowerInformation = 0x3d,
    SystemEmulationBasicInformation = 0x3e,
    SystemEmulationProcessorInformation = 0x3f,
    SystemExtendedHandleInformation = 0x40,
    SystemLostDelayedWriteInformation = 0x41,
    SystemBigPoolInformation = 0x42,
    SystemSessionPoolTagInformation = 0x43,
    SystemSessionMappedViewInformation = 0x44,
    SystemHotpatchInformation = 0x45,
    SystemObjectSecurityMode = 0x46,
    SystemWatchdogTimerHandler = 0x47,
    SystemWatchdogTimerInformation = 0x48,
    SystemLogicalProcessorInformation = 0x49,
    SystemWow64SharedInformationObsolete = 0x4a,
    SystemRegisterFirmwareTableInformationHandler = 0x4b,
    SystemFirmwareTableInformation = 0x4c,
    SystemModuleInformationEx = 0x4d,
    SystemVerifierTriageInformation = 0x4e,
    SystemSuperfetchInformation = 0x4f,
    SystemMemoryListInformation = 0x50,
    SystemFileCacheInformationEx = 0x51,
    SystemThreadPriorityClientIdInformation = 0x52,
    SystemProcessorIdleCycleTimeInformation = 0x53,
    SystemVerifierCancellationInformation = 0x54,
    SystemProcessorPowerInformationEx = 0x55,
    SystemRefTraceInformation = 0x56,
    SystemSpecialPoolInformation = 0x57,
    SystemProcessIdInformation = 0x58,
    SystemErrorPortInformation = 0x59,
    SystemBootEnvironmentInformation = 0x5a,
    SystemHypervisorInformation = 0x5b,
    SystemVerifierInformationEx = 0x5c,
    SystemTimeZoneInformation = 0x5d,
    SystemImageFileExecutionOptionsInformation = 0x5e,
    SystemCoverageInformation = 0x5f,
    SystemPrefetchPatchInformation = 0x60,
    SystemVerifierFaultsInformation = 0x61,
    SystemSystemPartitionInformation = 0x62,
    SystemSystemDiskInformation = 0x63,
    SystemProcessorPerformanceDistribution = 0x64,
    SystemNumaProximityNodeInformation = 0x65,
    SystemDynamicTimeZoneInformation = 0x66,
    SystemCodeIntegrityInformation = 0x67,
    SystemProcessorMicrocodeUpdateInformation = 0x68,
    SystemProcessorBrandString = 0x69,
    SystemVirtualAddressInformation = 0x6a,
    SystemLogicalProcessorAndGroupInformation = 0x6b,
    SystemProcessorCycleTimeInformation = 0x6c,
    SystemStoreInformation = 0x6d,
    SystemRegistryAppendString = 0x6e,
    SystemAitSamplingValue = 0x6f,
    SystemVhdBootInformation = 0x70,
    SystemCpuQuotaInformation = 0x71,
    SystemNativeBasicInformation = 0x72,
    SystemErrorPortTimeouts = 0x73,
    SystemLowPriorityIoInformation = 0x74,
    SystemBootEntropyInformation = 0x75,
    SystemVerifierCountersInformation = 0x76,
    SystemPagedPoolInformationEx = 0x77,
    SystemSystemPtesInformationEx = 0x78,
    SystemNodeDistanceInformation = 0x79,
    SystemAcpiAuditInformation = 0x7a,
    SystemBasicPerformanceInformation = 0x7b,
    SystemQueryPerformanceCounterInformation = 0x7c,
    SystemSessionBigPoolInformation = 0x7d,
    SystemBootGraphicsInformation = 0x7e,
    SystemScrubPhysicalMemoryInformation = 0x7f,
    SystemBadPageInformation = 0x80,
    SystemProcessorProfileControlArea = 0x81,
    SystemCombinePhysicalMemoryInformation = 0x82,
    SystemEntropyInterruptTimingInformation = 0x83,
    SystemConsoleInformation = 0x84,
    SystemPlatformBinaryInformation = 0x85,
    SystemThrottleNotificationInformation = 0x86,
    SystemHypervisorProcessorCountInformation = 0x87,
    SystemDeviceDataInformation = 0x88,
    SystemDeviceDataEnumerationInformation = 0x89,
    SystemMemoryTopologyInformation = 0x8a,
    SystemMemoryChannelInformation = 0x8b,
    SystemBootLogoInformation = 0x8c,
    SystemProcessorPerformanceInformationEx = 0x8d,
    SystemSpare0 = 0x8e,
    SystemSecureBootPolicyInformation = 0x8f,
    SystemPageFileInformationEx = 0x90,
    SystemSecureBootInformation = 0x91,
    SystemEntropyInterruptTimingRawInformation = 0x92,
    SystemPortableWorkspaceEfiLauncherInformation = 0x93,
    SystemFullProcessInformation = 0x94,
    SystemKernelDebuggerInformationEx = 0x95,
    SystemBootMetadataInformation = 0x96,
    SystemSoftRebootInformation = 0x97,
    SystemElamCertificateInformation = 0x98,
    SystemOfflineDumpConfigInformation = 0x99,
    SystemProcessorFeaturesInformation = 0x9a,
    SystemRegistryReconciliationInformation = 0x9b,
    MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

struct KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused;
	PVOID SectionPointer;
	ULONG CheckSum;
	PVOID LoadedImports;
	PVOID PatchInformation;
};

struct PIDBB_CACHE_ENTRY
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[ 16 ];
};

struct MAPPED_DRIVER_DATA
{
    ULONG_PTR BaseAddress;
    ULONG ModuleSize;
    ULONG ToCleanTimeStamp;
    wchar_t wsDriverName[ 40 ];
};

struct TAG_THREAD_INFO
{
	uintptr_t owning_thread;
};

struct TAG_WND
{
	char pad_0[ 0x10 ];
	TAG_THREAD_INFO* thread_info;
};

struct _MMPTE_HARDWARE
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG Dirty1 : 1;                                                     //0x0
	ULONGLONG Owner : 1;                                                      //0x0
	ULONGLONG WriteThrough : 1;                                               //0x0
	ULONGLONG CacheDisable : 1;                                               //0x0
	ULONGLONG Accessed : 1;                                                   //0x0
	ULONGLONG Dirty : 1;                                                      //0x0
	ULONGLONG LargePage : 1;                                                  //0x0
	ULONGLONG Global : 1;                                                     //0x0
	ULONGLONG CopyOnWrite : 1;                                                //0x0
	ULONGLONG Unused : 1;                                                     //0x0
	ULONGLONG Write : 1;                                                      //0x0
	ULONGLONG PageFrameNumber : 36;                                           //0x0
	ULONGLONG ReservedForHardware : 4;                                        //0x0
	ULONGLONG ReservedForSoftware : 4;                                        //0x0
	ULONGLONG WsleAge : 4;                                                    //0x0
	ULONGLONG WsleProtection : 3;                                             //0x0
	ULONGLONG NoExecute : 1;                                                  //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_PROTOTYPE
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG DemandFillProto : 1;                                            //0x0
	ULONGLONG HiberVerifyConverted : 1;                                       //0x0
	ULONGLONG ReadOnly : 1;                                                   //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG Combined : 1;                                                   //0x0
	ULONGLONG Unused1 : 4;                                                    //0x0
	LONGLONG ProtoAddress : 48;                                               //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_SOFTWARE
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG PageFileReserved : 1;                                           //0x0
	ULONGLONG PageFileAllocated : 1;                                          //0x0
	ULONGLONG ColdPage : 1;                                                   //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG Transition : 1;                                                 //0x0
	ULONGLONG PageFileLow : 4;                                                //0x0
	ULONGLONG UsedPageTableEntries : 10;                                      //0x0
	ULONGLONG ShadowStack : 1;                                                //0x0
	ULONGLONG Unused : 5;                                                     //0x0
	ULONGLONG PageFileHigh : 32;                                              //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_TIMESTAMP
{
	ULONGLONG MustBeZero : 1;                                                 //0x0
	ULONGLONG Unused : 3;                                                     //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG Transition : 1;                                                 //0x0
	ULONGLONG PageFileLow : 4;                                                //0x0
	ULONGLONG Reserved : 16;                                                  //0x0
	ULONGLONG GlobalTimeStamp : 32;                                           //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_TRANSITION
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG Write : 1;                                                      //0x0
	ULONGLONG Spare : 1;                                                      //0x0
	ULONGLONG IoTracker : 1;                                                  //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG Transition : 1;                                                 //0x0
	ULONGLONG PageFrameNumber : 36;                                           //0x0
	ULONGLONG Unused : 16;                                                    //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_SUBSECTION
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG Unused0 : 3;                                                    //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG ColdPage : 1;                                                   //0x0
	ULONGLONG Unused1 : 3;                                                    //0x0
	ULONGLONG ExecutePrivilege : 1;                                           //0x0
	LONGLONG SubsectionAddress : 48;                                          //0x0
};

//0x8 bytes (sizeof)
struct _MMPTE_LIST
{
	ULONGLONG Valid : 1;                                                      //0x0
	ULONGLONG OneEntry : 1;                                                   //0x0
	ULONGLONG filler0 : 2;                                                    //0x0
	ULONGLONG SwizzleBit : 1;                                                 //0x0
	ULONGLONG Protection : 5;                                                 //0x0
	ULONGLONG Prototype : 1;                                                  //0x0
	ULONGLONG Transition : 1;                                                 //0x0
	ULONGLONG filler1 : 16;                                                   //0x0
	ULONGLONG NextEntry : 36;                                                 //0x0
};

typedef struct _MMPTE
{
	union
	{
		ULONGLONG Long;                                                     //0x0
		volatile ULONGLONG VolatileLong;                                    //0x0
		struct _MMPTE_HARDWARE Hard;                                        //0x0
		struct _MMPTE_PROTOTYPE Proto;                                      //0x0
		struct _MMPTE_SOFTWARE Soft;                                        //0x0
		struct _MMPTE_TIMESTAMP TimeStamp;                                  //0x0
		struct _MMPTE_TRANSITION Trans;                                     //0x0
		struct _MMPTE_SUBSECTION Subsect;                                   //0x0
		struct _MMPTE_LIST List;                                            //0x0
	} u;
} MMPTE;
typedef MMPTE* PMMPTE;

typedef struct _DBGKD_DEBUG_DATA_HEADER64
{
	LIST_ENTRY64 List;
	ULONG        OwnerTag;
	ULONG        Size;
} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64
{
	DBGKD_DEBUG_DATA_HEADER64 Header;
	ULONG64   KernBase;
	ULONG64   BreakpointWithStatus;
	ULONG64   SavedContext;
	USHORT    ThCallbackStack;
	USHORT    NextCallback;
	USHORT    FramePointer;
	USHORT    PaeEnabled;
	ULONG64   KiCallUserMode;
	ULONG64   KeUserCallbackDispatcher;
	ULONG64   PsLoadedModuleList;
	ULONG64   PsActiveProcessHead;
	ULONG64   PspCidTable;
	ULONG64   ExpSystemResourcesList;
	ULONG64   ExpPagedPoolDescriptor;
	ULONG64   ExpNumberOfPagedPools;
	ULONG64   KeTimeIncrement;
	ULONG64   KeBugCheckCallbackListHead;
	ULONG64   KiBugcheckData;
	ULONG64   IopErrorLogListHead;
	ULONG64   ObpRootDirectoryObject;
	ULONG64   ObpTypeObjectType;
	ULONG64   MmSystemCacheStart;
	ULONG64   MmSystemCacheEnd;
	ULONG64   MmSystemCacheWs;
	ULONG64   MmPfnDatabase;
	ULONG64   MmSystemPtesStart;
	ULONG64   MmSystemPtesEnd;
	ULONG64   MmSubsectionBase;
	ULONG64   MmNumberOfPagingFiles;
	ULONG64   MmLowestPhysicalPage;
	ULONG64   MmHighestPhysicalPage;
	ULONG64   MmNumberOfPhysicalPages;
	ULONG64   MmMaximumNonPagedPoolInBytes;
	ULONG64   MmNonPagedSystemStart;
	ULONG64   MmNonPagedPoolStart;
	ULONG64   MmNonPagedPoolEnd;
	ULONG64   MmPagedPoolStart;
	ULONG64   MmPagedPoolEnd;
	ULONG64   MmPagedPoolInformation;
	ULONG64   MmPageSize;
	ULONG64   MmSizeOfPagedPoolInBytes;
	ULONG64   MmTotalCommitLimit;
	ULONG64   MmTotalCommittedPages;
	ULONG64   MmSharedCommit;
	ULONG64   MmDriverCommit;
	ULONG64   MmProcessCommit;
	ULONG64   MmPagedPoolCommit;
	ULONG64   MmExtendedCommit;
	ULONG64   MmZeroedPageListHead;
	ULONG64   MmFreePageListHead;
	ULONG64   MmStandbyPageListHead;
	ULONG64   MmModifiedPageListHead;
	ULONG64   MmModifiedNoWritePageListHead;
	ULONG64   MmAvailablePages;
	ULONG64   MmResidentAvailablePages;
	ULONG64   PoolTrackTable;
	ULONG64   NonPagedPoolDescriptor;
	ULONG64   MmHighestUserAddress;
	ULONG64   MmSystemRangeStart;
	ULONG64   MmUserProbeAddress;
	ULONG64   KdPrintCircularBuffer;
	ULONG64   KdPrintCircularBufferEnd;
	ULONG64   KdPrintWritePointer;
	ULONG64   KdPrintRolloverCount;
	ULONG64   MmLoadedUserImageList;
	ULONG64   NtBuildLab;
	ULONG64   KiNormalSystemCall;
	ULONG64   KiProcessorBlock;
	ULONG64   MmUnloadedDrivers;
	ULONG64   MmLastUnloadedDriver;
	ULONG64   MmTriageActionTaken;
	ULONG64   MmSpecialPoolTag;
	ULONG64   KernelVerifier;
	ULONG64   MmVerifierData;
	ULONG64   MmAllocatedNonPagedPool;
	ULONG64   MmPeakCommitment;
	ULONG64   MmTotalCommitLimitMaximum;
	ULONG64   CmNtCSDVersion;
	ULONG64   MmPhysicalMemoryBlock;
	ULONG64   MmSessionBase;
	ULONG64   MmSessionSize;
	ULONG64   MmSystemParentTablePage;
	ULONG64   MmVirtualTranslationBase;
	USHORT    OffsetKThreadNextProcessor;
	USHORT    OffsetKThreadTeb;
	USHORT    OffsetKThreadKernelStack;
	USHORT    OffsetKThreadInitialStack;
	USHORT    OffsetKThreadApcProcess;
	USHORT    OffsetKThreadState;
	USHORT    OffsetKThreadBStore;
	USHORT    OffsetKThreadBStoreLimit;
	USHORT    SizeEProcess;
	USHORT    OffsetEprocessPeb;
	USHORT    OffsetEprocessParentCID;
	USHORT    OffsetEprocessDirectoryTableBase;
	USHORT    SizePrcb;
	USHORT    OffsetPrcbDpcRoutine;
	USHORT    OffsetPrcbCurrentThread;
	USHORT    OffsetPrcbMhz;
	USHORT    OffsetPrcbCpuType;
	USHORT    OffsetPrcbVendorString;
	USHORT    OffsetPrcbProcStateContext;
	USHORT    OffsetPrcbNumber;
	USHORT    SizeEThread;
	ULONG64   KdPrintCircularBufferPtr;
	ULONG64   KdPrintBufferSize;
	ULONG64   KeLoaderBlock;
	USHORT    SizePcr;
	USHORT    OffsetPcrSelfPcr;
	USHORT    OffsetPcrCurrentPrcb;
	USHORT    OffsetPcrContainedPrcb;
	USHORT    OffsetPcrInitialBStore;
	USHORT    OffsetPcrBStoreLimit;
	USHORT    OffsetPcrInitialStack;
	USHORT    OffsetPcrStackLimit;
	USHORT    OffsetPrcbPcrPage;
	USHORT    OffsetPrcbProcStateSpecialReg;
	USHORT    GdtR0Code;
	USHORT    GdtR0Data;
	USHORT    GdtR0Pcr;
	USHORT    GdtR3Code;
	USHORT    GdtR3Data;
	USHORT    GdtR3Teb;
	USHORT    GdtLdt;
	USHORT    GdtTss;
	USHORT    Gdt64R3CmCode;
	USHORT    Gdt64R3CmTeb;
	ULONG64   IopNumTriageDumpDataBlocks;
	ULONG64   IopTriageDumpDataBlocks;
} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;

typedef struct _KDDEBUGGER_DATA_ADDITION64
{
	ULONG64   VfCrashDataBlock;
	ULONG64   MmBadPagesDetected;
	ULONG64   MmZeroedPageSingleBitErrorsDetected;
	ULONG64   EtwpDebuggerData;
	USHORT    OffsetPrcbContext;
	USHORT    OffsetPrcbMaxBreakpoints;
	USHORT    OffsetPrcbMaxWatchpoints;
	ULONG     OffsetKThreadStackLimit;
	ULONG     OffsetKThreadStackBase;
	ULONG     OffsetKThreadQueueListEntry;
	ULONG     OffsetEThreadIrpList;
	USHORT    OffsetPrcbIdleThread;
	USHORT    OffsetPrcbNormalDpcState;
	USHORT    OffsetPrcbDpcStack;
	USHORT    OffsetPrcbIsrStack;
	USHORT    SizeKDPC_STACK_FRAME;
	USHORT    OffsetKPriQueueThreadListHead;
	USHORT    OffsetKThreadWaitReason;
	USHORT    Padding;
	ULONG64   PteBase;
	ULONG64   RetpolineStubFunctionTable;
	ULONG     RetpolineStubFunctionTableSize;
	ULONG     RetpolineStubOffset;
	ULONG     RetpolineStubSize;
}KDDEBUGGER_DATA_ADDITION64, * PKDDEBUGGER_DATA_ADDITION64;

typedef struct _DUMP_HEADER
{
	ULONG Signature;
	ULONG ValidDump;
	ULONG MajorVersion;
	ULONG MinorVersion;
	ULONG_PTR DirectoryTableBase;
	ULONG_PTR PfnDataBase;
	PLIST_ENTRY PsLoadedModuleList;
	PLIST_ENTRY PsActiveProcessHead;
	ULONG MachineImageType;
	ULONG NumberProcessors;
	ULONG BugCheckCode;
	ULONG_PTR BugCheckParameter1;
	ULONG_PTR BugCheckParameter2;
	ULONG_PTR BugCheckParameter3;
	ULONG_PTR BugCheckParameter4;
	CHAR VersionUser[ 32 ];
	struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, * PDUMP_HEADER;
typedef struct _HANDLE_TABLE_ENTRY_INFO
{
	ULONG AuditMask;
	ULONG MaxRelativeAccessMask;
} HANDLE_TABLE_ENTRY_INFO, * PHANDLE_TABLE_ENTRY_INFO;
typedef struct _HANDLE_TABLE_ENTRY
{
	union
	{
		INT64 VolatileLowValue;
		INT64 LowValue;
		PHANDLE_TABLE_ENTRY_INFO InfoTable;

		struct
		{
			INT64 Unlocked : 1;
			INT64 RefCnt : 16;
			INT64 Attributes : 3;
			INT64 ObjectPointerBits : 44;
		};

	};

	union
	{
		INT64 HighValue;
		PVOID NextFreeHandleEntry;
		PVOID LeafHandleValue;

		struct
		{
			ULONG GrantedAccessBits : 25;
			ULONG NoRightsUpgrade : 1;
			ULONG Spare : 6;
		};
	};

} HANDLE_TABLE_ENTRY, * PHANDLE_TABLE_ENTRY;

typedef struct _OBJECT_HEADER
{
	__int64 PointerCount;
	__int64 HandleCount;
	EX_PUSH_LOCK Lock;
	char TypeIndex;
	char ___u4;
	char InfoMask;
	char ___u6;
	unsigned int Reserved;
	__int64 ___u8;
	void* SecurityDescriptor;
}OBJECT_HEADER, * POBJECT_HEADER;
typedef struct _HANDLE_TABLE_FREE_LIST
{
	EX_PUSH_LOCK FreeListLock;
	PHANDLE_TABLE_ENTRY FirstFreeHandleEntry;
	PHANDLE_TABLE_ENTRY LastFreeHandleEntry;
	LONG HandleCount;
	ULONG HighWaterMark;
} HANDLE_TABLE_FREE_LIST, * PHANDLE_TABLE_FREE_LIST;
typedef struct _HANDLE_TABLE
{
	ULONG NextHandleNeedingPool;
	LONG ExtraInfoPages;
	UINT64 TableCode;
	PEPROCESS QuotaProcess;
	LIST_ENTRY HandleTableList;
	ULONG UniqueProcessId;
	ULONG Flags;
	UCHAR StrictFIFO : 1;
	UCHAR EnableHandleExceptions : 1;
	UCHAR Rundown : 1;
	UCHAR Duplicated : 1;
	UCHAR RaiseUMExceptionOnInvalidHandleClose : 4;
	EX_PUSH_LOCK HandleContentionEvent;
	EX_PUSH_LOCK HandleTableLock;
	HANDLE_TABLE_FREE_LIST FreeLists[1];
	PVOID DebugInfo;
} HANDLE_TABLE, * PHANDLE_TABLE;
typedef struct _CID_TABLE_HIDDEN_THREAD
{
	HANDLE_TABLE_ENTRY OldEntry;
	void* DummyEThread;
}CID_TABLE_HIDDEN_THREAD, * PCID_TABLE_HIDDEN_THREAD;
typedef PHANDLE_TABLE_ENTRY(*f_ExpLookupHandleTableEntry) (PHANDLE_TABLE HandleTable, HANDLE Handle);
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, Signature ) == 0 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, ValidDump ) == 4 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, MajorVersion ) == 8 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, MinorVersion ) == 0xc );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, DirectoryTableBase ) == 0x10 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, PfnDataBase ) == 0x18 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, PsLoadedModuleList ) == 0x20 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, PsActiveProcessHead ) == 0x28 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, MachineImageType ) == 0x30 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, NumberProcessors ) == 0x34 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, BugCheckCode ) == 0x38 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, BugCheckParameter1 ) == 0x40 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, BugCheckParameter2 ) == 0x48 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, BugCheckParameter3 ) == 0x50 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, BugCheckParameter4 ) == 0x58 );
C_ASSERT( FIELD_OFFSET( DUMP_HEADER, KdDebuggerDataBlock ) == 0x80 );

#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PTE_SHIFT 3
#define PTI_SHIFT 12

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif 

#ifndef _WIN64
#define DUMP_BLOCK_SIZE 0x20000
#else
#define DUMP_BLOCK_SIZE 0x40000
#endif 

#define PHYSICAL_ADDRESS_BITS 40
#define MI_SYSTEM_RANGE_START (ULONG_PTR)(0xFFFF080000000000) // start of system space
```

`driver/utils.hpp`:

```hpp
#pragma once

#include "hash.hpp"
#include "ntifs.h"
namespace utils
{
	inline PUCHAR win32u = nullptr, ntdll = nullptr;

	inline bool valid( const uintptr_t address )
	{
		return ( ( address > 0x10000 ) && ( address < 0x7ffffffeffff ) );
	}

	inline bool valid_x86( const uint32_t address )
	{
		return ( ( address > 0x10000 ) && ( address < 0xffff0000 ) );
	}

	inline bool valid_buffer( void* buffer, const size_t size )
	{
		return ( valid( reinterpret_cast< uintptr_t >( buffer ) ) && valid( reinterpret_cast< uintptr_t >( buffer ) + size ) );
	}

	template <typename T = uint8_t*>
	inline T resolve_jxx( uint8_t* address )
	{
		return reinterpret_cast< T >( address + *reinterpret_cast< int8_t* >( address + 1 ) + 2 );
	}

	template <typename T = uint8_t*>
	inline T resolve_call( uint8_t* address )
	{
		return reinterpret_cast< T >( address + *reinterpret_cast< int32_t* >( address + 1 ) + 5 );
	}

	template <typename T = uint8_t*>
	inline T resolve_mov( uint8_t* address )
	{
		return reinterpret_cast< T >( address + *reinterpret_cast< int32_t* >( address + 3 ) + 7 );
	}

	inline PEPROCESS GetWinlogon()
	{
		for ( int i = 0; i < 0xFFFFFF; i += 4 )
		{
			PEPROCESS process{ };
			if ( NT_SUCCESS( PsLookupProcessByProcessId( HANDLE( i ), &process ) ) )
			{
				if ( strstr( PsGetProcessImageFileName( process ), XS( "winlogon" ) ) )
					return process;

				ObDereferenceObject( process );
			}
		}
		return nullptr;
	}

	inline __forceinline void XorBuffer( PUCHAR Buffer, ULONG len )
	{
		for ( auto i = 0ul; i < len; ++i )
		{
			Buffer[ i ] ^= 94;
			Buffer[ i ] ^= 47;
		}
	}

	inline BOOLEAN FindModuleByName( LPCSTR modname, SIZE_T* base = nullptr, SIZE_T* size = nullptr )
	{
		if ( !modname )
			return FALSE;

		ULONG bytes = 0;

		auto Status = ZwQuerySystemInformation( SystemModuleInformation, NULL, bytes, &bytes );
		if ( !bytes )
			return FALSE;

		const auto info = PRTL_PROCESS_MODULES( ExAllocatePool( NonPagedPool, bytes ) );

		Status = ZwQuerySystemInformation( SystemModuleInformation, info, bytes, &bytes );
		if ( !NT_SUCCESS( Status ) )
		{
			ExFreePool( info );
			return FALSE;
		}

		BOOLEAN bResult = FALSE;

		for ( ULONG i = 0; i < info->NumberOfModules; i++ )
		{
			const auto pModule = &info->Modules[ i ];

			if ( strstr( PCHAR( pModule->FullPathName ), modname ) )
			{
				if ( base )
					*base = SIZE_T( pModule->ImageBase );

				if ( size )
					*size = SIZE_T( pModule->ImageSize );

				bResult = true;
				break;
			}
		}

		if ( info )
			ExFreePool( info );

		return bResult;
	}

	inline NTSTATUS SuperCopyMemory( IN VOID UNALIGNED* Destination, IN CONST VOID UNALIGNED* Source, IN ULONG Length )
	{
		PMDL g_pmdl = IoAllocateMdl( Destination, Length, 0, 0, NULL );
		if ( !g_pmdl )
			return STATUS_UNSUCCESSFUL;
		MmBuildMdlForNonPagedPool( g_pmdl );
		unsigned int* Mapped = ( unsigned int* )MmMapLockedPages( g_pmdl, KernelMode );
		if ( !Mapped )
		{
			IoFreeMdl( g_pmdl );
			return STATUS_UNSUCCESSFUL;
		}
		KIRQL kirql = KeRaiseIrqlToDpcLevel();
		RtlCopyMemory( Mapped, Source, Length );
		KeLowerIrql( kirql );
		//Restore memory properties.
		MmUnmapLockedPages( ( PVOID )Mapped, g_pmdl );
		IoFreeMdl( g_pmdl );
		return STATUS_SUCCESS;
	}

	inline ULONG_PTR FindCodeCave( LPCSTR modname, LPCSTR secname, UINT len )
	{
		SIZE_T base = NULL;

		if ( !modname || !secname || len <= 0 )
			return NULL;

		if ( !FindModuleByName( modname, &base ) )
			return NULL;

		auto nth = RtlImageNtHeader( PVOID( base ) );
		if ( !nth )
			return NULL;

		PIMAGE_SECTION_HEADER pSection = nullptr;

		auto sec = IMAGE_FIRST_SECTION( nth );
		for ( auto i = 0; i < nth->FileHeader.NumberOfSections; i++, sec++ )
		{
			if ( !_strnicmp( reinterpret_cast< char* >( sec->Name ), secname, IMAGE_SIZEOF_SHORT_NAME ) )
			{
				pSection = sec;
				//	DbgOut( "FindCodeCave at module = 0x%p ( %s ), found section %s at RVA = 0x%X ( Size = 0x%X )", base, modname, PCHAR( sec->Name ), sec->VirtualAddress, sec->Misc.VirtualSize );
				break;
			}
		}

		if ( pSection )
		{
			PUCHAR cur = PUCHAR( base + pSection->VirtualAddress );

			for ( auto i = 0ul, j = 0ul; i < pSection->Misc.VirtualSize; ++i )
			{
				if ( cur[ i ] == 0xCC || cur[ i ] == 0xC3 || cur[ i ] == 0x90 )
					j++;
				else
					j = 0;

				if ( j == len )
				{
					auto ullAddress = ( ULONG_PTR( base + pSection->VirtualAddress ) + ( 1 + i ) - len + 1 );
					DbgOut( "FindCodeCave result at module = 0x%p ( %s ), found at section %s, address = 0x%llX", base, modname, PCHAR( sec->Name ), ullAddress );
					return ullAddress;
				}
			}
		}
		else
			DbgOut( "FindCodeCave at module = 0x%p ( %s ), section = %s not found!", base, modname, secname );

		return NULL;
	}

	inline BOOLEAN bDataCompare( const UCHAR* pData, const UCHAR* bMask, const char* szMask )
	{
		for ( ; *szMask; ++szMask, ++pData, ++bMask )
			if ( *szMask == 'x' && *pData != *bMask )
				return 0;

		return ( *szMask ) == 0;
	}

	inline SIZE_T FindPattern( LPCSTR modname, LPCSTR secname, UCHAR* bMask, const char* szMask )
	{
		SIZE_T base = NULL;

		if ( !modname || !secname || !bMask || !szMask )
			return NULL;

		if ( !FindModuleByName( modname, &base ) )
			return NULL;

		if ( !base )
			return NULL;

		auto nth = RtlImageNtHeader( PVOID( base ) );
		if ( !nth )
			return NULL;

		PIMAGE_SECTION_HEADER pSection = nullptr;

		auto sec = IMAGE_FIRST_SECTION( nth );
		for ( auto i = 0; i < nth->FileHeader.NumberOfSections; i++, sec++ )
		{
			if ( !_strnicmp( reinterpret_cast< char* >( sec->Name ), secname, IMAGE_SIZEOF_SHORT_NAME ) )
			{
				pSection = sec;
				//	DbgOut( "FindPattern at module = 0x%p ( %s ), found section %s at RVA = 0x%X ( Size = 0x%X )", base, modname, PCHAR( sec->Name ), sec->VirtualAddress, sec->Misc.VirtualSize );
				break;
			}
		}

		if ( pSection )
		{
			auto dwAddress = ( SIZE_T )( base + pSection->VirtualAddress );

			//DbgOut( "FindPattern at module = 0x%p ( %s ), found section VA = 0x%llX", base, modname, dwAddress );

			for ( auto i = 0ul; i < pSection->Misc.VirtualSize; ++i )
			{
				if ( bDataCompare( ( UCHAR* )( dwAddress + i ), bMask, szMask ) )
				{
					auto ullResult = ( SIZE_T )( dwAddress + i );
					DbgOut( "FindPattern at module = 0x%p ( %s ), found pattern at section = %s, address = 0x%llX", base, modname, PCHAR( pSection->Name ), ullResult );
					return ullResult;
				}
			}
		}
		else
			DbgOut( "FindPattern at module = 0x%p ( %s ), section = %s not found!", base, modname, secname );

		return NULL;
	}

	inline SIZE_T FindExport( const char* modname, const char* exportname )
	{
		SIZE_T base = NULL;

		if ( !FindModuleByName( modname, &base ) )
			return NULL;

		return SIZE_T( RtlFindExportedRoutineByName( PVOID( base ), exportname ) );
	}

	inline BOOL GetProcessBaseName( PEPROCESS Process, PANSI_STRING ProcessImageName )
	{
		BOOL bResult = FALSE;

		BOOL bAttach = FALSE;
		KAPC_STATE apc{ };
		if ( Process != PsGetCurrentProcess() )
		{
			bAttach = TRUE;
			KeStackAttachProcess( Process, &apc );
		}

		wchar_t lpModuleName[ MAX_PATH ]{ };
		auto status = ZwQueryVirtualMemory( NtCurrentProcess(), PsGetProcessSectionBaseAddress( Process ), ( MEMORY_INFORMATION_CLASS )2, lpModuleName, sizeof( lpModuleName ), NULL );
		if ( NT_SUCCESS( status ) )
		{
			PUNICODE_STRING pModuleName = PUNICODE_STRING( lpModuleName );
			if ( pModuleName->Length > 0 )
			{
				RtlUnicodeStringToAnsiString( ProcessImageName, pModuleName, TRUE );
				bResult = TRUE;
			}
		}
		else
			DbgOut( "GetProcessBaseName failed with = 0x%X", status );

		if ( bAttach )
			KeUnstackDetachProcess( &apc );

		return bResult;
	}

	inline NTSTATUS LoadFile( PUNICODE_STRING FileName, PUCHAR* pImageBase )
	{
		if ( !FileName )
			return STATUS_INVALID_PARAMETER;

		OBJECT_ATTRIBUTES oa{ };
		InitializeObjectAttributes( &oa, FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL );

		if ( KeGetCurrentIrql() != PASSIVE_LEVEL )
		{
			DbgOut( "[ LoadFile ] IRQL too high for IO operations!\n" );
			return STATUS_UNSUCCESSFUL;
		}

		HANDLE FileHandle = NULL;

		IO_STATUS_BLOCK IoStatusBlock{ };
		auto res = ZwCreateFile( &FileHandle,
			GENERIC_READ,
			&oa,
			&IoStatusBlock, NULL,
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ,
			FILE_OPEN,
			FILE_SYNCHRONOUS_IO_NONALERT,
			NULL, 0 );

		if ( !NT_SUCCESS( res ) )
		{
			DbgOut( "[ LoadFile ] ZwCreateFile failed 0x%X\n", res );
			return STATUS_UNSUCCESSFUL;
		}

		FILE_STANDARD_INFORMATION StandardInformation{ };
		res = ZwQueryInformationFile( FileHandle, &IoStatusBlock, &StandardInformation, sizeof( FILE_STANDARD_INFORMATION ), FileStandardInformation );
		if ( !NT_SUCCESS( res ) )
		{
			DbgOut( "[ LoadFile ] ZwQueryInformationFile failed 0x%X\n", res );
			ZwClose( FileHandle );
			return STATUS_UNSUCCESSFUL;
		}

		auto FileSize = StandardInformation.EndOfFile.LowPart;
		auto FileBuffer = PUCHAR( ExAllocatePool( NonPagedPool, FileSize ) );

		if ( !FileBuffer )
		{
			DbgOut( "[ LoadFile ] ExAllocatePoolWithTag failed\n" );
			ZwClose( FileHandle );
			return STATUS_SUCCESS;
		}

		LARGE_INTEGER li{ };
		res = ZwReadFile( FileHandle,
			NULL, NULL, NULL,
			&IoStatusBlock,
			FileBuffer,
			FileSize,
			&li, NULL );
		if ( !NT_SUCCESS( res ) )
		{
			DbgOut( "[ LoadFile ] ZwReadFile failed 0x%X\n", res );
			ExFreePool( FileBuffer );
			ZwClose( FileHandle );
			return STATUS_SUCCESS;
		}

		auto dos = PIMAGE_DOS_HEADER( FileBuffer );
		if ( dos->e_magic != IMAGE_DOS_SIGNATURE )
		{
			DbgOut( "[ LoadFile ] Invalid DOS signature!\n" );
			ExFreePool( FileBuffer );
			ZwClose( FileHandle );
			return STATUS_SUCCESS;
		}

		auto nt = PIMAGE_NT_HEADERS64( FileBuffer + dos->e_lfanew );
		if ( nt->Signature != IMAGE_NT_SIGNATURE )
		{
			DbgOut( "[ LoadFile ] Invalid NT signature!\n" );
			ExFreePool( FileBuffer );
			ZwClose( FileHandle );
			return STATUS_SUCCESS;
		}

		auto Image = PUCHAR( ExAllocatePool( NonPagedPool, nt->OptionalHeader.SizeOfImage ) );
		if ( !Image )
		{
			DbgOut( "[ LoadFile ] ExAllocatePoolWithTag[1] failed!\n" );
			ExFreePool( FileBuffer );
			ZwClose( FileHandle );
			return STATUS_SUCCESS;
		}

		memcpy( Image, FileBuffer, nt->OptionalHeader.SizeOfHeaders );

		auto pISH = IMAGE_FIRST_SECTION( nt );
		for ( unsigned i = 0; i < nt->FileHeader.NumberOfSections; i++ )
			memcpy(
				Image + pISH[ i ].VirtualAddress,
				FileBuffer + pISH[ i ].PointerToRawData,
				pISH[ i ].SizeOfRawData );

		if ( pImageBase )
			*pImageBase = Image;
		else
			ExFreePool( Image );

		ExFreePool( FileBuffer );
		ZwClose( FileHandle );
		return STATUS_SUCCESS;
	}

	inline PVOID GetFunctionAddress( PVOID Module, LPCSTR FunctionName )
	{
		PIMAGE_DOS_HEADER pIDH;
		PIMAGE_NT_HEADERS pINH;
		PIMAGE_EXPORT_DIRECTORY pIED;

		PULONG Address, Name;
		PUSHORT Ordinal;

		ULONG i;

		pIDH = ( PIMAGE_DOS_HEADER )Module;
		pINH = ( PIMAGE_NT_HEADERS )( ( PUCHAR )Module + pIDH->e_lfanew );

		pIED = ( PIMAGE_EXPORT_DIRECTORY )( ( PUCHAR )Module + pINH->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress );

		Address = ( PULONG )( ( PUCHAR )Module + pIED->AddressOfFunctions );
		Name = ( PULONG )( ( PUCHAR )Module + pIED->AddressOfNames );

		Ordinal = ( PUSHORT )( ( PUCHAR )Module + pIED->AddressOfNameOrdinals );

		for ( i = 0; i < pIED->AddressOfFunctions; i++ )
		{
			if ( !strcmp( FunctionName, ( char* )Module + Name[ i ] ) )
			{
				return ( PVOID )( ( PUCHAR )Module + Address[ Ordinal[ i ] ] );
			}
		}

		return NULL;
	}

	inline ULONG GetNtSyscall( LPCSTR FunctionName )
	{
		if ( !ntdll )
		{
			UNICODE_STRING FileName{ };
			RtlInitUnicodeString( &FileName, XS( L"\\SystemRoot\\System32\\ntdll.dll" ) );

			auto res = LoadFile( &FileName, &ntdll );
			if ( !NT_SUCCESS( res ) )
				DbgOut( "GetNtSyscall failed to load ntdll.dll = 0x%X\n", res );
		}

		if ( ntdll )
		{
			auto Fn = PUCHAR( GetFunctionAddress( ntdll, FunctionName ) );
			if ( Fn )
			{
				for ( int i = 0; i < 24; ++i )
				{
					if ( Fn[ i ] == 0xC2 || Fn[ i ] == 0xC3 )
						break;

					if ( Fn[ i ] == 0xB8 )
						return *( PULONG )( Fn + i + 1 );
				}
			}
		}
		return 0;
	}

	inline ULONG GetWin32Syscall( LPCSTR FunctionName )
	{
		if ( !win32u )
		{
			UNICODE_STRING FileName{ };
			RtlInitUnicodeString( &FileName, XS( L"\\SystemRoot\\System32\\win32u.dll" ) );

			auto res = LoadFile( &FileName, &win32u );
			if ( !NT_SUCCESS( res ) )
				DbgOut( "GetWin32Syscall failed to load win32u.dll = 0x%X\n", res );
		}

		if ( win32u )
		{
			auto Fn = PUCHAR( GetFunctionAddress( win32u, FunctionName ) );
			if ( Fn )
			{
				for ( int i = 0; i < 24; ++i )
				{
					if ( Fn[ i ] == 0xC2 || Fn[ i ] == 0xC3 )
						break;

					if ( Fn[ i ] == 0xB8 )
						return *( PULONG )( Fn + i + 1 );
				}
			}
		}
		return 0;
	}
};
typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	BYTE Reserved1[48];
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	PVOID Reserved2;
	ULONG HandleCount;
	ULONG SessionId;
	PVOID Reserved3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG Reserved4;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	PVOID Reserved5;
	SIZE_T QuotaPagedPoolUsage;
	PVOID Reserved6;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;
#pragma warning( push )
#pragma warning( disable : 4311 )
inline ULONG FindProcess(LPCWSTR ImageName)
{
	UNICODE_STRING ImageNameString;
	RtlInitUnicodeString(&ImageNameString, ImageName);

	ULONG buffer_size = 0;

	NTSTATUS status = ZwQuerySystemInformation(SystemProcessInformation, 0, buffer_size, &buffer_size);


	if (status != STATUS_INFO_LENGTH_MISMATCH)
	{
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[!] failed to allocate\n");
		return NULL;
	}
	buffer_size = 2 * buffer_size;
	PVOID buffer = ExAllocatePool(NonPagedPool, buffer_size);

	status = ZwQuerySystemInformation(SystemProcessInformation, buffer, buffer_size, &buffer_size);

	if (!NT_SUCCESS(status))
	{
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[!] failed to allocate2 : %X  \n", status);
		ExFreePool(buffer);
		return NULL;
	}

	PSYSTEM_PROCESS_INFORMATION current_process = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(buffer);

	while (true)
	{
		current_process = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(((unsigned char*)current_process) + current_process->NextEntryOffset);

		if (RtlEqualUnicodeString(&current_process->ImageName, &ImageNameString, TRUE))
		{
			HANDLE return_value = current_process->UniqueProcessId;


			ExFreePool(buffer);
			return (ULONG)(return_value);
		}

		if (current_process->NextEntryOffset == 0)
			break;
	}

	DbgPrintEx( DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[-] pid not found\n" );

	ExFreePool(buffer);

	return NULL;
}
#pragma warning( pop )

```

`driver/xorstr.hpp`:

```hpp
#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                             \
    ::jm::make_xorstr(                                          \
        []() { return str; },                                   \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{}, \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define XS(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype( C );
        };

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ( ( Size / 16 ) + ( Size % 16 != 0 ) ) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...( Cs );
            constexpr static value_type  str[ size ] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof( str )>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ( ( sizeof( str ) > 16 ) ? 32 : 16 );
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for ( char c : __TIME__ )
                value = static_cast< std::uint32_t >( ( value ^ c ) * 16777619ull );
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return ( static_cast< std::uint64_t >( first_part ) << 32 ) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<class T>
        XORSTR_FORCEINLINE constexpr std::uint64_t
            load_xored_str8( std::uint64_t key, std::size_t idx ) noexcept
        {
            using cast_type = typename unsigned_<sizeof( typename T::value_type )>::type;
            constexpr auto value_size = sizeof( typename T::value_type );
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for ( std::size_t i = 0; i < idx_offset && i + idx * idx_offset < T::size; ++i )
                value ^=
                ( std::uint64_t{ static_cast< cast_type >( T::str[ i + idx * idx_offset ] ) }
            << ( ( i % idx_offset ) * 8 * value_size ) );

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg( std::uint64_t value ) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm( "" : "=r"( value ) : "0"( value ) : );
#endif
            return value;
        }

        XORSTR_FORCEINLINE void xor128( std::uint64_t* value,
            const std::uint64_t* key ) noexcept
        {
            _mm_store_si128(
                reinterpret_cast< __m128i* >( value ),
                _mm_xor_si128( _mm_load_si128( reinterpret_cast< const __m128i* >( value ) ),
                    _mm_load_si128( reinterpret_cast< const __m128i* >( key ) ) ) );
        }

        XORSTR_FORCEINLINE void xor256( std::uint64_t* value,
            const std::uint64_t* key ) noexcept
        {
            _mm256_store_si256(
                reinterpret_cast< __m256i* >( value ),
                _mm256_xor_si256(
                    _mm256_load_si256( reinterpret_cast< const __m256i* >( value ) ),
                    _mm256_load_si256( reinterpret_cast< const __m256i* >( key ) ) ) );
        }

        template<std::uint64_t V>
        struct uint64_v {
            constexpr static std::uint64_t value = V;
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas( T::buffer_align ) std::uint64_t _storage[ T::buffer_size ];

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256( const std::uint64_t* keys,
            std::index_sequence<Idxs...> ) noexcept
        {
            ( detail::xor256( _storage + Idxs * 4, keys + Idxs * 4 ), ... );
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128( const std::uint64_t* keys,
            std::index_sequence<Idxs...> ) noexcept
        {
            ( detail::xor128( _storage + Idxs * 2, keys + Idxs * 2 ), ... );
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const value_type*;

        XORSTR_FORCEINLINE xor_string() noexcept
            : _storage{ detail::load_from_reg( detail::uint64_v<detail::load_xored_str8<T>(
                                                  Keys::key, Keys::idx )>::value )... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
#if defined(__clang__)
            alignas( T::buffer_align )
                std::uint64_t arr[ sizeof...( Keys ) ]{ detail::load_from_reg( Keys::key )... };
            std::uint64_t* keys =
                ( std::uint64_t* )detail::load_from_reg( ( std::uint64_t )arr );
#else
            alignas( T::buffer_align ) std::uint64_t keys[ sizeof...( Keys ) ]{
                detail::load_from_reg( Keys::key )...
            };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256( keys, std::make_index_sequence<T::buffer_size / 4>{} );
            if constexpr ( T::buffer_size % 4 != 0 )
                _crypt_128( keys, std::index_sequence<T::buffer_size / 2 - 1>{} );
#else
            _crypt_128( keys, std::make_index_sequence<T::buffer_size / 2>{} );
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast< const_pointer >( _storage );
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast< pointer >( _storage );
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            crypt();
            return ( pointer )( _storage );
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr( Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...> ) noexcept
    {
        return xor_string<detail::tstring_<str_lambda()[ StringIndices ]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```