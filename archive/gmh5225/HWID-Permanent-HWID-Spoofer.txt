Project Path: arc_gmh5225_HWID-Permanent-HWID-Spoofer_182hw7i5

Source Tree:

```txt
arc_gmh5225_HWID-Permanent-HWID-Spoofer_182hw7i5
├── Kernel
│   ├── Kernel.inf
│   ├── Kernel.vcxproj
│   ├── Kernel.vcxproj.filters
│   ├── main.c
│   ├── stdafx.h
│   ├── util.c
│   └── util.h
├── README.md
├── User
│   ├── User.vcxproj
│   ├── User.vcxproj.filters
│   ├── main.c
│   ├── stdafx.h
│   ├── util.c
│   └── util.h
├── hwid_spoofer_gui.rc
├── hwid_spoofer_gui.vcxproj
├── hwid_spoofer_gui.vcxproj.filters
├── hwid_spoofer_gui.vcxproj.user
├── loader.hpp
├── main.cpp
├── resource.h
├── serial.cpp
└── serial.h

```

`Kernel/Kernel.inf`:

```inf
;
; Kernel.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Kernel.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
Kernel_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Kernel.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Kernel.DeviceDesc%=Kernel_Device, Root\Kernel ; TODO: edit hw-id

[Kernel_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Kernel.sys

;-------------- Service installation
[Kernel_Device.NT.Services]
AddService = Kernel,%SPSVCINST_ASSOCSERVICE%, Kernel_Service_Inst

; -------------- Kernel driver install sections
[Kernel_Service_Inst]
DisplayName    = %Kernel.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Kernel.sys

;
;--- Kernel_Device Coinstaller installation ------
;

[Kernel_Device.NT.CoInstallers]
AddReg=Kernel_Device_CoInstaller_AddReg
CopyFiles=Kernel_Device_CoInstaller_CopyFiles

[Kernel_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Kernel_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Kernel_Device.NT.Wdf]
KmdfService =  Kernel, Kernel_wdfsect
[Kernel_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Kernel Installation Disk"
Kernel.DeviceDesc = "Kernel Device"
Kernel.SVCDESC = "Kernel Service"

```

`Kernel/Kernel.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Kernel</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Kernel.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Kernel/Kernel.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Kernel.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Kernel/main.c`:

```c
#include "stdafx.h"

struct {
	DWORD Length;
	NIC_DRIVER Drivers[0xFF];
} NICs = { 0 };

PDRIVER_DISPATCH DiskControlOriginal = 0, MountControlOriginal = 0, PartControlOriginal = 0, NsiControlOriginal = 0, GpuControlOriginal = 0;

/**** DISKS ****/
NTSTATUS PartInfoIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(PARTITION_INFORMATION_EX)) {
			PPARTITION_INFORMATION_EX info = (PPARTITION_INFORMATION_EX)request.Buffer;
			if (PARTITION_STYLE_GPT == info->PartitionStyle) {
				memset(&info->Gpt.PartitionId, 0, sizeof(GUID));
			}
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS PartLayoutIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(DRIVE_LAYOUT_INFORMATION_EX)) {
			PDRIVE_LAYOUT_INFORMATION_EX info = (PDRIVE_LAYOUT_INFORMATION_EX)request.Buffer;
			if (PARTITION_STYLE_GPT == info->PartitionStyle) {
				memset(&info->Gpt.DiskId, 0, sizeof(GUID));
			}
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS PartControl(PDEVICE_OBJECT device, PIRP irp) {
	PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
	switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_DISK_GET_PARTITION_INFO_EX:
			ChangeIoc(ioc, irp, PartInfoIoc);
			break;
		case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
			ChangeIoc(ioc, irp, PartLayoutIoc);
			break;
	}

	return PartControlOriginal(device, irp);
}

NTSTATUS StorageQueryIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(STORAGE_DEVICE_DESCRIPTOR)) {
			PSTORAGE_DEVICE_DESCRIPTOR desc = (PSTORAGE_DEVICE_DESCRIPTOR)request.Buffer;
			ULONG offset = desc->SerialNumberOffset;
			if (offset && offset < request.BufferLength) {
				strcpy((PCHAR)desc + offset, SERIAL);

				printf("handled StorageQueryIoc\n");
			}
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS AtaPassIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(ATA_PASS_THROUGH_EX) + sizeof(PIDENTIFY_DEVICE_DATA)) {
			PATA_PASS_THROUGH_EX pte = (PATA_PASS_THROUGH_EX)request.Buffer;
			ULONG offset = (ULONG)pte->DataBufferOffset;
			if (offset && offset < request.BufferLength) {
				PCHAR serial = (PCHAR)((PIDENTIFY_DEVICE_DATA)((PBYTE)request.Buffer + offset))->SerialNumber;
				SwapEndianess(serial, SERIAL);

				printf("handled AtaPassIoc\n");
			}
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS SmartDataIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(SENDCMDOUTPARAMS)) {
			PCHAR serial = ((PIDSECTOR)((PSENDCMDOUTPARAMS)request.Buffer)->bBuffer)->sSerialNumber;
			SwapEndianess(serial, SERIAL);

			printf("handled SmartDataIoc\n");
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS DiskControl(PDEVICE_OBJECT device, PIRP irp) {
	PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
	switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_STORAGE_QUERY_PROPERTY:
			if (StorageDeviceProperty == ((PSTORAGE_PROPERTY_QUERY)irp->AssociatedIrp.SystemBuffer)->PropertyId) {
				ChangeIoc(ioc, irp, StorageQueryIoc);
			}
			break;
		case IOCTL_ATA_PASS_THROUGH:
			ChangeIoc(ioc, irp, AtaPassIoc);
			break;
		case SMART_RCV_DRIVE_DATA:
			ChangeIoc(ioc, irp, SmartDataIoc);
			break;
	}

	return DiskControlOriginal(device, irp);
}

VOID SpoofRaidUnits(RU_REGISTER_INTERFACES RaidUnitRegisterInterfaces, BYTE RaidUnitExtension_SerialNumber_offset) {
	UNICODE_STRING storahci_str = RTL_CONSTANT_STRING(L"\\Driver\\storahci");
	PDRIVER_OBJECT storahci_object = 0;
	
	// Enumerate RaidPorts in storahci
	NTSTATUS status = ObReferenceObjectByName(&storahci_str, OBJ_CASE_INSENSITIVE, 0, 0, *IoDriverObjectType, KernelMode, 0, &storahci_object);
	if (NT_SUCCESS(status)) {
		ULONG length = 0;
		if (STATUS_BUFFER_TOO_SMALL == (status = IoEnumerateDeviceObjectList(storahci_object, 0, 0, &length)) && length) {
			ULONG size = length * sizeof(PDEVICE_OBJECT);
			PDEVICE_OBJECT *devices = ExAllocatePool(NonPagedPool, size);
			if (devices) {
				if (NT_SUCCESS(status = IoEnumerateDeviceObjectList(storahci_object, devices, size, &length)) && length) {
					for (ULONG i = 0; i < length; ++i) {
						PDEVICE_OBJECT raidport_object = devices[i];
						
						BYTE buffer[MAX_PATH] = { 0 };
						if (NT_SUCCESS(ObQueryNameString(raidport_object, (POBJECT_NAME_INFORMATION)buffer, sizeof(buffer), &size))) {
							PUNICODE_STRING raidport_str = (PUNICODE_STRING)buffer;

							// Enumerate devices for each RaidPort
							if (wcsstr(raidport_str->Buffer, L"\\RaidPort")) {
								DWORD total = 0, success = 0;
								for (PDEVICE_OBJECT device = raidport_object->DriverObject->DeviceObject; device; device = device->NextDevice) {
									if (FILE_DEVICE_DISK == device->DeviceType) {
										PSTRING serial = (PSTRING)((PBYTE)device->DeviceExtension + RaidUnitExtension_SerialNumber_offset);
										strcpy(serial->Buffer, SERIAL);
										serial->Length = (USHORT)strlen(SERIAL);

										if (NT_SUCCESS(status = RaidUnitRegisterInterfaces(device->DeviceExtension))) {
											++success;
										} else {
											printf("! RaidUnitRegisterInterfaces failed: %p !\n", status);
										}

										++total;
									}
								}

								printf("%wZ: RaidUnitRegisterInterfaces succeeded for %d/%d\n", raidport_str, success, total);
							}
						}

						ObDereferenceObject(raidport_object);
					}
				} else {
					printf("! failed to get storahci devices (got %d): %p !\n", length, status);
				}

				ExFreePool(devices);
			} else {
				printf("! failed to allocated %d storahci devices !\n", length);
			}
		} else {
			printf("! failed to get storahci device list size (got %d): %p !\n", length, status);
		}

		ObDereferenceObject(storahci_object);
	} else {
		printf("! failed to get %wZ: %p !\n", &storahci_object, status);
	}
}

VOID SpoofDisks() {
	SwapControl(RTL_CONSTANT_STRING(L"\\Driver\\partmgr"), PartControl, PartControlOriginal);

	UNICODE_STRING disk_str = RTL_CONSTANT_STRING(L"\\Driver\\Disk");
	PDRIVER_OBJECT disk_object = 0;

	NTSTATUS status = ObReferenceObjectByName(&disk_str, OBJ_CASE_INSENSITIVE, 0, 0, *IoDriverObjectType, KernelMode, 0, &disk_object);
	if (!NT_SUCCESS(status)) {
		printf("! failed to get %wZ: %p !\n", &disk_str, status);
		return;
	}

	AppendSwap(disk_str, &disk_object->MajorFunction[IRP_MJ_DEVICE_CONTROL], DiskControl, DiskControlOriginal);

	DISK_FAIL_PREDICTION DiskEnableDisableFailurePrediction = (DISK_FAIL_PREDICTION)FindPatternImage(disk_object->DriverStart, "\x48\x89\x00\x24\x10\x48\x89\x74\x24\x18\x57\x48\x81\xEC\x90\x00", "xx?xxxxxxxxxxxxx");
	if (DiskEnableDisableFailurePrediction) {
		ULONG length = 0;
		if (STATUS_BUFFER_TOO_SMALL == (status = IoEnumerateDeviceObjectList(disk_object, 0, 0, &length)) && length) {
			ULONG size = length * sizeof(PDEVICE_OBJECT);
			PDEVICE_OBJECT *devices = ExAllocatePool(NonPagedPool, size);
			if (devices) {
				if (NT_SUCCESS(status = IoEnumerateDeviceObjectList(disk_object, devices, size, &length)) && length) {
					ULONG success = 0, total = 0;

					for (ULONG i = 0; i < length; ++i) {
						PDEVICE_OBJECT device = devices[i];

						// Update disk properties for disk ID
						PDEVICE_OBJECT disk = IoGetAttachedDeviceReference(device);
						if (disk) {
							KEVENT event = { 0 };
							KeInitializeEvent(&event, NotificationEvent, FALSE);

							PIRP irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_UPDATE_PROPERTIES, disk, 0, 0, 0, 0, 0, &event, 0);
							if (irp) {
								if (STATUS_PENDING == IoCallDriver(disk, irp)) {
									KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, 0);
								}
							} else {
								printf("! failed to build IoControlRequest !\n");
							}

							ObDereferenceObject(disk);
						}

						PFUNCTIONAL_DEVICE_EXTENSION ext = device->DeviceExtension;
						if (ext) {
							strcpy((PCHAR)ext->DeviceDescriptor + ext->DeviceDescriptor->SerialNumberOffset, SERIAL);

							// Disables SMART
							if (NT_SUCCESS(status = DiskEnableDisableFailurePrediction(ext, FALSE))) {
								++success;
							} else {
								printf("! DiskEnableDisableFailurePrediction failed: %p !\n", status);
							}

							++total;
						}
						
						ObDereferenceObject(device);
					}

					printf("disabling smart succeeded for %d/%d\n", success, total);
				} else {
					printf("! failed to get disk devices (got %d): %p !\n", length, status);
				}

				ExFreePool(devices);
			} else {
				printf("! failed to allocated %d disk devices !\n", length);
			}
		} else {
			printf("! failed to get disk device list size (got %d): %p !\n", length, status);
		}
	} else {
		printf("! failed to find DiskEnableDisableFailurePrediction !\n");
	}

	ObDereferenceObject(disk_object);

	// RaidUnitRegisterInterfaces -> Registry
	PVOID storport = GetBaseAddress("storport.sys", 0);
	if (storport) {
		RU_REGISTER_INTERFACES RaidUnitRegisterInterfaces = (RU_REGISTER_INTERFACES)FindPatternImage(storport, "\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x85\xC0", "xxxx????xxxx????xx");
		if (RaidUnitRegisterInterfaces) {
			PBYTE RaidUnitExtension_SerialNumber = FindPatternImage(storport, "\x66\x39\x2C\x41", "xxxx");
			if (RaidUnitExtension_SerialNumber) {
				RaidUnitExtension_SerialNumber = FindPattern((PCHAR)RaidUnitExtension_SerialNumber, 32, "\x4C\x8D\x4F", "xxx");
				if (RaidUnitExtension_SerialNumber) {
					BYTE RaidUnitExtension_SerialNumber_offset = *(RaidUnitExtension_SerialNumber + 3);
					RaidUnitRegisterInterfaces = (RU_REGISTER_INTERFACES)((PBYTE)RaidUnitRegisterInterfaces + 8 + *(PINT)((PBYTE)RaidUnitRegisterInterfaces + 4));

					SpoofRaidUnits(RaidUnitRegisterInterfaces, RaidUnitExtension_SerialNumber_offset);
				} else {
					printf("! failed to find RaidUnitExtension_SerialNumber (1) !\n");
				}
			} else {
				printf("! failed to find RaidUnitExtension_SerialNumber (0) !\n");
			}
		} else {
			printf("! failed to find RaidUnitRegisterInterfaces !\n");
		}
	} else {
		printf("! failed to get \"storport.sys\" !\n");
	}
}

/**** VOLUMES ****/
NTSTATUS MountPointsIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(MOUNTMGR_MOUNT_POINTS)) {
			PMOUNTMGR_MOUNT_POINTS points = (PMOUNTMGR_MOUNT_POINTS)request.Buffer;
			for (DWORD i = 0; i < points->NumberOfMountPoints; ++i) {
				PMOUNTMGR_MOUNT_POINT point = &points->MountPoints[i];
				if (point->UniqueIdOffset) {
					point->UniqueIdLength = 0;
				}

				if (point->SymbolicLinkNameOffset) {
					point->SymbolicLinkNameLength = 0;
				}
			}
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS MountUniqueIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (request.BufferLength >= sizeof(MOUNTDEV_UNIQUE_ID)) {
			((PMOUNTDEV_UNIQUE_ID)request.Buffer)->UniqueIdLength = 0;
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS MountControl(PDEVICE_OBJECT device, PIRP irp) {
	PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
	switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_MOUNTMGR_QUERY_POINTS:
			ChangeIoc(ioc, irp, MountPointsIoc);
			break;
		case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
			ChangeIoc(ioc, irp, MountUniqueIoc);
			break;
	}

	return MountControlOriginal(device, irp);
}

// Volume serial is spoofed from usermode
void SpoofVolumes() {
	SwapControl(RTL_CONSTANT_STRING(L"\\Driver\\mountmgr"), MountControl, MountControlOriginal);
}

/**** NIC ****/
NTSTATUS NICIoc(PDEVICE_OBJECT device, PIRP irp, PVOID context) {
	if (context) {
		IOC_REQUEST request = *(PIOC_REQUEST)context;
		ExFreePool(context);

		if (irp->MdlAddress) {
			SpoofBuffer(SEED, (PBYTE)MmGetSystemAddressForMdl(irp->MdlAddress), 6);

			printf("handled NICIoc\n");
		}

		if (request.OldRoutine && irp->StackCount > 1) {
			return request.OldRoutine(device, irp, request.OldContext);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS NICControl(PDEVICE_OBJECT device, PIRP irp) {
	for (DWORD i = 0; i < NICs.Length; ++i) {
		PNIC_DRIVER driver = &NICs.Drivers[i];

		if (driver->Original && driver->DriverObject == device->DriverObject) {
			PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
			switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
				case IOCTL_NDIS_QUERY_GLOBAL_STATS: {
					switch (*(PDWORD)irp->AssociatedIrp.SystemBuffer) {
						case OID_802_3_PERMANENT_ADDRESS:
						case OID_802_3_CURRENT_ADDRESS:
						case OID_802_5_PERMANENT_ADDRESS:
						case OID_802_5_CURRENT_ADDRESS:
							ChangeIoc(ioc, irp, NICIoc);
							break;
					}

					break;
				}
			}

			return driver->Original(device, irp);
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS NsiControl(PDEVICE_OBJECT device, PIRP irp) {
	PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
	switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_NSI_PROXY_ARP: {
			DWORD length = ioc->Parameters.DeviceIoControl.OutputBufferLength;
			NTSTATUS ret = NsiControlOriginal(device, irp);

			PNSI_PARAMS params = (PNSI_PARAMS)irp->UserBuffer;
			if (params && NSI_PARAMS_ARP == params->Type) {
				memset(irp->UserBuffer, 0, length);

				printf("handled ARP table\n");
			}

			return ret;
		}
	}

	return NsiControlOriginal(device, irp);
}

VOID SpoofNIC() {
	SwapControl(RTL_CONSTANT_STRING(L"\\Driver\\nsiproxy"), NsiControl, NsiControlOriginal);

	PVOID base = GetBaseAddress("ndis.sys", 0);
	if (!base) {
		printf("! failed to get \"ndis.sys\" !\n");
		return;
	}

	PNDIS_FILTER_BLOCK ndisGlobalFilterList = FindPatternImage(base, "\x40\x8A\xF0\x48\x8B\x05", "xxxxxx");
	if (ndisGlobalFilterList) {
		PDWORD ndisFilter_IfBlock = FindPatternImage(base, "\x48\x85\x00\x0F\x84\x00\x00\x00\x00\x00\x8B\x00\x00\x00\x00\x00\x33", "xx?xx?????x???xxx");
		if (ndisFilter_IfBlock) {
			DWORD ndisFilter_IfBlock_offset = *(PDWORD)((PBYTE)ndisFilter_IfBlock + 12);

			ndisGlobalFilterList = (PNDIS_FILTER_BLOCK)((PBYTE)ndisGlobalFilterList + 3);
			ndisGlobalFilterList = *(PNDIS_FILTER_BLOCK *)((PBYTE)ndisGlobalFilterList + 7 + *(PINT)((PBYTE)ndisGlobalFilterList + 3));

			DWORD count = 0;
			for (PNDIS_FILTER_BLOCK filter = ndisGlobalFilterList; filter; filter = filter->NextFilter) {
				PNDIS_IF_BLOCK block = *(PNDIS_IF_BLOCK *)((PBYTE)filter + ndisFilter_IfBlock_offset);
				if (block) {
					PWCHAR copy = SafeCopy(filter->FilterInstanceName->Buffer, MAX_PATH);
					if (copy) {
						WCHAR adapter[MAX_PATH] = { 0 };
						swprintf(adapter, L"\\Device\\%ws", TrimGUID(copy, MAX_PATH / 2));
						ExFreePool(copy);

						printf("found NIC %ws\n", adapter);

						UNICODE_STRING name = { 0 };
						RtlInitUnicodeString(&name, adapter);

						PFILE_OBJECT file = 0;
						PDEVICE_OBJECT device = 0;

						NTSTATUS status = IoGetDeviceObjectPointer(&name, FILE_READ_DATA, &file, &device);
						if (NT_SUCCESS(status)) {
							PDRIVER_OBJECT driver = device->DriverObject;
							if (driver) {
								BOOL exists = FALSE;
								for (DWORD i = 0; i < NICs.Length; ++i) {
									if (NICs.Drivers[i].DriverObject == driver) {
										exists = TRUE;
										break;
									}
								}

								if (exists) {
									printf("%wZ already swapped\n", &driver->DriverName);
								} else {
									PNIC_DRIVER nic = &NICs.Drivers[NICs.Length];
									nic->DriverObject = driver;

									AppendSwap(driver->DriverName, &driver->MajorFunction[IRP_MJ_DEVICE_CONTROL], NICControl, nic->Original);

									++NICs.Length;
								}
							}

							// Indirectly dereferences device object
							ObDereferenceObject(file);
						} else {
							printf("! failed to get %wZ: %p !\n", &name, status);
						}
					}

					// Current MAC
					PIF_PHYSICAL_ADDRESS_LH addr = &block->ifPhysAddress;
					SpoofBuffer(SEED, addr->Address, addr->Length);
					addr = &block->PermanentPhysAddress;
					SpoofBuffer(SEED, addr->Address, addr->Length);

					++count;
				}
			}

			printf("handled %d MACs\n", count);
		} else {
			printf("! failed to find ndisFilter_IfBlock !\n");
		}
	} else {
		printf("! failed to find ndisGlobalFilterList !\n");
	}
}

/**** SMBIOS (and boot) ****/
void SpoofSMBIOS() {
	PVOID base = GetBaseAddress("ntoskrnl.exe", 0);
	if (!base) {
		printf("! failed to get \"ntoskrnl.exe\" !\n");
		return;
	}

	PBYTE ExpBootEnvironmentInformation = FindPatternImage(base, "\x0F\x10\x05\x00\x00\x00\x00\x0F\x11\x00\x8B", "xxx????xx?x");
	if (ExpBootEnvironmentInformation) {
		ExpBootEnvironmentInformation = ExpBootEnvironmentInformation + 7 + *(PINT)(ExpBootEnvironmentInformation + 3);
		SpoofBuffer(SEED, ExpBootEnvironmentInformation, 16);

		printf("handled ExpBootEnvironmentInformation\n");
	} else {
		printf("! ExpBootEnvironmentInformation not found !\n");
	}

	PPHYSICAL_ADDRESS WmipSMBiosTablePhysicalAddress = FindPatternImage(base, "\x48\x8B\x0D\x00\x00\x00\x00\x48\x85\xC9\x74\x00\x8B\x15", "xxx????xxxx?xx");
	if (WmipSMBiosTablePhysicalAddress) {
		WmipSMBiosTablePhysicalAddress = (PPHYSICAL_ADDRESS)((PBYTE)WmipSMBiosTablePhysicalAddress + 7 + *(PINT)((PBYTE)WmipSMBiosTablePhysicalAddress + 3));
		memset(WmipSMBiosTablePhysicalAddress, 0, sizeof(PHYSICAL_ADDRESS));

		printf("nulled SMBIOS table physical address\n");
	} else {
		printf("! WmipSMBiosTablePhysicalAddress not found !\n");
	}
}

/**** GPU ****/
NTSTATUS GpuControl(PDEVICE_OBJECT device, PIRP irp) {
	PIO_STACK_LOCATION ioc = IoGetCurrentIrpStackLocation(irp);
	switch (ioc->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_NVIDIA_SMIL: {
			NTSTATUS ret = GpuControlOriginal(device, irp);

			PCHAR buffer = irp->UserBuffer;
			if (buffer) {
				PCHAR copy = SafeCopy(buffer, IOCTL_NVIDIA_SMIL_MAX);
				if (copy) {
					for (DWORD i = 0; i < IOCTL_NVIDIA_SMIL_MAX - 4; ++i) {
						if (0 == memcmp(copy + i, "GPU-", 4)) {
							buffer[i] = 0;

							printf("handled GPU serial\n");
							break;
						}
					}

					ExFreePool(copy);
				}
			}

			return ret;
		}
	}

	return GpuControlOriginal(device, irp);
}

VOID SpoofGPU() {
	SwapControl(RTL_CONSTANT_STRING(L"\\Driver\\nvlddmkm"), GpuControl, GpuControlOriginal);
}

VOID DriverUnload(PDRIVER_OBJECT driver) {
	UNREFERENCED_PARAMETER(driver);
	printf("-- unloading\n");

	for (DWORD i = 0; i < SWAPS.Length; ++i) {
		PSWAP s = (PSWAP)&SWAPS.Buffer[i];
		if (s->Swap && s->Original) {
			InterlockedExchangePointer(s->Swap, s->Original);
			printf("reverted %wZ swap\n", &s->Name);
		}
	}

	printf("-- unloaded\n");
}

NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING registry_path) {
	UNREFERENCED_PARAMETER(registry_path);
	driver->DriverUnload = DriverUnload;

	ULONG64 time = 0;
	KeQuerySystemTime(&time);
	SEED = (DWORD)time;

	CHAR alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
	for (DWORD i = 0, l = (DWORD)strlen(SERIAL); i < l; ++i) {
		SERIAL[i] = alphabet[RtlRandomEx(&SEED) % (sizeof(alphabet) - 1)];
	}

	printf("++ loading (serial: %s)\n", SERIAL);

	SpoofDisks();
	SpoofVolumes();
	SpoofNIC();
	SpoofSMBIOS();
	SpoofGPU();

	printf("++ loaded\n");

	return STATUS_SUCCESS;
}

```

`Kernel/stdafx.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <ata.h>
#include <scsi.h>
#include <ntddndis.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <classpnp.h>
#include <ntimage.h>

#include "util.h"

static DWORD SEED = 0;
static CHAR SERIAL[] = "---------";

typedef struct _NIC_DRIVER {
	PDRIVER_OBJECT DriverObject;
	PDRIVER_DISPATCH Original;
} NIC_DRIVER, *PNIC_DRIVER;

typedef struct _SWAP {
	UNICODE_STRING Name;
	PVOID *Swap;
	PVOID Original;
} SWAP, *PSWAP;

static struct {
	SWAP Buffer[0xFF];
	ULONG Length;
} SWAPS = { 0 };

// Appends swap to swap list
#define AppendSwap(name, swap, hook, original) { \
	UNICODE_STRING _n = name; \
	PSWAP _s = &SWAPS.Buffer[SWAPS.Length++]; \
	*(PVOID *)&original = _s->Original = InterlockedExchangePointer((PVOID *)(_s->Swap = (PVOID *)swap), (PVOID)hook); \
	_s->Name = _n; \
	printf("swapped %wZ\n", &_n); \
}

// Swaps MJ device control and appends it to swap list on success
#define SwapControl(driver, hook, original) { \
	UNICODE_STRING str = driver; \
	PDRIVER_OBJECT object = 0; \
	NTSTATUS _status = ObReferenceObjectByName(&str, OBJ_CASE_INSENSITIVE, 0, 0, *IoDriverObjectType, KernelMode, 0, &object); \
	if (NT_SUCCESS(_status)) { \
		AppendSwap(str, &object->MajorFunction[IRP_MJ_DEVICE_CONTROL], hook, original); \
		ObDereferenceObject(object); \
	} else { \
		printf("! failed to get %wZ: %p !\n", &str, _status); \
	} \
}
```

`Kernel/util.c`:

```c
#include "stdafx.h"

PCHAR LowerStr(PCHAR str) {
	for (PCHAR s = str; *s; ++s) {
		*s = (CHAR)tolower(*s);
	}
	return str;
}

DWORD Random(PDWORD seed) {
	DWORD s = *seed * 1103515245 + 12345;
	*seed = s;
	return (s / 65536) % 32768;
}

DWORD Hash(PBYTE buffer, DWORD length) {
	if (!length) {
		return 0;
	}

	DWORD h = (*buffer ^ 0x4B9ACE2F) * 0x1000193;
	for (DWORD i = 1; i < length; ++i) {
		h = (buffer[i] ^ h) * 0x1000193;
	}
	return h;
}

PVOID SafeCopy(PVOID src, DWORD size) {
	PCHAR buffer = (PCHAR)ExAllocatePool(NonPagedPool, size);
	if (buffer) {
		MM_COPY_ADDRESS addr = { 0 };
		addr.VirtualAddress = src;

		SIZE_T read = 0;
		if (NT_SUCCESS(MmCopyMemory(buffer, addr, size, MM_COPY_MEMORY_VIRTUAL, &read)) && read == size) {
			return buffer;
		}

		ExFreePool(buffer);
	} else {
		printf("! failed to allocate pool of size %d !\n", size);
	}

	return 0;
}

VOID SpoofBuffer(DWORD seed, PBYTE buffer, DWORD length) {
	seed ^= Hash(buffer, length);
	for (DWORD i = 0; i < length; ++i) {
		buffer[i] ^= (BYTE)Random(&seed);
	}
}

PWCHAR TrimGUID(PWCHAR guid, DWORD max) {
	DWORD i = 0;
	PWCHAR start = guid;

	--max;
	for (; i < max && *start != L'{'; ++i, ++start);
	for (; i < max && guid[i++] != L'}';);
	
	guid[i] = 0;
	return start;
}

VOID ChangeIoc(PIO_STACK_LOCATION ioc, PIRP irp, PIO_COMPLETION_ROUTINE routine) {
	PIOC_REQUEST request = (PIOC_REQUEST)ExAllocatePool(NonPagedPool, sizeof(IOC_REQUEST));
	if (!request) {
		printf("! failed to allocate IOC_REQUEST !\n");
		return;
	}

	request->Buffer = irp->AssociatedIrp.SystemBuffer;
	request->BufferLength = ioc->Parameters.DeviceIoControl.OutputBufferLength;
	request->OldContext = ioc->Context;
	request->OldRoutine = ioc->CompletionRoutine;

	ioc->Control = SL_INVOKE_ON_SUCCESS;
	ioc->Context = request;
	ioc->CompletionRoutine = routine;
}

VOID SwapEndianess(PCHAR dest, PCHAR src) {
	for (size_t i = 0, l = strlen(src); i < l; i += 2) {
		dest[i] = src[i + 1];
		dest[i + 1] = src[i];
	}
}

BOOL CheckMask(PCHAR base, PCHAR pattern, PCHAR mask) {
	for (; *mask; ++base, ++pattern, ++mask) {
		if ('x' == *mask && *base != *pattern) {
			return FALSE;
		}
	}

	return TRUE;
}

PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask) {
	length -= (DWORD)strlen(mask);
	for (DWORD i = 0; i <= length; ++i) {
		PVOID addr = &base[i];
		if (CheckMask(addr, pattern, mask)) {
			return addr;
		}
	}

	return 0;
}

PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask) {
	PVOID match = 0;

	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
		PIMAGE_SECTION_HEADER section = &sections[i];
		if ('EGAP' == *(PINT)section->Name || memcmp(section->Name, ".text", 5) == 0) {
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match) {
				break;
			}
		}
	}

	return match;
}

PVOID GetBaseAddress(PCHAR name, PULONG out_size) {
	PVOID addr = 0;

	ULONG size = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &size);
	if (STATUS_INFO_LENGTH_MISMATCH != status) {
		printf("! ZwQuerySystemInformation for size failed: %p !\n", status);
		return addr;
	}

	PSYSTEM_MODULE_INFORMATION modules = ExAllocatePool(NonPagedPool, size);
	if (!modules) {
		printf("! failed to allocate %d bytes for modules !\n", size);
		return addr;
	}

	if (!NT_SUCCESS(status = ZwQuerySystemInformation(SystemModuleInformation, modules, size, 0))) {
		ExFreePool(modules);
		
		printf("! ZwQuerySystemInformation failed: %p !\n", status);
		return addr;
	}

	for (ULONG i = 0; i < modules->NumberOfModules; ++i) {
		SYSTEM_MODULE m = modules->Modules[i];

		if (strstr(LowerStr((PCHAR)m.FullPathName), name)) {
			addr = m.ImageBase;
			if (out_size) {
				*out_size = m.ImageSize;
			}
			break;
		}
	}

	ExFreePool(modules);
	return addr;
}

```

`Kernel/util.h`:

```h
#pragma once

// Util defs
#define printf(fmt, ...) DbgPrint("[dbg] "fmt, ##__VA_ARGS__)
#define LENGTH(a) (sizeof(a) / sizeof(a[0]))

#define IOCTL_NVIDIA_SMIL (0x8DE0008)
#define IOCTL_NVIDIA_SMIL_MAX (512)

typedef struct _IOC_REQUEST {
	PVOID Buffer;
	ULONG BufferLength;
	PVOID OldContext;
	PIO_COMPLETION_ROUTINE OldRoutine;
} IOC_REQUEST, *PIOC_REQUEST;

PCHAR LowerStr(PCHAR str);
DWORD Random(PDWORD seed);
PVOID SafeCopy(PVOID src, DWORD size);
VOID SpoofBuffer(DWORD seed, PBYTE buffer, DWORD length);
PWCHAR TrimGUID(PWCHAR guid, DWORD max);
VOID ChangeIoc(PIO_STACK_LOCATION ioc, PIRP irp, PIO_COMPLETION_ROUTINE routine);
VOID SwapEndianess(PCHAR dest, PCHAR src);
PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask);
PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask);
PVOID GetBaseAddress(PCHAR name, PULONG out_size);

// Win defs
#define IsListEmtpy(list) (list == list->Flink)

typedef NTSTATUS(__fastcall *DISK_FAIL_PREDICTION)(PVOID device_extension, BYTE enable);
typedef NTSTATUS(__fastcall *RU_REGISTER_INTERFACES)(PVOID device_extension);
extern POBJECT_TYPE *IoDriverObjectType;
NTKERNELAPI NTSTATUS ObReferenceObjectByName(IN PUNICODE_STRING ObjectName, IN ULONG Attributes, IN PACCESS_STATE PassedAccessState, IN ACCESS_MASK DesiredAccess, IN POBJECT_TYPE ObjectType, IN KPROCESSOR_MODE AccessMode, IN OUT PVOID ParseContext, OUT PVOID * Object);
NTSTATUS NTAPI ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

// dt ndis!_NDIS_IF_BLOCK
typedef struct _NDIS_IF_BLOCK {
	char _padding_0[0x464];
	IF_PHYSICAL_ADDRESS_LH ifPhysAddress; // 0x464
	IF_PHYSICAL_ADDRESS_LH PermanentPhysAddress; // 0x486
} NDIS_IF_BLOCK, *PNDIS_IF_BLOCK;

typedef struct _KSTRING {
	char _padding_0[0x10];
	WCHAR Buffer[1]; // 0x10 at least
} KSTRING, *PKSTRING;

// dt ndis!_NDIS_FILTER_BLOCK
typedef struct _NDIS_FILTER_BLOCK {
	char _padding_0[0x8];
	struct _NDIS_FILTER_BLOCK *NextFilter; // 0x8
	char _padding_1[0x18];
	PKSTRING FilterInstanceName; // 0x28
} NDIS_FILTER_BLOCK, *PNDIS_FILTER_BLOCK;

typedef struct _STOR_SCSI_IDENTITY {
	INQUIRYDATA *InquiryData;
	STRING SerialNumber;
	CHAR Supports1667;
	CHAR ZonedDevice;
} STOR_SCSI_IDENTITY, *PSTOR_SCSI_IDENTITY;

#define IOCTL_NSI_PROXY_ARP (0x0012001B)
#define NSI_PARAMS_ARP (11)
typedef struct _NSI_PARAMS {
	char _padding_0[0x18];
	ULONG Type; // 0x18
} NSI_PARAMS, *PNSI_PARAMS;

typedef struct _IDSECTOR {
	USHORT  wGenConfig;
	USHORT  wNumCyls;
	USHORT  wReserved;
	USHORT  wNumHeads;
	USHORT  wBytesPerTrack;
	USHORT  wBytesPerSector;
	USHORT  wSectorsPerTrack;
	USHORT  wVendorUnique[3];
	CHAR    sSerialNumber[20];
	USHORT  wBufferType;
	USHORT  wBufferSize;
	USHORT  wECCSize;
	CHAR    sFirmwareRev[8];
	CHAR    sModelNumber[40];
	USHORT  wMoreVendorUnique;
	USHORT  wDoubleWordIO;
	USHORT  wCapabilities;
	USHORT  wReserved1;
	USHORT  wPIOTiming;
	USHORT  wDMATiming;
	USHORT  wBS;
	USHORT  wNumCurrentCyls;
	USHORT  wNumCurrentHeads;
	USHORT  wNumCurrentSectorsPerTrack;
	ULONG   ulCurrentSectorCapacity;
	USHORT  wMultSectorStuff;
	ULONG   ulTotalAddressableSectors;
	USHORT  wSingleWordDMA;
	USHORT  wMultiWordDMA;
	BYTE    bReserved[128];
} IDSECTOR, *PIDSECTOR;

typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused;
	PVOID SectionPointer;
	ULONG CheckSum;
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

typedef struct _SYSTEM_MODULE {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION  {
	ULONG NumberOfModules;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;
```

`README.md`:

```md
# Permanent-HWID-Spoofer
A permanent hwid spoofer. Works for Valorant and all hwid locked applications.

```

`User/User.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{82CBF7D9-6CF2-4B1A-9BEC-CAF40175FE5A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>User</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`User/User.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`User/main.c`:

```c
#include "stdafx.h"

int main() {
	srand(GetTickCount());
	LoadLibrary(L"ntdll.dll");
	NtQueryKey = (NTQK)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryKey");
	if (!AdjustCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME)) {
		printf("failed to adjust privilege\n");
		return 1;
	}

	// Monitors
	OpenThen(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Enum\\DISPLAY", {
		ForEachSubkey(key, {
			OpenThen(key, name, {
				ForEachSubkey(key, {
					OpenThen(key, name, {
						ForEachSubkey(key, {
							if (_wcsicmp(name, L"device parameters") == 0) {
								SpoofBinary(key, name, L"EDID");
								break;
							}
						});
					});
				});
			});
		});
	});

	/*
	OpenThen(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Video", {
		ForEachSubkey(key, {
			HKEY parent = key;
			WCHAR spoof[MAX_PATH] = { 0 };

			OpenThen(HKEY_LOCAL_MACHINE, L"HARDWARE\\DEVICEMAP\\VIDEO", {
				DWORD count = 0;
				DWORD size = sizeof(count);
				if (GetKeyValue(key, L"MaxObjectNumber", (LPBYTE)&count, &size)) {
					WCHAR video[MAX_PATH] = { 0 };
					WCHAR path[MAX_PATH] = { 0 };

					for (DWORD i = 0; i < count; ++i) {
						size = sizeof(path);
						wsprintf(video, L"\\Device\\Video%d", i);
						if (GetKeyValue(key, video, (LPBYTE)path, &size)) {
							LPWSTR replace = StrStrIW(path, name);
							if (replace) {
								if (!spoof[0]) {
									wcscpy(spoof, name);
									OutSpoofUnique(spoof);
									RenameSubkey(parent, name, spoof);
								}

								memcpy(replace, spoof, wcslen(spoof) * 2);
								RegSetValueEx(key, video, 0, REG_SZ, (PBYTE)path, size);
							}
						}
					}
				}
			});
		});
	});
	*/

	// SMBIOS
	DeleteValue(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\mssmbios\\Data", L"SMBiosData");

	// Motherboard
	SpoofUniqueThen(HKEY_LOCAL_MACHINE, L"SYSTEM\\HardwareConfig", L"LastConfig", {
		ForEachSubkey(key, {
			if (_wcsicmp(name, L"current")) {
				RenameSubkey(key, name, spoof);
				break;
			}
		});
	});

	// NVIDIA
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\NVIDIA Corporation\\Global", L"ClientUUID");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\NVIDIA Corporation\\Global", L"PersistenceIdentifier");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\NVIDIA Corporation\\Global\\CoProcManager", L"ChipsetMatchID");

	// Misc
	DeleteKey(HKEY_LOCAL_MACHINE, L"SYSTEM\\MountedDevices");
	DeleteKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Dfrg\\Statistics");
	DeleteKey(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BitBucket\\Volume");
	DeleteKey(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2\\CPC\\Volume");
	DeleteKey(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2");
	DeleteValue(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BitBucket", L"LastEnum");

	SpoofBinary(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\TPM\\WMI", L"WindowsAIKHash");
	SpoofBinary(HKEY_CURRENT_USER, L"Software\\Microsoft\\Direct3D", L"WHQLClass");
	SpoofBinary(HKEY_CURRENT_USER, L"Software\\Classes\\Installer\\Dependencies", L"MSICache");

	OpenThen(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\0\\DiskController\\0\\DiskPeripheral", {
		ForEachSubkey(key, {
			SpoofUnique(key, name, L"Identifier");
		});
	});

	OpenThen(HKEY_LOCAL_MACHINE, L"HARDWARE\\DEVICEMAP\\Scsi", {
		ForEachSubkey(key, {
			OpenThen(key, name, {
				ForEachSubkey(key, {
					OpenThen(key, name, {
						ForEachSubkey(key, {
							if (wcsstr(name, L"arget")) {
								OpenThen(key, name, {
									ForEachSubkey(key, {
										SpoofUnique(key, name, L"Identifier");
									});
								});
							}
						});
					});
				});
			});
		});
	});

	SpoofBinary(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\TPM\\ODUID", L"RandomSeed");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Cryptography", L"MachineGuid");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\0001", L"HwProfileGuid");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate", L"AccountDomainSid");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate", L"PingID");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate", L"SusClientId");
	SpoofBinary(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate", L"SusClientIdValidation");
	SpoofBinary(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters", L"Dhcpv6DUID");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\SystemInformation", L"ComputerHardwareId");
	SpoofUniques(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\SystemInformation", L"ComputerHardwareIds");
	SpoofBinary(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Internet Explorer\\Migration", L"IE Installed Date");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\SQMClient", L"MachineId");
	SpoofQWORD(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\SQMClient", L"WinSqmFirstSessionStartTime");
	SpoofQWORD(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"InstallTime");
	SpoofQWORD(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"InstallDate");
	SpoofBinary(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"DigitalProductId");
	SpoofBinary(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"DigitalProductId4");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"BuildGUID");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ProductId");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"BuildLab");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"BuildLabEx");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\0000", L"_DriverProviderInfo");
	SpoofUnique(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\0000", L"UserModeDriverGUID");

	OpenThen(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}", {
		ForEachSubkey(key, {
			if (_wcsicmp(name, L"configuration") && _wcsicmp(name, L"properties")) {
				DeleteValue(key, name, L"NetworkAddress");
				SpoofQWORD(key, name, L"NetworkInterfaceInstallTimestamp");
			}
		});
	});

	DeleteKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Diagnostics\\DiagTrack\\SettingsRequests");
	SpoofQWORD(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Diagnostics\\DiagTrack\\SevilleEventlogManager", L"LastEventlogWrittenTime");
	SpoofQWORD(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform\\Activation", L"ProductActivationTime");
	DeleteValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform", L"BackupProductKeyDefault");
	DeleteValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform", L"actionlist");
	DeleteValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform", L"ServiceSessionId");
	DeleteKey(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist");
	DeleteKey(HKEY_CURRENT_USER, L"Software\\Hex-Rays\\IDA\\History");
	DeleteKey(HKEY_CURRENT_USER, L"Software\\Hex-Rays\\IDA\\History64");

	OpenThen(HKEY_LOCAL_MACHINE, L"HARDWARE\\UEFI\\ESRT", {
		WCHAR subkeys[0xFF][MAX_PATH] = { 0 };
		DWORD subkeys_length = 0;

		ForEachSubkey(key, {
			wcscpy(subkeys[subkeys_length++], name);
		});

		for (DWORD i = 0; i < subkeys_length; ++i) {
			WCHAR spoof[MAX_PATH] = { 0 };
			wcscpy(spoof, subkeys[i]);
			OutSpoofUnique(spoof);
			RenameSubkey(key, subkeys[i], spoof);
		}
	});

	// Tracking files
	WCHAR path[MAX_PATH] = { 0 };
	WCHAR temp[MAX_PATH] = { 0 };
	WCHAR appdata[MAX_PATH] = { 0 };
	WCHAR localappdata[MAX_PATH] = { 0 };
	GetTempPath(MAX_PATH, temp);

	SHGetFolderPath(0, CSIDL_APPDATA, 0, SHGFP_TYPE_DEFAULT, appdata);
	SHGetFolderPath(0, CSIDL_LOCAL_APPDATA, 0, SHGFP_TYPE_DEFAULT, localappdata);

	wsprintf(path, L"%ws*", temp);
	ForEachFile(path, {
		wsprintf(path, L"%ws%ws", temp, file);
		ForceDeleteFile(path);
	});

	wsprintf(path, L"%ws\\D3DSCache", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\NVIDIA Corporation\\GfeSDK", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\Feeds", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\Feeds Cache", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\Windows\\INetCache", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\Windows\\INetCookies", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\Windows\\WebCache", localappdata);
	ForceDeleteFile(path);

	wsprintf(path, L"%ws\\Microsoft\\XboxLive\\AuthStateCache.dat", localappdata);
	ForceDeleteFile(path);

	for (DWORD drives = GetLogicalDrives(), drive = L'C', index = 0; drives; drives >>= 1, ++index) {
		if (drives & 1) {
			printf("\n-- DRIVE: %c --\n\n", drive);

			// Volume serial change applies after restart
			wsprintf(path, L"\\\\.\\%c:", drive);
			HANDLE device = CreateFile(path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
			if (device != INVALID_HANDLE_VALUE) {
				BYTE sector[512] = { 0 };
				DWORD read = 0;
				if (ReadFile(device, sector, sizeof(sector), &read, 0) && read == sizeof(sector)) {
					for (DWORD i = 0; i < LENGTH(SECTORS); ++i) {
						PSECTOR s = &SECTORS[i];
						if (0 == memcmp(sector + s->NameOffset, s->Name, strlen(s->Name))) {
							*(PDWORD)(sector + s->SerialOffset) = (rand() << 16) + rand();
							if (INVALID_SET_FILE_POINTER != SetFilePointer(device, 0, 0, FILE_BEGIN)) {
								WriteFile(device, sector, sizeof(sector), 0, 0);
							}

							break;
						}
					}
				}

				CloseHandle(device);
			}

			wsprintf(path, L"%c:\\Windows\\System32\\restore\\MachineGuid.txt", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Users\\Public\\Libraries\\collection.dat", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\System Volume Information\\IndexerVolumeGuid", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\System Volume Information\\WPSettings.dat", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\System Volume Information\\tracking.log", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\ProgramData\\Microsoft\\Windows\\WER", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Users\\Public\\Shared Files", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Windows\\INF\\setupapi.dev.log", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Windows\\INF\\setupapi.setup.log", drive);
			ForceDeleteFile(path);

			// wsprintf(path, L"%c:\\Windows\\System32\\spp\\store", drive);
			// ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Users\\Public\\Libraries", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\MSOCache", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\ProgramData\\ntuser.pol", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Users\\Default\\NTUSER.DAT", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Recovery\\ntuser.sys", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\desktop.ini", drive);
			ForceDeleteFile(path);

			wsprintf(path, L"%c:\\Windows\\Prefetch\\*", drive);
			ForEachFile(path, {
				wsprintf(path, L"%c:\\Windows\\Prefetch\\%ws", drive, file);
				ForceDeleteFile(path);
			});

			wsprintf(path, L"%c:\\Users\\*", drive);
			ForEachFile(path, {
				if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
					WCHAR user[MAX_PATH] = { 0 };
					wcscpy(user, file);
					wsprintf(path, L"%c:\\Users\\%ws\\*", drive, user);
					ForEachFile(path, {
						if (StrStr(file, L"ntuser")) {
							wsprintf(path, L"%c:\\Users\\%ws\\%ws", drive, user, file);
							ForceDeleteFile(path);
						}
					});
				}
			});

			wsprintf(path, L"%c:\\Users", drive);
			RecursiveDelete(path, L"desktop.ini");

			CHAR journal[MAX_PATH] = { 0 };
			sprintf(journal, "fsutil usn deletejournal /d %c:", drive);
			system(journal);

			++drive;
		}
	}

	// Extra cleanup
	system("vssadmin delete shadows /All /Quiet");

	// WMIC holds cache of SMBIOS. With the driver loaded, starting WMIC will query the nulled SMBIOS data
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snapshot) {
		PROCESSENTRY32 entry = { 0 };
		entry.dwSize = sizeof(entry);
		if (Process32First(snapshot, &entry)) {
			do {
				// Sometimes 'net stop' by itself isn't enough
				if (0 == _wcsicmp(entry.szExeFile, L"WmiPrvSE.exe")) {
					HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, entry.th32ProcessID);
					if (INVALID_HANDLE_VALUE != process) {
						printf("Killed Winmgmt\n");
						TerminateProcess(process, 0);
						CloseHandle(process);
					}

					break;
				}
			} while (Process32Next(snapshot, &entry));
		}

		CloseHandle(snapshot);
	}

	system("net stop winmgmt /Y");

	system("pause");

	return 0;
}

```

`User/stdafx.h`:

```h
#pragma once

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <windows.h>
#include <shlwapi.h>
#include <accctrl.h>
#include <aclapi.h>
#include <shlobj_core.h>
#include <tlhelp32.h>

#pragma comment(lib, "shlwapi.lib")

#include "util.h"

typedef struct _SECTOR {
	LPCSTR Name;
	DWORD  NameOffset;
	DWORD  SerialOffset;
} SECTOR, *PSECTOR;

static SECTOR SECTORS[] = {
	{ "FAT",   0x36, 0x27 },
	{ "FAT32", 0x52, 0x43 },
	{ "NTFS",  0x03, 0x48 },
};
```

`User/util.c`:

```c
#include "stdafx.h"

static WCHAR alphabet[] = L"abcdef012345789";

LPWSTR GetKeyPath(HKEY key) {
	static WCHAR buffer[MAX_PATH] = { 0 };
	DWORD size = sizeof(buffer);
	memset(buffer, 0, sizeof(buffer));
	NtQueryKey(key, 3, buffer, size, &size);
	return buffer + 3;
}

BOOL GetKeyValue(HKEY key, LPCWSTR value, LPBYTE buffer, DWORD *size) {
	if (ERROR_SUCCESS == RegQueryValueEx(key, value, 0, 0, buffer, size)) {
		return TRUE;
	}

	printf("Failed to read: %ws\\%ws\n\n", GetKeyPath(key), value);
	return FALSE;
}

VOID OutSpoofUnique(LPWSTR buffer) {
	for (DWORD i = 0; i < wcslen(buffer); ++i) {
		if (iswxdigit(buffer[i])) {
			buffer[i] = alphabet[rand() % wcslen(alphabet)];
		}
	}
}

VOID KeySpoofOutGUID(HKEY key, LPCWSTR value, LPWSTR buffer, DWORD size) {
	if (!GetKeyValue(key, value, (LPBYTE)buffer, &size)) {
		return;
	}

	printf("%ws\\%ws\n%c%c %ws -> ", GetKeyPath(key), value, 192, 196, buffer);

	OutSpoofUnique(buffer);

	RegSetValueEx(key, value, 0, REG_SZ, (PBYTE)buffer, size);
	printf("%ws\n\n", buffer);
}

VOID KeySpoofUnique(HKEY key, LPCWSTR value) {
	WCHAR buffer[MAX_PATH] = { 0 };
	KeySpoofOutGUID(key, value, buffer, sizeof(buffer));
}

VOID SpoofUnique(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	OpenThen(key, subkey, {
		KeySpoofUnique(key, value);
	});
}

VOID SpoofUniques(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	OpenThen(key, subkey, {
		WCHAR buffer[0xFFF] = { 0 };
		DWORD size = sizeof(buffer);
		if (!GetKeyValue(key, value, (LPBYTE)buffer, &size)) {
			RegCloseKey(key);
			return;
		}

		for (DWORD i = 0; i < size; ++i) {
			if (iswxdigit(buffer[i])) {
				buffer[i] = alphabet[rand() % (wcslen(alphabet) - 1)];
			}
		}

		RegSetValueEx(key, value, 0, REG_MULTI_SZ, (PBYTE)buffer, size);
		printf("%ws\\%ws\n%c%c multi-string of length %d\n\n", GetKeyPath(key), value, 192, 196, size);
	});
}

VOID SpoofDWORD(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	OpenThen(key, subkey, {
		DWORD data = rand();
		if (ERROR_SUCCESS == RegSetValueEx(key, value, 0, REG_QWORD, (PBYTE)&data, sizeof(data))) {
			printf("%ws\\%ws\n%c%c qword\n\n", GetKeyPath(key), value, 192, 196);
		} else {
			printf("Failed to write: %ws\\%ws\n\n", GetKeyPath(key), value);
		}
	});
}

VOID SpoofQWORD(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	OpenThen(key, subkey, {
		LARGE_INTEGER data = { 0 };
		data.LowPart = rand();
		data.HighPart = rand();
		if (ERROR_SUCCESS == RegSetValueEx(key, value, 0, REG_QWORD, (PBYTE)&data, sizeof(data))) {
			printf("%ws\\%ws\n%c%c qword\n\n", GetKeyPath(key), value, 192, 196);
		} else {
			printf("Failed to write: %ws\\%ws\n\n", GetKeyPath(key), value);
		}
	});
}

VOID SpoofBinary(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	OpenThen(key, subkey, {
		DWORD size = 0;
		if (ERROR_SUCCESS != RegQueryValueEx(key, value, 0, 0, 0, &size)) {
			printf("Failed to query size of: %ws\\%ws\n\n", GetKeyPath(key), value);
			RegCloseKey(key);
			return;
		}

		BYTE *buffer = (BYTE *)malloc(size);
		if (!buffer) {
			printf("Failed to allocate buffer for SpoofBinary\n\n");
			RegCloseKey(key);
			return;
		}

		for (DWORD i = 0; i < size; ++i) {
			buffer[i] = (BYTE)(rand() % 0x100);
		}

		RegSetValueEx(key, value, 0, REG_BINARY, buffer, size);
		free(buffer);

		printf("%ws\\%ws\n%c%c binary of length %d\n\n", GetKeyPath(key), value, 192, 196, size);
	});
}

VOID RenameSubkey(HKEY key, LPCWSTR subkey, LPCWSTR name) {
	HKEY k = 0;
	DWORD error = RegCreateKey(key, name, &k);
	if (ERROR_CHILD_MUST_BE_VOLATILE == error) {
		error = RegCreateKeyEx(key, name, 0, 0, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, 0, &k, 0);
	}
	
	if (ERROR_SUCCESS != error) {
		printf("Failed to create key: %ws\\%ws\n\n", GetKeyPath(key), name);
		return;
	}

	if (ERROR_SUCCESS == RegCopyTree(key, subkey, k)) {
		if (ERROR_SUCCESS == SHDeleteKey(key, subkey)) {
			printf("%ws\\%ws\n%c%c renamed to %ws\n\n", GetKeyPath(key), subkey, 192, 196, name);
		} else {
			printf("Failed to delete key: %ws\\%ws\n\n", GetKeyPath(key), subkey);
		}
	} else {
		printf("Failed to copy key: %ws\\%ws\n\n", GetKeyPath(key), subkey);
	}

	RegCloseKey(k);
}

VOID DeleteKey(HKEY key, LPCWSTR subkey) {
	DWORD s = SHDeleteKey(key, subkey);
	if (ERROR_FILE_NOT_FOUND == s) {
		return;
	} else if (ERROR_SUCCESS == s) {
		printf("%ws\\%ws\n%c%c deleted\n\n", GetKeyPath(key), subkey, 192, 196);
	} else {
		printf("Failed to delete value: %ws\\%ws\n\n", GetKeyPath(key), subkey);
	}
}

VOID DeleteValue(HKEY key, LPCWSTR subkey, LPCWSTR value) {
	DWORD s = SHDeleteValue(key, subkey, value);
	if (ERROR_FILE_NOT_FOUND == s) {
		return;
	} else if (ERROR_SUCCESS == s) {
		printf("%ws\\%ws\\%ws\n%c%c deleted\n\n", GetKeyPath(key), subkey, value, 192, 196);
	} else {
		printf("Failed to delete value: %ws\\%ws\\%ws\n\n", GetKeyPath(key), subkey, value);
	}
}

BOOL AdjustCurrentPrivilege(LPCWSTR privilege) {
	LUID luid = { 0 };
	if (!LookupPrivilegeValue(0, privilege, &luid)) {
		printf("Failed to lookup privilege %ws: %d\n", privilege, GetLastError());
		return FALSE;
	}

	TOKEN_PRIVILEGES tp = { 0 };
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	HANDLE token = 0;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {
		printf("Failed to open current process token: %d\n", GetLastError());
		return FALSE;
	}

	if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(tp), 0, 0)) {
		printf("Failed to adjust current process token privileges: %d\n", GetLastError());
		CloseHandle(token);
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
		printf("Token failed to acquire privilege\n");
		CloseHandle(token);
		return FALSE;
	}

	CloseHandle(token);
	return TRUE;
}

VOID ForceDeleteFile(LPWSTR path) {
	if (!PathFileExists(path)) {
		return;
	}

	PSID all = 0, admin = 0;
	SID_IDENTIFIER_AUTHORITY world = SECURITY_WORLD_SID_AUTHORITY;
	if (!AllocateAndInitializeSid(&world, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &all)) {
		printf("Failed to initialize all SID for %ws: %d\n\n", path, GetLastError());
		return;
	}

	SID_IDENTIFIER_AUTHORITY auth = SECURITY_NT_AUTHORITY;
	if (!AllocateAndInitializeSid(&auth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &admin)) {
		printf("Failed to initialize admin SID for %ws: %d\n\n", path, GetLastError());
		FreeSid(all);
		return;
	}

	EXPLICIT_ACCESS access[2] = { 0 };
	access[0].grfAccessPermissions = GENERIC_ALL;
	access[0].grfAccessMode = SET_ACCESS;
	access[0].grfInheritance = NO_INHERITANCE;
	access[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	access[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	access[0].Trustee.ptstrName = all;
	access[1].grfAccessPermissions = GENERIC_ALL;
	access[1].grfAccessMode = SET_ACCESS;
	access[1].grfInheritance = NO_INHERITANCE;
	access[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	access[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	access[1].Trustee.ptstrName = admin;

	PACL acl = { 0 };
	DWORD error = SetEntriesInAcl(2, access, 0, &acl);
	if (ERROR_SUCCESS != error) {
		printf("Failed to set ACL entries for %ws: %d\n\n", path, error);
		FreeSid(all);
		FreeSid(admin);
		return;
	}

	if (ERROR_SUCCESS != (error = SetNamedSecurityInfo((LPWSTR)path, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, admin, 0, 0, 0))) {
		printf("Failed to set owner security info for %ws: %d\n\n", path, error);
		FreeSid(all);
		FreeSid(admin);
		LocalFree(acl);
		return;
	}

	if (ERROR_SUCCESS != (error = SetNamedSecurityInfo((LPWSTR)path, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, 0, 0, acl, 0))) {
		printf("Failed to set DACL info for %ws: %d\n\n", path, error);
		FreeSid(all);
		FreeSid(admin);
		LocalFree(acl);
		return;
	}

	SetFileAttributes(path, FILE_ATTRIBUTE_NORMAL);

	SHFILEOPSTRUCT op = { 0 };
	op.wFunc = FO_DELETE;
	path[wcslen(path) + 1] = 0;
	op.pFrom = path;
	op.pTo = L"\0";
	op.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT;
	op.lpszProgressTitle = L"";
	if (DeleteFile(path) || !SHFileOperation(&op)) {
		printf("%ws\n%c%c deleted\n\n", path, 192, 196);
	} else {
		printf("Failed to delete file %ws: %d\n\n", path, GetLastError());
	}

	FreeSid(all);
	FreeSid(admin);
	LocalFree(acl);
}

VOID RecursiveDelete(LPWSTR dir, LPWSTR match) {
	WCHAR path[MAX_PATH] = { 0 };
	wsprintf(path, L"%ws\\*", dir);

	WIN32_FIND_DATA fd = { 0 };
	HANDLE f = FindFirstFile(path, &fd);

	do {
		WCHAR sub[MAX_PATH] = { 0 };
		wsprintf(sub, L"%ws\\%ws", dir, fd.cFileName);

		if (wcscmp(fd.cFileName, L".") && wcscmp(fd.cFileName, L"..")) {
			if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				RecursiveDelete(sub, match);
			} else if (StrStr(fd.cFileName, match)) {
				ForceDeleteFile(sub);
			}
		}
	} while (FindNextFile(f, &fd));

	FindClose(f);
}
```

`User/util.h`:

```h
#pragma once

#define LENGTH(a) (sizeof(a) / sizeof(a[0]))

typedef NTSTATUS(WINAPI *NTQK)(HANDLE KeyHandle, DWORD KeyInformationClass, PVOID KeyInformation, ULONG Length, PULONG ResultLength);
NTQK NtQueryKey;

LPWSTR GetKeyPath(HKEY key);
BOOL GetKeyValue(HKEY key, LPCWSTR value, LPBYTE buffer, DWORD *size);
VOID OutSpoofUnique(LPWSTR buffer);
VOID KeySpoofOutGUID(HKEY key, LPCWSTR value, LPWSTR buffer, DWORD size);
VOID KeySpoofUnique(HKEY key, LPCWSTR value);
VOID SpoofUnique(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID SpoofUniques(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID SpoofQWORD(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID SpoofDWORD(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID SpoofBinary(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID RenameSubkey(HKEY key, LPCWSTR subkey, LPCWSTR name);
VOID DeleteValue(HKEY key, LPCWSTR subkey, LPCWSTR value);
VOID DeleteKey(HKEY key, LPCWSTR subkey);
BOOL AdjustCurrentPrivilege(LPCWSTR privilege);
VOID ForceDeleteFile(LPWSTR path);
VOID RecursiveDelete(LPWSTR dir, LPWSTR match);

#define ForEachFile(dir, callback) { \
	WIN32_FIND_DATA fd = { 0 }; \
	HANDLE f = FindFirstFile(dir, &fd); \
	do { \
		if (wcscmp(fd.cFileName, L".") && wcscmp(fd.cFileName, L"..")) { \
			LPWSTR file = fd.cFileName; \
			callback; \
		} \
	} while (FindNextFile(f, &fd)); \
	FindClose(f); \
}

#define ForEachSubkey(hkey_key, callback) { \
	WCHAR name[MAX_PATH] = { 0 }; \
	for (DWORD _i = 0, _s = sizeof(name); ERROR_SUCCESS == RegEnumKeyEx(hkey_key, _i, name, &_s, 0, 0, 0, 0); ++_i, _s = sizeof(name)) { \
		callback; \
	} \
}

#define SpoofUniqueThen(hkey_key, lpcwstr_subkey, lpcwstr_value, callback) { \
	HKEY _k = 0; \
	if (ERROR_SUCCESS != RegOpenKeyEx(hkey_key, lpcwstr_subkey, 0, KEY_ALL_ACCESS, &_k)) { \
		printf("Failed to open key: %ws\\%ws\n\n", GetKeyPath(hkey_key), lpcwstr_subkey); \
	} else { \
		WCHAR spoof[MAX_PATH] = { 0 }; \
		HKEY key = _k; \
		KeySpoofOutGUID(key, lpcwstr_value, spoof, sizeof(spoof)); \
		callback; \
		RegCloseKey(key); \
	} \
}

#define OpenThen(hkey_key, lpcwstr_subkey, callback) { \
	HKEY _k = 0; \
	if (ERROR_SUCCESS != RegOpenKeyEx(hkey_key, lpcwstr_subkey, 0, KEY_ALL_ACCESS, &_k)) { \
		printf("Failed to open key: %ws\\%ws\n\n", GetKeyPath(hkey_key), lpcwstr_subkey); \
	} else { \
		HKEY key = _k; \
		callback; \
		RegCloseKey(key); \
	} \
}
```

`hwid_spoofer_gui.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG1 DIALOGEX 0, 0, 558, 315
STYLE DS_ABSALIGN | DS_SETFONT | DS_MODALFRAME | DS_3DLOOK | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "硬件信息修改器 v1.0"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "硬盘",IDC_STATIC,7,7,176,279
    COMBOBOX        IDC_COMBO1,15,21,46,30,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "修改序列号",IDC_BUTTON1,15,36,154,17
    EDITTEXT        IDC_EDIT1,67,21,101,12,ES_AUTOHSCROLL
    PUSHBUTTON      "随机化修改全部序列号",IDC_BUTTON2,15,55,154,17
    EDITTEXT        IDC_EDIT2,52,82,117,12,ES_AUTOHSCROLL
    CONTROL         "自定义模式",IDC_CHECK1,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,132,104,10
    CONTROL         "随机化模式",IDC_CHECK2,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,146,104,10
    CONTROL         "全清空模式",IDC_CHECK3,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,160,104,10
    PUSHBUTTON      "加载驱动程序",IDC_BUTTON3,7,294,244,14
    PUSHBUTTON      "卸载驱动程序",IDC_BUTTON4,307,294,244,14
    CONTROL         "随机化硬盘GUID模式",IDC_CHECK4,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,186,104,10
    CONTROL         "全清空硬盘VOLUMN模式",IDC_CHECK5,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,199,104,10
    PUSHBUTTON      "尝试禁用SMART(可能蓝屏)",IDC_BUTTON5,15,258,154,17
    PUSHBUTTON      "尝试无HOOK修改序列号(可能蓝屏)",IDC_BUTTON6,15,237,154,17
    EDITTEXT        IDC_EDIT3,52,220,117,12,ES_AUTOHSCROLL
    GROUPBOX        "BOIS",IDC_STATIC,191,7,176,146
    PUSHBUTTON      "随机化序列号/版本号(可能蓝屏)",IDC_BUTTON7,201,128,154,17
    GROUPBOX        "显卡",IDC_STATIC,191,173,176,113
    EDITTEXT        IDC_EDIT4,237,188,117,12,ES_AUTOHSCROLL
    PUSHBUTTON      "自定义显卡序列号",IDC_BUTTON8,199,256,154,17
    GROUPBOX        "网卡",IDC_STATIC,375,7,176,104
    CONTROL         "全清空ARP TABLE",IDC_CHECK6,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,387,61,108,10
    CONTROL         "随机化全部物理MAC地址",IDC_CHECK7,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,387,77,108,10
    LTEXT           "序列号:",IDC_STATIC,15,84,30,8
    LTEXT           "硬盘名:",IDC_STATIC,15,100,30,8
    EDITTEXT        IDC_EDIT5,52,98,117,12,ES_AUTOHSCROLL
    LTEXT           "固件值:",IDC_STATIC,15,116,30,8
    EDITTEXT        IDC_EDIT6,52,114,117,12,ES_AUTOHSCROLL
    LTEXT           "序列号:",IDC_STATIC,16,223,30,8
    LTEXT           "供应商:",IDC_STATIC,200,22,30,8
    EDITTEXT        IDC_EDIT7,237,19,117,12,ES_AUTOHSCROLL
    LTEXT           "版本号:",IDC_STATIC,200,40,30,8
    EDITTEXT        IDC_EDIT8,237,37,117,12,ES_AUTOHSCROLL
    LTEXT           "时间点:",IDC_STATIC,200,58,30,8
    LTEXT           "制作商:",IDC_STATIC,200,76,30,8
    LTEXT           "产品名:",IDC_STATIC,200,94,30,8
    LTEXT           "序列号:",IDC_STATIC,200,112,30,8
    EDITTEXT        IDC_EDIT9,237,55,117,12,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT10,237,73,117,12,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT11,237,91,117,12,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT12,237,109,117,12,ES_AUTOHSCROLL
    LTEXT           "序列号:",IDC_STATIC,200,192,30,8
    LTEXT           "显卡名:",IDC_STATIC,200,214,30,8
    EDITTEXT        IDC_EDIT13,237,210,117,12,ES_AUTOHSCROLL
    LTEXT           "显存数:",IDC_STATIC,200,236,30,8
    EDITTEXT        IDC_EDIT14,237,232,117,12,ES_AUTOHSCROLL
    CONTROL         "自定义全部物理MAC地址",IDC_CHECK8,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,387,93,108,10
    LTEXT           "物理MAC:",IDC_STATIC,387,21,36,8
    EDITTEXT        IDC_EDIT15,429,19,117,12,ES_AUTOHSCROLL
    LTEXT           "当前MAC:",IDC_STATIC,387,40,36,8
    EDITTEXT        IDC_EDIT17,429,38,117,12,ES_AUTOHSCROLL
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG1, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 551
        TOPMARGIN, 7
        BOTTOMMARGIN, 308
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG1 AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "user.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404b0"
        BEGIN
            VALUE "CompanyName", "懒人科技无限公司"
            VALUE "FileDescription", "这是一个修改硬件数据的程序"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "Spoofer.exe"
            VALUE "LegalCopyright", "Copyright (C) 2021 - 2020"
            VALUE "OriginalFilename", "Spoofer.exe"
            VALUE "ProductName", "硬件信息修改程序"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`hwid_spoofer_gui.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{5B566A7A-464D-4206-880B-48DC1463E793}</ProjectGuid>
    <RootNamespace>hwidspoofergui</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>NotSet</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="disk.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="serial.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="disk.h" />
    <ClInclude Include="loader.hpp" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="serial.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="hwid_spoofer_gui.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="user.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`hwid_spoofer_gui.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="cpp">
      <UniqueIdentifier>{d9edd241-903a-431a-837d-2d8d03195cd7}</UniqueIdentifier>
    </Filter>
    <Filter Include="hpp">
      <UniqueIdentifier>{c47de1a0-eee3-4c4a-90d0-1c2a47fc2f50}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>cpp</Filter>
    </ClCompile>
    <ClCompile Include="serial.cpp">
      <Filter>cpp</Filter>
    </ClCompile>
    <ClCompile Include="disk.cpp">
      <Filter>cpp</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
    <ClInclude Include="serial.h">
      <Filter>hpp</Filter>
    </ClInclude>
    <ClInclude Include="disk.h">
      <Filter>hpp</Filter>
    </ClInclude>
    <ClInclude Include="loader.hpp">
      <Filter>hpp</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="hwid_spoofer_gui.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="user.ico">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`hwid_spoofer_gui.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`loader.hpp`:

```hpp
#pragma once
#include <Windows.h>

#include <iostream>

/* 安装驱动 */
bool install_driver(const wchar_t* drvPath, const wchar_t* serviceName)
{
	// 打开服务控制管理器数据库
	SC_HANDLE schSCManager = OpenSCManagerW(
		NULL,												// 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
		NULL,												// 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
		SC_MANAGER_ALL_ACCESS);		// 所有权限
	if (schSCManager == NULL)
	{
		std::cout << "[*] 错误码 : [ " << GetLastError() << " ] " << std::endl;
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 创建服务对象，添加至服务控制管理器数据库
	SC_HANDLE schService = CreateServiceW(
		schSCManager,									// 服务控件管理器数据库的句柄
		serviceName,										// 要安装的服务的名称
		serviceName,										// 用户界面程序用来标识服务的显示名称
		SERVICE_ALL_ACCESS,						// 对服务的访问权限：所有全权限
		SERVICE_KERNEL_DRIVER,				// 服务类型：驱动服务
		SERVICE_DEMAND_START,				// 服务启动选项：进程调用 StartService 时启动
		SERVICE_ERROR_IGNORE,					// 如果无法启动：忽略错误继续运行
		drvPath,												// 驱动文件绝对路径，如果包含空格需要多加双引号
		NULL,													// 服务所属的负载订购组：服务不属于某个组
		NULL,													// 接收订购组唯一标记值：不接收
		NULL,													// 服务加载顺序数组：服务没有依赖项
		NULL,													// 运行服务的账户名：使用 LocalSystem 账户
		NULL);													// LocalSystem 账户密码
	if (schService == NULL)
	{
		std::cout << "[*] 错误码 : [ " << GetLastError() << " ] " << std::endl;
		CloseServiceHandle(schService);
		CloseServiceHandle(schSCManager);
		return false;
	}

	CloseServiceHandle(schService);
	CloseServiceHandle(schSCManager);
	return true;
}

/* 启动服务 */
bool start_driver(const wchar_t* serviceName)
{
	// 打开服务控制管理器数据库
	SC_HANDLE schSCManager = OpenSCManagerW(
		NULL,													// 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
		NULL,													// 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
		SC_MANAGER_ALL_ACCESS);			// 所有权限
	if (schSCManager == NULL)
	{
		std::cout << "[*] 错误码 : [ " << GetLastError() << " ] " << std::endl;
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 打开服务
	SC_HANDLE hs = OpenServiceW(
		schSCManager,						// 服务控件管理器数据库的句柄
		serviceName,							// 要打开的服务名
		SERVICE_ALL_ACCESS);			// 服务访问权限：所有权限
	if (hs == NULL)
	{
		std::cout << "[*] 错误码 : [ " << GetLastError() << " ] " << std::endl;
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 开始服务
	if (StartServiceW(hs, 0, 0) == 0)
	{
		std::cout << "[*] 错误码 : [ " << GetLastError() << " ] " << std::endl;
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	CloseServiceHandle(hs);
	CloseServiceHandle(schSCManager);
	return true;
}

/* 停止服务 */
bool stop_driver(const wchar_t* serviceName)
{
	// 打开服务控制管理器数据库
	SC_HANDLE schSCManager = OpenSCManagerW(
		NULL,												// 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
		NULL,												// 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
		SC_MANAGER_ALL_ACCESS);		// 所有权限
	if (schSCManager == NULL)
	{
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 打开服务
	SC_HANDLE hs = OpenServiceW(
		schSCManager,							// 服务控件管理器数据库的句柄
		serviceName,								// 要打开的服务名
		SERVICE_ALL_ACCESS);				// 服务访问权限：所有权限
	if (hs == NULL)
	{
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 如果服务正在运行
	SERVICE_STATUS status;
	if (QueryServiceStatus(hs, &status) == 0)
	{
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	if (status.dwCurrentState != SERVICE_STOPPED && status.dwCurrentState != SERVICE_STOP_PENDING)
	{
		// 发送关闭服务请求
		if (ControlService(
			hs,												// 服务句柄
			SERVICE_CONTROL_STOP,       // 控制码：通知服务应该停止
			&status										// 接收最新的服务状态信息
		) == 0)
		{
			CloseServiceHandle(hs);
			CloseServiceHandle(schSCManager);
			return false;
		}

		// 判断超时
		int timeOut = 0;
		while (status.dwCurrentState != SERVICE_STOPPED)
		{
			timeOut++;
			QueryServiceStatus(hs, &status);
			Sleep(50);
		}

		if (timeOut > 80)
		{
			CloseServiceHandle(hs);
			CloseServiceHandle(schSCManager);
			return false;
		}
	}

	CloseServiceHandle(hs);
	CloseServiceHandle(schSCManager);
	return true;
}

/* 卸载驱动 */
bool unload_driver(const wchar_t* serviceName)
{
	// 打开服务控制管理器数据库
	SC_HANDLE schSCManager = OpenSCManagerW(
		NULL,												// 目标计算机的名称,NULL：连接本地计算机上的服务控制管理器
		NULL,												// 服务控制管理器数据库的名称，NULL：打开 SERVICES_ACTIVE_DATABASE 数据库
		SC_MANAGER_ALL_ACCESS);		// 所有权限
	if (schSCManager == NULL)
	{
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 打开服务
	SC_HANDLE hs = OpenServiceW(
		schSCManager,						// 服务控件管理器数据库的句柄
		serviceName,							// 要打开的服务名
		SERVICE_ALL_ACCESS);			// 服务访问权限：所有权限
	if (hs == NULL)
	{
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	// 删除服务
	if (DeleteService(hs) == 0)
	{
		CloseServiceHandle(hs);
		CloseServiceHandle(schSCManager);
		return false;
	}

	CloseServiceHandle(hs);
	CloseServiceHandle(schSCManager);
	return TRUE;
}

/* 开始安装 */
bool start_install_driver(const wchar_t* drvPath, const wchar_t* serviceName, bool uninstall = false)
{
	// 先尝试卸载
	if (uninstall)
	{
		stop_driver(serviceName);
		unload_driver(serviceName);
	}

	// 尝试加载
	return install_driver(drvPath, serviceName) && start_driver(serviceName);
}
```

`main.cpp`:

```cpp
#include "disk.h"
#include "loader.hpp"
#include "resource.h"

#include <time.h>
#include <windowsx.h>

#define ioctl_disk_customize_serial CTL_CODE(FILE_DEVICE_UNKNOWN, 0x500, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_random_serial CTL_CODE(FILE_DEVICE_UNKNOWN, 0x501, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_null_serial CTL_CODE(FILE_DEVICE_UNKNOWN, 0x502, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_random_guid CTL_CODE(FILE_DEVICE_UNKNOWN, 0x503, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_null_volumn CTL_CODE(FILE_DEVICE_UNKNOWN, 0x504, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_disable_smart CTL_CODE(FILE_DEVICE_UNKNOWN, 0x505, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_disk_change_serial CTL_CODE(FILE_DEVICE_UNKNOWN, 0x506, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define ioctl_smbois_customize CTL_CODE(FILE_DEVICE_UNKNOWN, 0x600, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define ioctl_gpu_customize CTL_CODE(FILE_DEVICE_UNKNOWN, 0x700, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define ioctl_arp_table_handle CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_mac_random CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define ioctl_mac_customize CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

struct common_buffer
{
	union
	{
		struct disk
		{
			int disk_mode;
			char serial_buffer[100];
			char product_buffer[100];
			char product_revision_buffer[100];
			bool guid_state;
			bool volumn_state;
		}_disk;

		struct smbois
		{
			char vendor[100]{ 0 };
			char version[100]{ 0 };
			char date[100]{ 0 };
			char manufacturer[100]{ 0 };
			char product_name[100]{ 0 };
			char serial_number[100]{ 0 };
		}_smbois;

		struct gpu
		{
			char serial_buffer[100];
		}_gpu;

		struct nic
		{
			bool arp_table;
			int mac_mode;
			char permanent[100]{ 0 };
			char current[100]{ 0 };
		}_nic;
	};
};

// 开启Win32视觉效果
#pragma comment(linker,"\"/manifestdependency:type='win32' \
name = 'Microsoft.Windows.Common-Controls' \
version = '6.0.0.0' \
processorArchitecture = '*' \
publicKeyToken = '6595b64144ccf1df' \
language = '*'\"")

const wchar_t* drv_name = L"NSpoofer";
HANDLE g_Driver = INVALID_HANDLE_VALUE;

// 硬盘初始化
VOID DiskInitialize(HWND h)
{
	std::map<char, unsigned long> drivers = get_disk_all_drive_serial();
	for (const auto& it : drivers)
	{
		char buffer[20]{ 0 };
		wsprintfA(buffer, "%c", it.first);
		ComboBox_AddString(GetDlgItem(h, IDC_COMBO1), buffer);
	}
}

// 显卡初始化
VOID GpuInitialize(HWND h)
{
	FILE *file = 0;
	char cmd[1024] = { 0 };

	if ((file = _popen("nvidia-smi -L", "r")) != NULL)
	{
		fgets(cmd, 1024, file);
		_pclose(file);

		auto beg = std::string{ cmd }.find("GPU-");
		auto end = std::string{ cmd }.find(")", beg);
		if (beg == std::string::npos || end == std::string::npos) return;
		std::string buf = std::string{ cmd }.substr(beg + 4, end - (beg + 4));

		SetWindowTextA(GetDlgItem(h, IDC_EDIT4), buf.c_str());
	}
}

// 硬盘的Command
VOID DiskCommand(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	int wmId = LOWORD(wParam);
	int wmEvent = HIWORD(wParam);

	switch (wmId)
	{
	case IDC_BUTTON1:
	{
		char buffer[50]{ 0 };
		ComboBox_GetText(GetDlgItem(hWnd, IDC_COMBO1), buffer, 50);
		if (strlen(buffer) == 0)
		{
			MessageBoxA(hWnd, "未选择卷标", 0, MB_OK | MB_ICONERROR);
			return;
		}

		char serial[50]{ 0 };
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT1), serial, 50);
		if (strlen(serial) == 0)
		{
			MessageBoxA(hWnd, "请输入新序列号", 0, MB_OK | MB_ICONERROR);
			return;
		}

		if (change_serial_number(buffer[0], atoi(serial)))
			MessageBoxA(hWnd, "卷标序列号修改成功", serial, MB_OK);
		else
			MessageBoxA(hWnd, "卷标序列号修改失败", buffer, MB_OK | MB_ICONERROR);
	}
	break;
	case IDC_BUTTON2:
	{
		srand((unsigned int)time(0));
		std::map<char, unsigned long> drivers = get_disk_all_drive_serial();
		for (const auto& it : drivers)
		{
			if (change_serial_number(it.first, rand() * rand()))
				MessageBoxA(hWnd, "卷标序列号修改成功", "温馨提示", MB_OK);
			else
				MessageBoxA(hWnd, "卷标序列号修改失败", 0, MB_OK | MB_ICONERROR);
		}
	}
	break;
	case IDC_BUTTON5:
	{
		if (g_Driver == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
			return;
		}

		DWORD res = 0;
		common_buffer common{ 0 };
		DeviceIoControl(g_Driver, ioctl_disk_disable_smart, &common, sizeof(common), 0, 0, &res, 0);
	}
	break;
	case IDC_BUTTON6:
	{
		if (g_Driver == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
			return;
		}

		char buffer[100]{ 0 };
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT3), buffer, 100);
		if (strlen(buffer) == 0)
		{
			MessageBoxA(hWnd, "请输入硬盘新序列号", 0, MB_OK | MB_ICONERROR);
			return;
		}

		DWORD res = 0;
		common_buffer common{ 0 };
		strcpy(common._disk.serial_buffer, buffer);
		DeviceIoControl(g_Driver, ioctl_disk_disable_smart, &common, sizeof(common), 0, 0, &res, 0);
	}
	break;
	}

	switch (wmEvent)
	{
	case CBN_SELCHANGE:
		if (wmId == IDC_COMBO1)
		{
			char buffer[50]{ 0 };
			ComboBox_GetText(GetDlgItem(hWnd, IDC_COMBO1), buffer, 50);

			std::map<char, unsigned long> drivers = get_disk_all_drive_serial();
			for (const auto& it : drivers)
			{
				if (it.first == buffer[0])
				{
					SetWindowTextA(GetDlgItem(hWnd, IDC_EDIT1), std::to_string(it.second).c_str());
					break;
				}
			}
		}
		break;
	case BN_CLICKED:
		if (wmId == IDC_CHECK1)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				SendMessageA(GetDlgItem(hWnd, IDC_CHECK1), BM_SETCHECK, 0, 0);
				return;
			}

			char serial_buffer[100]{ 0 };
			char disk_product_buffer[100]{ 0 };
			char disk_product_revision_buffer[100]{ 0 };
			GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT2), serial_buffer, 100);
			GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT5), disk_product_buffer, 100);
			GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT6), disk_product_revision_buffer, 100);
			if (strlen(serial_buffer) == 0 || strlen(disk_product_buffer) == 0 || strlen(disk_product_revision_buffer) == 0)
			{
				MessageBoxA(hWnd, "请输入完整硬盘新值", 0, MB_OK | MB_ICONERROR);
				SendMessageA(GetDlgItem(hWnd, IDC_CHECK1), BM_SETCHECK, 0, 0);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK1), BM_GETCHECK, 0, 0);
			if (result != BST_CHECKED) return;

			DWORD res = 0;
			common_buffer common{ 0 };
			common._disk.disk_mode = 0;
			strcpy(common._disk.serial_buffer, serial_buffer);
			strcpy(common._disk.product_buffer, disk_product_buffer);
			strcpy(common._disk.product_revision_buffer, disk_product_revision_buffer);
			DeviceIoControl(g_Driver, ioctl_disk_customize_serial, &common, sizeof(common), 0, 0, &res, 0);

			SendMessageA(GetDlgItem(hWnd, IDC_CHECK2), BM_SETCHECK, 0, 0);
			SendMessageA(GetDlgItem(hWnd, IDC_CHECK3), BM_SETCHECK, 0, 0);
		}
		if (wmId == IDC_CHECK2)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				SendMessageA(GetDlgItem(hWnd, IDC_CHECK2), BM_SETCHECK, 0, 0);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK2), BM_GETCHECK, 0, 0);
			if (result != BST_CHECKED) return;

			DWORD res = 0;
			common_buffer common{ 0 };
			common._disk.disk_mode = 1;
			DeviceIoControl(g_Driver, ioctl_disk_random_serial, &common, sizeof(common), 0, 0, &res, 0);

			SendMessageA(GetDlgItem(hWnd, IDC_CHECK1), BM_SETCHECK, 0, 0);
			SendMessageA(GetDlgItem(hWnd, IDC_CHECK3), BM_SETCHECK, 0, 0);
		}
		if (wmId == IDC_CHECK3)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				SendMessageA(GetDlgItem(hWnd, IDC_CHECK3), BM_SETCHECK, 0, 0);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK3), BM_GETCHECK, 0, 0);
			if (result != BST_CHECKED) return;

			DWORD res = 0;
			common_buffer common{ 0 };
			common._disk.disk_mode = 2;
			DeviceIoControl(g_Driver, ioctl_disk_null_serial, &common, sizeof(common), 0, 0, &res, 0);

			SendMessageA(GetDlgItem(hWnd, IDC_CHECK2), BM_SETCHECK, 0, 0);
			SendMessageA(GetDlgItem(hWnd, IDC_CHECK1), BM_SETCHECK, 0, 0);
		}
		if (wmId == IDC_CHECK4)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK4), BM_GETCHECK, 0, 0);

			DWORD res = 0;
			common_buffer common{ 0 };
			common._disk.guid_state = result;
			DeviceIoControl(g_Driver, ioctl_disk_random_guid, &common, sizeof(common), 0, 0, &res, 0);
		}
		if (wmId == IDC_CHECK5)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK5), BM_GETCHECK, 0, 0);

			DWORD res = 0;
			common_buffer common{ 0 };
			common._disk.volumn_state = result;
			DeviceIoControl(g_Driver, ioctl_disk_null_volumn, &common, sizeof(common), 0, 0, &res, 0);
		}
		break;
	}
}

// 驱动的Command
VOID DriverCommand(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	int wmId = LOWORD(wParam);
	int wmEvent = HIWORD(wParam);

	switch (wmId)
	{
	case IDC_BUTTON3:
	{
		if (g_Driver != INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "不允许重复加载驱动程序", 0, MB_OK | MB_ICONERROR);
			return;
		}

		OPENFILENAMEW ofn = { 0 };
		WCHAR strFilename[MAX_PATH] = { 0 };//用于接收文件名
		ofn.lStructSize = sizeof(OPENFILENAMEW);//结构体大小
		ofn.hwndOwner = NULL;//拥有着窗口句柄，为NULL表示对话框是非模态的，实际应用中一般都要有这个句柄
		ofn.lpstrFilter = L"SYS文件\0*.sys\0\0";//设置过滤
		ofn.nFilterIndex = 1;//过滤器索引
		ofn.lpstrFile = strFilename;//接收返回的文件名，注意第一个字符需要为NULL
		ofn.nMaxFile = sizeof(strFilename);//缓冲区长度
		ofn.lpstrInitialDir = NULL;//初始目录为默认
		ofn.lpstrTitle = L"请选择一个文件";//使用系统默认标题留空即可
		ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;//文件、目录必须存在，隐藏只读选项
		if (GetOpenFileNameW(&ofn) == FALSE)
		{
			MessageBoxA(hWnd, "没有选择驱动文件", 0, MB_OK | MB_ICONERROR);
			return;
		}

		if (start_install_driver(strFilename, drv_name, true) == false)
		{
			MessageBoxA(hWnd, "安装驱动程序失败", 0, MB_OK | MB_ICONERROR);
			return;
		}

#define DRIVER_NAME "\\\\.\\HwidSpoofer"
		g_Driver = CreateFileA(DRIVER_NAME, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
		if (g_Driver == INVALID_HANDLE_VALUE)
			MessageBoxA(hWnd, "链接驱动程序失败", 0, MB_OK | MB_ICONERROR);
		else
		{
			MessageBoxA(hWnd, "链接驱动程序成功", "温馨提示", MB_OK);
			EnableWindow(GetDlgItem(hWnd, IDC_BUTTON3), FALSE);
		}
	}
	break;
	case IDC_BUTTON4:
	{
		if (g_Driver != INVALID_HANDLE_VALUE)
			CloseHandle(g_Driver);
		g_Driver = INVALID_HANDLE_VALUE;

		stop_driver(drv_name);
		unload_driver(drv_name);

		MessageBoxA(hWnd, "卸载驱动成功", "温馨提示", MB_OK);
		EnableWindow(GetDlgItem(hWnd, IDC_BUTTON3), TRUE);
	}
	break;
	}
}

// BOIS的Command
VOID BoisCommand(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	int wmId = LOWORD(wParam);
	int wmEvent = HIWORD(wParam);

	switch (wmId)
	{
	case IDC_BUTTON7:
	{
		if (g_Driver == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
			return;
		}

		char vendor[100]{ 0 };
		char version[100]{ 0 };
		char date[100]{ 0 };
		char manufacturer[100]{ 0 };
		char product_name[100]{ 0 };
		char serial_number[100]{ 0 };
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT7), vendor, 100);
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT8), version, 100);
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT9), date, 100);
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT10), manufacturer, 100);
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT11), product_name, 100);
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT12), serial_number, 100);
		if (strlen(vendor) == 0
			|| strlen(version) == 0
			|| strlen(date) == 0
			|| strlen(manufacturer) == 0
			|| strlen(product_name) == 0
			|| strlen(serial_number) == 0)
		{
			MessageBoxA(hWnd, "请填写全部BOIS信息", 0, MB_OK | MB_ICONERROR);
			return;
		}

		if (MessageBoxA(hWnd, "只能修改一次,二次修改会导致蓝屏,是否继续?", "温馨提示", MB_YESNO | MB_ICONQUESTION) == IDYES)
		{
			DWORD res = 0;
			common_buffer common{ 0 };
			strcpy(common._smbois.vendor, vendor);
			strcpy(common._smbois.version, version);
			strcpy(common._smbois.date, date);
			strcpy(common._smbois.manufacturer, manufacturer);
			strcpy(common._smbois.product_name, product_name);
			strcpy(common._smbois.serial_number, serial_number);
			DeviceIoControl(g_Driver, ioctl_smbois_customize, &common, sizeof(common), 0, 0, &res, 0);
		}
	}
	break;
	}
}

// 显卡的Command
VOID GpuCommand(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	int wmId = LOWORD(wParam);
	int wmEvent = HIWORD(wParam);

	switch (wmId)
	{
	case IDC_BUTTON8:
	{
		if (g_Driver == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
			return;
		}

		char buffer[100]{ 0 };
		GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT4), buffer, 100);
		if (strlen(buffer) == 0)
		{
			MessageBoxA(hWnd, "请输入显卡新序列号", 0, MB_OK | MB_ICONERROR);
			return;
		}

		DWORD res = 0;
		common_buffer common{ 0 };
		strcpy(common._gpu.serial_buffer, buffer);
		DeviceIoControl(g_Driver, ioctl_gpu_customize, &common, sizeof(common), 0, 0, &res, 0);
	}
	break;
	}
}

// 网卡的Command
VOID NicCommand(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	int wmId = LOWORD(wParam);
	int wmEvent = HIWORD(wParam);

	switch (wmEvent)
	{
	case BN_CLICKED:
		if (wmId == IDC_CHECK6)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK6), BM_GETCHECK, 0, 0);

			DWORD res = 0;
			common_buffer common{ 0 };
			common._nic.arp_table = result;
			DeviceIoControl(g_Driver, ioctl_arp_table_handle, &common, sizeof(common), 0, 0, &res, 0);
		}
		if (wmId == IDC_CHECK7)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK7), BM_GETCHECK, 0, 0);
			if (result == 0) return;

			SendMessageA(GetDlgItem(hWnd, IDC_CHECK8), BM_SETCHECK, 0, 0);

			DWORD res = 0;
			common_buffer common{ 0 };
			common._nic.mac_mode = 0;
			DeviceIoControl(g_Driver, ioctl_mac_random, &common, sizeof(common), 0, 0, &res, 0);
		}
		if (wmId == IDC_CHECK8)
		{
			if (g_Driver == INVALID_HANDLE_VALUE)
			{
				MessageBoxA(hWnd, "未链接驱动程序", 0, MB_OK | MB_ICONERROR);
				return;
			}

			LRESULT result = SendMessageA(GetDlgItem(hWnd, IDC_CHECK8), BM_GETCHECK, 0, 0);
			if (result == 0) return;

			SendMessageA(GetDlgItem(hWnd, IDC_CHECK7), BM_SETCHECK, 0, 0);

			char permanent_mac[100]{ 0 };
			char current_mac[100]{ 0 };
			GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT15), permanent_mac, 100);
			GetWindowTextA(GetDlgItem(hWnd, IDC_EDIT17), current_mac, 100);
			if (strlen(permanent_mac) == 0 || strlen(current_mac) == 0)
			{
				MessageBoxA(hWnd, "请输入完整MAC地址", 0, MB_OK | MB_ICONERROR);
				return;
			}

			DWORD res = 0;
			common_buffer common{ 0 };
			strcpy(common._nic.permanent, permanent_mac);
			strcpy(common._nic.current, current_mac);
			common._nic.mac_mode = 1;
			DeviceIoControl(g_Driver, ioctl_mac_customize, &common, sizeof(common), 0, 0, &res, 0);
		}
		break;
	}
}

// 窗口过程函数
INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
		DiskInitialize(hWnd);
		GpuInitialize(hWnd);
		return 1;
	case WM_COMMAND:
		DiskCommand(hWnd, uMsg, wParam, lParam);
		DriverCommand(hWnd, uMsg, wParam, lParam);
		BoisCommand(hWnd, uMsg, wParam, lParam);
		GpuCommand(hWnd, uMsg, wParam, lParam);
		NicCommand(hWnd, uMsg, wParam, lParam);
		return 1;
	case WM_CLOSE:
		if (g_Driver != INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, "请先卸载驱动后再结束程序", 0, MB_OK | MB_ICONERROR);
			return 0;
		}
		PostQuitMessage(0);
		return 1;
	}

	return 0;
}

// 程序人口
int _stdcall WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int)
{
	HWND h = CreateDialogParamA(hInstance, MAKEINTRESOURCEA(IDD_DIALOG1), 0, DialogProc, 0);
	if (h)
	{
		// 创建窗口后马上显示和更新,不然窗口不出来哈
		ShowWindow(h, SW_SHOW);
		UpdateWindow(h);

		// 设置一下程序的图标
		SendMessage(h, WM_SETICON, FALSE, (LPARAM)LoadIconA(hInstance, MAKEINTRESOURCEA(IDI_ICON1)));

		MSG msg{ 0 };
		while (GetMessageA(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
	}

	return 1;
}
```

`resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 hwid_spoofer_gui.rc 使用
//
#define IDD_DIALOG1                     101
#define IDI_ICON1                       103
#define IDC_COMBO1                      1002
#define IDC_BUTTON1                     1004
#define IDC_EDIT1                       1005
#define IDC_BUTTON2                     1006
#define IDC_EDIT2                       1007
#define IDC_CHECK1                      1008
#define IDC_CHECK2                      1009
#define IDC_CHECK3                      1010
#define IDC_BUTTON3                     1011
#define IDC_BUTTON4                     1012
#define IDC_CHECK4                      1013
#define IDC_CHECK5                      1014
#define IDC_BUTTON5                     1015
#define IDC_BUTTON6                     1016
#define IDC_EDIT3                       1017
#define IDC_BUTTON7                     1018
#define IDC_EDIT4                       1019
#define IDC_BUTTON8                     1020
#define IDC_CHECK6                      1021
#define IDC_CHECK7                      1022
#define IDC_EDIT5                       1023
#define IDC_EDIT6                       1024
#define IDC_EDIT7                       1025
#define IDC_EDIT8                       1026
#define IDC_EDIT9                       1027
#define IDC_EDIT10                      1028
#define IDC_EDIT11                      1029
#define IDC_EDIT12                      1030
#define IDC_EDIT13                      1031
#define IDC_EDIT14                      1032
#define IDC_CHECK8                      1033
#define IDC_EDIT15                      1034
#define IDC_EDIT16                      1035
#define IDC_EDIT17                      1036

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`serial.cpp`:

```cpp
#include "serial.h"

#define VWIN32_DIOC_DOS_IOCTL     1		// specified MS-DOS device I/O ctl - Interrupt 21h Function 4400h - 4411h
#define VWIN32_DIOC_DOS_INT25     2		// Absolute Disk Read command - Interrupt 25h
#define VWIN32_DIOC_DOS_INT26     3		// Absolute Disk Write command - Interrupt 25h
#define VWIN32_DIOC_DOS_INT13     4		// Interrupt 13h commands
#define VWIN32_DIOC_SIMCTRLC      5			// Simulate Ctrl-C
#define VWIN32_DIOC_DOS_DRIVEINFO 6		// Interrupt 21h Function 730X commands

#define CARRY_FLAG 1

#pragma pack(1)

typedef struct _DISKIO {
	DWORD  dwStartSector;		// starting logical sector number
	WORD   wSectors;				// number of sectors
	DWORD  dwBuffer;				// address of read/write buffer
} DISKIO, *PDISKIO;

typedef struct _DIOC_REGISTERS
{
	DWORD reg_EBX;
	DWORD reg_EDX;
	DWORD reg_ECX;
	DWORD reg_EAX;
	DWORD reg_EDI;
	DWORD reg_ESI;
	DWORD reg_Flags;
} DIOC_REGISTERS, *PDIOC_REGISTERS;

#pragma pack()

bool DiskSectorWinNT::Open(char *vol)
{
	char szDrive[10]{ 0 };
	wsprintfA(szDrive, "\\\\.\\%c:", vol[0]);
	m_hDisk = ::CreateFile(
		szDrive,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);
	return m_hDisk != INVALID_HANDLE_VALUE;
}

void DiskSectorWinNT::Close()
{
	if (m_hDisk != INVALID_HANDLE_VALUE)
		::CloseHandle(m_hDisk);
}

bool DiskSectorWinNT::ReadSector(DWORD sector, char *Buffer, int sectorSize)
{
	DWORD read = 0;

	if (::SetFilePointer(m_hDisk, sector, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
		return false;

	if (!::ReadFile(m_hDisk, Buffer, sectorSize, &read, NULL))
		return false;

	return true;
}

bool DiskSectorWinNT::WriteSector(DWORD sector, char *Buffer, int sectorSize)
{
	DWORD wrote = 0;

	if (::SetFilePointer(m_hDisk, sector, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
		return false;

	if (!::WriteFile(m_hDisk, Buffer, sectorSize, &wrote, NULL))
		return false;

	return true;
}

DiskSector::DiskSector()
{
	if (GetVersion() > 0x80000000)
		util = new DiskSectorWin9x;
	else
		util = new DiskSectorWinNT;
}

void DiskSector::Close()
{
	util->Close();
}

bool DiskSector::Open(char *vol)
{
	return util->Open(vol);
}

bool DiskSector::WriteSector(DWORD sector, char *Buffer, int sectorSize)
{
	return util->WriteSector(sector, Buffer, sectorSize);
}

bool DiskSector::ReadSector(DWORD sector, char *Buffer, int sectorSize)
{
	return util->ReadSector(sector, Buffer, sectorSize);
}

DiskSector::~DiskSector()
{
	delete util;
}

bool DiskSectorWin9x::Open(char *vol)
{
	OSVERSIONINFOEX osvi = { 0 };
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	m_bOpened = false;

	if (!::GetVersionEx((OSVERSIONINFO *)&osvi))
	{
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if (!::GetVersionEx((OSVERSIONINFO *)&osvi))
			return false;
	}

	if (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
		return false;

	m_chDrive = toupper(vol[0]);
	m_nDriveNo = m_chDrive - 'A' + 1;

	char temp[10] = { 0 };
	wsprintfA(temp, "%c:\\", m_chDrive);

	if (::GetDriveType(temp) != DRIVE_FIXED)
		return false;

	m_bW9xOsr2AndAbove = (osvi.dwMajorVersion >= 4 && osvi.dwMinorVersion >= 10)
		||
		((osvi.dwBuildNumber == 4 && osvi.dwMinorVersion == 0)
			&& (osvi.szCSDVersion[1] == 'C' || osvi.szCSDVersion[1] == 'B'));

	m_hVmm32 = ::CreateFile("\\\\.\\VWIN32", 0, 0,
		NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

	m_bOpened = (m_hVmm32 != INVALID_HANDLE_VALUE);

	return m_bOpened;
}

void DiskSectorWin9x::Close()
{
	if (m_bOpened)
		::CloseHandle(m_hVmm32);
	m_bOpened = false;
}

bool DiskSectorWin9x::ReadLogicalSectors(HANDLE hDev,
	BYTE   bDrive,
	DWORD  dwStartSector,
	WORD   wSectors,
	LPBYTE lpSectBuff)
{
	BOOL fResult;
	DWORD cb;
	DIOC_REGISTERS reg = { 0 };
	DISKIO dio = { 0 };

	dio.dwStartSector = dwStartSector;
	dio.wSectors = wSectors;
	dio.dwBuffer = (DWORD)lpSectBuff;

	reg.reg_EAX = bDrive - 1;			// Int 25h drive numbers are 0-based.
	reg.reg_EBX = (DWORD)&dio;   // Drive letter 0 = A, 1 = B  2 = C ect..
	reg.reg_ECX = 0xFFFF;				// use DISKIO struct

	fResult = ::DeviceIoControl(hDev, VWIN32_DIOC_DOS_INT25,
		&reg, sizeof(reg),
		&reg, sizeof(reg), &cb, 0);

	fResult = fResult && !(reg.reg_Flags & CARRY_FLAG);

	return fResult == TRUE;
}

bool DiskSectorWin9x::WriteLogicalSectors(HANDLE hDev,
	BYTE   bDrive,
	DWORD  dwStartSector,
	WORD   wSectors,
	LPBYTE lpSectBuff)
{
	BOOL fResult;
	DWORD cb;
	DIOC_REGISTERS reg = { 0 };
	DISKIO dio = { 0 };

	dio.dwStartSector = dwStartSector;
	dio.wSectors = wSectors;
	dio.dwBuffer = (DWORD)lpSectBuff;

	reg.reg_EAX = bDrive - 1;    // Int 26h drive numbers are 0-based.
	reg.reg_EBX = (DWORD)&dio;
	reg.reg_ECX = 0xFFFF;        // use DISKIO struct

	fResult = ::DeviceIoControl(hDev, VWIN32_DIOC_DOS_INT26,
		&reg, sizeof(reg),
		&reg, sizeof(reg), &cb, 0);

	fResult = fResult && !(reg.reg_Flags & CARRY_FLAG);

	return fResult == TRUE;
}

bool DiskSectorWin9x::NewReadSectors(HANDLE hDev,
	BYTE   bDrive,
	DWORD  dwStartSector,
	WORD   wSectors,
	LPBYTE lpSectBuff)
{
	BOOL fResult;
	DWORD cb;
	DIOC_REGISTERS reg = { 0 };
	DISKIO dio;

	dio.dwStartSector = dwStartSector;
	dio.wSectors = wSectors;
	dio.dwBuffer = (DWORD)lpSectBuff;

	reg.reg_EAX = 0x7305;		// Ext_ABSDiskReadWrite
	reg.reg_EBX = (DWORD)&dio;
	reg.reg_ECX = -1;
	reg.reg_EDX = bDrive;		// Int 21h, fn 7305h drive numbers are 1-based

	fResult = ::DeviceIoControl(hDev, VWIN32_DIOC_DOS_DRIVEINFO,
		&reg, sizeof(reg),
		&reg, sizeof(reg), &cb, 0);

	fResult = fResult && !(reg.reg_Flags & CARRY_FLAG);

	return fResult == TRUE;
}

bool DiskSectorWin9x::NewWriteSectors(HANDLE hDev,
	BYTE   bDrive,
	DWORD  dwStartSector,
	WORD   wSectors,
	LPBYTE lpSectBuff)
{
	BOOL fResult;
	DWORD cb;
	DIOC_REGISTERS reg = { 0 };
	DISKIO dio;

	dio.dwStartSector = dwStartSector;
	dio.wSectors = wSectors;
	dio.dwBuffer = (DWORD)lpSectBuff;

	reg.reg_EAX = 0x7305;   // Ext_ABSDiskReadWrite
	reg.reg_EBX = (DWORD)&dio;
	reg.reg_ECX = -1;
	reg.reg_EDX = bDrive;   // Int 21h, fn 7305h drive numbers are 1-based
	reg.reg_ESI = 0x6001;   // Normal file data/write (See function documentation for other values)

	fResult = ::DeviceIoControl(hDev, VWIN32_DIOC_DOS_DRIVEINFO,
		&reg, sizeof(reg),
		&reg, sizeof(reg), &cb, 0);

	fResult = fResult && !(reg.reg_Flags & CARRY_FLAG);

	return fResult == TRUE;
}

bool DiskSectorWin9x::LockLogicalVolume(HANDLE hVWin32,
	BYTE   bDriveNum,
	BYTE   bLockLevel,
	WORD   wPermissions)
{
	BOOL fResult;
	DIOC_REGISTERS regs = { 0 };
	BYTE bDeviceCat;  // can be either 0x48 or 0x08
	DWORD cb;

	bDeviceCat = 0x48;

ATTEMPT_AGAIN:

	// Set up the parameters for the call.
	regs.reg_EAX = 0x440D;
	regs.reg_EBX = MAKEWORD(bDriveNum, bLockLevel);
	regs.reg_ECX = MAKEWORD(0x4A, bDeviceCat);
	regs.reg_EDX = wPermissions;

	fResult = ::DeviceIoControl(hVWin32, VWIN32_DIOC_DOS_IOCTL,
		&regs, sizeof(regs), &regs, sizeof(regs),
		&cb, 0);

	// See if DeviceIoControl and the lock succeeded
	fResult = fResult && !(regs.reg_Flags & CARRY_FLAG);

	// If DeviceIoControl or the lock failed, and device category 0x08
	// hasn't been tried, retry the operation with device category 0x08.
	if (!fResult && (bDeviceCat != 0x08))
	{
		bDeviceCat = 0x08;
		goto ATTEMPT_AGAIN;
	}

	return fResult == TRUE;
}

bool DiskSectorWin9x::UnlockLogicalVolume(HANDLE hVWin32, BYTE bDriveNum)
{
	BOOL           fResult;
	DIOC_REGISTERS regs = { 0 };
	BYTE           bDeviceCat;  // can be either 0x48 or 0x08
	DWORD          cb;

	bDeviceCat = 0x48;

ATTEMPT_AGAIN:

	// Set up the parameters for the call.
	regs.reg_EAX = 0x440D;
	regs.reg_EBX = bDriveNum;
	regs.reg_ECX = MAKEWORD(0x6A, bDeviceCat);

	fResult = ::DeviceIoControl(hVWin32, VWIN32_DIOC_DOS_IOCTL,
		&regs, sizeof(regs), &regs, sizeof(regs),
		&cb, 0);

	// See if DeviceIoControl and the unlock succeeded
	fResult = fResult && !(regs.reg_Flags & CARRY_FLAG);

	// If DeviceIoControl or the unlock failed, and device category 0x08
	// hasn't been tried, retry the operation with device category 0x08.
	if (!fResult && (bDeviceCat != 0x08))
	{
		bDeviceCat = 0x08;
		goto ATTEMPT_AGAIN;
	}
	return fResult == TRUE;
}

bool DiskSectorWin9x::ReadSector(DWORD sector, char *Buffer, int sectorSize)
{
	if (!m_bOpened)
		return false;

	if (m_bUseLocking)
	{
		if (!LockLogicalVolume(m_hVmm32, m_nDriveNo, 1, 1))
			return false;

		if (!LockLogicalVolume(m_hVmm32, m_nDriveNo, 2, 0))
		{
			UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
			return false;
		}
	}

	bool bRet;
	if (m_bW9xOsr2AndAbove)
		bRet = NewReadSectors(m_hVmm32, m_nDriveNo, sector, 1, (LPBYTE)Buffer);
	else
		bRet = ReadLogicalSectors(m_hVmm32, m_nDriveNo, sector, 1, (LPBYTE)Buffer);

	if (m_bUseLocking)
	{
		UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
		UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
	}
	return bRet;
}

bool DiskSectorWin9x::WriteSector(DWORD sector, char *Buffer, int sectorSize)
{
	if (!m_bOpened)
		return false;

	if (!LockLogicalVolume(m_hVmm32, m_nDriveNo, 1, 1))
		return false;

	if (!LockLogicalVolume(m_hVmm32, m_nDriveNo, 2, 0))
	{
		UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
		return false;
	}

	if (!LockLogicalVolume(m_hVmm32, m_nDriveNo, 3, 0))
	{
		UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
		UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
		return false;
	}

	bool bRet;

	if (m_bW9xOsr2AndAbove)
		bRet = NewWriteSectors(m_hVmm32, m_nDriveNo, sector, 1, (LPBYTE)Buffer);
	else
		bRet = WriteLogicalSectors(m_hVmm32, m_nDriveNo, sector, 1, (LPBYTE)Buffer);

	UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
	UnlockLogicalVolume(m_hVmm32, m_nDriveNo);
	UnlockLogicalVolume(m_hVmm32, m_nDriveNo);

	return bRet;
}
```

`serial.h`:

```h
#pragma once
#pragma warning(disable: 4996 4311 4302)

#include <Windows.h>

class DiskSectorRW
{
public:
	virtual bool Open(char *vol) = 0;
	virtual void Close() = 0;
	virtual bool ReadSector(DWORD sector, char *Buffer, int sectorSize = 512) = 0;
	virtual bool WriteSector(DWORD sector, char *buffer, int sectorSize = 512) = 0;
};

class DiskSectorWinNT : public DiskSectorRW
{
private:
	HANDLE m_hDisk;
public:
	bool Open(char *vol);
	void Close();
	bool ReadSector(DWORD sector, char *Buffer, int sectorSize = 512);
	bool WriteSector(DWORD sector, char *Buffer, int sectorSize = 512);
};

class DiskSectorWin9x : public DiskSectorRW
{
private:
	HANDLE m_hVmm32;
	bool m_bOpened;
	char m_chDrive;
	BYTE m_nDriveNo;
	bool m_bW9xOsr2AndAbove;
	bool m_bUseLocking;
public:

	DiskSectorWin9x() : m_bUseLocking(false) { }
	bool Open(char *vol);
	void Close();

	bool ReadSector(DWORD sector, char *Buffer, int sectorSize = 512);
	bool WriteSector(DWORD sector, char *Buffer, int sectorSize = 512);

	static bool LockLogicalVolume(HANDLE hVWin32, BYTE   bDriveNum, BYTE   bLockLevel, WORD wPermissions);
	static bool UnlockLogicalVolume(HANDLE hVWin32, BYTE bDriveNum);

	static bool ReadLogicalSectors(HANDLE hDev, BYTE   bDrive, DWORD  dwStartSector, WORD wSectors, LPBYTE lpSectBuff);
	static bool WriteLogicalSectors(HANDLE hDev, BYTE   bDrive, DWORD  dwStartSector, WORD   wSectors, LPBYTE lpSectBuff);

	static bool NewReadSectors(HANDLE hDev, BYTE   bDrive, DWORD  dwStartSector, WORD   wSectors, LPBYTE lpSectBuff);
	static bool NewWriteSectors(HANDLE hDev, BYTE   bDrive, DWORD  dwStartSector, WORD   wSectors, LPBYTE lpSectBuff);
};

class DiskSector
{
private:
	DiskSectorRW *util;
public:
	DiskSector();
	~DiskSector();
	bool Open(char *vol);
	void Close();
	bool ReadSector(DWORD sector, char *Buffer, int sectorSize = 512);
	bool WriteSector(DWORD sector, char *buffer, int sectorSize = 512);
};

```