Project Path: arc_gmh5225_dumpwow_eixybqi0

Source Tree:

```txt
arc_gmh5225_dumpwow_eixybqi0
├── CMakeLists.txt
├── LICENSE
├── README.md
├── dll
│   ├── CMakeLists.txt
│   ├── concolic.cpp
│   ├── concolic.hpp
│   ├── dumper.cpp
│   ├── imports.cpp
│   ├── imports.hpp
│   ├── log.cpp
│   ├── log.hpp
│   ├── main.cpp
│   ├── misc.cpp
│   ├── misc.hpp
│   ├── relocations.cpp
│   └── relocations.hpp
├── idc
│   └── find_lua.py
└── src
    ├── CMakeLists.txt
    ├── main.cpp
    └── raii_proc.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.12)

foreach(policy
    CMP0074 # CMake 3.12
    )
  if(POLICY ${policy})
    cmake_policy(SET ${policy} NEW)
  endif()
endforeach()

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

set(PROJECT_NAME dumpwow)

project(${PROJECT_NAME})

# build in Release-mode by default if not explicitly set
if( NOT CMAKE_BUILD_TYPE )
  set(CMAKE_BUILD_TYPE "RelWithDebInfo")
endif()

if ("x_${CMAKE_BUILD_TYPE}" STREQUAL "x_Debug")
    set(HADESMEM_BUILD "Debug")
else()
    set(HADESMEM_BUILD "Release")
endif()

if (CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(HADESMEM_ARCH "x64")
else()
    set(HADESMEM_ARCH "Win32")
endif()

if ("x_${HADESMEM_ROOT}" STREQUAL "x_")
    if (EXISTS "${CMAKE_SOURCE_DIR}/hadesmem-v${MSVC_TOOLSET_VERSION}-${HADESMEM_BUILD}-${HADESMEM_ARCH}")
        set(HADESMEM_ROOT "${CMAKE_SOURCE_DIR}/hadesmem-v${MSVC_TOOLSET_VERSION}-${HADESMEM_BUILD}-${HADESMEM_ARCH}")
        set(HADESMEM_LIB_DIR "${HADESMEM_ROOT}/lib")
    else()
        message(FATAL_ERROR "HADESMEM_ROOT not set.  ${PROJECT_NAME} requires hadesmem, available at https://github.com/namreeb/hadesmem")
    endif()
else()
    set(HADESMEM_LIB_DIR "${HADESMEM_ROOT}/build/vs/${HADESMEM_BUILD}/${HADESMEM_ARCH}")
endif()

if (NOT EXISTS "${HADESMEM_ROOT}/include/memory/hadesmem")
    message(FATAL_ERROR "hadesmem not found at ${HADESMEM_ROOT}")
else()
    message(STATUS "hadesmem found at ${HADESMEM_ROOT}")
endif()

message(STATUS "hadesmem library directory: ${HADESMEM_LIB_DIR}")

# threading library is required
find_package(Threads REQUIRED)

set(Boost_USE_STATIC_LIBS ON)
set(Boost_USE_MULTITHREADED ON)
set(Boost_USE_STATIC_RUNTIME OFF)

find_package(Boost)

if (BOOST_FOUND)
    message(STATUS "boost found at ${BOOST_ROOT}")
else()
    message(FATAL_ERROR "boost not found")
endif()

add_definitions(-DUNICODE -D_UNICODE -D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DASMJIT_STATIC -DASMJIT_BUILD_X86 -DHADESMEM_NO_PUGIXML)
include_directories(
    "Include"
    "${CMAKE_CURRENT_SOURCE_DIR}"
    "${Boost_INCLUDE_DIR}"
    "${HADESMEM_ROOT}/include/memory/"
    "${HADESMEM_ROOT}/deps/udis86/udis86"
    "${HADESMEM_ROOT}/deps/asmjit/asmjit/src"
)

link_directories("${HADESMEM_LIB_DIR}")

add_subdirectory(dll)
add_subdirectory(src)

install(FILES
    "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE"
    "${CMAKE_CURRENT_SOURCE_DIR}/README.md"
    DESTINATION "${CMAKE_INSTALL_PREFIX}")
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# dumpwow

Tool to dump unpacked and deobfuscated World of Warcraft binaries.

Depends on the [hadesmem](https://github.com/namreeb/hadesmem/) library.

```

`dll/CMakeLists.txt`:

```txt
set(DLL_NAME unpacker)

include_directories(Include ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_SOURCE_DIR})

set(SOURCE_FILES
    concolic.cpp
    dumper.cpp
    imports.cpp
    relocations.cpp
    log.cpp
    main.cpp
    misc.cpp
)

add_library(${DLL_NAME} SHARED ${SOURCE_FILES})
target_link_libraries(${DLL_NAME} shlwapi.lib asmjit.lib udis86.lib)

install(TARGETS ${DLL_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}")

```

`dll/concolic.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "concolic.hpp"

#include <Windows.h>

#include <cstdint>

//#define DEBUG_CONCOLIC

#ifdef DEBUG_CONCOLIC
#include "log.hpp"
#include <sstream>
#endif

namespace
{
template <typename T>
T read(PVOID &address)
{
    auto const ret_ptr = reinterpret_cast<T *>(address);

    address = reinterpret_cast<PVOID>(
        reinterpret_cast<std::uintptr_t>(address) + sizeof(T));

    return *ret_ptr;
}
}

bool conclic_begin(PVOID start, ConclicThreadContext &context)
{
    memset(&context, 0, sizeof(context));

    auto current = start;
#ifdef DEBUG_CONCOLIC
    auto instruction_ea = current;
#endif

    // 48:B8 5F8A36EDFA7F0000 -> mov rax,7FFAED368A5F
    if (read<std::uint8_t>(current) != 0x48 ||
        read<std::uint8_t>(current) != 0xB8)
    {
#ifdef DEBUG_CONCOLIC
        gLog << "ea: 0x" << instruction_ea << " initial mov not found"
            << std::endl;
#endif
        return false;
    }

    context.rax = read<std::uint64_t>(current);
#ifdef DEBUG_CONCOLIC
    gLog << "ea: 0x" << instruction_ea << " initial mov rax, 0x" << std::hex
        << context.rax << std::endl;
#endif

    do
    {
#ifdef DEBUG_CONCOLIC
        instruction_ea = current;
#endif
        auto const op1 = read<std::uint8_t>(current);

        switch (op1)
        {
            // FFE0 -> jmp rax
            case 0xFF:
            {
                auto const result = read<std::uint8_t>(current) == 0xE0;
#ifdef DEBUG_CONCOLIC
                gLog << "returning " << (result ? "true" : "false")
                    << ". rax: 0x" << std::hex << context.rax << std::dec
                    << "\n" << std::endl;
#endif
                return result;
            }
            // E9 98F4FFFF -> jmp -2920
            // E9 C3040000 -> jmp +1219
            case 0xE9:
            {
                auto const offset = read<std::int32_t>(current);
                current = reinterpret_cast<PVOID>(
                    reinterpret_cast<std::uintptr_t>(current) + offset);
#ifdef DEBUG_CONCOLIC
                gLog << "ea: 0x" << instruction_ea << " jump to 0x" << current
                    << std::endl;
#endif
                break;
            }
            case 0x48:
            {
                auto const op2 = read<std::uint8_t>(current);
                switch (op2)
                {
                    // 48:05 54AA1D29 -> add rax,291DAA54
                    case 0x05:
                    {
                        auto const operand = read<std::int32_t>(current);
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea << " add "
                            << std::hex << operand << " from " << context.rax
                            << " to " << context.rax + operand << std::dec
                            << std::endl;
#endif
                        context.rax += operand;
                        break;
                    }
                    // 48:2D F78E5718 -> sub rax,18578EF7
                    case 0x2D:
                    {
                        auto const operand = read<std::int32_t>(current);
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea << " sub "
                            << std::hex << operand << " from " << context.rax
                            << " to " << context.rax - operand << std::dec
                            << std::endl;
#endif
                        context.rax -= operand;
                        break;
                    }
                    // 48:35 04BE0778 -> xor rax,7807BE04
                    case 0x35:
                    {
                        auto const operand = static_cast<std::int64_t>(
                            read<std::int32_t>(current));
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea << " xor "
                            << std::hex << operand << " from " << context.rax
                            << " to " << (context.rax ^ operand) << std::dec
                            << std::endl;
#endif
                        context.rax ^= operand;
                        break;
                    }

                    default:
                    {
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea
                            << " 0x48 op2 unrecognized: " << std::hex << op1
                            << std::dec << std::endl;
#endif
                        return false;
                    }
                }

                break;
            }
            case 0x49:
            {
                auto const op2 = read<std::uint8_t>(current);
                switch (op2)
                {
                    // 49 0f af c2 -> imul rax, r10
                    case 0x0F:
                    {
                        auto const op3 = read<std::uint8_t>(current);

                        if (op3 != 0xAF)
                        {
#ifdef DEBUG_CONCOLIC
                            gLog << "ea: 0x" << instruction_ea
                                << " imul op3 unrecognized: " << std::hex
                                << static_cast<int>(op3) << std::dec
                                << std::endl;
#endif
                            return false;
                        }

                        auto const op4 = read<std::uint8_t>(current);

                        if (op4 == 0xC2)
                        {
                            auto const signed_rax = static_cast<std::int64_t>(
                                context.rax);
                            auto const signed_r10 = static_cast<std::int64_t>(
                                context.r10);

#ifdef DEBUG_CONCOLIC
                            gLog << "ea: 0x" << instruction_ea
                                << " imul rax, r10 (0x" << std::hex
                                << context.rax << " * 0x" << context.r10
                                << " = 0x" << (signed_rax*signed_r10) << "), ("
                                << std::dec << signed_rax << " * "
                                << signed_r10 << " = "
                                << (signed_rax*signed_r10) << ")" << std::endl;
#endif

                            context.rax = signed_rax * signed_r10;
                        }
                        else
                        {
#ifdef DEBUG_CONCOLIC
                            gLog << "ea: 0x" << instruction_ea
                                << " imul op4 unrecognized: " << std::hex
                                << static_cast<int>(op4) << std::dec
                                << std::endl;
#endif
                            return false;
                        }

                        break;
                    }
                    // 49 ba bb 40 7d ba f7 07 31 3c -> mov r10, 3C3107F7BA7D40BB
                    case 0xBA:
                    {
                        auto const operand = read<std::uint64_t>(current);
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea << " r10 set to 0x"
                            << std::hex << operand << std::dec << std::endl;
#endif

                        context.r10 = operand;
                        break;
                    }
                    default:
                    {
#ifdef DEBUG_CONCOLIC
                        gLog << "ea: 0x" << instruction_ea
                            << " 0x49 op2 unrecognized: " << std::hex << op1
                            << std::dec << std::endl;
#endif
                        return false;
                    }
                }
                break;
            }

            default:
            {
#ifdef DEBUG_CONCOLIC
                gLog << "ea: 0x" << instruction_ea << " op1 unrecognized: "
                    << std::hex << op1 << std::dec << std::endl;
#endif
                return false;
            }
        }
    } while (true);

    return true;
}
```

`dll/concolic.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#include <Windows.h>

#include <cstdint>

struct ConclicThreadContext
{
    std::uint64_t rax;
    std::uint64_t r10;
};

bool conclic_begin(PVOID start, ConclicThreadContext &context);
```

`dll/dumper.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

// define to disable TLS callbacks in memory and display a message box.  this
// will result in an incorrect (read: probably broken?) exe dump, but will also
// allow for attaching a debugger.
//#define DEBUG_DISABLE_TLS

#include "misc.hpp"
#include "log.hpp"
#include "imports.hpp"
#include "relocations.hpp"

#include <hadesmem/region.hpp>
#include <hadesmem/region_list.hpp>
#include <hadesmem/module.hpp>
#include <hadesmem/pelib/pe_file.hpp>
#include <hadesmem/pelib/nt_headers.hpp>
#include <hadesmem/pelib/section.hpp>
#include <hadesmem/pelib/section_list.hpp>
#include <hadesmem/pelib/tls_dir.hpp>

#include <Windows.h>

#include <stdexcept>
#include <experimental/filesystem>
#include <fstream>
#include <vector>
#include <cstring>
#include <cassert>

namespace fs = std::experimental::filesystem;

fs::path get_output_path(const fs::path& input_path);
PVOID find_remapped_base(const hadesmem::Process& process, PVOID base);
void repair_binary(const fs::path &path,const hadesmem::Process &process,
    PVOID base, std::vector<std::uint8_t> &pe,
    std::vector<std::uint8_t> &import_data);

void do_dump(PVOID base, DWORD pe_size)
{
    auto const exe_path = get_exe_path();
    auto const output_path = get_output_path(exe_path);

    const hadesmem::Process process(::GetCurrentProcessId());

    // this will let us work with the writable part of memory
    base = find_remapped_base(process, base);

    // memory_pe will hold the PE header data before any changes were made
    std::vector<std::uint8_t> memory_pe(pe_size);
    std::vector<std::uint8_t> import_data;
    repair_binary(exe_path, process, base, memory_pe, import_data);
    fix_relocation(base);

    std::ofstream out(output_path, std::ios::binary);

    if (!out)
        throw std::runtime_error("Failed to open unpacked exe for writing");

    // first, write PE header
    const hadesmem::PeFile pe_file(process, base, hadesmem::PeFileType::kImage,
        pe_size);
    const hadesmem::NtHeaders nt_header(process, pe_file);

    out.write(reinterpret_cast<const char*>(base),
        static_cast<std::streamsize>(nt_header.GetSizeOfHeaders()));

    // second, write sections
    const hadesmem::SectionList section_list(process, pe_file);
    for (auto const& section : section_list)
    {
        // TODO: better logic to identify our section here
        if (section.GetName() == ".wowim")
            continue;

        auto const section_base = reinterpret_cast<const char *>(base) +
            section.GetVirtualAddress();
        out.write(section_base, section.GetSizeOfRawData());
    }

    // third, write the new section created for imports
    if (!import_data.empty())
        out.write(reinterpret_cast<const char *>(&import_data[0]),
            import_data.size());

    out.close();
}

fs::path get_output_path(const fs::path& input_path)
{
    auto const dir = input_path.parent_path();
    auto const extension = input_path.extension();
    auto const stem = input_path.stem();

    return dir / (stem.string() + "_unpacked" + extension.string());
}

PVOID find_remapped_base(const hadesmem::Process& process, PVOID base)
{
    const hadesmem::RegionList region_list(process);

    const hadesmem::PeFile pe_file(process, base, hadesmem::PeFileType::kImage,
        0);

    // find the PE header in the remapped location
    for (auto const& region : region_list)
    {
        if (region.GetState() == MEM_FREE)
            continue;

        if (region.GetAllocBase() != region.GetBase())
            continue;

        if (region.GetSize() != pe_file.GetSize())
            continue;

        if (memcmp(base, region.GetBase(), region.GetSize()))
            continue;

#ifdef _DEBUG
        gLog << "Remapped base:\t\t0x" << std::hex << region.GetBase()
            << " protection: 0x" << region.GetProtect()
            << " size: 0x" << region.GetSize() << std::endl;
#endif

        return region.GetBase();
    }

    throw std::runtime_error(
        "find_remapped_base failed to find remapped location");
}

void repair_binary(const fs::path &path, const hadesmem::Process &process,
    PVOID base, std::vector<std::uint8_t> &pe,
    std::vector<std::uint8_t> &import_data)
{
    // copy the current PE header into the vector to save in case we need it
    memcpy(&pe[0], base, pe.size());

    const hadesmem::PeFile clobbered_pe(process, &pe[0],
        hadesmem::PeFileType::kData, static_cast<DWORD>(pe.size()));

    // read PE header from EXE file
    auto const pe_exe = read_pe_header_from_exe(path,
        static_cast<DWORD>(pe.size()));

    // install EXE PE header into memory
    memcpy(base, &pe_exe[0], pe_exe.size());

    // use the PE header read from the file
    const hadesmem::PeFile pe_file(process, base,
        hadesmem::PeFileType::kImage, static_cast<DWORD>(pe.size()));

    hadesmem::NtHeaders nt_header(process, pe_file);
    hadesmem::SectionList section_list(process, pe_file);
    auto raw_data_pointer = nt_header.GetSizeOfHeaders();

    // used later in import resolution
    PVOID rdata = nullptr;

    for (auto &section : section_list)
    {
        auto const virtual_size = round_up(section.GetVirtualSize(),
            nt_header.GetSectionAlignment());

        auto const section_base = reinterpret_cast<PVOID>(
            reinterpret_cast<std::uint8_t*>(base) +
            section.GetVirtualAddress());

        if (section.GetName() == ".rdata")
            rdata = section_base;

        // for some reason the wow binary has section with unusual sizes.  that's
        // fine, but lets clean it up by enforcing section alignment from the pe
        section.SetVirtualSize(virtual_size);

        // the unpacking may have enlarged the section.  increase the raw size
        // to match the virtual size, and then remove as much zero-fill from
        // the end as we can.
        for (auto remain = virtual_size; remain != 0; --remain)
        {
            auto const curr = reinterpret_cast<const std::uint8_t*>(
                section_base) + remain - 1;

            // we cannot shrink beyond this point
            if (*curr != 0x00)
            {
                auto const old_size = section.GetSizeOfRawData();
                section.SetSizeOfRawData(round_up(remain,
                    nt_header.GetFileAlignment()));
                break;
            }
        }

        // with sections changing size, we should also update the raw location
        section.SetPointerToRawData(raw_data_pointer);
        raw_data_pointer += section.GetSizeOfRawData();

        section.UpdateWrite();
    }

    auto const image_base = reinterpret_cast<void*>(
        nt_header.GetImageBase());

    // tls callbacks will point to the original (now unwritable) region of
    // memory.  the addresses should be rebased to be consistent with the base
    // address in the PE header.
    hadesmem::TlsDir tls_dir(process, pe_file);

    auto mem_tls_dir_in = reinterpret_cast<void**>(tls_dir.GetAddressOfCallBacks());
    auto mem_tls_dir_out = rebase(base, mem_tls_dir_in);

    while (*mem_tls_dir_in)
    {
#ifdef DEBUG_DISABLE_TLS
        *mem_tls_dir_out = nullptr;
#else
        *mem_tls_dir_out = rebase(image_base, *mem_tls_dir_in);
#endif
        ++mem_tls_dir_in;
        ++mem_tls_dir_out;
    }

    const hadesmem::Region old_tls_region(process, reinterpret_cast<PVOID>(
        tls_dir.GetAddressOfCallBacks()));

    auto const tls_callback_rva = static_cast<std::uint64_t>(
        reinterpret_cast<char*>(tls_dir.GetAddressOfCallBacks()) -
        reinterpret_cast<char*>(old_tls_region.GetAllocBase()));

    auto const output_tls_dir = nt_header.GetImageBase() + tls_callback_rva;

    auto const new_tls_address = reinterpret_cast<PVOID>(
        reinterpret_cast<char*>(base) + tls_callback_rva);

    auto const new_start_address = rebase(image_base,
        tls_dir.GetStartAddressOfRawData());
    auto const new_end_address = rebase(image_base,
        tls_dir.GetEndAddressOfRawData());
    auto const new_index_address = rebase(image_base,
        tls_dir.GetAddressOfIndex());
    auto const new_cb_address = rebase(image_base,
        tls_dir.GetAddressOfCallBacks());

    tls_dir.SetStartAddressOfRawData(new_start_address);
    tls_dir.SetEndAddressOfRawData(new_end_address);
    tls_dir.SetAddressOfIndex(new_index_address);
    tls_dir.SetAddressOfCallBacks(new_cb_address);

    tls_dir.UpdateWrite();

    std::uint8_t buff[5];

    auto const entry_point = reinterpret_cast<const char*>(base) +
        nt_header.GetAddressOfEntryPoint();

    memcpy(buff, entry_point, sizeof(buff));

    if (buff[0] == 0xE9)
    {
        auto const new_ep_offset = *reinterpret_cast<const std::int32_t*>(
            entry_point + 1);

        auto const new_ep = reinterpret_cast<const void*>(entry_point +
            new_ep_offset + 5);

        gLog << "True entry point:\t0x" << std::hex << new_ep << std::endl;
    }

    // the second TLS callback will generate simple pointer decryption
    // trampolines to mask calls to imported DLL functions.  to resolve
    // these calls we will perform a concolic execution of the trampolines
    // and see what function pointer results.
    if (rdata)
        rebuild_imports(process, pe_file, rdata, import_data);
    else
        gLog << "Did not find .rdata section.  Skipping import resolution."
        << std::endl;

#ifdef DEBUG_DISABLE_TLS
    auto const call_site = reinterpret_cast<void *>(
        reinterpret_cast<char *>(base) + 0x81F5E5);

    gMbLog << "Call site: 0x" << std::hex << call_site
        << "\nBase: 0x" << base << std::endl;
#endif
}

```

`dll/imports.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "imports.hpp"
#include "log.hpp"
#include "concolic.hpp"
#include "misc.hpp"

#include <hadesmem/process.hpp>
#include <hadesmem/region.hpp>
#include <hadesmem/module_list.hpp>
#include <hadesmem/pelib/section.hpp>
#include <hadesmem/pelib/section_list.hpp>
#include <hadesmem/pelib/export_list.hpp>
#include <hadesmem/pelib/import_dir.hpp>
#include <hadesmem/pelib/import_dir_list.hpp>
#include <hadesmem/pelib/import_thunk.hpp>
#include <hadesmem/pelib/import_thunk_list.hpp>

#include <Windows.h>

#include <vector>
#include <unordered_map>

namespace
{
class ImportTable
{
    private:
        const hadesmem::Process _process;
        const hadesmem::PeFile _pe_file;
        const DWORD _new_section_va;
        const DWORD _iat_va;

        std::vector<std::uint8_t> _buffer;

        bool _finalized;

        struct ImportDirEntry
        {
            IMAGE_IMPORT_DESCRIPTOR header;
            std::string name;

            std::vector<IMAGE_THUNK_DATA64> thunks;

            ImportDirEntry(const IMAGE_IMPORT_DESCRIPTOR &_header,
                const std::string &_name) : header(_header), name(_name) {}
        };

        std::vector<ImportDirEntry> _import_dirs;

        // write a string to memory and return RVA
        // return the RVA for it
        std::uint64_t write(const std::string &str)
        {
            auto const ret = _buffer.size();
            _buffer.resize(_buffer.size() + str.length() + 1);
            ::memcpy(&_buffer[ret], str.c_str(), str.length()+1);
            return _new_section_va + ret;
        }

        std::uint64_t write(const std::wstring &str)
        {
            return write(wstring_to_string(str));
        }

        template <typename T>
        std::uint64_t write()
        {
            auto const ret = _buffer.size();
            _buffer.resize(_buffer.size() + sizeof(T));
            ::memset(&buffer[ret], 0, sizeof(T));
            return _new_section_va + ret;
        }

        template <typename T>
        std::uint64_t write(const T &value)
        {
            auto const ret = _buffer.size();
            _buffer.resize(_buffer.size() + sizeof(T));
            ::memcpy(&_buffer[ret], &value, sizeof(T));
            return _new_section_va + ret;
        }

        template <typename T>
        std::uint64_t write(const std::vector<T> &vect)
        {
            if (vect.empty())
                return _buffer.size();

            auto const bytes = sizeof(T) * vect.size();

            auto const ret = _buffer.size();
            _buffer.resize(_buffer.size() + bytes);
            ::memcpy(&_buffer[ret], &vect[0], bytes);
            return _new_section_va + ret;
        }

        ImportDirEntry &get_import_dir(PVOID function)
        {
            const hadesmem::Region region(_process, function);
            const hadesmem::Module module(_process,
                reinterpret_cast<HMODULE>(region.GetAllocBase()));
            auto const mod_name = wstring_to_string(module.GetName());

            // if this function belongs to the same library as the last one,
            // return the last import directory
            if (!_import_dirs.empty() && _import_dirs.back().name == mod_name)
                return _import_dirs.back();

            // if the import directory for this library exists anywhere else,
            // it means we have made a mistake somewhere along the way.
            for (auto& import_dir : _import_dirs)
                if (mod_name == import_dir.name)
                {
                    gLog << "Import directory for 0x" << std::hex
                        << reinterpret_cast<std::uintptr_t>(function)
                        << " module \"" << mod_name
                        << "\" has already been finalized" << std::endl;
                    gLog << " alloc base: " << region.GetAllocBase() << std::endl;
                    throw std::runtime_error(
                        "Import directory ordering failure");
                }

            // create a new empty import directory for this module
            IMAGE_IMPORT_DESCRIPTOR imp_dir;
            ::memset(&imp_dir, 0, sizeof(imp_dir));

            imp_dir.Name = static_cast<DWORD>(write(module.GetName()));

            _import_dirs.emplace_back(imp_dir, mod_name);

            return _import_dirs.back();
        }

    public:
        ImportTable(const hadesmem::PeFile &pe_file, DWORD new_section_va,
            DWORD iat_va) : 
            _process(::GetCurrentProcessId()), _pe_file(pe_file),
            _new_section_va(new_section_va), _iat_va(iat_va), _finalized(false)
        {
        }

        // TODO: shorten this function and reduce code duplication
        void add_function(PVOID thunk, PVOID function, bool force_new_dir)
        {
            if (_finalized)
                throw std::runtime_error(
                    "Cannot add function to import table once finalized");

            const hadesmem::Region region(_process, function);
            const hadesmem::PeFile mod_pe(_process, region.GetAllocBase(),
                hadesmem::PeFileType::kImage, 0);
            const hadesmem::Module module(_process,
                reinterpret_cast<HMODULE>(region.GetAllocBase()));
            const hadesmem::ExportList export_list(_process, mod_pe);

            auto const mod_name = wstring_to_string(module.GetName());

            auto const thunk_rva = static_cast<DWORD>(
                reinterpret_cast<std::uintptr_t>(thunk) -
                reinterpret_cast<std::uintptr_t>(_pe_file.GetBase()));

            IMAGE_THUNK_DATA64 thunk_data;
            ::memset(&thunk_data, 0, sizeof(thunk_data));

            // if we are currently building the thunks for a different module,
            // it could be because that module has a forward to this function
            if (!force_new_dir && !_import_dirs.empty() &&
                _import_dirs.back().name != mod_name)
            {
                // in this case, check the module we've been building to see if
                // there is a forwarder to this function
                auto const current_module = _import_dirs.back().name;
                auto const current_module_handle = ::GetModuleHandleA(
                    current_module.c_str());

                if (!current_module_handle)
                    throw std::runtime_error("GetModuleHandle() failed");

                const hadesmem::PeFile current_module_pe(_process,
                    current_module_handle, hadesmem::PeFileType::kImage, 0);
                const hadesmem::ExportList current_module_export_list(_process,
                    current_module_pe);

                for (auto const& exp : current_module_export_list)
                {
                    if (!exp.IsForwarded())
                        continue;

                    if (exp.IsForwardedByOrdinal())
                    {
                        auto const target = ::GetProcAddress(module.GetHandle(),
                            reinterpret_cast<LPCSTR>(exp.GetForwarderOrdinal()));

                        if (target != function)
                            continue;

                        thunk_data.u1.AddressOfData = static_cast<ULONGLONG>(
                            write(static_cast<WORD>(0xFACE)));
                        write(exp.GetName());
                        if ((thunk_data.u1.AddressOfData +
                            exp.GetName().length() + 1) % 2 != 0)
                            write<std::uint8_t>(0);

                        gLog << "Thunk RVA: +0x" << std::hex << thunk_rva
                            << " -> " << current_module << "!" << exp.GetName()
                            << " <ordinal 0x" << std::hex
                            << exp.GetForwarderOrdinal()
                            << "> (ordinal forward)" << std::endl;

                        _import_dirs.back().thunks.push_back(thunk_data);
                        ::memcpy(thunk, &thunk_data, sizeof(thunk_data));

                        return;
                    }
                    else
                    {
                        auto const target = ::GetProcAddress(
                            module.GetHandle(),
                            exp.GetForwarderFunction().c_str());

                        if (target != function)
                            continue;

                        // TODO: Make actual hint
                        thunk_data.u1.AddressOfData = static_cast<ULONGLONG>(
                            write(static_cast<WORD>(0xFEED)));
                        write(exp.GetName());
                        if ((thunk_data.u1.AddressOfData +
                            exp.GetName().length() + 1) % 2 != 0)
                            write<std::uint8_t>(0);

                        gLog << "Thunk RVA: +0x" << std::hex << thunk_rva
                            << " -> " << current_module << "!" << exp.GetName()
                            << " (name forward)" << std::endl;

                        _import_dirs.back().thunks.push_back(thunk_data);
                        ::memcpy(thunk, &thunk_data, sizeof(thunk_data));

                        return;
                    }
                }
            }

            // if we reach here the possibility of a forward has been handled

            auto& import_dir = get_import_dir(function);

            for (auto const& e : export_list)
                if (e.GetVa() == function)
                {
                    // if this import directory was just created, set the
                    // first thunk based on this function
                    if (import_dir.header.FirstThunk == 0)
                        import_dir.header.FirstThunk = thunk_rva;

                    // hint is WORD value of index into the export name
                    // pointer table
                    thunk_data.u1.AddressOfData = static_cast<ULONGLONG>(
                        write(static_cast<WORD>(0xFACE)));
                    write(e.GetName());

                    // the above data must align to an even boundary.  if not,
                    // add a single zero byte for padding
                    if ((thunk_data.u1.AddressOfData + e.GetName().length() + 1)
                        % 2 != 0)
                        write<std::uint8_t>(0);

                    gLog << "Thunk RVA: +0x" << std::hex << thunk_rva << " -> "
                        << module.GetName() << "!" << e.GetName() << std::endl;

                    import_dir.thunks.push_back(thunk_data);
                    ::memcpy(thunk, &thunk_data, sizeof(thunk_data));

                    return;
                }

            throw std::runtime_error("Failed to create thunk");
        }

        void finalize(hadesmem::Section &new_section,
            std::vector<std::uint8_t> &buffer)
        {
            if (_finalized)
                throw std::runtime_error("Cannot finalize import table twice");

            IMAGE_THUNK_DATA64 empty_thunk_data;
            ::memset(&empty_thunk_data, 0, sizeof(empty_thunk_data));

            // first, write thunks and update headers for each import directory
            for (auto &import_dir : _import_dirs)
            {
                // RVA of import lookup table (ILT)
                import_dir.header.OriginalFirstThunk = _new_section_va +
                    static_cast<DWORD>(_buffer.size());

                write(import_dir.thunks);

                // terminate the list of thunks
                write(empty_thunk_data);
            }

            // second, write the import directory entries
            auto const import_dir_rva = static_cast<DWORD>(_buffer.size());
            for (auto &import_dir : _import_dirs)
                auto const dir_rva = static_cast<DWORD>(
                    write(import_dir.header));

            // third, update section data
            hadesmem::NtHeaders nt_header(_process, _pe_file);

            // enforce file alignment of new section
            _buffer.resize(round_up(static_cast<DWORD>(_buffer.size()),
                nt_header.GetFileAlignment()));
            new_section.SetSizeOfRawData(static_cast<DWORD>(_buffer.size()));
            new_section.SetVirtualSize(round_up(
                static_cast<DWORD>(_buffer.size()),
                nt_header.GetSectionAlignment()));
            new_section.UpdateWrite();

            // fourth, update PE header
            nt_header.SetDataDirectoryVirtualAddress(
                hadesmem::PeDataDir::Import, _new_section_va + import_dir_rva);
            nt_header.SetDataDirectorySize(hadesmem::PeDataDir::Import,
                static_cast<DWORD>(_import_dirs.size() * 
                    sizeof(IMAGE_IMPORT_DESCRIPTOR)));

            nt_header.SetDataDirectoryVirtualAddress(hadesmem::PeDataDir::IAT,
                _iat_va);
            nt_header.SetDataDirectorySize(hadesmem::PeDataDir::IAT,
                import_dir_rva);

            nt_header.UpdateWrite();

            buffer = std::move(_buffer);

            _finalized = true;
        }
};

hadesmem::Section add_section(const hadesmem::Process &process,
    const hadesmem::PeFile &pe_file)
{
    hadesmem::NtHeaders nt_header(process, pe_file);
    const hadesmem::Section last_section(process, pe_file,
        nt_header.GetNumberOfSections() - 1);

    auto const section_header_va = reinterpret_cast<std::uint8_t *>(
        last_section.GetBase()) + sizeof(IMAGE_SECTION_HEADER);
    auto const section_header_end_va = section_header_va +
        sizeof(IMAGE_SECTION_HEADER);

    if (section_header_end_va > (reinterpret_cast<std::uint8_t *>(
        pe_file.GetBase()) + nt_header.GetSizeOfHeaders()))
        throw std::runtime_error("No space remaining for new header");

    IMAGE_SECTION_HEADER new_section;
    ::memset(&new_section, 0, sizeof(new_section));
    ::memcpy(new_section.Name, ".wowim", sizeof(".wowim"));
    new_section.VirtualAddress = last_section.GetVirtualAddress() +
        last_section.GetVirtualSize();
    new_section.PointerToRawData = last_section.GetPointerToRawData() +
        last_section.GetSizeOfRawData();
    new_section.Characteristics = IMAGE_SCN_MEM_READ |
        IMAGE_SCN_CNT_INITIALIZED_DATA;
    ::memcpy(section_header_va, &new_section, sizeof(new_section));
    nt_header.SetNumberOfSections(nt_header.GetNumberOfSections() + 1);
    nt_header.UpdateWrite();

    return hadesmem::Section(process, pe_file, section_header_va);
}
}

void rebuild_imports(const hadesmem::Process &process,
    const hadesmem::PeFile &pe_file, PVOID rdata,
    std::vector<std::uint8_t> &buffer)
{
    // step one, create a new section for the import data.  while some generic
    // tools will attempt to expand the .rdata section, experimentally this is
    // not possible for wow.
    auto new_section = add_section(process, pe_file);

    const hadesmem::Region import_region(process, rdata);

    auto const base = import_region.GetAllocBase();

    auto const rdata_va = static_cast<DWORD>(
        reinterpret_cast<std::uintptr_t>(rdata) -
        reinterpret_cast<std::uintptr_t>(base));

    // assemble results within this structure
    ImportTable import_table(pe_file, new_section.GetVirtualAddress(),
        rdata_va);

    auto const import_region_end = reinterpret_cast<PVOID>(
        reinterpret_cast<std::uintptr_t>(import_region.GetBase()) +
        import_region.GetSize());

    // when true, the next function will force creation of a new import
    // directory
    auto force_new_import_dir = true;

    // step two, iterate over .rdata section and decrypt encrypted trampolines
    for (auto current_import =
        reinterpret_cast<PVOID *>(rdata);
        current_import < import_region_end;
        ++current_import)
    {
        auto const thunk_ea = *current_import;

        auto const import_rva = static_cast<DWORD>(
            reinterpret_cast<std::uintptr_t>(current_import) -
            reinterpret_cast<std::uintptr_t>(pe_file.GetBase()));
        auto const thunk_rva = static_cast<DWORD>(
            reinterpret_cast<std::uintptr_t>(thunk_ea) -
            reinterpret_cast<std::uintptr_t>(pe_file.GetBase()));

#ifdef _DEBUG
        gLog << "Import RVA: +0x" << std::hex << import_rva << " Thunk EA: 0x"
            << reinterpret_cast<std::uintptr_t>(thunk_ea) << " Thunk RVA: +0x"
            << thunk_rva << std::endl;
#endif

        if (!thunk_ea)
        {
            force_new_import_dir = true;
            continue;
        }

        // if the thunk ea is not sane, skip it.  this heuristic is not
        // necessary but greatly speeds up the process.  without it, each
        // of these addresses would be examined and result in an exception
        // when hadesmem calls VirtualQueryEx() and it fails.
        if (reinterpret_cast<std::uint64_t>(thunk_ea) >> 0x30)
        {
            gLog << "Bad thunk ea RVA: 0x" << std::hex << import_rva << " thunk_ea: 0x"
                << std::hex << reinterpret_cast<std::uintptr_t>(thunk_ea)
                << std::endl;

            continue;
        }

        try
        {
            const hadesmem::Region thunk_region(process, thunk_ea);

            if (thunk_region.GetType() == MEM_FREE)
                continue;

            if (thunk_region.GetProtect() == PAGE_EXECUTE)
            {
                auto const rva = static_cast<DWORD>(
                    reinterpret_cast<std::uintptr_t>(current_import) -
                    reinterpret_cast<std::uintptr_t>(pe_file.GetBase()));

                gLog << "[Import Resolution]: Skipping import from +0x"
                    << std::hex << rva << " because it points to unreadble "
                    "PAGE_EXECUTE memory.  If you see this, please file a bug."
                    << std::endl;

                continue;
            }

            if (thunk_region.GetProtect() != PAGE_EXECUTE_READ &&
                thunk_region.GetProtect() != PAGE_EXECUTE_READWRITE &&
                thunk_region.GetProtect() != PAGE_EXECUTE_WRITECOPY)
                continue;

            ConclicThreadContext ctx;

            if (!conclic_begin(thunk_ea, ctx))
            {
#ifdef _DEBUG
                gLog << "concolic failed RVA: 0x" << std::hex << import_rva << " thunk_ea: 0x"
                    << std::hex << reinterpret_cast<std::uintptr_t>(thunk_ea)
                    << std::endl;
#endif
                continue;
            }

            // the ImportTable class will build import directory entries as
            // needed for eventual serialization
            import_table.add_function(current_import,
                reinterpret_cast<PVOID>(ctx.rax), force_new_import_dir);

            force_new_import_dir = false;
        }
        catch (const std::exception &e)
        {
#ifdef _DEBUG
            gLog << "Exception: " << boost::diagnostic_information(e) << std::endl;
#endif
            break;
        }
    }

    // serialize the import table into memory in preparation for dumping to
    // the disk
    import_table.finalize(new_section, buffer);
}
```

`dll/imports.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#include <hadesmem/process.hpp>
#include <hadesmem/pelib/pe_file.hpp>

#include <Windows.h>

#include <vector>
#include <cstdint>

void rebuild_imports(const hadesmem::Process &process,
    const hadesmem::PeFile &pe_file, PVOID rdata,
    std::vector<std::uint8_t> &buffer);
```

`dll/log.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "log.hpp"
#include "misc.hpp"

#include <string>
#include <fstream>
#include <stdexcept>
#include <functional>

int LogStreamBuffer::sync()
{
    if (!str().empty())
    {
        _callback(str());
        str("");
    }

    return std::stringbuf::sync();
}
Log::Log(std::function<void(const std::string &)> callback)
    : _buffer(callback), std::ostream(&_buffer) {}

std::ostream & operator << (std::ostream &_Ostr, const std::wstring &_Str)
{
    return _Ostr << wstring_to_string(_Str);
}

Log gLog([] (const std::string &buff)
{
    auto const exe_path = get_exe_path();
    auto const parent = exe_path.parent_path();
    auto const log_path = parent / "log.txt";

    std::ofstream out(log_path, std::ios::app);

    if (!out)
        throw std::runtime_error("Failed to open log file");

    out << buff;
    out.close();
});

Log gMbLog([] (const std::string &buf)
{
    ::MessageBoxA(nullptr, buf.c_str(), "DEBUG", 0);
});


```

`dll/log.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#include <ostream>
#include <sstream>
#include <functional>

class LogStreamBuffer : public std::stringbuf
{
    private:
        std::function<void(const std::string &)> _callback;

    public:
        LogStreamBuffer(std::function<void(const std::string &)> callback)
            : _callback(callback) {}
        int sync();
};

class Log : public std::ostream
{
    private:
        LogStreamBuffer _buffer;

    public:
        Log(std::function<void(const std::string &)> callback);
};

std::ostream & operator << (std::ostream &_Ostr, const std::wstring &_Str);

// log to file
extern Log gLog;

// show a message box
extern Log gMbLog;

```

`dll/main.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "misc.hpp"
#include "log.hpp"

#include <hadesmem/patcher.hpp>
#include <hadesmem/pelib/pe_file.hpp>
#include <hadesmem/pelib/nt_headers.hpp>

#include <Windows.h>

#include <sstream>
#include <iomanip>
#include <string>

// hook LdrpCallTlsInitializers to replace the reason 
void HookCallTLSCallbacks(const hadesmem::Process &process, size_t rva,
    DWORD main_thread_id);

// hook BaseThreadInitThunk which will call the entry point
void HookBaseThreadInitThunk(const hadesmem::Process &process,
    DWORD main_thread_id, PVOID wow_base, DWORD wow_size);

// hook NtSetInformationThread to prevent ThreadHideFromDebugger
void HookSetInformationThread(const hadesmem::Process &process);

extern void do_dump(PVOID, DWORD);

extern "C" __declspec(dllexport) void Initialize(
    size_t call_tls_initializers_rva, DWORD main_thread_id, PVOID wow_base,
    DWORD wow_size)
{
    try
    {
        const hadesmem::Process process(::GetCurrentProcessId());

        HookCallTLSCallbacks(process, call_tls_initializers_rva,
            main_thread_id);
        HookBaseThreadInitThunk(process, main_thread_id, wow_base, wow_size);
        HookSetInformationThread(process);
    }
    catch (const std::exception &e)
    {
        std::wstringstream str;
        str << "Unpacker initialization failed: " << e.what();
        ::MessageBox(nullptr, str.str().c_str(), L"Unpacker", 0);
    }
}

void HookCallTLSCallbacks(const hadesmem::Process &process, size_t rva,
    DWORD main_thread_id)
{
    auto const ntdll = ::GetModuleHandle(L"ntdll");

    using LdrpCallTlsInitializersT = bool(*)(int, PVOID);

    auto const orig_call_tls_initializers = reinterpret_cast<
        LdrpCallTlsInitializersT>(reinterpret_cast<unsigned char *>(ntdll)
            + rva);

    // this is a memory leak but the process will not be long running so we
    // dont care
    auto const call_tls_detour = new hadesmem::PatchDetour<
        LdrpCallTlsInitializersT>(process, orig_call_tls_initializers,
            [main_thread_id](hadesmem::PatchDetourBase *detour,
                int reason, PVOID header)
    {
        // replace DLL_THREAD_ATTACH with DLL_PROCESS_ATTACH for the
        // main thread while this hook is active during startup.
        if (::GetCurrentThreadId() == main_thread_id &&
            reason == DLL_THREAD_ATTACH)
            reason = DLL_PROCESS_ATTACH;
        return detour->GetTrampolineT<LdrpCallTlsInitializersT>()
            (reason, header);
    });

    call_tls_detour->Apply();
}

using BaseThreadInitThunkT = std::uint64_t(*)(std::uint64_t,
    PVOID, std::uint64_t);

std::uint64_t BaseThreadInitThunkHook(hadesmem::PatchDetourBase *detour,
    PVOID base, DWORD pe_size, DWORD main_thread_id, std::uint64_t a1,
    PVOID func, std::uint64_t a3)
{
    if (::GetCurrentThreadId() != main_thread_id)
        return detour->GetTrampolineT<BaseThreadInitThunkT>()(a1, func,
            a3);

    try
    {
        const hadesmem::Process process(::GetCurrentProcessId());

        // PE header in memory is clobbered by TLS callbacks
        auto pe_buff = read_pe_header_from_exe(get_exe_path(), pe_size);

        const hadesmem::PeFile pe_file(process, &pe_buff[0],
            hadesmem::PeFileType::kData, static_cast<DWORD>(pe_buff.size()));

        const hadesmem::NtHeaders nt_header(process, pe_file);

        auto const entry_point = reinterpret_cast<PVOID>(
            reinterpret_cast<char *>(base) +
            nt_header.GetAddressOfEntryPoint());

        if (func != entry_point)
            return detour->GetTrampolineT<BaseThreadInitThunkT>()(a1, func,
                a3);

        if (*reinterpret_cast<std::uint8_t *>(entry_point) != 0xE9)
            throw std::runtime_error(
                "Entry point should start with a JMP (0xE9)");

        try
        {
            detour->Remove();
            do_dump(base, pe_size);
        }
        catch (const std::exception &e)
        {
            ::MessageBoxA(nullptr, boost::diagnostic_information(e).c_str(),
                "Unpacker Error", MB_ICONERROR);
        }
    }
    catch (const std::exception &e)
    {
        ::MessageBoxA(nullptr, boost::diagnostic_information(e).c_str(),
            "BaseThreadInitThunk Error", MB_ICONERROR);
    }

    ::TerminateProcess(::GetCurrentProcess(), 0);

    detour->Remove();
    return detour->GetTrampolineT<BaseThreadInitThunkT>()(a1, func,
        a3);
}

void HookBaseThreadInitThunk(const hadesmem::Process &process,
    DWORD main_thread_id, PVOID wow_base, DWORD wow_size)
{
    auto const k32 = ::GetModuleHandle(L"kernel32");
    if (!k32)
        throw std::runtime_error("Could not find kernel32");

    auto const orig = reinterpret_cast<BaseThreadInitThunkT>(
        ::GetProcAddress(k32, "BaseThreadInitThunk"));

    if (!orig)
        throw std::runtime_error("Could not find kernel32!BaseThreadInitThunk");

    auto pe_buff = read_pe_header_from_exe(get_exe_path(), wow_size);

    const hadesmem::PeFile pe_file(process, &pe_buff[0],
        hadesmem::PeFileType::kData, static_cast<DWORD>(pe_buff.size()));
    const hadesmem::NtHeaders nt_headers(process, pe_file);

    auto const entry_point = reinterpret_cast<const void *>(
        reinterpret_cast<std::uint8_t *>(wow_base) +
        nt_headers.GetAddressOfEntryPoint());

    // this is a memory leak but the process will not be long running so we
    // dont care
    auto const init_detour = new hadesmem::PatchDetour<
        BaseThreadInitThunkT>(process, orig,
            [entry_point, main_thread_id, wow_base, wow_size](
                hadesmem::PatchDetourBase *detour, std::uint64_t a1,
                PVOID func, std::uint64_t a3)
        {
            return BaseThreadInitThunkHook(detour, wow_base, wow_size,
                main_thread_id, a1, func, a3);
        });

    init_detour->Apply();
}

void HookSetInformationThread(const hadesmem::Process &process)
{
    auto const ntdll = ::GetModuleHandle(L"ntdll");
    if (!ntdll)
        throw std::runtime_error("Could not find ntdll");

    using SetInformationThreadT = NTSTATUS(*)(HANDLE, THREADINFOCLASS, PVOID,
        ULONG);

    auto const orig = reinterpret_cast<SetInformationThreadT>(
        ::GetProcAddress(ntdll, "NtSetInformationThread"));

    if (!orig)
        throw std::runtime_error(
            "Could not find ntdll!NtSetInformationThread");

    auto const set_information_thread_detour = new hadesmem::PatchDetour<
        SetInformationThreadT>(process, orig,
            [](hadesmem::PatchDetourBase *detour, HANDLE thread_handle,
                THREADINFOCLASS info_class, PVOID thread_info,
                ULONG info_length)
        {
            static constexpr THREADINFOCLASS ThreadHideFromDebugger =
                static_cast<THREADINFOCLASS>(0x11);

            if (info_class == ThreadHideFromDebugger && !thread_info &&
                !info_length)
                return static_cast<NTSTATUS>(0);

            return detour->GetTrampolineT<SetInformationThreadT>()(
                thread_handle, info_class, thread_info, info_length);
        });

    set_information_thread_detour->Apply();
}
```

`dll/misc.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "misc.hpp"

#include <hadesmem/pelib/pe_file.hpp>

#include <vector>
#include <cstdint>
#include <fstream>

fs::path get_exe_path()
{
    TCHAR filename[1024];
    if (!::GetModuleFileName(nullptr, filename, 
                             sizeof(filename) / sizeof(TCHAR)))
    {
        throw std::runtime_error("GetModuleFileName() failed");
    }

    return fs::path(filename);
}

std::vector<std::uint8_t> read_pe_header_from_exe(const fs::path &exe, DWORD size)
{
    std::vector<std::uint8_t> result(size);

    std::ifstream in(exe, std::ios::binary);

    if (!in)
        throw std::runtime_error("Failed to read PE header from binary");

    in.read(reinterpret_cast<char *>(&result[0]),
        static_cast<std::streamsize>(result.size()));
    in.close();

    return std::move(result);
}

// modified from https://stackoverflow.com/a/9194117
DWORD round_up(DWORD numToRound, DWORD multiple)
{
    assert(multiple > 0);
    return ((numToRound + multiple - 1) / multiple) * multiple;
}

// taken from https://stackoverflow.com/a/18374698
std::string wstring_to_string(const std::wstring& str)
{
    using convert_typeX = std::codecvt_utf8<wchar_t>;
    std::wstring_convert<convert_typeX, wchar_t> converterX;

    return converterX.to_bytes(str);
}
```

`dll/misc.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING

#include <Windows.h>

#include <experimental/filesystem>
#include <vector>
#include <cstdint>

#include <hadesmem/region.hpp>

namespace fs = std::experimental::filesystem;

fs::path get_exe_path();
std::vector<std::uint8_t> read_pe_header_from_exe(const fs::path &exe, DWORD pe_size);
DWORD round_up(DWORD numToRound, DWORD multiple);

std::string wstring_to_string(const std::wstring& str);

template <typename T>
T rebase(void* new_base, T address)
{
    const hadesmem::Process process(::GetCurrentProcessId());
    const hadesmem::Region region(process, reinterpret_cast<const void*>(
        address));

    auto const rva = static_cast<std::uint64_t>(
        reinterpret_cast<const char*>(address) -
        reinterpret_cast<const char*>(region.GetAllocBase()));

    return reinterpret_cast<T>(reinterpret_cast<char*>(new_base) + rva);
}

```

`dll/relocations.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#include "relocations.hpp"
#include "misc.hpp"

void fix_relocation(PVOID image_base)
{
    const auto module = PIMAGE_DOS_HEADER(image_base);
    auto headers = PIMAGE_NT_HEADERS64(reinterpret_cast<char*>(module) +
        module->e_lfanew);
    auto relocation = PIMAGE_BASE_RELOCATION(reinterpret_cast<char*>(module) +
        headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]
        .VirtualAddress);

    while (relocation->SizeOfBlock && relocation->VirtualAddress)
    {
        const auto block_relocation_count =
            (relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) /
            sizeof(WORD);
        const auto block_entries = PWORD(reinterpret_cast<char*>(relocation) +
            sizeof(IMAGE_BASE_RELOCATION));

        for (size_t i = 0; i < block_relocation_count; i++)
        {
            switch (block_entries[i] >> 12)
            {
            case IMAGE_REL_BASED_DIR64:
            {
                const auto p = reinterpret_cast<uintptr_t*>(
                    reinterpret_cast<char*>(module) +
                    relocation->VirtualAddress + (block_entries[i] & 0xFFF));
                *p = rebase(reinterpret_cast<PVOID>(headers->OptionalHeader.ImageBase), *p);
            }
            break;
            case IMAGE_REL_BASED_ABSOLUTE:
            case IMAGE_REL_BASED_HIGHLOW:
            case IMAGE_REL_BASED_HIGH:
            case IMAGE_REL_BASED_LOW:
            default:
            {
                // No need to fix absolute relocation it's just a dummy for alignment.
                // Other relocation types are not used in 64bit binaries.
            }
            break;
            }
        }

        relocation = PIMAGE_BASE_RELOCATION(reinterpret_cast<char*>(relocation) +
            relocation->SizeOfBlock);
    }
}

```

`dll/relocations.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#include <Windows.h>

void fix_relocation(PVOID base);

```

`idc/find_lua.py`:

```py
#!/usr/bin/python

import idc
import idaapi
import idautils
import ida_bytes
import ida_funcs
import traceback

# Get the name of the segment containing the given EA
def get_segment_name(ea):
    for seg_ea in idautils.Segments():
        if ea < seg_ea:
            continue
        seg_end = idc.get_segm_end(seg_ea)
        if ea > seg_end:
            continue
        return idc.get_segm_name(seg_ea)

def find_func_containing(ea):
    for segment_ea in idautils.Segments():
        if segment_ea > ea:
            continue
        segment_end = idc.get_segm_end(segment_ea)
        if segment_end < ea:
            continue
            
        for func_ea in idautils.Functions(segment_ea, segment_end):
            if func_ea > ea:
                continue
            func_end = idc.find_func_end(func_ea)
            if func_end <= ea:
                continue
            return func_ea
    return None

def find_game_init():
    strings = idautils.Strings()
    
    taint_ea = None
    
    # Find the string which is referenced only in CGameUI::Initialize
    for i in strings:
        if taint_ea is None and str(i) == 'Whether taint logging is enabled':
            taint_ea = i.ea
            break
            
    if taint_ea is None:
        raise RuntimeError('Unable to find CGGameUI::Initialize (1)')
        
    refs = list(idautils.DataRefsTo(taint_ea))
    
    if len(refs) != 1:
        raise RuntimeError('Unable to find CGGameUI::Initialize (2)')
    
    func_start = find_func_containing(refs[0])
    func_name = idc.get_func_name(func_start)
    
    mangled_name = '__ZN8CGGameUI10InitializeEv'
    
    if func_name != mangled_name:
        idc.set_name(func_start, mangled_name, SN_CHECK)

    print('CGGameUI::Initialize:  0x%x ' % func_start)
        
    return func_start

def find_framescript_register(game_init):
    game_init_end = idc.find_func_end(game_init)
    magic_string_found = False
    for head in idautils.Heads(game_init, game_init_end):
        disasm = idc.generate_disasm_line(head, 2)
        if not magic_string_found and '"FrameXML_Debug"' in disasm:
            magic_string_found = True
            continue
            
        if magic_string_found and disasm.startswith('call '):
            result = int(idc.get_operand_value(head, 0))
            func_name = idc.get_func_name(result)
            mangled_name = '__Z28FrameScript_RegisterFunctionPKcPFiP9lua_StateE'
            
            if func_name != mangled_name:
                idc.set_name(result, mangled_name, SN_CHECK)

            print('FrameScript::Register: 0x%08x' % result)
            return result
            
    raise RuntimeError('Unable to find FrameScript::Register (%d)' % \
        2 if magic_string_found else 1)

# Find all calls to FrameScript::Register
def find_register_calls(framescript_register):
    refs = list(idautils.CodeRefsTo(framescript_register, 1))
    print('Found %d calls to FrameScript::Register' % len(refs))
    return refs

# Examine the instructions in the given EA range for a Lua function array
def find_lua_function_array(start, end):
    for head in idautils.Heads(start, end):
        disasm = idc.generate_disasm_line(head, 2)
        if disasm.startswith('lea '):
            result = idc.get_operand_value(head, 1)
            return result
    raise RuntimeError('Unable to find Lua function array near 0x%08x' % start)

# Determine if the given EA is a valid entry in a Lua function array
def is_valid_lua_function_array_entry(ea):
    str_ea = ida_bytes.get_64bit(ea)
    func_name = ida_bytes.get_strlit_contents(str_ea, -1, 0)
    if func_name is None or len(func_name) == 0:
        return False
    func_ea = ida_bytes.get_64bit(ea+8)
    # If this points to somewhere other than the .text segment, it cant be valid
    if get_segment_name(func_ea) != '.text':
        return False

    f2 = find_func_containing(func_ea)
    # If no function is found, create one
    if f2 is None:
        ida_funcs.add_func(func_ea)
        print('Created function for Script_%s at 0x%08x' % (func_name, func_ea))
        f2 = func_ea
    elif f2 != func_ea:
        return False
    return find_func_containing(func_ea) == func_ea

# Determine if the given EA really points to a Lua function array
def is_valid_lua_function_array(ea):
    # First, verify that this EA is in the .data segment
    if get_segment_name(ea) != '.data':
        return False

    # Second, verify that the first two values point to a string and a function, respectively
    return is_valid_lua_function_array_entry(ea)

def main():
    print('\n\n')
    game_init = find_game_init()
    framescript_register = find_framescript_register(game_init)
    register_calls = find_register_calls(framescript_register)
    
    for c in register_calls:
        func_array = find_lua_function_array(c-0x20, c)
        if not is_valid_lua_function_array(func_array):
            print('WARNING: Invalid function array at 0x%08x (xref: 0x%08x)' % (func_array, c))
            continue            
            
        curr_ea = func_array
        while is_valid_lua_function_array_entry(curr_ea):
            str_ea = ida_bytes.get_64bit(curr_ea)
            func_ea = ida_bytes.get_64bit(curr_ea+8)
            func_name = ida_bytes.get_strlit_contents(str_ea, -1, 0)
            new_name = 'Script_' + func_name
            if idc.get_func_name(func_ea) != new_name:
                idc.set_name(func_ea, new_name)
            print('%s -> 0x%08x' % (new_name, func_ea))
            curr_ea += 16

if __name__ == '__main__':
    try:
        main()
    except:
        traceback.print_exc()
```

`src/CMakeLists.txt`:

```txt
set(EXECUTABLE_NAME dumpwow)

include_directories(Include ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_SOURCE_DIR})

set(SOURCE_FILES
    main.cpp
)

add_executable(${EXECUTABLE_NAME} ${SOURCE_FILES})
target_link_libraries(${EXECUTABLE_NAME} shlwapi.lib asmjit.lib udis86.lib)

install(TARGETS ${EXECUTABLE_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}")

```

`src/main.cpp`:

```cpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING

#include "raii_proc.hpp"

#include <hadesmem/injector.hpp>
#include <hadesmem/region_list.hpp>
#include <hadesmem/module.hpp>
#include <hadesmem/read.hpp>
#include <hadesmem/write.hpp>
#include <hadesmem/pelib/pe_file.hpp>
#include <hadesmem/pelib/tls_dir.hpp>
#include <hadesmem/find_pattern.hpp>

#include <Windows.h>
#include <intrin.h>

#include <iostream>
#include <vector>
#include <string>
#include <experimental/filesystem>
#include <thread>
#include <chrono>
#include <fstream>
#include <cstdio>
#include <atomic>

#pragma intrinsic(_ReturnAddress)

#define CALL_FIRST  1

namespace fs = std::experimental::filesystem;

fs::path get_temp_filename(const fs::path& path);
bool launch_wow_suspended(const fs::path &path,
    PROCESS_INFORMATION &proc_info);
hadesmem::PeFile find_wow_pe(const hadesmem::Process &process);
void *find_tls_callback_directory(const hadesmem::Process &process,
    const hadesmem::PeFile &pe);
BOOL ControlHandler(DWORD ctrl_type);
bool FindVEHCallerRVA();
size_t find_call_tls_initializers_rva();
void process_log_file(const fs::path &exe_path);

size_t g_veh_caller_rva;
std::atomic_bool g_exit_wow;

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        std::cerr << "Usage: " << argv[0] << " <wow.exe>" << std::endl;
        return EXIT_FAILURE;
    }

    auto const call_tls_initializers_rva = find_call_tls_initializers_rva();

    if (!call_tls_initializers_rva)
    {
        std::cerr << "Failed to find LdrpCallTlsInitializers" << std::endl;
        return EXIT_FAILURE;
    }

    const fs::path path(argv[1]);

    try
    {
        PROCESS_INFORMATION proc_info;
        if (!launch_wow_suspended(path, proc_info))
        {
            std::cerr << "launch_wow_suspended failed" << std::endl;
            return EXIT_FAILURE;
        }

        g_exit_wow = false;
      
        const hadesmem::Process process(proc_info.dwProcessId);

        // ensure process is killed upon exit
        const RaiiProc proc_killer(process.GetId());

        auto const pe_file = find_wow_pe(process);

        std::cout << "Wow base address:       0x" << std::hex
            << reinterpret_cast<std::uintptr_t>(pe_file.GetBase())
            << std::endl;

        // temporarily disable TLS callbacks to prevent them from executing
        // when we inject
        auto const tls_callback_directory = 
            find_tls_callback_directory(process, pe_file);

        if (!tls_callback_directory)
        {
            std::cerr << "Unable to find TLS callback directory" << std::endl;
            return EXIT_FAILURE;
        }

        std::cout << "TLS callback directory: 0x" << std::hex
            << reinterpret_cast<std::uintptr_t>(tls_callback_directory)
            << std::endl;

        auto const first_callback = hadesmem::Read<void *>(process,
            tls_callback_directory);

        std::cout << "First TLS callback:     0x" << std::hex
            << reinterpret_cast<std::uintptr_t>(first_callback)
            << std::endl;

        hadesmem::Write<void *>(process, tls_callback_directory, nullptr);

        auto const verify = hadesmem::Read<void *>(process,
            tls_callback_directory);

        if (verify)
        {
            std::cerr << "Failed to zero first TLS callback" << std::endl;
            return EXIT_FAILURE;
        }

        // with the TLS callbacks disabled, our DLL may be safely injected
        const hadesmem::Module unpacker(process, hadesmem::InjectDll(process,
            L"unpacker.dll", hadesmem::InjectFlags::kPathResolution));

        // call init function in DLL
        auto const func = reinterpret_cast<
            void(*)(size_t, DWORD, PVOID, DWORD)>(
            hadesmem::FindProcedure(process, unpacker, "Initialize"));

        hadesmem::Call(process, func, hadesmem::CallConv::kDefault,
            call_tls_initializers_rva, proc_info.dwThreadId,
            pe_file.GetBase(), pe_file.GetSize());

        // restore first TLS callback
        hadesmem::Write<void *>(process, tls_callback_directory,
            first_callback);

        if (!::SetConsoleCtrlHandler(ControlHandler, TRUE))
        {
            std::cerr << "SetConsoleCtrlHandler failed" << std::endl;
            return EXIT_FAILURE;
        }

        CONTEXT context;
        memset(&context, 0, sizeof(context));
        context.ContextFlags = CONTEXT_ALL;
        ::GetThreadContext(proc_info.hThread, &context);

        if (!::ResumeThread(proc_info.hThread))
        {
            std::cerr << "Failed to resume main thread" << std::endl;
            return EXIT_FAILURE;
        }

        DWORD exit_code = 0;

        do
        {
            if (g_exit_wow)
            {
                std::cout << "Received CTRL-C.  Terminating wow..."
                    << std::endl;
                ::TerminateProcess(process.GetHandle(), 0);
                g_exit_wow = false;
            }

            if (!::GetExitCodeProcess(proc_info.hProcess, &exit_code))
            {
                std::cerr << "GetExitCodeProcess failed" << std::endl;
                return EXIT_FAILURE;
            }

            // if there is a different exit code, the process has exited
            if (exit_code != STILL_ACTIVE)
                break;

            // if STILL_ACTIVE is the exit code, the process may have chosen to
            // exit using that error code, so try one more check
            if (::WaitForSingleObject(proc_info.hProcess, 0) != WAIT_TIMEOUT)
                break;

            // if the waiting timed out, it means the process is still running.
            // so let us sleep for a little while and then check again
            std::this_thread::sleep_for(std::chrono::milliseconds(300));
        } while (true);

        if (!::SetConsoleCtrlHandler(ControlHandler, FALSE))
        {
            std::cerr << "SetConsoleCtrlHandler failed" << std::endl;
            return EXIT_FAILURE;
        }

        std::cout << "Wow exited with code:   0x" << std::hex << exit_code
            << std::endl;

        process_log_file(path);
    }
    catch (const std::exception &e)
    {
        std::cerr << "Error:\n" << boost::diagnostic_information(e)
            << std::endl;
        process_log_file(path);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

LONG NTAPI VectoredExceptionHandler(struct _EXCEPTION_POINTERS *exceptionInfo)
{
    auto const return_address = reinterpret_cast<const std::uint8_t *>(
        ::_ReturnAddress());
    auto const base = reinterpret_cast<const std::uint8_t *>(
        ::GetModuleHandle(L"ntdll"));

    g_veh_caller_rva = return_address - base - 6;

    return EXCEPTION_CONTINUE_EXECUTION;
}

// find the RVA of RtlpCallVectoredHandlers within NTDLL so we know where to
// find it once we launch wow
bool FindVEHCallerRVA()
{
    // first, add our own VEH
    auto const veh_handle = ::AddVectoredExceptionHandler(CALL_FIRST,
        &VectoredExceptionHandler);

    // second, raise an exception
    ::RaiseException(1, 0, 0, nullptr);

    // third, remove the VEH
    if (!::RemoveVectoredExceptionHandler(veh_handle))
        return false;

    // at this point, g_veh_caller_rva will have a value.  now check if it is
    // valid
    auto const call_site = reinterpret_cast<std::uint8_t *>(
        GetModuleHandle(L"ntdll")) + g_veh_caller_rva;

    // first byte of indirect call instruction is right?
    return *call_site == 0xFF && *(call_site + 5) == 0;
}

bool launch_wow_suspended(const fs::path &path,
    PROCESS_INFORMATION &proc_info)
{
    // disable ASLR for subprocesses.  this will cause the base address used
    // in memory to match the base address that static analysis tools will use
    SIZE_T cb;
    if (!::InitializeProcThreadAttributeList(nullptr, 1, 0, &cb) &&
        ::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return false;

    auto attribs = reinterpret_cast<LPPROC_THREAD_ATTRIBUTE_LIST>(malloc(cb));

    if (!attribs)
        return false;

    if (!::InitializeProcThreadAttributeList(attribs, 1, 0, &cb))
    {
        free(attribs);
        return false;
    }

    DWORD64 attribute =
        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF;
    if (!::UpdateProcThreadAttribute(attribs, 0,
        PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &attribute, sizeof(DWORD64),
        nullptr, nullptr))
    {
        free(attribs);
        return false;
    }

    // launch wow in a suspended state
    STARTUPINFO start_info {};
    start_info.cb = static_cast<DWORD>(sizeof(start_info));
    memset(&proc_info, 0, sizeof(proc_info));

    wchar_t path_raw[MAX_PATH];
    memcpy(&path_raw[0], path.wstring().c_str(),
        (1 + path.wstring().length()) * sizeof(wchar_t));

    auto const result = !!::CreateProcessW(path_raw, nullptr, nullptr,
        nullptr, FALSE, CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT,
        nullptr, nullptr, &start_info, &proc_info);

    return result;
}

hadesmem::PeFile find_wow_pe(const hadesmem::Process &process)
{
    const hadesmem::RegionList region_list(process);

    // find the PE header for wow
    for (auto const &region : region_list)
    {
        if (region.GetState() == MEM_FREE)
            continue;

        if (region.GetType() != MEM_IMAGE)
            continue;

        if (region.GetProtect() != PAGE_READONLY)
            continue;

        if (region.GetAllocBase() != region.GetBase())
            continue;

        hadesmem::PeFile pe_file(process, region.GetBase(),
            hadesmem::PeFileType::kImage,
            static_cast<DWORD>(region.GetSize()));

        std::vector<ULONGLONG> callbacks;

        try
        {
            const hadesmem::TlsDir tls_dir(process, pe_file);
            tls_dir.GetCallbacks(std::back_inserter(callbacks));
        }
        catch (const hadesmem::Error &)
        {
            continue;
        }

        // wow has tls callbacks
        if (callbacks.empty())
            continue;

        return std::move(pe_file);
    }

    throw std::runtime_error("Could not find wow PE");
}

void *find_tls_callback_directory(const hadesmem::Process &process,
    const hadesmem::PeFile &pe)
{
    try
    {
        const hadesmem::TlsDir tls_dir(process, pe);
        return reinterpret_cast<void *>(tls_dir.GetAddressOfCallBacks());
    }
    catch (const hadesmem::Error &)
    {
        return nullptr;
    }
}

size_t find_call_tls_initializers_rva()
{
    auto const ntdll = ::GetModuleHandle(L"ntdll");

    if (!ntdll)
        return 0;

    const hadesmem::Process process(::GetCurrentProcessId());

    // find "LdrpCallTlsInitializers"
    auto const magic_value = hadesmem::Find(process, L"ntdll.dll",
        L"4C 64 72 70 43 61 6C 6C 54 6C 73 49 "
         "6E 69 74 69 61 6C 69 7A 65 72 73 00",
        hadesmem::PatternFlags::kScanData,
        0);

    if (!magic_value)
        return 0;

    const std::uint8_t *magic_value_ref = nullptr;

    // find recurrences of the byte pattern which dereferences the magic value
    // and check for one that actually is dereferencing it
    for (auto p = hadesmem::Find(process, L"ntdll.dll",
        L"4c 8d 05 ?? ?? ?? 00", 0, 0); p;)
    {
        auto const p_offset = reinterpret_cast<std::uint8_t *>(p) -
            reinterpret_cast<std::uint8_t *>(ntdll);

        auto const expected_offset = static_cast<std::uint32_t>(
            reinterpret_cast<std::uintptr_t>(magic_value) -
            reinterpret_cast<std::uintptr_t>(p)) - 7;

        auto const offset = hadesmem::Read<std::uint32_t>(process,
            reinterpret_cast<unsigned char *>(p) + 3);

        if (offset == expected_offset)
        {
            magic_value_ref = reinterpret_cast<const std::uint8_t *>(p);
            break;
        }

        p = hadesmem::Find(process, L"ntdll.dll", L"4c 8d 05 ?? ?? ?? 00", 0,
            p_offset);
    }

    // not found?  give up
    if (!magic_value_ref)
        return 0;

    const std::uint8_t *func = nullptr;

    // begin searching backwards for a few INT3 (0xCC) instructions to guess at
    // the start of the function
    for (int offset = 0; offset < 0x200; ++offset)
    {
        auto const p = reinterpret_cast<const std::uint8_t *>(magic_value_ref)
            - offset;

        if (*p != 0xCC &&
            *(p - 1) == 0xCC &&
            *(p - 2) == 0xCC &&
            *(p - 3) == 0xCC &&
            *(p - 4) == 0xCC)
        {
            func = p;
            break;
        }
    }

    // function start not found?  give up
    if (!func)
        return 0;

    return static_cast<std::uint64_t>(func -
        reinterpret_cast<const std::uint8_t *>(ntdll));
}

void process_log_file(const fs::path &exe_path)
{
    auto const parent = exe_path.parent_path();
    auto const log_path = parent / "log.txt";

    std::ifstream in(log_path, std::ios::ate);

    if (!in)
    {
        std::cerr << "Failed to read " << log_path << std::endl;
        return;
    }

    auto const file_size = static_cast<size_t>(in.tellg());
    in.seekg(std::ios::beg);

    std::vector<char> file_data(file_size + 1);
    in.read(&file_data[0], file_data.size());
    file_data[file_data.size() - 1] = '\0';
    in.close();


    std::cout << "\nLog:\n\n" << &file_data[0];

    std::remove(log_path.string().c_str());
}

BOOL ControlHandler(DWORD ctrl_type)
{
    if (ctrl_type == CTRL_C_EVENT)
    {
        g_exit_wow = true;
        return TRUE;
    }

    std::cout << "Received unrecognized event: " << std::dec << ctrl_type
        << std::endl;

    return FALSE;
}

```

`src/raii_proc.hpp`:

```hpp
/*
    MIT License

    Copyright (c) 2020 namreeb (legal@namreeb.org) http://github.com/namreeb/dumpwow

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

#pragma once

#include <Windows.h>

// RAII class to ensure process is killed
class RaiiProc
{
private:
    const DWORD _pid;
    const UINT _exit_code;
public:
    RaiiProc(DWORD pid, UINT exit_code=0) : _pid(pid), _exit_code(exit_code) {}
    ~RaiiProc()
    {
        auto const proc = ::OpenProcess(PROCESS_TERMINATE, FALSE, _pid);

        if (!proc)
            return;

        ::TerminateProcess(proc, _exit_code);
    }
};
```