Project Path: arc_gmh5225_QQTangCheatEngine_vq992qyh

Source Tree:

```txt
arc_gmh5225_QQTangCheatEngine_vq992qyh
├── QQTang CheatEngine
│   ├── Boss.hpp
│   ├── CCall.hpp
│   ├── EncodeMember.hpp
│   ├── GameBomb.hpp
│   ├── GameBox.hpp
│   ├── GameFloor.hpp
│   ├── GameInfo.hpp
│   ├── GameItem.hpp
│   ├── GameManager.hpp
│   ├── GameUI.hPP
│   ├── MapElem.hpp
│   ├── Maple.hpp
│   ├── MessageLayer.hpp
│   ├── NPC.hpp
│   ├── NPCItem.hpp
│   ├── Player.hpp
│   ├── PythonCode
│   │   ├── levelCFG.py
│   │   ├── uiConst.py
│   │   ├── uiFunc.py
│   │   ├── uiGame.py
│   │   ├── uiLogin.py
│   │   ├── uiLogo.py
│   │   ├── uiMain.py
│   │   ├── uiRoom.py
│   │   ├── uiSelRoom.py
│   │   ├── uiSelSect.py
│   │   ├── uiShop.py
│   │   ├── uiTemplate.py
│   │   └── uiWeb.py
│   ├── QQTEncoder.hpp
│   ├── QQTSection.hpp
│   ├── QQTang CheatEngine.vcxproj
│   ├── QQTang CheatEngine.vcxproj.filters
│   ├── QQTangCheatEngine.hpp
│   ├── QQTangClient.hpp
│   ├── QQTangEnum.hpp
│   ├── QQTangPackage.hpp
│   └── RoomInfo.hpp
├── QQTang CheatEngine.sln
├── README.md
├── SkinSharpByStaticLib
│   ├── Detours.lib
│   ├── SkinH.h
│   ├── SkinH_ST.lib
│   └── skinh.she
└── zlib1
    ├── WinMain.cpp
    ├── WinMain.h
    ├── resource.h
    ├── zlib1.rc
    ├── zlib1.vcxproj
    ├── zlib1.vcxproj.filters
    └── zlib1Code
        ├── adler32.cpp
        ├── compress.cpp
        ├── crc32.cpp
        ├── crc32.h
        ├── deflate.cpp
        ├── deflate.h
        ├── gzclose.cpp
        ├── gzguts.h
        ├── gzlib.cpp
        ├── gzread.cpp
        ├── gzwrite.cpp
        ├── infback.cpp
        ├── inffast.cpp
        ├── inffast.h
        ├── inffixed.h
        ├── inflate.cpp
        ├── inflate.h
        ├── inftrees.cpp
        ├── inftrees.h
        ├── trees.cpp
        ├── trees.h
        ├── uncompr.cpp
        ├── zconf.h
        ├── zlib.def
        ├── zlib.h
        ├── zutil.cpp
        └── zutil.h

```

`QQTang CheatEngine.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27428.2005
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "QQTang CheatEngine", "QQTang CheatEngine\QQTang CheatEngine.vcxproj", "{2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib1", "zlib1\zlib1.vcxproj", "{9DA95A37-01AB-4A9E-A5C0-5BAB1EEE24BF}"
	ProjectSection(ProjectDependencies) = postProject
		{2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D} = {2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "SkinSDK", "SkinSDK", "{860260FD-05E9-45DD-BBDF-D08AE3DE7F22}"
	ProjectSection(SolutionItems) = preProject
		SkinSharpByStaticLib\Detours.lib = SkinSharpByStaticLib\Detours.lib
		SkinSharpByStaticLib\SkinH.h = SkinSharpByStaticLib\SkinH.h
		SkinSharpByStaticLib\skinh.she = SkinSharpByStaticLib\skinh.she
		SkinSharpByStaticLib\SkinH_ST.lib = SkinSharpByStaticLib\SkinH_ST.lib
	EndProjectSection
EndProject
Global
	
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|QQTangCheatEngine = Release|QQTangCheatEngine
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D}.Release|QQTangCheatEngine.ActiveCfg = Release|Win32
		{2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D}.Release|QQTangCheatEngine.Deploy.0 = Release|Win32
		{9DA95A37-01AB-4A9E-A5C0-5BAB1EEE24BF}.Release|QQTangCheatEngine.ActiveCfg = Release|Win32
		{9DA95A37-01AB-4A9E-A5C0-5BAB1EEE24BF}.Release|QQTangCheatEngine.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E78BE233-3798-4080-8C8F-79DC13242730}
	EndGlobalSection
EndGlobal

```

`QQTang CheatEngine/Boss.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "NPC.hpp"
#define PBoss CBoss*

namespace QQTangCheatEngine
{
	class CBoss :
		public CNPC
	{
		public:

	};

	class CPVEBossInfo
	{
		private:
		INT32 m_IDFromClient;
		INT32 m_IDFromServer;
		BOOL m_IsShowHP;
		char m_szBossName [ 0x14 ];
		BossModle m_BossModle;
		INT32 m_BossFvck;
		INT32 m_BossDef;
		INT32 m_BossHP;
		INT32 m_BossSpeed;
		INT32 m_BossHurt;
		INT32 m_BossStatus;
		INT32 m_BossY;
		INT32 m_BossX;
		INT32 m_44;

		public:

		INT32 GetIDFromClient ( )
		{
			return m_IDFromClient;
		}

		INT32 GetIDFromServer ( )
		{
			return m_IDFromServer;
		}

		BOOL GetIsShowHP ( )
		{
			return m_IsShowHP;
		}

		char* GetszBossName ( )
		{
			return m_szBossName;
		}

		BossModle GetBossModle ( )
		{
			return m_BossModle;
		}

		INT32 GetBossFvck ( )
		{
			return m_BossFvck;
		}

		INT32 GetBossDef ( )
		{
			return m_BossDef;
		}

		INT32 GetBossHP ( )
		{
			return m_BossHP;
		}

		INT32 GetBossSpeed ( )
		{
			return m_BossSpeed;
		}

		INT32 GetBossHurt ( )
		{
			return m_BossHurt;
		}

		INT32 GetBossStatus ( )
		{
			return m_BossStatus;
		}

		INT32 GetBossY ( )
		{
			return m_BossY;
		}

		INT32 GetBossX ( )
		{
			return m_BossX;
		}

	};

	enum 
	{
		//0x48
		CPVEBossInfoSize = sizeof ( CPVEBossInfo ),
	};
	static_assert( CPVEBossInfoSize == 0x48, "CPVEBossInfoSize is error" );
}
```

`QQTang CheatEngine/CCall.hpp`:

```hpp
#pragma once
#pragma pack(1)
#include "Maple.hpp"
namespace QQTangCheatEngine
{
	class CCall
	{
		private:
			
		public:
			void   CreateRoom()
			{
				typedef void(__cdecl *pCreateRoom)();
				pCreateRoom(g_QQTangClient.m_CreateRoom)();
			}
			void   StartGame()
			{
				typedef void(__cdecl *pStartGame)();
				pStartGame(g_QQTangClient.m_StartGame)();
			}

			void   UseObject(ItemByPVE ObjectID,INT32 PetID)
			{
				typedef void(__cdecl *pUseObject)(ItemByPVE ObjectID, INT32 PetID);
				pUseObject(g_QQTangClient.m_UseObject)(ObjectID, PetID);
			}

			void   SelRoomSpeak(INT32 nsize, char *szBuffer)
			{
				typedef void(__cdecl *pSelRoomSpeak)(INT32 nsize, char *szBuffer);
				pSelRoomSpeak(g_QQTangClient.m_SelRoomSpeak)(nsize, szBuffer);
			}

			void   RoomSpeak(INT32 nsize, char *szBuffer)
			{
				typedef void(__cdecl *pRoomSpeak)(INT32 nsize, char *szBuffer);
				pRoomSpeak(g_QQTangClient.m_RoomSpeak)(nsize, szBuffer);
			}

			void   SetRoomMsg(char* szInRoomName,char* szOutRoomName, char* szPassWord)
			{
				typedef void(__cdecl *pSetRoomMsg)(char*, char*, char*);
				pSetRoomMsg(g_QQTangClient.m_SetRoomMsg)(szInRoomName, szOutRoomName, szPassWord);
			}

			void   OperateDoor(INT32 Index, INT32 nsize)
			{
				typedef void(__cdecl *pOperateDoor)(INT32 Index, INT32 nsize);
				pOperateDoor(g_QQTangClient.m_OperateDoor)(Index, nsize);
			}

			void   SelMap(MapID MapId, GameModle nsize)
			{
				typedef void(__cdecl *pSelMap)(MapID MapId, GameModle nsize);
				pSelMap(g_QQTangClient.m_SelMap)(MapId, nsize);
			}

			void   SelRoomModal(RoomType nType)
			{
				typedef void(__cdecl *pSelRoomModal)(RoomType nType);
				pSelRoomModal(g_QQTangClient.m_SelRoomType)(nType);
			}

			void   EnterRoom(INT32 TotalRoomID,char* szPassword)
			{
				typedef void(__cdecl *pEnterRoom)(INT32 TotalRoomID, char* szPassword);
				pEnterRoom(g_QQTangClient.m_EnterRoom)(TotalRoomID, szPassword);
			}

			void   EnterSelRoom(INT32 temp,PinDao pindao,QuYu quyu,INT32 SelSect)
			{
				typedef void(__cdecl *pEnterSelRoom)(INT32, PinDao, QuYu, INT32);
				pEnterSelRoom(g_QQTangClient.m_EnterSelRoom)(temp, pindao, quyu, SelSect);
			}

			void   MsgBox(char* szText, char* szCaption)
			{
				typedef void(__cdecl *pMsgBox)(char* , char*);
				pMsgBox(g_QQTangClient.m_MsgBox)(szText,szCaption);
			}

			void   NoticeBoard(char* szText, char* szCaption)
			{
				typedef void(__cdecl *pNoticeBoard)(char*, char*);
				pNoticeBoard(g_QQTangClient.m_NoticeBoard)(szText, szCaption);
			}

			void   ReleasePet(INT32 PetID)
			{
				typedef void(__cdecl *pReleasePet)(INT32);
				pReleasePet(g_QQTangClient.m_ReleasePet)(PetID);
			}

			void   ModifyRoomID(INT32 NewRoomID)
			{
				typedef void(__cdecl *pModifyRoomID)(INT32);
				pModifyRoomID(g_QQTangClient.m_ModifyRoomID)(NewRoomID);
			}

			void   ModifyPlayModle(INT32 nsize,PlayerModle NewPlayModle)
			{
				typedef void(__cdecl *pModifyPlayModle)(INT32, PlayerModle);
				pModifyPlayModle(g_QQTangClient.m_ModifyPlayModle)(nsize, NewPlayModle);
			}

			void   EnterRandRoom()
			{
				typedef void(__cdecl *pEnterRandRoom)();
				pEnterRandRoom(g_QQTangClient.m_EnterRandRoom)();
			}

			void   LeaveRoom()
			{
				typedef void(__cdecl *pLeaveRoom)();
				pLeaveRoom(g_QQTangClient.m_LeaveRoom)();
			}

			void   LeaveGame()
			{
				typedef void(__cdecl *pLeaveGame)();
				pLeaveGame(g_QQTangClient.m_LeaveGame)();
			}

			void   LeaveSelRoom()
			{
				typedef void(__cdecl *pLeaveSelRoom)();
				pLeaveSelRoom(g_QQTangClient.m_LeaveSelRoom)();
			}

			void   QuitGame()
			{
				typedef void(__cdecl *pQuitGame)();
				pQuitGame(g_QQTangClient.m_QuitGame)();
			}

			void   CarryPet(INT32 PetID)
			{
				typedef void(__cdecl *pCarryPet)(INT32);
				pCarryPet(g_QQTangClient.m_CarryPet)(PetID);
			}

			void   StopCarryPet(INT32 PetID)
			{
				typedef void(__cdecl *pStopCarryPet)(INT32);
				pStopCarryPet(g_QQTangClient.m_StopCarryPet)(PetID);
			}

			void   ModifyColor(INT32 nsize, TeamColor color)
			{
				typedef void(__cdecl *pModifyColor)(INT32, TeamColor);
				pModifyColor(g_QQTangClient.m_ModifyColor)(nsize, color);
			}

			void   ModifyChatRoomMap(INT32 MapId)
			{
				typedef void(__cdecl *pModifyChatRoomMap)(INT32);
				pModifyChatRoomMap(g_QQTangClient.m_ModifyChatRoomMap)(MapId);
			}

			CCall(){}
	};

}
```

`QQTang CheatEngine/EncodeMember.hpp`:

```hpp
/************************************************************************/
/* 
功能说明:部分道具信息加解密
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/

#pragma once
#pragma pack(1)
#include "Maple.hpp"
#define  CEncodeMember CEncodeMemberEx<INT32>
#define  PEncodeMember CEncodeMemberEx<INT32>*
#define  CEncodeINT16 CEncodeMemberEx<INT16>
#define  PEncodeINT16 CEncodeMemberEx<INT16>*

namespace QQTangCheatEngine
{ 
	template<typename T>
	class CEncodeMemberEx
	{
		private:

		T m_EncodeMember;

		UINT8 m_EncodeEnable;

		T m_EncodeMemberKey;

		UINT8 m_bytes [ 0xB ];

		public:

		CEncodeMemberEx ( T EncodeMember, T  EncodeMemberKey )
		{
			m_EncodeMember = EncodeMember;
			m_EncodeMemberKey = EncodeMemberKey;
		}

		//结果大于0x1234 尝试xor 0x1234
		T GetValue ( _In_ BOOL XOR = FALSE )
		{
			T nEncode = m_EncodeMember;

			CQQTangClient::Algorithm (
				( const PINT8 ) &m_EncodeMemberKey,
				FALSE, ( PINT8 ) &nEncode, sizeof ( T ) );

			if ( XOR )
			{
				nEncode ^= 0x1234;
			}
			return nEncode;
		}

		void SetValue ( _In_ T Value, _In_ BOOL XOR = FALSE )
		{
			if ( XOR )
			{
				Value ^= 0x1234;
			}
			CQQTangClient::Algorithm (
				( const PINT8 ) &m_EncodeMemberKey,
				TRUE, ( PINT8 ) &Value, sizeof ( T ) );
			m_EncodeMember = Value;
		}

		operator T( )
		{
			return GetValue ( );
		}

		CEncodeMemberEx& operator = ( _In_ T value )
		{
			SetValue ( value );
			return *this;
		}

		T GetEncodeMember()
		{
			return m_EncodeMember;
		}

		UINT8 GetEncodeEnable()
		{
			return m_EncodeEnable;
		}

		T GetEncodeMemberKey()
		{
			return m_EncodeMemberKey;
		}

	};

	enum
	{
 		CEncodeMemberExSize = sizeof ( CEncodeMemberEx <INT32 >),
	};
	static_assert( CEncodeMemberExSize == 20, "CEncodeMemberExSize is Error" );
}
```

`QQTang CheatEngine/GameBomb.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "maple.hpp"
#define PGameBomb CGameBomb*

namespace QQTangCheatEngine
{
	__interface IGameBombBase
	{
		void* InitBase ( bool Destroy );
		bool CanBomb ( );
		void FUNA ( );
		bool CanBombEx ( );
		INT32 GetStatus ( );
		void Update ( INT32 Elapse );
		void SetBomb ( );
		void SetStatus ( );
	};
	class CGameBomb :public IGameBombBase
	{

		INT32 m_BombStyle;//0x4
		UINT32 m_pBombItemA;//0x8
		UINT32 m_pBombItemB;//0xC
		UINT32 m_pBombItemC;//0x10
		//?
		UINT32 m_pBombItemD;//0x14
		UINT32 m_pBombItemE;//0x18

		INT16 m_BomberID;//0x1C
		INT16 m_BombPower;//0x1e

		UINT32 m_pBombItemG;//0x20
		INT32 m_GameTime;//0x24
		CLocation m_BombXY;//0x28

		BombStatus m_Status;//0x2C
		INT32 m_ExplodeTime;//0x30
		UINT32 m_pBombItemL;//0x34
		UINT32 m_pBombItemM;//0x38
		UINT32 m_pBombItemN;//0x3C
		UINT32 m_pBombItemO;//0x40

		public:
		INT32 GetBombStyle ( ) const
		{
			return m_BombStyle;
		}
		INT16 GetBomberID ( )const
		{
			return m_BomberID;
		}
		INT16 GetBombPower ( ) const
		{
			return m_BombPower;
		}
		INT32 GetGameTime ( ) const
		{
			return m_GameTime;
		}
		CLocation* GetBombXY ( )
		{
			return &m_BombXY;
		}
		BombStatus GetBombStatus ( ) const
		{
			return ( BombStatus ) ( m_Status & 0x00000FF );
		}
		INT32 GetExplodeTime ( ) const
		{
			return m_ExplodeTime;
		}

		//虚函数
		void* InitBase ( _In_ bool Destroy )
		{ }
		bool CanBomb ( )
		{ }
		void FUNA ( )
		{ }
		bool CanBombEx ( )
		{ }
		INT32 GetStatus ( )
		{ }
		void Update ( _In_ INT32 Elapse )
		{ }
		void SetBomb ( )
		{ }
		void SetStatus ( )
		{ }

	};

	enum
	{
		CGameBombSize = sizeof ( CGameBomb ) ,
	};
	static_assert( CGameBombSize == 0x44 , "CGameBombSize is error" );
}

```

`QQTang CheatEngine/GameBox.hpp`:

```hpp
/************************************************************************/
/* 
功能说明:墙壁
创建人:maple
创建日期:2014年9月7日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma  pack(1)
#include "Maple.hpp"
#define PGameBox CGameBox*

namespace QQTangCheatEngine
{
	__interface IGameBoxBase
	{
		void* DestroyBox ( bool Destroy ) ;
		bool InitBox ( ) ;
		bool InitFun ( ) ;
		void ExplodeBox ( ) ;
		INT32 GetBoxType ( ) ;
		LPVOID GetVoid ( ) ;
		char* GetName ( ) ;
		void UpDateBox ( INT32 Elapse ) ;
		void SetBoxXY ( INT16 x, INT16 y ) ;
		bool GetType ( INT32 value ) ;
		INT32 GetGridAttr ( INT32 X, INT32 Y ) ;
		bool CanThrough ( INT32 X, INT32 Y, PlayerDirection Direction ) ;
		bool PowerThrough ( INT32 X, INT32 Y, UINT8 Direction ) ;
		bool CanExplode ( ) ;
		bool CanMove ( ) ;
		void LoadUIByCreate ( ) ;
		void LoadUIByDestroy ( ) ;
		void LoadUIByMove ( INT16 X, INT16 Y,INT32 value ) ;
		void SmashBox ( INT32 value ) ;

	};

	class CGameBox :public IGameBoxBase
	{
		private:
		ItemByBox m_BoxID;
		CLocation m_BoxXY;
		INT32 m_LifeTime;

		INT32 m_0x10;
		INT32 m_0x14;
		INT32 m_0x18;
		INT32 m_0x1C;

		INT32 m_0x20;
		INT32 m_0x24;
		INT32 m_0x28;
		INT32 m_0x2C;

		INT32 m_0x30;
		INT32 m_0x34;
		INT32 m_0x38;
		INT32 m_0x3C;

		INT32 m_0x40;
		INT32 m_0x44;
		INT32 m_0x48;
		INT32 m_0x4C;

		INT32 m_0x50;
		INT32 m_0x54;
		INT32 m_0x58;
		INT32 m_0x5C;

		INT32  m_PushBox;
		INT32 m_0x64;
		INT32 m_0x68;
		INT32 m_0x6C;

		INT32 m_0x70;
		INT32 m_0x74;
		INT32 m_0x78;
		INT32 m_0x7C;




		public:
		CLocation* GetLocation ( )
		{
			return &m_BoxXY;
		}
		ItemByBox GetBoxID ( )
		{
			return m_BoxID;
		}
		INT32 GetLifeTime ( )
		{
			return m_LifeTime;
		}
		INT32 GetPushBox ( )
		{
			return m_PushBox;
		}
		//继承
		void* DestroyBox ( bool Destroy ){}
		bool InitBox ( ){}
		bool InitFun ( ){}
		void ExplodeBox ( ){}
		INT32 GetBoxType ( ){}
		LPVOID GetVoid ( ){}
		char* GetName ( ){}
		void UpDateBox ( INT32 Elapse ){}
		void SetBoxXY ( INT16 x, INT16 y ){}
		bool GetType ( INT32 value ){}		
		INT32 GetGridAttr ( INT32 X, INT32 Y ){}
		bool CanThrough ( INT32 X, INT32 Y, PlayerDirection Direction ){}
		bool PowerThrough ( INT32 X, INT32 Y, UINT8 Direction ){}
		bool CanExplode ( ){}
		bool CanMove ( ){}
		void LoadUIByCreate ( ){}
		void LoadUIByDestroy ( ){}
		void LoadUIByMove ( INT16 X, INT16 Y, INT32 value ){}
		void SmashBox ( INT32 value ){}
	};
	enum
	{
		//56
		CGameBoxSize = sizeof ( CGameBox ),
	};

	//检测CGAMEBOX大小
	static_assert( CGameBoxSize == 128, "CGameBoxSize is Error" );
}
```

`QQTang CheatEngine/GameFloor.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#define PGameFloor CGameFloor*

namespace QQTangCheatEngine
{
	__interface IGameFloorBase
	{
 		  void* DestroyBox ( bool Destroy ) ;
		  bool InitBox ( ) ;
		  bool InitFun ( ) ;
		  void ExplodeBox ( ) ;
		  INT32 GetBoxType ( ) ;
		  LPVOID GetVoid ( ) ;
		  char* GetName ( ) ;
		  void UpDateBox ( INT32 Elapse ) ;
		  void SetBoxXY ( INT16 x, INT16 y ) ;
		  bool GetType ( INT32 value ) ;
		 
		  INT32 GetGridAttr ( INT32 X, INT32 Y ) ;
		  bool CanThrough ( INT32 X, INT32 Y, PlayerDirection Direction ) ;
		  bool PowerThrough ( INT32 X, INT32 Y, UINT8 Direction ) ;
		  bool CanExplode ( ) ;
		  bool CanMove ( ) ;
		  void LoadUIByCreate ( ) ;
		  void LoadUIByDestroy ( ) ;
		  void LoadUIByMove ( INT16 X, INT16 Y, INT32 value ) ;
		  void SmashBox ( INT32 value ) ;

	};

	class CGameFloor :public IGameFloorBase
	{
		private:
		ItemByFloor m_FloorID;
		CLocation m_FloorXY;
		INT32 m_LifeTime;
		INT32 m_param1;
		LPVOID m_P1;
		LPVOID m_P2;
		LPVOID m_P3;
		LPVOID m_P4;
		LPVOID m_P5;
		LPVOID m_P6;
		LPVOID m_P7;
		LPVOID m_P8;
		LPVOID m_P9;

		public:
		CLocation* GetLocation ( )
		{
			return &m_FloorXY;
		}
		INT32 GetFloorID ( )
		{
			return m_FloorID;
		}
		INT32 GetLifeTime ( )
		{
			return m_LifeTime;
		}
		//继承
		void* DestroyBox ( bool Destroy ){}
		bool InitBox ( ){}
		bool InitFun ( ){}
		void ExplodeBox ( ){}
		INT32 GetBoxType ( ){}
		LPVOID GetVoid ( ){}
		char* GetName ( ){}
		void UpDateBox ( INT32 Elapse ){}
		void SetBoxXY ( INT16 x, INT16 y ){}
		bool GetType ( INT32 value ){}
		INT32 GetGridAttr ( INT16 X, INT16 Y ) { }
		bool CanThrough ( INT16 X, INT16 Y, PlayerDirection Direction ) { }
		bool PowerThrough ( INT16 X, INT16 Y, UINT8 Direction ) { }
		bool CanExplode ( ){}
		bool CanMove ( ){}
		void LoadUIByCreate ( ){}
		void LoadUIByDestroy ( ){}
		void LoadUIByMove ( INT16 X, INT16 Y, INT32 value ){}
		void SmashBox ( INT32 value ){}

	};
	enum
	{
		//56
		CGameFloorSize = sizeof ( CGameFloor ),
	};

	//检测CGAMEBOX大小
	static_assert( CGameFloorSize == 56, "CGameFloorSize is Error" );

}

```

`QQTang CheatEngine/GameInfo.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "GameFloor.hpp"
#include "GameBox.hpp"
#include "GameItem.hpp"
#include "GameBomb.hpp"
#include "Player.hpp"
#include "Boss.hpp"
#define PGameInfo CGameInfo*
#define PGameRoom CGameInfo::CGameRoom*
#define PMapItem CMapItem*
#define PMap CMap*
#define PMapBox CMapBox*
#define PMapFloor CMapFloor*
#define PSculptureItem CSculptureItem *
#define PMapBomb CMapBomb*
#define PGamePVE CGamePVE*
#define PBombExplode CBombExplode*
#define PBoxCode CGameInfo::CBoxCode*
#define PPlayBomb CPlayBomb*

namespace QQTangCheatEngine
{
	template<typename T, typename U>
	class CMapElemBase
	{
		protected:
		//0
		CEncodeMember m_MaxMapX;
		//0x14
		CEncodeMember m_MaxMapY;
		//28
		CMapY<T>* m_pID;
		//2C
		CMapY<U>* m_pInfo;
		//30
		PGameInfo m_pGameInfo;
		//34
		INT32 m_0x34;
		//38
		LPVOID m_0x38;
		//3c
		LPVOID m_0x3C;
		//40
		LPVOID m_0x40;
		//44 
		INT32 m_BeginID;
		public:
		virtual void* InitBase ( bool Destroy ) = 0;

		//0
		CEncodeMember* GetMaxMapX()
		{
			return &m_MaxMapX;
		}
		//0x14
		CEncodeMember GetMaxMapY()
		{
			return &m_MaxMapY;
		}
		//28
		CMapY<T> GetID()
		{
			return m_pID;
		}
		//2C
		CMapY<U> GetInfo()
		{
			return m_pInfo;
		}
		//30
		PGameInfo GetpGameInfo()
		{
			return m_pGameInfo;
		}
	};

	class CMap :public CMapElemBase < ItemByBox, PGameBox >
	{
		public:
		void*  InitBase ( bool Destroy ) { }

		ItemByBox GetBoxID ( short x, short y )
		{
			CMapX< ItemByBox >* pCX = m_pID [ y ].m_MapX;
			return pCX [ x ].m_ID;
		}
		PGameBox GetBoxInfo ( short x, short y )
		{
			CMapX<PGameBox>* pCX = m_pInfo [ y ].m_MapX;
			return pCX [ x ].m_pInfo;
		}

		PEncodeMember  GetMaxMapX ( )
		{
			return &this->m_MaxMapX;
		}
		PEncodeMember  GetMaxMapY ( )
		{
			return &this->m_MaxMapY;
		}
		PGameInfo GetGameInfo ( )
		{
			return m_pGameInfo;
		}


	};

	class CMapBox :public CMapElemBase < ItemByBox, PGameBox >
	{

		public:
		void* InitBase ( bool Destroy ) { }
		ItemByBox GetBoxID ( short x, short y )
		{
			CMapX< ItemByBox >* pCX = m_pID [ y ].m_MapX;
			return pCX [ x ].m_ID;
		}
		PGameBox GetBoxInfo ( short x, short y )
		{
			CMapX<PGameBox>* pCX = m_pInfo [ y ].m_MapX;
			return pCX [ x ].m_pInfo;
		}
		PEncodeMember  GetMaxMapX ( )
		{
			return &this->m_MaxMapX;
		}
		PEncodeMember  GetMaxMapY ( )
		{
			return &this->m_MaxMapY;
		}
		PGameInfo  GetGameInfo ( )
		{
			return m_pGameInfo;
		}

	};

	class CMapFloor : public CMapElemBase < ItemByFloor, PGameFloor >
	{

		public:
		void*  InitBase ( bool Destroy ) { }
		ItemByFloor  GetFloorID ( short x, short y )
		{
			CMapX< ItemByFloor >* pCX = m_pID [ y ].m_MapX;
			return pCX [ x ].m_ID;
		}
		PGameFloor  GetFloorInfo ( short x, short y )
		{
			CMapX<PGameFloor>* pCX = m_pInfo [ y ].m_MapX;
			return pCX [ x ].m_pInfo;
		}
		PEncodeMember  GetMaxMapX ( )
		{
			return &this->m_MaxMapX;
		}
		PEncodeMember  GetMaxMapY ( )
		{
			return &this->m_MaxMapY;
		}
		PGameInfo GetGameInfo ( )
		{
			return m_pGameInfo;
		}

	};

	class CGameInfo
	{
		private:
		//1310
		UINT8 m_0x1310 [ 0xE1C ];
		//212C
		CVector<PVOID>m_0x212C;
		//213C
		CMap m_Map;
		//2188
		CMapBox m_MapBox;
		//21D4
		CMapFloor m_MapFloor;

		//2220
		class CMapItem :public IBaseClass
		{
			private:
			INT32 m_0x2224;
			//不Get
			LPVOID m_GameItemInfo;
			INT32 m_0x222C;
			INT32 m_0x2230;
			INT32 m_MaxMapX;
			INT32 m_MaxMapY;
			INT32 m_0x223C;
			INT32 m_0x2240;
			INT32 m_0x2244;
			INT32 m_0x2248;
			CGameInfo* m_GameInfo;
			public:
			void* InitBase ( bool Destroy ) { }
			CGameInfo* GetGameInfo ( )
			{
				return m_GameInfo;
			}
			INT32 GetMaxMapX ( )
			{
				return m_MaxMapX;
			}
			INT32 GetMaxMapY ( )
			{
				return m_MaxMapY;
			}
			CVector<PGameItem>& FindGameItem ( short y, short x )
			{
				typedef CVector<CGameItem*>&( __thiscall *pFindGameItem )
					( PMapItem ThisClass, short y, short x );
				pFindGameItem pFind = ( pFindGameItem ) ( g_QQTangClient.m_FindGameItem );
				return pFind ( this, y, x );
			}
		}m_MapItem;

		//2250
		class CMapBomb :public IBaseClass
		{
			private:
			INT32 m_0x2254;
			LPVOID m_0x2258;
			INT32 m_0x225C;
			INT32 m_MapBombCountInc;
			INT32 m_0x2264;
			LPVOID m_0x2268;
			INT32 m_0x226C;
			INT32 m_MapBombCount;
			INT32 m_0x2274;
			LPVOID m_0x2278;
			INT32 m_0x227C;
			INT32 m_0x2280;
			INT32 m_0x2284;
			LPVOID m_0x2288;
			INT32 m_0x228C;
			INT32 m_BombCount;
			PGameInfo m_pGameInfo;
			//BAE
			INT32 m_BeginId;

			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( ) const
			{
				return m_pGameInfo;
			}
			CVector<PGameBomb>& FindGameBomb ( short y, short x )
			{
				typedef CVector<CGameBomb *>&( __thiscall *pFindGameBomb )
					( CMapBomb* ThisCall, short y, short x );
				pFindGameBomb pFind = ( pFindGameBomb ) ( g_QQTangClient.m_FindGameBomb );
				return pFind ( this, y, x );
			}
			INT32 GetMapBombCountInc ( ) const
			{
				return m_MapBombCountInc;
			}
			INT32 GetMapBombCount ( ) const
			{
				return m_MapBombCount;
			}
			INT32 GetBombCount ( ) const
			{
				return m_BombCount;
			}

		}m_MapBomb;

		//229C
		class CBombExplode :public IBaseClass
		{
			private:
			INT32 m_0x22A0;
			LPVOID m_0x22A4;
			INT32 m_0x22A8;
			INT32 m_0x22AC;
			INT32 m_MaxMapX;
			INT32 m_MaxMapY;
			INT32 m_0x22B8;
			INT32 m_0x22BC;
			INT32 m_0x22C0;
			INT32 m_0x22c4;
			PGameInfo m_pGameInfo;

			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			INT32 GetMaxMapX ( )const
			{
				return m_MaxMapX;
			}
			INT32 GetMaxMapY ( )const
			{
				return m_MaxMapY;
			}
		}m_BombExplode;

		//22CC
		class CBoxCode :public IBaseClass
		{
			private:
			INT32 m_0x22D0;
			INT32 m_0x22D4;
			INT32 m_0x22D8;
			INT32 m_0x22DC;
			INT32 m_0x22E0;
			INT32 m_0x22E4;
			INT32 m_0x22E8;
			INT32 m_0x22EC;
			PGameInfo m_pGameInfo;
			INT32 m_Code [ 15 * 13 ];
			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			INT32 GetCode(volatile INT32 y, volatile INT32 x)
			{
				INT32 BoxCode = 1;
				if ( ( y >= 0 && y <= 12 ) && ( x >= 0 && x <= 14 ) )
				{
					INT32 Index = ( y << 4 ) - y + x;
					BoxCode += ( m_Code [ Index ] >> 8 );
				}
				BoxCode <<= 4;
				BoxCode += y;
				BoxCode <<= 4;
				BoxCode += x;
				return BoxCode;
			}
		}m_BoxCode;

		//2600
		//基类墙壁....
		class CGameRoom :public IBaseClass
		{
			private:
			ItemByBox m_RoomType;
			CLocation m_RoomXY;
			INT32 m_RoomStatus;
			UINT32 m_0x10;
			UINT32 m_0x14;
			UINT32 m_0x18;
			UINT32 m_0x1C;
			UINT32 m_0x20;
			UINT32 m_0x24;
			UINT32 m_0x28;
			UINT32 m_0x2c;
			UINT32 m_0x30;
			UINT8 m_0x34;
			UINT8 m_0x35 [ 3 ];
			UINT8 m_RoomID;
			UINT8 m_RoomColor;
			UINT8 m_0x3A [ 2 ];
			INT32 m_TaskHp;
			UINT8 m_0x40 [ 0x20 ];
			UINT32 m_0x60;
			UINT32 m_0x64;
			UINT32 m_0x68;
			UINT32 m_0x6C;
			UINT32 m_0x70;
			public:
			void* InitBase ( bool Destroy ) { }
			ItemByBox GetRoomType ( ) //0x4 =2ee8
			{
				return m_RoomType;
			}
			CLocation* GetRoomXY ( )
			{
				return &m_RoomXY;
			}
			INT32 GetRoomStatus ( ) const//0xc
			{
				return m_RoomStatus;
			}
			UINT8 GetRoomID ( ) const//0x38
			{
				return m_RoomID;
			}
			UINT8 GetRoomColor ( ) const//0x39
			{
				return m_RoomColor;
			}
			INT32 GetTaskHp ( ) const//0x3c
			{
				return m_TaskHp;
			}
		}*m_pBunRoomA, *m_pBunRoomB, *m_pSculptureRoomA,
			*m_pSculptureRoomB, *m_pTankRoomA, *m_pTankRoomB;

		//2618
		class CSculptureItem :public IBaseClass
		{

			private:
			INT32 m_0x261C;
			LPVOID m_0x2620;
			INT32 m_0x2624;
			INT32 m_0x2628;
			INT32 m_MaxMapX;
			INT32 m_MaxMapY;
			PGameInfo m_pGameInfo;
			INT32 m_0x2638;
			INT32 m_0x263C;
			INT32 m_0x2640;
			INT32 m_0x2644;

			public:
			void* InitBase ( bool Destroy ) { }
			CVector<PGameItem>& FindSculptureItem ( short y, short x )
			{
				typedef CVector<CGameItem*>&( __thiscall *pFindSculptureItem )
					( PSculptureItem ThisClass, short y, short x );

				pFindSculptureItem pFind = ( pFindSculptureItem ) ( g_QQTangClient.m_FindSculptureItem );
				return pFind ( this, y, x );
			}
			PGameInfo GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			INT32 GetMaxMapX ( )
			{
				return m_MaxMapX;
			}
			INT32 GetMaxMapY ( )
			{
				return m_MaxMapY;
			}

		}m_SculptureItem;

		//2648
		CVector<CPlayer*> m_PlayerList;
		//2658
		CVector<CBoss*> m_BossList;

		//2668
		class CPlayBomb :public IBaseClass
		{
			private:
			PGameInfo m_pCGameInfo;
			INT32 m_PlayTime;
			UINT8 m_0x2674 [ 0x1C40 ];
			UINT8 m_0x42B4 [ 192 ];
			INT32 m_0x4374;
			INT32 m_0x4378;
			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )
			{
				return m_pCGameInfo;
			}
			INT32 GetPlayTime ( )
			{
				return m_PlayTime;
			}

		}m_PlayBomb;

		//437C
		class C437C :public IBaseClass
		{
			private:
			PGameInfo m_pGameInfo;
			INT32 m_0x4384;
			INT8 m_0x4388 [ 0x46 ];
			INT16 m_0x43CE;
			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )
			{
				return m_pGameInfo;
			}
		}m_0x437C;

		//43D0
		class C43D0 :public IBaseClass
		{
			private:
			PGameInfo m_pGameInfo;
			INT32 m_0x43D8;
			INT32 m_0x43DC;
			INT32 m_MaxMapX;
			INT32 m_MaxMapY;
			INT32 m_0x43E8;
			INT32 m_0x43EC;
			INT32 m_MaxMapXEx;
			INT32 m_MaxMapYEx;
			CVector<LPVOID> m_vec0x43F8;
			CVector<LPVOID> m_vec0x4408;
			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			INT32 GetMaxMapX ( )const
			{
				return m_MaxMapX;
			}
			INT32 GetMaxMapY ( )const
			{
				return m_MaxMapY;
			}
		}m_0x43D0;

		//4418
		class C4418 :public IBaseClass
		{
			private:
			INT32 m_0x441C;
			INT32 m_0x4420;
			INT32 m_0x4424;
			INT32 m_0x4428;
			PGameInfo m_pGameInfo;
			INT32 m_0x4430;
			CVector<LPVOID>m_vec0x4434;
			INT8 m_0x4444 [ 0x200 ];
			INT32 m_0x4644;
			CVector<ItemByGame>m_vecFlyItem;
			INT8 m_0x4658 [ 0x184 ];
			//47DC
			INT32 m_FlyItemTime;
			INT32 m_0x47E0;
			INT32 m_0x47E4;
			INT8 m_0x47E8 [ 0x318 ];
			INT32 m_0x4B00;
			INT32 m_0x4B04;
			INT32 m_0x4B08;
			UINT8 m_MachineSkill;
			INT8 m_0x4B0D [ 3 ];

			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )const
			{
				return m_pGameInfo;
			}
			vector<ItemByGame>* GetFlyItem ( )
			{
				return m_vecFlyItem.GetVecInfo ( );
			}
			INT32 GetFlyTime ( )const
			{
				return m_FlyItemTime;
			}
			UINT8 GetMachineSkill ( ) const
			{
				return m_MachineSkill;
			}
		} m_0x4418;

		//4B10
		class CReLive
		{
			private:
			CVector<CLocation> m_ReLiveXY;
			CVector<CLocation> m_XY;
			public:
			vector<CLocation>* GetReLiveXY ( )
			{
				return m_ReLiveXY.GetVecInfo();
			}
			vector<CLocation>* GetXY ( )
			{
				return m_XY.GetVecInfo ( );
			}

		}m_ReLive;

		//4B30
		class CPlayerInfo
		{
			private:
			//4B30
			INT16 m_MySelfID;
			INT16 m_0x4B32;
			//4B34
			CPlayer* m_pMySelf;
			//4B38
			CPlayer* m_pCurrentPlayer;
			//4B3C
			INT16 m_FirstPlayerID;
			INT16 m_0x4B3E;
			//4B40
			CPlayer* m_pArbitrator;
			//4B44
			INT32 m_PlayerCount;
			//4B48
			INT32 m_GameTime;
			INT32 m_0x4B4C;
			INT32 m_0x4B50;
			INT32 m_0x4B54;
			public:
			INT16 GetMySelfID ( )
			{
				return m_MySelfID;
			}
			CPlayer* GetMySelf ( )
			{
				return m_pMySelf;
			}
			CPlayer* GetArbitrator ( )
			{
				return m_pArbitrator;
			}
			INT32 GetPlayerCount ()const
			{
				return m_PlayerCount;
			}
			INT32 GetGameTime ( ) const
			{
				return m_GameTime;
			}
		}m_PlayerInfo;

		//4B58
		class C4B58 :public IBaseClass
		{
			private:
			PGameInfo m_pGameInfo;
			INT32 m_0x4B60 [ 0x10 ];
			vector<LPVOID>m_0x4BA0;
			INT32 m_0x4BAC [ 7 + 7 ];
			INT32 m_0x4BE4;
			INT32 m_0x4BE8 [ 7 + 7 ];
			INT8 m_0x4C20;
			INT8 m_0x4C21 [ 3 ];
			INT32 m_0x4C24;
			INT8 m_0x4C28;
			INT8 m_0x4C29 [ 3 ];
			float m_0x4C2C;
			public:
			void* InitBase ( bool Destroy ) { }
			PGameInfo GetGameInfo ( )const
			{
				return m_pGameInfo;
			}
		}m_0x4B58;

		//4C30
		class C4C30
		{
			private:
			CVector<LPVOID>m_vec0x4C30;
			CVector<LPVOID>m_vec0x4C40;
			INT8 m_0x4C50 [ 0x1C ];
			CVector<CLocation>m_vec4C6C;
			INT16 m_PlayerCount;
			// (eq 0x4E21)
			INT16 m_0x4C7E;
			INT32 m_4C80;
			INT8 m_4C84 [ 0x18B ];
		}m_0x4C30;

		//4E0F
		class C4E0F
		{
			private:
			INT8 m_0x4E0F;
			INT8 m_0x4E10;
			INT8 m_0x4E11;
			INT16 m_0x4E12;

			INT32 m_0x4E14;
			INT32 m_0x4E18;
			INT32 m_0x4E1C;

			INT32 m_0x4E20;
			INT32 m_0x4E24;
			INT32 m_0x4E28;
			INT32 m_0x4E2C;

			INT8 m_0x4E30 [ 0x44 ];
			INT32 m_0x4E74;
			INT32 m_0x4E78;
			INT32 m_0x4E7C;

			//eq 258
			INT32 m_0x4E80;
			//eq 208
			INT32 m_0x4E84;
			INT32 m_0x4E88;
			INT32 m_0x4E8C;

			//4e90
			class CGamePVE :public IBaseClass
			{
				private:
				//4
				BOOL m_CanNextMap;
				//8 c 10 14
				CVector<INT32> m_vecLockArea;
				//18 地图信息
				LPVOID m_pMapInfo;
				//1c
				CGameInfo* m_pGameInfo;
				//20
				INT32 m_LookMinX;
				INT32 m_LookMinY;
				INT32 m_LookMaxX;
				INT32 m_LookMaxY;
				INT32 m_LookSizeMinX;
				INT32 m_LookSizeMinY;
				INT32 m_LookSizeMaxX;
				INT32 m_LookSizeMaxY;
				CVector<CPVEBossInfo> m_vecBossInfo;
				INT32 m_50;
				INT32 m_54;
				INT32 m_58;
				INT32 m_5C;

				INT32 m_60;
				INT32 m_64;
				INT32 m_68;
				INT32 m_6C;

				INT32 m_70;
				INT32 m_74;
				INT32 m_78;
				INT32 m_7C;

				INT32 m_80;
				INT32 m_84;
				INT32 m_ContinueID;
				INT32 m_MapIndex;
				INT32 m_90;
				CVector<LPVOID> m_vecInfoC;
				INT32 m_A4;
				public:

				//4
				BOOL GetCanNextMap ( )
				{
					return m_CanNextMap;
				}
				//8 c 10 14
				CVector<INT32>* GetvecLockArea ( )
				{
					return &m_vecLockArea;
				}
				//18 地图信息
				LPVOID GetpMapInfo ( )
				{
					return m_pMapInfo;
				}
				//1c
				CGameInfo* GetpGameInfo ( )
				{
					return m_pGameInfo;
				}
				//20
				INT32 GetLookMinX ( )
				{
					return m_LookMinX;
				}
				INT32 GetLookMinY ( )
				{
					return m_LookMinY;
				}
				INT32 GetLookMaxX ( )
				{
					return m_LookMaxX;
				}
				INT32 GetLookMaxY ( )
				{
					return m_LookMaxY;
				}
				INT32 GetLookSizeMinX ( )
				{
					return m_LookSizeMinX;
				}
				INT32 GetLookSizeMinY ( )
				{
					return m_LookSizeMinY;
				}
				INT32 GetLookSizeMaxX ( )
				{
					return m_LookSizeMaxX;
				}
				INT32 GetLookSizeMaxY ( )
				{
					return m_LookSizeMaxY;
				}
				CVector<CPVEBossInfo>* GetvecBossInfo ( )
				{
					return &m_vecBossInfo;
				}

				INT32 GetContinueID ( )
				{
					return m_ContinueID;
				}
				INT32 GetMapIndex ( )
				{
					return m_MapIndex;
				}

				CVector<LPVOID>* GetvecInfoC ( )
				{
					return &m_vecInfoC;
				}

				void* InitBase ( bool Destroy ) { }

			}*m_pGamePVE;

			INT16 m_PVENextMapX;
			INT16 m_PVENextMapY;
			INT8 m_0x4E98 [ 0xC ];

			public:
			PGamePVE GetGamePVE ( )
			{
				return m_pGamePVE;
			}

		}m_0x4E0F;

		public:
		PMap GetMap( )
		{
			return &m_Map;
		}

		PMapBox GetMapBox ( )
		{
			return &m_MapBox;
		}

		PMapFloor GetMapFloor ( )
		{
			return &m_MapFloor;
		}

		PMapItem GetMapItem ( )
		{
			return &m_MapItem;
		}

		PMapBomb GetMapBomb ( )
		{
			return &m_MapBomb;
		}

		PBombExplode GetBombExplode ( )
		{
			return &m_BombExplode;
		}

		PBoxCode GetBoxCode ( )
		{
			return &m_BoxCode;
		}
		//2600
		PGameRoom GetBunRoomA ( ) const
		{
			return m_pBunRoomA;
		}
		PGameRoom GetBunRoomB ( ) const
		{
			return m_pBunRoomB;
		}
		PGameRoom GetSculptureRoomA ( ) const
		{
			return m_pSculptureRoomA;
		}
		PGameRoom GetSculptureRoomB ( ) const
		{
			return m_pSculptureRoomB;
		}
		PGameRoom GetTankRoomA ( ) const
		{
			return m_pTankRoomA;
		}
		PGameRoom GetTankRoomB ( ) const
		{
			return m_pTankRoomB;
		}

		//2618
		PSculptureItem GetSculptureItem ( )
		{
			return &m_SculptureItem;
		}

		//2648
		vector<CPlayer*>* GetPlayerList ( )
		{
			return m_PlayerList.GetVecInfo ( );
		}

		CPlayer* AtPlayer ( NPCINDEX index )
		{
			vector<CPlayer*>*pvecPlayer = GetPlayerList ( );
			if ( pvecPlayer->size ( ) > index )
			{
				return ( *pvecPlayer ) [ index ];
			}
			return NULL;
		}

		CPlayer* FindPlayer ( INT16 IdFromClient )
		{
			vector<CPlayer*>*pvecPlayer = GetPlayerList ( );
			vector<CPlayer*>::iterator it;
			for ( it = pvecPlayer->begin ( ); it != pvecPlayer->end ( ); it++ )
			{
				if ( IdFromClient == ( *it )->GetIDFromClinet ( ) )
				{
					return ( *it );
				}
			}
			return NULL;
		}

		//2658
		vector<CBoss*>* GetBossList ( )
		{
			return m_BossList.GetVecInfo ( );
		}

		CBoss* AtBOSS ( NPCINDEX index )
		{
			vector<CBoss*>*pvecBOSS = GetBossList ( );
			if ( pvecBOSS->size ( ) > index )
			{
				return ( *pvecBOSS ) [ index ];
			}
			return NULL;
		}

		CBoss* FindBOSS ( INT16 IdFromClient )
		{
			vector<CBoss*>*pvecBOSS = GetBossList ( );
			vector<CBoss*>::iterator it;
			for ( it = pvecBOSS->begin ( ); it != pvecBOSS->end ( ); it++ )
			{
				if ( IdFromClient == ( *it )->GetIDFromClinet ( ) )
				{
					return ( *it );
				}
			}
			return NULL;
		}
		bool IsBossID ( INT16 IdFromClient )
		{
			vector<CBoss*>*pvecBOSS = GetBossList ( );
			vector<CBoss*>::iterator it;
			for ( it = pvecBOSS->begin ( ); it != pvecBOSS->end ( ); it++ )
			{
				if ( IdFromClient == ( *it )->GetIDFromClinet ( ) )
				{
					return true;
				}
			}
			return false;
		}

		//2668
		PPlayBomb GetPlayBomb ( )
		{
			return &m_PlayBomb;
		}

        vector<ItemByGame>* GetFlyItem ( )
        {
            return m_0x4418.GetFlyItem ( );
        }

		UINT8 GetMachineSkill ( ) const
		{
			return m_0x4418.GetMachineSkill ( );
		}
		INT32 GetGameTime ( )const
		{
			return m_PlayerInfo.GetGameTime ( );
		}

		CPlayerInfo* GetPlayerInfo ( )
		{
			return &m_PlayerInfo;
		}

	};

	enum
	{
		CGameInfoSize = sizeof ( CGameInfo ),
	};
	static_assert( CGameInfoSize == 15252, "CGameInfoSize is error" );
}

```

`QQTang CheatEngine/GameItem.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma  pack(1)
#include "Maple.hpp"
#define PGameItem CGameItem*

namespace QQTangCheatEngine
{
	__interface IGameItemBase
	{
		void* InitBase ( bool Destroy );
		bool IsUsing ( );
	};

	class CGameItem :public IGameItemBase
	{
		private:
		INT32 m_LeftTime;
		INT32 m_0x8;
		ItemByGame m_ItemID;
		CLocation m_ItemXY;
		INT32 m_0x14;
		INT32 m_0x18;
		INT32 m_0x1C;
		INT32 m_0x20;
		INT32 m_0x24;
		INT32 m_0x2C;
		INT32 m_0x30;
		INT32 m_0x34;

		public:
		INT16 GetItemInMaxX ( )const
		{
			return m_ItemXY.GetX ( );
		}
		INT16 GetItemInMaxY ( )const
		{
			return m_ItemXY.GetY ( );
		}
		ItemByGame GetItemID ( )const
		{
			return m_ItemID;
		}
		INT16 GetItemInPlayerX ( )
		{
			INT16 x = m_ItemXY.GetX ( );
			x = x * 4 + x;
			return (x * 8 + 20);
		}
		INT16 GetItemInPlayerY ( )
		{
			INT16  y = m_ItemXY.GetY ( );
			y = y * 4 + y;
			return ( y * 8 + 20 );
		}

        BOOL IsPropToServer ( )
        {
            switch ( m_ItemID )
            {
                //81
                case QQTangCheatEngine::GAME_TONGBI:
                {
                    return TRUE;
                }
                //82
                case QQTangCheatEngine::GAME_YINBI:
                {
                    return TRUE;
                }
                //83
                case QQTangCheatEngine::GAME_JINBI:
                {
                    return TRUE;
                }
                //84
                case QQTangCheatEngine::GAME_QIANDAI:
                {
                    return TRUE;
                }
                //85
                case QQTangCheatEngine::GAME_BAOXIANG1000TB:
                {
                    return TRUE;
                }
                //91
                case QQTangCheatEngine::GAME_HONGZUANSHI:
                {
                    return TRUE;
                }
                //92
                case QQTangCheatEngine::GAME_LANZUANSHI:
                {
                    return TRUE;
                }
                //211
                case QQTangCheatEngine::GAME_ZIZUANSHI:
                {
                    return TRUE;
                }
                //212
                case QQTangCheatEngine::GAME_XUEPINGZI:
                {
                    return TRUE;
                }
                //213
                case QQTangCheatEngine::GAME_HUANGLUOSI:
                {
                    return TRUE;
                }
                //93
                case QQTangCheatEngine::GAME_TANGBI1000:
                {
                    return TRUE;
                }
                //94
                case QQTangCheatEngine::GAME_TANGBI500:
                {
                    return TRUE;
                }
                //86
                case QQTangCheatEngine::GAME_JINGYAN20:
                {
                    return TRUE;
                }
                //87
                case QQTangCheatEngine::GAME_JINGYAN50:
                {
                    return TRUE;
                }
                //88
                case QQTangCheatEngine::GAME_JINGYAN100:
                {
                    return TRUE;
                }
                //89
                case QQTangCheatEngine::GAME_JINGYAN200:
                {
                    return TRUE;
                }
                //96
                case QQTangCheatEngine::GAME_MEIGUI1:
                {
                    return TRUE;
                }
                //97
                case QQTangCheatEngine::GAME_LVSHUIJING:
                {
                    return TRUE;
                }
                //98
                case QQTangCheatEngine::GAME_KUBI:
                {
                    return TRUE;
                }
                //150
                case QQTangCheatEngine::GAME_HONGBAOSHI:
                {
                    return TRUE;
                }
                //151
                case QQTangCheatEngine::GAME_HUANGBAOSHI:
                {
                    return TRUE;
                }
                //152
                case QQTangCheatEngine::GAME_LVBAOSHI:
                {
                    return TRUE;
                }
                //402
                case QQTangCheatEngine::GAME_MEIGUI2:
                {
                    return TRUE;
                }
                //403
                case QQTangCheatEngine::GAME_DIARY:
                {
                    return TRUE;
                }
            }

            if ( ( m_ItemID < 400 || m_ItemID > 1000 ) &&
                ( m_ItemID <= 24000 || m_ItemID >= 24500 ) &&
                ( m_ItemID <= 30000 || m_ItemID >= 32000 ) &&
                ( m_ItemID < 25001 || m_ItemID > 29000 ) &&
                ( m_ItemID < 9001 || m_ItemID > 9010 ) )
            {
                return FALSE;
            }
            return TRUE;
        }



		void* InitBase ( bool Destroy ) { }
		bool IsUsing ( ) { }
	};


}


```

`QQTang CheatEngine/GameManager.hpp`:

```hpp
/************************************************************************/
/* 
功能说明:
创建人:maple
创建日期:2014年9月2日
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)

#include "GameInfo.hpp"
#define PGameManager CGameManager*
#define PGameDispose CGameDispose*
#define PGameModleInfo CGameModleInfo*
#define PGameDisplayInfo CGameDisplayInfo*

namespace QQTangCheatEngine
{
    class CGameManager;
    class CGameDisplayInfo;
    typedef void ( __thiscall * GameDisplayAddress )( PGameDisplayInfo , GameID , LPVOID );

    class CBaseGameDisplayInfo :public IBaseClass
    {
    private:
        GameDisplayAddress m_DisplayAddress;
    public:
        GameDisplayAddress GetDisplayAddr ( )
        {
            return m_DisplayAddress;
        }
        void SetDisplayAddr ( GameDisplayAddress lpAddress )
        {
            DWORD dwOldProtect = 0;
            VirtualProtect ( &m_DisplayAddress , sizeof ( m_DisplayAddress ) , PAGE_READWRITE , &dwOldProtect );
            m_DisplayAddress = lpAddress;
            VirtualProtect ( &m_DisplayAddress , sizeof ( m_DisplayAddress ) , PAGE_READONLY , &dwOldProtect );
        }
//         __declspec( property( get = GetDisplayAddr , put = SetDisplayAddr ) ) GameDisplayAddress DisplayAddress;
    };

    class CGameDisplayInfo :public CBaseGameDisplayInfo
    {
    private:
        PGameManager m_pGameManager;
    public:
        PGameManager GetGameManager ( )
        {
            return m_pGameManager;
        }
        void HookGameDisplay ( GameID gameid , LPVOID pPacks )
        {

        }
    };



	__interface IHeaderBase
	{
 		void* InitBase ( bool val ) ;
		void UpDateGame ( UINT32 uElapse ) ;
		void EnterGame ( ) ;
		void ShowGameUI ( ) ;
		bool FunA ( INT32 value ) ;
		bool ShowBoss ( ) ;
		bool FunB ( ) ;
	};

	__interface IGameModleInfoBase
	{
 		void* InitBase ( bool Destroy ) ;
		bool InitGame ( LPVOID p, LPVOID gameinfo ) ;
		void InitGame ( ) ;
		bool RetTrue ( ) ;
		bool is ( ) ;
		INT32 GetA ( ) ;
		void GetPlayerDropItem ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) ;
		void GetBossDropItem ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) ;
		void Fun ( CPlayer* pPlayer ) ;
		INT32 GetB ( ) ;
		void ret ( ) ;
		INT32 ret6 ( ) ;
		void funA ( ) ;
		INT32 Ret6 ( ) ;
		INT32 Ret0 ( ) ;
		INT32 ret0 ( ) ;
		void  incm_18 ( ) ;
		void funb ( ) ;
		
		void func ( ) ;
		
		void* InitBaseA ( bool Destroy ) ;
		bool InitGameA ( LPVOID p, LPVOID gameinfo ) ;
		void InitGameA ( ) ;
		bool retA ( ) ;
		bool retB ( ) ;
		INT32 retC ( ) ;
		void GetPlayerDropItemA ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) ;
		void GetBossDropItemA ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) ;
		void FunA ( CPlayer* pPlayer ) ;
		INT32 retD ( ) ;
		void retE ( ) ;
		INT32 retE6 ( ) ;
		void retF ( ) ;
		INT32 retG6 ( ) ;
		INT32 retE5 ( ) ;
		INT32 retE0 ( ) ;
		void retG ( ) ;
		void retH ( ) ;
		
		void funD ( ) ;
		
		void* InitBaseB ( bool Destroy ) ;
		bool InitGameB ( LPVOID p, LPVOID gameinfo ) ;
		bool InitGameB ( ) ;
		bool retAA ( ) ;
		bool retAB ( ) ;
		BOOL retAC ( ) ;
		void GetPlayerDropItemB ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) ;
		void GetBossDropItemB ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) ;
		void FunAA ( INT32 value ) ;
		INT32 GetFunA ( INT32 value ) ;
		void GetFunB ( ) ;
		INT32 GetFUN6 ( ) ;
		void FunAC ( ) ;
		INT32 GetFUNA6 ( ) ;
		INT32 GetFUNA0 ( ) ;
		INT32 GetFUNB0 ( ) ;
		void FunAD ( ) ;
		void FunAE ( ) ;
		
		void FunAF ( ) ;
		//......
	};

	__interface I4F00Base
	{
		void* InitBaseA ( );
		void* InitBaseB ( );
	};

	class CGameManager
	{
		private:

		class CHeader :public IHeaderBase
		{
			private:
			//4
			UINT32 m_uElapse;
			//8
			INT32 m_RunGameEvent;
			//0xC
			INT64 m_GameTime;
			//0x14
			INT32 m_0x14;
			//0x18
			MapID m_GameMapID;
			//0x1C
			UINT8 m_0x1C [ 0xA ];
			//0x26
			UINT8 m_PlayerCount;
			//0x27
			UINT8 m_0x27 [ 0x12E9 ];
			public:
			UINT32 GetElapse ( ) const
			{
				return m_uElapse;
			}
			INT32 GetRunGameEvent ( ) const
			{
				return m_RunGameEvent;
			}
			INT64 GetGameTime ( ) const
			{
				return m_GameTime;
			}

			MapID GetGameMapID ( ) const
			{
				return m_GameMapID;
			}
			UINT8 GetPlayerCount ( ) const
			{
				return m_PlayerCount;
			}

			void* InitBase ( bool val ) {}
			void UpDateGame ( UINT32 uElapse ) {}
			void EnterGame ( ) {}
			void ShowGameUI ( ) {}
			bool FunA ( INT32 value ) {}
			bool ShowBoss ( ) {}
			bool FunB ( ) {}
		}m_Header;

		//0x1310
		CGameInfo m_GameInfo;

		//0x4EA4
		class CGameModleInfo :public IGameModleInfoBase
		{
			private:
			CGameInfo* m_pGameInfo;
			GameModle m_GameModle;
			INT32 m_MaxMapX;
			INT32 m_MaxMapY;
			INT32 m_inc;
			public:
			CGameInfo* GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			GameModle GetGameModle ( )
			{
				return m_GameModle;
			}
			INT32 GetMaxMapX ( )
			{
				return m_MaxMapX;
			}
			INT32 GetMaxMapY ( )
			{
				return m_MaxMapY;
			}

			void* InitBase ( bool Destroy ) { }
			bool InitGame ( LPVOID p, LPVOID gameinfo ) { }
			void InitGame ( ) { }
			bool RetTrue ( ) { }
			bool is ( ) { }
			INT32 GetA ( ) { }
			void GetPlayerDropItem ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) { }
			void GetBossDropItem ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) { }
			void Fun ( CPlayer* pPlayer ) { }
			INT32 GetB ( ) { }
			void ret ( ) { }
			INT32 ret6 ( ) { }
			void funA ( ) { }
			INT32 Ret6 ( ) { }
			INT32 Ret0 ( ) { }
			INT32 ret0 ( ) { }
			void  incm_18 ( ) { }
			void funb ( ) { }
			
			void func ( ) { }
			
			void* InitBaseA ( bool Destroy ) { }
			bool InitGameA ( LPVOID p, LPVOID gameinfo ) { }
			void InitGameA ( ) { }
			bool retA ( ) { }
			bool retB ( ) { }
			INT32 retC ( ) { }
			void GetPlayerDropItemA ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) { }
			void GetBossDropItemA ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) { }
			void FunA ( CPlayer* pPlayer ) { }
			INT32 retD ( ) { }
			void retE ( ) { }
			INT32 retE6 ( ) { }
			void retF ( ) { }
			INT32 retG6 ( ) { }
			INT32 retE5 ( ) { }
			INT32 retE0 ( ) { }
			void retG ( ) { }
			void retH ( ) { }
			
			void funD ( ) { }
			
			void* InitBaseB ( bool Destroy ) { }
			bool InitGameB ( LPVOID p, LPVOID gameinfo ) { }
			bool InitGameB ( ) { }
			bool retAA ( ) { }
			bool retAB ( ) { }
			BOOL retAC ( ) { }
			void GetPlayerDropItemB ( CPlayer* pPlayer, CVector<ItemByGame>&vecItem ) { }
			void GetBossDropItemB ( CBoss* pBoss, CVector<ItemByGame>&vecItem ) { }
			void FunAA ( INT32 value ) { }
			INT32 GetFunA ( INT32 value ) { }
			void GetFunB ( ) { }
			INT32 GetFUN6 ( ) { }
			void FunAC ( ) { }
			INT32 GetFUNA6 ( ) { }
			INT32 GetFUNA0 ( ) { }
			INT32 GetFUNB0 ( ) { }
			void FunAD ( ) { }
			void FunAE ( ) { }
			
			void FunAF ( ) { }

		}*m_pGameModleInfo;

		//0x4EA8
		class CGameDispose :public IBaseClass
		{
			private:
			INT32 m_4EAC;
			LPVOID m_4EB0;
			INT32 m_4EB4;
			INT32 m_4EB8;
			PGameManager m_pGameManager;

			public:
			void* InitBase ( bool Destroy ) { }

			template<typename T>
			void GameDispose ( GameID gameid, T& Package )
			{
				typedef void ( __thiscall *pGameDispose )
					( PGameDispose ThisClass, GameID gameid, T& Package );
				pGameDispose pDispose = ( pGameDispose ) ( g_QQTangClient.m_GameDispose );
				pDispose ( this, gameid, Package );
			}

            
            PGameDisplayInfo GetGameDisplayInfo ( GameID gameid )
            {
                typedef  PGameDisplayInfo ( __thiscall *pGetGameDisplayInfo )
                    ( PGameDispose ThisClass , GameID gameid );
                pGetGameDisplayInfo pInfo = ( pGetGameDisplayInfo ) ( g_QQTangClient.m_DisPlayAddress );
                return pInfo ( this , gameid );
            }

		}m_GameDispose;

		//0x4EC0
		class C4EC0 :public IBaseClass
		{
			private:
			//0x4EC4
			CHeader* m_Header;
			//0x4EC8
			CVector<LPVOID>m_4EC8;
			//0x4ED8
			CVector<LPVOID>m_4ED8;
			//0x4EE8
			CVector<LPVOID>m_4EE8;

			public:
			void* InitBase ( bool Destroy ) { };

		}m_0x4EC0;

		//0x4EF8
		class C4EF8
		{
			private:
			INT32 m_0x4EF8;
			INT32 m_0x4EFC;
			class C4F00 :public I4F00Base
			{
				private:
				INT32 m_0x4F04;
				INT32 m_0x4F08;
				INT32 m_0x4F0C;
				INT8 m_0x4F10 [ 0x60 ];
				INT32 m_0x4F70;
				INT32 m_0x4F74;
				INT32 m_0x4F78;
				INT32 m_0x4F7C;

				public:
				void* InitBaseA ( ) { }
				void* InitBaseB ( ) { }

			}m_0x4F00;
		}m_0x4EF8;
		
		//0x4F80
		class C4F80 :public IBaseClass
		{
			private:
			C4EF8 m_4F84;
			INT32 m_500C;
			INT32 m_5010;
			INT32 m_5014;
			INT32 m_5018;
			INT32 m_501C;
			INT8 m_5020 [ 0x168 ];
			public:
			void* InitBase ( bool Destroy ) { }
		}m_0x4F80;

		//0x5188
		class C5188 :public IBaseClass
		{
			private:
			CVector<LPVOID>m_518C;
			public:
			void* InitBase ( bool Destroy ) { }
		} m_0x5188;

		//0x519C
		class C519C
		{
			private:
			INT8 m_519C;
			INT8 m_519D;
			INT8 m_519E;
			INT8 m_519F;
			INT8 m_51A0;
			INT8 m_51A1;
			INT8 m_51A2;
			INT8 m_51A3;
			INT32 m_51A4;
			INT32 m_51A8;
		}m_0x519C;

		public:
		CGameInfo* GetGameInfo ( )
		{
			return &m_GameInfo;
		}
		PGameModleInfo GetGameModleInfo ( )
		{
			return m_pGameModleInfo;
		}
		CGameDispose* GetGameDispose ( )
		{
			return &m_GameDispose;
		}
	};
	enum 
	{
		//20908
		CGameManagerSize = sizeof ( CGameManager ),
	};
	static_assert( CGameManagerSize == 20908, "CGameManagerSize is error" );
}
```

`QQTang CheatEngine/GameUI.hPP`:

```hPP
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "QQTangClient.hpp"
#define PGameUI CGameUI*
namespace QQTangCheatEngine
{
	__interface IGameUIBase
	{
		void Init ( );
		void  InitGlobal ( int a , int b , int c , int d );
		void  ImportUIScript ( int a , int b , int c , int d );
		void  UnLoad ( );//??
		void  RefurbishGameUI ( float a );
		void  GFX ( );//???
		void  GameEvent ( int a , int b , char* butter );
		void  GameEventEx ( );
		void  CheatUIRoom ( char* pszRoomType );
		void  ShowMouse ( BOOL bShow );
		char*  GetUIRoom ( );
		void  UnKnowA ( int a , int b );
		void  UnKnowB ( int a , int b , int c );
		void  GameSay (
			const char* pszChatType ,
			char* pszChatText , INT32 EventValue ,
			UINT8 Red , UINT8 Green , UINT8 Blue );
		void  GameMsgBox ( char* pszText , char* pszCaption , int Zero , const char* pszMsgbox , int Event );
		void  InitGameUIItem ( char*pszGameUIItem , char* pszItemNumber );
		void  LoadGameUIImg ( char*pszUIName , char* pszImg );
		void  GameUIShow ( char* pszGameUIShow );
		void  ShowPlayerCheat ( int a , int b , int c );
		void  UnKnowC ( int a , int b );
		void  UnLoadEx ( int a );
	};

	class CGameUI :public IGameUIBase
	{
		public:
		static PGameUI GetGameUI ( )
		{
			return( PGameUI ) ( *( PUINT32 ) ( g_QQTangClient.m_GameUI ) );
		}


		void Init ( )
		{ }
		void  InitGlobal ( int a , int b , int c , int d )
		{ }
		void  ImportUIScript ( int a , int b , int c , int d )
		{ }
		void  UnLoad ( )
		{ }//??
		void  RefurbishGameUI ( float a )
		{ }
		void  GFX ( )
		{ }//???
		void  GameEvent ( int a , int b , char* butter )
		{ }
		void  GameEventEx ( )
		{ }
		void  CheatUIRoom ( char* pszRoomType )
		{ }
		void  ShowMouse ( BOOL bShow )
		{ }
        char*  GetUIRoom ( )
        {
            return nullptr;
        }
		void  UnKnowA ( int a , int b )
		{ }
		void  UnKnowB ( int a , int b , int c )
		{ }
		void  GameSay (
			const char* pszChatType ,
			char* pszChatText , INT32 EventValue ,
			UINT8 Red , UINT8 Green , UINT8 Blue )
		{ }
		void  GameMsgBox ( char* pszText , char* pszCaption , int Zero , const char* pszMsgbox , int Event )
		{ }
		void  InitGameUIItem ( char*pszGameUIItem , char* pszItemNumber )
		{ }
		void  LoadGameUIImg ( char*pszUIName , char* pszImg )
		{ }
		void  GameUIShow ( char* pszGameUIShow )
		{ }
		void  ShowPlayerCheat ( int a , int b , int c )
		{ }
		void  UnKnowC ( int a , int b )
		{ }
		void  UnLoadEx ( int a )
		{ }

        //
     public:
         void GameDebugPrintf ( const LPSTR lpszFmt , ... )
        {
            char szOutPutText [ 4096 ];
            va_list args;
            va_start ( args , lpszFmt );
            wvsprintf ( szOutPutText , lpszFmt , args );
            va_end ( args );
            DebugPrintf ( ( const LPSTR ) szOutPutText );
        }
    private:
        void DebugPrintf ( const LPSTR szOutPutText )
        {
            char* pszRoomType = GetUIRoom ( );
            if ( pszRoomType  == nullptr )
            {
                return;
            }
            if ( lstrcmp ( pszRoomType , "selSect" ) == 0 ||
                lstrcmp ( pszRoomType , "shop" ) == 0 ||
                lstrcmp ( pszRoomType , "web" ) == 0 ||
                lstrcmp ( pszRoomType , "login" ) == 0 )
            {
                GameMsgBox (
                    ( char* ) szOutPutText , pszRoomType ,
                    NULL , UI_SysMsgbox , NULL );
                return;
            }
            if ( lstrcmp ( pszRoomType , "selRoom" ) == 0 )
            {
                GameSay ( UI_selRoom_chatArea_chatPanel_chatList , ( char* ) szOutPutText , 0xCF , 0x0 , 0xFF , 0xFF );
                return;
            }
            if ( lstrcmp ( pszRoomType , "room" ) == 0 )
            {
                GameSay ( UI_room_chatArea_chatPanel_chatList , ( char* ) szOutPutText , 0xCF , 0x0 , 0xFF , 0xFF );
                return;
            }
            if ( lstrcmp ( pszRoomType , "game" ) == 0 )
            {
                GameSay ( UI_game_chatList , ( char* ) szOutPutText , 0xCF , 0x0 , 0xFF , 0xFF );
                return;
            }

        }

	};

}



```

`QQTang CheatEngine/MapElem.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "GameBox.hpp"
#include "GameFloor.hpp"


namespace QQTangCheatEngine
{
	class CGameInfo;


}

```

`QQTang CheatEngine/Maple.hpp`:

```hpp
/************************************************************************/
/*
功能说明:预编译头文件
创建人:Maple
创建日期:2014年9月1日
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)


#include <WinSDKVer.h>
//最低平台XP
#define _WIN32_WINNT _WIN32_WINNT_WINXP 
#include <SDKDDKVer.h>
//取消不常用的头文件
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <cstdio>
#include <cstring>
#include <vector>
#include <string>
#include <set>
#include <cassert>
using namespace std;

#include "QQTangEnum.hpp"
#include "EncodeMember.hpp"
#define PItemBySet CItemBySet*
//C# var - - C++ 11
#define var auto

namespace QQTangCheatEngine
{	
	//接口
	__interface IBaseClass
	{
		void* InitBase ( bool Destroy );
	};

	class CLocation
	{
		private:
		short m_y;
		short m_x;
		public:
		CLocation ( ) { }
		CLocation (INT16 x, INT16 y )
		{
			m_y = y;
			m_x = x;
		}
		short GetX ( )const
		{
			return m_x;
		}
		short GetY ( ) const
		{
			return m_y;
		}
		short GetPlayerX ()const
		{ 
			INT16 x = m_x * 4 + m_x;
			return x * 8 + 20;
		}
		short GetPlayerY ( )const
		{
			INT16 y = m_y * 4 + m_y;
			return y * 8 + 20;
		}
		void SetX ( INT16 x )
		{
			m_x = x;
		}
		void SetY ( INT16 y )
		{
			m_y = y;
		}
		CLocation& operator = ( CLocation& Location )
		{
			m_x = Location.GetX ( );
			m_y = Location.GetY ( );
			return *this;
		}
		 

	}; 

	template<class X>
	class CMapX
	{
		public:
		union 
		{
			X m_ID;
			X m_pInfo;
		};


	};
 
	template<class Y>
	class CMapY
	{
		public:
		CMapX<Y>*  m_MapX;
	};
 
 
	template<class T>
	class CVector
	{
		private:
		//好像从2012 vector size 优化变小了
#if _MSC_VER > 1600 
		INT32 m_value;
#endif
		vector<T> m_vecInfo;
		public:
		vector<T>* GetVecInfo ( )
		{
			return &m_vecInfo;
		}
	};
	enum 
	{
		CVectorSize = sizeof ( CVector <INT32>),
	};

	class CIpAddress
	{
		private:
		union 
		{
			UINT32 m_IP;
			struct 
			{
				UINT8 m_a;
				UINT8 m_b;
				UINT8 m_c;
				UINT8 m_d;
			};
		};
		public:
		UINT32 GetIP ( )const
		{
			return m_IP;
		}
		INT32 GetIP ( _Inout_ char* szIP )
		{
			return wsprintf ( szIP, "%d.%d.%d.%d", m_a, m_b, m_c, m_d );
		}
	};

	//注意 这里他是加密的
	class CItemBySet
	{
		private:
		CEncodeMember m_ItemID;
		CEncodeMember m_ItemSize;
		//eq -1?
		CEncodeMember m_ConstFF;
		public:
		CEncodeMember& GetItemID ( )
		{
			return m_ItemID;
		}
		CEncodeMember& GetItemSize ( )
		{
			return m_ItemSize;
		}

	};

	//注意 这里他妈不加密了 换码农了就这样
	class CItemByDrop
	{
		private:
		ItemByGame m_ItemID;
		union
		{
			INT32 m_ItemSizeInfo;
			struct
			{
				INT16 m_ItemSize;
				INT16 m_Alignment;
			};
		};
		public:

		ItemByGame GetItemID ( )
		{
			return m_ItemID;
		}
		INT16  GetItemSize ( )
		{
			return m_ItemSize;
		}

        BOOL IsPropToServer ( )
        {
            switch ( m_ItemID )
            {
                //81
                case QQTangCheatEngine::GAME_TONGBI:
                {
                    return TRUE;
                }
                //82
                case QQTangCheatEngine::GAME_YINBI:
                {
                    return TRUE;
                }
                //83
                case QQTangCheatEngine::GAME_JINBI:
                {
                    return TRUE;
                }
                //84
                case QQTangCheatEngine::GAME_QIANDAI:
                {
                    return TRUE;
                }
                //85
                case QQTangCheatEngine::GAME_BAOXIANG1000TB:
                {
                    return TRUE;
                }
                //91
                case QQTangCheatEngine::GAME_HONGZUANSHI:
                {
                    return TRUE;
                }
                //92
                case QQTangCheatEngine::GAME_LANZUANSHI:
                {
                    return TRUE;
                }
                //211
                case QQTangCheatEngine::GAME_ZIZUANSHI:
                {
                    return TRUE;
                }
                //212
                case QQTangCheatEngine::GAME_XUEPINGZI:
                {
                    return TRUE;
                }
                //213
                case QQTangCheatEngine::GAME_HUANGLUOSI:
                {
                    return TRUE;
                }
                //93
                case QQTangCheatEngine::GAME_TANGBI1000:
                {
                    return TRUE;
                }
                //94
                case QQTangCheatEngine::GAME_TANGBI500:
                {
                    return TRUE;
                }
                //86
                case QQTangCheatEngine::GAME_JINGYAN20:
                {
                    return TRUE;
                }
                //87
                case QQTangCheatEngine::GAME_JINGYAN50:
                {
                    return TRUE;
                }
                //88
                case QQTangCheatEngine::GAME_JINGYAN100:
                {
                    return TRUE;
                }
                //89
                case QQTangCheatEngine::GAME_JINGYAN200:
                {
                    return TRUE;
                }
                //96
                case QQTangCheatEngine::GAME_MEIGUI1:
                {
                    return TRUE;
                }
                //97
                case QQTangCheatEngine::GAME_LVSHUIJING:
                {
                    return TRUE;
                }
                //98
                case QQTangCheatEngine::GAME_KUBI:
                {
                    return TRUE;
                }
                //150
                case QQTangCheatEngine::GAME_HONGBAOSHI:
                {
                    return TRUE;
                }
                //151
                case QQTangCheatEngine::GAME_HUANGBAOSHI:
                {
                    return TRUE;
                }
                //152
                case QQTangCheatEngine::GAME_LVBAOSHI:
                {
                    return TRUE;
                }
                //402
                case QQTangCheatEngine::GAME_MEIGUI2:
                {
                    return TRUE;
                }
                //403
                case QQTangCheatEngine::GAME_DIARY:
                {
                    return TRUE;
                }
            }

            if ( ( m_ItemID < 400 || m_ItemID > 1000 ) &&
                ( m_ItemID <= 24000 || m_ItemID >= 24500 ) &&
                ( m_ItemID <= 30000 || m_ItemID >= 32000 ) &&
                ( m_ItemID < 25001 || m_ItemID > 29000 ) &&
                ( m_ItemID < 9001 || m_ItemID > 9010 ) )
            {
                return FALSE;
            }
            return TRUE;
        }


	};

    BOOL IsPropToServer (ItemByGame PropID )
    {
        switch ( PropID )
        {
            //81
            case QQTangCheatEngine::GAME_TONGBI:
            {
                return TRUE;
            }
            //82
            case QQTangCheatEngine::GAME_YINBI:
            {
                return TRUE;
            }
            //83
            case QQTangCheatEngine::GAME_JINBI:
            {
                return TRUE;
            }
            //84
            case QQTangCheatEngine::GAME_QIANDAI:
            {
                return TRUE;
            }
            //85
            case QQTangCheatEngine::GAME_BAOXIANG1000TB:
            {
                return TRUE;
            }
            //91
            case QQTangCheatEngine::GAME_HONGZUANSHI:
            {
                return TRUE;
            }
            //92
            case QQTangCheatEngine::GAME_LANZUANSHI:
            {
                return TRUE;
            }
            //211
            case QQTangCheatEngine::GAME_ZIZUANSHI:
            {
                return TRUE;
            }
            //212
            case QQTangCheatEngine::GAME_XUEPINGZI:
            {
                return TRUE;
            }
            //213
            case QQTangCheatEngine::GAME_HUANGLUOSI:
            {
                return TRUE;
            }
            //93
            case QQTangCheatEngine::GAME_TANGBI1000:
            {
                return TRUE;
            }
            //94
            case QQTangCheatEngine::GAME_TANGBI500:
            {
                return TRUE;
            }
            //86
            case QQTangCheatEngine::GAME_JINGYAN20:
            {
                return TRUE;
            }
            //87
            case QQTangCheatEngine::GAME_JINGYAN50:
            {
                return TRUE;
            }
            //88
            case QQTangCheatEngine::GAME_JINGYAN100:
            {
                return TRUE;
            }
            //89
            case QQTangCheatEngine::GAME_JINGYAN200:
            {
                return TRUE;
            }
            //96
            case QQTangCheatEngine::GAME_MEIGUI1:
            {
                return TRUE;
            }
            //97
            case QQTangCheatEngine::GAME_LVSHUIJING:
            {
                return TRUE;
            }
            //98
            case QQTangCheatEngine::GAME_KUBI:
            {
                return TRUE;
            }
            //150
            case QQTangCheatEngine::GAME_HONGBAOSHI:
            {
                return TRUE;
            }
            //151
            case QQTangCheatEngine::GAME_HUANGBAOSHI:
            {
                return TRUE;
            }
            //152
            case QQTangCheatEngine::GAME_LVBAOSHI:
            {
                return TRUE;
            }
            //402
            case QQTangCheatEngine::GAME_MEIGUI2:
            {
                return TRUE;
            }
            //403
            case QQTangCheatEngine::GAME_DIARY:
            {
                return TRUE;
            }
        }

        if ( ( PropID < 400 || PropID > 1000 ) &&
            ( PropID <= 24000 || PropID >= 24500 ) &&
            ( PropID <= 30000 || PropID >= 32000 ) &&
            ( PropID < 25001 || PropID > 29000 ) &&
            ( PropID < 9001 || PropID > 9010 ) )
        {
            return FALSE;
        }
        return TRUE;
    }

}
```

`QQTang CheatEngine/MessageLayer.hpp`:

```hpp
/************************************************************************/
/* 
功能说明:消息层 通信
创建人:maple
创建日期:2014年9月3日
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "QQTangClient.hpp"
#include "GameManager.hpp"
#include "QQTEncoder.hpp"
#include "QQTSection.hpp"
#define PMessageLayer CMessageLayer*

namespace QQTangCheatEngine
{
	class CToServerPackage
	{
		//size 3072
		public:
		GameID m_GameID;
		UINT8 m_byBuffer [ 0xBFC ];
		CToServerPackage ( _In_ GameID gameid )
		{
			m_GameID = gameid;
		}
	};

	class CMsg4Base
	{
		public:
		virtual void InitBaseA ( INT32 value ) = 0;
		virtual void InitBaseB ( INT32 value1, INT32 value2 ) = 0;
	};
 
	class CMessageLayerBase
	{
		public:

		virtual void InitFun1 ( LPVOID lpValue ) = 0;
		virtual void InitFun2 ( INT16 value1, INT16 value2 ) = 0;
		virtual void NotifyGameBegin ( LPVOID lpMsg ) = 0;
		virtual void GetDataFromServer ( DWORD dwMsgLength, LPVOID lpMsg ) = 0;
		virtual void GetDataFromPlayer ( DWORD dwMsgLength, LPVOID lpMsg ) = 0;
		virtual void InitFun3 ( INT32 value1, INT32 value2, INT32 vlaue3 ) = 0;
		virtual void UpdateUI ( ) = 0;
		virtual void AboutGame ( INT32 value1, INT32 value2 ) = 0;
		virtual void LoadMap ( MapID ID, INT32 value ) = 0;
		virtual void InitFun4 ( LPVOID lpValue ) = 0;
		virtual void InitMessageLayer ( bool value ) = 0;
		virtual void UpdateUIEx ( INT32 value ) = 0;
	};

	class CMessageLayer : public CMessageLayerBase
	{
		private:
		class CMsg4 : public CMsg4Base
		{
			private:
			UINT8 m_0x8 [ 0x5C0 ];

			public:
			void InitBaseA ( INT32 value )
			{
				return;
			}
			void InitBaseB ( INT32 value1, INT32 value2 )
			{
				return;
			}

		}m_Msg4;
		class CMsg5C8 :public IBaseClass
		{
			private:
			UINT8 m_0x5CC [ 0x17C ];
			//0x748
			INT32 m_TimeCount;
			public:
			void* InitBase ( bool Destroy ) { }
			INT32 GetTimeCount ( ) const
			{
				return m_TimeCount;
			}


		}m_Msg5C8;
		class CGameLayer :public IBaseClass
		{
			private:
			UINT8 m_0x750 [ 0x7C ];
			//0x7CC
			PQQTEncoder m_pQQTEncoder;
			//0x7D0
			PQQTSection m_pQQTSection;
			//0X7D4
			PGameManager m_pGameManager;

			INT32 m_0x7D8;

			public:
			void* InitBase ( bool Destroy ) { }

			PGameManager GetGameManager ( )
			{
				return m_pGameManager;
			}
			PQQTEncoder GetQQTEncoder ( )
			{
				return m_pQQTEncoder;
			}
			PQQTSection GetQQTSection ( )
			{
				return m_pQQTSection;
			}
		}m_GameLayer;
		class CMsg7DC :public IBaseClass
		{
			private:
			UINT8 m_7E0 [ 0x408 ];
			public:
			void* InitBase ( bool Destroy ) { }
		}m_Msg7DC [ 17 ];

		public:
		//继承
		void InitFun1 ( LPVOID lpValue ){}
		void InitFun2 ( INT16 value1, INT16 value2 ){}
		void NotifyGameBegin ( LPVOID lpMsg ){}
		void GetDataFromServer ( DWORD dwMsgLength, LPVOID lpMsg ){}
		void GetDataFromPlayer ( DWORD dwMsgLength, LPVOID lpMsg ){}
		void InitFun3 ( INT32 value1, INT32 value2, INT32 vlaue3 ){}
		void UpdateUI ( ){}
		void AboutGame ( INT32 value1, INT32 value2 ){}
		void LoadMap ( MapID ID, INT32 value ){}
		void InitFun4 ( LPVOID lpValue ){}
		void InitMessageLayer ( bool value ){}
		void UpdateUIEx ( INT32 value ){}

		//静态
		static PMessageLayer GetMessageLayer ( )
		{
			return ( PMessageLayer ) g_QQTangClient.m_MessageLayer;
		}

		PGameManager GetGameManager ( )
		{
			return m_GameLayer.GetGameManager ( );
		}

		template<typename T>
		void SetDataToServer ( _In_ GameID gameid, _In_ T& Package )
		{
			typedef void ( __thiscall *pSetDataToServer ) ( _In_ PMessageLayer ThisClass, _In_ GameID gameid, _In_ T& Package );
			pSetDataToServer pToServer = ( pSetDataToServer ) ( g_QQTangClient.m_DataToServer );
			pToServer ( this, gameid, Package );
		}

		 
		void SetDataToServerEx ( _In_ volatile GameID gameid, _In_ volatile LPVOID Package )
		{
			if ( NULL == this->m_GameLayer.GetQQTSection ( ) )
			{
				return;
			}

			CToServerPackage ToServerPackage ( gameid );

			DWORD dwPackageSize = 0;

			this->m_GameLayer.GetQQTEncoder ( )->EnCoder (
				this->m_GameLayer.GetQQTEncoder ( ),
				gameid, ToServerPackage.m_byBuffer,
				&dwPackageSize, Package, TRUE );

			this->m_GameLayer.GetQQTSection ( )->SendDataToServer ( dwPackageSize + 4, &ToServerPackage );
		}

		template<typename T>
		void SetDataToClient (_In_ GameID gameid,_In_ T& Package )
		{
			typedef void ( __thiscall * pSetDataToClient )( _In_ PMessageLayer ThisClass, _In_ GameID gameid, _In_ T& Package );
			pSetDataToClient pToPlayer = ( pSetDataToClient ) ( g_QQTangClient.m_DataToClient );
			pToPlayer ( this, gameid, Package );
		}

		UINT32 GetTimeSub ( )
		{
			typedef UINT32 ( __thiscall *pGetTimeSub )( CMsg5C8* ThisClass );
			pGetTimeSub  pGet = ( pGetTimeSub ) ( g_QQTangClient.m_GetTimeSub );
			return pGet ( &this->m_Msg5C8 );
		}

	};
	enum
	{
		//19624
		CMessageLayerSize = sizeof ( CMessageLayer )
	};
}

```

`QQTang CheatEngine/NPC.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "NPCItem.hpp"
#include "GameItem.hpp"
#define PNPC CNPC*

namespace QQTangCheatEngine
{
	class CGameInfo;
	class CNPC;

	__interface IBasicBase
	{
		void* InitBaseA ( bool Destroy );
		void* InitBaseB ( );
		void* InitBaseC ( );
		void* ShowA ( );
		void* ShowB ( );
		bool IsInvincible ( );

	};
	__interface IInfoBase
	{
		void InitBaseA ( );
		void InitBaseB ( );

	};
	__interface INPCBase
	{
		void* InitBaseA ( bool Destroy );

	};

	class CNPC :public IBasicBase
	{
		private:
		CItemInfo m_ItemInfo;

		class CBasic :public IBasicBase
		{
			private:
			INT32 m_31C;
			INT32 m_320;
			CGameInfo* m_pGameInfo;
			INT16 m_IDFromClinet;
			INT16 m_IDFromServer;
			PNPC m_pNPC;
			BOOL m_Invincible;
			INT32 m_InvincibleTime;
			float m_NPCX;
			float m_NPCY;
			INT32 m_340;
			INT32 m_344;
			INT32 m_348;

			public:
			CGameInfo* GetGameInfo ( )
			{
				return m_pGameInfo;
			}
			INT16 GetIDFromClinet ( )
			{
				return m_IDFromClinet;
			}
			INT16 GetIDFromServer ( )
			{
				return m_IDFromServer;
			}
			PNPC GetNPC ( )
			{
				return m_pNPC;
			}
			BOOL GetInvincible ( )
			{
				return m_Invincible;
			}
			INT32 GetInvincibleTime ( )
			{
				return m_InvincibleTime;
			}
			float GetNPCX ( )
			{
				return m_NPCX;
			}
			float GetNPCY ( )
			{
				return m_NPCY;
			}

			void* InitBaseA ( bool Destroy )
			{ }
			void* InitBaseB ( )
			{ }
			void* InitBaseC ( )
			{ }
			void* ShowA ( )
			{ }
			void* ShowB ( )
			{ }
			bool IsInvincible ( )
			{ }
		}m_Basic;

		class CInfo :public IInfoBase
		{
			private:
			INT32 m_350;
			INT32 m_X;
			INT32 m_Y;
			INT32 m_35C;
			INT32 m_360;
			INT32 m_364;
			INT32 m_368;
			LPVOID m_36C;
			//CONST 2
			INT32 m_370;
			INT32 m_374;
			INT32 m_378;
			UINT32 m_PlayerQQ;
			char m_PlayerName [ 0x14 ];
			//PlayerModle
			UINT8 m_PlayerModle;
			//TeamColor
			UINT8 m_PlayerTeamColor;
			INT16 m_396;
			INT32 m_398;
			INT32 m_39C;
			INT32 m_3A0;
			INT32 m_3A4;
			INT32 m_PlayerX;
			INT32 m_PlayerY;
			INT32 m_3B0;
			UINT8 m_PlayerFaceA;
			UINT8 m_PlayerFaceB;
			UINT8 m_PlayerFaceC;
			UINT8 m_PlayerStatus;
			UINT8 m_PlayerMoving;
			INT8 m_3B9;
			INT8 m_3BA;
			INT8 m_3BB;
			INT32 m_3BCH;
			INT32 m_3C0;
			INT32 m_3C4;
			INT32 m_3C8;
			INT32 m_3CC;
			INT32 m_3D0;
			INT32 m_3D4;
			INT32 m_3D8;
			INT32 m_3DC;
			INT32 m_3E0;
			INT32 m_3E4;
			INT32 m_3E8;
			CVector<CGameItem>m_vecGameItem;

			public:
			CVector<CGameItem>* GetGameItem ( )
			{
				return &m_vecGameItem;
			}

			bool IsItemUsing ( )
			{
				vector<CGameItem>* vecItem = m_vecGameItem.GetVecInfo ( );
				vector<CGameItem>::iterator it;
				for ( it = vecItem->begin ( ); it != vecItem->end ( ); it++ )
				{
					return ( *it ).IsUsing ( );
				}
			}

			INT32 GetX ( )
			{
				return m_X;
			}
			INT32 GetY ( )
			{
				return m_Y;
			}
			UINT32 GetPlayerQQ ( )
			{
				return m_PlayerQQ;
			}
			char* GetPlayerName ( )
			{
				return m_PlayerName;
			}
			UINT8 GetPlayerModle ( )
			{
				return m_PlayerModle;
			}
			UINT8 GetPlayerTeamColor ( )
			{
				return m_PlayerTeamColor;
			}
			INT32 GetPlayerX ( )
			{
				return m_PlayerX;
			}
			INT32 GetPlayerY ( )
			{
				return m_PlayerY;
			}
			UINT8 GetPlayerStatus ( )
			{
				return m_PlayerStatus;
			}

			UINT8 GetPlayerMoving ( )
			{
				return m_PlayerMoving;
			}
			UINT8 GetPlayerFace ( )
			{
				return m_PlayerFaceA;
			}

			void InitBaseA ( )
			{ }
			void InitBaseB ( )
			{ }

		}m_INFO;

		CGameInfo* m_pGameInfo;
		PNPCItem m_pNPCItem;
		LPVOID m_pAvatarInfo;
		INT32 m_408;
		LPVOID m_40C;
		INT32 m_410;
		INT32 m_414;
		INT32 m_418;
		LPVOID m_41C;
		LPVOID m_420;
		BOOL m_XBomb;
		INT32 m_428;
		INT32 m_42C;
		INT32 m_430;
		INT32 m_434;
		INT32 m_438;
		INT32 m_43C;
		INT32 m_440;
		INT32 m_444;
		INT32 m_448;
		INT32 m_44C;
		INT32 m_450;
		INT32 m_454;
		INT32 m_458;
		INT32 m_45C;
		INT32 m_460;
		INT32 m_464;
		INT32 m_468;
		INT32 m_46C;
		INT16 m_ReLiveY;
		INT16 m_ReLiveX;
		INT32 m_474;
		INT32 m_478;
		INT32 m_47C;
		INT32 m_480;
		INT32 m_484;
		INT32 m_488;
		INT32 m_48C;
		INT8 m_bytes [ 0x200 ];

		INT32 m_WUGUI;
		INT32 m_694;
		INT32 m_698;
		INT32 m_69C;

		INT32 m_6A0;
		INT32 m_6A4;
		INT32 m_6A8;
		INT32 m_6AC;

		INT32 m_6B0;
		INT32 m_6B4;
		INT32 m_6B8;
		INT32 m_6BC;

		//机械技能时间
		INT32 m_MachineSkillCD;
		BOOL m_CanMachineSkill;
		BOOL m_ReversalControl;
		BOOL m_ThroughMapItem;

		BOOL m_DetectPower;
		BOOL m_CanGetItem;
		INT32 m_6D8;
		INT32 m_6DC;

		INT32 m_6E0;
		INT32 m_6E4;
		INT32 m_6E8;
		INT32 m_6EC;

		INT32 m_6F0;
		INT32 m_6F4;
		INT32 m_6F8;
		INT32 m_6FC;

		INT32 m_700;
		INT32 m_704;
		INT32 m_708;
		INT32 m_70C;

		INT32 m_710;
		INT32 m_714;
		INT32 m_718;
		INT32 m_71C;

		INT32 m_720;
		INT32 m_724;
		INT32 m_728;
		INT32 m_72C;

		INT32 m_730;
		INT32 m_734;
		INT32 m_738;
		INT32 m_73C;

		INT32 m_740;
		INT32 m_744;
		INT32 m_748;
		INT32 m_74C;

		INT32 m_750;
		union
		{
			BOOL m_PVEInvincible;
			struct
			{
				INT16 m_754;
				INT16 m_756;

			};
		};
		INT32 m_PVEInvincibleTime;
		INT32 m_75C;
		// 		union
		// 		{
		// 			struct 
		// 			{
		// 				
		INT32 m_LayoutBombSpeed;
		INT32 m_764;
		INT32 m_768;
		// 			};
		//cl不给力啊

		//vector<LPVOID> m_vecInfo;
		// 		};

		//maple 2014-09-27 22:08:53
		//0x76C
		class CNewBossInfo
		{

			CVector<LPVOID>m_0x76C;
			INT32 m_0x77C;

			INT32 m_0x780;
			INT32 m_0x784;
			INT32 m_0x788;
			INT32 m_0x78C;

			INT32 m_0x790;
			INT32 m_0x794;
			INT32 m_0x798;
			INT32 m_0x79C;


			INT32 m_0x7A0;
			INT32 m_0x7A4;
			INT32 m_0x7A8;
			INT32 m_0x7AC;

			INT32 m_0x7B0;
			INT32 m_0x7B4;
			CVector<LPVOID>m_0x7B8;

			INT32 m_0x7C8;
			CLocation m_LiveXY;

			INT32 m_0x7D0;
			INT32 m_0x7D4;
			INT32 m_Fuvk;
			INT32 m_0x7DC;

			INT32 m_0x7E0;
			INT32 m_0x7E4;
			INT32 m_0x7E8;
			INT32 m_0x7EC;

			INT32 m_0x7F0;
			INT32 m_0x7F4;
			INT32 m_0x7F8;
			INT32 m_0x7FC;

			INT32 m_0x800;
			INT32 m_0x804;
			INT32 m_0x808;
			INT32 m_0x80C;

			INT32 m_0x810;
			INT32 m_0x814;
			INT32 m_0x818;
			INT32 m_0x81C;

			INT32 m_0x820;
			INT32 m_0x824;
			INT32 m_0x828;
			INT32 m_0x82C;

			INT32 m_0x830;
			INT32 m_0x834;
			INT32 m_0x838;
			INT32 m_0x83C;

			INT32 m_0x840;
			INT32 m_0x844;
			INT32 m_0x848;
			INT32 m_0x84C;

			INT32 m_0x850;
			INT32 m_0x854;
			INT32 m_0x858;
			INT32 m_0x85C;


			INT32 m_0x860;
			INT32 m_0x864;
			INT32 m_0x868;
			INT32 m_0x86C;

			INT32 m_0x870;
			INT32 m_0x874;
			INT32 m_0x878;
			INT32 m_0x87C;

			INT32 m_0x880;
			INT32 m_0x884;
			INT32 m_0x888;
			INT32 m_0x88C;

			INT32 m_0x890;
			INT32 m_0x894;
			INT32 m_0x898;
			INT32 m_0x89C;

			INT32 m_0x8A0;
			INT32 m_0x8A4;
			INT32 m_0x8A8;
			INT32 m_0x8AC;

			INT32 m_0x8B0;
			INT32 m_0x8B4;
			INT32 m_0x8B8;
			INT32 m_0x8BC;

			INT32 m_0x8C0;
			INT32 m_0x8C4;
			INT32 m_0x8C8;
			INT32 m_0x8CC;

			INT32 m_0x8D0;
			INT32 m_0x8D4;
			INT32 m_0x8D8;
			INT32 m_0x8DC;


			INT32 m_0x8E0;
			INT32 m_0x8E4;
			INT32 m_0x8E8;
			INT32 m_0x8EC;

			INT32 m_0x8F0;
			INT32 m_0x8F4;
			INT32 m_0x8F8;
			INT32 m_0x8FC;

			INT32 m_0x900;
			INT32 m_0x904;
			INT32 m_0x908;
			INT32 m_0x90C;

			INT32 m_0x910;
			INT32 m_0x914;
			INT32 m_0x918;
			INT32 m_0x91C;

			INT32 m_0x920;
			INT32 m_0x924;
			INT32 m_0x928;
			INT32 m_0x92C;

			INT32 m_0x930;
			INT32 m_0x934;
			INT32 m_0x938;
			INT32 m_0x93C;

			INT32 m_0x940;
			INT32 m_0x944;







		}m_NewBossInfo;


		public:
		CItemInfo* GetItemInfo ( )
		{
			return &m_ItemInfo;
		}
		CBasic* GetBasic ( )
		{
			return &m_Basic;
		}
		CInfo* GetINFO ( )
		{
			return &m_INFO;
		}
		CGameInfo* GetGameInfo ( )
		{
			return this->m_pGameInfo;
		}
		PNPCItem  GetNPCItem ( )
		{
			return this->m_pNPCItem;
		}
		LPVOID GetAvatarInfo ( )
		{
			return this->m_pAvatarInfo;
		}
		BOOL  GetXBomb ( )
		{
			return this->m_XBomb;
		}
		INT16 GetReLiveY ( )
		{
			return this->m_ReLiveY;
		}
		INT16 GetReLiveX ( )
		{
			return this->m_ReLiveX;
		}
		INT32 GetWUGUI ( )
		{
			return this->m_WUGUI;
		}
		BOOL  GetReversalControl ( )
		{
			return this->m_ReversalControl;
		}
		BOOL  GetThroughMapItem ( )
		{
			return this->m_ThroughMapItem;
		}
		INT32 GetMachineSkillCD ( )
		{
			return m_MachineSkillCD;
		}
		BOOL GetCanMachineSkill ( )
		{
			return m_CanMachineSkill;
		}

		BOOL  GetDetectPower ( )
		{
			return this->m_DetectPower;
		}
		BOOL  GetCanGetItem ( )
		{
			return this->m_CanGetItem;
		}
		BOOL  GetPVEInvincible ( )
		{
			return this->m_PVEInvincible;
		}
		INT32 GetPVEInvincibleTime ( )
		{
			return this->m_PVEInvincibleTime;
		}
		INT32 GetLayoutBombSpeed ( )
		{
			return this->m_LayoutBombSpeed;
		}

		INT16 GetIDFromClinet ( )
		{
			return m_Basic.GetIDFromClinet ( );
		}
		INT16 GetIDFromServer ( )
		{
			return m_Basic.GetIDFromServer ( );
		}
		PNPC GetNPC ( )
		{
			return m_Basic.GetNPC ( );
		}
		BOOL GetInvincible ( )
		{
			return m_Basic.GetInvincible ( );
		}
		INT32 GetInvincibleTime ( )
		{
			return m_Basic.GetInvincibleTime ( );
		}
		float GetNPCX ( )
		{
			return m_Basic.GetNPCX ( );
		}

		float GetNPCY ( )
		{
			return m_Basic.GetNPCY ( );
		}

		bool IsInvincible ( )
		{
			return m_Basic.IsInvincible ( );
		}

		CVector<CGameItem>* GetGameItem ( )
		{
			return m_INFO.GetGameItem ( );
		}

		INT32 GetX ( )
		{
			return m_INFO.GetX ( );
		}
		INT32 GetY ( )
		{
			return m_INFO.GetY ( );
		}
		UINT32 GetPlayerQQ ( )
		{
			return m_INFO.GetPlayerQQ ( );
		}
		char* GetPlayerName ( )
		{
			return m_INFO.GetPlayerName ( );
		}
		UINT8 GetPlayerModle ( )
		{
			return m_INFO.GetPlayerModle ( );
		}
		UINT8 GetPlayerTeamColor ( )
		{
			return m_INFO.GetPlayerTeamColor ( );
		}
		INT32 GetPlayerX ( )
		{
			return m_INFO.GetPlayerX ( );
		}
		INT32 GetPlayerY ( )
		{
			return m_INFO.GetPlayerY ( );
		}
		UINT8 GetPlayerFace ( )
		{
			return m_INFO.GetPlayerFace ( );
		}

		UINT8 GetPlayerStatus ( )
		{
			return m_INFO.GetPlayerStatus ( );
		}

		UINT8 GetPlayerMoving ( )
		{
			return m_INFO.GetPlayerMoving ( );
		}

		INT16 GetPlayerInMapX ( )
		{
			return ( ( INT16 ) ( this->GetNPCX ( ) ) / 40 );
		}

		INT16 GetPlayerInMapY ( )
		{
			return ( ( INT16 ) ( this->GetNPCY ( ) ) / 40 );
		}

		bool IsItemUsing ( )
		{
			return m_INFO.IsItemUsing ( );
		}

	};

	enum
	{
		CNPCSize = sizeof ( CNPC ) ,
	};
	static_assert( CNPCSize == 0x948 , "CNPCSize is error" );
}



```

`QQTang CheatEngine/NPCItem.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#define PNPCItem CNPCItem*

namespace QQTangCheatEngine
{
	class CNPC;
	__interface I19CBase
	{
		public:
		void* InitBaseA ( bool Destroy );
		void* InitBaseB ( bool Destroy );
		void* InitBaseC ( bool Destroy );
		void* InitBaseD ( DWORD value );
		void* InitBaseE ( DWORD value );

	};
	__interface IItemInfoBase
	{
		public:
		void* InitBase ( bool Destroy );
		void InitBase ( );
		INT32 GetItem2B4 ( );
		INT32 SetHp ( INT32 value );
		void AddHp ( INT32 value );
		bool GetAvatar ( );
		void AddLayoutBomb ( INT16 value );
		INT32 GetBombPower ( );
		INT32 FunZeroB ( );
		INT32 FunZeroC ( INT32 value );
		void CalcBombSize ( );
	};

	class CItemInfo
	{
		private:
		CEncodeMember m_MinBomb;
		CEncodeMember m_MaxBomb;

		CEncodeMember m_MinPower;
		CEncodeMember m_MaxPower;

		CEncodeMember m_MinSpeed;
		CEncodeMember m_MaxSpeed;

		CEncodeMember m_PVESpeed;
		CEncodeMember m_PVEBomb;
		CEncodeMember m_PVEPower;

		// 不知道是什么
		CEncodeMember m_PVEITEMA;
		CEncodeMember m_PVEITEMB;

		CEncodeMember m_HP;

		CEncodeMember m_IsInvincible;

		INT32 m_108;

		CEncodeMember m_10C;

		INT32 m_120;

		CEncodeMember m_GetBomb;
		CEncodeMember m_GetPower;
		CEncodeMember m_GetSpeed;
		CEncodeMember m_AddBomb;
		CEncodeMember m_AddPower;
		CEncodeMember m_AddSpeed;

		class C19C :public I19CBase
		{
			private:
			INT32 m_200;
			CVector < CItemBySet > m_vecItemBySet;
			INT32 m_210;

			public:
			CVector<CItemBySet> *GetItemBySet ( )
			{
				return &m_vecItemBySet;
			}


			void* InitBaseA ( bool Destroy )
			{ }
			void* InitBaseB ( bool Destroy )
			{ }
			void* InitBaseC ( bool Destroy )
			{ }
			void* InitBaseD ( DWORD value )
			{ }
			void* InitBaseE ( DWORD value )
			{ }
		}m_19C;

		class C1B8 :public C19C
		{
			private:
			INT32 m_1C;
			CVector < LPVOID > m_vec20;
			CVector < LPVOID > m_vec30;

		}m_1B8;

		CEncodeMember m_KillSize;
		CEncodeMember m_DieSize;
		//连杀次数...double kill ^ ^
		CEncodeMember m_DoubleKillSize;
		CEncodeMember m_RedTreasure;
		CEncodeMember m_YellowTreasure;
		CEncodeMember m_GreenTreasure;
		INT32 m_BombType;
		INT32 m_BombEffect;
		INT32 m_EffectColor;
		CEncodeINT16 m_LayoutBomb;

		//0x28C
		CEncodeMember m_BombZero;

		INT32 m_bytes2A0;
		INT32 m_bytes2A4;
		INT32 m_bytes2A8;
		INT32 m_bytes2AC;

		//2B0
		union
		{
			UINT8 m_BunType;
			UINT8 m_SculptureColor;
		};
		INT8 m_bytes2B1 [ 3 ];

		CEncodeMember m_2B4;

		// 		INT32 m_2C8;
		//DropItem
		CVector < CItemByDrop > m_vecFirstItemByDrop;

		// 		INT32 m_2D8;
		//DropItem
		CVector<CItemByDrop>m_vecNextItemByDrop;

		CNPC* m_pNPC;
		INT32 m_ShowPVELevel;
		INT32 m_PVEAttack;
		INT32 m_ShowMaxBombA;
		INT32 m_2F8;
		INT32 m_ShowMaxHp;
		INT32 m_ShowMaxBombB;
		CEncodeMember m_LayoutBombTime;

		public:

		CEncodeMember* GetMinBomb ( )
		{
			return &m_MinBomb;
		}
		CEncodeMember* GetMaxBomb ( )
		{
			return &m_MaxBomb;
		}

		CEncodeMember* GetMinPower ( )
		{
			return &m_MinPower;
		}
		CEncodeMember* GetMaxPower ( )
		{
			return &m_MaxPower;
		}

		CEncodeMember* GetMinSpeed ( )
		{
			return &m_MinSpeed;
		}
		CEncodeMember* GetMaxSpeed ( )
		{
			return &m_MaxSpeed;
		}

		CEncodeMember* GetPVESpeed ( )
		{
			return &m_PVESpeed;
		}
		CEncodeMember* GetPVEBomb ( )
		{
			return &m_PVEBomb;
		}
		CEncodeMember* GetPVEPower ( )
		{
			return &m_PVEPower;
		}

		CEncodeMember* GetHP ( )
		{
			return &m_HP;
		}

		CEncodeMember* GetIsInvincible ( )
		{
			return &m_IsInvincible;
		}

		CEncodeMember* GetGetBomb ( )
		{
			return &m_GetBomb;
		}
		CEncodeMember* GetGetPower ( )
		{
			return &m_GetPower;
		}
		CEncodeMember* GetGetSpeed ( )
		{
			return &m_GetSpeed;
		}
		CEncodeMember* GetAddBomb ( )
		{
			return &m_AddBomb;
		}
		CEncodeMember* GetAddPower ( )
		{
			return &m_AddPower;
		}
		CEncodeMember* GetAddSpeed ( )
		{
			return &m_AddSpeed;
		}

		CEncodeMember* GetKillSize ( )
		{
			return &m_KillSize;
		}
		CEncodeMember* GetDieSize ( )
		{
			return &m_DieSize;
		}
		//连杀次数...double kill ^ ^
		CEncodeMember* GetDoubleKillSize ( )
		{
			return &m_DoubleKillSize;
		}
		CEncodeMember* GetRedTreasure ( )
		{
			return &m_RedTreasure;
		}
		CEncodeMember* GetYellowTreasure ( )
		{
			return &m_YellowTreasure;
		}
		CEncodeMember* GetGreenTreasure ( )
		{
			return &m_GreenTreasure;
		}
		INT32 GetBombType ( )
		{
			return m_BombType;
		}
		INT32 GetBombEffect ( )
		{
			return m_BombEffect;
		}
		INT32 GetEffectColor ( )
		{
			return m_EffectColor;
		}
		CEncodeINT16* GetLayoutBomb ( )
		{
			return &m_LayoutBomb;
		}

		//0x28C
		CEncodeMember* GetBombZero ( )
		{
			return &m_BombZero;
		}

		//2B0

		UINT8 GetBunType ( )
		{
			return m_BunType;
		}
		UINT8 GetSculptureColor ( )
		{
			return m_SculptureColor;
		}



		//DropItem
		CVector < CItemByDrop > * GetvecFirstItemByDrop ( )
		{
			return &m_vecFirstItemByDrop;
		}

		// 		INT32 Get2D8;
		//DropItem
		CVector<CItemByDrop>* GetvecNextItemByDrop ( )
		{
			return &m_vecNextItemByDrop;
		}

		CNPC* GetpNPC ( )
		{
			return m_pNPC;
		}
		INT32 GetShowPVELevel ( )
		{
			return m_ShowPVELevel;
		}
		INT32 GetPVEAttack ( )
		{
			return m_PVEAttack;
		}
		INT32 GetShowMaxBombA ( )
		{
			return m_ShowMaxBombA;
		}
		INT32 GetShowMaxHp ( )
		{
			return m_ShowMaxHp;
		}
		INT32 GetShowMaxBombB ( )
		{
			return m_ShowMaxBombB;
		}
		CEncodeMember* GetLayoutBombTime ( )
		{
			return &m_LayoutBombTime;
		}


		void* InitBase ( bool Destroy )
		{ }
		void InitBase ( )
		{ }
		INT32 GetItem2B4 ( )
		{ }
		INT32 SetHp ( INT32 value )
		{ }
		void AddHp ( INT32 value )
		{ }
		bool GetAvatar ( )
		{ }
		void AddLayoutBomb ( INT16 value )
		{ }
		INT32 GetBombPower ( )
		{ }
		INT32 FunZeroB ( )
		{ }
		INT32 FunZeroC ( INT32 value )
		{ }
		void CalcBombSize ( )
		{ }


	};
	class CNPCItem :public IItemInfoBase
	{
		private:
		CItemInfo m_ItemInfo;
		public:
		CItemInfo* GetItemInfo ( )
		{
			return &m_ItemInfo;
		}

		CEncodeMember* GetMinBomb ( )
		{
			return m_ItemInfo.GetMinBomb ( );
		}
		CEncodeMember* GetMaxBomb ( )
		{
			return m_ItemInfo.GetMaxBomb ( );
		}

		CEncodeMember* GetMinPower ( )
		{
			return m_ItemInfo.GetMinPower ( );
		}
		CEncodeMember* GetMaxPower ( )
		{
			return m_ItemInfo.GetMaxPower ( );
		}

		CEncodeMember* GetMinSpeed ( )
		{
			return m_ItemInfo.GetMinSpeed ( );
		}
		CEncodeMember* GetMaxSpeed ( )
		{
			return m_ItemInfo.GetMaxSpeed ( );
		}

		CEncodeMember* GetPVESpeed ( )
		{
			return m_ItemInfo.GetPVESpeed ( );
		}
		CEncodeMember* GetPVEBomb ( )
		{
			return m_ItemInfo.GetPVEBomb ( );
		}
		CEncodeMember* GetPVEPower ( )
		{
			return m_ItemInfo.GetPVEPower ( );
		}

		CEncodeMember* GetHP ( )
		{
			return m_ItemInfo.GetHP ( );
		}

		CEncodeMember* GetIsInvincible ( )
		{
			return m_ItemInfo.GetIsInvincible ( );
		}

		CEncodeMember* GetGetBomb ( )
		{
			return m_ItemInfo.GetGetBomb ( );
		}
		CEncodeMember* GetGetPower ( )
		{
			return m_ItemInfo.GetGetPower ( );
		}
		CEncodeMember* GetGetSpeed ( )
		{
			return m_ItemInfo.GetGetSpeed ( );
		}
		CEncodeMember* GetAddBomb ( )
		{
			return m_ItemInfo.GetAddBomb ( );
		}
		CEncodeMember* GetAddPower ( )
		{
			return m_ItemInfo.GetAddPower ( );
		}
		CEncodeMember* GetAddSpeed ( )
		{
			return m_ItemInfo.GetAddSpeed ( );
		}

		CEncodeMember* GetKillSize ( )
		{
			return m_ItemInfo.GetKillSize ( );
		}
		CEncodeMember* GetDieSize ( )
		{
			return m_ItemInfo.GetDieSize ( );
		}
		//连杀次数...double kill ^ ^
		CEncodeMember* GetDoubleKillSize ( )
		{
			return m_ItemInfo.GetDoubleKillSize ( );
		}
		CEncodeMember* GetRedTreasure ( )
		{
			return m_ItemInfo.GetRedTreasure ( );
		}
		CEncodeMember* GetYellowTreasure ( )
		{
			return m_ItemInfo.GetYellowTreasure ( );
		}
		CEncodeMember* GetGreenTreasure ( )
		{
			return m_ItemInfo.GetGreenTreasure ( );
		}
		INT32 GetBombType ( )
		{
			return m_ItemInfo.GetBombType ( );
		}
		INT32 GetBombEffect ( )
		{
			return m_ItemInfo.GetBombEffect ( );
		}
		INT32 GetEffectColor ( )
		{
			return m_ItemInfo.GetEffectColor ( );
		}
		CEncodeINT16* GetLayoutBomb ( )
		{
			return m_ItemInfo.GetLayoutBomb ( );
		}

		//0x28C
		CEncodeMember* GetBombZero ( )
		{
			return m_ItemInfo.GetBombZero ( );
		}

		//2B0

		UINT8 GetBunType ( )
		{
			return m_ItemInfo.GetBunType ( );
		}
		UINT8 GetSculptureColor ( )
		{
			return m_ItemInfo.GetSculptureColor ( );
		}



		//DropItem
		CVector<CItemByDrop>* GetvecFirstItemByDrop ( )
		{
			return m_ItemInfo.GetvecFirstItemByDrop ( );
		}

		// 		INT32 Get2D8;
		//DropItem
		CVector<CItemByDrop>* GetvecNextItemByDrop ( )
		{
			return m_ItemInfo.GetvecNextItemByDrop ( );
		}

		CNPC* GetpNPC ( )
		{
			return m_ItemInfo.GetpNPC ( );
		}
		INT32 GetShowPVELevel ( )
		{
			return m_ItemInfo.GetShowPVELevel ( );
		}
		INT32 GetPVEAttack ( )
		{
			return m_ItemInfo.GetPVEAttack ( );
		}
		INT32 GetShowMaxBombA ( )
		{
			return m_ItemInfo.GetShowMaxBombA ( );
		}
		INT32 GetShowMaxHp ( )
		{
			return m_ItemInfo.GetShowMaxHp ( );
		}
		INT32 GetShowMaxBombB ( )
		{
			return m_ItemInfo.GetShowMaxBombB ( );
		}
		CEncodeMember* GetLayoutBombTime ( )
		{
			return m_ItemInfo.GetLayoutBombTime ( );
		}



		//虚函数实现
		void* InitBase ( bool Destroy )
		{ }
		void InitBase ( )
		{ }
		INT32 GetItem2B4 ( )
		{ }
		INT32 SetHp ( INT32 value )
		{ }
		void AddHp ( INT32 value )
		{ }
		bool GetAvatar ( )
		{ }
		void AddLayoutBomb ( INT16 value )
		{ }
		INT32 GetBombPower ( )
		{ }
		INT32 FunZeroB ( )
		{ }
		INT32 FunZeroC ( INT32 value )
		{ }
		void CalcBombSize ( )
		{ }
	};

	enum
	{
		CNPCItemSize = sizeof ( CNPCItem ) ,
	};
	static_assert( CNPCItemSize == 0x318 , "CNPCItemSize is error" );
}



```

`QQTang CheatEngine/Player.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "NPC.hpp"
#define PPlyaer CPlayer*

namespace QQTangCheatEngine
{
 
	class CPlayer : 
		public CNPC
	{
		public:

	};
}


```

`QQTang CheatEngine/PythonCode/levelCFG.py`:

```py
version = 1
class LevelCfg:
    __module__ = __name__
    points = [0,
     1000,
     2000,
     3000,
     4000,
     5000,
     10000,
     12000,
     14000,
     16000,
     18000,
     20000,
     30000,
     33000,
     36000,
     39000,
     42000,
     45000,
     60000,
     64000,
     68000,
     72000,
     76000,
     80000,
     100000,
     105000,
     110000,
     115000,
     120000,
     125000,
     150000,
     156000,
     162000,
     168000,
     174000,
     180000,
     210000,
     217000,
     224000,
     231000,
     238000,
     245000,
     280000,
     288000,
     296000,
     304000,
     312000,
     320000,
     360000,
     369000,
     378000,
     387000,
     396000,
     405000,
     450000,
     460000,
     470000,
     480000,
     490000,
     500000,
     550000,
     565000,
     580000,
     595000,
     610000,
     625000,
     700000,
     720000,
     740000,
     760000,
     780000,
     800000,
     900000,
     925000,
     950000,
     975000,
     1000000,
     1025000,
     1150000,
     1180000,
     1210000,
     1240000,
     1270000,
     1300000,
     1450000,
     1485000,
     1520000,
     1555000,
     1590000,
     1625000,
     1800000,
     1840000,
     1880000,
     1920000,
     1960000,
     2000000,
     2200000,
     2245000,
     2290000,
     2335000,
     2380000,
     2425000,
     2650000,
     2700000,
     2750000,
     2800000,
     2850000,
     2900000,
     3150000,
     3205000,
     3260000,
     3315000,
     3370000,
     3425000,
     3700000,
     3760000,
     3820000,
     3880000,
     3940000,
     4000000,
     4300000,
     4370000,
     4440000,
     4510000,
     4580000,
     4650000,
     5000000,
     5090000,
     5180000,
     5270000,
     5360000,
     5450000,
     5900000,
     6020000,
     6140000,
     6260000,
     6380000,
     6500000,
     7100000,
     7260000,
     7420000,
     7580000,
     7740000,
     7900000,
     8700000,
     8910000,
     9120000,
     9330000,
     9540000,
     9750000,
     10800000,
     11070000,
     11340000,
     11610000,
     11880000,
     12150000,
     13500000,
     14685000,
     15870000,
     17055000,
     18240000,
     19425000,
     25350000,
     29145000,
     32940000,
     36735000,
     40530000,
     44325000,
     63300000,
     71380000,
     79460000,
     87540000,
     95620000,
     103700000,
     144100000,
     292805000,
     441510000,
     590515000,
     738920000,
     887625000,
     1631150000]
    titles = ['QQ\xcc\xc3\xc6\xbd\xc3\xf1',
     '\xcc\xc7\xb9\xfb\xb0\xae\xba\xc3\xd5\xdf',
     '\xb2\xc9\xb9\xba\xd1\xa7\xcd\xbd',
     '\xb0\xbe\xcc\xc7\xb9\xa4\xc8\xcb',
     '\xb0\xe8\xcc\xc7\xca\xec\xc1\xb7\xb9\xa4',
     '\xcc\xf0\xce\xb6\xbc\xbc\xca\xf5\xd4\xb1',
     '\xc4\xf3\xd0\xce\xca\xa6\xb8\xb5',
     '\xc6\xb7\xcc\xc7\xb8\xdf\xca\xd6',
     '\xd4\xec\xd0\xcd\xd7\xa8\xbc\xd2',
     'QQ\xcc\xc7\xb4\xf3\xca\xa6',
     '\xcc\xc7\xb9\xfb\xd6\xbe\xd4\xb8\xd5\xdf',
     '\xc4\xcc\xc0\xd2\xd4\xa4\xb1\xb8\xb1\xf8',
     'QQ\xcc\xc7\xd5\xbd\xca\xbf',
     '\xc5\xd9\xb1\xf9\xc6\xef\xb1\xf8',
     '\xb0\xf4\xb0\xf4\xcc\xc7\xd3\xce\xcf\xc0',
     '\xb1\xfd\xb8\xc9\xb6\xd3\xb3\xa4',
     '\xb9\xfb\xb6\xb3\xc6\xef\xca\xbf',
     '\xb0\xf4\xb0\xf4\xcc\xc7\xbd\xab\xbe\xfc',
     '\xb1\xf9\xe7\xf7\xc1\xdc\xd3\xc2\xd5\xdf',
     'QQ\xcc\xc3\xd3\xa2\xd0\xdb',
     '\xcc\xc7\xb9\xfb\xd5\xf2\xb3\xa4',
     '\xd6\xd0\xbb\xaa\xb3\xc7\xd6\xf7',
     '\xc3\xce\xbb\xc3\xb5\xba\xd6\xf7',
     '\xd0\xc7\xd0\xc7\xb9\xab\xbe\xf4',
     '\xd4\xc2\xc1\xc1\xcd\xf5\xd7\xd3',
     '\xcc\xab\xd1\xf4\xb9\xfa\xcd\xf5',
     '\xd7\xcf\xd7\xea\xbb\xca\xb5\xdb',
     '\xbf\xe1\xb1\xc8\xb4\xf3\xcc\xec\xca\xb9',
     '\xb4\xb4\xca\xc0\xd6\xae\xc9\xf1',
     '???']

class Level:
    __module__ = __name__

    def __point2level(this, point):
        for i in range(len(LevelCfg.points)):
            if (point < LevelCfg.points[i]):
                return i

        return (len(LevelCfg.points) - 1)



    def getInfo(this, point):
        level = this._Level__point2level(point)
        mainLevel = (((level - 1) / 6) + 1)
        minLevel = (((level - 1) % 6) + 1)
        return (LevelCfg.titles[(mainLevel - 1)],
         mainLevel,
         minLevel)



    def getExp(this, point):
        level = this._Level__point2level(point)
        hi = LevelCfg.points[level]
        lo = LevelCfg.points[(level - 1)]
        rate = (((point - lo) * 100) / (hi - lo))
        rate = min(max(rate, 0), 100)
        return rate



    def getRate(this, point):
        level = this._Level__point2level(point)
        hi = LevelCfg.points[level]
        lo = LevelCfg.points[(level - 1)]
        strRate = ('%.2f%%' % (((point - lo) * 100.0) / (hi - lo)))
        return strRate



    def getMainLevel(this, mainLevel):
        return ('object/ui/level/medal/%03d.img' % mainLevel)



    def getMinLevel(this, mainLevel, minLevel):
        if (mainLevel == 10):
            path = ('object/ui/level/tie/a%02d.img' % minLevel)
        elif (mainLevel == 20):
            path = ('object/ui/level/tie/b%02d.img' % minLevel)
        elif ((mainLevel > 20) and (mainLevel <= 23)):
            path = ('object/ui/level/tie/c%02d.img' % minLevel)
        elif ((mainLevel > 23) and (mainLevel <= 26)):
            path = ('object/ui/level/tie/d%02d.img' % minLevel)
        elif ((mainLevel > 26) and (mainLevel <= 29)):
            path = ('object/ui/level/tie/e%02d.img' % minLevel)
        elif (mainLevel == 30):
            path = ('object/ui/level/tie/f%02d.img' % minLevel)
        else:
            path = ('object/ui/level/tie/t%02d.img' % minLevel)
        return path



    def setUI(this, ui, levelInfo):
        ui += '.levelIcon'
        Win_SetImg((ui + '.mainLevel'), this.getMainLevel(levelInfo[1]))
        Win_SetImg((ui + '.minLevel'), this.getMinLevel(levelInfo[1], levelInfo[2]))



    def clearUI(this, ui):
        ui += '.levelIcon'
        Win_SetImg((ui + '.mainLevel'), '')
        Win_SetImg((ui + '.minLevel'), '')




#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiConst.py`:

```py
print 3
class CNil:
    __module__ = __name__

(false, true,) = (False,
 True)
eBkImgPlayOnce = (1 << 3)
normal_layer_init = 0
focus_layer_plus = 1000
console_layer = 65535
systooltip_layer = 65534
msgbox_layer = 65533
buddy_widget_none = 0
buddy_widget_tipwgt = 1
buddy_widget_msgbox = 2
buddy_widget_console = 3
buddy_widget_npcdlg = 4
buddy_widget_infowgt = 5
buddy_widget_buddy = 6
buddy_widget_scroll_primary = 7
buddy_widget_scroll_secondary = 8
buddy_style_self = 0
buddy_style_scrn_default = 1
buddy_style_root_default = 2
wgtstyle_none = 0
wgtstyle_flash = 4
wgtstyle_vertical = 8
wgtstyle_primary = 16
wgtstyle_adjustself = 32
wgtstyle_clipchild_window = 64
wgtstyle_clipchild_client = 128
wgtstyle_systemdraw = 256
wgtstyle_advance = 512
wgtstyle_popup = 1024
wgtstyle_self_xmove = 2048
wgtstyle_self_ymove = 4096
wgtstyle_self_xsize = 8192
wgtstyle_self_ysize = 16384
wgtstyle_static = 32768
wgtstyle_topmost = 65536
wgtstyle_alphawin = 262144
wgtstyle_flipdrag = 524288
wgtstyle_template = 1048576
wgtstyle_clipself = 2097152
wgtstyle_cleanwin = 4194304
ui_btn_style_none = 0
ui_btn_style_popupmsg = 1
ui_btn_style_radio = 2
ui_btn_style_auto_toggle = 4
ui_btn_style_auto_round = 8
dt_top = 0
dt_left = 0
dt_center = 1
dt_right = 2
dt_vcenter = 4
dt_bottom = 8
alignstyle_none = 0
alignstyle_top_in = 1
alignstyle_bottom_in = 2
alignstyle_left_in = 4
alignstyle_right_in = 8
alignstyle_top_out = 16
alignstyle_bottom_out = 32
alignstyle_left_out = 64
alignstyle_right_out = 128
alignstyle_hcenter = 256
alignstyle_vcenter = 512
value_channel_state = 0
value_channel_style = 1
value_channel_dragtype = 2
value_channel_tabstop = 3
value_channel_groupstop = 4
value_channel_groupid = 5
value_channel_textstyle = 6
value_channel_textsize = 7
value_channel_snaph = 8
value_channel_snapv = 9
value_channel_value = 10
value_channel_minvalue = 11
value_channel_maxvalue = 12
value_channel_step = 13
value_channel_page = 14
value_channel_pagenum = 15
value_channel_sel = 16
value_channel_pos = 17
value_channel_race = 18
value_channel_gender = 19
value_channel_hair = 20
value_channel_value_h = 21
value_channel_value_v = 22
value_channel_lower_h = 23
value_channel_uper_h = 24
value_channel_lower_v = 25
value_channel_uper_v = 26
value_channel_method = 27
value_channel_customitem_state = 28
value_channel_frame = 31
value_channel_listitem_num = 32
value_channel_bar_num_state = 31
value_channel_winrect = 34
value_channel_clientrect = 35
value_channel_captionrect = 36
value_channel_dragrect = 37
value_channel_dragindex = 38
VALUE_CHANNEL_FRAMESCHEME = 45
value_channel_console_src_pos_x = 46
value_channel_console_src_pos_y = 47
value_channel_console_dst_pos_x = 48
value_channel_console_dst_pos_y = 49
value_channel_range_begin = 50
value_channel_range_end = 51
value_channel_color_back = 52
value_channel_color_draw = 53
value_channel_color_focus = 54
value_channel_color_edge = 55
value_channel_switch = 56
value_channel_update_dirty = 57
value_channel_caption = 200
value_channel_seltext = 201
value_channel_pathname = 202
value_channel_dirname = 203
value_channel_bksurfname = 204
value_channel_edithistory = 205
value_channel_buddy = 206
value_channel_itemtext = 207
value_channel_tiptext = 208
value_channel_typename = 209
value_channel_console_enter_string = 210
value_channel_draw_flag = 801
value_channel_maxchar = 903
aligntype_none = 0
aligntype_brother = 1
aligntype_father = 2
aligntype_uncle = 4
aligntype_grandpa = 8
aligntype_winrect = 16
aligntype_clientrect = 32
aligntype_captionrect = 64
aligntype_dragrect = 128
edit_normal = 0
edit_number = 1
edit_coder = 2
edit_talk = 3
edit_charNumber = 4
flyer_scroll_sate_start = 0
flyer_scroll_sate_forward = 1
flyer_scroll_sate_backward = 2
flyer_scroll_sate_end = 3
drawflag_none = 0
drawflag_win_edge = 1
drawflag_win_fill = 2
drawflag_client_edge = 4
drawflag_client_fill = 8
drawflag_caption_edge = 16
drawflag_caption_fill = 32
drawflag_drag_edge = 64
drawflag_drag_fill = 128
drawflag_none = 0
drawflag_win_edge = 1
drawflag_win_fill = 2
drawflag_client_edge = 4
drawflag_client_fill = 8
drawflag_caption_edge = 16
drawflag_caption_fill = 32
drawflag_drag_edge = 64
drawflag_drag_fill = 128
drawflag_backpatch_h = 256
drawflag_coverpatch_h = 512
drawflag_backpatch_v = 1024
drawflag_coverpatch_v = 2048
drawflag_backpatch_mid = 4096
drawflag_coverpatch_mid = 8192
ui_totalmaxpoint = 30
ui_initmaxpoint = 10
soundMain = 'uiMain.wav'
soundUI = 'uiNormal.wav'
soundLeave = 'uiLeave.wav'
soundFail = 'uiFail.wav'
musicStart = 'm09.ogg'
musicDirAndSection = 'das.ogg'
musicRoom = 'm10.ogg'
equipMap = {'cap': 1,
 'fhadorn': 1,
 'bhadorn': 2,
 'thadorn': 3,
 'hair': 4,
 'mask': 5,
 'eye': 5,
 'mouth': 6,
 'ear': 7,
 'cladorn': 10,
 'cloth': 9,
 'npack': 12,
 'fpack': 11,
 'leg': 13,
 'foot': 14}
normalItem = {'bomb': 1,
 'huanying': 2,
 'bg': 3,
 'frame': 4,
 'enter': 5,
 'card': 6,
 'item': 7}
attrMap = {1: 'hot',
 2: 'new',
 3: 'numberlimited',
 4: '',
 5: 'free',
 6: 'timelimited',
 7: 'member'}

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiFunc.py`:

```py
import sys
faceIconList = ['/aiq',
 '/am',
 '/bb',
 '/bei',
 '/baiy',
 '/bz',
 '/cy',
 '/dao',
 '/db',
 '/dg',
 '/dh',
 '/dk',
 '/dp',
 '/ds',
 '/dx',
 '/dy',
 '/fad',
 '/fan',
 '/fd',
 '/feid',
 '/fendou',
 '/fn',
 '/gf',
 '/gg',
 '/hanx',
 '/hx',
 '/hy',
 '/jie',
 '/jk',
 '/jy',
 '/ka',
 '/kl',
 '/kuk',
 '/kun',
 '/lh',
 '/ll',
 '/lw',
 '/maom',
 '/mg',
 '/mm',
 '/ng',
 '/pz',
 '/qianc',
 '/qiang',
 '/qiao',
 '/ruo',
 '/se',
 '/shan',
 '/shd',
 '/shl',
 '/shuai',
 '/shui',
 '/sj',
 '/tiao',
 '/tp',
 '/tu',
 '/tx',
 '/ty',
 '/wen',
 '/ws',
 '/wx',
 '/xg',
 '/xin',
 '/xs',
 '/xu',
 '/yb',
 '/yiw',
 '/yj',
 '/yl',
 '/yun',
 '/yw',
 '/yy',
 '/zhao',
 '/zhd',
 '/zhem',
 '/zhm',
 '/zj',
 '/zk',
 '/zq',
 '/zt']
faceIconList = ['/m00',
 '/m01',
 '/m02',
 '/m03',
 '/m04',
 '/m05',
 '/m06',
 '/m07',
 '/m08',
 '/m09',
 '/m10',
 '/m11',
 '/m12',
 '/m13',
 '/m14',
 '/m15',
 '/m16',
 '/m17',
 '/m18',
 '/m19',
 '/m20',
 '/m21',
 '/m22',
 '/m23',
 '/kdz',
 '/klz',
 '/kyl',
 '/kym',
 '/kyh',
 '/kxy',
 '/krh',
 '/kqq',
 '/kpx',
 '/kot',
 '/kku',
 '/kkx',
 '/khan',
 '/khx',
 '/khd',
 '/kgd',
 '/kfb',
 '/kfs',
 '/kdk',
 '/kcb',
 '/kbt',
 '/kbs',
 '/kbz',
 '/k23',
 '/jy',
 '/pz',
 '/se',
 '/fd',
 '/dy',
 '/ll',
 '/hx',
 '/bz',
 '/shui',
 '/dk',
 '/gg',
 '/fn',
 '/tp',
 '/cy',
 '/wx',
 '/ng',
 '/kuk',
 '/feid',
 '/zk',
 '/tu',
 '/tx',
 '/ka',
 '/baiy',
 '/am',
 '/jie',
 '/kun',
 '/jk',
 '/lh',
 '/hanx',
 '/db',
 '/fendou',
 '/zhm',
 '/yiw',
 '/xu',
 '/yun',
 '/zhem',
 '/shuai',
 '/kl',
 '/qiao',
 '/zj',
 '/shan',
 '/fad',
 '/aiq',
 '/tiao',
 '/zhao',
 '/mm',
 '/zt',
 '/maom',
 '/xg',
 '/yb',
 '/qianc',
 '/dp',
 '/bei',
 '/dg',
 '/shd',
 '/zhd',
 '/dao',
 '/zq',
 '/yy',
 '/bb',
 '/gf',
 '/fan',
 '/yw',
 '/mg',
 '/dx',
 '/wen',
 '/xin',
 '/xs',
 '/hy',
 '/lw',
 '/dh',
 '/sj',
 '/yj',
 '/ds',
 '/ty',
 '/yl',
 '/qiang',
 '/ruo',
 '/ws',
 '/shl',
 '/dd',
 '/mn',
 '/hl',
 '/mamao',
 '/qz',
 '/fw',
 '/oh',
 '/bj',
 '/qsh',
 '/xiq',
 '/xy',
 '/duoy',
 '/xr',
 '/xixing',
 '/nv',
 '/nan']
memberFaceIconList = ['/m00',
 '/m01',
 '/m02',
 '/m03',
 '/m04',
 '/m05',
 '/m06',
 '/m07',
 '/m08',
 '/m09',
 '/m10',
 '/m11',
 '/m12',
 '/m13',
 '/m14',
 '/m15',
 '/m16',
 '/m17',
 '/m18',
 '/m19',
 '/m20',
 '/m21',
 '/m22',
 '/m23']
initFaceIconList(faceIconList)

def do(wgt, func):
    do2(wgt, func)



def do2(wgt, func):
    if (wgt.__dict__.has_key(func) and wgt.__dict__[func]()):
        pass



def do3(wgt, func, arg):
    if (wgt.__dict__.has_key(func) and wgt.__dict__[func](arg)):
        pass



def do4(wgt, func, arg1, arg2):
    if (wgt.__dict__.has_key(func) and wgt.__dict__[func](arg1, arg2)):
        pass



def doUI(ui, func):
    value = ''
    i = 0
    while 1:
        j = ui.find('.', i)
        if (j == -1):
            value += ui[i:]
            break
        else:
            value += (ui[i:j] + '.children.')
            i = (j + 1)

    if ((func == 'OnClick') and do3(eval(value), func, ui)):
        pass


class MyStdout:
    __module__ = __name__

    def write(self, s):
        Win_ConsolePrint(s)



sys.stdout = MyStdout()
sys.stderr = MyStdout()

def getMyIdx():
    me = Win_GetFocusPath()
    return getTailNum(me)



def getMyIdx2():
    me = Win_GetMyPath()
    return getTailNum(me)



def getTailNum(s):
    if ((s[-2] >= '0') and (s[-2] <= '9')):
        return int(s[-2:])
    elif ((s[-1] >= '0') and (s[-1] <= '9')):
        return int(s[-1:])
    else:
        return 0



def getMidIdx(s):
    for i in range(len(s)):
        if ((s[i] >= '0') and (s[i] <= '9')):
            if ((i + 1) >= len(s)):
                return int(s[i])
            if ((s[(i + 1)] >= '0') and (s[(i + 1)] <= '9')):
                return int(s[i:(i + 2)])
            else:
                return int(s[i])




def getMyMidIdx():
    me = Win_GetMyPath()
    return getMidIdx(me)



def ui_setCapture(widget):
    Win_ShowWidget(widget, True)
    Win_SetFocus(widget)
    Win_SetCapture(widget)



def getLevelPic(level):
    level = min(max(1, level), 225)
    return ('res/uires/level/%03d.img' % level)



def go2shop():
    global localShopVersion
    serverID = GetRandShopServerID()
    localShopVersion = lastestShopVersion
    SetLocalShopVertion(uin, lastestShopVersion)
    if (0 != serverID):
        print 'EnterShop,',
        print uin,
        print serverID
        print 'InitializeShop()'
        InitializeShop()
        EnterShop(uin, serverID)
        PlaySound(soundMain, 1)



def isMapExist(ID):
    index = -1
    for i in range(len(mapDesc)):
        if (mapDesc[i][0] == ID):
            index = i
            break

    if (index == -1):
        return 0
    else:
        return 1



def getMapDesc(ID):
    for i in range(len(mapDesc)):
        if (mapDesc[i][0] == ID):
            return mapDesc[i]

    for i in range(len(mapDesc)):
        if (mapDesc[i][5] == 8):
            return mapDesc[i]




def getMapTypeByID(ID):
    return getMapDesc(ID)[1]



def getMapDescByID(ID):
    return getMapDesc(ID)[2]



def getMapSizeXByID(ID):
    return getMapDesc(ID)[3]



def getMapSizeYByID(ID):
    return getMapDesc(ID)[4]



def getMapMaxPlayerNumByID(ID):
    return getMapDesc(ID)[5]



def getMapFilenameByID(ID):
    return getMapDesc(ID)[6]



def getThumbnailFilenameByID(ID):
    return getMapDesc(ID)[7]



def getSoundFxFilenameByID(ID):
    return getMapDesc(ID)[8]



def getMapPointByID(ID):
    return getMapDesc(ID)[9]



def getDetailDescByID(ID):
    return getMapDesc(ID)[10]



def getTotalMapCount():
    return len(mapDesc)



def getMapIdByIndex(index):
    '\n    \xb8\xf9\xbe\xddindex\xb5\xc3\xb5\xbd\xb5\xd8\xcd\xbc\xb5\xc4ID\n    '
    if ((index < 0) or (index >= len(mapDesc))):
        return 0
    return mapDesc[index][0]



def getMapFilenameByIndex(index):
    '\n    \xb8\xf9\xbe\xddindex\xb5\xc3\xb5\xbd\xb5\xd8\xcd\xbc\xc3\xfb\xb3\xc6\n    '
    if ((index < 0) or (index >= len(mapDesc))):
        return ''
    return mapDesc[index][6]



def getThumbnailFilenameByIndex(index):
    '\n    \xb8\xf9\xbe\xddindex\xb5\xc3\xb5\xbd\xb5\xd8\xcd\xbc\xcb\xf5\xc2\xd4\xcd\xbc\xb5\xc4\xc3\xfb\xb3\xc6\n    '
    if ((index < 0) or (index >= len(mapDesc))):
        return ''
    return mapDesc[index][7]



def mapID2name(ID):
    if (0 == ID):
        return '\xcb\xe6\xbb\xfa\xb5\xd8\xcd\xbc'
    index = 0
    for i in range(len(mapDesc)):
        if (mapDesc[i][0] == ID):
            index = i
            break

    name = mapDesc[index][2]
    type = mapDesc[index][1]
    return name


screenEnterWeb = ''

def ui_jumpHelpWeb():
    global screenEnterWeb
    screenEnterWeb = Win_GetCurScreen()
    PlaySound(soundMain, 1)
    GotoUIScreen('web')
    JumpHelpWeb('http://qqtang.qq.com/game/help/operation.htm')



def ui_jumpOfficialWeb():
    global screenEnterWeb
    screenEnterWeb = Win_GetCurScreen()
    PlaySound(soundMain, 1)
    GotoUIScreen('web')
    JumpHelpWeb('http://qqtang.qq.com')



def ui_jumpLeagueWeb():
    global screenEnterWeb
    screenEnterWeb = Win_GetCurScreen()
    PlaySound(soundMain, 1)
    GotoUIScreen('web')
    JumpHelpWeb('http://newqqtang.qq.com/vip/')



def ui_jumpWeb(url):
    global screenEnterWeb
    screenEnterWeb = Win_GetCurScreen()
    PlaySound(soundMain, 1)
    GotoUIScreen('web')
    JumpHelpWeb(url)



def ui_showMemberWeb(url, flag):
    global joinMemberURL
    global exitFlag
    exitFlag = flag
    joinMemberURL = url
    ui_setCapture('UI.joinMemberWeb')
    sc_ShowWeb('joinmember', 230, 198, 325, 200, joinMemberURL)



def GetItemTypeName(ID):
    if (not itemList.has_key(ID)):
        type = ''
    else:
        type = itemList[ID][0]
    return type



def GetSubIDByItemID(ID):
    if (not itemList.has_key(ID)):
        return 0
    else:
        return itemList[ID][1]


QB = -1
gameMoney = -1
sugarMoney = -1
QQTTicket = 0

def getMoney():
    return (QB,
     gameMoney,
     sugarMoney)



def ui_NotifyMoney(iQB, iGameMoney, iSugarMoney):
    global sugarMoney
    global QQTTicket
    global QB
    global gameMoney
    print 'ui_NotifyMoney'
    QB = iQB
    gameMoney = iGameMoney
    sugarMoney = iSugarMoney
    ticketInfo = GetMyTicket()
    QQTTicket = ticketInfo.m_iNumOfItem
    if ((-1 == sugarMoney) and Win_SetText('UI.shop.sugarMoney', '')):
        pass
    if ((QQTTicket < 0) and Win_SetText('UI.shop.shopTicket', '')):
        pass



def ui_updateTicket():
    global QQTTicket
    print 'ui_updateTicket()'
    ticketInfo = GetMyTicket()
    QQTTicket = ticketInfo.m_iNumOfItem
    if ((QQTTicket < 0) and Win_SetText('UI.shop.shopTicket', '')):
        pass


game_mapID = 0

def game_setMapID(mapID):
    global game_mapID
    if (Win_GetCurScreen() == 'game'):
        info = getMapDesc(mapID)
        Win_SetImg((uiGamePlayerList + '.mapIcon'), ('map/icon/%s.img' % info[1]))
        setSelectedMapType(info[1])
        name = info[2].replace('\n', '')
        Win_SetText((uiGamePlayerList + '.mapName'), name)
        game_mapID = mapID



def getMyUin():
    return uin



def NotifyMyUin(myUin):
    global uin
    print 'NotifyMyUin',
    print myUin
    uin = myUin



def filterChatMsg(msg):
    if (msg != ''):
        msg = msg.replace('/<h>', '')
        msg = msg.replace('/<H>', '')
    return msg


bFruitUpdate = 0

def ui_NotifyUpdateFruit():
    global bFruitUpdate
    bFruitUpdate = 1



def onStopEffect(id):
    pass


#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiGame.py`:

```py
isBringItem = True
bRecord = 0
chatDlgO = 550
chatDlgY = chatDlgO
isBugle = 0

def NotifyAddHint(flag, x, y, szMsg):
    if (Win_GetCurScreen() == 'game'):
        ui = 'UI.game.hint'
        Win_Move2Pos(ui, x, y)
        Win_SetText((ui + '.words'), szMsg)
        Win_SetImg(ui, ('object/ui/game/chatpopo%d.img' % flag))
        if (((flag == 1) or (flag == 3)) and Win_SetRect((ui + '.words'), value_channel_winrect, (x + 55), (y + 20), 180, 140)):
            Win_SetRect((ui + '.words'), value_channel_clientrect, 0, 0, 180, 140)
            Win_SetRect((ui + '.words'), value_channel_captionrect, 0, 0, 180, 140)
        Win_ShowWidget(ui, 1)



def NotifyRemoveHint():
    if (Win_GetCurScreen() == 'game'):
        ui = 'UI.game.hint'
        Win_ShowWidget(ui, 0)



def ClearTotem():
    i = 0
    while (i < 8):
        ui = (uiGamePlayerList + ('.kintotem%d' % i))
        Win_SetImg(ui, '')
        i += 1




def showRecordPlayer(bshow):
    global bRecord
    bRecord = bshow
    Win_ShowWidget('UI.game.RecordPlayer', (bshow != 0))
    if ((bshow != 0) and showRecordRecorder(0)):
        pass



def showRecordRecorder(bshow):
    if ((bshow != 0) and Win_ShowWidget((uiGamePlayerList + '.saveReplayBtn'), True)):
        Win_ShowWidget((uiGamePlayerList + '.cancelSaveReplayBtn'), False)



def setRecordQQNumber(qqnumber):
    Win_SetText('UI.game.RecordPlayer.QQNumber', str(qqnumber))



def sendGameChat():
    global chatDlgY
    ui = 'UI.game.chat.edit'
    text = Win_GetText(ui)
    Win_SetText(ui, '')
    Win_ShowWidget('UI.game.chat', False)
    Win_SetFocus('')
    print 'RoomChat(',
    print text
    RoomChat(0, text)
    chatDlgY = chatDlgO
    PlaySound(soundMain, 1)



def sendSectionChat():
    ui = 'UI.game.chat.edit'
    text = Win_GetText(ui)
    Win_SetText(ui, '')
    Win_ShowWidget('UI.game.chat', False)
    Win_SetFocus('')
    print 'Ingameing send bugle',
    print text
    chatDlgY = chatDlgO
    PlaySound(soundMain, 1)
    SectionChat(1, text)



def ui_NotifyShowLevelIcon(score, idx, bshow):
    ui = (uiGamePlayerList + ('.level%d' % idx))
    si = GetSeatInfo(idx)
    playerInfo = si.player
    info = CNil()
    info.uin = playerInfo.m_dwUin
    info.kinIndex = playerInfo.m_dwKinIndex
    info.totemID = playerInfo.m_stKinFlagID.m_iFlagID
    info.kinName = playerInfo.m_szKinName
    if (bshow and (bRecord == 0)):
        level = Level().getInfo(score)
        Level().setUI(ui, level)
        Win_ShowWidget(ui, 1)
        totemID = info.totemID
        if (((totemID >= 0) and (totemID <= 48)) and Win_SetImg((uiGamePlayerList + ('.kintotem%d' % idx)), ('object/ui/kinTotem/%03d.img' % totemID))):
            Win_ShowWidget((uiGamePlayerList + ('.kintotem%d' % idx)), 1)
    else:
        Win_ShowWidget(ui, 0)
        Win_ShowWidget((uiGamePlayerList + ('.kintotem%d' % idx)), 0)
    if ((info.uin == 0) and Win_ShowWidget(ui, 0)):
        Win_ShowWidget((uiGamePlayerList + ('.kintotem%d' % idx)), 0)



def ui_NotifyShowResultLevelIcon(x, y, score, idx, bshow):
    ui = ('UI.game.resultDlg.level%d' % idx)
    if (bshow and Win_Move2Pos(ui, x, y)):
        level = Level().getInfo(score)
        Level().setUI(ui, level)
        Win_ShowWidget(ui, 1)



def ui_NotifyRenderResultLevelIcon(idx, alpha):
    ui = ('UI.game.resultDlg.level%d' % idx)
    Win_SetValue(ui, min(alpha, 1.0), 42)



def ui_SetGameMode(mode):
    print 'game mode = ',
    print mode
    if ((mode == 0) and Win_ShowWidget(uiGamePlayerList, 1)):
        Win_ShowWidget(uiPvePlayerList, 0)
        Win_ShowWidget(uiPveFuncDlg, 0)
        Win_ShowWidget('UI.game.pveTime', 0)


g_PVEBossCnt = 0
g_PVEBossID = []
g_DefBossCnt = 3
g_PVEPlayerCnt = 0
g_PVEPlayerID = []
g_DefPlayerCnt = 4
g_RoleNameList = ('',
 'xwk',
 'tt',
 'xq',
 'cl',
 'bbl',
 'hy',
 'mly',
 'hwz',
 'boy',
 'cbz',
 'xz',
 'ls',
 'kl',
 'nz',
 'wll',
 'yy',
 '',
 'yd',
 'ld',
 'ge',
 'tb',
 'girl')

def ui_InitPVEBoss():
    global g_PVEBossID
    global g_PVEBossCnt
    bossInfo = GetPVEBossInfo()
    g_PVEBossID = []
    g_PVEBossCnt = len(bossInfo)
    print 'Init boss cnt=',
    print g_PVEBossCnt
    if (g_PVEBossCnt <= 0):
        for i in range(g_DefBossCnt):
            ui = ('UI.game.pveBossInfo%d' % i)
            Win_ShowWidget(ui, 0)

        return 
    posx = 70
    posy = 25
    step = (580 / g_PVEBossCnt)
    for i in range(g_DefBossCnt):
        ui = ('UI.game.pveBossInfo%d' % i)
        if ((i >= g_PVEBossCnt) and Win_ShowWidget(ui, 0)):
            continue
        Win_SetImg((ui + '.BossPortrait'), ('object/ui/room/char/icon_%d.img' % bossInfo[i].m_iImageID))
        print 'bossInfo[i].m_iImageID = ',
        print bossInfo[i].m_iImageID
        g_PVEBossID.append(bossInfo[i].m_iNPCID)
        Win_ShowWidget(ui, 1)
        curposx = (posx + (i * step))
        Win_Move2Pos(ui, curposx, posy)
        Win_SetRect((ui + '.lifeLineBack'), value_channel_winrect, (curposx + 54), posy, (step - 55), 17)
        Win_SetRect((ui + '.lifeLineFront'), value_channel_winrect, (curposx + 56), posy, (step - 61), 17)
        Win_SetStripTotalNum((ui + '.lifeLineBack'), bossInfo[i].m_iHP)
        Win_SetStripNum((ui + '.lifeLineBack'), bossInfo[i].m_iHP)
        Win_SetStripDestNum((ui + '.lifeLineBack'), bossInfo[i].m_iHP)
        Win_SetStripTotalNum((ui + '.lifeLineFront'), bossInfo[i].m_iHP)
        Win_SetStripNum((ui + '.lifeLineFront'), bossInfo[i].m_iHP)
        Win_SetStripDestNum((ui + '.lifeLineFront'), bossInfo[i].m_iHP)




def ui_UpdatePVEBossLife(id, life):
    for i in range(len(g_PVEBossID)):
        if (g_PVEBossID[i] == id):
            print g_PVEBossID,
            print id,
            print life
            ui = ('UI.game.pveBossInfo%d' % i)
            Win_SetStripDestNum((ui + '.lifeLineFront'), life)




def ui_InitPVEPlayer():
    global g_PVEPlayerID
    global g_PVEPlayerCnt
    playerInfo = GetPVEPlayerInfo()
    g_PVEPlayerCnt = len(playerInfo)
    g_PVEPlayerID = []
    for i in range(g_PVEPlayerCnt):
        g_PVEPlayerID.append(playerInfo[i].m_nPlayerID)

    print 'Init PvE Player: count=%d, ',
    print g_PVEPlayerID
    for i in range(g_DefPlayerCnt):
        ui = ('UI.game.pvePlayerList.playerInfo%d' % i)
        if ((i >= g_PVEPlayerCnt) and Win_ShowWidget(ui, 0)):
            continue
        Win_ShowWidget(ui, 1)
        Win_SetImg((ui + '.playerIcon'), ('object/ui/room/char/icon_%s.img' % g_RoleNameList[playerInfo[i].m_nRoleID]))
        Win_SetText((ui + '.playerName'), str(playerInfo[i].m_szNickName))
        level = Level().getInfo(playerInfo[i].m_nPoints)
        Level().setUI(ui, level)
        Win_SetText((ui + '.playerLife'), str(playerInfo[i].m_nHP))
        Win_SetStripTotalNum((ui + '.playerLifeLine'), playerInfo[i].m_nHP)
        Win_SetStripNum((ui + '.playerLifeLine'), playerInfo[i].m_nHP)
        Win_SetStripDestNum((ui + '.playerLifeLine'), playerInfo[i].m_nHP)




def ui_UpdatePVEPlayerLife(id, life):
    print ('update PvE player life: playerID=%d, life=%d' % (id,
     life))
    for i in range(len(g_PVEPlayerID)):
        ui = ('UI.game.pvePlayerList.playerInfo%d' % i)
        if ((g_PVEPlayerID[i] == id) and Win_SetText((ui + '.playerLife'), str(life))):
            Win_SetStripDestNum((ui + '.playerLifeLine'), life)




def ui_UpdateTankBaseLife(id, life):
    print ('tank base %d life is %d' % (id,
     life))
    ui = ('UI.game.tankBaseInfo' + str(id))
    Win_SetText((ui + '.tankBaseLife'), str(life))
    Win_SetStripDestNum((ui + '.tankBaseLifeLine'), life)



def ui_DisposePVEPlayerLeave(id):
    for i in range(len(g_PVEPlayerID)):
        ui = ('UI.game.pvePlayerList.playerInfo%d' % i)
        if ((g_PVEPlayerID[i] == id) and Win_ShowWidget(ui, 0)):
            pass




def ui_SetItemTimeSpeed(idx, speed):
    ui = ('UI.game.statusBar.itemMask%d' % idx)
    Win_SetAngleStep(ui, speed)



def ui_SetItemTimeCur(idx, curAngle):
    ui = ('UI.game.statusBar.itemMask%d' % idx)
    Win_SetAngleCur(ui, curAngle)



def InitItemTime():
    for i in range(7):
        ui = ('UI.game.statusBar.itemMask%d' % i)
        Win_SetAngleCur(ui, 360.0)
        Win_SetAngleDest(ui, 360.0)
        Win_SetAngleStep(ui, 0.0)




def ui_SetBaseItemTimeSpeed(speed):
    ui = 'UI.game.statusBar.baseItemCycle'
    Win_SetAngleStep(ui, speed)



def ui_SetBaseItemTimeCur(curAngle):
    ui = 'UI.game.statusBar.baseItemCycle'
    Win_SetAngleCur(ui, curAngle)



def InitBaseItemTime():
    ui = 'UI.game.statusBar.baseItemCycle'
    Win_SetAngleCur(ui, 360.0)
    Win_SetAngleDest(ui, 360.0)
    Win_SetAngleStep(ui, 0.0)



def setSelectedMapType(type):
    if ((type == 'tank') and Win_ShowWidget('UI.game.tankBaseInfo1', 1)):
        Win_ShowWidget('UI.game.tankBaseInfo2', 1)
        Win_SetImg('UI.game.tankBaseInfo2.tankBaseLifeLine', 'object/ui/game/img_playerLifeBlue.img')
        ui_UpdateTankBaseLife(1, 100)
        ui_UpdateTankBaseLife(2, 100)


class UI_children_game:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)
    accel = (('OnAccel_OnEnter',
      13,
      0,
      0,
      0))
    cursor = 'normal'

    def OnInit():
        print 'game OnInit'
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        Win_ShowWidget(uiMenuDlg, 0)
        Win_ShowWidget(uiPlayerInfoDlg, False)
        Win_ShowWidget('UI.game.hint', 0)
        Win_ShowWidget(uiAddFriendDlg, 0)
        Win_ShowWidget(uiBeAddedFriendDlg, 0)
        Win_ShowWidget(uiKinInfoDlg, 0)
        Win_ShowWidget(uiSetupDlg, 0)
        Win_ShowWidget(uiKinInviteDlg, 0)
        sc_HideWeb('kinMatch')
        sc_HideWeb('kinTeam')
        Win_ShowWidget(uiKinTipDlg, 0)
        Win_ShowWidget('UI.room.createkinhintDlg', 0)
        Win_ShowWidget('UI.room.createkinDlg', 0)
        Win_ShowWidget(uiRoomStorageDlg, 0)
        Win_SetText('UI.game.chatList', '', value_channel_listitem_num)
        Win_Timer('UI.game.chatList', 1500)
        Win_ShowWidget('UI.game.chat', False)
        CloseC2CDealDlg(bC2CDealShow)
        for i in range(8):
            Win_ShowWidget((uiGamePlayerList + ('.level%d' % i)), 0)

        InitSpeaker()
        ClearTotem()
        InitItemTime()
        InitBaseItemTime()
        screenStartIn()



    def OnDenit():
        print 'OnDenit() game'
        Win_ShowWidget(uiRoomStorageDlg, 0)



    def OnAccel_OnEnter():
        if Win_IsVisible('UI.SysMsgbox'):
            return 
        ui = uiPlayerInfoDlg
        if (Win_IsVisible(ui) and Win_ShowWidget(ui, 0)):
            return 
        ui = 'UI.game.chat'
        if (Win_IsVisible(ui) and (isBugle == 1)):
            if sendSectionChat():
                pass



    def OnAccel_OnEscape():
        print '<entry esc>'
        if (Win_IsVisible('UI.SysMsgbox') and Win_ShowWidget('UI.SysMsgbox', false)):
            pass
        return 1


    class children:
        __module__ = __name__
        class playerListDlg(TStatic):
            __module__ = __name__
            initlayer = -999999
            rect = (609,
             0,
             1,
             1)
            bkimage = 'object/ui/game/dlg_playerList.img'
            class children:
                __module__ = __name__
                class time:
                    __module__ = __name__
                    initlayer = 9999
                    type = 'NUMLABEL'
                    rect = (30,
                     57,
                     165,
                     52)
                    bkimage = 'object/ui/common/number3.img'
                    textsize = 27
                    textwidth = 27
                    textheight = 36
                    caption = '99:99'

                class mapIcon(TStatic):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (68,
                     10,
                     30,
                     30)
                    bkimage = 'map/icon/water.img'
                    bkImgFlag = dt_center

                class mapName(TLabel,
                 Static):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (102,
                     16,
                     82,
                     12)
                    drawcolor = lightColor
                    textstyle = dt_center

                class playerBtn0(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (46,
                     90,
                     137,
                     60)

                    def OnClick(this):
                        seatIdx = getMyIdx()
                        uin = sc_game_getPlayerUin(seatIdx)
                        if ((uin > 0) and go2playerInfo(uin)):
                            SetPlayerModeInfo(uin, 0)



                class playerBtn1(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + 48),
                     137,
                     60)

                class playerBtn2(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 2)),
                     137,
                     60)

                class playerBtn3(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 3)),
                     137,
                     60)

                class playerBtn4(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 4)),
                     137,
                     60)

                class playerBtn5(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 5)),
                     137,
                     60)

                class playerBtn6(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 6)),
                     137,
                     60)

                class playerBtn7(playerBtn0):
                    __module__ = __name__
                    rect = (38,
                     (91 + (48 * 7)),
                     137,
                     60)

                class level0(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (98,
                     130,
                     40,
                     15)
                    class children:
                        __module__ = __name__
                        class levelIcon(TLevelIcon):
                            __module__ = __name__
                            rect = (0,
                             0,
                             40,
                             15)



                class level1(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + 51),
                     40,
                     15)

                class level2(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 2)),
                     40,
                     15)

                class level3(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 3)),
                     40,
                     15)

                class level4(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 4)),
                     40,
                     15)

                class level5(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 5)),
                     40,
                     15)

                class level6(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 6)),
                     40,
                     15)

                class level7(level0):
                    __module__ = __name__
                    rect = (98,
                     (130 + (51 * 7)),
                     40,
                     15)

                class kintotem0(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (98,
                     110,
                     16,
                     15)

                class kintotem1(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + 51),
                     16,
                     15)

                class kintotem2(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 2)),
                     16,
                     15)

                class kintotem3(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 3)),
                     16,
                     15)

                class kintotem4(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 4)),
                     16,
                     15)

                class kintotem5(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 5)),
                     16,
                     15)

                class kintotem6(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 6)),
                     16,
                     15)

                class kintotem7(kintotem0):
                    __module__ = __name__
                    rect = (98,
                     (110 + (51 * 7)),
                     16,
                     15)

                class saveReplayBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (27,
                     533,
                     90,
                     48)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/game/btn_saveReplay.img'

                    def OnClick(this):
                        BeginRecord()
                        Win_ShowWidget((uiGamePlayerList + '.saveReplayBtn'), False)
                        Win_ShowWidget((uiGamePlayerList + '.cancelSaveReplayBtn'), True)



                class cancelSaveReplayBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (27,
                     533,
                     90,
                     48)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/game/btn_cancelSaveReplay.img'
                    visible = False

                    def OnClick(this):
                        StopRecord()
                        Win_ShowWidget((uiGamePlayerList + '.saveReplayBtn'), True)
                        Win_ShowWidget((uiGamePlayerList + '.cancelSaveReplayBtn'), False)



                class leave(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (125,
                     534,
                     52,
                     48)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/common/btn_leavegame.img'

                    def OnClick(this):
                        print '<leave> game'
                        LeaveGame()
                        PlaySound(soundLeave, 1)





        class pvePlayerList(TStatic):
            __module__ = __name__
            initlayer = 9999
            rect = (0,
             0,
             1,
             1)
            class children:
                __module__ = __name__
                class playerInfo0(TStatic):
                    __module__ = __name__
                    rect = (0,
                     80,
                     1,
                     1)
                    class children:
                        __module__ = __name__
                        class playerMask(TStatic):
                            __module__ = __name__
                            initlayer = -9999
                            rect = (0,
                             40,
                             100,
                             25)
                            bkimage = 'object/ui/game/mask_player.img'
                            alphafactor = 0.80000000000000004
                            textEdgeColor = maskColor

                        class playerIcon(TStatic):
                            __module__ = __name__
                            initlayer = -99999
                            rect = (2,
                             0,
                             50,
                             50)
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0)]
                            bkimage = 'object/ui/room/char/icon_xq.img'
                            alphafactor = 0.80000000000000004

                        class playerLife(TLabel):
                            __module__ = __name__
                            rect = (1,
                             44,
                             24,
                             12)
                            bkimage = ''
                            caption = '9999'
                            drawcolor = (0,
                             255,
                             255,
                             255)
                            textEdgeType = 2
                            textEdgeColor = (0,
                             255,
                             255,
                             255)

                        class playerLifeLine:
                            __module__ = __name__
                            type = 'DYLIFESTRIP'
                            rect = (0,
                             56,
                             90,
                             5)
                            bkimage = 'object/ui/game/img_playerLife.img'
                            totalnum = 1000
                            destnum = 1000
                            stepnum = 500

                        class levelIcon(TLevelIcon):
                            __module__ = __name__
                            rect = (0,
                             60,
                             40,
                             15)

                        class playerName(TLabel):
                            __module__ = __name__
                            rect = (26,
                             66,
                             96,
                             12)
                            drawcolor = zoneChooseColor
                            textEdgeType = -1
                            caption = '\xb0\xa2\xb2\xae\xb2\xca\xb5\xe7'



                class playerInfo1(playerInfo0):
                    __module__ = __name__
                    rect = (0,
                     (80 + 80),
                     1,
                     1)

                class playerInfo2(playerInfo0):
                    __module__ = __name__
                    rect = (0,
                     (80 + (80 * 2)),
                     1,
                     1)

                class playerInfo3(playerInfo0):
                    __module__ = __name__
                    rect = (0,
                     (80 + (80 * 3)),
                     1,
                     1)



        class pveFuncDlg(TStatic):
            __module__ = __name__
            visible = 0
            rect = (620,
             538,
             181,
             64)
            bkimage = 'object/ui/game/dlg_pveFunc.img'
            class children:
                __module__ = __name__
                class storageBtn(TButton):
                    __module__ = __name__
                    rect = (15,
                     10,
                     95,
                     45)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/game/btn_storage.img'

                    def OnClick(this):
                        if (Win_IsVisible(uiRoomStorageDlg) and Win_ShowWidget(uiRoomStorageDlg, 0)):
                            pass
                        PlaySound(soundUI, 1)



                class leaveBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (112,
                     8,
                     52,
                     48)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/common/btn_leavegame.img'

                    def OnClick(this):
                        print '<leave> game'
                        LeaveGame()
                        PlaySound(soundLeave, 1)





        class pveTime:
            __module__ = __name__
            type = 'NUMLABEL'
            rect = (650,
             20,
             135,
             36)
            bkimage = 'object/ui/common/number3.img'
            textsize = 27
            textwidth = 27
            textheight = 36
            caption = '99:99'

        class pveBossInfo0(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)
            class children:
                __module__ = __name__
                class BossPortrait(TStatic):
                    __module__ = __name__
                    initlayer = 99999
                    rect = (0,
                     0,
                     55,
                     55)
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    bkimage = 'object/ui/room/char/icon_xq.img'

                class lifeLineBack:
                    __module__ = __name__
                    initlayer = 999
                    type = 'DYLIFESTRIP'
                    rect = (0,
                     0,
                     1,
                     20)
                    totalnum = 1000
                    bkimage = 'object/ui/game/img_lifeNull.img'

                class lifeLineFront(lifeLineBack):
                    __module__ = __name__
                    initlayer = 9999
                    bkimage = 'object/ui/game/img_lifeRed.img'
                    stepnum = 200



        class pveBossInfo1(pveBossInfo0):
            __module__ = __name__

        class pveBossInfo2(pveBossInfo0):
            __module__ = __name__

        class RecordPlayer(TStatic):
            __module__ = __name__
            visible = 1
            initlayer = 9999
            rect = (631,
             580,
             174,
             33)
            bkimage = 'object/ui/game/record/ProcessBar.img'
            class children:
                __module__ = __name__
                class ResumeButton(TButton):
                    __module__ = __name__
                    initlayer = 10
                    rect = (3,
                     -40,
                     29,
                     20)
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      3,
                      3)]
                    bkimage = 'object/ui/game/record/btn_Resume.img'

                    def OnClick(this):
                        ResumePlayRecord()



                class X2Button(TButton):
                    __module__ = __name__
                    initlayer = 10
                    rect = (29,
                     -40,
                     29,
                     20)
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      3,
                      3)]
                    bkimage = 'object/ui/game/record/btn_2xSpeedPlay.img'

                    def OnClick(this):
                        SetPlayRecordSpeed(2)



                class X4Button(TButton):
                    __module__ = __name__
                    initlayer = 10
                    rect = (56,
                     -40,
                     29,
                     20)
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      3,
                      3)]
                    bkimage = 'object/ui/game/record/btn_4xSpeedPlay.img'

                    def OnClick(this):
                        SetPlayRecordSpeed(4)



                class PauseButton(TButton):
                    __module__ = __name__
                    initlayer = 10
                    rect = (82,
                     -40,
                     29,
                     20)
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      3,
                      3)]
                    bkimage = 'object/ui/game/record/btn_Pause.img'

                    def OnClick(this):
                        PausePlayRecord()





        class resultDlg(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)
            class children:
                __module__ = __name__
                class level0(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (709,
                     102,
                     40,
                     15)
                    class children:
                        __module__ = __name__
                        class levelIcon(TLevelIcon):
                            __module__ = __name__
                            rect = (0,
                             0,
                             40,
                             15)



                class level1(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + 51),
                     40,
                     15)

                class level2(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 2)),
                     40,
                     15)

                class level3(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 3)),
                     40,
                     15)

                class level4(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 4)),
                     40,
                     15)

                class level5(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 5)),
                     40,
                     15)

                class level6(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 6)),
                     40,
                     15)

                class level7(level0):
                    __module__ = __name__
                    rect = (709,
                     (102 + (51 * 7)),
                     40,
                     15)

                class level8(level0):
                    __module__ = __name__
                    rect = (709,
                     102,
                     40,
                     15)



        class tankBaseInfo1(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 9999
            rect = (495,
             478,
             1,
             1)
            class children:
                __module__ = __name__
                class tankBaseLife(TLabel):
                    __module__ = __name__
                    rect = (1,
                     50,
                     20,
                     12)
                    bkimage = ''
                    caption = '100'
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeType = 2
                    textEdgeColor = (0,
                     255,
                     255,
                     255)

                class tankBaseLifeLine:
                    __module__ = __name__
                    type = 'DYLIFESTRIP'
                    rect = (21,
                     56,
                     90,
                     5)
                    bkimage = 'object/ui/game/img_playerLifeRed.img'
                    totalnum = 100
                    destnum = 100
                    stepnum = 20



        class tankBaseInfo2(tankBaseInfo1):
            __module__ = __name__
            rect = (495,
             468,
             1,
             1)

        class statusBar(TStatic):
            __module__ = __name__
            rect = (0,
             540,
             623,
             60)
            bkimage = 'object/ui/game/dlg_statusBar.img'
            class children:
                __module__ = __name__
                class baseItemNum0(TPicLabel,
                 Static):
                    __module__ = __name__
                    initlayer = 10000
                    rect = (48,
                     42,
                     12,
                     12)
                    bkimage = 'res/uires/number/itemNum.img'
                    caption = '0'

                class baseItemNum1(baseItemNum0):
                    __module__ = __name__
                    rect = (99,
                     42,
                     12,
                     12)

                class baseItemNum2(baseItemNum0):
                    __module__ = __name__
                    rect = (150,
                     42,
                     12,
                     12)

                class itemNum0(baseItemNum0):
                    __module__ = __name__
                    rect = (200,
                     42,
                     12,
                     12)

                class itemNum1(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 1)),
                     42,
                     12,
                     12)

                class itemNum2(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 2)),
                     42,
                     12,
                     12)

                class itemNum3(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 3)),
                     42,
                     12,
                     12)

                class itemNum4(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 4)),
                     42,
                     12,
                     12)

                class itemNum5(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 5)),
                     42,
                     12,
                     12)

                class itemNum6(itemNum0):
                    __module__ = __name__
                    rect = ((200 + (52 * 6)),
                     42,
                     12,
                     12)

                class baseItemIcon0(TStatic):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (185,
                     0,
                     50,
                     50)
                    bkImgFlag = 5

                class baseItemIcon1(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + 54),
                     0,
                     50,
                     50)

                class baseItemIcon2(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + (54 * 2)),
                     0,
                     50,
                     50)

                class baseItemIcon3(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + (54 * 3)),
                     0,
                     50,
                     50)

                class baseItemIcon4(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + (54 * 4)),
                     0,
                     50,
                     50)

                class baseItemIcon5(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + (54 * 5)),
                     0,
                     50,
                     50)

                class baseItemIcon6(baseItemIcon0):
                    __module__ = __name__
                    rect = ((185 + (54 * 6)),
                     0,
                     50,
                     50)

                class itemMask0:
                    __module__ = __name__
                    initlayer = 20000
                    type = 'DYMASK'
                    rect = (177,
                     6,
                     50,
                     50)
                    bkimage = 'object/ui/game/img_itemMask.img'

                class itemMask1(itemMask0):
                    __module__ = __name__
                    rect = ((177 + 54),
                     6,
                     50,
                     50)

                class itemMask2(itemMask0):
                    __module__ = __name__
                    rect = ((177 + (54 * 2)),
                     6,
                     50,
                     50)

                class itemMask3(itemMask0):
                    __module__ = __name__
                    rect = ((177 + (54 * 3)),
                     6,
                     50,
                     50)

                class itemMask4(itemMask0):
                    __module__ = __name__
                    rect = ((177 + (54 * 4)),
                     6,
                     50,
                     50)

                class itemMask5(itemMask0):
                    __module__ = __name__
                    rect = ((177 + (54 * 5)),
                     6,
                     50,
                     50)

                class itemMask6(itemMask0):
                    __module__ = __name__
                    rect = ((177 + (54 * 6)),
                     6,
                     50,
                     50)

                class baseItemCycle:
                    __module__ = __name__
                    initlayer = 20000
                    type = 'DYMASK'
                    rect = (2,
                     2,
                     50,
                     50)
                    bkimage = 'object/ui/game/img_maskCycle.img'



        class chat(TDlg):
            __module__ = __name__
            initlayer = 99999
            alphaspeed = (1 / (40.0 * 0.20000000000000001))
            visible = 0
            rect = (200,
             500,
             332,
             22)
            bkimage = 'res/uires/gameChat/liaotianshurukuang_di.img'

            def OnFrame():
                global chatDlgY
                ui = 'UI.game.chat'
                if (not Win_IsVisible(ui)):
                    return 
                if (chatDlgY > 500):
                    chatDlgY -= (((chatDlgO - 500) * sc_getDeltaTick()) / 200)
                    Win_Move2Pos(ui, 200, int(chatDlgY))
                else:
                    chatDlgY = 500
                    Win_Move2Pos(ui, 200, chatDlgY)


            class children:
                __module__ = __name__
                class bugle(TButton):
                    __module__ = __name__
                    rect = ((284 - 22),
                     3,
                     20,
                     16)
                    num = GetBugleNumber()
                    if (num > 0):
                        bkimage = 'res/uires/gameChat/anniu_bugle_normal.img'
                    else:
                        enable = 0
                        bkimage = 'res/uires/gameChat/anniu_bugle_none.img'

                    def OnClick(this):
                        global isBugle
                        if (isBugle == 0):
                            isBugle = 1
                            Win_SetImg('UI.game.chat.bugle', 'res/uires/gameChat/anniu_bugle_hit.img')
                            Win_SetValue('UI.game.chat.edit', 44, 903)
                            Win_SetText('UI.game.chat.edit', '')
                        else:
                            isBugle = 0
                            Win_SetImg('UI.game.chat.bugle', 'res/uires/gameChat/anniu_bugle_normal.img')
                            Win_SetValue('UI.game.chat.edit', 100, 903)



                class send(TButton):
                    __module__ = __name__
                    rect = ((306 - 22),
                     3,
                     20,
                     16)
                    bkimage = 'res/uires/gameChat/anniu_fasong.img'

                    def OnClick(this):
                        if ((isBugle == 1) and sendSectionChat()):
                            pass



                class expr(TButton):
                    __module__ = __name__
                    enable = 0
                    rect = ((328 - 22),
                     3,
                     20,
                     16)
                    bkimage = 'res/uires/gameChat/anniu_biaoqing.img'

                class edit(TEdit):
                    __module__ = __name__
                    rect = (12,
                     4,
                     ((278 - 12) - 22),
                     12)
                    maxchar = 100
                    drawcolor = (51,
                     113,
                     149,
                     255)
                    textEdgeType = -1



        class chatList:
            __module__ = __name__
            textEdgeColor = (0,
             0,
             0,
             255)
            maxline = 20
            initlayer = 89999
            type = 'TEXTLIST'
            rect = (23,
             402,
             434,
             117)
            rowspace = 6
            textfont = 1

            def OnTimer(this):
                if ((Win_GetCurScreen() == 'game') and Win_SetColorText(this, '', 207, 0, 0, 0)):
                    pass



        class broadcastZone(TStatic):
            __module__ = __name__
            rect = (9,
             520,
             500,
             17)
            class children:
                __module__ = __name__
                class speaker(TRichEdit):
                    __module__ = __name__
                    initlayer = 99999
                    rect = (0,
                     0,
                     400,
                     17)
                    bkimage = 'object/ui/room/img_popo.img'
                    captionrect = (12,
                     3,
                     380,
                     12)
                    textEdgeType = -1
                    iconflag = 1
                    editable = 0



        class hint(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 99999
            rect = (0,
             0,
             334,
             165)
            class children:
                __module__ = __name__
                class words(TLabel):
                    __module__ = __name__
                    rect = (55,
                     20,
                     180,
                     140)
                    drawcolor = (51,
                     113,
                     149,
                     255)
                    textEdgeType = -1





UI.children.game = UI_children_game

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiLogin.py`:

```py
isPreLoadRes = False
uin = -1
isLeague = 0
screenAlphaDir = 0
screenAlpha = 1.0

def screenStartIn():
    global screenAlphaDir
    global screenAlpha
    screenAlphaDir = 0.5
    screenAlpha = 0.0



def screenStartOut():
    global screenAlphaDir
    global screenAlpha
    return 
    screenAlphaDir = -4
    screenAlpha = 1.0


class TScreenMask(TStatic):
    __module__ = __name__
    initlayer = 9999999
    rect = (0,
     0,
     0,
     0)

    def OnDraw():
        global screenAlpha
        if sc_isWindow():
            return 
        if (screenAlphaDir == 0):
            return 
        screenAlpha += (((1.0 / 500.0) * sc_getDeltaTick()) * screenAlphaDir)
        if (screenAlpha > 1.0):
            screenAlpha = 1
            screenAlhpaDir = 0
        elif (screenAlpha < 0):
            screenAlpha = 0
            screenAlhpaDir = 0
        maskAlpha = ((1 - screenAlpha) * 255)
        color = (int(maskAlpha) << 24)
        sc_drawBar(0, 0, 800, 600, color)




def LoginOK():
    do(UI.children.login.children.wait, 'finish')
    print 'login ok'
    GotoUIScreen('selSect')



def LoginFailed():
    do(UI.children.login.children.wait, 'finish')
    Win_ShowWidget('UI.login.loginDlg', True)



def NotifyVNetAuthorizationResult(bSuccess):
    if (bSuccess and Win_IsVisible('UI.login.vnetDlg')):
        doUI('UI.login.vnetDlg.crossBtn', 'OnClick')
    if doUI('UI.login.wait', 'start'):
        PlaySound(soundMain, 1)



def NotifyLoginSuccessType(result):
    global loginType
    if ((result == 1) or (result == 2)):
        loginType = result
    else:
        loginType = 0



def ShowVerifyDlg():
    Win_SetText('UI.login.verifyDlg.verifyEdit', '')
    Win_SetImg('UI.login.verifyDlg.verifyPic', '')
    Win_SetImg('UI.login.verifyDlg.verifyPic', 'res/verify.bmp')
    do(UI.children.login.children.wait, 'finish')
    ui_setCapture('UI.login.verifyDlg')
    PlaySound(soundMain, 1)


class UI_children_login:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     331)
    bkimage = 'ui/selSect/bg_login.img'
    accel = ()

    def OnEnter():
        if (Win_IsVisible('UI.login.wait') or Win_IsVisible('UI.login.vnetDlg')):
            return 
        if (Win_IsVisible('UI.login.verifyDlg') and doUI('UI.login.verifyDlg.confirm', 'OnClick')):
            return 
        if (Win_IsChecked('UI.login.loginDlg.userProtocolCk') and doUI('UI.login.loginDlg.confirmBtn', 'OnClick')):
            pass



    def OnEscape():
        if (Win_IsVisible('UI.login.wait') and do(UI.children.login.children.wait, 'finish')):
            LoginTimeout(1)
        return 1



    def OnInit():
        global uin
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        Win_ShowWidget(uiMenuDlg, 0)
        print 'OnInit login'
        Win_Timer('UI.login.resPreLoader', 1000)
        Win_ShowWidget('UI.login.loginDlg.vnetLoginBtn', CanLoginFromVNet())
        Win_SetFocus('UI.login.loginDlg.player1.pwd')
        Win_SelectSelf('UI.login.loginDlg.player1')
        Win_ShowWidget('UI.login.loginDlg.player1', True)
        uin = GetLoginUinFromCmdLn()
        if ((uin > 0) and Win_SetText('UI.login.loginDlg.player1.id', str(uin))):
            Win_SetText('UI.login.loginDlg.player1.pwd', '********')
            do(UI.children.login.children.wait, 'start')
            LoginFromGetData()
        Win_ShowWidget('UI.login.loginDlg', 1)
        PlayMusic(musicStart, -1)
        Win_SetCheck('UI.login.loginDlg.userProtocolCk', 1)


    class children:
        __module__ = __name__
        class logo(TStatic):
            __module__ = __name__
            initlayer = 100000
            rect = (504,
             18,
             199,
             167)
            bkimage = 'object/ui/login/img_logo.img'

        class loginDlg(TStatic):
            __module__ = __name__
            initlayer = 10001
            rect = (437,
             112,
             346,
             429)
            bkimage = 'object/ui/login/dlg_login.img'
            class children:
                __module__ = __name__
                class player1(TStatic):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (0,
                     0,
                     0,
                     0)
                    groupstop = 1
                    class children:
                        __module__ = __name__
                        class id(TEditID):
                            __module__ = __name__
                            editable = 1
                            rect = (139,
                             104,
                             140,
                             24)
                            captionrect = (0,
                             6,
                             100,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor

                            def OnMsgBoxOk(h):
                                Win_SetFocus('UI.login.loginDlg.player1.id')



                            def OnTab():
                                Win_SetFocus('UI.login.loginDlg.player1.pwd')



                        class pwd(TEditPassword):
                            __module__ = __name__
                            editable = 1
                            rect = (139,
                             147,
                             140,
                             24)
                            captionrect = (0,
                             6,
                             100,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor

                            def OnMsgBoxOk(h):
                                Win_SetFocus('UI.login.loginDlg.player1.pwd')



                            def OnTab():
                                Win_SetFocus('UI.login.loginDlg.player1.id')





                class playAnimBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      2,
                      2)]
                    rect = ((475 - 437),
                     (321 - 112),
                     98,
                     31)
                    bkimage = 'object/ui/login/btn_playAnim.img'

                    def OnClick(this):
                        PlayCG()



                class userProtocolCk(TStdCheck):
                    __module__ = __name__
                    rect = (150,
                     185,
                     20,
                     17)
                    bkimagepos = (0,
                     5)

                    def OnClick(this):
                        ui = 'UI.login.loginDlg'
                        if (Win_IsChecked((ui + '.userProtocolCk')) and Win_EnableWidget((ui + '.confirmBtn'), True)):
                            pass
                        PlaySound(soundUI, 1)



                class agreeUserProtocal(THyperLink):
                    __module__ = __name__
                    rect = (162,
                     187,
                     130,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    URL = 'http://qqtang.qq.com/service/license.html'
                    caption = '\xd2\xd1\xd4\xc4\xb6\xc1\xb2\xa2\xcd\xac\xd2\xe2\xd3\xce\xcf\xb7\xd0\xad\xd2\xe9'

                class helpBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = ((466 - 437),
                     (371 - 112),
                     76,
                     31)
                    bkimage = 'object/ui/login/btn_help.img'

                    def OnClick(this):
                        ui_jumpHelpWeb()



                class confirmBtn(TButton):
                    __module__ = __name__
                    initlayer = 10003
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      2,
                      2)]
                    rect = ((624 - 437),
                     (371 - 112),
                     80,
                     31)
                    bkimage = 'object/ui/login/btn_login.img'

                    def OnClick(this):
                        global uin
                        id = int(Win_GetText('UI.login.loginDlg.player1.id'))
                        uin = id
                        pw = Win_GetText('UI.login.loginDlg.player1.pwd')
                        if ((uin < 10001) and Win_ShowMsgBox('\xc4\xfa\xca\xe4\xc8\xeb\xc1\xcb\xce\xde\xd0\xa7\xb5\xc4QQ\xba\xc5', '', 0, 'Ui.login.loginDlg.player1.id', 0)):
                            ui_msgBox(2)
                            return 
                        if (('' == pw) and Win_ShowMsgBox('\xc7\xeb\xca\xe4\xc8\xeb\xc3\xdc\xc2\xeb', '', 0, 'Ui.login.loginDlg.player1.pwd', 0)):
                            ui_msgBox(2)
                            return 
                        Login(id, 0, pw, '')
                        doUI('UI.login.wait', 'start')
                        PlaySound(soundMain, 1)



                class quitBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      2,
                      2)]
                    rect = ((709 - 437),
                     (371 - 112),
                     41,
                     31)
                    bkimage = 'object/ui/login/btn_quit.img'
                    bkImgFlag = dt_center

                    def OnClick(this):
                        PlaySound(soundLeave, 1)
                        Quit()



                class vnetLoginBtn(TButton):
                    __module__ = __name__
                    visible = 1
                    rect = (150,
                     (321 - 112),
                     76,
                     31)
                    bkimage = 'object/ui/login/btn_vnetLogin.img'

                    def OnClick(this):
                        Win_EnableWidget('UI.login.loginDlg', 0)
                        Win_ShowWidget('UI.login.vnetDlg', 1)
                        sc_ShowLoginVNetWeb(435, 215, 312, 64)
                        PlaySound(soundMain, 1)





        class vnetDlg(TDlg):
            __module__ = __name__
            visible = 0
            initlayer = 200000
            rect = (420,
             200,
             364,
             104)
            bkimage = 'object/ui/login/dlg_vnetLogin.img'
            class children:
                __module__ = __name__
                class crossBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (335,
                     4,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'

                    def OnClick(this):
                        sc_DestroyLoginVNetWeb()
                        Win_ShowWidget('UI.login.vnetDlg', False)
                        Win_EnableWidget('UI.login.loginDlg', 1)





        class wait(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            darkBG = 1
            rect = (287,
             320,
             226,
             95)
            bkimage = 'object/ui/login/dlg_wait.img'

            def start():
                global waitNum
                waitNum = 30
                Win_SetText('UI.login.wait.numberTip', ('%02d' % waitNum))
                Win_Timer('UI.login.wait.numberTip', 1000)
                ui_setCapture('UI.login.wait')



            def finish():
                Win_Timer('UI.login.wait.numberTip', 0)
                Win_ShowWidget('UI.login.wait', false)


            class children:
                __module__ = __name__
                class numberTip:
                    __module__ = __name__
                    type = 'NUMLABEL'
                    rect = (5,
                     -130,
                     206,
                     130)
                    bkimage = 'object/ui/common/number1.img'
                    textsize = 103
                    textwidth = 103
                    textheight = 130

                    def OnTimer(this):
                        global waitNum
                        waitNum -= 1
                        if ((waitNum < 0) and do(UI.children.login.children.wait, 'finish')):
                            LoginTimeout(0)
                            return 
                        Win_SetText(this, ('%02d' % waitNum))



                class linkAnim(TStatic):
                    __module__ = __name__
                    rect = (17,
                     30,
                     192,
                     21)
                    bkimage = 'object/ui/login/img_link.img'
                    framescheme = [(0,
                      1,
                      0,
                      1,
                      0,
                      1,
                      0,
                      1)]

                class cancelBtn(TButton):
                    __module__ = __name__
                    rect = (91,
                     55,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        do(UI.children.login.children.wait, 'finish')
                        LoginTimeout(1)





        class verifyDlg(TStatic):
            __module__ = __name__
            initlayer = 200000
            visible = 0
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/login/dlg_verify.img'
            class children:
                __module__ = __name__
                class verifyEdit(TEdit):
                    __module__ = __name__
                    editable = 1
                    maxchar = 4
                    rect = (50,
                     120,
                     100,
                     24)
                    captionrect = (0,
                     6,
                     100,
                     12)
                    drawcolor = darkColor
                    textEdgeType = -1

                class verifyPic(TStatic):
                    __module__ = __name__
                    rect = (43,
                     154,
                     1,
                     1)

                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (190,
                     170,
                     129,
                     30)
                    bkimage = 'object/ui/login/btn_nextpic.img'

                    def OnClick(this):
                        GetVerifyCode()



                class confirm(TButton):
                    __module__ = __name__
                    rect = (160,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        verifyCode = Win_GetText('UI.login.verifyDlg.verifyEdit')
                        if ((verifyCode == '') and ui_msgBox(2)):
                            Win_ShowMsgBox('\xc7\xeb\xca\xe4\xc8\xeb\xd1\xe9\xd6\xa4\xc2\xeb!', '', 0, 'UI.SysMsgbox', -1)
                            return 
                        Win_ShowWidget('UI.login.verifyDlg', False)
                        PlaySound(soundMain, 1)
                        LoginQQWithVerifyCode(verifyCode)



                class crossBtn(TButton):
                    __module__ = __name__
                    rect = (340,
                     6,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.login.verifyDlg', False)
                        PlaySound(soundMain, 1)





        class resPreLoader(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                global isPreLoadRes
                Win_Timer('UI.login.resPreLoader', 0)
                if (not isPreLoadRes):
                    isPreLoadRes = True
                    PreLoadRes()





UI.children.login = UI_children_login

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiLogo.py`:

```py
class UI_children_logo:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)

    def OnInit():
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        Win_ShowWidget(uiMenuDlg, 0)
        NotifyMainWndReady(int(500))
        Win_SetValue('UI.logo.bgLogo', 1, 41)
        Win_SetValue('UI.logo.bgLogo', 2, 901)
        Win_Timer('UI.logo.InTimer', 200)


    class children:
        __module__ = __name__
        class bgLogo(TStatic):
            __module__ = __name__
            initlayer = 100000
            rect = (0,
             0,
             800,
             600)
            bkimage = 'object/ui/bg/bg_logo.img'

        class InTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                Win_SetValue('UI.logo.bgLogo', 0.02, 41)
                Win_SetValue('UI.logo.bgLogo', 1, 901)
                Win_Timer(this, 0)
                Win_Timer('UI.logo.StopTimer', 3000)



        class StopTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                Win_SetValue('UI.logo.bgLogo', 0.01, 41)
                Win_SetValue('UI.logo.bgLogo', 2, 901)
                Win_Timer(this, 0)
                Win_Timer('UI.logo.OutTimer', 2000)



        class OutTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                GotoUIScreen('login')
                Win_Timer(this, 0)





UI.children.logo = UI_children_logo

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiMain.py`:

```py
uiPlayerInfoDlg = 'UI.playerInfoDlg'
uiPvpInfoDlg = (uiPlayerInfoDlg + '.pvpInfoDlg')
uiPveInfoDlg = (uiPlayerInfoDlg + '.pveInfoDlg')
uiModeInfoDlg = (uiPlayerInfoDlg + '.modeInfoDlg')
uiSetupDlg = 'UI.setupDlg'
uiGuideBar = 'UI.guideBar'
uiSocialityDlg = 'UI.socialityDlg'
uiMenuDlg = 'UI.menuDlg'
uiPlayerListDlg = (uiSocialityDlg + '.playerListDlg')
uiKinDlg = (uiSocialityDlg + '.kinDlg')
uiKinMemberDlg = (uiKinDlg + '.kinmemberDlg')
uiKinManagerDlg = (uiKinDlg + '.kinmanagerDlg')
uiKinCreateHintDlg = 'UI.createkinhintDlg'
uiKinCreateDlg = 'UI.createkinDlg'
uitopKinDlg = 'UI.topkinDlg'
uiKinInfoDlg = 'UI.kinInfoDlg'
uiKinInviteDlg = 'UI.kinInviteDlg'
uiKinTipDlg = 'UI.kinTipDlg'
uiAddFriendDlg = 'UI.requestMakeFriendsDlg'
uiBeAddedFriendDlg = 'UI.friendDlg'
uiPlayerMenu = 'UI.playerMenu'
uiSparkDlg = 'UI.sparkDlg'
uiReceiveSparkDlg = 'UI.receiveSparkDlg'
uiMarriageDlg = 'UI.marriageInfoDlg'
uiDivorceDlg = 'UI.divorceDlg'
uiModifyLoveWordDlg = 'UI.modifyLoveWordDlg'
uiMarriageConfirmDlg = 'UI.marriageConfirmDlg'
uiWeddingOverDlg = 'UI.weddingOverDlg'
uiWeddingDlg = 'UI.room.weddingDlg'
uiTaskSelDlg = 'UI.taskSelectDlg'
uiSetRecorderDlg = 'UI.SetRecorderDlg'
uiSelroomPlayerList = 'UI.selRoom.playerListDlg'
uiTaskDlg = 'UI.shop.taskDlg'
uiRefineDlg = 'UI.shop.refineDlg'
uiForgeDlg = 'UI.shop.refineDlg.forgeDlg'
uiComposeDlg = 'UI.shop.refineDlg.composeDlg'
uiAvatarForgeDlg = 'UI.shop.refineDlg.AvatarForgeDlg'
uiForgeConfirmDlg = 'UI.shop.refineDlg.forgeConfirmDlg'
uiRoomStorageDlg = 'UI.storageDlg'
uiShopStorageDlg = 'UI.shop.storageDlg'
uiSelModeDlg = 'UI.room.selModeDlg'
uiModifyRoomDlg = 'UI.room.modifyRoomDlg'
uiMatchRoomDlg = 'UI.room.matchDlg'
uiGamePlayerList = 'UI.game.playerListDlg'
uiPvePlayerList = 'UI.game.pvePlayerList'
uiPveFuncDlg = 'UI.game.pveFuncDlg'
uiPetPan = 'UI.selRoom.petPan'
uiC2CInviteDlg = 'UI.C2CInvite'
uiC2CDealDlg = 'UI.C2CDealDlg'
uiPawnShopDlg = 'UI.selRoom.pawnshop'
lightColor = (255,
 255,
 255,
 255)
zoneChooseColor = (255,
 250,
 236,
 255)
darkColor = (102,
 51,
 0,
 255)
maskColor = (51,
 51,
 51,
 255)
kinColor = (153,
 244,
 255,
 255)
normalNameColor = (199,
 242,
 252,
 255)
memberNameColor = (255,
 189,
 222,
 255)
broadcastColor = maskColor
MyExecFile('res/uires/uiConst.pyc')
MyExecFile('res/uires/uiTemplate.pyc')
MyExecFile('object/itemCFG.py')
MyExecFile('object/commodityCFG.py')
MyExecFile('map/mapDesc.py')
MyExecFile('res/uires/uiFunc.pyc')
MyExecFile('res/uires/levelCFG.pyc')
yesMove = 0
mark_task = 0
mark_shopPetTab = 0
joinMemberURL = ''
exitFlag = 0
shopEntry = 0
loginType = 0
friendUin = 0
beAddUin = 0
dealUin = 0
friendName = ''
beSparkedUin = 0
beSparkedNick = ''
sparkUin = 0
sparkNick = ''
weddingModeID = 0
queryingUin = 0
beInWeddingRoom = 0
weddingEffectFile = 'effect\\lihua2.eff'
priestwords = ''
beWedding = 0
practiceMode = 0
kinMemberCnt = 0
CurrentPos = 0
defkinDlgCnt = 7
ActiveMemberPos = 999999
ShowOnline = 0
OnlineCnt = 0
oldTotemEventCnt = -1
customtotemID = 0
totemPage = 0
totemPageNum = 2
lookupKinID = 0
totalStorageCnt = 0
defShopStorageCnt = 48
shopStoragePos = 0
defRoomStorageCnt = 20
roomStoragePos = 0
defRoomEquipCnt = 7
curRoomStorageIdx = -1
curEquipIdx = -1
curStorageID = 0
uiStorageIdx = 0
defMyPropC2CDealDlgCnt = 15
MyPropC2CDealDlgPos = 0
curPropC2CDealIdx = -1
uiPropC2CInx = 0
curBiddingIdx = -1
MyBiddingList = []
totaldstGoodsListCnt = 0
C2CDealDstGoodsPos = 0
ticketitemid = 1800
residualTicket = 0
bC2CDealShow = 0
bPawnShopShow = 0
MyDealStorageListCnt = 0
totalP2PDealPropCnt = 0
InvalidIdx = -1
inviteDealUin = 0

def CHECK_PET(ID):
    if ((ID > 25001) and (ID < 26000)):
        return 1
    return 0



def CHECK_PET_RELATION(ID):
    return ((ID >= 25001) and (ID <= 29000))


class storageList:
    __module__ = __name__
    items = []

    def clear(this):
        global roomStoragePos
        global totalStorageCnt
        global shopStoragePos
        storageList.items = []
        totalStorageCnt = 0
        shopStoragePos = 0
        roomStoragePos = 0



    def update(this):
        global roomStoragePos
        global totalStorageCnt
        global shopStoragePos
        storageList.items = GetStorage()
        totalStorageCnt = len(storageList.items)
        shopStoragePos = 0
        roomStoragePos = 0
        return totalStorageCnt



    def at(this, itemIdx):
        if (itemIdx >= len(storageList.items)):
            return None
        return storageList.items[itemIdx]



g_StorageList = storageList()
class P2PDealPropList:
    __module__ = __name__
    items = []

    def clear(this):
        global totalP2PDealPropCnt
        P2PDealPropList.items = []
        totalP2PDealPropCnt = 0



    def update(this):
        global totalP2PDealPropCnt
        P2PDealPropList.items = GetP2PDealProplist()
        totalP2PDealPropCnt = len(P2PDealPropList.items)
        return totalP2PDealPropCnt



    def at(this, itemIdx):
        if (itemIdx >= len(P2PDealPropList.items)):
            return None
        return P2PDealPropList.items[itemIdx]



g_P2PDealPropList = P2PDealPropList()
class dstGoodsList:
    __module__ = __name__
    items = []

    def clear(this):
        global totaldstGoodsListCnt
        global C2CDealDstGoodsPos
        dstGoodsList.items = []
        totaldstGoodsListCnt = 0
        C2CDealDstGoodsPos = 0



    def update(this):
        global totaldstGoodsListCnt
        global C2CDealDstGoodsPos
        dstGoodsList.items = GetdstGoods()
        totaldstGoodsListCnt = len(dstGoodsList.items)
        C2CDealDstGoodsPos = 0
        return totaldstGoodsListCnt



    def at(this, itemIdx):
        if (itemIdx >= len(dstGoodsList.items)):
            return None
        return dstGoodsList.items[itemIdx]



g_DstGoodsList = dstGoodsList()
class MyDealStorageList:
    __module__ = __name__
    items = []

    def clear(this):
        global MyDealStorageListCnt
        MyDealStorageList.items = []
        MyDealStorageListCnt = 0



    def update(this):
        global MyDealStorageListCnt
        MyDealStorageList.items = GetDealStorage()
        MyDealStorageListCnt = len(MyDealStorageList.items)
        return MyDealStorageListCnt



    def at(this, itemIdx):
        if (itemIdx >= len(MyDealStorageList.items)):
            return None
        return MyDealStorageList.items[itemIdx]



g_MyDealStorageList = MyDealStorageList()

def os_join(dir, fname):
    if (dir[-1] == '\\'):
        return (dir + fname)
    else:
        return ((dir + '\\') + fname)



def os_dirname(dir):
    for i in range((len(dir) - 1), -1, -1):
        if (dir[i] == '\\'):
            return dir[0:i]

    return dir


class LogicalDrives:
    __module__ = __name__

    def getDrivers(self):
        bitmaks = int(win32_GetLogicalDrives())
        drivers = []
        for i in range(32):
            if ((bitmaks & (1 << i)) and drivers.append((chr((ord('A') + i)) + ':\\'))):
                pass

        return drivers



dr = LogicalDrives()
curFile = -1

def go2setup(_uin):
    ui_setCapture(uiSetupDlg)
    Device().restore()
    KeyLayout().restore()
    PlaySound(soundUI, 1)



def NotifyLoginSuccessType(value):
    global loginType
    loginType = value



def ShowMemoryStatus():
    sc_LogOutMemoryStatus()



def changeMenuMode(mode):
    if ((0 == mode) and Win_ShowWidget((uiPlayerMenu + '.addBtn'), 1)):
        Win_ShowWidget((uiPlayerMenu + '.deleteBtn'), 0)
        Win_EnableWidget((uiPlayerInfoDlg + '.addFriendBtn'), 1)



def ReceivedRequestAddFriend(uin):
    global beAddUin
    beAddUin = uin
    Win_SetCheck((uiBeAddedFriendDlg + '.addFriend'), 1)
    Win_SetFocus((uiBeAddedFriendDlg + '.text'))
    ui_setCapture(uiBeAddedFriendDlg)



def initAllUse():
    Win_ShowWidget(uiSetupDlg, False)
    Win_ShowWidget(uiPlayerInfoDlg, False)



def ui_OnMsgBoxResult(h, isOK):
    print 'ui_OnMsgBoxResult',
    print h,
    print isOK
    if (0 == isOK):
        return 
    if (-1 == h):
        exec execStr
    else:
        if ((-2 == h) and doUI('UI.room.selMapDlg.crossBtn', 'OnClick')):
            LeaveRoom(uin)
            ui_jumpLeagueWeb()


class Device:
    __module__ = __name__

    def __restoreUI(this):
        flag = 0
        ui = uiSetupDlg
        Win_SetCheck((ui + '.soundChk'), device.sound)
        Win_SetCheck((ui + '.musicChk'), device.music)
        Win_SetCheck((ui + '.fullScreenChk'), device.fullScreen)
        Win_SetCheck((ui + '.fxChk'), device.effect)
        Win_SetCheck((ui + '.Begindlg'), device.showNext)
        flag = device.render
        print 'flag = %d',
        print flag
        if ((flag == 3) and Win_SetCheck((ui + '.softromance'), 1)):
            pass



    def restore(this):

        def restoreDevice():
            if (device.music and ResumeMusic()):
                pass
            if (device.sound and ResumeSound()):
                pass


        this._Device__restoreUI()
        restoreDevice()



    def save(this):

        def saveSet():
            ui = uiSetupDlg
            device.sound = Win_IsChecked((ui + '.soundChk'))
            device.music = Win_IsChecked((ui + '.musicChk'))
            device.fullScreen = Win_IsChecked((ui + '.fullScreenChk'))
            device.effect = Win_IsChecked((ui + '.fxChk'))
            device.showNext = Win_IsChecked((ui + '.Begindlg'))
            if Win_IsChecked((ui + '.softromance')):
                device.render = 3
            else:
                device.render = 1



        def saveFile():
            f = open('devConfig.txt', 'wt')
            f.write('class device:\n')
            for i in device.__dict__.items():
                key = i[0]
                if ((key[:2] != '__') and f.write((('  ' + key) + '= '))):
                    f.write((str(i[1]) + '\n'))

            f.close()


        saveSet()
        saveFile()



class keyLayout:
    __module__ = __name__
    moveUp = -1
    moveDown = -1
    moveLeft = -1
    moveRight = -1
    putBomb = -1
    switchItem = -1
    smartUseItem = -1
    chat = -1
    customChat = -1
    useItem0 = -1
    useItem1 = -1
    useItem2 = -1
    useItem3 = -1
    useItem4 = -1
    useItem5 = -1
    useItem6 = -1
    shop0 = -1
    shop1 = -1
    shop2 = -1
    shop3 = -1
    shop4 = -1
    shop5 = -1
    shop6 = -1
    system = -1
    quickHelp = -1

class KeyLayout:
    __module__ = __name__

    def restore(this):
        sc_keyLayout_restore(uin)
        ui = uiSetupDlg
        Win_SetValue((ui + '.up'), keyLayout.moveUp)
        Win_SetValue((ui + '.down'), keyLayout.moveDown)
        Win_SetValue((ui + '.left'), keyLayout.moveLeft)
        Win_SetValue((ui + '.right'), keyLayout.moveRight)
        Win_SetValue((ui + '.putBomb'), keyLayout.putBomb)
        Win_SetValue((ui + '.switchItem'), keyLayout.switchItem)
        Win_SetValue((ui + '.smartUseItem'), keyLayout.smartUseItem)
        Win_SetValue((ui + '.chat'), keyLayout.chat)
        Win_SetValue((ui + '.customChat'), keyLayout.customChat)
        Win_SetValue((ui + '.useItem0'), keyLayout.useItem0)
        Win_SetValue((ui + '.useItem1'), keyLayout.useItem1)
        Win_SetValue((ui + '.useItem2'), keyLayout.useItem2)
        Win_SetValue((ui + '.useItem3'), keyLayout.useItem3)
        Win_SetValue((ui + '.useItem4'), keyLayout.useItem4)
        Win_SetValue((ui + '.useItem5'), keyLayout.useItem5)
        Win_SetValue((ui + '.useItem6'), keyLayout.useItem6)
        Win_SetValue((ui + '.shop0'), keyLayout.shop0)
        Win_SetValue((ui + '.shop1'), keyLayout.shop1)
        Win_SetValue((ui + '.shop2'), keyLayout.shop2)
        Win_SetValue((ui + '.shop3'), keyLayout.shop3)
        Win_SetValue((ui + '.shop4'), keyLayout.shop4)
        Win_SetValue((ui + '.shop5'), keyLayout.shop5)
        Win_SetValue((ui + '.shop6'), keyLayout.shop6)
        Win_SetValue((ui + '.system'), keyLayout.system)



    def save(this):
        ui = uiSetupDlg
        keyLayout.moveUp = int(Win_GetValue((ui + '.up')))
        keyLayout.moveDown = int(Win_GetValue((ui + '.down')))
        keyLayout.moveLeft = int(Win_GetValue((ui + '.left')))
        keyLayout.moveRight = int(Win_GetValue((ui + '.right')))
        keyLayout.putBomb = int(Win_GetValue((ui + '.putBomb')))
        keyLayout.switchItem = int(Win_GetValue((ui + '.switchItem')))
        keyLayout.smartUseItem = int(Win_GetValue((ui + '.smartUseItem')))
        keyLayout.chat = int(Win_GetValue((ui + '.chat')))
        keyLayout.customChat = int(Win_GetValue((ui + '.customChat')))
        keyLayout.useItem0 = int(Win_GetValue((ui + '.useItem0')))
        keyLayout.useItem1 = int(Win_GetValue((ui + '.useItem1')))
        keyLayout.useItem2 = int(Win_GetValue((ui + '.useItem2')))
        keyLayout.useItem3 = int(Win_GetValue((ui + '.useItem3')))
        keyLayout.useItem4 = int(Win_GetValue((ui + '.useItem4')))
        keyLayout.useItem5 = int(Win_GetValue((ui + '.useItem5')))
        keyLayout.useItem6 = int(Win_GetValue((ui + '.useItem6')))
        keyLayout.shop0 = int(Win_GetValue((ui + '.shop0')))
        keyLayout.shop1 = int(Win_GetValue((ui + '.shop1')))
        keyLayout.shop2 = int(Win_GetValue((ui + '.shop2')))
        keyLayout.shop3 = int(Win_GetValue((ui + '.shop3')))
        keyLayout.shop4 = int(Win_GetValue((ui + '.shop4')))
        keyLayout.shop5 = int(Win_GetValue((ui + '.shop5')))
        keyLayout.shop6 = int(Win_GetValue((ui + '.shop6')))
        keyLayout.system = int(Win_GetValue((ui + '.system')))
        sc_keyLayout_save(uin)
        LoadShopKeyboardLayout()




def ui_msgBox(type):
    global yesMove
    print 'ui_msgBox',
    print type
    sc_HideWeb('kinMatch')
    sc_HideWeb('kinTeam')
    Win_SetCapture('UI.SysMsgbox')
    Win_MovePos('UI.SysMsgbox.yesbtn', -yesMove, 0)
    yesMove = 0
    Win_ShowWidget('UI.SysMsgbox.nobtn', True)
    if ((1 == type) and Win_SetImg('UI.SysMsgbox.yesbtn', 'object/ui/common/btn_agree.img')):
        Win_SetImg('UI.SysMsgbox.nobtn', 'object/ui/common/btn_refuse.img')



def recv_FriendAvt(uin, path):
    print uin,
    print path
    Win_SetImg((uiPlayerInfoDlg + '.avt'), path)
    Win_SetText((uiPlayerInfoDlg + '.avtUin'), str(uin))


class TLevelIcon(TStatic):
    __module__ = __name__
    rect = (0,
     0,
     39,
     15)
    class children:
        __module__ = __name__
        class minLevel(TStatic):
            __module__ = __name__
            framescheme = [(0,
              99,
              0,
              99,
              0,
              99,
              0,
              99)]
            framespeed = 0.14999999999999999
            loopspeed = 4.0
            bkimage = 'object/ui/level/tie/t01.img'
            rect = (0,
             0,
             39,
             15)

        class mainLevel(minLevel):
            __module__ = __name__
            rect = (0,
             0,
             39,
             15)
            bkimage = 'object/ui/level/medal/001.img'



class TTip(TStatic):
    __module__ = __name__
    initlayer = 999999
    visible = 0
    enable = 0

class MemberList:
    __module__ = __name__

    def getCnt(this):
        global kinMemberCnt
        kinMemberCnt = GetPlayerCnt(2)
        return kinMemberCnt



    def getOnlineCnt(this):
        global OnlineCnt
        OnlineCnt = GetPlayerCnt(3)
        return OnlineCnt



    def __get(this, i):
        info = CNil()
        if (ShowOnline == 0):
            ii = fetch_PlayerInfoInPlayerList(i, 2)
        else:
            ii = fetch_PlayerInfoInPlayerList(i, 3)
        a = ii.m_PlayerInfo
        gameInfo = a.m_stGameInfo
        info.Uin = a.m_dwPlayerUin
        info.nickname = a.m_szPlayerNickname.replace('\n', '')
        if (info.Uin != 0):
            info.gender = (1 == int(a.m_bGender))
        if (info.Uin != 0):
            info.grade = Level().getInfo(gameInfo.m_dwPoint)
        info.position = GetKinPositionByUin(info.Uin)
        info.honor = GetKinMemberHonor(info.Uin, 0)
        return info



    def at(this, Idx):
        if (Idx >= kinMemberCnt):
            return None
        return this._MemberList__get(Idx)




def ui_updateMemberList():
    global kinMemberCnt
    global ActiveMemberPos
    global CurrentPos
    Win_SetText((uiKinMemberDlg + '.text'), '')
    kininfo = GetInviteKinInfo(1)
    kinname = kininfo.m_szName
    kinname = kinname.replace('\n', '')
    kinname = kinname.replace("'", "\\'")
    Win_SetText((uiKinMemberDlg + '.name'), kinname)
    notification = kininfo.m_szNotification
    notification = notification.replace("'", "\\'")
    Win_SetText((uiKinMemberDlg + '.text'), notification)
    kinMemberCnt = MemberList().getCnt()
    if (ShowOnline == 0):
        ShowCnt = MemberList().getCnt()
    else:
        ShowCnt = MemberList().getOnlineCnt()
    ActiveMemberPos = 999999
    CurrentPos = min(CurrentPos, (ShowCnt - defkinDlgCnt))
    CurrentPos = max(CurrentPos, 0)
    for i in range(defkinDlgCnt):
        ui = (uiKinMemberDlg + ('.MemberPlayer%d' % i))
        Win_SetText((ui + '.NickName'), '')
        Win_SetText((ui + '.Grade'), '')
        Win_SetImg((ui + '.genderPic'), '')
        Win_SetText((ui + '.Position'), '')
        Win_SetText((ui + '.honor'), '')
        idx = (CurrentPos + i)
        Win_SetCheck(ui, 0)
        if ((idx >= ShowCnt) and Win_SetText((ui + '.NickName'), '')):
            Win_SetText((ui + '.Grade'), '')
            Win_SetImg((ui + '.genderPic'), '')
            Win_SetText((ui + '.Position'), '')
            Win_SetText((ui + '.honor'), '')
            Win_EnableWidget(ui, 0)
            continue

    Win_SetPos((uiKinMemberDlg + '.scroll'), Win_GetPos((uiKinMemberDlg + '.scroll')))
    doUI((uiKinMemberDlg + '.scroll'), 'OnPosChange')
    Win_SetText((uiKinMemberDlg + '.kinCount'), str(kinMemberCnt))
    onlineCnt = GetPlayerCnt(3)
    Win_SetText((uiKinMemberDlg + '.OnlineCount'), str(onlineCnt))
    Win_SetText((uiKinMemberDlg + '.kinHonor'), str(GetKinParam(1)))



def ShowkininviteDlg():
    info = GetInviteKinInfo(0)
    name = info.m_szName
    if (info.m_iKinSection == 1):
        kinSection = '\xb5\xe7\xd0\xc5'
    else:
        kinSection = '\xcd\xf8\xcd\xa8'
    playerinfo = GetPlayerInfoByUin(info.m_dwUin)
    governor = (((playerinfo.m_szPlayerNickname + '[') + str(info.m_dwUin)) + ']')
    Win_SetText((uiKinInviteDlg + '.name'), name)
    Win_SetText((uiKinInviteDlg + '.kininfo_status'), kinSection)
    Win_SetText((uiKinInviteDlg + '.kininfo_governor'), governor)
    Win_SetText((uiKinInviteDlg + '.kininfo_size'), str(((info.m_dwStatus & -1048576) >> 20)))
    Win_SetText((uiKinInviteDlg + '.kininfo_grade'), str(info.m_iGrade))
    Win_SetText((uiKinInviteDlg + '.kininfo_honor'), str(info.m_iLastHonor))
    Win_SetText((uiKinInviteDlg + '.kininfo_MemberCount'), str(info.m_wMemberNum))
    if ((info.m_wContentLen > 0) and Win_SetText((uiKinInviteDlg + '.kininfo_enounce'), info.m_szContent)):
        pass
    ui_setCapture(uiKinInviteDlg)



def ClearkinInfoDlg():
    Win_SetText((uiKinInfoDlg + '.kinSection'), '')
    Win_SetText((uiKinInfoDlg + '.kinname'), '')
    Win_SetText((uiKinInfoDlg + '.governor'), '')
    Win_SetText((uiKinInfoDlg + '.Size'), '')
    Win_SetText((uiKinInfoDlg + '.Grade'), '')
    Win_SetText((uiKinInfoDlg + '.Credit'), '')
    Win_SetText((uiKinInfoDlg + '.MemberCount'), '')
    Win_SetText((uiKinInfoDlg + '.Proclaim'), '')



def ShowkinInfoDlg():
    ClearkinInfoDlg()
    info = GetInviteKinInfo(0)
    name = info.m_szName
    name = name.replace('\n', '')
    name = name.replace("'", "\\'")
    if (info.m_iKinSection == 1):
        kinSection = '\xb5\xe7\xd0\xc5'
    else:
        kinSection = '\xcd\xf8\xcd\xa8'
    playerinfo = GetPlayerInfoByUin(info.m_dwUin)
    governor = (((playerinfo.m_szPlayerNickname + '[') + str(info.m_dwUin)) + ']')
    Win_SetText((uiKinInfoDlg + '.kinSection'), kinSection)
    Win_SetText((uiKinInfoDlg + '.kinname'), name)
    Win_SetText((uiKinInfoDlg + '.governor'), governor)
    Win_SetText((uiKinInfoDlg + '.Size'), str(((info.m_dwStatus & -1048576) >> 20)))
    Win_SetText((uiKinInfoDlg + '.Grade'), str(info.m_iGrade))
    Win_SetText((uiKinInfoDlg + '.Credit'), str(info.m_iLastHonor))
    Win_SetText((uiKinInfoDlg + '.MemberCount'), str(info.m_wMemberNum))
    if ((info.m_wContentLen > 0) and Win_SetText((uiKinInfoDlg + 'Proclaim'), info.m_szContent)):
        pass
    Win_ShowWidget(uiPlayerInfoDlg, 0)
    ui_setCapture(uiKinInfoDlg)



def settotemPage(page, pageNum):
    Win_SetText((uiKinManagerDlg + '.totemBtn.totemDlg.pageLab'), ('%d/%d' % ((page + 1),
     pageNum)))
    facePage = page
    start = (page * 24)
    for k in range(24):
        i = (start + k)
        ui = ((uiKinManagerDlg + '.totemBtn.totemDlg.box.face') + str(k))
        if ((i < len(faceIconList)) and Win_SetImg(ui, ('object/ui/kinTotem/%03d.img' % ((i + 1))))):
            Win_ShowWidget(ui, True)



class TTipDown(TLabel,
 Static):
    __module__ = __name__
    enable = 0
    initlayer = 999999
    bkimage = 'res/uires/help/help_small.img'
    rect = (0,
     0,
     138,
     71)
    drawcolor = (0,
     0,
     0,
     255)
    textEdgeColor = (10,
     0,
     0,
     0)
    caption = 'nameLess1\nnameLess2'
    captionrect = (9,
     24,
     121,
     38)
    class children:
        __module__ = __name__
        class title(TStatic):
            __module__ = __name__
            bkimage = 'res/uires/help/help_tittle.img'
            rect = (9,
             4,
             40,
             16)

        class point(TStatic):
            __module__ = __name__
            bkimage = 'res/uires/help/arrow_up_left.img'
            rect = (41,
             -11,
             10,
             10)




def InitRecordFileDlg():
    doUI(uiSetRecorderDlg, 'initMe')
    ui_setCapture(uiSetRecorderDlg)



def updateKinManagerDlg():
    doUI((uiKinDlg + '.kinmanagerTab'), 'OnClick')



def C2CInviteNegotiate(dstUin, iNegotiate):
    global dealUin
    if bC2CDealShow:
        return 
    dealUin = dstUin
    C2CInviteDeal(dstUin, iNegotiate)



def ShowC2CInviteDlg(Uin):
    global inviteDealUin
    print ('bC2CDealShow = %d' % bC2CDealShow)
    if (bC2CDealShow == 1):
        return 
    inviteDealUin = Uin
    Win_ShowWidget(uiSocialityDlg, 0)
    sc_HideWeb('kinMatch')
    sc_HideWeb('kinTeam')
    Win_ShowWidget(uiMenuDlg, 0)
    Win_ShowWidget(uiPlayerInfoDlg, False)
    Win_ShowWidget(uiAddFriendDlg, 0)
    Win_ShowWidget(uiBeAddedFriendDlg, 0)
    Win_ShowWidget(uiKinInfoDlg, 0)
    Win_ShowWidget(uiSetupDlg, 0)
    Win_ShowWidget(uiKinInviteDlg, 0)
    Win_ShowWidget(uiKinTipDlg, 0)
    Win_ShowWidget(uiRoomStorageDlg, 0)
    Win_ShowWidget(uiPetPan, 0)
    ui_setCapture(uiC2CInviteDlg)



def UpdateMyPropC2CDealDlg():
    if ((totalP2PDealPropCnt == 0) and Win_SetText((uiC2CDealDlg + '.MyPropPage'), '1/1')):
        pass
    for i in range(defMyPropC2CDealDlgCnt):
        ui = (uiC2CDealDlg + ('.funcItem%d' % i))
        idx = (i + MyPropC2CDealDlgPos)
        if ((idx >= totalP2PDealPropCnt) and Win_SetImg((ui + '.itemPic'), '')):
            if Win_SetText((ui + '.itemNum'), ''):
                continue
            info = g_P2PDealPropList.at(idx).m_stItem
            if (CHECK_PET_RELATION(info.m_nItemID) and CHECK_PET(info.m_nItemID)):
                Win_SetText((ui + '.itemNum'), ('%4d' % 1))
                petResId = GetPetResId(info.m_nItemID, 10)
                Win_SetImg((ui + '.itemPic'), ('res/uiRes/icon/pet/pet%d.img' % petResId))




def ui_UpdateMyBidding():
    ClearMyBiddingList()
    if (len(MyBiddingList) == 0):
        print 'in ui_UpdateMyBidding MyBiddingList is Null'
        return 
    BiddingCount = min(len(MyBiddingList), 6)
    Found = 0
    for i in range(BiddingCount):
        info = MyBiddingList[i]
        ui = (uiC2CDealDlg + ('.Mybidding%d' % i))
        if (info[0] == ticketitemid):
            Found = 1
            Win_SetText((uiC2CDealDlg + '.srcBill'), ('%12f' % info[1]))
            continue
        if (Found == 1):
            ui = (uiC2CDealDlg + ('.Mybidding%d' % (i - 1)))
        if ((info[0] <= 0) and Win_SetImg((ui + '.itemPic'), '')):
            Win_SetText((ui + '.itemNum'), '')




def UpdateMyBiddingList(obj, Num):
    Found = 0
    for i in range(len(MyBiddingList)):
        if (obj[0] == MyBiddingList[i][0]):
            if (MyBiddingList[i][1] < Num):
                MyBiddingList[i][1] += 1
            Found = 1
            break

    FoundTicket = 0
    ticketinfo = [ticketitemid,
     0]
    for i in range(len(MyBiddingList)):
        if (MyBiddingList[i][0] == ticketitemid):
            FoundTicket = 1
            ticketinfo[1] = MyBiddingList[i][1]
            del MyBiddingList[i]
            break

    MaxBiddingCount = 5
    if (((not Found) and (len(MyBiddingList) < MaxBiddingCount)) and MyBiddingList.append(obj)):
        pass
    if (FoundTicket and MyBiddingList.append(ticketinfo)):
        pass
    print len(MyBiddingList)



def ui_UpdateDstBidding():
    InitDstBiddingList()
    g_DstGoodsList.update()
    BiddingCount = min(totaldstGoodsListCnt, 6)
    for i in range(BiddingCount):
        ui = (uiC2CDealDlg + ('.DstBidding%d' % i))
        if ((g_DstGoodsList.at(i).m_iItemID == ticketitemid) and Win_SetText((uiC2CDealDlg + '.dstBill'), ('%12f' % g_DstGoodsList.at(i).m_iItemNum))):
            continue
        print ('ui_UpdateDstBidding %s' % ui)
        if ((g_DstGoodsList.at(i).m_iItemID <= 0) and Win_SetImg((ui + '.itemPic'), '')):
            Win_SetText((ui + '.itemNum'), '')




def removeBiddingItem(idx):
    if (idx < len(MyBiddingList)):
        if (MyBiddingList[idx][1] > 0):
            MyBiddingList[idx][1] = (MyBiddingList[idx][1] - 1)
            if (MyBiddingList[idx][1] == 0):
                del MyBiddingList[idx]
        else:
            del MyBiddingList[idx]



def ClearMyBiddingList():
    for i in range(5):
        ui = (uiC2CDealDlg + ('.Mybidding%d' % i))
        Win_SetImg((ui + '.itemPic'), '')
        Win_SetText((ui + '.itemNum'), '')

    Win_SetText((uiC2CDealDlg + '.srcBill'), str(0))



def InitDstBiddingList():
    g_DstGoodsList.clear()
    for i in range(5):
        ui = (uiC2CDealDlg + ('.DstBidding%d' % i))
        Win_SetImg((ui + '.itemPic'), '')
        Win_SetText((ui + '.itemNum'), '')

    Win_SetText((uiC2CDealDlg + '.dstBill'), str(0))



def ShowC2CDealDlg(Uin):
    global bC2CDealShow
    global residualTicket
    global MyBiddingList
    global dealUin
    if bC2CDealShow:
        return 
    bC2CDealShow = 1
    SetC2CDlgFlag(bC2CDealShow)
    residualTicket = GetMyBill()
    dealUin = Uin
    g_P2PDealPropList.update()
    MyBiddingList = []
    g_DstGoodsList.clear()
    UpdateMyPropC2CDealDlg()
    InitDstBiddingList()
    ClearMyBiddingList()
    Win_SetText((uiC2CDealDlg + '.residualBill'), ('%12f' % residualTicket))
    Win_ShowWidget(uiC2CDealDlg, 1)
    RequestStartDeal(dealUin, 1)



def UpdateC2CDealDlgAfterBargain():
    global residualTicket
    global MyBiddingList
    residualTicket = GetMyBill()
    Win_SetText((uiC2CDealDlg + '.residualBill'), ('%12f' % residualTicket))
    g_P2PDealPropList.update()
    MyBiddingList = []
    g_DstGoodsList.clear()
    UpdateMyPropC2CDealDlg()
    InitDstBiddingList()
    ClearMyBiddingList()



def CloseC2CDealDlg(iFlag):
    global bC2CDealShow
    global dealUin
    if (bC2CDealShow == 0):
        return 
    Win_ShowWidget(uiC2CDealDlg, 0)
    if ((iFlag and (dealUin != 0)) and C2CInviteDeal(dealUin, 4)):
        pass
    RequestStartDeal(dealUin, 2)
    bC2CDealShow = 0
    dealUin = 0
    SetC2CDlgFlag(bC2CDealShow)



def UpdateAfterNegotiate():
    global residualTicket
    residualTicket = GetMyBill()
    print ('...............................................................residualTicket = %d' % residualTicket)
    for i in range(len(MyBiddingList)):
        if (MyBiddingList[i][0] == ticketitemid):
            residualTicket -= MyBiddingList[i][1]
            break

    Win_SetText((uiC2CDealDlg + '.residualBill'), ('%12f' % residualTicket))



def UpdateStorageinDealDlg(bid, MyBidIdx):
    for i in range(defMyPropC2CDealDlgCnt):
        ui = (uiC2CDealDlg + ('.funcItem%d' % i))
        idx = (i + MyPropC2CDealDlgPos)
        if ((idx >= totalP2PDealPropCnt) and Win_SetImg((ui + '.itemPic'), '')):
            Win_SetText((ui + '.itemNum'), '')
            continue
        if (MyBidIdx == InvalidIdx):
            for j in range(len(MyBiddingList)):
                if ((g_P2PDealPropList.at(idx).m_stItem.m_nItemID == MyBiddingList[j][0]) and (bid == 1)):
                    if CHECK_PET(g_P2PDealPropList.at(idx).m_stItem.m_nItemID):
                        if Win_SetText((ui + '.itemNum'), ('%4d' % 0)):
                            pass

        else:
            if ((MyBidIdx < len(MyBiddingList)) and (bid == 0)):
                if ((MyBiddingList[MyBidIdx][1] > 0) and (g_P2PDealPropList.at(idx).m_stItem.m_nItemID == MyBiddingList[MyBidIdx][0])):
                    if CHECK_PET(g_P2PDealPropList.at(idx).m_stItem.m_nItemID):
                        if Win_SetText((ui + '.itemNum'), ('%4d' % 1)):
                            pass




def DealInitialize():
    InitializeDealer()



def UnInializeDealerException():
    UnInitialDealer()



def CloseC2CDealDlgFromCpp():
    CloseC2CDealDlg(bC2CDealShow)



def DisableEnterRoom():
    Win_ShowWidget('UI.selRoom.practiceBtn', 0)
    Win_ShowWidget('UI.selRoom.fastJoinRoomBtn', 0)
    Win_ShowWidget('UI.selRoom.newRoomBtn', 0)



def ReceiveSpark(uin):
    global sparkUin
    if doUI((uiSocialityDlg + '.crossBtn'), 'OnClick'):
        Win_ShowWidget(uiKinCreateHintDlg, 0)
        Win_ShowWidget(uiKinCreateDlg, 0)
        if (Win_IsVisible('UI.shop') and ((fruitState != 0) and (fruitState != 1))):
            return 
        if (validateState == 1):
            return 
    if Win_IsVisible('UI.web'):
        return 
    word = Win_GetText('UI.TextBuffer')
    name = Win_GetText('UI.TextBuffer2')
    txt = ((((name + '[') + str(uin)) + ']:\n') + word)
    Win_SetText((uiReceiveSparkDlg + '.sparkword'), txt)
    sparkUin = uin
    ui_setCapture(uiReceiveSparkDlg)



def ReceiveMarriageConfirm():
    Win_ShowWidget('UI.SysMsgbox', 0)
    txt = Win_GetText('UI.TextBuffer')
    Win_SetText((uiMarriageConfirmDlg + '.marriageWord'), txt)
    ui_setCapture(uiMarriageConfirmDlg)



def ui_UpdateMyMarriageInfo():
    if (queryingUin != uin):
        return 
    if (Win_IsVisible(uiPlayerInfoDlg) and ui_getPlayerDetail()):
        pass



def ShowMarriageDlg():

    def showLevelIcon(level):
        ui = (uiMarriageDlg + '.marriageLevel')
        heart = 'object/ui/marriage/marriageLevel/dlg_heart.img'
        diamond = 'object/ui/marriage/marriageLevel/dlg_diamond.img'
        coronet = 'object/ui/marriage/marriageLevel/dlg_coronet.img'
        if ((level < 2) and Win_SetImg((ui + '.level1'), heart)):
            Win_ShowWidget((ui + '.level1'), 1)
            Win_ShowWidget((ui + '.level2'), 0)
            Win_ShowWidget((ui + '.level3'), 0)
            Win_ShowWidget((ui + '.level4'), 0)
            Win_ShowWidget((ui + '.level5'), 0)


    ui = uiMarriageDlg
    if (queryingUin == uin):
        marInfo = GetMyMarriageDetail()
        Win_EnableWidget((uiMarriageDlg + '.divorce'), 1)
        Win_EnableWidget((uiMarriageDlg + '.modify'), 1)
    else:
        marInfo = GetMarriageDetail()
        Win_EnableWidget((uiMarriageDlg + '.divorce'), 0)
        Win_EnableWidget((uiMarriageDlg + '.modify'), 0)
    Win_SetText((ui + '.spouseName'), marInfo.m_szSpouseNickname)
    Win_SetText((ui + '.marriageAge'), (str(marInfo.m_dwMarriageAge) + ' \xcc\xec'))
    Win_SetText((ui + '.closeNum'), str(marInfo.m_dwMarriageLoyalty))
    showLevelIcon(marInfo.m_wMarriageLevel)
    lineLen = int(((135 * marInfo.m_dwMarriageLoyalty) / marInfo.m_dwLevelValue))
    txt = ((str(marInfo.m_dwMarriageLoyalty) + '/') + str(marInfo.m_dwLevelValue))
    Win_SetDrawTexRect((ui + '.closeLine'), 0, 0, lineLen, 17)
    Win_SetText((ui + '.closeLineValue.value'), txt)
    Win_SetText((ui + '.loveword'), marInfo.m_szLoveWord)
    if (marInfo.m_dwRingID > 0):
        ring = ('object/ui/marriage/ring/ring%d.img' % marInfo.m_dwRingID)
        Win_SetImg((ui + '.ring'), ring)
        Win_ShowWidget((ui + '.ring'), 1)
        Win_ShowWidget((ui + '.noRing'), 0)
    else:
        Win_ShowWidget((ui + '.noRing'), 1)
        Win_ShowWidget((ui + '.ring'), 0)
        if ((((uin == queryingUin) or (uin == marInfo.m_dwMarriageUin)) and ((not (Win_GetCurScreen() == 'game')) and (not (Win_GetCurScreen() == 'room')))) and Win_EnableWidget((ui + '.noRing'), 1)):
            pass
    ui_setCapture(uiMarriageDlg)



def SetWeddingStart(wMode, uin, TargetUin):
    global beWedding
    global sparkUin
    global weddingModeID
    global beSparkedNick
    global sparkNick
    global beSparkedUin
    weddingModeID = wMode
    if ((weddingModeID < 0) or (weddingModeID > 1)):
        weddingModeID = 0
    sparkUin = uin
    sparkNick = Win_GetText('UI.TextBuffer')
    beSparkedUin = TargetUin
    beSparkedNick = Win_GetText('UI.TextBuffer2')
    beWedding = 1
    SetWeddingRoom()



def SetWeddingRoom():
    doUI('UI.room.helpKB.crossBtn', 'OnClick')
    doUI('UI.taskSelectDlg.cancel', 'OnClick')
    if ((beWedding == 1) and Win_EnableWidget((uiWeddingDlg + '.startWedding'), 0)):
        Win_EnableWidget((uiWeddingDlg + '.modeLeft'), 0)
        Win_EnableWidget((uiWeddingDlg + '.modeRight'), 0)
    Win_ShowWidget('UI.room.selChatBg', 0)
    if (not weddingMode.has_key(weddingModeID)):
        return 
    desc = weddingMode[weddingModeID]
    (bg, bgIcon, priest, priestSmall, marriageConfirm, weddingMusic,) = desc[0:6]
    Win_SetImg('UI.room.chatRoomBg', bg)
    Win_SetImg((uiWeddingDlg + '.priest'), priest)
    Win_SetImg('UI.room.priestSmall', priestSmall)
    Win_ShowWidget('UI.room.priestSmall', 0)
    Win_SetImg((uiWeddingDlg + '.bgPreview'), bgIcon)
    Win_SetImg(uiMarriageConfirmDlg, marriageConfirm)
    PlayMusic(weddingMusic, -1)
    print 'PlayMusic(weddingMusic,-1):',
    print weddingMusic
    Win_ShowWidget(uiWeddingDlg, 1)



def ChangeWeddingMode(change):
    global weddingModeID
    num = len(weddingMode)
    if (change == 1):
        weddingModeID = (weddingModeID + 1)
        weddingModeID = (weddingModeID % num)
    elif (change == -1):
        weddingModeID = (weddingModeID - 1)
        if (weddingModeID < 0):
            weddingModeID = (weddingModeID + num)
    SetWeddingRoom()



def MyWeddingOver():
    txt = Win_GetText('UI.TextBuffer3')
    print 'word:',
    print txt
    Win_SetText((uiWeddingOverDlg + '.congratulations'), txt)
    ui_setCapture(uiWeddingOverDlg)
    PlaySound('weddingOver.wav', 1)



def WeddingOver(uin, targetUin):
    global sparkNick
    global sparkUin
    global priestwordNum
    global beSparkedNick
    global priestwords
    global beSparkedUin
    Win_ShowWidget('UI.room.priestSmall', 1)
    Win_SetValue('UI.room.priestSmall', 1.0, 41)
    Win_SetValue('UI.room.priestSmall', 1, 901)
    sparkUin = uin
    sparkNick = Win_GetText('UI.TextBuffer')
    beSparkedUin = targetUin
    beSparkedNick = Win_GetText('UI.TextBuffer2')
    priestwordNum = 1
    priestwords = (((sparkNick + ':\n\xc4\xe3\xd4\xb8\xd2\xe2\xd3\xeb') + beSparkedNick) + '\xbd\xe1\xce\xaa\xb7\xf2\xc6\xde\xc2\xf0\xa3\xbf')
    ui = 'UI.room.priestword'
    Win_SetText((ui + '.words'), priestwords)
    Win_ShowWidget(ui, 1)
    Win_SetValue(ui, 1.0, 41)
    Win_SetValue(ui, 1, 901)
    Win_Timer(ui, 2000)



def PlayerWord():
    global priestwords
    global priestwordNum
    uin = 0
    if (priestwordNum == 1):
        uin = sparkUin
    elif (priestwordNum == 2):
        uin = beSparkedUin
    elif (priestwordNum == 3):
        priestwordNum = (priestwordNum + 1)
        Win_Timer('UI.room.tempTimer', 2000)
        return 
    else:
        return 
    seatID = -1
    seatID = GetSeatIDByUin(uin)
    if (seatID < 0):
        return 
    ui = ('UI.room.playerChat' + str(seatID))
    Win_SetText(ui, '\xce\xd2\xd4\xb8\xd2\xe2^^')
    ui_playerChat(seatID)
    if (priestwordNum == 1):
        priestwords = (((beSparkedNick + ':\n\xc4\xe3\xd4\xb8\xd2\xe2\xd3\xeb') + sparkNick) + '\xbd\xe1\xce\xaa\xb7\xf2\xc6\xde\xc2\xf0\xa3\xbf')
    elif (priestwordNum == 2):
        priestwords = '\xb9\xa7\xcf\xb2\xc4\xe3\xc3\xc7\xd2\xd1\xbe\xad\xb3\xc9\xce\xaaQQ\xcc\xc3\xba\xcf\xb7\xa8\xb7\xf2\xc6\xde!'
    else:
        return 
    priestwordNum = (priestwordNum + 1)
    Win_Timer('UI.room.tempTimer', 2000)



def UpdateLoveword():
    txt = Win_GetText((uiModifyLoveWordDlg + '.loveword'))
    Win_SetText((uiMarriageDlg + '.loveword'), txt)



def RestartWedding():
    global beWedding
    beWedding = 0
    Win_ShowWidget(uiMarriageConfirmDlg, 0)
    SetWeddingRoom()



def UpdateWeddingMode(mode):
    global beWedding
    global weddingModeID
    beWedding = 0
    weddingModeID = mode
    if ((weddingModeID < 0) or (weddingModeID > 1)):
        weddingModeID = 0
    SetWeddingRoom()


weddingMode = {0: ('object/ui/marriage/bg/dlg_westBG.img',
     'object/ui/marriage/bg/dlg_westIcon.img',
     'object/ui/marriage/priest/dlg_westPriest.img',
     'object/ui/marriage/priest/dlg_westPriestS.img',
     'object/ui/marriage/dlg_marriageConfirmWest.img',
     'weddingWest.ogg'),
 1: ('object/ui/marriage/bg/dlg_chinaBG.img',
     'object/ui/marriage/bg/dlg_chinaIcon.img',
     'object/ui/marriage/priest/dlg_chinaPriest.img',
     'object/ui/marriage/priest/dlg_chinaPriestS.img',
     'object/ui/marriage/dlg_marriageConfirmChina.img',
     'weddingWest.ogg')}
playerModeDlg = ['bunModeDlg',
 'matchModeDlg',
 'sculptureModeDlg']
playerModeImg = ['img_bun.img',
 'img_match.img',
 'img_sculpture.img']
levelNum = 7
modeNum = 14

def InitPlayerModeInfo():
    for j in range(len(playerModeDlg)):
        ui = ((uiModeInfoDlg + '.') + playerModeDlg[j])
        imgPath = ('object/ui/guideBar/player/' + playerModeImg[j])
        Win_SetImg((ui + '.level1'), imgPath)
        Win_SetText((ui + '.exp'), '0.00%')
        Win_SetDrawTexRect((ui + '.expLine'), 0, 0, 0, 12)

    for level in range((levelNum - 1)):
        Win_SetImg(((uiModeInfoDlg + '.bunModeDlg.level') + str((level + 2))), 'object/ui/guideBar/player/img_mask.img')
        Win_SetImg(((uiModeInfoDlg + '.matchModeDlg.level') + str((level + 2))), 'object/ui/guideBar/player/img_mask.img')
        Win_SetImg(((uiModeInfoDlg + '.sculptureModeDlg.level') + str((level + 2))), 'object/ui/guideBar/player/img_mask.img')




def SetPlayerModeInfo(nUin, iFlag):
    InitPlayerModeInfo()
    info = CNil()
    num = GetPlayerModeInfoByUin(nUin, iFlag)
    if ((num > modeNum) or (num == 0)):
        return 
    for i in range(num):
        ui = ((uiModeInfoDlg + '.') + playerModeDlg[i])
        imgPath = ('object/ui/guideBar/player/' + playerModeImg[i])
        info = GetPlayerModeInfoByModeIndex(nUin, i, iFlag)
        curPoints = info.m_dwPatternPoint
        curLevel = info.m_wPatternLevel
        nextLevelPoint = info.m_dwLevelValue
        strRate = ('%.2f%%' % ((curPoints * 100.0) / nextLevelPoint))
        Win_SetText((ui + '.exp'), strRate)
        Win_SetDrawTexRect((ui + '.expLine'), 0, 0, ((curPoints * 180) / nextLevelPoint), 12)
        for level in range(curLevel):
            Win_SetImg(((ui + '.level') + str((level + 1))), imgPath)

        for otherLevel in range((levelNum - curLevel)):
            Win_SetImg(((ui + '.level') + str(((otherLevel + curLevel) + 1))), 'object/ui/guideBar/player/img_mask.img')




class UI:
    __module__ = __name__
    AllCursor = ({'name': 'normal',
      'path': 'object/ui/cursor/arror.img',
      'step': 0.59999999999999998},
     {'name': 'Click',
      'path': 'object/ui/cursor/dianji.img',
      'step': 0.59999999999999998,
      'holdframe': 1},
     {'name': 'attack',
      'path': 'object/ui/cursor/fight.gsa',
      'step': 0.80000000000000004})
    AllScreen = ({'id': 'logo',
      'path': 'res/uires/uiLogo.pyc'},
     {'id': 'login',
      'path': 'res/uires/uiLogin.pyc'},
     {'id': 'selRoom',
      'path': 'res/uires/uiSelRoom.pyc'},
     {'id': 'selSect',
      'path': 'res/uires/uiSelSect.pyc'},
     {'id': 'room',
      'path': 'res/uires/uiRoom.pyc'},
     {'id': 'shop',
      'path': 'res/uires/uiShop.pyc'},
     {'id': 'web',
      'path': 'res/uires/uiWeb.pyc'},
     {'id': 'game',
      'path': 'res/uires/uiGame.pyc'})
    accel = (('OnAccel_FocusPaste',
      86,
      17,
      0,
      0),
     ('OnAccel_FocusCut',
      88,
      17,
      0,
      0),
     ('OnAccel_FocusCopy',
      67,
      17,
      0,
      0),
     ('OnAccel_OnF6',
      117,
      0,
      0,
      0),
     ('OnAccel_OnF10',
      121,
      0,
      0,
      0),
     ('OnAccel_OnF11',
      122,
      0,
      0,
      0))
    buddy = ({'type': buddy_widget_tipwgt,
      'style': buddy_style_self,
      'id': 'UI.SysTooltip'},
     {'type': buddy_widget_msgbox,
      'style': buddy_style_self,
      'id': 'UI.SysMsgbox'},
     {'type': buddy_widget_console,
      'style': buddy_style_self,
      'id': 'UI.SysConsole'})

    def OnInit():
        Device().restore()
        Device().save()
        settotemPage(0, totemPageNum)
        Win_SelectSelf((uiPlayerInfoDlg + '.pvpInfoTab'))
        Win_SetCheck((uiPlayerInfoDlg + '.pvpInfoTab'), 1)
        doUI((uiPlayerInfoDlg + '.pvpInfoTab'), 'OnClick')
        Win_SelectSelf((uiSocialityDlg + '.playerTab'))
        Win_SetCheck((uiSocialityDlg + '.playerTab'), 1)
        InitPlayerModeInfo()



    def OnAccel_FocusPaste():
        Win_FocusOnPaste()



    def OnAccel_FocusCut():
        print 'cut'
        Win_FocusOnCut()



    def OnAccel_FocusCopy():
        print 'copy'
        Win_FocusOnCopy()



    def OnAccel_OnF6():
        CloseC2CDealDlg(bC2CDealShow)
        go2playerInfo(uin)



    def OnAccel_OnF10():
        print 'OnF10'
        CloseC2CDealDlg(bC2CDealShow)
        go2setup(uin)



    def OnAccel_OnF11():
        sc_printScreen()


    class children:
        __module__ = __name__
        class TextBuffer(TLabel):
            __module__ = __name__
            visible = 0

        class TextBuffer2(TLabel):
            __module__ = __name__
            visible = 0

        class TextBuffer3(TLabel):
            __module__ = __name__
            visible = 0

        class SysConsole:
            __module__ = __name__
            type = 'CONSOLE'
            rect = (0,
             0,
             800,
             250)
            bkcolor = (0,
             196,
             0,
             128)
            initlayer = console_layer
            srcpos = (0,
             -250)
            dstpos = (0,
             0)
            speed = 12.0
            visible = 0
            drawflag = (drawflag_win_edge + drawflag_win_fill)

            def OnSelfShow():
                Win_SetFocus('UI.SysConsole.downinput')



            def OnSelfHide():
                Win_SetFocus()



            def OnTrigger(state):
                if ((state == flyer_scroll_sate_start) and Win_ShowWidget('UI.SysConsole', false)):
                    pass


            class children:
                __module__ = __name__
                class downinput:
                    __module__ = __name__
                    type = 'EDIT'
                    rect = (0,
                     0,
                     600,
                     16)
                    drawcolor = lightColor
                    bkcolor = (0,
                     0,
                     0,
                     128)
                    tabstop = 0
                    textstyle = (dt_left + dt_vcenter)
                    maxchar = 128
                    aligntype = (aligntype_winrect + aligntype_father)
                    alignstyle = (alignstyle_bottom_in + alignstyle_left_in)
                    marginh = 20
                    drawflag = (drawflag_win_edge + drawflag_win_fill)

                    def OnEnter():
                        info = Win_GetText('UI.SysConsole.downinput')
                        if ((info != '') and Win_SetText('UI.SysConsole', info, value_channel_console_enter_string)):
                            pass
                        Win_SetText('UI.SysConsole.downinput', '')



                class cmdlabel:
                    __module__ = __name__
                    type = 'LABEL'
                    rect = (0,
                     0,
                     20,
                     16)
                    textstyle = (dt_center + dt_vcenter)
                    drawcolor = lightColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    caption = '>>'
                    aligntype = (aligntype_winrect + aligntype_father)
                    alignstyle = (alignstyle_bottom_in + alignstyle_left_in)



        class SysTooltip:
            __module__ = __name__
            type = 'LABEL'
            drawcolor = lightColor
            bkcolor = (0,
             0,
             128,
             128)
            edgecolor = (0,
             0,
             0,
             128)
            maxwidth = 160
            sizeable = 1
            visible = 0
            marginh = 3
            marginv = 3
            textsize = 12
            initlayer = systooltip_layer
            textfont = 1
            drawflag = (drawflag_win_edge + drawflag_win_fill)
            alphaspeed = 0.02

        class SysMsgbox:
            __module__ = __name__
            type = 'MESSAGEBOX'
            darkBG = 1
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            textsize = 12
            textstyle = (dt_center + dt_vcenter)
            initlayer = 999999
            visible = 0
            drawcolor = zoneChooseColor
            textEdgeType = -1

            def OnMsgBoxCancel(h):
                print 'OnMsgBoxCancel',
                print h,
                print 0
                if ((h >= 0) and OnMsgBoxResult(h, 0)):
                    pass



            def OnMsgBoxOk(h):
                print 'OnMsgBoxOk',
                print h,
                print 1
                if ((h >= 0) and OnMsgBoxResult(h, 1)):
                    pass


            class children:
                __module__ = __name__
                class yesbtn:
                    __module__ = __name__
                    type = 'BUTTON'
                    rect = (100,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_agree.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    defaultok = 1

                class nobtn:
                    __module__ = __name__
                    type = 'BUTTON'
                    rect = (225,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_refuse.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    defaultcancel = 1

                class textlabel:
                    __module__ = __name__
                    type = 'LABEL'
                    rowspace = 2
                    rect = (40,
                     82,
                     280,
                     130)
                    bkimagepos = (0,
                     0)
                    textsize = 12
                    textstyle = (dt_left + dt_top)
                    textEdgeType = -1
                    drawcolor = zoneChooseColor



        class playerInfoDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            darkBG = 1
            visible = 0
            rect = (((800 - 392) / 2),
             ((600 - 497) / 2),
             392,
             497)

            def OnEnter():
                path = Win_GetFocusPath()
                doUI((uiPlayerInfoDlg + '.closeBtn'), 'OnClick')



            def OnEscape():
                path = Win_GetFocusPath()
                doUI((uiPlayerInfoDlg + '.closeBtn'), 'OnClick')



            def OnInit():
                Win_SelectSelf((uiPlayerInfoDlg + '.pvpInfoTab'))
                Win_SetCheck((uiPlayerInfoDlg + '.pvpInfoTab'), 1)
                doUI((uiPlayerInfoDlg + '.pvpInfoTab'), 'OnClick')


            class children:
                __module__ = __name__
                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (350,
                     0,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerInfoDlg, False)
                        PlaySound(soundLeave, 1)



                class addFriendBtn(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (12,
                     248,
                     66,
                     27)
                    bkimage = 'object/ui/guideBar/player/btn_addFriend.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global friendUin
                        uin = Win_GetText((uiPlayerInfoDlg + '.QQ'))
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        friendUin = int(uin)
                        NickName = GetPlayerNickNamebyUin(friendUin, 0)
                        NickName = NickName.replace('\n', '')
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        Win_SetText((uiAddFriendDlg + '.text'), '')
                        Win_SetFocus((uiAddFriendDlg + '.text'))
                        Win_SetText((uiAddFriendDlg + '.name'), NickName)
                        ui_setCapture(uiAddFriendDlg)



                class deleteFriendBtn(TButton):
                    __module__ = __name__
                    rect = (12,
                     248,
                     66,
                     27)
                    bkimage = 'object/ui/guideBar/player/btn_deleteFriend.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        uin = Win_GetText((uiPlayerInfoDlg + '.QQ'))
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        DoFriendTask('', 0, int(uin), 2)



                class privateChatBtn(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (86,
                     248,
                     66,
                     27)
                    bkimage = 'object/ui/guideBar/player/btn_privateChat.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        name = Win_GetText((uiPlayerInfoDlg + '.nickName'))
                        uin = Win_GetText((uiPlayerInfoDlg + '.QQ'))
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        NotifyWisper(name, int(uin))



                class traceBtn(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (159,
                     248,
                     66,
                     27)
                    bkimage = 'object/ui/guideBar/player/btn_trace.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        uin = Win_GetText((uiPlayerInfoDlg + '.QQ'))
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        DoFriendTask('', 0, int(uin), 3)



                class avtUin(TLabel):
                    __module__ = __name__
                    caption = '-99'

                class QQ(TLabel):
                    __module__ = __name__
                    caption = '123456789'
                    rect = (75,
                     53,
                     120,
                     12)
                    drawcolor = darkColor
                    textEdgeType = -1

                class nickName(TLabel):
                    __module__ = __name__
                    caption = '\xce\xd2\xb0\xae\xb1\xb1\xbe\xa9\xcc\xec\xc3\xc5'
                    rect = (75,
                     76,
                     (233 - 88),
                     12)
                    textEdgeColor = maskColor

                class genderPic(TStatic):
                    __module__ = __name__
                    rect = (75,
                     96,
                     16,
                     15)
                    bkimage = 'res/uires/selRoom/icon/nv.img'

                class gender(TLabel):
                    __module__ = __name__
                    caption = '\xc5\xae\xc9\xfa'
                    rect = (105,
                     98,
                     60,
                     12)
                    drawcolor = darkColor
                    textEdgeType = -1

                class marriagetotem(TStatic):
                    __module__ = __name__
                    rect = (65,
                     116,
                     16,
                     15)

                class spouseName(TLabel):
                    __module__ = __name__
                    rect = (86,
                     121,
                     100,
                     12)
                    drawcolor = darkColor
                    textEdgeType = -1
                    caption = ''

                class spark(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (186,
                     111,
                     37,
                     22)
                    bkimage = 'object/ui/guideBar/player/btn_spark.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global beSparkedNick
                        global beSparkedUin
                        uin = Win_GetText((uiPlayerInfoDlg + '.QQ'))
                        nick = Win_GetText((uiPlayerInfoDlg + '.nickName'))
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        PlaySound(soundLeave, 1)
                        beSparkedUin = int(uin)
                        beSparkedNick = nick
                        Win_SetText((uiSparkDlg + '.spouseName'), beSparkedNick)
                        ui_setCapture(uiSparkDlg)
                        PlaySound(soundLeave, 1)



                class lookupMarriage(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (186,
                     111,
                     37,
                     22)
                    bkimage = 'object/ui/guideBar/player/btn_lookup.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerInfoDlg, 0)
                        ShowMarriageDlg()
                        PlaySound(soundLeave, 1)



                class kintotem(TStatic):
                    __module__ = __name__
                    rect = (70,
                     140,
                     16,
                     15)
                    bkimage = 'object/ui/kinTotem/001.img'

                class kin(TLabel):
                    __module__ = __name__
                    rect = (95,
                     145,
                     100,
                     12)
                    drawcolor = darkColor
                    textEdgeType = -1
                    caption = ''

                class lookup(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (186,
                     135,
                     37,
                     22)
                    bkimage = 'object/ui/guideBar/player/btn_lookup.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ClearkinInfoDlg()
                        kininfo = GetInviteKinInfo(1)
                        if (lookupKinID == 0):
                            print '1:   Win_ShowWidget(uiPlayerInfoDlg, 0)'
                            Win_ShowWidget(uiPlayerInfoDlg, 0)
                            ui_setCapture(uiKinInfoDlg)
                        elif (kininfo.m_dwKinIndex != lookupKinID):
                            print 'kininfo.m_dwKinIndex != lookupKinID: ',
                            print kininfo.m_dwKinIndex,
                            print ' != ',
                            print lookupKinID
                            DoKinTask('', '', 0, lookupKinID, 1)
                        else:
                            name = kininfo.m_szName
                            if (kininfo.m_iKinSection == 1):
                                kinSection = '\xb5\xe7\xd0\xc5'
                            else:
                                kinSection = '\xcd\xf8\xcd\xa8'
                            playerinfo = GetPlayerInfoByUin(kininfo.m_dwUin)
                            governor = (((playerinfo.m_szPlayerNickname + '[') + str(kininfo.m_dwUin)) + ']')
                            Win_SetText((uiKinInfoDlg + '.kinSection'), kinSection)
                            Win_SetText((uiKinInfoDlg + '.kinname'), name)
                            Win_SetText((uiKinInfoDlg + '.governor'), governor)
                            Win_SetText((uiKinInfoDlg + '.Size'), str(((kininfo.m_dwStatus & -1048576) >> 20)))
                            Win_SetText((uiKinInfoDlg + '.Grade'), str(kininfo.m_iGrade))
                            Win_SetText((uiKinInfoDlg + '.Credit'), str(kininfo.m_iLastHonor))
                            Win_SetText((uiKinInfoDlg + '.MemberCount'), str(kininfo.m_wMemberNum))
                            if ((kininfo.m_wContentLen > 0) and Win_SetText((uiKinInfoDlg + '.Proclaim'), kininfo.m_szContent)):
                                pass
                            print '2:   Win_ShowWidget(uiPlayerInfoDlg, 0)'
                            Win_ShowWidget(uiPlayerInfoDlg, 0)
                            ui_setCapture(uiKinInfoDlg)
                        PlaySound(soundLeave, 1)



                class state(TLabel,
                 Static):
                    __module__ = __name__
                    rowspace = 2
                    caption = '123456789'
                    rect = (71,
                     172,
                     (150 - 20),
                     77)
                    drawcolor = darkColor
                    textEdgeType = -1

                class pvpInfoTab(TTabWin):
                    __module__ = __name__
                    initlayer = 200000
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (30,
                     285,
                     86,
                     31)
                    hotcover = 'object/ui/guideBar/player/tab_pvpInfo.img'
                    groupstop = 0
                    groupid = 7

                    def OnClick(this):
                        Win_ShowWidget(uiPvpInfoDlg, 1)
                        Win_ShowWidget(uiPveInfoDlg, 0)
                        Win_ShowWidget(uiModeInfoDlg, 0)
                        PlaySound(soundUI, 1)



                class pveInfoTab(pvpInfoTab):
                    __module__ = __name__
                    initlayer = 200000
                    hotrect = (122,
                     285,
                     86,
                     31)
                    hotcover = 'object/ui/guideBar/player/tab_pveInfo.img'
                    groupstop = 1
                    groupid = 7

                    def OnClick(this):
                        Win_ShowWidget(uiPvpInfoDlg, 0)
                        Win_ShowWidget(uiModeInfoDlg, 0)
                        Win_ShowWidget(uiPveInfoDlg, 1)
                        PlaySound(soundUI, 1)



                class modeInfoTab(pvpInfoTab):
                    __module__ = __name__
                    initlayer = 200000
                    hotrect = (214,
                     285,
                     86,
                     31)
                    hotcover = 'object/ui/guideBar/player/tab_modeInfo.img'
                    groupstop = 2
                    groupid = 7

                    def OnClick(this):
                        Win_ShowWidget(uiPvpInfoDlg, 0)
                        Win_ShowWidget(uiPveInfoDlg, 0)
                        Win_ShowWidget(uiModeInfoDlg, 1)
                        PlaySound(soundUI, 1)



                class pvpInfoDlg(TStatic):
                    __module__ = __name__
                    rect = (0,
                     298,
                     264,
                     173)
                    class children:
                        __module__ = __name__
                        class expLine(TStatic):
                            __module__ = __name__
                            rect = (65,
                             23,
                             136,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine.img'

                        class exp(TLabel):
                            __module__ = __name__
                            initlayer = 1000
                            rect = (110,
                             23,
                             50,
                             12)
                            drawcolor = lightColor
                            textEdgeType = 1
                            textEdgeColor = maskColor
                            caption = '99%'

                        class reputation(TLabel):
                            __module__ = __name__
                            rect = (110,
                             46,
                             50,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1
                            caption = '1000'

                        class levelIcon(TLevelIcon):
                            __module__ = __name__
                            rect = (74,
                             92,
                             16,
                             15)

                        class level(TLabel,
                         Static):
                            __module__ = __name__
                            caption = '\xd0\xc2\xb1\xf8'
                            rect = (118,
                             98,
                             140,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1

                        class point(TLabel,
                         Static):
                            __module__ = __name__
                            caption = '10000'
                            rect = (110,
                             72,
                             159,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1

                        class success(TLabel,
                         Static):
                            __module__ = __name__
                            caption = '100\xca\xa491\xb0\xdc'
                            rect = (76,
                             125,
                             200,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1



                class pveInfoDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (0,
                     314,
                     258,
                     173)
                    bkimage = 'object/ui/guideBar/player/dlg_pveInfo.img'
                    bkimagepos = (3,
                     -9)
                    class children:
                        __module__ = __name__
                        class pveLevelLabel(TLabel):
                            __module__ = __name__
                            rect = (70,
                             5,
                             12,
                             12)
                            drawcolor = (135,
                             249,
                             255,
                             255)
                            textEdgeType = 0

                        class pveLevel(TStatic):
                            __module__ = __name__
                            rect = (92,
                             5,
                             118,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine2.img'

                        class pveCourage(TLabel):
                            __module__ = __name__
                            rect = (100,
                             26,
                             118,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1

                        class pveLife(TLabel):
                            __module__ = __name__
                            rect = (100,
                             46,
                             118,
                             12)
                            drawcolor = darkColor
                            textEdgeType = -1

                        class pveBomb(TStatic):
                            __module__ = __name__
                            rect = (92,
                             64,
                             118,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine2.img'

                        class pveBombResume(TStatic):
                            __module__ = __name__
                            rect = (92,
                             83,
                             118,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine2.img'

                        class pvePower(TStatic):
                            __module__ = __name__
                            rect = (92,
                             103,
                             118,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine2.img'

                        class pveSpeed(TStatic):
                            __module__ = __name__
                            rect = (92,
                             122,
                             118,
                             12)
                            bkimage = 'object/ui/guideBar/player/img_expLine2.img'



                class modeInfoDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (0,
                     314,
                     258,
                     173)
                    bkimage = 'object/ui/guideBar/player/dlg_modeInfo.img'
                    class children:
                        __module__ = __name__
                        class bunModeDlg(TStatic):
                            __module__ = __name__
                            rect = (0,
                             0,
                             258,
                             45)
                            class children:
                                __module__ = __name__
                                class level1(TStatic):
                                    __module__ = __name__
                                    rect = (71,
                                     12,
                                     22,
                                     25)
                                    bkimage = 'object/ui/guideBar/player/img_bun.img'

                                class level2(level1):
                                    __module__ = __name__
                                    rect = (95,
                                     12,
                                     22,
                                     25)
                                    bkimage = 'object/ui/guideBar/player/img_bun.img'

                                class level3(level1):
                                    __module__ = __name__
                                    rect = (118,
                                     12,
                                     22,
                                     25)

                                class level4(level1):
                                    __module__ = __name__
                                    rect = (141,
                                     12,
                                     22,
                                     25)

                                class level5(level1):
                                    __module__ = __name__
                                    rect = (164,
                                     12,
                                     22,
                                     25)

                                class level6(level1):
                                    __module__ = __name__
                                    rect = (187,
                                     12,
                                     22,
                                     25)

                                class level7(level1):
                                    __module__ = __name__
                                    rect = (210,
                                     12,
                                     22,
                                     25)

                                class expLine(TStatic):
                                    __module__ = __name__
                                    rect = (70,
                                     39,
                                     180,
                                     12)
                                    bkimage = 'object/ui/guideBar/player/img_modeExpLine.img'

                                class exp(TLabel):
                                    __module__ = __name__
                                    initlayer = 1000
                                    rect = (140,
                                     38,
                                     50,
                                     12)
                                    drawcolor = lightColor
                                    textEdgeType = 1
                                    textEdgeColor = maskColor
                                    caption = '99%'



                        class matchModeDlg(bunModeDlg):
                            __module__ = __name__
                            rect = (0,
                             48,
                             258,
                             45)

                        class sculptureModeDlg(bunModeDlg):
                            __module__ = __name__
                            rect = (0,
                             92,
                             258,
                             45)



                class mask(TStatic):
                    __module__ = __name__
                    initlayer = -999
                    rect = (-10,
                     -16,
                     1,
                     1)
                    bkimage = 'object/ui/guideBar/player/dlg_playerInfo.img'

                class demoMask(TStatic):
                    __module__ = __name__
                    initlayer = -99999
                    rect = (244,
                     321,
                     99,
                     99)
                    bkimage = 'object/ui/guideBar/player/mask_demo.img'

                class avt(TStatic):
                    __module__ = __name__
                    framespeed = 0.25
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    initlayer = -9999
                    rect = (220,
                     18,
                     (125 - 266),
                     (365 - 27))
                    bkimage = 'res/uiRes/avt_girl.gif'

                class playerDemo(TStatic):
                    __module__ = __name__
                    initlayer = -9999
                    rect = (245,
                     317,
                     96,
                     96)
                    class children:
                        __module__ = __name__
                        class demo(TStatic):
                            __module__ = __name__
                            initlayer = 99999
                            rect = (0,
                             10,
                             71,
                             85)
                            callbackdraw = 'SC_selRoom_drawPlayer'

                        class bg(TStatic):
                            __module__ = __name__
                            bkImgFlag = dt_center
                            framespeed = 0.25
                            initlayer = -9999
                            rect = (0,
                             10,
                             96,
                             96)

                        class frame(TStatic):
                            __module__ = __name__
                            bkImgFlag = dt_center
                            framespeed = 0.25
                            initlayer = 999
                            framescheme = [(0,
                              99,
                              0,
                              99,
                              0,
                              99,
                              0,
                              99)]
                            rect = (0,
                             10,
                             96,
                             96)

                        class enter(TStatic):
                            __module__ = __name__
                            framescheme = [(0,
                              99,
                              0,
                              99,
                              0,
                              99,
                              0,
                              99)]
                            bkImgFlag = (dt_center | eBkImgPlayOnce)
                            framespeed = 0.25
                            initlayer = 999
                            rect = (0,
                             10,
                             96,
                             96)

                        class goldDiamond(TStatic):
                            __module__ = __name__
                            rect = (70,
                             20,
                             20,
                             19)
                            framescheme = [(0,
                              13,
                              0,
                              13,
                              0,
                              13,
                              0,
                              13)]
                            initlayer = 99999





        class setupDlg(TStatic):
            __module__ = __name__
            initlayer = 99999
            darkBG = 1
            visible = 0
            rect = (((800 - 402) / 2),
             ((600 - 468) / 2),
             402,
             468)
            bkimage = 'object/ui/common/dlg_setup.img'
            bkimagepos = (-8,
             -6)

            def OnEnter():
                doUI((uiSetupDlg + '.modifyBtn'), 'OnClick')



            def OnEscape():
                doUI((uiSetupDlg + '.cancelBtn'), 'OnClick')


            class children:
                __module__ = __name__
                class modifyBtn(TButton):
                    __module__ = __name__
                    rect = (130,
                     (474 - 53),
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiSetupDlg, False)
                        PlaySound(soundLeave, 1)
                        KeyLayout().save()
                        Device().save()



                class crossBtn(TButton):
                    __module__ = __name__
                    rect = (367,
                     14,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        doUI((uiSetupDlg + '.cancelBtn'), 'OnClick')



                class cancelBtn(TButton):
                    __module__ = __name__
                    rect = ((212 - 8),
                     (474 - 53),
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiSetupDlg, False)
                        PlaySound(soundLeave, 1)
                        Device().restore()
                        KeyLayout().restore()



                class up(TKeyEdit):
                    __module__ = __name__
                    rect = (75,
                     77,
                     (123 - 80),
                     12)
                    caption = 'error'
                    textstyle = dt_center
                    drawcolor = (51,
                     113,
                     149,
                     255)
                    textEdgeType = -1

                class down(up):
                    __module__ = __name__
                    rect = (75,
                     141,
                     (123 - 80),
                     12)

                class left(up):
                    __module__ = __name__
                    rect = (20,
                     117,
                     (74 - 32),
                     12)

                class right(up):
                    __module__ = __name__
                    rect = (131,
                     116,
                     (180 - 137),
                     12)

                class putBomb(up):
                    __module__ = __name__
                    rect = (52,
                     204,
                     (103 - 52),
                     12)

                class switchItem(up):
                    __module__ = __name__
                    rect = (138,
                     204,
                     (190 - 138),
                     12)

                class smartUseItem(up):
                    __module__ = __name__
                    rect = (55,
                     245,
                     48,
                     12)

                class chat(up):
                    __module__ = __name__
                    rect = (141,
                     245,
                     48,
                     12)

                class customChat(up):
                    __module__ = __name__
                    rect = (85,
                     270,
                     60,
                     12)

                class useItem0(up):
                    __module__ = __name__
                    rect = (250,
                     95,
                     35,
                     12)

                class useItem1(up):
                    __module__ = __name__
                    rect = (250,
                     111,
                     35,
                     12)

                class useItem2(up):
                    __module__ = __name__
                    rect = (250,
                     127,
                     35,
                     12)

                class useItem3(up):
                    __module__ = __name__
                    rect = (250,
                     143,
                     35,
                     12)

                class useItem4(up):
                    __module__ = __name__
                    rect = (250,
                     159,
                     35,
                     12)

                class useItem5(up):
                    __module__ = __name__
                    rect = (250,
                     175,
                     35,
                     12)

                class useItem6(up):
                    __module__ = __name__
                    rect = (250,
                     191,
                     35,
                     12)

                class shop0(up):
                    __module__ = __name__
                    rect = (347,
                     95,
                     35,
                     12)

                class shop1(up):
                    __module__ = __name__
                    rect = (347,
                     111,
                     35,
                     12)

                class shop2(up):
                    __module__ = __name__
                    rect = (347,
                     127,
                     35,
                     12)

                class shop3(up):
                    __module__ = __name__
                    rect = (347,
                     143,
                     35,
                     12)

                class shop4(up):
                    __module__ = __name__
                    rect = (347,
                     157,
                     35,
                     12)

                class shop5(up):
                    __module__ = __name__
                    rect = (347,
                     173,
                     35,
                     12)

                class shop6(up):
                    __module__ = __name__
                    rect = (347,
                     189,
                     35,
                     12)

                class system(up):
                    __module__ = __name__
                    rect = (80,
                     294,
                     60,
                     12)

                class soundChk(TStdCheck):
                    __module__ = __name__
                    rect = (20,
                     (374 - 14),
                     60,
                     20)

                    def OnClick(this):
                        if (Win_IsChecked((uiSetupDlg + '.soundChk')) and ResumeSound()):
                            PlaySound(soundUI, 1)



                class musicChk(soundChk):
                    __module__ = __name__
                    rect = (108,
                     (374 - 14),
                     60,
                     20)

                    def OnClick(this):
                        if (Win_IsChecked((uiSetupDlg + '.musicChk')) and ResumeMusic()):
                            pass



                class fxChk(soundChk):
                    __module__ = __name__
                    rect = (198,
                     (374 - 14),
                     60,
                     20)

                    def OnClick(this):
                        PlaySound(soundUI, 1)



                class fullScreenChk(soundChk):
                    __module__ = __name__
                    rect = (272,
                     (374 - 14),
                     60,
                     20)

                    def OnClick(this):
                        PlaySound(soundUI, 1)



                class Begindlg(soundChk):
                    __module__ = __name__
                    rect = (20,
                     378,
                     60,
                     20)

                    def OnClick(this):
                        PlaySound(soundUI, 1)



                class softromance(TRadio):
                    __module__ = __name__
                    framescheme = [(1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (198,
                     377,
                     60,
                     20)
                    bkimage = 'object/ui/common/btn_ratio.img'
                    groupstop = 1

                class hardromance(softromance):
                    __module__ = __name__
                    framescheme = [(1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (198,
                     395,
                     60,
                     20)
                    bkimage = 'object/ui/common/btn_ratio.img'
                    groupstop = 2



        class guideBar(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (0,
             -1,
             800,
             36)
            bkimage = 'object/ui/guideBar/img_guide.img'
            class children:
                __module__ = __name__
                __doc__ = "\n                class shopBtn(TButton):\n                    rect = (5, 1, 102, 31)\n                    bkimage = 'object/ui/guideBar/btn_shop.img'\n                    tipwidget = uiGuideBar+'.tipShop'\n                    def OnClick(this):\n                        global bC2CDealShow\n                        CloseC2CDealDlg(bC2CDealShow)\n                        if Win_GetCurScreen() == 'selRoom':\n                            SC_ClickShopBtn()\n                            go2shop()\n                        elif Win_GetCurScreen() == 'room':\n                            global markEnterShop \n                            markEnterShop = True\n                            LeaveRoom(uin)\n                            PlayMusic( musicStart, -1)\n                class tipShop(TStatic):\n                    visible = 0\n                    initlayer = 999999\n                    bkimage = 'object/ui/guideBar/tip_enterShop.img'\n                    rect = ( 115, 2, 1, 1)\n                    def OnTimer(this):\n                        Win_ShowWidget(this, not Win_IsVisible(this))\n                "
                class tradeBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     1,
                     102,
                     31)
                    bkimage = 'object/ui/guideBar/btn_trade.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        print ('bPawnShopShow = %d' % bPawnShopShow)
                        if ((Win_GetCurScreen() == 'room') and LeaveRoom(uin)):
                            pass
                        if (bPawnShopShow == 1):
                            return 
                        LoginDeal()
                        residualmoeny = GetMyBill()
                        Win_SetText((uiPawnShopDlg + '.residualBill'), ('%12f' % residualmoeny))
                        Win_ShowWidget(uiPawnShopDlg, 1)
                        PlaySound(soundUI, 1)


                    class children:
                        __module__ = __name__
                        class tradeTip:
                            __module__ = __name__
                            type = 'DYLABEL'
                            initlayer = 99999
                            rect = (0,
                             60,
                             130,
                             1)
                            captionrect = (4,
                             4,
                             120,
                             1)
                            drawcolor = maskColor
                            textEdgeType = -1
                            bkimage = 'object/ui/common/img_tip.img'

                            def OnTimer(this):
                                Win_ShowWidget(this, 0)
                                Win_Timer(this, 0)





                class socialityBtn(TButton):
                    __module__ = __name__
                    rect = (142,
                     -2,
                     84,
                     39)
                    bkimage = 'object/ui/guideBar/btn_sociality.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        ui_setCapture(uiSocialityDlg)
                        Win_SelectSelf((uiSocialityDlg + '.kinMatchTab'))
                        Win_SetCheck((uiSocialityDlg + '.kinMatchTab'), 1)
                        sc_LoadWeb('kinMatch', 61, 108, 329, 401, ChangeURL('http%3A%2F%2Fapp.qqtang.qq.com%2Fcgi-bin%2Fa20071119jzls%2Fmy_family_rank.cgi'))
                        sc_LoadWeb('kinTeam', 61, 108, 329, 401, ChangeURL('http%3A%2F%2Fapp.qqtang.qq.com%2Fcgi-bin%2Fa20071119jzls%2Fmy_team.cgi'))
                        doUI((uiSocialityDlg + '.kinMatchTab'), 'OnClick')
                        PlaySound(soundUI, 1)



                class taskBtn(TButton):
                    __module__ = __name__
                    rect = (252,
                     -2,
                     84,
                     39)
                    bkimage = 'object/ui/guideBar/btn_task.img'
                    tipwidget = (uiGuideBar + '.tipTask')

                    def OnClick(this):
                        global markEnterShop
                        global mark_task
                        CloseC2CDealDlg(bC2CDealShow)
                        mark_task = 1
                        if ((Win_GetCurScreen() == 'selRoom') and SC_ClickShopBtn()):
                            go2shop()



                    def OnMouseMoveIn():
                        me = Win_GetMyPath()
                        x = (Win_GetX(me) + 20)
                        y = (Win_GetY(me) + 54)
                        tipIndex = SC_GetTipName()
                        ui = (uiGuideBar + '.tipTask')
                        if (tipIndex == 1):
                            text = '  \xc8\xce\xce\xf1\xb4\xfd\xc1\xec\xc8\xa1'
                        elif (tipIndex == 2):
                            text = '  \xc8\xce\xce\xf1\xbd\xf8\xd0\xd0\xd6\xd0'
                        elif (tipIndex == 3):
                            text = '  \xc8\xce\xce\xf1\xcd\xea\xb3\xc9'
                        elif (tipIndex == 4):
                            text = '  \xce\xde\xbf\xc9\xc1\xec\xc8\xa1\xc8\xce\xce\xf1'
                        else:
                            text = ''
                        Win_Move2Pos(ui, x, y)
                        Win_SetText(ui, text)



                class tipTask:
                    __module__ = __name__
                    visible = 0
                    type = 'DYLABEL'
                    initlayer = 999999
                    bkimage = 'object/ui/common/img_tip.img'
                    rect = (0,
                     0,
                     130,
                     71)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    drawcolor = maskColor
                    textEdgeType = -1

                class memberBtn(TButton):
                    __module__ = __name__
                    rect = (362,
                     -2,
                     84,
                     39)
                    bkimage = 'object/ui/guideBar/btn_member.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        Navigate(0)



                class infoBtn(TButton):
                    __module__ = __name__
                    rect = (472,
                     -2,
                     84,
                     39)
                    bkimage = 'object/ui/guideBar/btn_info.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        uin = GetLocalUin()
                        print ('(%d)' % uin)
                        go2playerInfo(uin)
                        SetPlayerModeInfo(uin, 0)



                class PetBtn(TButton):
                    __module__ = __name__
                    rect = (582,
                     -2,
                     84,
                     39)
                    bkimage = 'object/ui/guideBar/btn_pet.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        PlaySound(soundUI, 1)
                        if ((Win_GetCurScreen() == 'room') and ui_msgBox(1)):
                            Win_ShowMsgBox('   \xb4\xf2\xbf\xaa\xb3\xe8\xce\xef\xd6\xae\xbc\xd2\xbd\xab\xcd\xcb\xb3\xf6\xb5\xb1\xc7\xb0\xb7\xbf\xbc\xe4', '\xce\xc2\xdc\xb0\xcc\xe1\xca\xbe', 0, 'UI.SysMsgbox', -6)



                class menuBtn(TCheck):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      1,
                      1,
                      2,
                      2,
                      2,
                      2),
                     (0,
                      0,
                      1,
                      1,
                      0,
                      0,
                      0,
                      0)]
                    rect = (691,
                     1,
                     90,
                     31)
                    bkimage = 'object/ui/guideBar/btn_menu.img'

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        if (Win_IsChecked((uiGuideBar + '.menuBtn')) and Win_ShowWidget(uiMenuDlg, 1)):
                            print 'show'





        class menuDlg(TDlg):
            __module__ = __name__
            initlayer = 888888
            visible = 0
            style = wgtstyle_popup
            rect = (705,
             1,
             80,
             174)
            bkimagepos = (0,
             34)
            bkimage = 'object/ui/guideBar/dlg_menu.img'

            def OnSelfHide():
                Win_SetCheck((uiGuideBar + '.menuBtn'), 0)
                print 'onSelfHide    menudlg'



            def OnMouseMoveOut():
                Win_ShowWidget(uiMenuDlg, 0)


            class children:
                __module__ = __name__
                class setupBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     40,
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_setup.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        SC_ClickCustomSettingBtn()
                        Win_ShowWidget(uiMenuDlg, False)
                        go2setup(uin)



                class helpBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     (40 + 36),
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_help.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        SC_ClickHelperInfoBtn()
                        Win_ShowWidget(uiMenuDlg, False)
                        ui_jumpHelpWeb()



                class GCSBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     (40 + (36 * 2)),
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_GCS.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiMenuDlg, False)
                        Navigate(3)



                class recordBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     (40 + (36 * 3)),
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_record.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        SC_ClickWatchVedioBtn()
                        Win_ShowWidget(uiMenuDlg, False)
                        InitRecordFileDlg()
                        PlaySound(soundUI, 1)



                class QQTWebBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     (40 + (36 * 4)),
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_web.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiMenuDlg, False)
                        ui_jumpOfficialWeb()



                class topkinBtn(TButton):
                    __module__ = __name__
                    rect = (5,
                     (40 + (36 * 5)),
                     70,
                     33)
                    bkimage = 'object/ui/guideBar/btn_top_kin.img'

                    def OnClick(this):
                        Win_ShowWidget(uiMenuDlg, False)
                        DoKinTask('', '', 0, lookupKinID, 15)
                        ui_updateTopkinList()
                        PlaySound(soundUI, 1)





        class socialityDlg(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 60000
            rect = (30,
             45,
             400,
             500)
            darkBG = 1
            bkimage = 'object/ui/guideBar/dlg_player.img'

            def OnDenit():
                sc_HideWeb('kinMatch')
                sc_HideWeb('kinTeam')


            class children:
                __module__ = __name__
                class crossBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (360,
                     30,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiSocialityDlg, 0)
                        sc_HideWeb('kinTeam')
                        sc_HideWeb('kinMatch')
                        PlaySound(soundUI, 1)



                class kinMatchTab(TTabWin):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 1
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (11,
                     1,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/tab_kinMatch.img'

                    def OnClick(this):
                        sc_HideWeb('kinTeam')
                        Win_ShowWidget(uiKinDlg, 0)
                        Win_ShowWidget(uiPlayerListDlg, 0)
                        Win_SetImg(uiSocialityDlg, 'object/ui/guideBar/dlg_player.img')
                        sc_ShowWeb('kinMatch', 61, 108, 329, 401, ChangeURL('http%3A%2F%2Fapp.qqtang.qq.com%2Fcgi-bin%2Fa20071119jzls%2Fmy_family_rank.cgi'))



                class teamTab(TTabWin):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 2
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (76,
                     1,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/tab_team.img'

                    def OnClick(this):
                        sc_HideWeb('kinMatch')
                        Win_ShowWidget(uiKinDlg, 0)
                        Win_ShowWidget(uiPlayerListDlg, 0)
                        Win_SetImg(uiSocialityDlg, 'object/ui/guideBar/dlg_player.img')
                        sc_ShowWeb('kinTeam', 61, 108, 329, 401, ChangeURL('http%3A%2F%2Fapp.qqtang.qq.com%2Fcgi-bin%2Fa20071119jzls%2Fmy_team.cgi'))



                class allKinMemberTab(TTabWin):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 3
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (141,
                     1,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/tab_allKinMember.img'

                    def OnClick(this):
                        global playerMode
                        sc_HideWeb('kinTeam')
                        sc_HideWeb('kinMatch')
                        Win_ShowWidget(uiKinDlg, 0)
                        Win_SetImg(uiSocialityDlg, 'object/ui/guideBar/dlg_player.img')
                        KinID = GetKinParam(0)
                        if ((KinID == 0) and Win_ShowWidget(uiPlayerListDlg, 0)):
                            Win_SelectSelf((uiSocialityDlg + '.playerTab'))
                            ui_setCapture(uiKinCreateHintDlg)
                            playerMode = 0
                            updatePlayer()
                        PlaySound(soundUI, 1)



                class kinTab(TTabWin):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 4
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (206,
                     1,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/tab_kin.img'

                    def OnClick(this):
                        global playerMode
                        sc_HideWeb('kinTeam')
                        sc_HideWeb('kinMatch')
                        kinID = GetKinParam(0)
                        if ((kinID <= 0) and ui_setCapture(uiKinCreateHintDlg)):
                            Win_ShowWidget(uiPlayerListDlg, 0)
                            Win_SelectSelf((uiSocialityDlg + '.playerTab'))
                            playerMode = 0
                            updatePlayer()
                        PlaySound(soundUI, 1)



                class playerListDlg(TStatic):
                    __module__ = __name__
                    rect = (4,
                     28,
                     382,
                     490)
                    class children:
                        __module__ = __name__
                        class friendMask(TStatic):
                            __module__ = __name__
                            initlayer = 50000
                            rect = (27,
                             34,
                             1,
                             1)
                            bkimage = 'object/ui/guideBar/img_friendMask.img'
                            class children:
                                __module__ = __name__
                                class tipBtn(TButton):
                                    __module__ = __name__
                                    initlayer = 20000
                                    rect = (0,
                                     0,
                                     1,
                                     1)

                                    def OnClick(this):
                                        if ((playerMode == 1) and InvalidOperation()):
                                            pass





                        class playerInfo1(TButton):
                            __module__ = __name__
                            initlayer = 20000
                            rect = (31,
                             44,
                             321,
                             23)
                            bkimage = 'object/ui/guideBar/btn_player.img'
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              -1,
                              -1,
                              -1,
                              -1)]
                            bkImgFlag = dt_center

                            def OnClick(this):
                                i = getMyIdx2()
                                print 'FindFriend  ',
                                print uins[(i - 1)],
                                print '...',
                                print i
                                go2playerInfo(uins[(i - 1)])



                            def OnRBtnUp(pos):
                                global friendName
                                global friendUin
                                (x, y,) = pos
                                if ((x + 77) > 800):
                                    x = (800 - 77)
                                Win_Move2Pos(uiPlayerMenu, x, y)
                                i = getMyIdx2()
                                friendUin = uins[(i - 1)]
                                friendName = Win_GetText((Win_GetMyPath() + '.name'))
                                kinID = GetKinParam(0)
                                if ((kinID > 0) and Win_ShowWidget((uiPlayerMenu + '.kininviteBtn'), kinID)):
                                    pass
                                Win_ShowWidget((uiPlayerMenu + '.addBtn'), (not GetAttribute(friendUin, 0)))
                                Win_ShowWidget((uiPlayerMenu + '.deleteBtn'), GetAttribute(friendUin, 0))
                                Win_ShowWidget((uiPlayerMenu + '.shieldBtn'), (not GetAttribute(friendUin, 1)))
                                Win_ShowWidget((uiPlayerMenu + '.unshieldBtn'), GetAttribute(friendUin, 1))
                                Win_ShowWidget(uiPlayerMenu, 1)



                            def OnMouseMoveIn():
                                idx = getMyIdx2()
                                if ((idx > 1) and Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % (idx - 1))), 20000.0, 902)):
                                    pass
                                if ((idx < 16) and Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % (idx + 1))), 20000.0, 902)):
                                    pass
                                Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % idx)), 35000.0, 902)


                            class children:
                                __module__ = __name__
                                class gender(TStatic):
                                    __module__ = __name__
                                    rect = (292,
                                     3,
                                     16,
                                     15)
                                    bkimage = 'res/uires/selRoom/icon/nan.img'

                                class levelIcon(TLevelIcon):
                                    __module__ = __name__
                                    rect = (30,
                                     1,
                                     39,
                                     15)

                                class goldDiamond(TStatic):
                                    __module__ = __name__
                                    visible = 0
                                    rect = (53,
                                     4,
                                     20,
                                     19)
                                    framescheme = [(0,
                                      15,
                                      0,
                                      15,
                                      0,
                                      15,
                                      0,
                                      15)]
                                    bkimage = 'res/uires/selRoom/goldDiamond.img'

                                class kintotem(TStatic):
                                    __module__ = __name__
                                    visible = 0
                                    rect = (8,
                                     2,
                                     16,
                                     15)
                                    framescheme = [(0,
                                      13,
                                      0,
                                      13,
                                      0,
                                      13,
                                      0,
                                      13)]

                                class league(TStatic):
                                    __module__ = __name__
                                    visible = 0
                                    rect = (92,
                                     4,
                                     16,
                                     15)
                                    framescheme = [(0,
                                      13,
                                      0,
                                      13,
                                      0,
                                      13,
                                      0,
                                      13)]
                                    bkimage = 'res/uires/selRoom/diamond_bk.img'

                                class name(TLabel,
                                 Static):
                                    __module__ = __name__
                                    rect = (168,
                                     6,
                                     120,
                                     12)
                                    drawcolor = lightColor
                                    textEdgeType = 1
                                    textEdgeColor = maskColor
                                    textstyle = dt_right

                                class namecard(TStatic):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      99,
                                      0,
                                      99,
                                      0,
                                      99,
                                      0,
                                      99)]
                                    initlayer = -100
                                    rect = (7,
                                     1,
                                     1,
                                     1)

                                class namecardbound(TStatic):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      99,
                                      0,
                                      99,
                                      0,
                                      99,
                                      0,
                                      99)]
                                    rect = (7,
                                     1,
                                     1,
                                     1)



                        class playerInfo2(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + 24),
                             321,
                             23)

                        class playerInfo3(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 2)),
                             321,
                             23)

                        class playerInfo4(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 3)),
                             321,
                             23)

                        class playerInfo5(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 4)),
                             321,
                             23)

                        class playerInfo6(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 5)),
                             321,
                             23)

                        class playerInfo7(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 6)),
                             321,
                             23)

                        class playerInfo8(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 7)),
                             321,
                             23)

                        class playerInfo9(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 8)),
                             321,
                             23)

                        class playerInfo10(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 9)),
                             321,
                             23)

                        class playerInfo11(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 10)),
                             321,
                             23)

                        class playerInfo12(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 11)),
                             321,
                             23)

                        class playerInfo13(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 12)),
                             321,
                             23)

                        class playerInfo14(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 13)),
                             321,
                             23)

                        class playerInfo15(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 14)),
                             321,
                             23)

                        class playerInfo16(playerInfo1):
                            __module__ = __name__
                            rect = (31,
                             (44 + (24 * 15)),
                             321,
                             23)

                        class left(TButton):
                            __module__ = __name__
                            rect = (280,
                             435,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_left.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                pos = myGetPlayerPos()
                                if ((pos != 0) and PlaySound(soundUI, 1)):
                                    pos = max((pos - (defPlayerCnt - 1)), 0)
                                    mySetPlayerPos(pos)
                                    updatePlayer()



                        class right(TButton):
                            __module__ = __name__
                            rect = (311,
                             435,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_right.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                PlayerList_right()
                                pos = myGetPlayerPos()
                                cnt = myGetPlayerCnt()
                                if (((pos + (defPlayerCnt - 1)) < cnt) and PlaySound(soundUI, 1)):
                                    pos += (defPlayerCnt - 1)
                                    mySetPlayerPos(pos)
                                    updatePlayer()





                class kinDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (4,
                     28,
                     382,
                     490)
                    class children:
                        __module__ = __name__
                        class kinmemberTab(TTabWin):
                            __module__ = __name__
                            groupid = 4
                            groupstop = 1
                            rect = (0,
                             0,
                             1,
                             1)
                            hotrect = (20,
                             5,
                             63,
                             34)
                            hotcover = 'object/ui/guideBar/tab_kinMember.img'

                            def OnClick(this):
                                Win_SetImg(uiSocialityDlg, 'object/ui/guideBar/dlg_kinMember.img')
                                Win_ShowWidget(uiKinManagerDlg, 0)
                                Win_ShowWidget(uiKinMemberDlg, 1)
                                ui_updateMemberList()
                                info = GetInviteKinInfo(1)
                                uin = GetLocalUin()
                                if ((uin == info.m_dwUin) and Win_ShowWidget((uiKinManagerDlg + '.amend'), 1)):
                                    Win_ShowWidget((uiKinManagerDlg + '.issue'), 1)
                                PlaySound(soundUI, 1)



                        class kinmanagerTab(TTabWin):
                            __module__ = __name__
                            groupid = 4
                            groupstop = 2
                            rect = (0,
                             0,
                             1,
                             1)
                            hotrect = (85,
                             5,
                             63,
                             34)
                            hotcover = 'object/ui/guideBar/tab_kinMgr.img'

                            def OnClick(this):
                                Win_SetImg(uiSocialityDlg, 'object/ui/guideBar/dlg_kinMgr.img')
                                Win_ShowWidget(uiKinManagerDlg, 1)
                                Win_ShowWidget(uiKinMemberDlg, 0)
                                for i in range(5):
                                    Win_SetText((uiKinManagerDlg + ('.customPosition%d' % i)), GetKinPosition(i))

                                info = GetInviteKinInfo(1)
                                uin = GetLocalUin()
                                maxKinmemberCnt = ((info.m_dwStatus & -1048576) >> 20)
                                MemberNum = info.m_wMemberNum
                                kinmemcntstatus = ((str(MemberNum) + '/') + str(maxKinmemberCnt))
                                Win_SetText((uiKinManagerDlg + '.KinMemberCntStatus'), kinmemcntstatus)
                                Win_SetText((uiKinManagerDlg + '.text'), info.m_szContent)
                                totemID = info.m_stKinFlagID.m_iFlagID
                                Win_SetImg((uiKinManagerDlg + '.totemBtn'), ('object/ui/kinTotem/%03d.img' % (totemID)))
                                if ((uin == info.m_dwUin) and Win_SetFocus((uiKinManagerDlg + '.customPosition0'))):
                                    IsDismiss = GetKinMemberHonor(uin, 2)
                                    if ((IsDismiss == 1) and Win_ShowWidget((uiKinManagerDlg + '.dismissBtn'), 0)):
                                        Win_ShowWidget((uiKinManagerDlg + '.quitBtn'), 0)
                                        Win_ShowWidget((uiKinManagerDlg + '.canceldismissBtn'), 1)
                                        Win_SetImg((uiKinManagerDlg + '.canceldismissBtn'), 'object/ui/guideBar/btn_cancel_dismiss.img')
                                PlaySound(soundUI, 1)



                        class kinmanagerDlg(TStatic):
                            __module__ = __name__
                            visible = 0
                            rect = (0,
                             30,
                             377,
                             429)
                            class children:
                                __module__ = __name__
                                class confirm(TButton):
                                    __module__ = __name__
                                    rect = (212,
                                     388,
                                     43,
                                     31)
                                    bkimage = 'object/ui/common/btn_confirm.img'
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]

                                    def OnClick(this):
                                        placeholder = ('%c' % 7)
                                        if ((Win_GetText((uiKinManagerDlg + '.customPosition0')) != '') and ((Win_GetText((uiKinManagerDlg + '.customPosition1')) != '') and ((Win_GetText((uiKinManagerDlg + '.customPosition2')) != '') and ((Win_GetText((uiKinManagerDlg + '.customPosition3')) != '') and (Win_GetText((uiKinManagerDlg + '.customPosition4')) != ''))))):
                                            positioninfo = (((((((((Win_GetText((uiKinManagerDlg + '.customPosition0')) + placeholder) + Win_GetText((uiKinManagerDlg + '.customPosition1'))) + placeholder) + Win_GetText((uiKinManagerDlg + '.customPosition2'))) + placeholder) + Win_GetText((uiKinManagerDlg + '.customPosition3'))) + placeholder) + Win_GetText((uiKinManagerDlg + '.customPosition4'))) + placeholder)
                                            DoKinTask('', positioninfo, len(positioninfo), 0, 9)
                                        DoKinTask('', str(customtotemID), len(str(customtotemID)), 0, 3)
                                        proclaim = Win_GetText((uiKinManagerDlg + '.text'))
                                        if ((proclaim != '') and DoKinTask('', proclaim, len(proclaim), 0, 13)):
                                            pass
                                        PlaySound(soundUI, 1)



                                class dismissBtn(TButton):
                                    __module__ = __name__
                                    rect = (34,
                                     388,
                                     69,
                                     32)
                                    bkimage = 'object/ui/guideBar/btn_dismiss.img'
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]

                                    def OnClick(this):
                                        uin = GetLocalUin()
                                        Win_SetText((uiKinTipDlg + '.prompt'), '\xc4\xfa\xc8\xb7\xb6\xa8\xd2\xaa\xbd\xe2\xc9\xa2\xc4\xfa\xb5\xc4\xbc\xd2\xd7\xe5\xc2\xf0?')
                                        Win_SetText((uiKinTipDlg + '.pParam1'), '')
                                        Win_SetText((uiKinTipDlg + '.pParam2'), '')
                                        Win_SetText((uiKinTipDlg + '.uin'), str(uin))
                                        Win_SetText((uiKinTipDlg + '.TaskMode'), '7')
                                        ui_setCapture(uiKinTipDlg)
                                        PlaySound(soundUI, 1)
                                        doUI((uiKinDlg + '.kinmanagerTab'), 'OnClick')



                                class canceldismissBtn(dismissBtn):
                                    __module__ = __name__
                                    bkimage = 'object/ui/guideBar/btn_cancel_dismiss.img'
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]

                                    def OnClick(this):
                                        DoKinTask('', '', 0, uin, 7)
                                        doUI((uiKinDlg + '.kinmanagerTab'), 'OnClick')



                                class quitBtn(TButton):
                                    __module__ = __name__
                                    rect = (34,
                                     388,
                                     66,
                                     27)
                                    bkimage = 'object/ui/guideBar/btn_quitKin.img'
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]

                                    def OnClick(this):
                                        print 'Click the kininvitedlg confirm'
                                        uin = GetLocalUin()
                                        Win_SetText((uiKinTipDlg + '.prompt'), '\xc4\xfa\xc8\xb7\xb6\xa8\xd2\xaa\xcd\xcb\xb3\xf6\xbc\xd2\xd7\xe5\xc2\xf0?')
                                        Win_SetText((uiKinTipDlg + '.pParam1'), '')
                                        Win_SetText((uiKinTipDlg + '.pParam2'), '')
                                        Win_SetText((uiKinTipDlg + '.uin'), str(uin))
                                        Win_SetText((uiKinTipDlg + '.TaskMode'), '6')
                                        ui_setCapture(uiKinTipDlg)
                                        PlaySound(soundUI, 1)
                                        doUI((uiKinDlg + '.kinmanagerTab'), 'OnClick')



                                class KinMemberCntStatus(TLabel):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    rect = (306,
                                     332,
                                     60,
                                     24)
                                    drawcolor = kinColor

                                class totemBtn(TCheck):
                                    __module__ = __name__
                                    initlayer = 9000
                                    extendstyle = ui_btn_style_none
                                    framescheme = [(0,
                                      0,
                                      1,
                                      1,
                                      2,
                                      2,
                                      2,
                                      2),
                                     (2,
                                      2,
                                      1,
                                      1,
                                      0,
                                      0,
                                      2,
                                      2)]
                                    rect = (122,
                                     342,
                                     (24 - 5),
                                     (26 - 4))

                                    def OnClick(this):
                                        info = GetInviteKinInfo(1)
                                        uin = GetLocalUin()
                                        if ((uin == info.m_dwUin) and Win_IsChecked((uiKinManagerDlg + '.totemBtn'))):
                                            if (oldWinEventCnt == Win_GetEventCnt()):
                                                if Win_SetCheck((uiKinManagerDlg + '.totemBtn'), False):
                                                    pass
                                            else:
                                                Win_ShowWidget((uiKinManagerDlg + '.totemBtn.totemDlg'), False)


                                    class children:
                                        __module__ = __name__
                                        class totemDlg(TWidget):
                                            __module__ = __name__
                                            visible = 0
                                            style = wgtstyle_popup
                                            rect = (23,
                                             (-137 + 17),
                                             174,
                                             137)
                                            bkimage = 'object/ui/chat/dlg_face.img'

                                            def OnSelfHide():
                                                global oldWinEventCnt
                                                oldWinEventCnt = Win_GetEventCnt()
                                                Win_SetCheck((uiKinManagerDlg + '.totemBtn'), False)


                                            class children:
                                                __module__ = __name__
                                                class box(TStatic):
                                                    __module__ = __name__
                                                    rect = (0,
                                                     0,
                                                     10,
                                                     10)
                                                    class children:
                                                        __module__ = __name__
                                                        class face0(TButton):
                                                            __module__ = __name__
                                                            framescheme = [(0,
                                                              0,
                                                              0,
                                                              99,
                                                              0,
                                                              0,
                                                              0,
                                                              0)]
                                                            rect = (8,
                                                             6,
                                                             26,
                                                             26)
                                                            bkImgFlag = dt_center
                                                            bkimage = 'object/ui/kinTotem/001.img'

                                                            def OnClick(this):
                                                                global customtotemID
                                                                i = ((totemPage * 24) + getMyIdx())
                                                                customtotemID = (i + 1)
                                                                Win_SetImg((uiKinManagerDlg + '.totemBtn'), ('object/ui/kinTotem/%03d.img' % (customtotemID)))
                                                                Win_ShowWidget((uiKinManagerDlg + '.totemBtn.totemDlg'), 0)



                                                        class face1(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + 27),
                                                             6,
                                                             26,
                                                             26)

                                                        class face2(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 2)),
                                                             6,
                                                             26,
                                                             26)

                                                        class face3(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 3)),
                                                             6,
                                                             26,
                                                             26)

                                                        class face4(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 4)),
                                                             6,
                                                             26,
                                                             26)

                                                        class face5(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 5)),
                                                             6,
                                                             26,
                                                             26)

                                                        class face6(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 0)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face7(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 1)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face8(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 2)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face9(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 3)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face10(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 4)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face11(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 5)),
                                                             (6 + (27 * 1)),
                                                             26,
                                                             26)

                                                        class face12(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 0)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face13(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 1)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face14(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 2)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face15(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 3)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face16(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 4)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face17(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 5)),
                                                             (6 + (27 * 2)),
                                                             26,
                                                             26)

                                                        class face18(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 0)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)

                                                        class face19(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 1)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)

                                                        class face20(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 2)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)

                                                        class face21(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 3)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)

                                                        class face22(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 4)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)

                                                        class face23(face0):
                                                            __module__ = __name__
                                                            rect = ((8 + (27 * 5)),
                                                             (6 + (27 * 3)),
                                                             26,
                                                             26)



                                                class pageLab(TLabel):
                                                    __module__ = __name__
                                                    rect = ((102 + 22),
                                                     117,
                                                     18,
                                                     12)
                                                    drawcolor = lightColor
                                                    textEdgeColor = (6,
                                                     102,
                                                     231,
                                                     255)

                                                class leftBtn(TButton):
                                                    __module__ = __name__
                                                    rect = (102,
                                                     115,
                                                     17,
                                                     17)
                                                    bkimage = 'res/uires/face/biaoq_zuo.img'

                                                    def OnClick(this):
                                                        global totemPage
                                                        totemPage -= 1
                                                        if (totemPage < 0):
                                                            totemPage = (totemPageNum - 1)
                                                        settotemPage(totemPage, totemPageNum)
                                                        PlaySound(soundUI, 1)



                                                class rightBtn(TButton):
                                                    __module__ = __name__
                                                    rect = (148,
                                                     115,
                                                     17,
                                                     17)
                                                    bkimage = 'res/uires/face/biaoq_you.img'

                                                    def OnClick(this):
                                                        global totemPage
                                                        totemPage += 1
                                                        if (totemPage >= totemPageNum):
                                                            totemPage = 0
                                                        settotemPage(totemPage, totemPageNum)
                                                        PlaySound(soundUI, 1)







                                class customPosition0(TRichEdit):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    maxchar = 8
                                    rect = (200,
                                     173,
                                     145,
                                     24)
                                    drawcolor = (255,
                                     123,
                                     44,
                                     255)
                                    textEdgeColor = maskColor
                                    captionrect = (40,
                                     8,
                                     100,
                                     12)

                                    def OnTab():
                                        idx = getMyIdx2()
                                        Win_SetFocus((uiKinManagerDlg + ('.customPosition%d' % ((idx + 1) % 5))))



                                class customPosition1(customPosition0):
                                    __module__ = __name__
                                    rect = (200,
                                     (173 + 26),
                                     145,
                                     24)
                                    drawcolor = (247,
                                     65,
                                     255,
                                     255)

                                class customPosition2(customPosition0):
                                    __module__ = __name__
                                    rect = (200,
                                     (173 + (2 * 26)),
                                     145,
                                     24)
                                    drawcolor = (69,
                                     139,
                                     255,
                                     255)

                                class customPosition3(customPosition0):
                                    __module__ = __name__
                                    rect = (200,
                                     (173 + (3 * 26)),
                                     145,
                                     24)
                                    drawcolor = (179,
                                     203,
                                     15,
                                     255)

                                class customPosition4(customPosition0):
                                    __module__ = __name__
                                    rect = (200,
                                     (173 + (4 * 26)),
                                     145,
                                     24)
                                    drawcolor = (24,
                                     201,
                                     99,
                                     255)

                                class text:
                                    __module__ = __name__
                                    type = 'MULTIEDIT'
                                    maxchar = 250
                                    rect = (37,
                                     52,
                                     308,
                                     80)
                                    drawcolor = (153,
                                     244,
                                     255,
                                     255)
                                    bkcolor = (0,
                                     0,
                                     0,
                                     0)
                                    textEdgeColor = (255,
                                     0,
                                     0,
                                     0)
                                    textsize = 12
                                    rowspace = 4
                                    editable = 1
                                    returnflag = 1
                                    maxline = 4
                                    richmode = 0
                                    accel = (('OnAccel_FocusPaste',
                                      86,
                                      17,
                                      0,
                                      0),
                                     ('OnAccel_FocusCut',
                                      88,
                                      17,
                                      0,
                                      0),
                                     ('OnAccel_FocusCopy',
                                      67,
                                      17,
                                      0,
                                      0))

                                    def OnAccel_FocusPaste():
                                        Win_FocusOnPaste()



                                    def OnAccel_FocusCut():
                                        Win_FocusOnCut()



                                    def OnAccel_FocusCopy():
                                        Win_FocusOnCopy()





                        class kinmemberDlg(TStatic):
                            __module__ = __name__
                            visible = 0
                            rect = (0,
                             30,
                             400,
                             500)
                            class children:
                                __module__ = __name__
                                class kinHonor(TLabel):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    rect = (250,
                                     32,
                                     70,
                                     25)
                                    caption = '\xb4\xf3\xcc\xec\xca\xb9'
                                    drawcolor = kinColor
                                    textEdgeColor = maskColor

                                class name(TLabel):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    rect = (20,
                                     32,
                                     120,
                                     25)
                                    caption = '\xb4\xf3\xcc\xec\xca\xb9'
                                    drawcolor = kinColor
                                    textEdgeColor = maskColor

                                class OnlineCount(TLabel):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    rect = (284,
                                     410,
                                     50,
                                     25)
                                    caption = 'abc'
                                    drawcolor = kinColor
                                    textEdgeColor = maskColor

                                class kinCount(TLabel,
                                 Static):
                                    __module__ = __name__
                                    textstyle = (dt_center + dt_vcenter)
                                    rect = (202,
                                     410,
                                     50,
                                     25)
                                    caption = 'abc'
                                    drawcolor = kinColor
                                    textEdgeColor = maskColor

                                class OnlineChk(TCheck):
                                    __module__ = __name__
                                    rect = (20,
                                     418,
                                     60,
                                     20)
                                    framescheme = [(-1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1),
                                     (0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0)]
                                    bkimage = 'object/ui/common/btn_check.img'

                                    def OnClick(this):
                                        global ShowOnline
                                        if Win_IsChecked(this):
                                            ShowOnline = 1
                                            ui_updateMemberList()
                                        else:
                                            ShowOnline = 0
                                            ui_updateMemberList()
                                        PlaySound(soundUI, 1)



                                class kinOprMenu(TWidget):
                                    __module__ = __name__
                                    initlayer = 9001
                                    visible = 0
                                    style = wgtstyle_popup
                                    rect = (0,
                                     0,
                                     77,
                                     99)
                                    bkimage = 'object/ui/guideBar/kin/bg_kin_menu.img'
                                    class children:
                                        __module__ = __name__
                                        class promotion(TButton):
                                            __module__ = __name__
                                            rect = (5,
                                             6,
                                             50,
                                             14)
                                            bkimage = 'object/ui/guideBar/btn_playermenuChoose.img'
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              -1,
                                              -1,
                                              -1,
                                              -1)]
                                            caption = '\xd6\xb0\xce\xbb\xcc\xe1\xc9\xfd'
                                            drawcolor = lightColor
                                            textEdgeType = -1

                                            def OnClick(this):
                                                Win_ShowWidget((uiKinMemberDlg + '.kinOprMenu'), 0)
                                                PlaySound(soundUI, 1)
                                                info = MemberList().at(ActiveMemberPos)
                                                uin = info.Uin
                                                print ('uin = %d' % uin)
                                                position = GetKinPositionByUin(info.Uin)
                                                DoKinTask('Y', position, len(position), uin, 2)



                                        class demotion(TButton):
                                            __module__ = __name__
                                            rect = (5,
                                             ((4 + 25) + 1),
                                             50,
                                             14)
                                            bkimage = 'object/ui/guideBar/btn_playermenuChoose.img'
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              -1,
                                              -1,
                                              -1,
                                              -1)]
                                            caption = '\xd6\xb0\xce\xbb\xcf\xc2\xb5\xf7'
                                            drawcolor = lightColor
                                            textEdgeType = -1

                                            def OnClick(this):
                                                Win_ShowWidget((uiKinMemberDlg + '.kinOprMenu'), 0)
                                                PlaySound(soundUI, 1)
                                                info = MemberList().at(ActiveMemberPos)
                                                uin = info.Uin
                                                print ('uin = %d' % uin)
                                                position = GetKinPositionByUin(info.Uin)
                                                DoKinTask('N', position, len(position), uin, 2)



                                        class fire(TButton):
                                            __module__ = __name__
                                            rect = (5,
                                             (4 + 50),
                                             50,
                                             14)
                                            bkimage = 'object/ui/guideBar/btn_playermenuChoose.img'
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              -1,
                                              -1,
                                              -1,
                                              -1)]
                                            caption = '\xbf\xaa\xb3\xfd\xb3\xc9\xd4\xb1'
                                            drawcolor = lightColor
                                            textEdgeType = -1

                                            def OnClick(this):
                                                Win_ShowWidget((uiKinMemberDlg + '.kinOprMenu'), 0)
                                                PlaySound(soundUI, 1)
                                                info = MemberList().at(ActiveMemberPos)
                                                uin = info.Uin
                                                Win_SetText((uiKinTipDlg + '.prompt'), ('\xc4\xfa\xc8\xb7\xb6\xa8\xd2\xaa\xbf\xaa\xb3\xfd%s[%d]\xc2\xf0?' % (info.nickname,
                                                 uin)))
                                                Win_SetText((uiKinTipDlg + '.pParam1'), '')
                                                Win_SetText((uiKinTipDlg + '.pParam2'), '')
                                                Win_SetText((uiKinTipDlg + '.uin'), str(uin))
                                                Win_SetText((uiKinTipDlg + '.TaskMode'), '5')
                                                ui_setCapture(uiKinTipDlg)





                                class scroll(TVScroll):
                                    __module__ = __name__
                                    rect = (345,
                                     77,
                                     26,
                                     198)
                                    pos = 0

                                    def OnPosChange():
                                        global kinMemberCnt
                                        global CurrentPos
                                        kinMemberCnt = MemberList().getCnt()
                                        if (ShowOnline == 0):
                                            ShowCnt = MemberList().getCnt()
                                        else:
                                            ShowCnt = MemberList().getOnlineCnt()
                                        ui = uiKinMemberDlg
                                        Win_SetRange((ui + '.scroll'), max((ShowCnt - defkinDlgCnt), 0))
                                        pos = Win_GetPos((ui + '.scroll'))
                                        if ((pos != CurrentPos) and PlaySound(soundUI, 1)):
                                            CurrentPos = pos
                                            for i in range(defkinDlgCnt):
                                                ui = (uiKinMemberDlg + ('.MemberPlayer%d' % i))
                                                Win_SetText((ui + '.NickName'), '')
                                                Win_SetText((ui + '.Grade'), '')
                                                Win_SetImg((ui + '.genderPic'), '')
                                                Win_SetText((ui + '.Position'), '')
                                                Win_SetText((ui + '.honor'), '')
                                                idx = (CurrentPos + i)
                                                if ((idx >= ShowCnt) and Win_SetText((ui + '.NickName'), '')):
                                                    Win_SetText((ui + '.Grade'), '')
                                                    Win_SetImg((ui + '.genderPic'), '')
                                                    Win_SetText((ui + '.Position'), '')
                                                    Win_SetText((ui + '.honor'), '')
                                                    Win_EnableWidget(ui, 0)
                                                    continue
                                                Win_SetCheck(ui, (idx == ActiveMemberPos))



                                    class children:
                                        __module__ = __name__
                                        class blockbtn(TScrollBtn):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              1,
                                              1,
                                              0,
                                              0)]
                                            rect = (0,
                                             0,
                                             26,
                                             41)
                                            bkimage = 'object/ui/common/scl_block.img'



                                class MemberPlayer0(TButton):
                                    __module__ = __name__
                                    bkcolor = (222,
                                     255,
                                     36,
                                     255)
                                    rect = (22,
                                     100,
                                     314,
                                     24)
                                    groupstop = 0
                                    framescheme = [(0,
                                      0,
                                      0,
                                      0,
                                      -1,
                                      -1,
                                      -1,
                                      -1)]
                                    bkimage = 'object/ui/guideBar/btn_player.img'
                                    bkimagepos = (0,
                                     -5)

                                    def OnClick(this):
                                        global ActiveMemberPos
                                        idx = getTailNum(this)
                                        ActiveMemberPos = (CurrentPos + idx)
                                        PlaySound(soundUI, 1)



                                    def OnRBtnUp(pos):
                                        global ActiveMemberPos
                                        PlaySound(soundUI, 1)
                                        me = Win_GetMyPath()
                                        idx = getTailNum(me)
                                        ActiveMemberPos = (CurrentPos + idx)
                                        (x, y,) = pos
                                        if ((x + 77) > 600):
                                            x = (600 - 77)
                                        Win_EnableWidget((uiKinMemberDlg + '.kinOprMenu.fire'), 1)
                                        myUin = GetLocalUin()
                                        kininfo = GetInviteKinInfo(1)
                                        if ((myUin != kininfo.m_dwUin) and Win_EnableWidget((uiKinMemberDlg + '.kinOprMenu.fire'), 0)):
                                            pass
                                        Win_Move2Pos((uiKinMemberDlg + '.kinOprMenu'), x, y)
                                        Win_ShowWidget((uiKinMemberDlg + '.kinOprMenu'), 1)
                                        Win_SetFocus((uiKinMemberDlg + '.kinOprMenu.promotion'))


                                    class children:
                                        __module__ = __name__
                                        class NickName(TLabel,
                                         Static):
                                            __module__ = __name__
                                            textstyle = (dt_center + dt_vcenter)
                                            rect = (0,
                                             0,
                                             77,
                                             24)
                                            drawcolor = kinColor
                                            textEdgeType = -1

                                        class genderPic(TStatic):
                                            __module__ = __name__
                                            rect = (88,
                                             0,
                                             34,
                                             24)
                                            textEdgeType = -1

                                        class Grade(TLabel,
                                         Static):
                                            __module__ = __name__
                                            textstyle = (dt_center + dt_vcenter)
                                            rect = (115,
                                             0,
                                             60,
                                             24)
                                            textEdgeType = -1
                                            drawcolor = kinColor

                                        class Position(TLabel,
                                         Static):
                                            __module__ = __name__
                                            textstyle = (dt_center + dt_vcenter)
                                            rect = (175,
                                             0,
                                             57,
                                             24)
                                            textEdgeType = -1
                                            drawcolor = kinColor

                                        class honor(TLabel,
                                         Static):
                                            __module__ = __name__
                                            textstyle = (dt_center + dt_vcenter)
                                            rect = (230,
                                             0,
                                             85,
                                             24)
                                            textEdgeType = -1
                                            drawcolor = kinColor



                                class MemberPlayer1(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + 24),
                                     314,
                                     24)
                                    groupstop = 1

                                class MemberPlayer2(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + (2 * 24)),
                                     314,
                                     24)
                                    groupstop = 2

                                class MemberPlayer3(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + (3 * 24)),
                                     314,
                                     24)
                                    groupstop = 3

                                class MemberPlayer4(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + (4 * 24)),
                                     314,
                                     24)
                                    groupstop = 4

                                class MemberPlayer5(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + (5 * 24)),
                                     314,
                                     24)
                                    groupstop = 5

                                class MemberPlayer6(MemberPlayer0):
                                    __module__ = __name__
                                    rect = (22,
                                     (100 + (6 * 24)),
                                     314,
                                     24)
                                    groupstop = 6

                                class amend(TButton):
                                    __module__ = __name__
                                    rect = (315,
                                     322,
                                     43,
                                     31)
                                    bkimage = 'object/ui/guideBar/btn_amend.img'
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]

                                    def OnClick(this):
                                        Win_SetValue((uiKinMemberDlg + '.text'), 1, 905)
                                        Win_SetDrawColor((uiKinMemberDlg + '.text'), 255, 255, 255, 255)
                                        Win_SetFocus((uiKinMemberDlg + '.text'))
                                        PlaySound(soundUI, 1)



                                class issue(TButton):
                                    __module__ = __name__
                                    rect = (315,
                                     368,
                                     43,
                                     31)
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    bkimage = 'object/ui/guideBar/btn_issue.img'

                                    def OnClick(this):
                                        broadcast = Win_GetText((uiKinMemberDlg + '.text'))
                                        if ((broadcast != '') and DoKinTask('', broadcast, len(broadcast), 0, 14)):
                                            pass
                                        Win_SetValue((uiKinMemberDlg + '.text'), 0, 905)
                                        Win_SetDrawColor((uiKinMemberDlg + '.text'), 255, 123, 44, 255)
                                        PlaySound(soundUI, 1)



                                class text:
                                    __module__ = __name__
                                    type = 'MULTIEDIT'
                                    maxchar = 134
                                    rect = (28,
                                     316,
                                     260,
                                     80)
                                    drawcolor = kinColor
                                    textEdgeColor = maskColor
                                    textsize = 12
                                    rowspace = 4
                                    editable = 0
                                    returnflag = 1
                                    maxline = 4
                                    richmode = 0
                                    accel = (('OnAccel_FocusPaste',
                                      86,
                                      17,
                                      0,
                                      0),
                                     ('OnAccel_FocusCut',
                                      88,
                                      17,
                                      0,
                                      0),
                                     ('OnAccel_FocusCopy',
                                      67,
                                      17,
                                      0,
                                      0))

                                    def OnAccel_FocusPaste():
                                        Win_FocusOnPaste()



                                    def OnAccel_FocusCut():
                                        Win_FocusOnCut()



                                    def OnAccel_FocusCopy():
                                        Win_FocusOnCopy()









        class createkinhintDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            darkBG = 1
            visible = 0
            rect = (200,
             100,
             368,
             326)
            bkimage = 'object/ui/guideBar/kin/dlg_createHint.img'

            def OnEscape():
                doUI((uiKinCreateHintDlg + '.cancel'), 'OnClick')



            def OnEnter():
                doUI((uiKinCreateHintDlg + '.confirm'), 'OnClick')


            class children:
                __module__ = __name__
                class confirm(TButton):
                    __module__ = __name__
                    rect = (110,
                     280,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinCreateHintDlg, 0)
                        ui_setCapture(uiKinCreateDlg)
                        Win_SetText((uiKinCreateDlg + '.kinName'), '')
                        Win_SetText((uiKinCreateDlg + '.text'), '')
                        Win_SetCheck((uiKinCreateDlg + '.dianxin'), 1)
                        Win_SetFocus((uiKinCreateDlg + '.kinName'))
                        PlaySound(soundLeave, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (220,
                     280,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinCreateHintDlg, 0)
                        doUI((uiSocialityDlg + '.crossBtn'), 'OnClick')
                        PlaySound(soundLeave, 1)





        class createkinDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            darkBG = 1
            visible = 0
            rect = (200,
             100,
             327,
             378)
            bkimage = 'object/ui/guideBar/kin/dlg_createKin.img'

            def OnEscape():
                doUI((uiKinCreateDlg + '.cancel'), 'OnClick')



            def OnEnter():
                doUI((uiKinCreateDlg + '.confirm'), 'OnClick')


            class children:
                __module__ = __name__
                class confirm(TButton):
                    __module__ = __name__
                    rect = (100,
                     330,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        text = Win_GetText((uiKinCreateDlg + '.text'))
                        text = filterChatMsg(text)
                        text = text.replace('\n', ' ')
                        name = Win_GetText((uiKinCreateDlg + '.kinName'))
                        name = filterChatMsg(name)
                        name = name.replace('\n', '')
                        name = name.replace(' ', '')
                        if Win_IsChecked((uiKinCreateDlg + '.dianxin')):
                            kinSection = 1
                        else:
                            kinSection = 2
                        strlen = len(text)
                        DoKinTask(name, text, strlen, kinSection, 0)
                        Win_ShowWidget(uiKinCreateDlg, 0)
                        PlaySound(soundLeave, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (180,
                     330,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinCreateDlg, 0)
                        doUI((uiSocialityDlg + '.crossBtn'), 'OnClick')
                        PlaySound(soundLeave, 1)



                class dianxin(TRadio):
                    __module__ = __name__
                    rect = (108,
                     285,
                     60,
                     20)
                    bkimage = 'object/ui/common/btn_check.img'
                    framescheme = [(-1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    bkimagepos = (0,
                     5)
                    groupstop = 1

                class wangtong(dianxin):
                    __module__ = __name__
                    rect = (169,
                     285,
                     60,
                     20)
                    bkimage = 'object/ui/common/btn_check.img'
                    framescheme = [(-1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    bkimagepos = (0,
                     5)
                    groupstop = 2

                class kinName(TRichEdit):
                    __module__ = __name__
                    initlayer = 10000
                    maxchar = 14
                    rect = (100,
                     80,
                     122,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    caption = 'abcd'

                    def OnTab():
                        Win_SetFocus((uiKinCreateDlg + '.text'))



                class text:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 160
                    rect = (40,
                     155,
                     240,
                     80)
                    drawcolor = zoneChooseColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 4
                    richmode = 0
                    caption = 'abcd'
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()



                    def OnTab():
                        Win_SetFocus((uiKinCreateDlg + '.kinName'))





        class topkinDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            darkBG = 1
            visible = 0
            rect = (200,
             50,
             384,
             450)
            bkimage = 'object/ui/guideBar/kin/dlg_topkin.img'

            def OnEscape():
                doUI((uitopKinDlg + '.closeBtn'), 'OnClick')



            def OnEnter():
                doUI((uitopKinDlg + '.closeBtn'), 'OnClick')


            class children:
                __module__ = __name__
                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (360,
                     31,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uitopKinDlg, 0)
                        PlaySound(soundLeave, 1)



                class telecomBtn(TTabWin):
                    __module__ = __name__
                    groupid = 5
                    groupstop = 1
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (15,
                     0,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/kin/btn_telecom.img'

                    def OnClick(this):
                        global chinatelecom
                        chinatelecom = 1
                        ui_updateTopkinList()
                        PlaySound(soundUI, 1)



                class unicomBtn(TTabWin):
                    __module__ = __name__
                    groupid = 5
                    groupstop = 2
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (80,
                     0,
                     64,
                     28)
                    hotcover = 'object/ui/guideBar/kin/btn_netcom.img'

                    def OnClick(this):
                        global chinatelecom
                        chinatelecom = 0
                        ui_updateTopkinList()
                        PlaySound(soundUI, 1)



                class honorBtn(TTabWin):
                    __module__ = __name__
                    groupid = 6
                    groupstop = 1
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (15,
                     33,
                     63,
                     34)
                    hotcover = 'object/ui/guideBar/kin/btn_honor.img'

                    def OnClick(this):
                        global setreputation
                        setreputation = 1
                        Win_ShowWidget((uitopKinDlg + '.activity'), 0)
                        ui_updateTopkinList()
                        PlaySound(soundUI, 1)



                class activityBtn(TTabWin):
                    __module__ = __name__
                    groupid = 6
                    groupstop = 2
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (81,
                     33,
                     63,
                     34)
                    hotcover = 'object/ui/guideBar/kin/btn_activity.img'

                    def OnClick(this):
                        global setreputation
                        setreputation = 0
                        Win_ShowWidget((uitopKinDlg + '.activity'), 1)
                        ui_updateTopkinList()
                        PlaySound(soundUI, 1)



                class activity(TLabel):
                    __module__ = __name__
                    rect = (160,
                     67,
                     43,
                     24)
                    bkimage = 'object/ui/guideBar/kin/img_activity.img'

                class topkin0(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    bkimage = 'object/ui/guideBar/btn_player.img'
                    bkimagepos = (0,
                     -4)
                    rect = (24,
                     106,
                     314,
                     24)

                    def OnClick(this):
                        global lookupKinID
                        global ActivetopkinPos
                        idx = getTailNum(this)
                        ActivetopkinPos = (TopkinCurrentPos + idx)
                        info = TopkinList().at(ActivetopkinPos)
                        lookupKinID = info.kinindex
                        doUI((uiPlayerInfoDlg + '.lookup'), 'OnClick')
                        PlaySound(soundUI, 1)


                    class children:
                        __module__ = __name__
                        class kinName(TLabel,
                         Static):
                            __module__ = __name__
                            textstyle = (dt_center + dt_vcenter)
                            rect = (2,
                             0,
                             86,
                             24)
                            drawcolor = normalNameColor
                            textEdgeType = 0
                            textEdgeColor = maskColor

                        class value(TLabel,
                         Static):
                            __module__ = __name__
                            textstyle = (dt_center + dt_vcenter)
                            rect = (135,
                             0,
                             60,
                             24)
                            drawcolor = normalNameColor
                            textEdgeType = 0
                            textEdgeColor = maskColor

                        class Order(TLabel,
                         Static):
                            __module__ = __name__
                            textstyle = (dt_center + dt_vcenter)
                            rect = (240,
                             0,
                             40,
                             24)
                            drawcolor = normalNameColor
                            textEdgeType = 0
                            textEdgeColor = maskColor

                        class isAscend(TStatic):
                            __module__ = __name__
                            rect = (280,
                             4,
                             20,
                             20)



                class topkin1(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + 24),
                     314,
                     24)

                class topkin2(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + (2 * 24)),
                     314,
                     24)

                class topkin3(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + (3 * 24)),
                     314,
                     24)

                class topkin4(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + (4 * 24)),
                     314,
                     24)

                class topkin5(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + (5 * 24)),
                     314,
                     24)

                class topkin6(topkin0):
                    __module__ = __name__
                    rect = (24,
                     (106 + (6 * 24)),
                     314,
                     24)

                class topkin7(topkin0):
                    __module__ = __name__
                    bkimage = ''
                    rect = (24,
                     (109 + (7 * 24)),
                     314,
                     27)

                    def OnClick(this):
                        global lookupKinID
                        kinobject = fetch_topkininfolist(chinatelecom, setreputation, 10)
                        lookupKinID = kinobject.m_dwKinIndex
                        doUI((uiPlayerInfoDlg + '.lookup'), 'OnClick')
                        PlaySound(soundUI, 1)



                class topkin8(topkin7):
                    __module__ = __name__
                    bkimage = ''
                    rect = (24,
                     (110 + (8 * 24)),
                     314,
                     27)

                    def OnClick(this):
                        global lookupKinID
                        kinobject = fetch_topkininfolist(chinatelecom, setreputation, 11)
                        lookupKinID = kinobject.m_dwKinIndex
                        doUI((uiPlayerInfoDlg + '.lookup'), 'OnClick')
                        PlaySound(soundUI, 1)



                class scroll(TVScroll):
                    __module__ = __name__
                    rect = (352,
                     96,
                     26,
                     216)
                    pos = 0

                    def OnPosChange():
                        global TopkinCnt
                        global TopkinCurrentPos
                        TopkinCnt = TopkinList().getCnt()
                        ShowCnt = TopkinList().getCnt()
                        ui = uitopKinDlg
                        Win_SetRange((ui + '.scroll'), max((ShowCnt - defTopkinDlgCnt), 0))
                        pos = Win_GetPos((ui + '.scroll'))
                        if ((pos != TopkinCurrentPos) and PlaySound(soundUI, 1)):
                            TopkinCurrentPos = pos
                            for i in range(defTopkinDlgCnt):
                                ui = (uitopKinDlg + ('.topkin%d' % i))
                                Win_SetText((ui + '.kinName'), '')
                                Win_SetText((ui + '.value'), '')
                                Win_SetText((ui + '.Order'), '')
                                idx = (TopkinCurrentPos + i)
                                if ((idx >= ShowCnt) and Win_SetText((ui + '.kinName'), '')):
                                    Win_SetText((ui + '.value'), '')
                                    Win_SetText((ui + '.Order'), '')
                                    Win_SetImg((ui + '.isAscend'), '')
                                    Win_EnableWidget(ui, 0)
                                    continue
                                Win_SetCheck(ui, (idx == ActivetopkinPos))



                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              1,
                              1,
                              0,
                              0,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             41)
                            bkimage = 'object/ui/common/scl_block.img'





        class kinInfoDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/guideBar/kin/dlg_kinInfo.img'
            class children:
                __module__ = __name__
                class kinname(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (110,
                     60,
                     160,
                     12)
                    drawcolor = normalNameColor
                    ttextEdgeColor = (0,
                     49,
                     174,
                     255)
                    textstyle = dt_center

                class kinSection(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     90,
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class governor(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + 24),
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class Size(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + (2 * 24)),
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class Grade(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + (3 * 24)),
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class Credit(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + (4 * 24)),
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class MemberCount(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + (5 * 24)),
                     211,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1

                class Proclaim(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (150,
                     (90 + (6 * 24)),
                     211,
                     32)
                    textstyle = (dt_left + dt_top)
                    drawcolor = maskColor
                    textEdgeType = -1
                    rowspace = 7

                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (362,
                     7,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinInfoDlg, False)
                        Win_ShowWidget(uiPlayerInfoDlg, False)
                        PlaySound(soundLeave, 1)





        class marriageInfoDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             364,
             385)
            bkimage = 'object/ui/marriage/dlg_marriageInfo.img'
            class children:
                __module__ = __name__
                class spouseName(TLabel):
                    __module__ = __name__
                    rect = (83,
                     70,
                     128,
                     12)
                    caption = ''
                    drawcolor = normalNameColor
                    ttextEdgeColor = (0,
                     49,
                     174,
                     255)
                    textstyle = dt_center

                class marriageAge(TLabel):
                    __module__ = __name__
                    rect = (83,
                     (68 + 24),
                     128,
                     12)
                    caption = '0'
                    drawcolor = maskColor
                    textEdgeType = -1
                    textstyle = dt_center

                class marriageLevel(TStatic):
                    __module__ = __name__
                    rect = (89,
                     (68 + 42),
                     125,
                     30)
                    drawcolor = maskColor
                    textEdgeType = -1
                    class children:
                        __module__ = __name__
                        class level1(TStatic):
                            __module__ = __name__
                            visible = 1
                            rect = (0,
                             0,
                             20,
                             24)

                        class level2(level1):
                            __module__ = __name__
                            rect = ((0 + 24),
                             0,
                             20,
                             24)

                        class level3(level1):
                            __module__ = __name__
                            rect = ((0 + (24 * 2)),
                             0,
                             20,
                             24)

                        class level4(level1):
                            __module__ = __name__
                            rect = ((0 + (24 * 3)),
                             0,
                             20,
                             24)

                        class level5(level1):
                            __module__ = __name__
                            rect = ((0 + (24 * 4)),
                             0,
                             20,
                             24)



                class closeLine(TButton):
                    __module__ = __name__
                    rect = (83,
                     (68 + 66),
                     125,
                     17)
                    bkimage = 'object/ui/marriage/dlg_closeLine.img'

                    def OnMouseMoveIn():
                        print 'mousemovein!'
                        Win_ShowWidget((uiMarriageDlg + '.closeLineValue'), 1)



                    def OnMouseMoveOut():
                        print 'mousemoveout!'
                        Win_ShowWidget((uiMarriageDlg + '.closeLineValue'), 0)



                class closeLineValue(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (87,
                     (68 + 36),
                     128,
                     35)
                    bkimage = 'object/ui/marriage/dlg_closeLineValue.img'
                    class children:
                        __module__ = __name__
                        class value(TLabel):
                            __module__ = __name__
                            rect = (10,
                             0,
                             128,
                             25)
                            caption = ''
                            drawcolor = maskColor
                            textEdgeType = -1
                            textstyle = dt_center



                class closeNum(TLabel):
                    __module__ = __name__
                    rect = (83,
                     (68 + 92),
                     128,
                     12)
                    caption = ''
                    drawcolor = maskColor
                    textEdgeType = -1
                    textstyle = dt_center

                class loveword(TLabel,
                 Static):
                    __module__ = __name__
                    rowspace = 2
                    caption = ''
                    rect = (41,
                     (68 + 165),
                     295,
                     95)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1

                class modify(TButton):
                    __module__ = __name__
                    rect = (180,
                     187,
                     37,
                     20)
                    bkimage = 'object/ui/marriage/btn_modify.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui_setCapture(uiModifyLoveWordDlg)
                        PlaySound(soundUI, 1)



                class divorce(TButton):
                    __module__ = __name__
                    rect = (83,
                     348,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_divorce.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiMarriageDlg, 0)
                        ui_setCapture(uiDivorceDlg)
                        PlaySound(soundUI, 1)



                class close(TButton):
                    __module__ = __name__
                    rect = (235,
                     348,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_close.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiMarriageDlg, 0)
                        PlaySound(soundLeave, 1)



                class ring(TStatic):
                    __module__ = __name__
                    rect = (231,
                     61,
                     20,
                     19)
                    framescheme = [(0,
                      13,
                      0,
                      13,
                      0,
                      13,
                      0,
                      13)]

                class noRing(TButton):
                    __module__ = __name__
                    initlayer = -99999
                    rect = (238,
                     63,
                     99,
                     99)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/marriage/btn_noRing.img'

                    def OnClick(this):
                        Win_ShowWidget(uiMarriageDlg, 0)
                        doUI('UI.selRoom.shopBtn', 'OnClick')
                        PlaySound(soundUI, 1)





        class modifyLoveWordDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/marriage/dlg_loveWord.img'
            class children:
                __module__ = __name__
                class loveword:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 198
                    rect = (42,
                     110,
                     235,
                     80)
                    caption = 'for ever\xa1\xad\xa1\xad'
                    drawcolor = zoneChooseColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 5
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()



                class save(TButton):
                    __module__ = __name__
                    rect = (85,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_save.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        txt = Win_GetText((uiModifyLoveWordDlg + '.loveword'))
                        SaveLoveWord(len(txt), txt)
                        Win_ShowWidget(uiModifyLoveWordDlg, 0)
                        PlaySound(soundUI, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (225,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_divorceCancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiModifyLoveWordDlg, 0)
                        PlaySound(soundLeave, 1)





        class sparkDlg(TStatic):
            __module__ = __name__
            initlayer = 99999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/marriage/dlg_spark.img'
            class children:
                __module__ = __name__
                class spouseName(TLabel):
                    __module__ = __name__
                    rect = (115,
                     65,
                     105,
                     20)
                    drawcolor = normalNameColor
                    ttextEdgeColor = (0,
                     49,
                     174,
                     255)
                    textstyle = dt_center

                class sparkword:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 198
                    rect = (45,
                     140,
                     270,
                     70)
                    drawcolor = zoneChooseColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 5
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()



                class send(TButton):
                    __module__ = __name__
                    rect = (70,
                     280,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_sparkSend.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        txt = Win_GetText((uiSparkDlg + '.sparkword'))
                        Win_ShowWidget(uiSparkDlg, 0)
                        Spark(len(txt), txt, beSparkedUin)
                        PlaySound(soundUI, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (220,
                     280,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_sparkCancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiSparkDlg, 0)
                        PlaySound(soundLeave, 1)





        class weddingOverDlg(TStatic):
            __module__ = __name__
            initlayer = 99999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             327,
             378)
            bkimage = 'object/ui/marriage/dlg_weddingSuccess.img'
            class children:
                __module__ = __name__
                class congratulations:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 198
                    rect = (40,
                     90,
                     240,
                     170)
                    drawcolor = zoneChooseColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 5
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()



                class confirm(TButton):
                    __module__ = __name__
                    rect = (126,
                     323,
                     53,
                     32)
                    bkimage = 'object/ui/marriage/btn_divorceConfirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiWeddingOverDlg, 0)
                        SetWeddingEffect(weddingEffectFile)





        class marriageConfirmDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/marriage/dlg_marriageConfirm.img'
            class children:
                __module__ = __name__
                class marriageWord(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (44,
                     85,
                     215,
                     105)
                    rowspace = 2
                    caption = '\xbc\xde\xb8\xf8\xce\xd2\xb0\xc9'
                    drawcolor = darkColor
                    textEdgeType = -1

                class accept(TButton):
                    __module__ = __name__
                    rect = (75,
                     250,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_Iaccept.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        print 'sparkUin:',
                        print sparkUin,
                        print '   uin:',
                        print uin,
                        print '  beSparkedUin:',
                        print beSparkedUin
                        if ((uin == sparkUin) and AnswerWedding(0, beSparkedUin)):
                            pass
                        Win_ShowWidget(uiMarriageConfirmDlg, 0)
                        PlaySound(soundUI, 1)



                class reject(TButton):
                    __module__ = __name__
                    rect = (290,
                     250,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_Ireject.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        if ((uin == sparkUin) and AnswerWedding(1, beSparkedUin)):
                            pass
                        Win_ShowWidget(uiMarriageConfirmDlg, 0)
                        PlaySound(soundLeave, 1)





        class divorceDlg(TStatic):
            __module__ = __name__
            initlayer = 99999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/marriage/dlg_divorce.img'
            class children:
                __module__ = __name__
                class confirm(TButton):
                    __module__ = __name__
                    rect = (70,
                     203,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_divorceConfirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiDivorceDlg, 0)
                        Divorce()
                        PlaySound(soundUI, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (220,
                     203,
                     65,
                     25)
                    bkimage = 'object/ui/marriage/btn_divorceCancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiDivorceDlg, 0)
                        PlaySound(soundLeave, 1)





        class receiveSparkDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 393) / 2),
             ((600 - 361) / 2),
             393,
             361)
            bkimage = 'object/ui/marriage/dlg_receiveSpark.img'
            class children:
                __module__ = __name__
                class sparkword(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (40,
                     130,
                     235,
                     110)
                    rowspace = 2
                    caption = '\xbc\xde\xb8\xf8\xce\xd2\xb0\xc9'
                    drawcolor = zoneChooseColor
                    textEdgeType = -1

                class accept(TButton):
                    __module__ = __name__
                    rect = (53,
                     325,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_Iaccept.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        AnswerSpark(0, sparkUin)
                        Win_ShowWidget(uiReceiveSparkDlg, 0)
                        PlaySound(soundUI, 1)



                class reject(TButton):
                    __module__ = __name__
                    rect = (190,
                     325,
                     65,
                     31)
                    bkimage = 'object/ui/marriage/btn_Ireject.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        AnswerSpark(1, sparkUin)
                        Win_ShowWidget(uiReceiveSparkDlg, 0)
                        PlaySound(soundLeave, 1)





        class kinInviteDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (200,
             100,
             393,
             361)
            bkimage = 'object/ui/guideBar/kin/dlg_kinInvite.img'
            class children:
                __module__ = __name__
                class name(TLabel):
                    __module__ = __name__
                    rect = (45,
                     63,
                     175,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_center

                class cross(TButton):
                    __module__ = __name__
                    rect = (362,
                     8,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinInviteDlg, 0)
                        PlaySound(soundUI, 1)



                class confirm(TButton):
                    __module__ = __name__
                    rect = (120,
                     309,
                     63,
                     31)
                    bkimage = 'object/ui/common/btn_agree.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinInviteDlg, 0)
                        DoKinTask('', 'Y', 1, 0, 11)
                        PlaySound(soundUI, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (210,
                     309,
                     63,
                     31)
                    bkimage = 'object/ui/common/btn_refuse.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinInviteDlg, 0)
                        DoKinTask('', 'N', 1, 0, 11)
                        PlaySound(soundUI, 1)



                class kininfo_status(TLabel):
                    __module__ = __name__
                    rect = (150,
                     90,
                     180,
                     12)
                    textstyle = (dt_left + dt_vcenter)
                    drawcolor = maskColor
                    textEdgeType = -1

                class kininfo_governor(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + 24),
                     180,
                     12)

                class kininfo_size(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + (24 * 2)),
                     180,
                     12)

                class kininfo_grade(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + (24 * 3)),
                     180,
                     12)

                class kininfo_honor(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + (24 * 4)),
                     180,
                     12)

                class kininfo_MemberCount(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + (24 * 5)),
                     180,
                     12)

                class kininfo_enounce(kininfo_status):
                    __module__ = __name__
                    rect = (150,
                     (90 + (24 * 6)),
                     180,
                     32)
                    textstyle = (dt_left + dt_top)
                    rowspace = 7



        class kinTipDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            class children:
                __module__ = __name__
                class confirm(TButton):
                    __module__ = __name__
                    rect = (100,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        pPar1 = Win_GetText((uiKinTipDlg + '.pParam1'))
                        pPar2 = Win_GetText((uiKinTipDlg + '.pParam2'))
                        Uin = int(Win_GetText((uiKinTipDlg + '.uin')))
                        iMode = int(Win_GetText((uiKinTipDlg + '.TaskMode')))
                        DoKinTask(pPar1, pPar2, len(pPar2), Uin, iMode)
                        Win_ShowWidget(uiKinTipDlg, 0)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (225,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiKinTipDlg, 0)



                class prompt(TLabel):
                    __module__ = __name__
                    rect = (42,
                     84,
                     280,
                     130)
                    textEdgeType = -1
                    drawcolor = zoneChooseColor

                class pParam1(TLabel):
                    __module__ = __name__
                    visible = 0

                class pParam2(TLabel):
                    __module__ = __name__
                    visible = 0

                class uin(TLabel):
                    __module__ = __name__
                    visible = 0

                class TaskMode(TLabel):
                    __module__ = __name__
                    visible = 0



        class requestMakeFriendsDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/guideBar/friend/dlg_addFriends.img'
            class children:
                __module__ = __name__
                class name(TButton):
                    __module__ = __name__
                    rect = (122,
                     76,
                     120,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textstyle = dt_left

                    def OnClick(this):
                        go2playerInfo(friendUin)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (196,
                     280,
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiAddFriendDlg, 0)



                class confirm(TButton):
                    __module__ = __name__
                    rect = (120,
                     280,
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        txt = Win_GetText((uiAddFriendDlg + '.text'))
                        txt = filterChatMsg(txt)
                        placeholder = ('%c' % 7)
                        txt = txt.replace('\n', placeholder)
                        strlen = len(txt)
                        DoFriendTask(txt, strlen, friendUin, 1)
                        Win_ShowWidget(uiAddFriendDlg, 0)



                class text:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 50
                    rect = (42,
                     136,
                     280,
                     76)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 3
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()





        class friendDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/guideBar/friend/dlg_beAddedFriends.img'
            class children:
                __module__ = __name__
                class name(TButton):
                    __module__ = __name__
                    rect = (122,
                     76,
                     120,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textstyle = dt_left

                    def OnClick(this):
                        print 'Click response on name'
                        go2playerInfo(beAddUin)



                class refuse(TButton):
                    __module__ = __name__
                    rect = (196,
                     280,
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_refuse.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiBeAddedFriendDlg, 0)
                        DoFriendTask('n', 0, beAddUin, 6)



                class confirm(TButton):
                    __module__ = __name__
                    rect = (120,
                     280,
                     66,
                     27)
                    bkimage = 'object/ui/common/btn_agree.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiBeAddedFriendDlg, 0)
                        if Win_IsChecked((uiBeAddedFriendDlg + '.addFriend')):
                            txt = Win_GetText((uiBeAddedFriendDlg + '.text'))
                            txt = filterChatMsg(txt)
                            strlen = len(txt)
                            DoFriendTask(txt, strlen, beAddUin, 1)
                        DoFriendTask('y', 0, beAddUin, 6)



                class addFriend(TCheck):
                    __module__ = __name__
                    framescheme = [(-1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (32,
                     212,
                     120,
                     16)
                    bkimagepos = (0,
                     5)
                    bkimage = 'object/ui/common/btn_check.img'

                    def OnClick(this):
                        PlaySound(soundUI, 1)



                class text:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 50
                    rect = (42,
                     136,
                     280,
                     60)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 3
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()





        class joinMemberWeb(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 365) / 2),
             ((600 - 290) / 2),
             368,
             326)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            bkimagepos = (-5,
             -19)
            darkBG = 1
            class children:
                __module__ = __name__
                class crossBtn(TButton):
                    __module__ = __name__
                    rect = (160,
                     260,
                     43,
                     31)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/common/btn_close.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.joinMemberWeb', 0)
                        sc_HideWeb('joinmember')
                        PlaySound(soundLeave, 1)
                        if ((1 == exitFlag) and OnMsgBoxResult(((2 << 24) + 1), 1)):
                            pass





        class playerMenu(TWidget):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            style = wgtstyle_popup
            rect = (110,
             110,
             67,
             108)
            bkimage = 'object/ui/guideBar/dlg_playermenu.img'
            class children:
                __module__ = __name__
                class messageBtn(TButton):
                    __module__ = __name__
                    rect = (0,
                     2,
                     67,
                     14)
                    bkimage = 'object/ui/guideBar/btn_playermenuChoose.img'
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    caption = '\xb7\xa2\xcb\xcd\xc3\xdc\xd3\xef'
                    drawcolor = lightColor
                    textEdgeType = -1

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        NotifyWisper(friendName, friendUin)



                class traceBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     17,
                     67,
                     14)
                    caption = '\xba\xc3\xd3\xd1\xd7\xb7\xd7\xd9'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        DoFriendTask('', 0, friendUin, 3)



                class addBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     35,
                     67,
                     14)
                    caption = '\xcc\xed\xbc\xd3\xba\xc3\xd3\xd1'

                    def OnClick(this):
                        NickName = GetPlayerNickNamebyUin(friendUin, 0)
                        NickName = NickName.replace('\n', '')
                        Win_ShowWidget(uiPlayerMenu, 0)
                        Win_SetText((uiAddFriendDlg + '.text'), '')
                        Win_SetFocus((uiAddFriendDlg + '.text'))
                        Win_SetText((uiAddFriendDlg + '.name'), NickName)
                        ui_setCapture(uiAddFriendDlg)



                class deleteBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     35,
                     67,
                     14)
                    caption = '\xc9\xbe\xb3\xfd\xba\xc3\xd3\xd1'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        DoFriendTask('', 0, friendUin, 2)



                class infoBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     53,
                     67,
                     14)
                    caption = '\xb2\xe9\xbf\xb4\xd7\xca\xc1\xcf'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        go2playerInfo(friendUin)



                class shieldBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     71,
                     67,
                     14)
                    caption = '\xc6\xc1\xb1\xce\xcd\xe6\xbc\xd2'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        DoFriendTask('', 0, friendUin, 5)



                class unshieldBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     71,
                     67,
                     14)
                    caption = '\xc8\xa1\xcf\xfb\xc6\xc1\xb1\xce'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        DoFriendTask('', 0, friendUin, 7)



                class kininviteBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     89,
                     67,
                     14)
                    caption = '\xbc\xd2\xd7\xe5\xd1\xfb\xc7\xeb'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        DoKinTask('', '', 0, friendUin, 4)



                class C2CInviteBtn(messageBtn):
                    __module__ = __name__
                    rect = (0,
                     106,
                     67,
                     14)
                    caption = '\xd3\xeb\xcb\xfb\xbd\xbb\xd2\xd7'

                    def OnClick(this):
                        Win_ShowWidget(uiPlayerMenu, 0)
                        NotifyWisper(friendName, friendUin)
                        SectionChat(0, ('/c2c ' + str(friendUin)))





        class taskSelectDlg(TStatic):
            __module__ = __name__
            initlayer = 99999
            darkBG = 1
            visible = 0
            rect = (200,
             100,
             368,
             326)
            bkimage = 'object/ui/task/dlg_taskSelect.img'
            class children:
                __module__ = __name__
                class taskPractic(TButton):
                    __module__ = __name__
                    rect = (52,
                     132,
                     112,
                     91)
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    bkimage = 'object/ui/task/btn_greenHand.img'

                    def OnClick(this):
                        print 'select practice task...........'
                        Win_ShowWidget(uiTaskSelDlg, 0)
                        Win_ShowWidget('UI.newPlayerDirectionDlg', 0)
                        PlaySound(soundLeave, 1)
                        DisableEnterRoom()
                        print 'enter practice room'
                        sc_beginTutorial()



                class freePractice(TButton):
                    __module__ = __name__
                    rect = (198,
                     132,
                     112,
                     91)
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    bkimage = 'object/ui/task/btn_free.img'

                    def OnClick(this):
                        print 'select free practice.............'
                        Win_ShowWidget(uiTaskSelDlg, 0)
                        Win_ShowWidget('UI.newPlayerDirectionDlg', 0)
                        PlaySound(soundLeave, 1)
                        DisableEnterRoom()
                        print 'enter freePractice room'
                        sc_beginFreePractice()



                class cancel(TButton):
                    __module__ = __name__
                    rect = (160,
                     280,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiTaskSelDlg, 0)
                        Win_ShowWidget('UI.newPlayerDirectionDlg', 0)
                        PlaySound(soundLeave, 1)





        class newPlayerDirectionDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (518,
             105,
             280,
             85)
            bkimage = 'object/ui/game/newplayerpopo.img'
            class children:
                __module__ = __name__
                class text(TLabel):
                    __module__ = __name__
                    rect = (58,
                     22,
                     200,
                     50)
                    drawcolor = (51,
                     113,
                     149,
                     255)
                    textEdgeType = -1
                    caption = '\xc4\xfa\xcf\xd6\xd4\xda\xbf\xc9\xd2\xd4\xd6\xd8\xb8\xb4\xd0\xc2\xca\xd6\xc8\xce\xce\xf1\xa3\xac\n\xd2\xb2\xbf\xc9\xd2\xd4\xd1\xa1\xd4\xf1\xbd\xf8\xd0\xd0\xd7\xd4\xd3\xc9\xc1\xb7\xcf\xb0\xa1\xa3\n\xc8\xe7\xb9\xfb\xc4\xfa\xb2\xd9\xd7\xf7\xb6\xbc\xd2\xd1\xca\xec\xc1\xb7\xb5\xc4\xbb\xb0\xa3\xac\n\xb9\xa7\xcf\xb2\xc4\xe3\xbf\xc9\xd2\xd4\xb8\xfa\xc6\xe4\xcb\xfb\xcd\xe6\xbc\xd2PK\xc1\xcb'



        class SetRecorderDlg(TDlg):
            __module__ = __name__
            initlayer = 999999
            darkBG = 1
            visible = 0
            rect = (130,
             60,
             393,
             361)
            bkimage = 'object/ui/guideBar/dlg_record.img'

            def initMe():
                Win_SetText((uiSetRecorderDlg + '.CurrentDirLabel'), os_join(os_getmoduledir(), 'Record'))
                Win_SetPos((uiSetRecorderDlg + '.scroll'), 0)
                doUI((uiSetRecorderDlg + '.scroll'), 'OnPosChange')


            class children:
                __module__ = __name__
                class CurrentDirLabel(TEdit):
                    __module__ = __name__
                    editable = 0
                    maxchar = 200
                    rect = (64,
                     50,
                     245,
                     12)
                    drawcolor = lightColor
                    caption = os_join(os_getmoduledir(), 'Record')
                    class children:
                        __module__ = __name__
                        class icon(TStatic):
                            __module__ = __name__
                            framescheme = [(1,
                              1,
                              1,
                              1,
                              1,
                              1,
                              1,
                              1)]
                            rect = (-26,
                             -3,
                             17,
                             12)
                            bkimage = 'object/ui/record/icon_folder.img'



                class GotoUpButton(TButton):
                    __module__ = __name__
                    rect = (320,
                     44,
                     34,
                     22)
                    bkimage = 'object/ui/guideBar/btn_folderUp.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        curDirname = Win_GetText((uiSetRecorderDlg + '.CurrentDirLabel'))
                        if (curDirname == '\xce\xd2\xb5\xc4\xb5\xe7\xc4\xd4'):
                            print '\xce\xd2\xb5\xc4\xb5\xe7\xc4\xd4'
                            return ''
                        parentDirname = os_dirname(curDirname)
                        print parentDirname
                        print 'not ismount'
                        Win_SetText((uiSetRecorderDlg + '.CurrentDirLabel'), parentDirname)
                        doUI((uiSetRecorderDlg + '.scroll'), 'OnPosChange')



                class OK(TButton):
                    __module__ = __name__
                    rect = (116,
                     370,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        currentDirname = Win_GetText((uiSetRecorderDlg + '.CurrentDirLabel'))
                        print currentDirname
                        print curFile
                        if (curFile == -1):
                            print 'no selected file'
                        else:
                            pos = Win_GetPos((uiSetRecorderDlg + '.scroll'))
                            currFilename = Win_GetText((((uiSetRecorderDlg + '.file') + str((curFile + 1))) + '.name'))
                            print 'isdir',
                            print os_isdir(os_join(currentDirname, currFilename))
                            print currFilename
                            if os_isdir(os_join(currentDirname, currFilename)):
                                print 'dir'
                            else:
                                Win_ShowWidget(uiSetRecorderDlg, False)
                                print 'PlayRecord',
                                print os_join(currentDirname, currFilename)
                                PlayRecord(os_join(currentDirname, currFilename))



                class Cancel(TButton):
                    __module__ = __name__
                    rect = (225,
                     370,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiSetRecorderDlg, False)
                        PlaySound(soundLeave, 1)



                class closeBtn(Cancel):
                    __module__ = __name__
                    rect = (364,
                     5,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                class scroll(TVScroll):
                    __module__ = __name__
                    rect = (356,
                     74,
                     26,
                     288)
                    pos = 0
                    visible = 1
                    pagesize = -5

                    def OnPosChange():
                        fileCnt = 0
                        selFileList = []
                        tempFilelist = []
                        tempFilelist1 = []
                        curDirname = Win_GetText((uiSetRecorderDlg + '.CurrentDirLabel'))
                        ui = uiSetRecorderDlg
                        if (curDirname == '\xce\xd2\xb5\xc4\xb5\xe7\xc4\xd4'):
                            selFileList = dr.getDrivers()
                        else:
                            try:
                                tempFilelist = os_listdir(curDirname)
                                print 'step1'
                                for f in tempFilelist:
                                    if (os_isdir(os_join(curDirname, f)) and selFileList.append(f)):
                                        pass
                                    if ((f[-4:].lower() == '.qbv') and tempFilelist1.append(f)):
                                        pass

                                for i in tempFilelist1:
                                    selFileList.append(i)

                            except:
                                print 'Cant open'
                        fileCnt = len(selFileList)
                        pos = Win_GetPos((ui + '.scroll'))
                        print 'pos=',
                        print pos
                        driveList = []
                        isDrive = 0
                        driveList = dr.getDrivers()
                        driveCnt = len(driveList)
                        print 'driveCnt=',
                        print driveCnt
                        for i in range(driveCnt):
                            if (driveList[i] == curDirname):
                                isDrive = 1
                                break

                        if (curDirname == '\xce\xd2\xb5\xc4\xb5\xe7\xc4\xd4'):
                            print 'Computer'
                            Win_SetImg((ui + '.CurrentDirLabel.icon'), 'res/uires/selRoom/recorder/computer_icon.img')
                        elif (isDrive == 1):
                            print 'Mount'
                            Win_SetImg((ui + '.CurrentDirLabel.icon'), 'res/uires/selRoom/recorder/hardrive_icon.img')
                        else:
                            print 'folder'
                            Win_SetImg((ui + '.CurrentDirLabel.icon'), 'object/ui/record/icon_folder.img')
                        Win_SetRange((ui + '.scroll'), (fileCnt - 12))
                        for i in range(12):
                            fileUI = ((ui + '.file') + str((i + 1)))
                            if (((pos + i) < fileCnt) and (curFile == i)):
                                if Win_SetBkColor(fileUI, 24, 24, 192, 127):
                                    pass
                                if ((curDirname == '\xce\xd2\xb5\xc4\xb5\xe7\xc4\xd4') and Win_SetImg((fileUI + '.icon'), 'res/uires/selRoom/recorder/hardrive_icon.img')):
                                    pass
                                Win_SetText((fileUI + '.name'), selFileList[(pos + i)])



                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              1,
                              1,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             41)
                            bkimage = 'object/ui/common/scl_block.img'



                class file1(TButton):
                    __module__ = __name__
                    drawflag = drawflag_win_fill
                    rect = (43,
                     74,
                     300,
                     19)

                    def OnClick(this):
                        global curFile
                        curFile = (getMyIdx() - 1)
                        print curFile
                        doUI((uiSetRecorderDlg + '.scroll'), 'OnPosChange')
                        PlaySound(soundUI, 1)



                    def OnDBClick():
                        global curFile
                        print 'OnDBClick'
                        curFile = (getMyIdx() - 1)
                        currDirname = Win_GetText((uiSetRecorderDlg + '.CurrentDirLabel'))
                        currFilename = Win_GetText((((uiSetRecorderDlg + '.file') + str((curFile + 1))) + '.name'))
                        if (os_isdir(os_join(currDirname, currFilename)) and Win_SetText((uiSetRecorderDlg + '.CurrentDirLabel'), os_join(currDirname, currFilename))):
                            pass
                        Win_SetPos((uiSetRecorderDlg + '.scroll'), 0)
                        doUI((uiSetRecorderDlg + '.scroll'), 'OnPosChange')


                    class children:
                        __module__ = __name__
                        class icon(TStatic):
                            __module__ = __name__
                            framescheme = [(1,
                              1,
                              1,
                              1,
                              1,
                              1,
                              1,
                              1)]
                            rect = (0,
                             1,
                             12,
                             18)
                            bkimage = 'object/ui/record/icon_folder.img'

                        class name(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (30,
                             3,
                             240,
                             12)
                            drawcolor = lightColor



                class file2(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + 24),
                     300,
                     19)

                class file3(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 2)),
                     300,
                     19)

                class file4(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 3)),
                     300,
                     19)

                class file5(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 4)),
                     300,
                     19)

                class file6(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 5)),
                     300,
                     19)

                class file7(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 6)),
                     300,
                     19)

                class file8(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 7)),
                     300,
                     19)

                class file9(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 8)),
                     300,
                     19)

                class file10(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 9)),
                     300,
                     19)

                class file11(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 10)),
                     300,
                     19)

                class file12(file1):
                    __module__ = __name__
                    rect = (43,
                     (74 + (24 * 11)),
                     300,
                     19)



        class storageDlg(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (178,
             196,
             325,
             286)
            bkimage = 'object/ui/storage/dlg_roomStorage.img'

            def OnSelfHide():
                ui = (uiRoomStorageDlg + ('.funcItem%d' % uiStorageIdx))
                Win_SetDragImg(ui, '')


            class children:
                __module__ = __name__
                class storageLeft(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (10,
                     254,
                     33,
                     36)
                    bkimage = 'object/ui/common/btn_left.img'

                    def OnClick(this):
                        global roomStoragePos
                        roomStoragePos = max((roomStoragePos - defRoomStorageCnt), 0)
                        UpdateRoomStorage()
                        PlaySound(soundUI, 1)



                class storageRight(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (121,
                     254,
                     33,
                     35)
                    bkimage = 'object/ui/common/btn_right.img'

                    def OnClick(this):
                        global roomStoragePos
                        if ((roomStoragePos + defRoomStorageCnt) >= totalStorageCnt):
                            return 
                        roomStoragePos = (roomStoragePos + defRoomStorageCnt)
                        UpdateRoomStorage()
                        PlaySound(soundUI, 1)



                class storagePage:
                    __module__ = __name__
                    type = 'NUMLABEL'
                    rect = (43,
                     260,
                     80,
                     24)
                    bkimage = 'object/ui/common/number2.img'
                    textstyle = dt_center
                    textsize = 16
                    textwidth = 19
                    textheight = 24

                class storageDescription:
                    __module__ = __name__
                    type = 'DYLABEL'
                    initlayer = 99999
                    rect = (0,
                     0,
                     130,
                     1)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    bkimage = 'object/ui/common/img_tip.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                class funcItem0(TRadio):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 0
                    rect = (5,
                     2,
                     60,
                     60)
                    dragtype = 6
                    bkimage = 'object/ui/storage/img_choose.img'
                    framescheme = [(-1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    tipwidget = (uiRoomStorageDlg + '.storageDescription')

                    def OnDBClick():
                        global curRoomStorageIdx
                        me = getMyIdx2()
                        curRoomStorageIdx = (roomStoragePos + me)
                        EquipOneProp(-1, g_StorageList.at(curRoomStorageIdx).m_stItem.m_nItemID)
                        curEquipIdx = -1
                        curRoomStorageIdx = -1
                        ui_UpdateRoomEquip()



                    def OnBeginItemDrag():
                        global curRoomStorageIdx
                        global uiStorageIdx
                        uiStorageIdx = getMyIdx2()
                        print uiStorageIdx
                        curRoomStorageIdx = (roomStoragePos + uiStorageIdx)
                        info = g_StorageList.at(curRoomStorageIdx).m_stItem
                        path = Win_GetMyPath()
                        Win_SetDragImg(path, ('res/uires/icon/item/item%d.img' % info.m_nItemID))



                    def OnRClick():
                        global curRoomStorageIdx
                        path = Win_GetMyPath()
                        me = getMyIdx2()
                        if (curRoomStorageIdx == (roomStoragePos + me)):
                            curRoomStorageIdx = -1
                            Win_SetCheck(path, 0)



                    def OnMouseMoveIn():
                        me = Win_GetMyPath()
                        idx = (getMyIdx2() + roomStoragePos)
                        if (idx >= totalStorageCnt):
                            return 
                        info = g_StorageList.at(idx)
                        ui = (uiRoomStorageDlg + '.storageDescription')
                        Win_SetText(ui, ((info.m_szName + '\n') + info.m_szDescrip))
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))


                    class children:
                        __module__ = __name__
                        class itemPic(TStatic):
                            __module__ = __name__
                            rect = (0,
                             0,
                             60,
                             56)
                            bkImgFlag = dt_center

                        class itemNum(TLabel):
                            __module__ = __name__
                            rect = (30,
                             40,
                             24,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor



                class funcItem1(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 1)),
                     2,
                     60,
                     60)
                    groupstop = 1

                class funcItem2(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 2)),
                     2,
                     60,
                     60)
                    groupstop = 2

                class funcItem3(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 3)),
                     2,
                     60,
                     60)
                    groupstop = 3

                class funcItem4(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 4)),
                     2,
                     60,
                     60)
                    groupstop = 4

                class funcItem5(funcItem0):
                    __module__ = __name__
                    rect = (5,
                     (2 + (62 * 1)),
                     60,
                     60)
                    groupstop = 5

                class funcItem6(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 1)),
                     (2 + (62 * 1)),
                     60,
                     60)
                    groupstop = 6

                class funcItem7(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 2)),
                     (2 + (62 * 1)),
                     60,
                     60)
                    groupstop = 7

                class funcItem8(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 3)),
                     (2 + (62 * 1)),
                     60,
                     60)
                    groupstop = 8

                class funcItem9(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 4)),
                     (2 + (62 * 1)),
                     60,
                     60)
                    groupstop = 9

                class funcItem10(funcItem0):
                    __module__ = __name__
                    rect = (5,
                     (2 + (62 * 2)),
                     60,
                     60)
                    groupstop = 10

                class funcItem11(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 1)),
                     (2 + (62 * 2)),
                     60,
                     60)
                    groupstop = 11

                class funcItem12(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 2)),
                     (2 + (62 * 2)),
                     60,
                     60)
                    groupstop = 12

                class funcItem13(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 3)),
                     (2 + (62 * 2)),
                     60,
                     60)
                    groupstop = 13

                class funcItem14(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 4)),
                     (2 + (62 * 2)),
                     60,
                     60)
                    groupstop = 14

                class funcItem15(funcItem0):
                    __module__ = __name__
                    rect = (5,
                     (2 + (62 * 3)),
                     60,
                     60)
                    groupstop = 15

                class funcItem16(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 1)),
                     (2 + (62 * 3)),
                     60,
                     60)
                    groupstop = 16

                class funcItem17(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 2)),
                     (2 + (62 * 3)),
                     60,
                     60)
                    groupstop = 17

                class funcItem18(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 3)),
                     (2 + (62 * 3)),
                     60,
                     60)
                    groupstop = 18

                class funcItem19(funcItem0):
                    __module__ = __name__
                    rect = ((5 + (62 * 4)),
                     (2 + (62 * 3)),
                     60,
                     60)
                    groupstop = 19



        class C2CInvite(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (200,
             300,
             198,
             103)
            bkimage = 'object/ui/deal/RequestDealPanel.img'
            class children:
                __module__ = __name__
                class name(TButton):
                    __module__ = __name__
                    rect = (51,
                     20,
                     120,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textstyle = dt_left

                    def OnClick(this):
                        print 'Click response on name'
                        go2playerInfo(inviteDealUin)



                class confirm(TButton):
                    __module__ = __name__
                    rect = (40,
                     60,
                     47,
                     34)
                    bkimage = 'object/ui/deal/LittleAgreeBtn.img'

                    def OnClick(this):
                        global dealUin
                        if (not bC2CDealShow):
                            dealUin = inviteDealUin
                            C2CInviteDeal(dealUin, 2)
                            ShowC2CDealDlg(dealUin)
                        Win_ShowWidget(uiC2CInviteDlg, 0)
                        PlaySound(soundUI, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (110,
                     60,
                     47,
                     34)
                    bkimage = 'object/ui/deal/LittleRefuseBtn.img'

                    def OnClick(this):
                        C2CInviteDeal(inviteDealUin, 3)
                        Win_ShowWidget(uiC2CInviteDlg, 0)
                        PlaySound(soundUI, 1)





        class C2CDealDlg(TStatic):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (26,
             44,
             381,
             594)
            bkimage = 'object/ui/deal/C2CDealPanel.img'
            class children:
                __module__ = __name__
                class name(TLabel):
                    __module__ = __name__
                    rect = ((51 + 32),
                     (20 + 15),
                     120,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textstyle = dt_left

                class cancel(TButton):
                    __module__ = __name__
                    rect = (350,
                     11,
                     31,
                     31)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        CloseC2CDealDlg(1)



                class NegotiateBtn(TButton):
                    __module__ = __name__
                    rect = (264,
                     246,
                     80,
                     31)
                    bkimage = 'object/ui/deal/DisagreeBtn.img'

                    def OnClick(this):
                        if (Win_GetText((uiC2CDealDlg + '.srcBill')) == ''):
                            srcBiddingBill = 0
                        else:
                            lastBidding = [ e for e in MyBiddingList if (e[0] == ticketitemid) ]
                            srcBiddingBill = int(Win_GetText((uiC2CDealDlg + '.srcBill')))
                        if ((srcBiddingBill > residualTicket) and ui_msgBox(3)):
                            Win_ShowMsgBox('\xc4\xfa\xb5\xc4\xbf\xe1\xb1\xc8\xb1\xa6\xca\xaf\xb2\xbb\xd7\xe3,\xb1\xbe\xb4\xce\xb3\xf6\xbc\xdb\xc3\xbb\xd3\xd0\xb3\xc9\xb9\xa6', '', 3, 'UI.SysMsgbox', -1)
                            Win_SetText((uiC2CDealDlg + '.srcBill'), ('%12f' % 0))
                            if (lastBidding != None):
                                srcBiddingBill = lastBidding[0][1]
                                Win_SetText((uiC2CDealDlg + '.srcBill'), ('%12f' % srcBiddingBill))
                            return 
                            print srcBiddingBill
                        for i in range(len(MyBiddingList)):
                            if (ticketitemid == MyBiddingList[i][0]):
                                del MyBiddingList[i]
                                break

                        MyBiddingList.append([ticketitemid,
                         srcBiddingBill])
                        Negotiate = [len(MyBiddingList),
                         MyBiddingList,
                         0,
                         0]
                        RequestNegotiate(dealUin, Negotiate)
                        UpdateAfterNegotiate()
                        UpdateStorageinDealDlg(1, InvalidIdx)
                        Win_EnableWidget((uiC2CDealDlg + '.NegotiateBtn'), 0)
                        Win_Timer((uiC2CDealDlg + '.NegotiateBtn'), 1500)



                    def OnTimer(this):
                        Win_Timer(this, 0)
                        Win_EnableWidget((uiC2CDealDlg + '.NegotiateBtn'), 1)



                    def OnMouseMoveIn():
                        ui = (uiC2CDealDlg + '.PropDescription')
                        me = Win_GetMyPath()
                        Win_SetText(ui, '\xcf\xf2\xb6\xd4\xb7\xbd\xbf\xaa\xb3\xf6\xd7\xd4\xbc\xba\xcf\xeb\xc2\xf4\xb3\xf6\xb5\xc4\xce\xef\xc6\xb7')
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))
                        Win_ShowWidget(ui, 1)
                        Win_Timer(ui, 3000)



                class BargainingBtn(TButton):
                    __module__ = __name__
                    rect = (164,
                     246,
                     80,
                     31)
                    bkimage = 'object/ui/deal/AgreeBtn.img'

                    def OnClick(this):
                        Bargainning = [len(MyBiddingList),
                         MyBiddingList]
                        RequestBargaining(dealUin, Bargainning)
                        Win_EnableWidget((uiC2CDealDlg + '.BargainingBtn'), 0)
                        Win_Timer((uiC2CDealDlg + '.BargainingBtn'), 3000)



                    def OnTimer(this):
                        Win_Timer(this, 0)
                        Win_EnableWidget((uiC2CDealDlg + '.BargainingBtn'), 1)



                    def OnMouseMoveIn():
                        ui = (uiC2CDealDlg + '.PropDescription')
                        me = Win_GetMyPath()
                        Win_SetText(ui, '\xc8\xb7\xb6\xa8\xba\xcd\xb6\xd4\xb7\xbd\xbd\xbb\xbb\xbb\xcb\xab\xb7\xbd\xb3\xf6\xbc\xdb\xce\xef\xc6\xb7')
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))
                        Win_ShowWidget(ui, 1)
                        Win_Timer(ui, 3000)



                class dstBill(TEditID):
                    __module__ = __name__
                    editable = 0
                    initlayer = 550001
                    maxchar = 9
                    rect = ((207 - 20),
                     70,
                     81,
                     16)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    captionrect = (2,
                     4,
                     78,
                     16)
                    textstyle = dt_right
                    caption = '0.0'

                class srcBill(TEditID):
                    __module__ = __name__
                    initlayer = 550001
                    maxchar = 9
                    rect = ((207 - 20),
                     152,
                     81,
                     16)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    captionrect = (2,
                     4,
                     78,
                     16)
                    textstyle = dt_right
                    caption = '0.0'

                class residualBill(TEditID):
                    __module__ = __name__
                    editable = 0
                    initlayer = 550001
                    maxchar = 12
                    rect = ((207 - 20),
                     495,
                     81,
                     16)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    captionrect = (2,
                     4,
                     78,
                     16)
                    textstyle = dt_right

                class DstBidding0(TRadio):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (33,
                     93,
                     60,
                     56)
                    bkimage = 'object/ui/room/btn_equipItem.img'
                    groupid = 6
                    groupstop = 0
                    dragtype = 7
                    class children:
                        __module__ = __name__
                        class itemPic(TStatic):
                            __module__ = __name__
                            rect = (0,
                             0,
                             60,
                             56)
                            bkImgFlag = dt_center

                        class itemNum(TLabel):
                            __module__ = __name__
                            rect = (36,
                             36,
                             24,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor



                class DstBidding1(DstBidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 1)),
                     93,
                     60,
                     56)
                    groupstop = 1

                class DstBidding2(DstBidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 2)),
                     93,
                     60,
                     56)
                    groupstop = 2

                class DstBidding3(DstBidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 3)),
                     93,
                     60,
                     56)
                    groupstop = 3

                class DstBidding4(DstBidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 4)),
                     93,
                     60,
                     56)
                    groupstop = 4

                class Mybidding0(TRadio):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (33,
                     181,
                     60,
                     56)
                    bkimage = 'object/ui/room/btn_equipItem.img'
                    groupid = 6
                    groupstop = 0
                    dragtype = 7

                    def OnDragItemDrop():
                        global curBiddingIdx
                        global curPropC2CDealIdx
                        me = getMyIdx2()
                        if (Win_IsVisible(uiC2CDealDlg) and ((curPropC2CDealIdx >= 0) and (curPropC2CDealIdx < totalP2PDealPropCnt))):
                            if (len(MyBiddingList) > 6):
                                return 
                            if Win_SetCheck(Win_GetMyPath(), 0):
                                Win_SetCheck((uiC2CDealDlg + ('.funcItem%d' % (curPropC2CDealIdx - MyPropC2CDealDlgPos))), 0)
                                info = [g_P2PDealPropList.at(curPropC2CDealIdx).m_stItem.m_nItemID,
                                 1]
                                Num = g_P2PDealPropList.at(curPropC2CDealIdx).m_stItem.m_iNumOfItem
                                UpdateMyBiddingList(info, Num)
                                curBiddingIdx = -1
                                curPropC2CDealIdx = -1
                                ui_UpdateMyBidding()
                                UpdateStorageinDealDlg(1, InvalidIdx)



                    def OnRClick():
                        global curEquipIdx
                        print 'MyBidding is right click'
                        path = Win_GetMyPath()
                        me = getMyIdx2()
                        UpdateStorageinDealDlg(0, me)
                        removeBiddingItem(me)
                        ui_UpdateMyBidding()
                        if (curEquipIdx == me):
                            curEquipIdx = -1
                            Win_SetCheck(path, 0)


                    class children:
                        __module__ = __name__
                        class itemPic(TStatic):
                            __module__ = __name__
                            rect = (0,
                             0,
                             60,
                             56)
                            bkImgFlag = dt_center

                        class itemNum(TLabel):
                            __module__ = __name__
                            rect = (36,
                             36,
                             24,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor



                class Mybidding1(Mybidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 1)),
                     181,
                     60,
                     56)
                    groupstop = 1

                class Mybidding2(Mybidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 2)),
                     181,
                     60,
                     56)
                    groupstop = 2

                class Mybidding3(Mybidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 3)),
                     181,
                     60,
                     56)
                    groupstop = 3

                class Mybidding4(Mybidding0):
                    __module__ = __name__
                    rect = ((33 + (62 * 4)),
                     181,
                     60,
                     56)
                    groupstop = 4

                class Left(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (33,
                     485,
                     33,
                     36)
                    bkimage = 'object/ui/common/btn_left.img'

                    def OnClick(this):
                        global MyPropC2CDealDlgPos
                        MyPropC2CDealDlgPos = max((MyPropC2CDealDlgPos - defMyPropC2CDealDlgCnt), 0)
                        UpdateMyPropC2CDealDlg()
                        PlaySound(soundUI, 1)



                class Right(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (146,
                     485,
                     33,
                     36)
                    bkimage = 'object/ui/common/btn_right.img'

                    def OnClick(this):
                        global MyPropC2CDealDlgPos
                        if ((MyPropC2CDealDlgPos + defMyPropC2CDealDlgCnt) >= totalP2PDealPropCnt):
                            return 
                        MyPropC2CDealDlgPos = (MyPropC2CDealDlgPos + defMyPropC2CDealDlgCnt)
                        UpdateMyPropC2CDealDlg()
                        PlaySound(soundUI, 1)



                class MyPropPage:
                    __module__ = __name__
                    type = 'NUMLABEL'
                    rect = (63,
                     490,
                     80,
                     24)
                    bkimage = 'object/ui/common/number2.img'
                    textstyle = dt_center
                    textsize = 16
                    textwidth = 19
                    textheight = 24

                class PropDescription:
                    __module__ = __name__
                    type = 'DYLABEL'
                    initlayer = 99999
                    rect = (0,
                     0,
                     130,
                     1)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    bkimage = 'object/ui/common/img_tip.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                    def OnTimer(this):
                        Win_ShowWidget(this, 0)
                        Win_Timer(this, 0)



                class funcItem0(TRadio):
                    __module__ = __name__
                    groupid = 3
                    groupstop = 0
                    rect = (33,
                     296,
                     60,
                     60)
                    dragtype = 7
                    bkimage = 'object/ui/storage/img_choose.img'
                    framescheme = [(-1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    tipwidget = (uiC2CDealDlg + '.PropDescription')

                    def OnDBClick():
                        global curPropC2CDealIdx
                        if (len(MyBiddingList) > 6):
                            return 
                        me = getMyIdx2()
                        curPropC2CDealIdx = (MyPropC2CDealDlgPos + me)
                        if (g_P2PDealPropList.at(curPropC2CDealIdx) == None):
                            return 
                        info = [g_P2PDealPropList.at(curPropC2CDealIdx).m_stItem.m_nItemID,
                         1]
                        Num = g_P2PDealPropList.at(curPropC2CDealIdx).m_stItem.m_iNumOfItem
                        UpdateMyBiddingList(info, Num)
                        curBiddingIdx = -1
                        curPropC2CDealIdx = -1
                        UpdateStorageinDealDlg(1, InvalidIdx)
                        ui_UpdateMyBidding()



                    def OnBeginItemDrag():
                        global uiPropC2CInx
                        global curPropC2CDealIdx
                        uiPropC2CInx = getMyIdx2()
                        print uiPropC2CInx
                        curPropC2CDealIdx = (MyPropC2CDealDlgPos + uiPropC2CInx)
                        if (g_P2PDealPropList.at(curPropC2CDealIdx) == None):
                            return 
                        info = g_P2PDealPropList.at(curPropC2CDealIdx).m_stItem
                        path = Win_GetMyPath()
                        if CHECK_PET(info.m_nItemID):
                            petResId = GetPetResId(info.m_nItemID, 10)
                            Win_SetDragImg(path, ('res/uiRes/icon/pet/pet%d.img' % petResId))
                        else:
                            Win_SetDragImg(path, ('res/uires/icon/item/item%d.img' % info.m_nItemID))



                    def OnRClick():
                        global curPropC2CDealIdx
                        path = Win_GetMyPath()
                        me = getMyIdx2()
                        if (curPropC2CDealIdx == (MyPropC2CDealDlgPos + me)):
                            curPropC2CDealIdx = -1
                            Win_SetCheck(path, 0)



                    def OnMouseMoveIn():
                        me = Win_GetMyPath()
                        idx = (getMyIdx2() + MyPropC2CDealDlgPos)
                        if (idx >= totalP2PDealPropCnt):
                            return 
                        info = g_P2PDealPropList.at(idx)
                        ui = (uiC2CDealDlg + '.PropDescription')
                        Win_SetText(ui, ((info.m_szName + '\n') + info.m_szDescrip))
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))


                    class children:
                        __module__ = __name__
                        class itemPic(TStatic):
                            __module__ = __name__
                            rect = (0,
                             0,
                             60,
                             56)
                            bkImgFlag = dt_center

                        class itemNum(TLabel):
                            __module__ = __name__
                            rect = (30,
                             40,
                             24,
                             12)
                            drawcolor = lightColor
                            textEdgeColor = maskColor



                class funcItem1(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 1)),
                     296,
                     60,
                     60)
                    groupstop = 1

                class funcItem2(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 2)),
                     296,
                     60,
                     60)
                    groupstop = 2

                class funcItem3(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 3)),
                     296,
                     60,
                     60)
                    groupstop = 3

                class funcItem4(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 4)),
                     296,
                     60,
                     60)
                    groupstop = 4

                class funcItem5(funcItem0):
                    __module__ = __name__
                    rect = (33,
                     (296 + (62 * 1)),
                     60,
                     60)
                    groupstop = 5

                class funcItem6(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 1)),
                     (296 + (62 * 1)),
                     60,
                     60)
                    groupstop = 6

                class funcItem7(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 2)),
                     (296 + (62 * 1)),
                     60,
                     60)
                    groupstop = 7

                class funcItem8(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 3)),
                     (296 + (62 * 1)),
                     60,
                     60)
                    groupstop = 8

                class funcItem9(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 4)),
                     (296 + (62 * 1)),
                     60,
                     60)
                    groupstop = 9

                class funcItem10(funcItem0):
                    __module__ = __name__
                    rect = (33,
                     (296 + (62 * 2)),
                     60,
                     60)
                    groupstop = 10

                class funcItem11(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 1)),
                     (296 + (62 * 2)),
                     60,
                     60)
                    groupstop = 11

                class funcItem12(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 2)),
                     (296 + (62 * 2)),
                     60,
                     60)
                    groupstop = 12

                class funcItem13(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 3)),
                     (296 + (62 * 2)),
                     60,
                     60)
                    groupstop = 13

                class funcItem14(funcItem0):
                    __module__ = __name__
                    rect = ((33 + (62 * 4)),
                     (296 + (62 * 2)),
                     60,
                     60)
                    groupstop = 14






#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiRoom.py`:

```py
class UI_children_logo:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)

    def OnInit():
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        Win_ShowWidget(uiMenuDlg, 0)
        NotifyMainWndReady(int(500))
        Win_SetValue('UI.logo.bgLogo', 1, 41)
        Win_SetValue('UI.logo.bgLogo', 2, 901)
        Win_Timer('UI.logo.InTimer', 200)


    class children:
        __module__ = __name__
        class bgLogo(TStatic):
            __module__ = __name__
            initlayer = 100000
            rect = (0,
             0,
             800,
             600)
            bkimage = 'object/ui/bg/bg_logo.img'

        class InTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                Win_SetValue('UI.logo.bgLogo', 0.02, 41)
                Win_SetValue('UI.logo.bgLogo', 1, 901)
                Win_Timer(this, 0)
                Win_Timer('UI.logo.StopTimer', 3000)



        class StopTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                Win_SetValue('UI.logo.bgLogo', 0.01, 41)
                Win_SetValue('UI.logo.bgLogo', 2, 901)
                Win_Timer(this, 0)
                Win_Timer('UI.logo.OutTimer', 2000)



        class OutTimer(TStatic):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)

            def OnTimer(this):
                GotoUIScreen('login')
                Win_Timer(this, 0)





UI.children.logo = UI_children_logo

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiSelRoom.py`:

```py
'\nexecfile("uiConst.py")\nexecfile("uiTemplate.py")\nlightColor = 1\nzoneChooseColor = 1\nmaskColor = 1\nuiShopStorageDlg = \'\'\ndef SC_GetTipIndex(idx):\n    return 1\nuiTaskDlg = \'\'\nclass TTip:\n    pass\nmemberFaceIconList =[]\nfaceIconList = []\n'
msgcnt = 3
bmsg = ([0] * msgcnt)
msgbuf = ([''] * msgcnt)
namebuf = ([''] * msgcnt)
uinbuf = ([0] * msgcnt)
isBugle = 0
IsPopo = 0
CurXeffectSubID = 0
menuMode = 0
ChatMode = 0
ChatOrientation = 0
ChatAreaTab = 0
localShopVersion = 0
lastestShopVersion = 0
CommonType = 0
PVPType = 1
PVEType = 2
LootType = 3
GameType = 0
OldGameType = 0
IsShowStorageDlg = 0
ChatType = 4
firstEnter = 1
playerExp = 0
playerReputation = 0
isQQMember = 0
allGameModeList = [(-1,
  'none',
  '\xcb\xf9\xd3\xd0\xb7\xbf\xbc\xe4'),
 (0,
  'all',
  '\xc8\xab\xb2\xbf\xb5\xd8\xcd\xbc'),
 (1,
  'normal',
  '\xc6\xd5\xcd\xa8'),
 (2,
  'bomb',
  '\xcc\xdf\xd5\xa8\xb5\xaf'),
 (3,
  'bun',
  '\xc7\xc0\xb0\xfc\xd7\xd3'),
 (4,
  'match',
  '\xb1\xc8\xce\xe4'),
 (5,
  'treasure',
  '\xb6\xe1\xb1\xa6'),
 (6,
  'sculpture',
  '\xd3\xa2\xd0\xdb\xb4\xab\xcb\xb5'),
 (7,
  'machine',
  '\xbb\xfa\xd0\xb5\xca\xc0\xbd\xe7'),
 (8,
  'box',
  '\xcd\xc6\xcf\xe4\xd7\xd3'),
 (13,
  'tank',
  '\xcc\xc7\xbf\xcd\xd5\xbd')]
gameModeList = allGameModeList
validGameModeDict = {}
allMapTypeList = ['rand',
 'box',
 'machine',
 'treasure',
 'sculpture',
 'bomb',
 'bun',
 'tank',
 'match',
 'pig',
 'water',
 'field',
 'town',
 'desert',
 'mine',
 'snow']
mapTypeList = []

def setupValidGameMode():
    global gameModeList

    def setupValidGameModeDict():
        global validGameModeDict
        validGameModeDict = {'rand': 1}
        for i in gameModeList:
            validGameModeDict[i[1]] = 1

        if validGameModeDict.has_key('normal'):
            normalList = ['water',
             'field',
             'town',
             'desert',
             'mine',
             'snow',
             'pig']
            for name in normalList:
                validGameModeDict[name] = 1




    def setupValidMapType():
        global mapTypeList
        mapTypeList = []
        for it in allMapTypeList:
            if (validGameModeDict.has_key(it) and mapTypeList.append(it)):
                pass



    gameModeList = [allGameModeList[0]]
    validGameMode = fetch_ValidGameModes()
    for i in allGameModeList:
        if ((validGameMode.count(i[0]) > 0) and gameModeList.append(i)):
            pass

    setupValidGameModeDict()
    setupValidMapType()



def setupMapList(gameType):
    global mapTypeList
    if (gameType == 2):
        mapTypeList = ['pve']
    else:
        mapTypeList = []
        for it in allMapTypeList:
            if (validGameModeDict.has_key(it) and mapTypeList.append(it)):
                pass



curGameMode = 0
oldWinEventCnt = -1
hasInfo = 0
roomID = -1
playerMode = 0
friendPos = 0
friendCnt = 0
friendIndex = 0
kinMemberPos = 0
kinMemberCnt = 0
kinMemberIndex = 0
playerPos = 0
playerCnt = 0
defPlayerCnt = 16
uins = range((defPlayerCnt + 1))
playerMode2 = 0
playerPos2 = 0
friendPos2 = 0
kinMemberPos2 = 0
defPlayerCnt2 = 11
flexMode = 2
uins2 = range((defPlayerCnt2 + 1))
roomCnt = 0
defRoomNum = 9
roomPagePos = 1
markEnterShop = False
facePage = 0
memberFacePage = 0
memberFacePageNum = ((len(memberFaceIconList) + 23) / 24)
facePageNum = (((len(faceIconList) + 23) / 24) - memberFacePageNum)
isMemberFace = 0
chatNameInSec = '\xb4\xf3  \xcc\xfc'
chatNameInRoom = '\xb7\xbf  \xbc\xe4'
chatNameSpeaker = '\xd0\xa1\xc0\xae\xb0\xc8'
TopkinCnt = 0
TopkinCurrentPos = 0
defTopkinDlgCnt = 7
ActivetopkinPos = 999999
chinatelecom = 1
setreputation = 1
curPetId = 0
curPetName = ''
curPetState = 1
petsIdList = []
skillIdList = []
baseSkillIdList = []
petItemList = []
petItemPos = 0
defPetItemCnt = 12
curUseItem = 0
PawnTypeCnt = 0
CurrenPawnType = -1
PawnItemCnt = 0
defPawnItemCnt = 22
defPawnwareCnt = 12
PawnGoodsCnt = 0
CurrentPawnItemID = 0
defPawnGoodsCnt = 24
PawnGoodsPos = 0
totalPawnGoodsCnt = 0
defStorageInPawnCnt = 12
CurrentPropIdx = 0
defCommittedCnt = 6
check12 = 1
Commit2Pawn = 1
CancelCommit2Pawn = 3
MyPawnItemListCnt = 0
buyItemInfo = []
petbaseInfo = CNil()
ShowMyPawned = 0
IsShowingStorageTip = 0

def CHECK_BASESKILL(skillId):
    return (skillId <= 50)



def CHECK_PET(ID):
    if ((ID >= 25001) and (ID <= 26000)):
        return 1
    return 0



def CHECK_PET_RELATION(ID):
    return ((ID >= 25001) and (ID <= 29000))



def ui_GetLevelMainPath(point):
    levelInfo = Level().getInfo(point)
    print levelInfo
    if ((0 == point) and (-1 == point)):
        return ''
    return Level().getMainLevel(levelInfo[1])



def ui_GetLevelSubPath(point):
    levelInfo = Level().getInfo(point)
    if ((0 == point) and (-1 == point)):
        return ''
    return Level().getMinLevel(levelInfo[1], levelInfo[2])



def ChangeChatMode(newMode):
    global isMemberFace
    global ChatMode
    if (Win_GetCurScreen() == 'selRoom'):
        ui = 'UI.selRoom.chatArea'
    elif (Win_GetCurScreen() == 'room'):
        ui = 'UI.room.chatArea'
    else:
        return 
    num = GetBugleNumber()
    if (num <= 0):
        ChatMode = 0
        Win_SetImg((ui + '.speakerBtn'), 'object/ui/chat/btn_ldspker_disable.img')
        Win_EnableWidget((ui + '.faceBtn.faceDlg.choose'), 1)
        Win_SetText((ui + '.chatEdit'), '')
        Win_SetValue((ui + '.chatEdit'), 200, 903)
    elif (newMode == 1):
        ChatMode = 1
        isMemberFace = 0
        Win_EnableWidget((ui + '.faceBtn.faceDlg.choose'), 0)
        setFacePage(facePage, facePageNum)
        Win_SetImg((ui + '.speakerBtn'), 'object/ui/chat/btn_ldspker_pushdown.img')
        Win_SetText((ui + '.chatEdit'), '')
        Win_SetValue((ui + '.chatEdit'), 44, 903)
    else:
        ChatMode = 0
        Win_EnableWidget((ui + '.faceBtn.faceDlg.choose'), 1)
        Win_SetImg((ui + '.speakerBtn'), 'object/ui/chat/btn_speaker.img')
        Win_SetText((ui + '.chatEdit'), '')
        Win_SetValue((ui + '.chatEdit'), 200, 903)



def UpdateUIWisper():
    name = GetWisperName(0)
    if ((Win_GetCurScreen() == 'selRoom') and (name != '0')):
        if Win_SetText('UI.selRoom.chatArea.orientation', name):
            pass



def UpdateUIKinChat():
    name = GetWisperName(1)
    if ((Win_GetCurScreen() == 'selRoom') and Win_SetText('UI.selRoom.chatArea.orientation', name)):
        pass



def NotifyWisper(name, wisperuin):
    print 'SetWisperPlayer',
    print name,
    print ((' [' + str(wisperuin)) + ']')
    SetWisperPlayer(wisperuin, name)
    if ((wisperuin and ((wisperuin != uin) and (ChatMode == 1))) and ChangeChatMode(0)):
        pass
    UpdateUIWisper()



def InitChatMode():
    if ((Win_GetCurScreen() == 'selRoom') and NotifyWisper(chatNameInSec, 0)):
        pass
    ChangeChatMode(0)



def UIRefreshChatMode():
    ChangeChatMode(ChatMode)



def startGlint():
    global hasInfo
    hasInfo = 1
    ui = ''
    if ('selRoom' == Win_GetCurScreen()):
        ui = 'UI.selRoom.chatArea.donateInfo'
    elif ('room' == Win_GetCurScreen()):
        ui = 'UI.room.chatArea.donateInfo'
    Win_ShowWidget(ui, True)
    Win_Timer(ui, 400)



def endGlint():
    global hasInfo
    hasInfo = 0
    ui = ''
    if ('selRoom' == Win_GetCurScreen()):
        ui = 'UI.selRoom.chatArea.donateInfo'
    elif ('room' == Win_GetCurScreen()):
        ui = 'UI.room.chatArea.donateInfo'
    Win_Timer(ui, 0)
    Win_ShowWidget(ui, False)



def InitChatArea():
    Win_SetText('UI.selRoom.chatArea.chatPanel.chatList', '', value_channel_listitem_num)
    Win_SetText('UI.selRoom.chatArea.kinchatPanel.chatList', '', value_channel_listitem_num)
    Win_SetText('UI.selRoom.chatArea.wisperPanel.chatList', '', value_channel_listitem_num)
    if ((ChatAreaTab == 0) and Win_SelectSelf('UI.selRoom.chatArea.integration')):
        Win_ShowWidget('UI.selRoom.chatArea.chatPanel', 1)
        Win_ShowWidget('UI.selRoom.chatArea.kinchatPanel', 0)
        Win_ShowWidget('UI.selRoom.chatArea.wisperPanel', 0)



def flexChatArea(mode):
    global defPlayerCnt2
    ui = ['UI.selRoom.chatArea.chatPanel',
     'UI.selRoom.chatArea.kinchatPanel',
     'UI.selRoom.chatArea.wisperPanel']
    for k in range(len(ui)):
        if ((1 == mode) and Win_SetImg(ui[k], 'object/ui/selRoom/dlg_chatMin.img')):
            Win_Move2Pos(ui[k], 442, 354)
            Win_SetRect(ui[k], value_channel_winrect, 442, 354, 320, 116)
            Win_SetRect((ui[k] + '.chatList'), value_channel_winrect, Win_GetX((ui[k] + '.chatList')), Win_GetY((ui[k] + '.chatList')), 320, 98)
            Win_SetRect((ui[k] + '.chatList'), value_channel_clientrect, 0, 0, 320, 98)
            Win_SetRect((ui[k] + '.chatList.chatScroll'), value_channel_clientrect, 0, 0, 14, 90)
            Win_Update((ui[k] + '.chatList'))
            Win_Update((ui[k] + '.chatList.chatScroll'))
            defPlayerCnt2 = 11




def InitSpeaker():
    global isBugle
    if (Win_GetCurScreen() == 'selRoom'):
        ui = ['UI.selRoom.chatArea.chatPanel',
         'UI.selRoom.chatArea.kinchatPanel',
         'UI.selRoom.chatArea.wisperPanel']
        for k in range(len(ui)):
            if ((IsPopo == 1) and Win_SetValue((ui[k] + '.speaker0.popo'), 1.0, 42)):
                Win_SetValue((ui[k] + '.speaker0.popo'), 1, 901)
                if ((CurXeffectSubID == 0) and Win_SetImg((ui[k] + '.speaker0.popo'), 'object/ui/selRoom/img_popo.img')):
                    pass
            for i in range(msgcnt):
                if (bmsg[i] and Win_ShowWidget((ui[k] + ('.speaker%d' % i)), 1)):
                    Win_SetDrawColor((ui[k] + ('.speaker%d' % i)), 200, 100, 100, 255)
                    Win_SetValue((ui[k] + ('.speaker%d' % i)), 1.0, 41)
                    Win_SetValue((ui[k] + ('.speaker%d' % i)), 1, 901)
                    Win_SetText((ui[k] + ('.speaker%d.words' % i)), (namebuf[i] + msgbuf[i]))


    elif (Win_GetCurScreen() == 'room'):
        ui = ['UI.room.chatArea.chatPanel',
         'UI.room.chatArea.kinchatPanel',
         'UI.room.chatArea.wisperPanel']
        for k in range(len(ui)):
            if ((IsPopo == 1) and Win_SetValue((ui[k] + '.speaker0.popo'), 1.0, 42)):
                Win_SetValue((ui[k] + '.speaker0.popo'), 1, 901)
                if ((CurXeffectSubID == 0) and Win_SetImg((ui[k] + '.speaker0.popo'), 'object/ui/room/img_popo.img')):
                    pass
            i = 0
            if (bmsg[i] and Win_ShowWidget((ui[k] + ('.speaker%d' % i)), 1)):
                Win_SetDrawColor((ui[k] + ('.speaker%d' % i)), 200, 100, 100, 255)
                Win_SetValue((ui[k] + ('.speaker%d' % i)), 1.0, 41)
                Win_SetValue((ui[k] + ('.speaker%d' % i)), 1, 901)
                Win_SetText((ui[k] + ('.speaker%d.words' % i)), msgbuf[i])
                Win_SetText((ui[k] + ('.speaker%d.nameBtn' % i)), namebuf[i])
                path = (ui[k] + ('.speaker%d.nameBtn' % i))
                winrect = Win_GetRect(path, value_channel_winrect)
                caprect = Win_GetRect(path, value_channel_captionrect)
                Win_SetRect(path, value_channel_winrect, winrect[0], winrect[1], (len(namebuf[i]) * 6), winrect[3])
                Win_SetRect(path, value_channel_captionrect, caprect[0], caprect[1], (len(namebuf[i]) * 6), caprect[3])
                Win_SetRect((ui[k] + ('.speaker%d.words' % i)), value_channel_winrect, (winrect[0] + (len(namebuf[i]) * 6)), winrect[1], (465 - (len(namebuf[i]) * 6)), winrect[3])
                Win_SetRect((ui[k] + ('.speaker%d.words' % i)), value_channel_captionrect, caprect[0], caprect[1], (465 - (len(namebuf[i]) * 6)), caprect[3])

    elif (Win_GetCurScreen() == 'game'):
        ui = 'UI.game.broadcastZone.speaker'
        isBugle = 0
        if (bmsg[0] and Win_SetDrawColor(ui, 200, 100, 100, 255)):
            Win_SetValue(ui, 1.0, 41)
            Win_SetValue(ui, 1, 901)
            Win_SetText(ui, (namebuf[0] + msgbuf[0]))



def NotifyBroadcast(name, uin, msg):
    (r, g, b, a,) = broadcastColor
    for i in range(msgcnt):
        if (bmsg[i] and (i < (msgcnt - 1))):
            continue
        bmsg[i] = 1
        for j in range(i):
            k = (i - j)
            msgbuf[k] = msgbuf[(k - 1)]
            namebuf[k] = namebuf[(k - 1)]
            uinbuf[k] = uinbuf[(k - 1)]

        msgbuf[0] = msg
        namebuf[0] = name
        uinbuf[0] = uin
        break

    if (Win_GetCurScreen() == 'selRoom'):
        ui = ['UI.selRoom.chatArea.chatPanel',
         'UI.selRoom.chatArea.kinchatPanel',
         'UI.selRoom.chatArea.wisperPanel']
        for j in range(len(ui)):
            for i in range(msgcnt):
                if (bmsg[i] and Win_ShowWidget((ui[j] + ('.speaker%d' % i)), 1)):
                    Win_SetDrawColor((ui[j] + ('.speaker%d' % i)), r, g, b, a)
                    Win_SetValue((ui[j] + ('.speaker%d' % i)), 1.0, 41)
                    Win_SetValue((ui[j] + ('.speaker%d' % i)), 1, 901)
                    Win_SetText((ui[j] + ('.speaker%d.words' % i)), (namebuf[i] + msgbuf[i]))


    elif (Win_GetCurScreen() == 'room'):
        ui = ['UI.room.chatArea.chatPanel',
         'UI.room.chatArea.kinchatPanel',
         'UI.room.chatArea.wisperPanel']
        for k in range(len(ui)):
            i = 0
            if (bmsg[i] and Win_ShowWidget((ui[k] + ('.speaker%d' % i)), 1)):
                Win_SetDrawColor((ui[k] + ('.speaker%d' % i)), r, g, b, a)
                Win_SetValue((ui[k] + ('.speaker%d' % i)), 1.0, 41)
                Win_SetValue((ui[k] + ('.speaker%d' % i)), 1, 901)
                Win_SetText((ui[k] + ('.speaker%d.words' % i)), msgbuf[i])
                Win_SetText((ui[k] + ('.speaker%d.nameBtn' % i)), namebuf[i])
                path = (ui[k] + ('.speaker%d.nameBtn' % i))
                winrect = Win_GetRect(path, value_channel_winrect)
                caprect = Win_GetRect(path, value_channel_captionrect)
                Win_SetRect(path, value_channel_winrect, winrect[0], winrect[1], (len(namebuf[i]) * 6), winrect[3])
                Win_SetRect(path, value_channel_captionrect, caprect[0], caprect[1], (len(namebuf[i]) * 6), caprect[3])
                Win_SetRect((ui[k] + ('.speaker%d.words' % i)), value_channel_winrect, (winrect[0] + (len(namebuf[i]) * 6)), winrect[1], (465 - (len(namebuf[i]) * 6)), winrect[3])
                Win_SetRect((ui[k] + ('.speaker%d.words' % i)), value_channel_captionrect, caprect[0], caprect[1], (465 - (len(namebuf[i]) * 6)), caprect[3])

    elif (Win_GetCurScreen() == 'game'):
        ui = 'UI.game.broadcastZone.speaker'
        Win_SetText(ui, (name + msg))
        Win_SetValue(ui, 1.0, 41)
        Win_SetValue(ui, 1, 901)



def NotifyRemoveMsg():
    j = (msgcnt - 1)
    for i in range(msgcnt):
        j = ((msgcnt - i) - 1)
        if bmsg[j]:
            bmsg[j] = 0
            break

    if (Win_GetCurScreen() == 'selRoom'):
        ui = ['UI.selRoom.chatArea.chatPanel',
         'UI.selRoom.chatArea.kinchatPanel',
         'UI.selRoom.chatArea.wisperPanel']
        for k in range(len(ui)):
            Win_SetValue((ui[k] + ('.speaker%d' % j)), 0.01, 41)
            Win_SetValue((ui[k] + ('.speaker%d' % j)), 2, 901)

    elif (Win_GetCurScreen() == 'room'):
        ui = ['UI.room.chatArea.chatPanel',
         'UI.room.chatArea.kinchatPanel',
         'UI.room.chatArea.wisperPanel']
        for k in range(len(ui)):
            Win_SetValue((ui[k] + ('.speaker%d' % j)), 0.01, 41)
            Win_SetValue((ui[k] + ('.speaker%d' % j)), 2, 901)

    elif (Win_GetCurScreen() == 'game'):
        ui = 'UI.game.broadcastZone.speaker'
        if ((0 == j) and Win_SetValue(ui, 0.01, 41)):
            Win_SetValue(ui, 2, 901)



def NotifyAddPopo(dwXeffectID):
    global CurXeffectSubID
    global IsPopo
    IsPopo = 1
    if (dwXeffectID != 0):
        desc = itemList[dwXeffectID]
        (type, dwXeffectSubID,) = desc[0:2]
        CurXeffectSubID = dwXeffectSubID
        if (type != 'xeffect'):
            dwXeffectID = 0
            CurXeffectSubID = 0
    else:
        CurXeffectSubID = 0
    if (Win_GetCurScreen() == 'selRoom'):
        ui = ['UI.selRoom.chatArea.chatPanel.speaker0.popo',
         'UI.selRoom.chatArea.kinchatPanel.speaker0.popo',
         'UI.selRoom.chatArea.wisperPanel.speaker0.popo']
        if (dwXeffectID == 0):
            for j in range(len(ui)):
                Win_SetValue(ui[j], 0.80000000000000004, 42)
                Win_SetValue(ui[j], 0.01, 41)
                Win_SetValue(ui[j], 1, 901)
                Win_SetImg(ui[j], 'object/ui/selRoom/img_popo.img')

        else:
            for j in range(len(ui)):
                Win_SetValue(ui[j], 0.80000000000000004, 42)
                Win_SetValue(ui[j], 0.01, 41)
                Win_SetValue(ui[j], 1, 901)
                Win_SetImg(ui[j], (('object/xeffect/xeffect' + str(dwXeffectSubID)) + '_stand.img'))

    elif (Win_GetCurScreen() == 'room'):
        ui = ['UI.room.chatArea.chatPanel.speaker0.popo',
         'UI.room.chatArea.kinchatPanel.speaker0.popo',
         'UI.room.chatArea.wisperPanel.speaker0.popo']
        if (dwXeffectID == 0):
            for k in range(len(ui)):
                Win_SetValue(ui[k], 0.80000000000000004, 42)
                Win_SetValue(ui[k], 0.01, 41)
                Win_SetValue(ui[k], 1, 901)
                Win_SetImg(ui[k], 'object/ui/room/img_popo.img')

        else:
            for k in range(len(ui)):
                Win_SetValue(ui[k], 0.80000000000000004, 42)
                Win_SetValue(ui[k], 0.01, 41)
                Win_SetValue(ui[k], 1, 901)
                Win_SetImg(ui[k], (('object/xeffect/xeffect' + str(dwXeffectSubID)) + '_walk.img'))




def NotifyRemovePopo():
    global IsPopo
    IsPopo = 0
    if (Win_GetCurScreen() == 'selRoom'):
        ui = 'UI.selRoom.chatArea.chatPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.chatPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.chatPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.kinchatPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.kinchatPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.kinchatPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.wisperPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.wisperPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.selRoom.chatArea.wisperPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
    elif (Win_GetCurScreen() == 'room'):
        ui = 'UI.room.chatArea.chatPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.chatPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.chatPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.kinchatPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.kinchatPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.kinchatPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.wisperPanel.speaker0.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.wisperPanel.speaker1.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)
        ui = 'UI.room.chatArea.wisperPanel.speaker2.popo'
        Win_SetValue(ui, 0.01, 41)
        Win_SetValue(ui, 2, 901)



def useExtItem(ID, playerNum):
    if commodityList.has_key(ID):
        type = commodityList[ID][0]
        idx = commodityList[ID][1]
        picName = ('object/%s/%s%d_stand.img' % (type,
         type,
         idx))
        if ((type == 'namecard') and Win_SetImg((uiPlayerListDlg + ('.playerInfo%d.namecard' % playerNum)), picName)):
            pass
    else:
        return 



def unUseAllExtItem(playerNum):
    Win_SetImg((uiPlayerListDlg + ('.playerInfo%d.namecard' % playerNum)), '')
    Win_SetImg((uiPlayerListDlg + ('.playerInfo%d.namecardbound' % playerNum)), '')



def closeMenu():
    ui = Win_GetCurScreen()
    Win_ShowWidget((('UI.' + ui) + '.menuDlg'), 0)



def stripStr(s):
    if ('' == s):
        return ''
    while ((len(s) > 1) and (('"' == s[0]) or ("'" == s[0]))):
        s = s[1:]

    while ((len(s) > 1) and (('"' == s[-1]) or (("'" == s[-1]) or (' ' == s[-1])))):
        s = s[:-1]

    return s


class Sect:
    __module__ = __name__

    def getName(this):
        info = sc_getCurSectInfo()
        name = info.m_szSectionName
        serverName = zoneList[curZone]
        return ((stripStr(serverName) + '  >>  ') + stripStr(name))



    def meGetPlayerInfo(this):
        return fetch_PlayerInfoInPlayerList(0, 0).m_PlayerInfo



    def meHasPassport(this):
        pi = this.meGetPlayerInfo()
        return (0 != (pi.m_dwIdentity & ((64 | 256) | 512)))



    def meGetPoint(this):
        pi = this.meGetPlayerInfo()
        gi = pi.m_stGameInfo
        return gi.m_dwPoint




def leaveSection():
    doUI('UI.selRoom', 'OnEscape')



def getMapInfo(ID):
    desc = getMapDesc(ID)
    info = CNil()
    info.ID = desc[0]
    info.type = desc[1]
    info.name = desc[2]
    info.size = ('%d X %d' % (desc[3],
     desc[4]))
    info.playerNum = desc[5]
    info.picName = ('map/' + desc[7])
    return info



def setFacePage(page, pageNum):
    global facePage
    global memberFacePage
    if (Win_GetCurScreen() == 'selRoom'):
        ui_bg = 'UI.selRoom.chatArea'
    elif (Win_GetCurScreen() == 'room'):
        ui_bg = 'UI.room.chatArea'
    else:
        return 
    Win_SetText((ui_bg + '.faceBtn.faceDlg.pageLab'), ('%d/%d' % ((page + 1),
     pageNum)))
    if isMemberFace:
        memberFacePage = page
        start = (page * 24)
        for k in range(24):
            i = (start + k)
            ui = ((ui_bg + '.faceBtn.faceDlg.box.face') + str(k))
            if ((i < len(memberFaceIconList)) and Win_SetImg(ui, ('res/uires/face/faces/member/%03d.img' % (i)))):
                Win_ShowWidget(ui, True)

    else:
        facePage = page
        start = ((page + memberFacePageNum) * 24)
        for k in range(24):
            i = (start + k)
            ui = ((ui_bg + '.faceBtn.faceDlg.box.face') + str(k))
            if ((i < len(faceIconList)) and Win_SetImg(ui, ('res/uires/face/faces/%03d.img' % (i)))):
                Win_ShowWidget(ui, True)




def playerInfo_useCommItem(ID):

    def useIt(ID):
        if (not itemList.has_key(ID)):
            print 'dont know comm item, ID=',
            print ID
            return 
        desc = itemList[ID]
        (type, idx,) = desc[0:2]
        ui = (uiPlayerInfoDlg + '.playerDemo')
        if equipMap.has_key(type):
            itemInfo = GetItemInfoFromSec(ID)
            selRoom_playerWear(type, idx, itemInfo.m_bItemEffect, itemInfo.m_bItemColor)
        else:
            if (('bg' == type) and Win_SetImg((ui + '.bg'), ('object/bg/bg%d_stand.img' % idx))):
                pass


    useIt(ID)



def ui_sectSetBtnState(buttonID, isEnable):
    if ((1 == buttonID) and Win_EnableWidget('UI.selRoom.roomLeft', isEnable)):
        pass



def myGetPlayerCnt():
    global friendCnt
    global playerCnt
    global kinMemberCnt
    cnt = GetPlayerCnt(playerMode)
    if (0 == playerMode):
        playerCnt = cnt
    elif (1 == playerMode):
        friendCnt = cnt
    elif (2 == playerMode):
        kinMemberCnt = cnt
    return cnt



def myGetPlayerPos():
    if (0 == playerMode):
        return playerPos
    elif (1 == playerMode):
        return friendPos
    elif (2 == playerMode):
        return kinMemberPos



def mySetPlayerPos(pos):
    global playerPos
    global kinMemberPos
    global friendPos
    if (0 == playerMode):
        playerPos = pos
    elif (1 == playerMode):
        friendPos = pos
    elif (2 == playerMode):
        kinMemberPos = pos



def maskPlayer(begin, end):
    ui = (uiPlayerListDlg + '.friendMask')
    x = Win_GetX(ui)
    y = 107
    if (((begin >= end) or (begin < 0)) and Win_SetDrawTexRect(ui, 0, (begin * 24), 330, 0)):
        Win_SetRect((ui + '.tipBtn'), value_channel_winrect, x, (y + (begin * 24)), 330, 0)



def updatePlayer():

    def myGetPlayerInfo(i, mode):

        def getFake(i):
            if (i >= playerCnt):
                return None
            info = CNil()
            info.isVip = True
            info.name = 'Mike Chen'
            info.isBoy = True
            info.level = 2
            info.uin = 6676317
            return info



        def get(i, mode):
            cnt = 0
            if (mode == 0):
                cnt = playerCnt
            elif (1 == mode):
                cnt = friendCnt
            elif (2 == mode):
                cnt = kinMemberCnt
            if (i >= cnt):
                return None
            info = CNil()
            pi = fetch_PlayerInfoInPlayerList(i, mode)
            a = pi.m_PlayerInfo
            gameInfo = a.m_stGameInfo
            info.state = pi.m_nPlayerStatus
            info.isVip = (a.m_dwIdentity & 8)
            info.isgoldDiamond = (a.m_dwIdentity & 8192)
            info.name = a.m_szPlayerNickname.replace('\n', '')
            info.isBoy = (1 == int(a.m_bGender))
            info.level = Level().getInfo(gameInfo.m_dwPoint)
            info.uin = a.m_dwPlayerUin
            info.extItemNum = a.m_bExtItemNum
            info.m_dwKinIndex = a.m_dwKinIndex
            info.m_nKinNameLen = a.m_nKinNameLen
            info.m_szKinName = a.m_szKinName
            info.m_stKinFlagID = a.m_stKinFlagID
            return info


        return get(i, mode)



    def show(player, b):
        Win_ShowWidget((player + '.name'), b)
        Win_ShowWidget((player + '.gender'), b)
        Win_ShowWidget((player + '.levelIcon'), b)
        Win_ShowWidget((player + '.goldDiamond'), b)
        Win_ShowWidget((player + '.kintotem'), b)


    listCnt = myGetPlayerCnt()
    listPos = myGetPlayerPos()
    for i in range(defPlayerCnt):
        player = ((uiPlayerListDlg + '.playerInfo') + str((i + 1)))
        unUseAllExtItem((i + 1))
        info = myGetPlayerInfo((i + listPos), playerMode)
        if (((info == None) or (info.uin == 0)) and show(player, 0)):
            Win_EnableWidget(player, 0)

    if (1 == playerMode):
        maskBegin = min((GetValidFriendsCount() - listPos), defPlayerCnt)
        maskEnd = min((listCnt - listPos), defPlayerCnt)
        maskPlayer(maskBegin, maskEnd)
    else:
        maskPlayer(0, 0)



def useExtItem2(ID, playerNum):
    if commodityList.has_key(ID):
        type = commodityList[ID][0]
        idx = commodityList[ID][1]
        picName = ('object/%s/%s%d_stand.img' % (type,
         type,
         idx))
        if ((type == 'namecard') and Win_SetImg((uiSelroomPlayerList + ('.playerInfo%d.namecard' % playerNum)), picName)):
            pass
    else:
        return 



def unUseAllExtItem2(playerNum):
    Win_SetImg((uiSelroomPlayerList + ('.playerInfo%d.namecard' % playerNum)), '')
    Win_SetImg((uiSelroomPlayerList + ('.playerInfo%d.namecardbound' % playerNum)), '')



def myGetPlayerCnt2():
    global friendCnt
    global playerCnt
    global kinMemberCnt
    cnt = GetPlayerCnt(playerMode2)
    if (0 == playerMode2):
        playerCnt = cnt
    elif (1 == playerMode2):
        friendCnt = cnt
    elif (2 == playerMode2):
        kinMemberCnt = cnt
    return cnt



def myGetPlayerPos2():
    if (0 == playerMode2):
        return playerPos2
    elif (1 == playerMode2):
        return friendPos2
    elif (2 == playerMode2):
        return kinMemberPos2



def mySetPlayerPos2(pos):
    global playerPos2
    global friendPos2
    global kinMemberPos2
    if (0 == playerMode2):
        playerPos2 = pos
    elif (1 == playerMode2):
        friendPos2 = pos
    elif (2 == playerMode2):
        kinMemberPos2 = pos



def maskPlayer2(begin, end):
    ui = (uiSelroomPlayerList + '.friendMask')
    x = Win_GetX(ui)
    y = 96
    if (((begin >= end) or (begin < 0)) and Win_SetDrawTexRect(ui, 0, (begin * 24), 330, 0)):
        Win_SetRect((ui + '.tipBtn'), value_channel_winrect, x, (y + (begin * 24)), 330, 0)



def updatePlayer2():

    def myGetPlayerInfo(i, mode):

        def get(i, mode):
            cnt = 0
            if (mode == 0):
                cnt = playerCnt
            elif (1 == mode):
                cnt = friendCnt
            elif (2 == mode):
                cnt = kinMemberCnt
            if (i >= cnt):
                return None
            info = CNil()
            pi = fetch_PlayerInfoInPlayerList(i, mode)
            a = pi.m_PlayerInfo
            gameInfo = a.m_stGameInfo
            info.state = pi.m_nPlayerStatus
            info.isVip = (a.m_dwIdentity & 8)
            info.isgoldDiamond = (a.m_dwIdentity & 8192)
            info.name = a.m_szPlayerNickname.replace('\n', '')
            info.isBoy = (1 == int(a.m_bGender))
            info.level = Level().getInfo(gameInfo.m_dwPoint)
            info.uin = a.m_dwPlayerUin
            info.extItemNum = a.m_bExtItemNum
            info.m_dwKinIndex = a.m_dwKinIndex
            info.m_nKinNameLen = a.m_nKinNameLen
            info.m_szKinName = a.m_szKinName
            info.m_stKinFlagID = a.m_stKinFlagID
            return info


        return get(i, mode)



    def show(player, b):
        Win_ShowWidget((player + '.name'), b)
        Win_ShowWidget((player + '.gender'), b)
        Win_ShowWidget((player + '.levelIcon'), b)
        Win_ShowWidget((player + '.goldDiamond'), b)
        Win_ShowWidget((player + '.kintotem'), b)


    listCnt = myGetPlayerCnt2()
    listPos = myGetPlayerPos2()
    for i in range(11):
        player = ((uiSelroomPlayerList + '.playerInfo') + str((i + 1)))
        if ((i >= defPlayerCnt2) and Win_ShowWidget(player, 0)):
            continue
        unUseAllExtItem2((i + 1))
        info = myGetPlayerInfo((i + listPos), playerMode2)
        if (((info == None) or (info.uin == 0)) and show(player, 0)):
            Win_EnableWidget(player, 0)

    if (1 == playerMode2):
        maskBegin = min((GetValidFriendsCount() - listPos), defPlayerCnt2)
        maskEnd = min((listCnt - listPos), defPlayerCnt2)
        maskPlayer2(maskBegin, maskEnd)
    else:
        maskPlayer2(0, 0)



def myGetRoomCnt():
    return GetRoomCnt()



def updateRoom():
    global roomCnt

    def myGetRoomInfo(i):

        def getFake(i):
            global roomCnt
            roomCnt = 8
            if (i >= roomCnt):
                return None
            info = CNil()
            info.no = 10
            info.logicID = 20
            info.name = 'nameless'
            roomFlag = 0
            info.isStandardRoom = Rand(2)
            info.hasPassword = Rand(2)
            info.time = 3
            info.playerNum = 3
            info.roomMaxPlayerNum = 3
            info.mapName = mapList[1][0]
            return info



        def get(i):
            if (i >= roomCnt):
                return None
            ri = GetRoomInfo(i, GameType)
            info = CNil()
            info.no = ri.sUIRoomID
            info.logicID = ri.shRoomLogicalID
            info.isVip = ri.sIsVIP
            info.name = ri.m_szRoomName
            info.flag = ri.iRoomFlag
            info.isStandardRoom = (0 == ri.iRuleType)
            info.hasPassword = ri.IsRoomLocked
            info.time = 3
            info.playerNum = ri.sPlayerInRoom
            info.roomMaxPlayerNum = ri.sMaxPlayer
            info.mapName = mapID2name(ri.m_nMapID)
            info.mapType = getMapInfo(ri.m_nMapID).type
            return info


        return get(i)


    roomCnt = myGetRoomCnt()
    for i in range(8):
        room = ('UI.selRoom.room' + str((i + 1)))
        info = myGetRoomInfo(i)
        if ((None == info) and Win_ShowWidget(room, False)):
            continue
        Win_ShowWidget(room, True)
        Win_EnableWidget(room, False)
        Win_SetImg(room, 'object/ui/selRoom/dlg_room.img')
        if ((1 == info.flag) and Win_EnableWidget(room, True)):
            pass
        Win_SetText((room + '.no'), ('%03d' % info.no))
        Win_ShowWidget((room + '.vip'), info.isVip)
        if ((0 == info.flag) and Win_SetValue((room + '.logicID'), -1)):
            Win_SetText((room + '.name'), '')
            Win_ShowWidget((room + '.standard'), False)
            Win_ShowWidget((room + '.password'), False)
            Win_SetText((room + '.playerNum'), '')
            Win_SetText((room + '.mapName'), '')
            Win_SetImg((room + '.mapIcon'), '')
            Win_ShowWidget((room + '.vip'), False)
        if ((4 == GameType) and Win_SetText((room + '.name'), '\xc1\xc4\xcc\xec\xca\xd2')):
            Win_SetImg((room + '.mapIcon'), 'res/uires/selRoom/icon/chat.img')




def ui_getPlayerDetail():
    global lookupKinID

    def myGetPlayerDetail():
        info = CNil()
        pi = GetPlayerDetail()
        info.uin = pi.m_dwFriendUin
        info.name = '-'
        info.nickName = pi.m_szPlayerName.replace('\n', '')
        info.isBoy = (1 == int(pi.m_cGender))
        info.m_dwKinIndex = pi.m_dwKinIndex
        info.m_nKinNameLen = pi.m_nKinNameLen
        info.m_stKinFlagID = pi.m_stKinFlagID
        info.m_szKinName = pi.m_szKinName
        info.m_iHonor = pi.m_iHonor
        info.isgoldDiamond = (pi.m_dwIdentity & 8192)
        channelName = stripStr(pi.m_szChannelName)
        sectionName = stripStr(pi.m_szSectionName)
        roomName = stripStr(pi.m_szRoomName)
        areaName = stripStr(pi.m_szZoneName)
        if (areaName == ''):
            areaName = '\xd0\xa1\xc7\xf8'
        roomNO = str(pi.m_sRoomUIID)
        if (roomNO == '0'):
            roomNO = ''
        if (1 == pi.m_bStatus):
            info.state = '\xd4\xda\xcf\xdf'
            info.state += ('\n\xa1\xbe\xc6\xb5\xb5\xc0\xa1\xbf%s(%s)' % (channelName,
             areaName))
            info.state += ('\n\xa1\xbe\xd0\xa1\xc7\xf8\xa1\xbf' + sectionName)
        elif (2 == pi.m_bStatus):
            info.state = '\xd4\xda\xb7\xbf\xbc\xe4\xc4\xda'
            info.state += ('\n\xa1\xbe\xc6\xb5\xb5\xc0\xa1\xbf%s(%s)' % (channelName,
             areaName))
            info.state += ('\n\xa1\xbe\xd0\xa1\xc7\xf8\xa1\xbf' + sectionName)
            info.state += (('\n\xa1\xbe\xb7\xbf\xbc\xe4%s\xa1\xbf' % roomNO) + roomName)
        elif (3 == pi.m_bStatus):
            info.state = '\xd5\xfd\xd4\xda\xd3\xce\xcf\xb7'
            info.state += ('\n\xa1\xbe\xc6\xb5\xb5\xc0\xa1\xbf%s(%s)' % (channelName,
             areaName))
            info.state += ('\n\xa1\xbe\xd0\xa1\xc7\xf8\xa1\xbf' + sectionName)
            info.state += (('\n\xa1\xbe\xb7\xbf\xbc\xe4%s\xa1\xbf' % roomNO) + roomName)
        elif (0 == pi.m_bStatus):
            info.state = '\xb2\xbb\xd4\xda\xcf\xdf'
            info.isBoy = -1
        else:
            info.state = '\xce\xb4\xd6\xaa'
        info.bStatus = ((pi.m_bStatus >= 1) and (pi.m_bStatus <= 3))
        info.isfriend = GetAttribute(pi.m_dwFriendUin, 0)
        gi = pi.m_stGameInfo
        info.winNum = gi.m_nWinNum
        info.loseNum = gi.m_nLossNum
        info.drawNum = gi.m_nEqualNum
        info.point = gi.m_dwPoint
        info.level = Level().getInfo(gi.m_dwPoint)
        info.exp = Level().getExp(gi.m_dwPoint)
        info.expRate = Level().getRate(gi.m_dwPoint)
        info.roleID = gi.m_bRoleID
        print info.level,
        print info.exp,
        print info.expRate
        info.pveWinNum = gi.m_dwExtWinNum
        info.pveLoseNum = gi.m_dwExtLossNum
        info.pveDrawNum = gi.m_dwExtEqualNum
        info.pvePoint = gi.m_dwExtPoint
        info.pveInfo = GetPVEData(info.pvePoint)
        return info



    def myGetPlayerDetailFake():
        info = CNil()
        info.uin = 123456789
        info.name = 'm_szPlayerName'
        info.isBoy = True
        info.winNum = 100
        info.loseNum = 90
        info.point = 998877
        info.level = 100
        return info


    ui = uiPlayerInfoDlg
    if (not Win_IsVisible(ui)):
        return 
    myInfo = GetPlayerInfoByUin(uin)
    myMarriageInfo = GetMyMarriageDetail()
    if (queryingUin == uin):
        marriageInfo = GetMyMarriageDetail()
    else:
        marriageInfo = GetMarriageDetail()
    info = myGetPlayerDetail()
    MeIsBoy = (1 == int(myInfo.m_bGender))
    Win_SetText((ui + '.QQ'), str(info.uin))
    avtUin = int(Win_GetText((ui + '.avtUin')))
    if ((avtUin != info.uin) and Win_SetText((ui + '.avtUin'), '-1')):
        if (((info.isBoy == -1) or info.isBoy) and Win_SetImg((ui + '.avt'), 'res/uiRes/avt_boy.gif')):
            pass
    if ((info.isBoy == -1) and Win_SetText((ui + '.gender'), '_')):
        Win_SetImg((ui + '.genderPic'), '')
    (r1, g1, b1, a1,) = (135,
     249,
     255,
     255)
    (r2, g2, b2, a2,) = memberNameColor
    if (info.isgoldDiamond and Win_SetImg((ui + '.playerDemo.goldDiamond'), 'res/uires/selRoom/goldDiamond.img')):
        Win_SetDrawColor((ui + '.nickName'), r1, g1, b1, a1)
    Win_SetText((ui + '.nickName'), info.nickName)
    Win_SetText((ui + '.state'), info.state)
    if ((marriageInfo.m_dwMarriageUin != 0) and Win_SetText((ui + '.spouseName'), marriageInfo.m_szSpouseNickname)):
        Win_ShowWidget((ui + '.lookupMarriage'), 1)
        Win_ShowWidget((ui + '.spark'), 0)
    lookupKinID = 0
    if (info.m_dwKinIndex != 0):
        lookupKinID = info.m_dwKinIndex
        if (((info.m_stKinFlagID.m_iFlagID >= 0) and (info.m_stKinFlagID.m_iFlagID <= 48)) and Win_SetImg((ui + '.kintotem'), ('object/ui/kinTotem/%03d.img' % (info.m_stKinFlagID.m_iFlagID)))):
            pass
    if ((info.m_nKinNameLen != 0) and Win_SetText((ui + '.kin'), info.m_szKinName)):
        pass
    Win_ShowWidget((ui + '.addFriendBtn'), (not info.isfriend))
    Win_EnableWidget((ui + '.addFriendBtn'), (not (info.uin == uin)))
    Win_ShowWidget((ui + '.deleteFriendBtn'), info.isfriend)
    Win_EnableWidget((ui + '.traceBtn'), (info.bStatus and GetAttribute(info.uin, 0)))
    Win_EnableWidget((ui + '.privateChatBtn'), info.bStatus)
    Win_EnableWidget((ui + '.privateChatBtn'), (not (info.uin == uin)))
    Win_SetDrawTexRect((uiPvpInfoDlg + '.expLine'), 0, 0, ((info.exp * 136) / 100), 12)
    Win_SetText((uiPvpInfoDlg + '.exp'), info.expRate)
    Win_SetText((uiPvpInfoDlg + '.reputation'), str(info.m_iHonor))
    Win_SetText((uiPvpInfoDlg + '.point'), str(info.point))
    Level().setUI(uiPvpInfoDlg, info.level)
    levelname = info.level[0]
    if ((info.level[1] == 25) and (not info.isBoy)):
        levelname = '\xd4\xc2\xc1\xc1\xb9\xab\xd6\xf7'
    elif ((info.level[1] == 26) and (not info.isBoy)):
        levelname = '\xcc\xab\xd1\xf4\xc5\xae\xcd\xf5'
    elif ((info.level[1] == 27) and (not info.isBoy)):
        levelname = '\xd7\xcf\xd7\xea\xc5\xae\xbb\xca'
    Win_SetText((uiPvpInfoDlg + '.level'), levelname)
    Win_SetText((uiPvpInfoDlg + '.success'), ('%d\xca\xa4 %d\xb0\xdc %d\xc6\xbd' % (info.winNum,
     info.loseNum,
     info.drawNum)))
    Win_SetText((uiPveInfoDlg + '.pveLevelLabel'), str(info.pveInfo.m_unLevel))
    Win_SetDrawTexRect((uiPveInfoDlg + '.pveLevel'), 0, 0, ((info.pveInfo.m_unLevel * 118) / 20), 12)
    Win_SetText((uiPveInfoDlg + '.pveCourage'), str(info.pvePoint))
    Win_SetText((uiPveInfoDlg + '.pveLife'), str(info.pveInfo.m_unHp))
    Win_SetDrawTexRect((uiPveInfoDlg + '.pveBomb'), 0, 0, ((info.pveInfo.m_unBombNum * 118) / 8), 12)
    Win_SetDrawTexRect((uiPveInfoDlg + '.pveBombResume'), 0, 0, int((118.0 / (2.0 * (info.pveInfo.m_fBombReSpeed + 0.0001)))), 12)
    Win_SetDrawTexRect((uiPveInfoDlg + '.pvePower'), 0, 0, ((info.pveInfo.m_unBombPow * 118) / 4000), 12)
    Win_SetDrawTexRect((uiPveInfoDlg + '.pveSpeed'), 0, 0, ((info.pveInfo.m_unSpeed * 118) / 8), 12)



def ui_NotifyPlayerUpdate():
    if ((Win_GetCurScreen() == 'selRoom') and updatePlayer()):
        updatePlayer2()



def ui_NotifyRoom():
    if ((Win_GetCurScreen() == 'selRoom') and updateRoom()):
        pass



def isAllowFx_selRoom():
    if Win_IsVisible('UI.SysMsgbox'):
        return False
    elif Win_IsVisible(uiSetupDlg):
        return False
    elif Win_IsVisible('UI.selRoom.pwRoom'):
        return False
    else:
        return True



def go2playerInfo(_uin, isDoFind = 1):
    global queryingUin

    def clearMyUI():
        global lookupKinID
        ui = uiPlayerInfoDlg
        lookupKinID = 0
        if (not Win_IsVisible(ui)):
            return 
        Win_SetText((ui + '.gender'), '')
        Win_SetImg((ui + '.genderPic'), '')
        Win_SetText((ui + '.QQ'), '')
        Win_SetText((ui + '.nickName'), '')
        Win_SetText((ui + '.state'), '')
        Win_SetImg((ui + '.kintotem'), '')
        Win_SetText((ui + '.kin'), '')
        Win_SetDrawTexRect((uiPvpInfoDlg + '.expLine'), 0, 0, 0, 0)
        Win_SetText((uiPvpInfoDlg + '.exp'), '')
        Win_SetText((uiPvpInfoDlg + '.reputation'), '')
        Win_SetText((uiPvpInfoDlg + '.point'), '')
        Level().clearUI(uiPvpInfoDlg)
        Win_SetText((uiPvpInfoDlg + '.level'), '')
        Win_SetText((uiPvpInfoDlg + '.success'), '')
        Win_SetText((uiPveInfoDlg + '.pveLevelLabel'), '')
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveLevel'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveCourage'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveLife'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveBomb'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveBombResume'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pvePower'), 0, 0, 0, 0)
        Win_SetDrawTexRect((uiPveInfoDlg + '.pveSpeed'), 0, 0, 0, 0)
        ui += '.playerDemo'
        Win_SetImg((ui + '.bg'), '')
        Win_SetImg((ui + '.enter'), '')
        Win_SetImg((ui + '.frame'), '')


    queryingUin = _uin
    ui_setCapture(uiPlayerInfoDlg)
    clearMyUI()
    PlaySound(soundUI, 1)
    if (isDoFind and FindFriend(_uin)):
        pass


class TopkinList:
    __module__ = __name__

    def getCnt(this):
        global TopkinCnt
        TopkinCnt = 10
        return TopkinCnt



    def __get(this, i):
        info = CNil()
        kinobject = fetch_topkininfolist(chinatelecom, setreputation, i)
        kinname = kinobject.m_szName
        kinname = kinname.replace('\n', '')
        kinname = kinname.replace("'", "\\'")
        info.kinindex = kinobject.m_dwKinIndex
        info.name = kinname
        info.value = kinobject.m_iValue
        info.order = kinobject.m_nOrder
        info.ascend = kinobject.m_nAscend
        return info



    def at(this, Idx):
        if (Idx >= TopkinCnt):
            return None
        return this._TopkinList__get(Idx)




def ui_updateMykinintop():
    Win_SetText((uitopKinDlg + '.topkin7.kinName'), '')
    Win_SetText((uitopKinDlg + '.topkin7.value'), '')
    Win_SetText((uitopKinDlg + '.topkin7.Order'), '')
    Win_SetImg((uitopKinDlg + '.topkin7.isAscend'), '')
    Win_SetText((uitopKinDlg + '.topkin8.kinName'), '')
    Win_SetText((uitopKinDlg + '.topkin8.value'), '')
    Win_SetText((uitopKinDlg + '.topkin8.Order'), '')
    Win_SetImg((uitopKinDlg + '.topkin8.isAscend'), '')
    info = CNil()
    kinobject = fetch_topkininfolist(chinatelecom, setreputation, 10)
    kinname = kinobject.m_szName
    kinname = kinname.replace('\n', '')
    kinname = kinname.replace("'", "\\'")
    info.kinindex = kinobject.m_dwKinIndex
    info.name = kinname
    info.value = kinobject.m_iValue
    info.order = kinobject.m_nOrder
    info.ascend = kinobject.m_nAscend
    Win_SetText((uitopKinDlg + '.topkin7.kinName'), info.name)
    if (kinobject.m_dwKinIndex == 0):
        info.value = ''
    Win_SetText((uitopKinDlg + '.topkin7.value'), str(info.value))
    Win_SetText((uitopKinDlg + '.topkin7.Order'), str(info.order))
    if ((kinobject.m_dwKinIndex == 0) and Win_SetImg((uitopKinDlg + '.topkin7.isAscend'), '')):
        pass
    kinobject = fetch_topkininfolist(chinatelecom, setreputation, 11)
    kinname = kinobject.m_szName
    kinname = kinname.replace('\n', '')
    kinname = kinname.replace("'", "\\'")
    info.kinindex = kinobject.m_dwKinIndex
    info.name = kinname
    info.value = kinobject.m_iValue
    info.order = kinobject.m_nOrder
    info.ascend = kinobject.m_nAscend
    Win_SetText((uitopKinDlg + '.topkin8.kinName'), info.name)
    if (kinobject.m_dwKinIndex == 0):
        info.value = ''
    Win_SetText((uitopKinDlg + '.topkin8.value'), str(info.value))
    Win_SetText((uitopKinDlg + '.topkin8.Order'), str(info.order))
    if ((kinobject.m_dwKinIndex == 0) and Win_SetImg((uitopKinDlg + '.topkin8.isAscend'), '')):
        pass



def ui_updateTopkinList():
    global ActivetopkinPos
    global TopkinCurrentPos
    ShowCnt = TopkinList().getCnt()
    TopKinCnt = TopkinList().getCnt()
    ActivetopkinPos = 999999
    TopkinCurrentPos = min(TopkinCurrentPos, (ShowCnt - defTopkinDlgCnt))
    TopkinCurrentPos = max(TopkinCurrentPos, 0)
    for i in range(defTopkinDlgCnt):
        ui = (uitopKinDlg + ('.topkin%d' % i))
        Win_SetText((ui + '.kinName'), '')
        Win_SetText((ui + '.value'), '')
        Win_SetImg((ui + '.Order'), '')
        idx = (TopkinCurrentPos + i)
        Win_SetCheck(ui, 0)
        if ((idx >= ShowCnt) and Win_SetText((ui + '.kinNmae'), '')):
            Win_SetText((ui + '.value'), '')
            Win_SetImg((ui + '.Order'), '')
            Win_EnableWidget(ui, 0)
            continue

    ui_updateMykinintop()
    ui_setCapture(uitopKinDlg)



def InitGameType():
    if ((GameType == 0) and Win_SelectSelf('UI.selRoom.modeCompete')):
        Win_SelectSelf('UI.selRoom.modeCompete.modeNoItem')
        Win_ShowWidget('UI.selRoom.modeCompete.modeNoItem', 1)
        Win_ShowWidget('UI.selRoom.modeCompete.modeItem', 1)
        doUI('UI.selRoom.modeCompete.modeNoItem', 'OnClick')



def UpdatePetInfo():
    global curPetState
    global curPetId
    global skillIdList
    global petsIdList
    global curPetName
    global baseSkillIdList

    def Clear():
        Win_SetText((uiPetPan + '.petPreview'), '')
        Win_SetImg((uiPetPan + '.petPreview'), '')
        Win_SetImg((uiPetPan + '.petFace'), '')
        Win_SetText((uiPetPan + '.nameEdit'), '')
        Win_SetText((uiPetPan + '.level'), '')
        Win_EnableWidget((uiPetPan + '.freePetBtn'), 1)
        Win_EnableWidget((uiPetPan + '.changeNameBtn'), 1)
        Win_EnableWidget((uiPetPan + '.adoptPetBtn'), 1)
        Win_EnableWidget((uiPetPan + '.petStateBtn'), 1)
        Win_EnableWidget((uiPetPan + '.nameEdit'), 1)
        Win_EnableWidget((uiPetPan + '.raisePetBtn'), 1)
        Win_EnableWidget((uiPetPan + '.left'), 1)
        Win_EnableWidget((uiPetPan + '.right'), 1)
        for i in range(3):
            Win_SetText((uiPetPan + ('.baseSkillDlg.skill%d' % i)), '')

        for i in range(10):
            Win_SetText((uiPetPan + ('.skillDlg.skill%d' % i)), '')




    def ShowEmptyPan():
        Win_SetText((uiPetPan + '.petPreview'), '    \xc4\xfa\xb5\xb1\xc7\xb0\xbb\xb9\xc3\xbb\xd3\xd0\xb3\xe8\xce\xef\xb1\xa6\xb1\xa6,\xc8\xe7\xb9\xfb\xc4\xfa\xd2\xd1\xd3\xd0\xb3\xe8\xce\xef\xbf\xa8\xc5\xc6\xc7\xeb\xb4\xf2\xbf\xaa\xb3\xe8\xce\xef\xb1\xb3\xb0\xfc\xa3\xac\xb5\xe3\xbb\xf7\xd3\xd2\xbc\xfc\xd5\xd9\xbb\xbd\xb3\xf6\xc4\xfa\xb5\xc4\xb3\xe8\xce\xef\xb1\xa6\xb1\xa6\xa3\xa1 ')
        Win_SetImg((uiPetPan + '.petPreview'), '')
        Win_SetImg((uiPetPan + '.petFace'), '')
        Win_SetText((uiPetPan + '.nameEdit'), '')
        Win_SetText((uiPetPan + '.level'), '')
        Win_EnableWidget((uiPetPan + '.freePetBtn'), 0)
        Win_EnableWidget((uiPetPan + '.changeNameBtn'), 0)
        Win_EnableWidget((uiPetPan + '.adoptPetBtn'), 1)
        Win_EnableWidget((uiPetPan + '.petStateBtn'), 0)
        Win_EnableWidget((uiPetPan + '.nameEdit'), 0)
        Win_EnableWidget((uiPetPan + '.raisePetBtn'), 1)
        Win_ShowWidget((uiPetPan + '.foodDlg'), 1)
        Win_EnableWidget((uiPetPan + '.left'), 0)
        Win_EnableWidget((uiPetPan + '.right'), 0)
        Win_SetDrawTexRect((uiPetPan + '.expLine'), 0, 0, 0, 12)
        Win_SetText((uiPetPan + '.expValue'), '0 / 0')
        Win_SetDrawTexRect((uiPetPan + '.loyaltyLine'), 0, 0, 0, 12)
        Win_SetText((uiPetPan + '.loyaltyValue'), '0 / 0')
        UpdatePetItemUi()
        for i in range(3):
            Win_SetText((uiPetPan + ('.baseSkillDlg.skill%d' % i)), '')

        for i in range(10):
            Win_SetText((uiPetPan + ('.skillDlg.skill%d' % i)), '')



    Clear()
    petsIdList = GetPlayerAllPetsId()
    if (len(petsIdList) == 0):
        curPetId = 0
        ShowEmptyPan()
        return False
    if (curPetId == 0):
        petInfo = GetCurActivePetInfo()
    else:
        petInfo = GetPetBaseInfo(curPetId)
        if (petInfo.m_dwPetId == 0):
            petInfo = GetCurActivePetInfo()
    if (petInfo.m_dwPetId == 0):
        curPetId = 0
        ShowEmptyPan()
        return False
    curPetId = petInfo.m_dwPetId
    petResId = GetPetResId(petInfo.m_dwPetTypeId, petInfo.m_wPetLevel)
    Win_SetImg((uiPetPan + '.petPreview'), ('object/pet/pet%d_stand.img' % petResId))
    Win_SetText((uiPetPan + '.petPreview'), '')
    if (petInfo.m_wPetMood >= 90):
        moodUiId = 4
    elif ((petInfo.m_wPetMood >= 60) and (petInfo.m_wPetMood < 90)):
        moodUiId = 3
    elif ((petInfo.m_wPetMood >= 40) and (petInfo.m_wPetMood < 60)):
        moodUiId = 2
    elif ((petInfo.m_wPetMood >= 10) and (petInfo.m_wPetMood < 40)):
        moodUiId = 1
    else:
        moodUiId = 0
    Win_SetImg((uiPetPan + '.petFace'), ('object/ui/pet/face%d.img' % moodUiId))
    Win_SetText((uiPetPan + '.nameEdit'), petInfo.m_szPetName)
    curPetName = petInfo.m_szPetName
    Win_SetText((uiPetPan + '.level'), ('%d \xbc\xb6' % petInfo.m_wPetLevel))
    petLevelRateInfo = GetPetLevelRateInfo(petInfo.m_dwPetExperience)
    Win_SetDrawTexRect((uiPetPan + '.expLine'), 0, 0, int((petLevelRateInfo.m_fRate * 94)), 12)
    Win_SetText((uiPetPan + '.expValue'), ('%d/%d' % (petInfo.m_dwPetExperience,
     petLevelRateInfo.m_unNextLevelExp)))
    Win_SetDrawTexRect((uiPetPan + '.loyaltyLine'), 0, 0, int(((petInfo.m_dwPetLoyalty / 1000.0) * 94)), 12)
    Win_SetText((uiPetPan + '.loyaltyValue'), ('%d/1000' % petInfo.m_dwPetLoyalty))
    curPetState = petInfo.m_wPetState
    if ((petInfo.m_wPetState == 1) and Win_EnableWidget((uiPetPan + '.petStateBtn'), 1)):
        Win_SetImg((uiPetPan + '.petStateBtn'), 'object/ui/pet/btn_stop_take.img')
    skillIdList = []
    baseSkillIdList = []
    for idx in range(petInfo.m_dwSkillCount):
        id = ord(petInfo.m_szSkills[idx])
        if (CHECK_BASESKILL(id) and baseSkillIdList.append(id)):
            pass

    baseSkillIdList.sort()
    skillIdList.sort()
    index = 0
    for skillId in baseSkillIdList:
        name = GetSkillNameById(skillId)
        Win_SetText((uiPetPan + ('.baseSkillDlg.skill%d' % index)), name)
        index += 1

    index = 0
    for skillId in skillIdList:
        name = GetSkillNameById(skillId)
        Win_SetText((uiPetPan + ('.skillDlg.skill%d' % index)), name)
        index += 1

    return True



def UpdatePetItemUi():
    global petItemList
    global petItemPos

    def PetItemSort(x, y):
        return (y.m_nItemID - x.m_nItemID)


    petItemList = GetAllMyPetItems()
    if petItemList.sort(PetItemSort):
        totalItem = len(petItemList)
        if (petItemPos >= totalItem):
            petItemPos -= defPetItemCnt
            if (petItemPos < 0):
                petItemPos = 0
        totalPage = 1
        curPage = 1
        if ((totalItem > 0) and ((totalItem % defPetItemCnt) == 0)):
            totalPage = (totalItem / defPetItemCnt)
        curPage = ((petItemPos / defPetItemCnt) + 1)
    Win_SetText((uiPetPan + '.foodDlg.petItemPage'), ('%d/%d' % (curPage,
     totalPage)))
    for i in range(defPetItemCnt):
        if (((petItemPos + i) >= totalItem) and Win_SetImg((uiPetPan + ('.foodDlg.petItem%d.itemPic' % i)), '')):
            Win_SetText((uiPetPan + ('.foodDlg.petItem%d.itemNum' % i)), '')




def ShowPetInfoDlg(petInfo):
    global skillIdList
    global baseSkillIdList

    def Clear():
        Win_SetImg((uiPetPan + '.petPreview'), '')
        Win_SetText((uiPetPan + '.petPreview'), '')
        Win_SetImg((uiPetPan + '.petFace'), '')
        Win_SetText((uiPetPan + '.nameEdit'), '')
        Win_SetText((uiPetPan + '.level'), '')
        Win_EnableWidget((uiPetPan + '.freePetBtn'), 0)
        Win_EnableWidget((uiPetPan + '.changeNameBtn'), 0)
        Win_EnableWidget((uiPetPan + '.adoptPetBtn'), 0)
        Win_EnableWidget((uiPetPan + '.petStateBtn'), 0)
        Win_EnableWidget((uiPetPan + '.nameEdit'), 0)
        Win_EnableWidget((uiPetPan + '.raisePetBtn'), 0)
        Win_ShowWidget((uiPetPan + '.foodDlg'), 0)
        Win_EnableWidget((uiPetPan + '.left'), 0)
        Win_EnableWidget((uiPetPan + '.right'), 0)
        for i in range(3):
            Win_SetText((uiPetPan + ('.baseSkillDlg.skill%d' % i)), '')

        for i in range(10):
            Win_SetText((uiPetPan + ('.skillDlg.skill%d' % i)), '')



    Clear()
    petResId = GetPetResId(petInfo.m_dwPetTypeId, petInfo.m_wPetLevel)
    Win_SetImg((uiPetPan + '.petPreview'), ('object/pet/pet%d_stand.img' % petResId))
    Win_SetText((uiPetPan + '.petPreview'), '')
    if (petInfo.m_wPetMood >= 90):
        moodUiId = 4
    elif ((petInfo.m_wPetMood >= 60) and (petInfo.m_wPetMood < 90)):
        moodUiId = 3
    elif ((petInfo.m_wPetMood >= 40) and (petInfo.m_wPetMood < 60)):
        moodUiId = 2
    elif ((petInfo.m_wPetMood >= 10) and (petInfo.m_wPetMood < 40)):
        moodUiId = 1
    else:
        moodUiId = 0
    Win_SetImg((uiPetPan + '.petFace'), ('object/ui/pet/face%d.img' % moodUiId))
    Win_SetText((uiPetPan + '.nameEdit'), petInfo.m_szPetName)
    curPetName = petInfo.m_szPetName
    Win_SetText((uiPetPan + '.level'), ('%d \xbc\xb6' % petInfo.m_wPetLevel))
    petLevelRateInfo = GetPetLevelRateInfo(petInfo.m_dwPetExperience)
    Win_SetDrawTexRect((uiPetPan + '.expLine'), 0, 0, int((petLevelRateInfo.m_fRate * 94)), 12)
    Win_SetText((uiPetPan + '.expValue'), ('%d/%d' % (petInfo.m_dwPetExperience,
     petLevelRateInfo.m_unNextLevelExp)))
    Win_SetDrawTexRect((uiPetPan + '.loyaltyLine'), 0, 0, int(((petInfo.m_dwPetLoyalty / 1000.0) * 94)), 12)
    Win_SetText((uiPetPan + '.loyaltyValue'), ('%d/1000' % petInfo.m_dwPetLoyalty))
    skillIdList = []
    baseSkillIdList = []
    for idx in range(petInfo.m_dwSkillCount):
        id = ord(petInfo.m_szSkills[idx])
        if (CHECK_BASESKILL(id) and baseSkillIdList.append(id)):
            pass

    baseSkillIdList.sort()
    skillIdList.sort()
    index = 0
    for skillId in baseSkillIdList:
        name = GetSkillNameById(skillId)
        Win_SetText((uiPetPan + ('.baseSkillDlg.skill%d' % index)), name)
        index += 1

    index = 0
    for skillId in skillIdList:
        name = GetSkillNameById(skillId)
        Win_SetText((uiPetPan + ('.skillDlg.skill%d' % index)), name)
        index += 1

    Win_ShowWidget((uiPetPan + '.baseSkillDlg'), 1)
    Win_ShowWidget((uiPetPan + '.skillDlg'), 1)
    Win_ShowWidget(uiPetPan, 1)
    ui_setCapture(uiPetPan)


class PawnTypeList:
    __module__ = __name__
    items = []

    def clear(this):
        global PawnTypeCnt
        PawnTypeList.items = []
        PawnTypeCnt = 0



    def update(this):
        global PawnTypeCnt
        PawnTypeList.items = GetPawnTypeList()
        PawnTypeCnt = len(PawnTypeList.items)
        return PawnTypeCnt



    def at(this, itemIdx):
        if (itemIdx >= len(PawnTypeList.items)):
            return None
        return PawnTypeList.items[itemIdx]



g_PawnTypeList = PawnTypeList()
class PawnItemList:
    __module__ = __name__
    items = []

    def clear(this):
        global PawnItemCnt
        PawnItemList.items = []
        PawnItemCnt = 0



    def update(this):
        global PawnItemCnt
        PawnItemList.items = GetPawnItemList((CurrenPawnType + 1))
        PawnItemCnt = len(PawnItemList.items)
        return PawnItemCnt



    def at(this, itemIdx):
        if (itemIdx >= len(PawnItemList.items)):
            return None
        return PawnItemList.items[itemIdx]



g_PawnItemList = PawnItemList()
class PawnGoodsList:
    __module__ = __name__
    items = []

    def clear(this):
        global PawnGoodsCnt
        PawnGoodsList.items = []
        PawnGoodsCnt = 0



    def update(this):
        global PawnGoodsCnt
        PawnGoodsList.items = GetPawnGoodsListbyID(CurrentPawnItemID)
        PawnGoodsCnt = len(PawnGoodsList.items)
        return PawnGoodsCnt



    def at(this, itemIdx):
        if (itemIdx >= len(PawnGoodsList.items)):
            return None
        return PawnGoodsList.items[itemIdx]



g_PawnGoodsList = PawnGoodsList()
class MyPawnItemList:
    __module__ = __name__
    items = []

    def clear(this):
        global MyPawnItemListCnt
        MyPawnItemList.items = []
        MyPawnItemListCnt = 0



    def update(this):
        global MyPawnItemListCnt
        MyPawnItemList.items = GetMyPawnItemList()
        MyPawnItemListCnt = len(MyPawnItemList.items)
        return MyPawnItemListCnt



    def at(this, itemIdx):
        if (itemIdx >= len(MyPawnItemList.items)):
            return None
        return MyPawnItemList.items[itemIdx]



g_MyPawnItemList = MyPawnItemList()

def ClearWareList():
    for i in range(defPawnwareCnt):
        ui = (uiPawnShopDlg + ('.ware%d' % (i + 1)))
        Win_EnableWidget(ui, 1)
        Win_SetText((ui + '.name'), '')
        Win_SetText((ui + '.price1'), '')
        Win_SetText((ui + '.price'), '')
        Win_SetImg((ui + '.picture'), '')
        Win_SetText((ui + '.ID'), '')
        Win_SetText((ui + '.saleIndex'), '')
        Win_SetImg((ui + '.memberPic'), '')
        Win_SetText((ui + '.Num'), '')
        Win_SetText((ui + '.dstUin'), '')
        Win_SetImg((ui + '.PetInfo'), '')
        Win_SetImg((ui + '.buyBtn'), '')
        Win_EnableWidget((ui + '.petInfo'), 0)
        Win_EnableWidget((ui + '.buyBtn'), 0)

    Win_SetText((uiPawnShopDlg + '.PawnGoodsPage'), '')



def ui_updatePawnTypeList():
    global PawnTypeCnt
    global CurrenPawnType
    print 'ui_updatePawnTypeList begin'
    CurrenPawnType = -1
    PawnTypeCnt = 0
    g_PawnItemList.clear()
    g_PawnTypeList.clear()
    g_PawnTypeList.update()
    print ('[ui_updatePawnTypeList]PawnTypeCnt=%d' % PawnTypeCnt)
    Win_SetText((uiPawnShopDlg + '.SearchPropName'), '')
    Win_SetText((uiPawnShopDlg + '.Rank'), '')
    Win_ShowWidget((uiPawnShopDlg + '.CommitPanel'), 0)
    ClearWareList()
    print ('PawnTypeCnt = %d' % PawnTypeCnt)
    Win_SetPos((uiPawnShopDlg + '.itemScroll'), 0)
    doUI((uiPawnShopDlg + '.itemScroll'), 'OnPosChange')



def ui_updatePawnGoodsList(CurrentPos, TotalCount):
    global totalPawnGoodsCnt
    global PawnGoodsPos
    global bPawnShopShow
    PawnItemCnt = 0
    bPawnShopShow = 1
    totalPawnGoodsCnt = TotalCount
    PawnGoodsPos = CurrentPos
    g_PawnGoodsList.clear()
    g_PawnGoodsList.update()
    print ('PawnGoodsCnt = %d' % PawnGoodsCnt)
    Win_SetPos((uiPawnShopDlg + '.wareScroll'), 0)
    doUI((uiPawnShopDlg + '.wareScroll'), 'OnPosChange')
    ui_UpdatePawnGoods()



def ui_ShowMyPawnedInWare(currentPos):
    global PawnGoodsCnt
    global totalPawnGoodsCnt
    global MyPawnItemListCnt
    global PawnGoodsPos
    global bPawnShopShow
    bPawnShopShow = 1
    g_MyPawnItemList.clear()
    PawnGoodsPos = currentPos
    MyPawnItemListCnt = g_MyPawnItemList.update()
    totalPawnGoodsCnt = MyPawnItemListCnt
    if (MyPawnItemListCnt > defPawnGoodsCnt):
        PawnGoodsCnt = defPawnGoodsCnt
    else:
        PawnGoodsCnt = MyPawnItemListCnt
    print ('[ui_ShowMyPawnedInWare]totalPawnGoodsCnt = %d,PawnGoodsCnt = %d' % (totalPawnGoodsCnt,
     PawnGoodsCnt))
    print ('[ui_ShowMyPawnedInWare] PawnGoodsPos= %d' % PawnGoodsPos)
    Win_SetPos((uiPawnShopDlg + '.wareScroll'), 0)
    doUI((uiPawnShopDlg + '.wareScroll'), 'OnPosChange')
    ui_UpdatePawnGoods()



def ui_updateMyPawnedInWare(currentPos):
    if (Win_IsChecked((uiPawnShopDlg + '.pawnedBtn')) and ClearWareList()):
        ui_ShowMyPawnedInWare(currentPos)



def ui_UpdatePawnGoods():
    print ('[ui_UpdatePawnGoods]totalPawnGoodsCnt = %d,PawnGoodsCnt = %d' % (totalPawnGoodsCnt,
     PawnGoodsCnt))
    if ((totalPawnGoodsCnt == 0) and Win_SetText((uiPawnShopDlg + '.PawnGoodsPage'), '1/1')):
        pass
    for i in range(defPawnGoodsCnt):
        ui = (uiPawnShopDlg + ('.ware%d' % (i + 1)))
        idx = (i + PawnGoodsPos)
        if (idx >= totalPawnGoodsCnt):
            continue




def updateMyStorageInPawn():
    g_MyDealStorageList.clear()
    g_MyDealStorageList.update()
    print ('[updateMyStorageInPawn] MyDealStorageListCnt = %d' % MyDealStorageListCnt)
    Win_SetPos((uiPawnShopDlg + '.CommitPanel.StorageScroll'), 0)
    doUI((uiPawnShopDlg + '.CommitPanel.StorageScroll'), 'OnPosChange')
    residualTicket = GetMyBill()
    print residualTicket
    Win_SetText((uiPawnShopDlg + '.residualBill'), ('%12f' % residualTicket))



def ui_updateCommitBox():
    g_MyPawnItemList.clear()
    g_MyPawnItemList.update()
    for i in range(defCommittedCnt):
        ui = (uiPawnShopDlg + ('.CommitPanel.CommittedItem%d' % i))
        Win_SetText((ui + '.PropName'), '')
        Win_SetText((ui + '.PropNum'), '')
        Win_SetText((ui + '.interval'), '')
        Win_SetText((ui + '.price'), '')
        Win_ShowWidget(ui, 0)

    Win_SetPos((uiPawnShopDlg + '.CommitPanel.CommittedScroll'), 0)
    doUI((uiPawnShopDlg + '.CommitPanel.CommittedScroll'), 'OnPosChange')



def updateCurrentPropID(PropID):
    global CurrentPawnItemID
    CurrentPawnItemID = PropID



def Responsepawnpetinfo():
    global petbaseInfo
    petbaseInfo = GetPawnPetInfo()
    if ((petbaseInfo.m_dwPetTypeId > 0) and ShowPetInfoDlg(petbaseInfo)):
        pass



def ui_SetGameType(gameType):
    global GameType
    global OldGameType
    SetGameType(gameType)
    OldGameType = GameType
    GameType = gameType



def NewPlayerPractice():
    ui = 'UI.selRoom.practiceBtn'
    doUI(ui, 'OnClick')
    Win_ShowWidget('UI.newPlayerDirectionDlg', 1)


class UI_children_selRoom:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)
    bkimage = 'object/ui/bg/bg_selRoom.img'
    accel = (('OnAccel_OnF1',
      112,
      0,
      0,
      0),
     ('OnAccel_OnF2',
      113,
      0,
      0,
      0),
     ('OnAccel_OnF4',
      115,
      0,
      0,
      0),
     ('OnAccel_OnF7',
      118,
      0,
      0,
      0))

    def OnAccel_OnF1():
        ui_jumpHelpWeb()
        PlaySound(soundMain, 1)



    def OnAccel_OnF2():
        if ((isAllowFx_selRoom() and (not Win_IsVisible(uiTaskSelDlg))) and doUI('UI.selRoom.fastJoinRoomBtn', 'OnClick')):
            pass



    def OnAccel_OnF4():
        if (isAllowFx_selRoom() and doUI('UI.selRoom.shopBtn', 'OnClick')):
            pass



    def OnAccel_OnF7():
        if ((isAllowFx_selRoom() and (not Win_IsVisible(uiTaskSelDlg))) and doUI('UI.selRoom.newRoomBtn', 'OnClick')):
            pass



    def OnEnter():
        if (Win_IsVisible('UI.selRoom.pwRoom') and doUI('UI.selRoom.pwRoom.confirm', 'OnClick')):
            return 
        doUI('UI.selRoom.chatArea.sendBtn', 'OnClick')



    def OnEscape():
        if Win_IsVisible('UI.selRoom.pwRoom'):
            return 
        doUI('UI.selRoom.leaveBtn', 'OnClick')



    def OnInit():
        global isQQMember
        global localShopVersion
        global ChatAreaTab
        global playerPos
        global playerMode2
        global playerMode
        global markEnterShop
        global practiceMode
        global playerPos2
        global firstEnter
        global lastestShopVersion
        global isLeague
        global bPawnShopShow
        global isShowTaskSelDlg
        Win_ShowWidget(uiMarriageConfirmDlg, 0)
        bPawnShopShow = 0
        if markEnterShop:
            markEnterShop = False
            SC_ClickShopBtn()
            go2shop()
            return 
        if ((GameType == ChatType) and Win_ShowWidget('UI.selRoom.mapFilterMask', 1)):
            pass
        Win_ShowWidget(uiGuideBar, 1)
        Win_EnableWidget(uiGuideBar, 1)
        Win_ShowWidget(uiSocialityDlg, 0)
        sc_HideWeb('kinMatch')
        sc_HideWeb('kinTeam')
        Win_ShowWidget(uiMenuDlg, 0)
        initAllUse()
        Win_ShowWidget('UI.selRoom.chatArea.speakerTip', 0)
        if firstEnter:
            localShopVersion = GetLocalShopVertion(uin)
            lastestShopVersion = GetLastShopVertion()
        if ((localShopVersion < lastestShopVersion) and Win_ShowWidget('UI.selRoom.tipShop', 1)):
            pass
        identity = fetch_PlayerIdentityByUin(uin)
        isLeague = (identity & 8192)
        isQQMember = (identity & 32)
        ChatAreaTab = 0
        setupValidGameMode()
        if firstEnter:
            firstEnter = 0
            KeyLayout().restore()
        PlayMusic(musicDirAndSection, -1)
        if (isMemberFace and setFacePage(0, memberFacePageNum)):
            pass
        playerMode = 0
        playerPos = 0
        updatePlayer()
        flexChatArea(flexMode)
        playerMode2 = 0
        Win_SelectSelf('UI.selRoom.playerTab')
        playerPos2 = 0
        updatePlayer2()
        InitGameType()
        updateRoom()
        Win_SetCheck('UI.selRoom.roomState', True)
        Win_SetText('UI.selRoom.name', Sect().getName())
        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
        Win_SetImg('UI.selRoom.mapFilterBtn.icon', ('map/icon/%s.img' % gameModeList[1][1]))
        Win_SetText('UI.selRoom.mapFilterBtn.text', gameModeList[1][2])
        InitSpeaker()
        InitChatArea()
        InitChatMode()
        if ((GetLeaveWordCount() > 0) and startGlint()):
            pass
        screenStartIn()
        if (practiceMode and Win_ShowWidget(uiTaskSelDlg, 1)):
            ui_setCapture(uiTaskSelDlg)
            practiceMode = 0
        if ((chinatelecom == 1) and Win_SetCheck((uitopKinDlg + '.unicomBtn'), 0)):
            Win_SetCheck((uitopKinDlg + '.telecomBtn'), 1)
        if ((setreputation == 1) and Win_ShowWidget((uitopKinDlg + '.activity'), 0)):
            Win_SetCheck((uitopKinDlg + '.honorBtn'), 1)
            Win_SetCheck((uitopKinDlg + '.activityBtn'), 0)
        if ((chIdx == 1) and (isShowTaskSelDlg == 0)):
            isShowTaskSelDlg = 1
            ui_setCapture(uiTaskSelDlg)
            PlaySound(soundMain, 1)
        SC_SetBeGuide(Sect().meGetPoint(), 0)



    def OnDenit():
        Win_ShowWidget(uiC2CInviteDlg, False)
        Win_Timer('UI.selRoom.chatArea.speakerTip', 0)
        Win_ShowWidget('UI.selRoom.chatArea.speakerTip', False)
        doUI((uiPawnShopDlg + '.crossBtn'), 'OnClick')
        Win_ShowWidget('UI.selRoom.practiceBtn', 1)
        Win_ShowWidget('UI.selRoom.fastJoinRoomBtn', 1)
        Win_ShowWidget('UI.selRoom.newRoomBtn', 1)


    class children:
        __module__ = __name__
        class name(TLabel,
         Static):
            __module__ = __name__
            rect = (36,
             562,
             200,
             12)
            drawcolor = lightColor
            textEdgeColor = (66,
             95,
             133,
             255)
            textEdgeType = 1

        class modeCompete(TTabWin):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)
            hotrect = (20,
             39,
             98,
             30)
            groupid = 1
            groupstop = 0
            hotcover = 'object/ui/selRoom/tab_compete.img'

            def OnClick(this):
                Win_ShowWidget('UI.selRoom.mapFilterMask', 0)
                Win_ShowWidget((this + '.modeNoItem'), 1)
                Win_ShowWidget((this + '.modeItem'), 1)
                Win_ShowWidget('UI.selRoom.mapFilterBtn', 1)
                Win_SelectSelf('UI.selRoom.modeCompete.modeNoItem')
                doUI('UI.selRoom.modeCompete.modeNoItem', 'OnClick')


            class children:
                __module__ = __name__
                class modeNoItem(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (30,
                     70,
                     57,
                     25)
                    hotcover = 'object/ui/selRoom/tab_noItem.img'
                    groupid = 2
                    groupstop = 0

                    def OnClick(this):
                        ui_SetGameType(CommonType)
                        NotifyRoom(CommonType)



                class modeItem(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (94,
                     70,
                     57,
                     25)
                    hotcover = 'object/ui/selRoom/tab_item.img'
                    groupid = 2
                    groupstop = 1

                    def OnClick(this):
                        ui_SetGameType(PVPType)
                        NotifyRoom(PVPType)



                class modeHonor(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (158,
                     70,
                     57,
                     25)
                    hotcover = 'object/ui/selRoom/tab_honor.img'
                    groupid = 2
                    groupstop = 2

                    def OnClick(this):
                        ui_SetGameType(LootType)
                        NotifyRoom(LootType)





        class modeExplore(TTabWin):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)
            hotrect = (122,
             39,
             98,
             30)
            groupid = 1
            groupstop = 1
            hotcover = 'object/ui/selRoom/tab_explore.img'

            def OnClick(this):
                Win_ShowWidget('UI.selRoom.mapFilterMask', 0)
                Win_ShowWidget('UI.selRoom.modeCompete.modeNoItem', 0)
                Win_ShowWidget('UI.selRoom.modeCompete.modeItem', 0)
                Win_ShowWidget('UI.selRoom.mapFilterBtn', 1)
                ui_SetGameType(PVEType)
                print ('behind %d,%d' % (OldGameType,
                 GameType))
                updateRoom()



        class modeChat(TTabWin):
            __module__ = __name__
            rect = (0,
             0,
             1,
             1)
            hotrect = (224,
             39,
             98,
             30)
            groupid = 1
            groupstop = 2
            hotcover = 'object/ui/selRoom/tab_chat.img'

            def OnClick(this):
                Win_ShowWidget('UI.selRoom.modeCompete.modeNoItem', 0)
                Win_ShowWidget('UI.selRoom.modeCompete.modeItem', 0)
                Win_ShowWidget('UI.selRoom.mapFilterMask', 1)
                Win_ShowWidget('UI.selRoom.mapFliterBtn', 0)
                ui_SetGameType(ChatType)
                NotifyRoom(ChatType)



        class room1(TButton):
            __module__ = __name__
            framescheme = [(1,
              1,
              1,
              1,
              2,
              2,
              0,
              0)]
            rect = (27,
             101,
             181,
             111)
            bkimage = 'object/ui/selRoom/dlg_room.img'

            def OnClick(this):
                global roomID
                me = Win_GetFocusPath()
                print '<enter room>',
                print me,
                roomID = int(Win_GetValue((me + '.logicID')))
                print '<room>=',
                print roomID
                if (not Win_IsVisible((me + '.password'))):
                    print 'EnterRoom(',
                    print roomID,
                    print ''
                    EnterRoom(roomID, '')
                    PlaySound(soundMain, 1)
                else:
                    ui_setCapture('UI.selRoom.pwRoom')
                    Win_SetText('UI.selRoom.pwRoom.pw', '')
                    Win_SetFocus('UI.selRoom.pwRoom.pw')
                    PlaySound(soundUI, 1)



            def OnDBClick():
                me = Win_GetMyPath()
                doUI(me, 'OnClick')


            class children:
                __module__ = __name__
                class no(TPicLabel,
                 Static):
                    __module__ = __name__
                    rect = (15,
                     13,
                     (48 - 18),
                     12)
                    textsize = 10
                    bkimage = 'object/ui/selRoom/num.img'

                class logicID(TEditNum,
                 Static):
                    __module__ = __name__
                    visible = 0
                    rect = (0,
                     0,
                     0,
                     0)
                    value = 10

                class name(TLabel,
                 Static):
                    __module__ = __name__
                    drawcolor = maskColor
                    textEdgeType = -1
                    textEdgeColor = (0,
                     0,
                     0,
                     255)
                    rect = (58,
                     15,
                     (154 - 61),
                     12)

                class standard(TStatic):
                    __module__ = __name__
                    rect = (146,
                     (40 - 3),
                     28,
                     27)

                class password(TStatic):
                    __module__ = __name__
                    rect = (151,
                     10,
                     19,
                     20)
                    bkimage = 'res/uires/selRoom/icon/fangjiananniu_suo.img'

                class time(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (88,
                     62,
                     34,
                     30)
                    bkimage = 'res/uires/selRoom/fangjian_time.img'

                class playerNum(TPicLabel,
                 Static):
                    __module__ = __name__
                    bkimage = 'res/uires/selRoom/room/num_player.img'
                    textsize = 10
                    rect = (60,
                     70,
                     (15 * 4),
                     19)

                class mapIcon(TStatic):
                    __module__ = __name__
                    rect = (8,
                     40,
                     78,
                     20)
                    bkimage = 'map/icon/water.img'

                class mapName(TLabel,
                 Static):
                    __module__ = __name__
                    drawcolor = (255,
                     224,
                     82,
                     255)
                    textEdgeColor = (0,
                     49,
                     174,
                     255)
                    rect = (60,
                     44,
                     150,
                     12)

                class vip(TStatic):
                    __module__ = __name__
                    rect = (102,
                     70,
                     62,
                     20)
                    bkimage = 'object/ui/selRoom/icon_vip.img'



        class room2(room1):
            __module__ = __name__
            rect = (223,
             101,
             181,
             111)

        class room3(room1):
            __module__ = __name__
            rect = (27,
             213,
             181,
             111)

        class room4(room1):
            __module__ = __name__
            rect = (223,
             213,
             181,
             111)

        class room5(room1):
            __module__ = __name__
            rect = (27,
             325,
             181,
             111)

        class room6(room1):
            __module__ = __name__
            rect = (223,
             325,
             181,
             111)

        class room7(room1):
            __module__ = __name__
            rect = (27,
             437,
             181,
             111)

        class room8(room1):
            __module__ = __name__
            rect = (223,
             437,
             181,
             111)

        class roomLeft(TButton):
            __module__ = __name__
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            initlayer = -9999
            rect = (332,
             550,
             33,
             35)
            bkimage = 'object/ui/common/btn_left.img'

            def OnClick(this):
                global roomPagePos
                SectUserClickBtn(1)
                PlaySound(soundUI, 1)
                if (roomPagePos > 0):
                    roomPagePos -= 1



        class roomRight(TButton):
            __module__ = __name__
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            initlayer = -9999
            rect = (367,
             550,
             33,
             35)
            bkimage = 'object/ui/common/btn_right.img'

            def OnClick(this):
                global roomPagePos
                SectUserClickBtn(2)
                PlaySound(soundUI, 1)
                roomPagePos += 1



        class mapFilterBtn(TButton):
            __module__ = __name__
            initlayer = 90001
            rect = (279,
             71,
             114,
             18)

            def OnClick(this):
                ui_setCapture('UI.selRoom.mapFilterDlg')
                do(UI.children.selRoom.children.mapFilterDlg.children.scroll, 'OnPosChange')
                PlaySound(soundUI, 1)


            class children:
                __module__ = __name__
                class icon(TStatic):
                    __module__ = __name__
                    rect = (10,
                     0,
                     16,
                     18)
                    bkimage = ('map/icon/%s.img' % gameModeList[1][1])

                class text(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (36,
                     3,
                     60,
                     12)
                    caption = gameModeList[1][2]
                    drawcolor = (255,
                     255,
                     255,
                     255)

                class downArrow(TButton):
                    __module__ = __name__
                    rect = (94,
                     0,
                     18,
                     18)
                    bkimage = 'object/ui/selRoom/btn_mapFilter.img'

                    def OnClick(this):
                        doUI('UI.selRoom.mapFilterBtn', 'OnClick')





        class mapFilterMask(TStatic):
            __module__ = __name__
            initlayer = 99999
            rect = (278,
             71,
             115,
             18)
            bkimage = 'object/ui/chatRoom/dlg_mapFilterMask.img'

        class practiceBtn(TButton):
            __module__ = __name__
            rect = (505,
             538,
             51,
             54)
            bkimage = 'object/ui/selSect/btn_practice.img'

            def OnClick(this):
                if (not Win_IsVisible(this)):
                    return 
                CloseC2CDealDlg(bC2CDealShow)
                ui_setCapture(uiTaskSelDlg)
                PlaySound(soundMain, 1)



        class fastJoinRoomBtn(TButton):
            __module__ = __name__
            rect = (560,
             538,
             51,
             54)
            bkimage = 'object/ui/selSect/btn_quickJoin.img'

            def OnClick(this):
                if (not Win_IsVisible(this)):
                    return 
                CloseC2CDealDlg(bC2CDealShow)
                SetGameType(GameType)
                SC_ClickAutoEnterRoomBtn()
                AutoJoinRoom()
                PlaySound(soundMain, 1)
                screenStartOut()



        class newRoomBtn(TButton):
            __module__ = __name__
            rect = (615,
             538,
             51,
             54)
            bkimage = 'object/ui/selRoom/btn_createRoom.img'

            def OnClick(this):
                if (not Win_IsVisible(this)):
                    return 
                CloseC2CDealDlg(bC2CDealShow)
                SC_ClickCreateRoomBtn()
                PlaySound(soundUI, 1)
                CreateRoom('', 2, 1, '')
                return 



        class matchBtn(TButton):
            __module__ = __name__
            rect = (670,
             538,
             51,
             54)
            bkimage = 'object/ui/selRoom/btn_match.img'

            def OnClick(this):
                global bMatchChannel
                if (not Win_IsVisible(this)):
                    return 
                bMatchChannel = 1
                doUI('UI.selRoom.leaveBtn', 'OnClick')



        class shopBtn(TButton):
            __module__ = __name__
            rect = (435,
             536,
             65,
             58)
            bkimage = 'object/ui/selRoom/btn_shop.img'

            def OnClick(this):
                CloseC2CDealDlg(bC2CDealShow)
                SC_ClickShopBtn()
                go2shop()



        class tipGuide(TStatic):
            __module__ = __name__
            visible = 1
            initlayer = 999999
            bkimage = 'object/ui/selRoom/tip_GuideMid.img'
            rect = (430,
             496,
             1,
             1)

            def OnTimer(this):
                print 'tipGuide: ontimer()'
                Win_SetValue(this, 0.050000000000000003, 41)
                Win_SetValue(this, 2, 901)
                Win_Timer(this, 0)


            class children:
                __module__ = __name__
                class word(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (20,
                     13,
                     150,
                     50)
                    rowspace = 5
                    drawcolor = (69,
                     69,
                     69,
                     255)
                    textEdgeType = -1



        class tipEnterShop(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            bkimage = 'object/ui/selRoom/tip_enterShop.img'
            rect = (430,
             496,
             1,
             1)

            def OnTimer(this):
                Win_ShowWidget(this, (not Win_IsVisible(this)))



        class leaveBtn(TButton):
            __module__ = __name__
            rect = (735,
             542,
             52,
             48)
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            bkimage = 'object/ui/common/btn_leave.img'

            def OnClick(this):
                global bmsg
                CloseC2CDealDlg(bC2CDealShow)
                UnInitialDealer()
                SC_ClickExitBtnInSection()
                UnInitializeShop()
                LogoutSection(uin)
                GotoUIScreen('selSect')
                PlaySound(soundLeave, 1)
                PlayMusic(musicDirAndSection, -1)
                bmsg = ([0] * msgcnt)



        class tipShop(TTip):
            __module__ = __name__
            visible = 0
            rect = (520,
             578,
             500,
             500)
            bkimage = 'object/ui/common/tip_new.img'

        class playerTab(TTabWin):
            __module__ = __name__
            groupid = 3
            groupstop = 1
            rect = (-2,
             0,
             1,
             1)
            hotrect = (432,
             67,
             76,
             19)
            hotcover = 'object/ui/selRoom/tab_player.img'

            def OnClick(this):
                global playerMode2
                PlaySound(soundUI, 1)
                playerMode2 = 0
                updatePlayer2()



        class friendTab(TTabWin):
            __module__ = __name__
            groupid = 3
            groupstop = 2
            rect = (-2,
             0,
             1,
             1)
            hotrect = (509,
             67,
             76,
             19)
            hotcover = 'object/ui/selRoom/tab_friend.img'

            def OnClick(this):
                global playerMode2
                playerMode2 = 1
                DoFriendTask('', 0, friendUin, 0)
                updatePlayer2()
                PlaySound(soundUI, 1)



        class allKinMemberTab(TTabWin):
            __module__ = __name__
            groupid = 3
            groupstop = 3
            rect = (-2,
             0,
             1,
             1)
            hotrect = (587,
             66,
             76,
             19)
            hotcover = 'object/ui/selRoom/tab_allKinMember.img'

            def OnClick(this):
                global playerMode2
                KinID = GetKinParam(0)
                if ((KinID == 0) and Win_SelectSelf('UI.selRoom.playerTab')):
                    ui_setCapture(uiKinCreateHintDlg)
                    playerMode2 = 0
                    updatePlayer2()
                PlaySound(soundUI, 1)



        class playerListDlg(TStatic):
            __module__ = __name__
            initlayer = 10000
            rect = (450,
             97,
             330,
             260)
            class children:
                __module__ = __name__
                class friendMask(TStatic):
                    __module__ = __name__
                    initlayer = 50000
                    rect = (0,
                     0,
                     1,
                     1)
                    bkimage = 'object/ui/guideBar/img_friendMask.img'
                    class children:
                        __module__ = __name__
                        class tipBtn(TButton):
                            __module__ = __name__
                            initlayer = 20000
                            rect = (0,
                             0,
                             1,
                             1)

                            def OnClick(this):
                                if ((playerMode2 == 1) and InvalidOperation()):
                                    pass





                class playerInfo1(TButton):
                    __module__ = __name__
                    initlayer = 20000
                    rect = (0,
                     0,
                     321,
                     23)
                    bkimage = 'object/ui/guideBar/btn_player.img'
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    bkImgFlag = dt_center

                    def OnClick(this):
                        i = getMyIdx2()
                        print 'FindFriend  ',
                        print uins2[(i - 1)],
                        print '...',
                        print i
                        go2playerInfo(uins2[(i - 1)])
                        if ((false == Win_IsChecked('UI.selRoom.friendTab')) and SetPlayerModeInfo(uins2[(i - 1)], 0)):
                            pass



                    def OnRBtnUp(pos):
                        global friendName
                        global friendUin
                        (x, y,) = pos
                        if ((x + 77) > 800):
                            x = (800 - 77)
                        Win_Move2Pos(uiPlayerMenu, x, y)
                        i = getMyIdx2()
                        friendUin = uins2[(i - 1)]
                        friendName = Win_GetText((Win_GetMyPath() + '.name'))
                        kinID = GetKinParam(0)
                        if ((kinID > 0) and Win_ShowWidget((uiPlayerMenu + '.kininviteBtn'), kinID)):
                            pass
                        Win_ShowWidget((uiPlayerMenu + '.addBtn'), (not GetAttribute(friendUin, 0)))
                        Win_ShowWidget((uiPlayerMenu + '.deleteBtn'), GetAttribute(friendUin, 0))
                        Win_ShowWidget((uiPlayerMenu + '.shieldBtn'), (not GetAttribute(friendUin, 1)))
                        Win_ShowWidget((uiPlayerMenu + '.unshieldBtn'), GetAttribute(friendUin, 1))
                        Win_ShowWidget(uiPlayerMenu, 1)



                    def OnMouseMoveIn():
                        idx = getMyIdx2()
                        if ((idx > 1) and Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % (idx - 1))), 20000.0, 902)):
                            pass
                        if ((idx < 16) and Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % (idx + 1))), 20000.0, 902)):
                            pass
                        Win_SetValue((uiPlayerListDlg + ('.playerInfo%d' % idx)), 35000.0, 902)


                    class children:
                        __module__ = __name__
                        class gender(TStatic):
                            __module__ = __name__
                            rect = (292,
                             3,
                             16,
                             15)
                            bkimage = 'res/uires/selRoom/icon/nan.img'

                        class levelIcon(TLevelIcon):
                            __module__ = __name__
                            rect = (30,
                             1,
                             39,
                             15)

                        class goldDiamond(TStatic):
                            __module__ = __name__
                            visible = 0
                            rect = (53,
                             4,
                             20,
                             19)
                            framescheme = [(0,
                              15,
                              0,
                              15,
                              0,
                              15,
                              0,
                              15)]
                            bkimage = 'res/uires/selRoom/goldDiamond.img'

                        class kintotem(TStatic):
                            __module__ = __name__
                            visible = 0
                            rect = (8,
                             2,
                             16,
                             15)
                            framescheme = [(0,
                              13,
                              0,
                              13,
                              0,
                              13,
                              0,
                              13)]

                        class league(TStatic):
                            __module__ = __name__
                            visible = 0
                            rect = (92,
                             4,
                             16,
                             15)
                            framescheme = [(0,
                              13,
                              0,
                              13,
                              0,
                              13,
                              0,
                              13)]
                            bkimage = 'res/uires/selRoom/diamond_bk.img'

                        class name(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (168,
                             6,
                             120,
                             12)
                            drawcolor = lightColor
                            textEdgeType = 1
                            textEdgeColor = maskColor
                            textstyle = dt_right

                        class namecard(TStatic):
                            __module__ = __name__
                            framescheme = [(0,
                              99,
                              0,
                              99,
                              0,
                              99,
                              0,
                              99)]
                            initlayer = -100
                            rect = (7,
                             1,
                             1,
                             1)

                        class namecardbound(TStatic):
                            __module__ = __name__
                            framescheme = [(0,
                              99,
                              0,
                              99,
                              0,
                              99,
                              0,
                              99)]
                            rect = (7,
                             1,
                             1,
                             1)



                class playerInfo2(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + 24),
                     321,
                     23)

                class playerInfo3(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 2)),
                     321,
                     23)

                class playerInfo4(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 3)),
                     321,
                     23)

                class playerInfo5(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 4)),
                     321,
                     23)

                class playerInfo6(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 5)),
                     321,
                     23)

                class playerInfo7(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 6)),
                     321,
                     23)

                class playerInfo8(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 7)),
                     321,
                     23)

                class playerInfo9(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 8)),
                     321,
                     23)

                class playerInfo10(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 9)),
                     321,
                     23)

                class playerInfo11(playerInfo1):
                    __module__ = __name__
                    rect = (0,
                     (0 + (24 * 10)),
                     321,
                     23)

                class left(TButton):
                    __module__ = __name__
                    rect = (-19,
                     4,
                     16,
                     57)
                    bkimage = 'object/ui/selRoom/btn_left.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        pos = myGetPlayerPos2()
                        if ((pos != 0) and PlaySound(soundUI, 1)):
                            pos = max((pos - defPlayerCnt2), 0)
                            mySetPlayerPos2(pos)
                            updatePlayer2()



                class right(TButton):
                    __module__ = __name__
                    rect = (334,
                     4,
                     16,
                     57)
                    bkimage = 'object/ui/selRoom/btn_right.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        PlayerList_right()
                        pos = myGetPlayerPos2()
                        cnt = myGetPlayerCnt2()
                        if (((pos + defPlayerCnt2) < cnt) and PlaySound(soundUI, 1)):
                            pos += defPlayerCnt2
                            mySetPlayerPos2(pos)
                            updatePlayer2()





        class chatArea(TPoser):
            __module__ = __name__
            initlayer = 100000
            rect = (0,
             0,
             350,
             455)
            class children:
                __module__ = __name__
                class chatPanel(TStatic):
                    __module__ = __name__
                    initlayer = 500000
                    rect = (442,
                     354,
                     320,
                     116)
                    bkimage = 'object/ui/selRoom/dlg_chatMin.img'
                    class children:
                        __module__ = __name__
                        class flexUpBtn(TButton):
                            __module__ = __name__
                            rect = (173,
                             2,
                             40,
                             13)
                            bkimage = 'object/ui/selRoom/btn_flexUp.img'

                            def OnClick(this):
                                global flexMode
                                flexMode = min(3, (flexMode + 1))
                                flexChatArea(flexMode)



                        class flexDownBtn(TButton):
                            __module__ = __name__
                            rect = (132,
                             2,
                             40,
                             13)
                            bkimage = 'object/ui/selRoom/btn_flexDown.img'

                            def OnClick(this):
                                global flexMode
                                flexMode = max(1, (flexMode - 1))
                                flexChatArea(flexMode)



                        class speaker0(TLabel):
                            __module__ = __name__
                            initlayer = 100000
                            rect = (-4,
                             17,
                             350,
                             17)
                            bkimage = 'object/ui/selRoom/mask_speaker.img'

                            def OnDisappear():
                                me = Win_GetMyPath()
                                Win_ShowWidget(me, 0)


                            class children:
                                __module__ = __name__
                                class popo(TStatic):
                                    __module__ = __name__
                                    rect = (0,
                                     0,
                                     350,
                                     17)
                                    alphafactor = 0.59999999999999998
                                    minalphafactor = 0.59999999999999998
                                    bkimage = 'object/ui/selRoom/img_popo.img'

                                class words:
                                    __module__ = __name__
                                    type = 'MULTIEDIT'
                                    rowspace = 0
                                    editable = 0
                                    textEdgeType = -1
                                    drawcolor = broadcastColor
                                    rect = (0,
                                     0,
                                     350,
                                     12)
                                    captionrect = (12,
                                     3,
                                     336,
                                     12)
                                    maxline = 1

                                class nameBtn(TButton):
                                    __module__ = __name__
                                    initlayer = 200000
                                    rect = (0,
                                     0,
                                     310,
                                     18)
                                    textEdgeType = -1
                                    captionrect = (4,
                                     2,
                                     120,
                                     12)
                                    drawcolor = broadcastColor

                                    def OnClick(this):
                                        idx = getTailNum(this[:-len('.nameBtn')])
                                        name = namebuf[idx]
                                        uin = uinbuf[idx]
                                        NotifyWisper(name, uin)
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                                    def OnDBClick():
                                        me = Win_GetMyPath()
                                        idx = getTailNum(me[:-len('.nameBtn')])
                                        uin = uinbuf[idx]
                                        Win_FocusOnInsert('UI.selRoom.chatArea.chatEdit', str(uin))
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                                    def OnRClick():
                                        me = Win_GetMyPath()
                                        winrect = Win_GetRect(me, 906)
                                        idx = getTailNum(me[:-len('.nameBtn')])
                                        y = winrect[1]
                                        if (y > 400):
                                            y = 400
                                        Win_Move2Pos(uiPlayerMenu, (winrect[0] + 30), y)
                                        friendUin = uinbuf[idx]
                                        friendName = namebuf[idx]
                                        kinID = GetKinParam(0)
                                        if ((kinID > 0) and Win_ShowWidget((uiPlayerMenu + '.kininviteBtn'), kinID)):
                                            pass
                                        Win_ShowWidget((uiPlayerMenu + '.addBtn'), (not GetAttribute(friendUin, 0)))
                                        Win_ShowWidget((uiPlayerMenu + '.deleteBtn'), GetAttribute(friendUin, 0))
                                        Win_ShowWidget((uiPlayerMenu + '.shieldBtn'), (not GetAttribute(friendUin, 1)))
                                        Win_ShowWidget((uiPlayerMenu + '.unshieldBtn'), GetAttribute(friendUin, 1))
                                        Win_ShowWidget(uiPlayerMenu, 1)





                        class speaker1(speaker0):
                            __module__ = __name__
                            rect = (-4,
                             34,
                             350,
                             17)

                        class speaker2(speaker0):
                            __module__ = __name__
                            rect = (-4,
                             51,
                             350,
                             17)

                        class chatList:
                            __module__ = __name__
                            type = 'TEXTLIST'
                            rect = (3,
                             20,
                             320,
                             98)
                            captionrect = (0,
                             0,
                             320,
                             98)
                            drawcolor = (199,
                             242,
                             252,
                             255)
                            rowspace = 6
                            textfont = 1
                            textEdgeType = -1
                            scrollspace = 18

                            def OnClick(this):
                                if ((not Win_IsVisible(uiPlayerInfoDlg)) and Win_SetFocus('UI.selRoom.chatArea.chatEdit')):
                                    pass



                            def OnClickName(name, uin):
                                print 'OnClickName',
                                print name,
                                print uin
                                NotifyWisper(name, uin)
                                Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                            def OnClickHLink(url):
                                ui_jumpWeb(url)



                            def OnDBClick(me):
                                print me
                                uin = Win_GetText(me)
                                Win_FocusOnInsert('UI.selRoom.chatArea.chatEdit', uin)
                                Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                            def OnRClickName(name, uin):
                                global friendName
                                global friendUin
                                print '[OnRClick]'
                                me = Win_GetMyPath()
                                winrect = Win_GetRect(me, 906)
                                y = winrect[1]
                                if (y > 400):
                                    y = 400
                                Win_Move2Pos(uiPlayerMenu, (winrect[0] + 30), y)
                                friendUin = uin
                                friendName = name
                                kinID = GetKinParam(0)
                                if ((kinID > 0) and Win_ShowWidget((uiPlayerMenu + '.kininviteBtn'), kinID)):
                                    pass
                                Win_ShowWidget((uiPlayerMenu + '.addBtn'), (not GetAttribute(friendUin, 0)))
                                Win_ShowWidget((uiPlayerMenu + '.deleteBtn'), GetAttribute(friendUin, 0))
                                Win_ShowWidget((uiPlayerMenu + '.shieldBtn'), (not GetAttribute(friendUin, 1)))
                                Win_ShowWidget((uiPlayerMenu + '.unshieldBtn'), GetAttribute(friendUin, 1))
                                Win_ShowWidget(uiPlayerMenu, 1)
                                Win_SetFocus('UI.selRoom.chatArea.chatEdit')


                            class children:
                                __module__ = __name__
                                class chatScroll(TVScroll):
                                    __module__ = __name__
                                    extendstyle = 0
                                    rect = (326,
                                     0,
                                     14,
                                     90)
                                    pagesize = 8
                                    class children:
                                        __module__ = __name__
                                        class blockbtn(TScrollBtn):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              1,
                                              1,
                                              0,
                                              0)]
                                            rect = (0,
                                             0,
                                             14,
                                             23)
                                            bkimage = 'object/ui/room/scl_block.img'







                class chatEdit(TRichEdit):
                    __module__ = __name__
                    initlayer = 550001
                    maxchar = 200
                    rect = (546,
                     500,
                     234,
                     20)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    captionrect = (0,
                     4,
                     234,
                     12)

                class orientation(TButton):
                    __module__ = __name__
                    initlayer = 550001
                    rect = (465,
                     500,
                     80,
                     20)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor
                    textstyle = (dt_center + dt_vcenter)

                    def OnClick(this):
                        global ChatOrientation
                        if ((ChatMode == 0) and Win_SetText('UI.selRoom.chatArea.chatEdit', '')):
                            kininfo = GetInviteKinInfo(1)
                            if ((kininfo.m_dwKinIndex != 0) and (ChatOrientation == 0)):
                                SectionChat(0, '/kinchat on')
                                ChatOrientation = 1
                        if Win_SetFocus('UI.selRoom.chatArea.chatEdit'):
                            pass



                class commandPrompt(TCheck):
                    __module__ = __name__
                    initlayer = 650001
                    extendstyle = ui_btn_style_none
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1),
                     (0,
                      0,
                      2,
                      2,
                      0,
                      0,
                      1,
                      1)]
                    rect = (443,
                     496,
                     23,
                     24)
                    bkimage = 'object/ui/chat/btn_commandPrompt.img'

                    def OnClick(this):
                        if (Win_IsChecked('UI.selRoom.chatArea.commandPrompt') and (oldWinEventCnt == Win_GetEventCnt())):
                            if Win_SetCheck('UI.selRoom.chatArea.commandPrompt', False):
                                pass
                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')


                    class children:
                        __module__ = __name__
                        class comDlg(TWidget):
                            __module__ = __name__
                            visible = 0
                            style = wgtstyle_popup
                            rect = (3,
                             -140,
                             92,
                             140)
                            bkimage = 'object/ui/chat/img_commandPrompt.img'

                            def OnSelfHide():
                                global oldWinEventCnt
                                oldWinEventCnt = Win_GetEventCnt()
                                Win_SetCheck('UI.selRoom.chatArea.commandPrompt', False)


                            class children:
                                __module__ = __name__
                                class profileView(TButton):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      0,
                                      0,
                                      -1,
                                      -1,
                                      -1,
                                      -1)]
                                    rect = (0,
                                     10,
                                     92,
                                     16)
                                    bkimage = 'object/ui/chat/img_cmdChoose.img'
                                    bkImgFlag = dt_center
                                    caption = '\xb2\xe9\xbf\xb4\xcd\xe6\xbc\xd2\xd7\xca\xc1\xcf'
                                    textstyle = (dt_center + dt_vcenter)

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/who ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)



                                class enterRoom(profileView):
                                    __module__ = __name__
                                    rect = (0,
                                     31,
                                     92,
                                     16)
                                    caption = '\xbc\xd3\xc8\xeb\xd3\xce\xcf\xb7\xb7\xbf\xbc\xe4'

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/go ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)



                                class refuseInvite(profileView):
                                    __module__ = __name__
                                    rect = (0,
                                     52,
                                     92,
                                     16)
                                    caption = '\xbe\xdc\xbe\xf8\xcb\xfb\xc8\xcb\xd1\xfb\xc7\xeb'

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/refuse ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)



                                class unrefuseInvite(profileView):
                                    __module__ = __name__
                                    rect = (0,
                                     73,
                                     92,
                                     16)
                                    caption = '\xbd\xe2\xb3\xfd\xbe\xdc\xbe\xf8\xd1\xfb\xc7\xeb'

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/unrefuse ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)



                                class ignoreWisper(profileView):
                                    __module__ = __name__
                                    rect = (0,
                                     94,
                                     92,
                                     16)
                                    caption = '\xc6\xc1\xb1\xce\xcb\xfb\xc8\xcb\xc3\xdc\xd3\xef'

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/M ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)



                                class unignoreWisper(profileView):
                                    __module__ = __name__
                                    rect = (0,
                                     115,
                                     92,
                                     16)
                                    caption = '\xbd\xe2\xb3\xfd\xb5\xa5\xc3\xdc\xc6\xc1\xb1\xce'

                                    def OnClick(this):
                                        Win_SetText('UI.selRoom.chatArea.chatEdit', '/U ')
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')
                                        Win_ShowWidget('UI.selRoom.chatArea.commandPrompt.comDlg', False)







                class sendBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    initlayer = 550001
                    rect = (698,
                     475,
                     34,
                     22)
                    bkimage = 'object/ui/chat/btn_send.img'

                    def OnClick(this):
                        global ChatMode
                        txt = Win_GetText('UI.selRoom.chatArea.chatEdit')
                        txt = filterChatMsg(txt)
                        if ((txt != '') and (ChatMode == 0)):
                            if SectionChat(0, txt):
                                print 'SectionChat',
                                print txt
                            Win_SetText('UI.selRoom.chatArea.chatEdit', txt, value_channel_edithistory)
                            Win_SetText('UI.selRoom.chatArea.chatEdit', '')
                        if ((not Win_IsVisible(uiPlayerInfoDlg)) and Win_SetFocus('UI.selRoom.chatArea.chatEdit')):
                            pass



                class donateInfo(TButton):
                    __module__ = __name__
                    initlayer = 550001
                    rect = (629,
                     471,
                     30,
                     30)
                    visible = 0
                    choice = 0

                    def OnClick(this):
                        GetLeaveWord()



                    def OnTimer(this):
                        ui = this
                        mychoice = UI.children.selRoom.children.chatArea.children.donateInfo.choice
                        if (1 == mychoice):
                            UI.children.selRoom.children.chatArea.children.donateInfo.choice = 0
                            Win_SetImg(ui, '')
                        else:
                            UI.children.selRoom.children.chatArea.children.donateInfo.choice = 1
                            Win_SetImg(ui, 'object/ui/selRoom/btn_message.img')



                class faceBtn(TCheck):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1),
                     (0,
                      0,
                      2,
                      2,
                      0,
                      0,
                      1,
                      1)]
                    initlayer = 550001
                    extendstyle = ui_btn_style_none
                    rect = (670,
                     475,
                     24,
                     22)
                    bkimage = 'object/ui/chat/btn_expression.img'

                    def OnClick(this):
                        if (Win_IsChecked('UI.selRoom.chatArea.faceBtn') and (oldWinEventCnt == Win_GetEventCnt())):
                            if Win_SetCheck('UI.selRoom.chatArea.faceBtn', False):
                                pass
                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')


                    class children:
                        __module__ = __name__
                        class faceDlg(TWidget):
                            __module__ = __name__
                            visible = 0
                            style = wgtstyle_popup
                            rect = ((406 - 547),
                             -137,
                             174,
                             137)
                            bkimage = 'object/ui/chat/dlg_face.img'

                            def OnSelfHide():
                                global oldWinEventCnt
                                oldWinEventCnt = Win_GetEventCnt()
                                Win_SetCheck('UI.selRoom.chatArea.faceBtn', False)


                            class children:
                                __module__ = __name__
                                class box(TStatic):
                                    __module__ = __name__
                                    rect = (0,
                                     0,
                                     10,
                                     10)
                                    class children:
                                        __module__ = __name__
                                        class face0(TButton):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              0,
                                              99,
                                              0,
                                              0,
                                              0,
                                              0)]
                                            rect = (8,
                                             6,
                                             26,
                                             26)
                                            bkImgFlag = dt_center
                                            bkimage = 'res/uires/face/faces/000.img'

                                            def OnClick(this):
                                                if isMemberFace:
                                                    i = ((memberFacePage * 24) + getMyIdx())
                                                else:
                                                    i = (((facePage + memberFacePageNum) * 24) + getMyIdx())
                                                Win_FocusOnInsert('UI.selRoom.chatArea.chatEdit', faceIconList[i])
                                                Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                                        class face1(face0):
                                            __module__ = __name__
                                            rect = ((8 + 27),
                                             6,
                                             26,
                                             26)

                                        class face2(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 2)),
                                             6,
                                             26,
                                             26)

                                        class face3(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 3)),
                                             6,
                                             26,
                                             26)

                                        class face4(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 4)),
                                             6,
                                             26,
                                             26)

                                        class face5(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 5)),
                                             6,
                                             26,
                                             26)

                                        class face6(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 0)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face7(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 1)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face8(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 2)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face9(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 3)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face10(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 4)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face11(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 5)),
                                             (6 + (27 * 1)),
                                             26,
                                             26)

                                        class face12(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 0)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face13(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 1)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face14(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 2)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face15(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 3)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face16(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 4)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face17(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 5)),
                                             (6 + (27 * 2)),
                                             26,
                                             26)

                                        class face18(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 0)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)

                                        class face19(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 1)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)

                                        class face20(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 2)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)

                                        class face21(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 3)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)

                                        class face22(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 4)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)

                                        class face23(face0):
                                            __module__ = __name__
                                            rect = ((8 + (27 * 5)),
                                             (6 + (27 * 3)),
                                             26,
                                             26)



                                class pageLab(TLabel):
                                    __module__ = __name__
                                    rect = ((102 + 22),
                                     117,
                                     18,
                                     12)
                                    drawcolor = (255,
                                     255,
                                     255,
                                     255)
                                    textEdgeColor = (6,
                                     102,
                                     231,
                                     255)

                                class leftBtn(TButton):
                                    __module__ = __name__
                                    rect = (102,
                                     115,
                                     17,
                                     17)
                                    bkimage = 'res/uires/face/biaoq_zuo.img'

                                    def OnClick(this):
                                        global facePage
                                        global memberFacePage
                                        if isMemberFace:
                                            memberFacePage -= 1
                                            if (memberFacePage < 0):
                                                memberFacePage = (memberFacePageNum - 1)
                                            setFacePage(memberFacePage, memberFacePageNum)
                                        else:
                                            facePage -= 1
                                            if (facePage < 0):
                                                facePage = (facePageNum - 1)
                                            setFacePage(facePage, facePageNum)
                                        PlaySound(soundUI, 1)
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                                class rightBtn(TButton):
                                    __module__ = __name__
                                    rect = (148,
                                     115,
                                     17,
                                     17)
                                    bkimage = 'res/uires/face/biaoq_you.img'

                                    def OnClick(this):
                                        global facePage
                                        global memberFacePage
                                        if isMemberFace:
                                            memberFacePage += 1
                                            if (memberFacePage >= memberFacePageNum):
                                                memberFacePage = 0
                                            setFacePage(memberFacePage, memberFacePageNum)
                                        else:
                                            facePage += 1
                                            if (facePage >= facePageNum):
                                                facePage = 0
                                            setFacePage(facePage, facePageNum)
                                        PlaySound(soundUI, 1)
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')



                                class choose(TButton):
                                    __module__ = __name__
                                    rect = (10,
                                     115,
                                     44,
                                     18)
                                    bkimage = 'object/ui/chat/btn_facemember.img'

                                    def OnClick(this):
                                        global isMemberFace
                                        if ((ChatMode == 0) and isMemberFace):
                                            isMemberFace = 0
                                            if Win_SetImg('UI.selRoom.chatArea.faceBtn.faceDlg.choose', 'object/ui/chat/btn_facemember.img'):
                                                setFacePage(facePage, facePageNum)
                                        PlaySound(soundUI, 1)
                                        Win_SetFocus('UI.selRoom.chatArea.chatEdit')







                class speakerBtn(TButton):
                    __module__ = __name__
                    initlayer = 550001
                    rect = (735,
                     473,
                     45,
                     24)

                    def OnClick(this):
                        global ChatMode
                        global ChatOrientation
                        ChatOrientation = 0
                        num = GetBugleNumber()
                        if Win_SetFocus('UI.selRoom.chatArea.chatEdit'):
                            if ((num > 0) and (ChatMode == 0)):
                                ChangeChatMode(1)
                                NotifyWisper(chatNameSpeaker, 0)



                class speakerTip:
                    __module__ = __name__
                    visible = 0
                    type = 'DYLABEL'
                    initlayer = 999999
                    bkimage = 'object/ui/common/img_tip.img'
                    rect = (646,
                     450,
                     130,
                     1)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    drawcolor = maskColor
                    textEdgeType = -1

                    def OnInit():
                        Win_SetText('UI.selRoom.chatArea.speakerTip', '\xc4\xfa\xcf\xd6\xd4\xda\xc3\xbb\xd3\xd0\xd0\xa1\xc0\xae\xb0\xc8\xb5\xc0\xbe\xdf\xa3\xac\xc7\xeb\xcf\xc8\xd4\xda\xc9\xcc\xb5\xea\xb9\xba\xc2\xf2\xba\xf3\xd4\xd9\xca\xb9\xd3\xc3\xa3\xac\xd0\xbb\xd0\xbb\xa3\xa1')



                    def OnTimer(this):
                        Win_Timer(this, 0)
                        Win_ShowWidget(this, False)



                class integration(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (443,
                     471,
                     40,
                     20)
                    groupstop = 0
                    initlayer = 600010
                    hotcover = 'object/ui/chat/tab_integration.img'

                    def OnClick(this):
                        global ChatAreaTab
                        ChatAreaTab = 0
                        Win_ShowWidget('UI.selRoom.chatArea.chatPanel', 1)
                        Win_ShowWidget('UI.selRoom.chatArea.kinchatPanel', 0)
                        Win_ShowWidget('UI.selRoom.chatArea.wisperPanel', 0)
                        PlaySound(soundUI, 1)



                class kinchat(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (483,
                     471,
                     40,
                     20)
                    groupstop = 1
                    initlayer = 600015
                    hotcover = 'object/ui/chat/tab_kin.img'

                    def OnClick(this):
                        global ChatAreaTab
                        ChatAreaTab = 1
                        Win_ShowWidget('UI.selRoom.chatArea.chatPanel', 0)
                        Win_ShowWidget('UI.selRoom.chatArea.kinchatPanel', 1)
                        Win_ShowWidget('UI.selRoom.chatArea.wisperPanel', 0)
                        PlaySound(soundUI, 1)



                class wisper(kinchat):
                    __module__ = __name__
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (523,
                     471,
                     40,
                     20)
                    groupstop = 2
                    initlayer = 600010
                    hotcover = 'object/ui/chat/tab_whisper.img'

                    def OnClick(this):
                        global ChatAreaTab
                        ChatAreaTab = 2
                        Win_ShowWidget('UI.selRoom.chatArea.chatPanel', 0)
                        Win_ShowWidget('UI.selRoom.chatArea.kinchatPanel', 0)
                        Win_ShowWidget('UI.selRoom.chatArea.wisperPanel', 1)
                        PlaySound(soundUI, 1)



                class kinchatPanel(chatPanel):
                    __module__ = __name__

                class wisperPanel(chatPanel):
                    __module__ = __name__



        class pwRoom(TStatic):
            __module__ = __name__
            initlayer = 99999
            visible = 0
            darkBG = 1
            rect = (267,
             196,
             365,
             205)
            bkimage = 'object/ui/selRoom/dlg_pwRoom.img'
            class children:
                __module__ = __name__
                class pw(TEditPassword):
                    __module__ = __name__
                    drawcolor = zoneChooseColor
                    rect = (42,
                     84,
                     300,
                     12)
                    maxchar = 15

                class confirm(TButton):
                    __module__ = __name__
                    rect = (140,
                     165,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        CloseC2CDealDlg(bC2CDealShow)
                        Win_ShowWidget('UI.selRoom.pwRoom', False)
                        pw = Win_GetText('UI.selRoom.pwRoom.pw')
                        EnterRoom(roomID, pw)
                        print 'EnterRoom(',
                        print roomID,
                        print pw
                        PlaySound(soundMain, 1)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (200,
                     165,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.selRoom.pwRoom', False)
                        PlaySound(soundLeave, 1)





        class mapFilterDlg(TDlg):
            __module__ = __name__
            style = wgtstyle_popup
            initlayer = 80000
            visible = 0
            rect = (278,
             88,
             92,
             197)
            bkimage = 'object/ui/selRoom/map/dlg_mapFilter.img'

            def initMe():
                doUI('UI.room.selMap.scroll', 'OnPosChange')


            class children:
                __module__ = __name__
                class scroll(TVScroll):
                    __module__ = __name__
                    visible = 1
                    rect = ((442 - 338),
                     (61 - 44),
                     16,
                     73)
                    pos = 0
                    pagesize = -5

                    def OnPosChange():
                        scrollCnt = 11
                        ui = 'UI.selRoom.mapFilterDlg'
                        pos = Win_GetPos((ui + '.scroll'))
                        gameModeCnt = len(gameModeList)
                        print ('gameModeCnt is %d' % gameModeCnt)
                        Win_SetRange((ui + '.scroll'), (gameModeCnt - scrollCnt))
                        for i in range(scrollCnt):
                            mapUI = ((ui + '.mapMode') + str(i))
                            Win_SetValue(mapUI, 0, value_channel_draw_flag)
                            iPos = (i + pos)
                            if ((iPos >= gameModeCnt) and Win_ShowWidget(mapUI, False)):
                                pass




                class mapMode0(TButton):
                    __module__ = __name__
                    visible = 0
                    bkcolor = (222,
                     255,
                     36,
                     255)
                    rect = (0,
                     3,
                     100,
                     17)
                    framescheme = [(-1,
                      -1,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1)]
                    bkimage = 'object/ui/chat/img_cmdChoose.img'

                    def OnClick(this):
                        global curGameMode
                        ui = 'UI.selRoom.mapFilterDlg'
                        pos = Win_GetPos((ui + '.scroll'))
                        curGameMode = (getMyIdx() + pos)
                        Win_ShowWidget(ui, 0)
                        info = gameModeList[curGameMode]
                        Win_SetText('UI.selRoom.mapFilterBtn.text', info[2])
                        Win_SetImg('UI.selRoom.mapFilterBtn.icon', ('map/icon/%s.img' % info[1]))
                        request_UserSelGameModeList(info[0])
                        PlaySound(soundUI, 1)


                    class children:
                        __module__ = __name__
                        class icon(TStatic):
                            __module__ = __name__
                            rect = (9,
                             0,
                             16,
                             17)
                            bkimage = 'map/icon/water.img'

                        class name(TLabel,
                         Static):
                            __module__ = __name__
                            rect = ((286 - 250),
                             (69 - 66),
                             80,
                             12)
                            drawcolor = (255,
                             255,
                             255,
                             255)



                class mapMode1(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 1)),
                     100,
                     17)

                class mapMode2(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 2)),
                     100,
                     17)

                class mapMode3(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 3)),
                     100,
                     17)

                class mapMode4(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 4)),
                     100,
                     17)

                class mapMode5(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 5)),
                     100,
                     17)

                class mapMode6(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 6)),
                     100,
                     17)

                class mapMode7(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 7)),
                     100,
                     17)

                class mapMode8(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 8)),
                     100,
                     17)

                class mapMode9(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 9)),
                     100,
                     17)

                class mapMode10(mapMode0):
                    __module__ = __name__
                    rect = (0,
                     (3 + (17 * 10)),
                     100,
                     17)



        class petPan(TStatic):
            __module__ = __name__
            visible = 0
            darkBG = 1
            initlayer = 999999
            rect = (80,
             100,
             353,
             530)
            bkimage = 'object/ui/pet/dlg_pet.img'

            def OnDenit():
                Win_ShowWidget(uiPetPan, 0)
                Win_ShowWidget((uiPetPan + '.foodDlg'), 0)


            class children:
                __module__ = __name__
                class petPreview(TLabel):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (55,
                     48,
                     94,
                     94)
                    framescheme = [(0,
                      15,
                      0,
                      15,
                      0,
                      15,
                      0,
                      15)]
                    drawcolor = lightColor
                    bkimage = ''

                class petFace(TStatic):
                    __module__ = __name__
                    initlayer = 9998
                    rect = (114,
                     50,
                     40,
                     40)
                    framescheme = [(0,
                      15,
                      0,
                      15,
                      0,
                      15,
                      0,
                      15)]
                    bkimage = ''

                class crossBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (214,
                     9,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiPetPan, 0)
                        PlaySound(soundUI, 1)



                class adoptPetBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (196,
                     46,
                     40,
                     30)
                    bkimage = 'object/ui/pet/btn_adopt.img'

                    def OnClick(this):
                        global mark_shopPetTab
                        PlaySound(soundUI, 1)
                        mark_shopPetTab = 1
                        doUI('UI.selRoom.shopBtn', 'OnClick')



                class petStateBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (196,
                     80,
                     40,
                     30)
                    bkimage = 'object/ui/pet/btn_take.img'

                    def OnClick(this):
                        PlaySound(soundUI, 1)
                        if ((curPetState == 1) and Win_EnableWidget(this, 0)):
                            StopTakePet(curPetId)



                class freePetBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (196,
                     114,
                     40,
                     30)
                    bkimage = 'object/ui/pet/btn_free.img'

                    def OnClick(this):
                        PlaySound(soundUI, 1)
                        ui_msgBox(1)
                        Win_ShowMsgBox('    \xc4\xfa\xc8\xb7\xc8\xcf\xc8\xc3\xc4\xfa\xb5\xc4\xb3\xe8\xce\xef\xb1\xa6\xb1\xa6\xc0\xeb\xbf\xaa\xc4\xfa\xc2\xf0', '\xce\xc2\xdc\xb0\xcc\xe1\xca\xbe', 0, 'UI.SysMsgbox', -9)



                class nameEdit(TEdit):
                    __module__ = __name__
                    editable = 1
                    maxchar = 10
                    rect = (57,
                     158,
                     123,
                     16)
                    drawcolor = lightColor

                class changeNameBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (182,
                     150,
                     55,
                     26)
                    bkimage = 'object/ui/pet/btn_change_name.img'

                    def OnClick(this):
                        strName = Win_GetText((uiPetPan + '.nameEdit'))
                        if (curPetName == strName):
                            return 
                        Win_EnableWidget(this, 0)
                        ChangePetName(curPetId, strName)
                        PlaySound(soundUI, 1)



                class level(TLabel):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (84,
                     186,
                     100,
                     18)
                    drawcolor = darkColor
                    textEdgeType = -1
                    caption = ''

                class expLine(TStatic):
                    __module__ = __name__
                    bkimage = 'object/ui/pet/img_exp.img'
                    rect = (74,
                     209,
                     94,
                     12)

                class expValue(TLabel):
                    __module__ = __name__
                    rect = (174,
                     209,
                     100,
                     12)
                    drawcolor = lightColor
                    textEdgeColor = maskColor

                class loyaltyLine(TStatic):
                    __module__ = __name__
                    bkimage = 'object/ui/pet/img_exp.img'
                    rect = (74,
                     227,
                     94,
                     12)

                class loyaltyValue(TLabel):
                    __module__ = __name__
                    rect = (174,
                     227,
                     100,
                     12)
                    drawcolor = lightColor
                    textEdgeColor = maskColor

                class raisePetBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (13,
                     246,
                     109,
                     27)
                    bkimage = 'object/ui/pet/btn_raise.img'

                    def OnClick(this):
                        PlaySound(soundUI, 1)
                        ui = (uiPetPan + '.foodDlg')
                        if ((not Win_IsVisible(ui)) and UpdatePetItemUi()):
                            Win_ShowWidget(ui, 1)
                            Win_SetImg(this, 'object/ui/pet/btn_raise1.img')



                class foodDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = 9999
                    rect = (1,
                     280,
                     250,
                     217)
                    bkimage = 'object/ui/pet/dlg_food.img'
                    class children:
                        __module__ = __name__
                        class firstPageBtn(TButton):
                            __module__ = __name__
                            initlayer = 9999
                            rect = (18,
                             195,
                             34,
                             21)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/pet/btn_first_page.img'

                            def OnClick(this):
                                global petItemPos
                                petItemPos = 0
                                UpdatePetItemUi()
                                PlaySound(soundUI, 1)



                        class lastPageBtn(TButton):
                            __module__ = __name__
                            initlayer = 9999
                            rect = (206,
                             195,
                             34,
                             21)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/pet/btn_last_page.img'

                            def OnClick(this):
                                global petItemPos
                                petItemPos = ((len(petItemList) / defPetItemCnt) * defPetItemCnt)
                                UpdatePetItemUi()
                                PlaySound(soundUI, 1)



                        class prePageBtn(TButton):
                            __module__ = __name__
                            initlayer = 9999
                            rect = (48,
                             195,
                             34,
                             21)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/pet/btn_pre_page.img'

                            def OnClick(this):
                                global petItemPos
                                petItemPos -= defPetItemCnt
                                if (petItemPos < 0):
                                    petItemPos = 0
                                UpdatePetItemUi()
                                PlaySound(soundUI, 1)



                        class nextPageBtn(TButton):
                            __module__ = __name__
                            initlayer = 9999
                            rect = (186,
                             195,
                             25,
                             21)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/pet/btn_next_page.img'

                            def OnClick(this):
                                global petItemPos
                                if ((petItemPos + defPetItemCnt) >= len(petItemList)):
                                    return 
                                petItemPos += defPetItemCnt
                                UpdatePetItemUi()
                                PlaySound(soundUI, 1)



                        class petItemPage:
                            __module__ = __name__
                            type = 'NUMLABEL'
                            rect = (85,
                             194,
                             80,
                             24)
                            bkimage = 'object/ui/common/number6.img'
                            textstyle = dt_center
                            textsize = 16
                            textwidth = 14
                            textheight = 18

                        class petItem0(TButton):
                            __module__ = __name__
                            rect = (5,
                             2,
                             60,
                             60)
                            bkimage = 'object/ui/storage/img_choose.img'
                            framescheme = [(-1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1),
                             (0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0)]
                            tipwidget = (uiPetPan + '.description')

                            def OnRClick():
                                global curUseItem
                                PlaySound(soundUI, 1)
                                me = getMyIdx2()
                                index = (petItemPos + me)
                                if (index >= len(petItemList)):
                                    return 
                                curUseItem = petItemList[index].m_nItemID
                                ui_msgBox(1)
                                Win_ShowMsgBox('   \xc4\xfa\xc8\xb7\xc8\xcf\xd2\xaa\xca\xb9\xd3\xc3\xb3\xe8\xce\xef\xb5\xc0\xbe\xdf\xc2\xf0?', '\xce\xc2\xdc\xb0\xcc\xe1\xca\xbe', 0, 'UI.SysMsgbox', -8)



                            def OnMouseMoveIn():
                                ui = (uiPetPan + '.description')
                                index = (petItemPos + getMyIdx2())
                                if ((index >= len(petItemList)) and Win_ShowWidget(ui, 0)):
                                    return 
                                Win_ShowWidget(ui, 1)
                                item = petItemList[index].m_nItemID
                                if itemList.has_key(item):
                                    description = ((itemList[item][2] + ' \xa3\xba ') + itemList[item][3])
                                else:
                                    Win_ShowWidget(ui, 0)
                                    return 
                                Win_SetText(ui, description)
                                me = Win_GetMyPath()
                                winrect = Win_GetRect(me, value_channel_winrect)
                                caprect = Win_GetRect(ui, value_channel_captionrect)
                                Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))


                            class children:
                                __module__ = __name__
                                class itemPic(TStatic):
                                    __module__ = __name__
                                    rect = (0,
                                     0,
                                     60,
                                     56)
                                    bkImgFlag = dt_center

                                class itemNum(TLabel):
                                    __module__ = __name__
                                    rect = (30,
                                     40,
                                     24,
                                     12)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor



                        class petItem1(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 1)),
                             2,
                             60,
                             60)

                        class petItem2(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 2)),
                             2,
                             60,
                             60)

                        class petItem3(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 3)),
                             2,
                             60,
                             60)

                        class petItem4(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 0)),
                             (2 + (62 * 1)),
                             60,
                             60)

                        class petItem5(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 1)),
                             (2 + (62 * 1)),
                             60,
                             60)

                        class petItem6(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 2)),
                             (2 + (62 * 1)),
                             60,
                             60)

                        class petItem7(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 3)),
                             (2 + (62 * 1)),
                             60,
                             60)

                        class petItem8(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 0)),
                             (2 + (62 * 2)),
                             60,
                             60)

                        class petItem9(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 1)),
                             (2 + (62 * 2)),
                             60,
                             60)

                        class petItem10(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 2)),
                             (2 + (62 * 2)),
                             60,
                             60)

                        class petItem11(petItem0):
                            __module__ = __name__
                            rect = ((5 + (62 * 3)),
                             (2 + (62 * 2)),
                             60,
                             60)



                class sKillBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (128,
                     246,
                     109,
                     27)
                    bkimage = 'object/ui/pet/btn_skill.img'

                    def OnClick(this):
                        PlaySound(soundUI, 1)
                        ui = (uiPetPan + '.skillDlg')
                        if ((not Win_IsVisible(ui)) and Win_ShowWidget((uiPetPan + '.baseSkillDlg'), 1)):
                            Win_ShowWidget(ui, 1)
                            Win_SetImg(this, 'object/ui/pet/btn_skill1.img')



                class baseSkillDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = 9999
                    rect = (244,
                     -2,
                     108,
                     100)
                    bkimage = 'object/ui/pet/dlg_baseskill.img'
                    class children:
                        __module__ = __name__
                        class skill0(TButton):
                            __module__ = __name__
                            editable = 0
                            visible = 1
                            initlayer = 10000
                            rect = (20,
                             18,
                             73,
                             22)
                            drawcolor = lightColor
                            tipwidget = (uiPetPan + '.description')

                            def OnMouseMoveIn():
                                me = Win_GetMyPath()
                                idx = getMyIdx2()
                                ui = (uiPetPan + '.description')
                                skillDes = ''
                                if (idx >= len(baseSkillIdList)):
                                    skillDes = ''
                                    Win_SetText(ui, skillDes)
                                    Win_ShowWidget(ui, 0)
                                    return 
                                else:
                                    skillDes = GetSkillDescription(baseSkillIdList[idx])
                                Win_SetText(ui, skillDes)
                                winrect = Win_GetRect(me, value_channel_winrect)
                                caprect = Win_GetRect(ui, value_channel_captionrect)
                                Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))
                                Win_ShowWidget(ui, 1)



                        class skill1(skill0):
                            __module__ = __name__
                            rect = (20,
                             (18 + 28),
                             73,
                             22)

                        class skill2(skill0):
                            __module__ = __name__
                            rect = (20,
                             (18 + (28 * 2)),
                             73,
                             22)



                class skillDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = 9999
                    rect = (244,
                     96,
                     108,
                     282)
                    bkimage = 'object/ui/pet/dlg_skill.img'
                    class children:
                        __module__ = __name__
                        class skill0(TButton):
                            __module__ = __name__
                            editable = 0
                            visible = 1
                            initlayer = 10000
                            rect = (20,
                             5,
                             73,
                             22)
                            drawcolor = lightColor
                            tipwidget = (uiPetPan + '.description')

                            def OnMouseMoveIn():
                                me = Win_GetMyPath()
                                idx = getMyIdx2()
                                ui = (uiPetPan + '.description')
                                skillDes = ''
                                if (idx >= len(skillIdList)):
                                    skillDes = ''
                                    Win_SetText(ui, skillDes)
                                    Win_ShowWidget(ui, 0)
                                    return 
                                else:
                                    skillDes = GetSkillDescription(skillIdList[idx])
                                Win_SetText(ui, skillDes)
                                winrect = Win_GetRect(me, value_channel_winrect)
                                caprect = Win_GetRect(ui, value_channel_captionrect)
                                Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))
                                Win_ShowWidget(ui, 1)



                        class skill1(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + 28),
                             73,
                             22)

                        class skill2(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 2)),
                             73,
                             22)

                        class skill3(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 3)),
                             73,
                             22)

                        class skill4(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 4)),
                             73,
                             22)

                        class skill5(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 5)),
                             73,
                             22)

                        class skill6(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 6)),
                             73,
                             22)

                        class skill7(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 7)),
                             73,
                             22)

                        class skill8(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 8)),
                             73,
                             22)

                        class skill9(skill0):
                            __module__ = __name__
                            rect = (20,
                             (5 + (28 * 9)),
                             73,
                             22)



                class left(TButton):
                    __module__ = __name__
                    rect = (34,
                     71,
                     16,
                     57)
                    bkimage = 'object/ui/selRoom/btn_left.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global curPetId
                        PlaySound(soundUI, 1)
                        ui = (uiPetPan + '.skillDlg')
                        if (len(petsIdList) < 2):
                            return 
                        index = 0
                        for x in petsIdList:
                            if (curPetId == x):
                                break
                            index += 1

                        index -= 1
                        if (index < 0):
                            index = (len(petsIdList) - 1)
                        curPetId = petsIdList[index]
                        UpdatePetInfo()



                class right(TButton):
                    __module__ = __name__
                    rect = (156,
                     71,
                     16,
                     57)
                    bkimage = 'object/ui/selRoom/btn_right.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global curPetId
                        PlaySound(soundUI, 1)
                        ui = (uiPetPan + '.skillDlg')
                        if (len(petsIdList) < 2):
                            return 
                        index = 0
                        for x in petsIdList:
                            if (curPetId == x):
                                break
                            index += 1

                        index += 1
                        if (index >= len(petsIdList)):
                            index = 0
                        curPetId = petsIdList[index]
                        UpdatePetInfo()



                class description:
                    __module__ = __name__
                    type = 'DYLABEL'
                    initlayer = 99999999
                    rect = (0,
                     0,
                     130,
                     1)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    bkimage = 'object/ui/common/img_tip.img'
                    textEdgeType = -1
                    drawcolor = maskColor



        class pawnshop(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (0,
             40,
             800,
             560)
            bkimage = 'object/ui/deal/bg_pawnshop.img'

            def OnInit():
                global PawnItemCnt
                PawnItemCnt = 0
                print 'pawnshop OnInit'
                Win_SetCheck((uiPawnShopDlg + '.pawnedBtn'), 0)
                Win_SetCheck((uiPawnShopDlg + '.pawningBtn'), 1)


            class children:
                __module__ = __name__
                class advertBtn(TButton):
                    __module__ = __name__
                    initlayer = 9999
                    rect = (18,
                     71,
                     163,
                     463)
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]

                    def OnClick(this):
                        sc_HideWeb('party')
                        url = GetCurAdvert()
                        print url
                        ui_jumpWeb(url)



                class crossBtn(TButton):
                    __module__ = __name__
                    initlayer = 999999
                    rect = (770,
                     10,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global CurrenPawnType
                        global bPawnShopShow
                        CurrenPawnType = -1
                        bPawnShopShow = 0
                        LogoutDeal()
                        Win_SetCheck((uiPawnShopDlg + '.pawnedBtn'), 0)
                        Win_SetCheck((uiPawnShopDlg + '.pawningBtn'), 1)
                        Win_ShowWidget(uiPawnShopDlg, 0)
                        PlaySound(soundUI, 1)



                class ware1(TCheck):
                    __module__ = __name__
                    initlayer = 2
                    rect = (368,
                     77,
                     198,
                     72)
                    bkimage = 'object/ui/shop/img_ware.img'
                    framescheme = [(1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1,
                      1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    groupstop = 1

                    def OnClick(me):
                        pass

                    class children:
                        __module__ = __name__
                        class buyBtn(TButton):
                            __module__ = __name__
                            initlayer = -99
                            rect = (158,
                             25,
                             36,
                             42)
                            bkimage = 'object/ui/shop/btn_buy.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(me):
                                global buyItemInfo
                                pos = Win_GetPos((uiPawnShopDlg + '.wareScroll'))
                                wareIdx = getMyMidIdx()
                                print wareIdx,
                                print pos
                                print ('wareIdx=%d' % wareIdx)
                                ui = (uiPawnShopDlg + ('.ware%d' % wareIdx))
                                propId = int(Win_GetText((ui + '.ID')))
                                propname = Win_GetText((ui + '.name'))
                                price = int(Win_GetText((ui + '.price')))
                                saleindex = int(Win_GetText((ui + '.saleIndex')))
                                num = int(Win_GetText((ui + '.realNum')))
                                dstUin = int(Win_GetText((ui + '.dstUin')))
                                buyItemInfo = []
                                print ('propId = %(1)d propname = %(2)s price = %(3)d saleindex = %(4)d num = %(5)d dstUin = %(6)d' % {'1': propId,
                                 '2': propname,
                                 '3': price,
                                 '4': saleindex,
                                 '5': num,
                                 '6': dstUin})
                                buyItemInfo.append(propId)
                                buyItemInfo.append(price)
                                buyItemInfo.append(saleindex)
                                buyItemInfo.append(num)
                                buyItemInfo.append(dstUin)
                                if (ShowMyPawned and Win_SetText((uiPawnShopDlg + '.buyTipDlg.prompt'), '\xc4\xfa\xc8\xb7\xb6\xa8\xd2\xaa\xc8\xa1\xcf\xfb\xbc\xc4\xca\xdb\xb8\xc3\xb5\xc0\xbe\xdf\xc2\xf0?')):
                                    pass
                                ui_setCapture((uiPawnShopDlg + '.buyTipDlg'))



                        class frame(TStatic):
                            __module__ = __name__
                            visible = 0
                            initlayer = -999
                            rect = (0,
                             0,
                             1,
                             1)
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0)]
                            bkimage = 'object/ui/shop/img_wareFrame.img'

                        class ID(TString):
                            __module__ = __name__
                            caption = '-1'

                        class picture(TStatic):
                            __module__ = __name__
                            bkImgFlag = dt_center
                            rect = (3,
                             3,
                             66,
                             66)

                        class name(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (80,
                             (70 - 60),
                             (227 - 114),
                             12)
                            drawcolor = (255,
                             255,
                             0,
                             255)

                        class price1(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (72,
                             29,
                             100,
                             12)
                            drawcolor = (255,
                             255,
                             255,
                             255)
                            textstyle = dt_left
                            textLineType = 0

                        class Num(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (72,
                             45,
                             100,
                             12)
                            drawcolor = (255,
                             255,
                             255,
                             255)
                            textstyle = dt_left
                            textLineType = 0

                        class realNum(TString):
                            __module__ = __name__
                            caption = '-1'

                        class memberPic(TStatic):
                            __module__ = __name__
                            rect = (((97 - 19) - 6),
                             50,
                             27,
                             12)
                            bkimage = 'object/ui/shop/wareAttr/memberPic.img'

                        class saleIndex(TString):
                            __module__ = __name__
                            caption = '-1'

                        class price(TString):
                            __module__ = __name__
                            caption = '-1'

                        class dstUin(TString):
                            __module__ = __name__
                            caption = '-1'

                        class PetInfo(TButton):
                            __module__ = __name__
                            initlayer = -99
                            rect = (139,
                             46,
                             36,
                             36)
                            bkimage = 'object/ui/deal/lookuppetBtn.img'
                            framescheme = [(0,
                              0,
                              1,
                              1,
                              2,
                              2,
                              3,
                              3)]

                            def OnClick(me):
                                wareIdx = getMyMidIdx()
                                print ('[PetInfo] wareIdx=%d' % wareIdx)
                                ui = (uiPawnShopDlg + ('.ware%d' % wareIdx))
                                saeIdx = saleindex = int(Win_GetText((ui + '.saleIndex')))
                                RequestPawnPetInfo(saeIdx)





                class ware2(ware1):
                    __module__ = __name__
                    rect = (567,
                     77,
                     198,
                     72)
                    groupstop = 2
                    initlayer = 1

                class ware3(ware1):
                    __module__ = __name__
                    rect = (368,
                     (77 + 73),
                     198,
                     72)
                    groupstop = 3
                    initlayer = 4

                class ware4(ware1):
                    __module__ = __name__
                    rect = (567,
                     (77 + 73),
                     198,
                     72)
                    groupstop = 4
                    initlayer = 3

                class ware5(ware1):
                    __module__ = __name__
                    rect = (368,
                     (77 + (73 * 2)),
                     198,
                     72)
                    groupstop = 5
                    initlayer = 6

                class ware6(ware1):
                    __module__ = __name__
                    rect = (567,
                     (77 + (73 * 2)),
                     198,
                     72)
                    groupstop = 6
                    initlayer = 5

                class ware7(ware1):
                    __module__ = __name__
                    rect = (368,
                     (77 + (73 * 3)),
                     198,
                     72)
                    groupstop = 7
                    initlayer = 8

                class ware8(ware1):
                    __module__ = __name__
                    rect = (567,
                     (77 + (73 * 3)),
                     198,
                     72)
                    groupstop = 8
                    initlayer = 7

                class ware9(ware1):
                    __module__ = __name__
                    rect = (368,
                     (77 + (73 * 4)),
                     198,
                     72)
                    groupstop = 9
                    initlayer = 10

                class ware10(ware1):
                    __module__ = __name__
                    rect = (567,
                     (77 + (73 * 4)),
                     198,
                     72)
                    groupstop = 10
                    initlayer = 9

                class ware11(ware1):
                    __module__ = __name__
                    rect = (368,
                     (77 + (73 * 5)),
                     198,
                     72)
                    groupstop = 11
                    initlayer = 12

                class ware12(ware1):
                    __module__ = __name__
                    rect = (567,
                     (77 + (73 * 5)),
                     198,
                     72)
                    groupstop = 12
                    initlayer = 11

                class itemList0(TButton):
                    __module__ = __name__
                    rect = (190,
                     75,
                     132,
                     19)
                    bkimage = 'object/ui/forge/btn_type.img'
                    textEdgeColor = (80,
                     80,
                     80,
                     255)
                    teststyle = dt_left

                    def OnClick(this):
                        global CurrentPawnItemID
                        global PawnItemCnt
                        global CurrenPawnType
                        if ShowMyPawned:
                            return 
                        pos = Win_GetPos((uiPawnShopDlg + '.itemScroll'))
                        idx = (getMyIdx2() + pos)
                        print ('idx = %d,CurrenPawnType = %d' % (idx,
                         CurrenPawnType))
                        if (idx < CurrenPawnType):
                            CurrenPawnType = idx
                            g_PawnItemList.clear()
                            g_PawnItemList.update()
                            doUI((uiPawnShopDlg + '.itemScroll'), 'OnPosChange')
                        elif (idx == CurrenPawnType):
                            CurrenPawnType = -1
                            PawnItemCnt = 0
                            doUI((uiPawnShopDlg + '.itemScroll'), 'OnPosChange')
                        elif ((CurrenPawnType >= 0) and (idx <= (CurrenPawnType + PawnItemCnt))):
                            print ('[itemList0]idx- CurrenPawnType = %d' % (idx - CurrenPawnType))
                            CurrentPawnItemID = g_PawnItemList.at(((idx - CurrenPawnType) - 1)).m_nPropID
                            RequestGetPawnGoodsbyID(CurrentPawnItemID, 0)
                            print ('CurrentItem Prop = %(n)d,PropName = %(x)s' % {'n': g_PawnItemList.at(((idx - CurrenPawnType) - 1)).m_nPropID,
                             'x': g_PawnItemList.at(((idx - CurrenPawnType) - 1)).m_sPropName})
                        elif (idx < (PawnTypeCnt + PawnItemCnt)):
                            CurrenPawnType = (idx - PawnItemCnt)
                            g_PawnItemList.clear()
                            g_PawnItemList.update()
                            print ('idx = %d,CurrenPawnType = %d,PawnTypeCnt = %d,PawnItemCnt = %d' % (idx,
                             CurrenPawnType,
                             PawnTypeCnt,
                             PawnItemCnt))
                            doUI((uiPawnShopDlg + '.itemScroll'), 'OnPosChange')



                class itemList1(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 1)),
                     132,
                     19)

                class itemList2(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 2)),
                     132,
                     19)

                class itemList3(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 3)),
                     132,
                     19)

                class itemList4(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 4)),
                     132,
                     19)

                class itemList5(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 5)),
                     132,
                     19)

                class itemList6(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 6)),
                     132,
                     19)

                class itemList7(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 7)),
                     132,
                     19)

                class itemList8(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 8)),
                     132,
                     19)

                class itemList9(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 9)),
                     132,
                     19)

                class itemList9(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 9)),
                     132,
                     19)

                class itemList10(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 10)),
                     132,
                     19)

                class itemList11(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 11)),
                     132,
                     19)

                class itemList12(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 12)),
                     132,
                     19)

                class itemList13(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 13)),
                     132,
                     19)

                class itemList14(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 14)),
                     132,
                     19)

                class itemList15(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 15)),
                     132,
                     19)

                class itemList16(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 16)),
                     132,
                     19)

                class itemList17(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 17)),
                     132,
                     19)

                class itemList18(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 18)),
                     132,
                     19)

                class itemList19(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 19)),
                     132,
                     19)

                class itemList20(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 20)),
                     132,
                     19)

                class itemList21(itemList0):
                    __module__ = __name__
                    rect = (190,
                     (75 + (20 * 21)),
                     132,
                     19)

                class itemScroll(TVScroll):
                    __module__ = __name__
                    rect = ((340 - 14),
                     (75 + 16),
                     26,
                     408)
                    pos = 0

                    def OnPosChange():
                        (PawnTypeCnt,
                         PawnItemCnt,
                         CurrenPawnType,
                         defPawnItemCnt)
                        pos = Win_GetPos((uiPawnShopDlg + '.itemScroll'))
                        sclRange = PawnTypeCnt
                        if (CurrenPawnType >= 0):
                            print ('[itemScroll::OnPosChange]pos = %d,PawnItemCnt = %d' % (pos,
                             PawnItemCnt))
                            sclRange += PawnItemCnt
                        Win_SetRange((uiPawnShopDlg + '.itemScroll'), max((sclRange - defPawnItemCnt), 0))
                        for i in range(defPawnItemCnt):
                            idx = (pos + i)
                            Win_SetDrawColor((uiPawnShopDlg + ('.itemList%d' % i)), 255, 255, 255, 255)
                            if ((idx <= CurrenPawnType) and Win_SetImg((uiPawnShopDlg + ('.itemList%d' % i)), 'object/ui/forge/btn_type.img')):
                                Win_SetText((uiPawnShopDlg + ('.itemList%d' % i)), g_PawnTypeList.at(idx).m_TypeName)



                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              1,
                              1,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             42)
                            bkimage = 'object/ui/common/scl_block.img'

                        class spinup(TSpinDec):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (5,
                             -17,
                             18,
                             18)
                            bkimage = 'object/ui/forge/scl_up.img'

                            def OnClick(this):
                                PlaySound(soundUI, 1)



                        class spindown(TSpinInc):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (5,
                             (420 - 13),
                             18,
                             18)
                            bkimage = 'object/ui/forge/scl_down.img'

                            def OnClick(this):
                                PlaySound(soundUI, 1)





                class wareScroll(TVScroll):
                    __module__ = __name__
                    rect = (763,
                     (75 + 16),
                     26,
                     408)
                    pos = 0

                    def OnPosChange():
                        currentpos = 0
                        if ShowMyPawned:
                            ShowList = g_MyPawnItemList
                            currentpos = PawnGoodsPos
                        else:
                            ShowList = g_PawnGoodsList
                        print PawnGoodsCnt
                        Win_SetRange((uiPawnShopDlg + '.wareScroll'), (((PawnGoodsCnt - defPawnwareCnt) + 1) / 2))
                        pos = Win_GetPos((uiPawnShopDlg + '.wareScroll'))
                        print '[wareScroll::OnPosChange]pos=',
                        print pos
                        for i in range(defPawnwareCnt):
                            ui = (uiPawnShopDlg + ('.ware%d' % (i + 1)))
                            info = ShowList.at(((currentpos + i) + (pos * 2)))
                            if ((None == info) and Win_EnableWidget(ui, 0)):
                                Win_SetText((ui + '.name'), '')
                                Win_SetText((ui + '.ID'), '')
                                Win_SetImg((ui + '.picture'), '')
                                Win_SetText((ui + '.price1'), '')
                                Win_SetImg((ui + '.memberPic'), '')
                                Win_SetText((ui + '.Num'), '')
                                Win_SetText((ui + '.dstUin'), '')
                                Win_SetImg((ui + '.buyBtn'), '')
                                Win_SetImg((ui + '.PetInfo'), '')
                                Win_EnableWidget((ui + '.PetInfo'), 0)
                                Win_EnableWidget((ui + '.buyBtn'), 0)



                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              1,
                              1,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             42)
                            bkimage = 'object/ui/common/scl_block.img'

                        class spinup(TSpinDec):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (5,
                             -17,
                             18,
                             18)
                            bkimage = 'object/ui/forge/scl_up.img'

                            def OnClick(this):
                                PlaySound(soundUI, 1)



                        class spindown(TSpinInc):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (5,
                             (420 - 13),
                             18,
                             18)
                            bkimage = 'object/ui/forge/scl_down.img'

                            def OnClick(this):
                                PlaySound(soundUI, 1)





                class Left(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = ((600 - 165),
                     518,
                     33,
                     36)
                    bkimage = 'object/ui/common/btn_left.img'

                    def OnClick(this):
                        global PawnGoodsPos
                        if ((not ShowMyPawned) and RequestGetPawnGoodsbyID(CurrentPawnItemID, 1)):
                            pass
                        PlaySound(soundUI, 1)
                        Win_EnableWidget((uiPawnShopDlg + '.Left'), 0)
                        Win_Timer((uiPawnShopDlg + '.Left'), 3000)



                    def OnTimer(this):
                        Win_Timer(this, 0)
                        Win_EnableWidget((uiPawnShopDlg + '.Left'), 1)



                class Right(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = ((700 - 68),
                     518,
                     33,
                     36)
                    bkimage = 'object/ui/common/btn_right.img'

                    def OnClick(this):
                        global PawnGoodsPos
                        if ((not ShowMyPawned) and RequestGetPawnGoodsbyID(CurrentPawnItemID, 2)):
                            pass
                        PlaySound(soundUI, 1)
                        Win_EnableWidget((uiPawnShopDlg + '.Right'), 0)
                        Win_Timer((uiPawnShopDlg + '.Right'), 3000)



                    def OnTimer(this):
                        Win_Timer(this, 0)
                        Win_EnableWidget((uiPawnShopDlg + '.Right'), 1)



                class PawnGoodsPage:
                    __module__ = __name__
                    type = 'NUMLABEL'
                    rect = (508,
                     522,
                     80,
                     24)
                    bkimage = 'object/ui/common/number2.img'
                    textstyle = dt_center
                    textsize = 16
                    textwidth = 19
                    textheight = 24

                class MyStorage(TButton):
                    __module__ = __name__
                    rect = (497,
                     38,
                     76,
                     31)
                    bkimage = 'object/ui/deal/mystoragebtn.img'

                    def OnClick(this):
                        global IsShowStorageDlg
                        print 'MyStorage onclick'
                        doUI((uiPawnShopDlg + '.crossBtn'), 'OnClick')
                        doUI('UI.selRoom.shopBtn', 'OnClick')
                        IsShowStorageDlg = 1
                        PlaySound(soundUI, 1)



                class Commit(TButton):
                    __module__ = __name__
                    rect = (387,
                     38,
                     76,
                     31)
                    bkimage = 'object/ui/deal/commitbtn.img'

                    def OnClick(this):
                        print 'Commit click'
                        updateMyStorageInPawn()
                        ui_setCapture((uiPawnShopDlg + '.CommitPanel'))
                        PlaySound(soundUI, 1)



                class CommitPanel(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = 999999
                    rect = (15,
                     45,
                     346,
                     513)
                    bkimage = 'object/ui/deal/commitpanel.img'
                    class children:
                        __module__ = __name__
                        __doc__ = "class confirmBtn(TButton):\n                            initlayer = 999999\n                            rect = (140,466, 76, 31)\n                            bkimage = 'object/ui/deal/confirmbtn.img'\n                            def OnClick(this):\n                                Win_ShowWidget( uiPawnShopDlg+'.CommitPanel', 0)\n                                Win_SetCheck(uiPawnShopDlg + '.pawnedBtn',0)\n                                Win_SetCheck(uiPawnShopDlg + '.pawningBtn',1)\n                                ui_updatePawnTypeList()\n                                PlaySound( soundUI, 1)"
                        class cancelBtn(TButton):
                            __module__ = __name__
                            initlayer = 999999
                            rect = ((230 + 20),
                             466,
                             76,
                             31)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/common/btn_close.img'

                            def OnClick(this):
                                Win_ShowWidget((uiPawnShopDlg + '.CommitPanel'), 0)
                                Win_SetCheck((uiPawnShopDlg + '.pawnedBtn'), 0)
                                Win_SetCheck((uiPawnShopDlg + '.pawningBtn'), 1)
                                ui_updatePawnTypeList()
                                PlaySound(soundUI, 1)



                        class storageDescription:
                            __module__ = __name__
                            type = 'DYLABEL'
                            initlayer = 99999
                            rect = (0,
                             0,
                             130,
                             1)
                            captionrect = (4,
                             4,
                             120,
                             1)
                            bkimage = 'object/ui/common/img_tip.img'
                            textEdgeType = -1
                            drawcolor = maskColor

                        class funcItem0(TRadio):
                            __module__ = __name__
                            groupid = 3
                            groupstop = 0
                            rect = (35,
                             265,
                             53,
                             53)
                            dragtype = 7
                            bkimage = 'object/ui/storage/img_choose.img'
                            framescheme = [(-1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1,
                              -1),
                             (0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0)]
                            tipwidget = (uiPawnShopDlg + '.CommitPanel.storageDescription')

                            def OnClick(this):
                                global CurrentPropIdx
                                me = Win_GetFocusPath()
                                CurrentPropIdx = ((Win_GetScrollPos((uiPawnShopDlg + '.CommitPanel.StorageScroll')) * 4) + getTailNum(me))
                                if (g_MyDealStorageList.at(CurrentPropIdx) == None):
                                    return 
                                print ('CurrentPropIdx = %d' % CurrentPropIdx)
                                if (check12 and Win_SetCheck((uiPawnShopDlg + '.CommitPanel.PawnSettings.halfday'), 1)):
                                    Win_SetCheck((uiPawnShopDlg + '.CommitPanel.PawnSettings.aday'), 0)
                                ui_setCapture((uiPawnShopDlg + '.CommitPanel.PawnSettings'))
                                Win_SetFocus((uiPawnShopDlg + '.CommitPanel.PawnSettings.srcBill'))



                            def OnMouseMoveIn():
                                me = Win_GetMyPath()
                                idx = ((Win_GetScrollPos((uiPawnShopDlg + '.CommitPanel.StorageScroll')) * 4) + getTailNum(me))
                                if (idx >= MyDealStorageListCnt):
                                    return 
                                info = g_MyDealStorageList.at(idx)
                                ui = (uiPawnShopDlg + '.CommitPanel.storageDescription')
                                Win_SetText(ui, ((info.m_szName + '\n') + info.m_szDescrip))
                                winrect = Win_GetRect(me, value_channel_winrect)
                                caprect = Win_GetRect(ui, value_channel_captionrect)
                                Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))


                            class children:
                                __module__ = __name__
                                class itemPic(TStatic):
                                    __module__ = __name__
                                    rect = (0,
                                     0,
                                     53,
                                     53)
                                    bkImgFlag = dt_center

                                class itemNum(TLabel):
                                    __module__ = __name__
                                    rect = (30,
                                     40,
                                     24,
                                     12)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor



                        class funcItem1(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 1)),
                             265,
                             53,
                             53)
                            groupstop = 1

                        class funcItem2(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 2)),
                             265,
                             53,
                             53)
                            groupstop = 2

                        class funcItem3(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 3)),
                             265,
                             53,
                             53)
                            groupstop = 3

                        class funcItem4(funcItem0):
                            __module__ = __name__
                            rect = (35,
                             (265 + (63 * 1)),
                             53,
                             53)
                            groupstop = 4

                        class funcItem5(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 1)),
                             (265 + (63 * 1)),
                             53,
                             53)
                            groupstop = 5

                        class funcItem6(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 2)),
                             (265 + (63 * 1)),
                             53,
                             53)
                            groupstop = 6

                        class funcItem7(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 3)),
                             (265 + (63 * 1)),
                             53,
                             53)
                            groupstop = 7

                        class funcItem8(funcItem0):
                            __module__ = __name__
                            rect = (35,
                             (265 + (63 * 2)),
                             53,
                             53)
                            groupstop = 8

                        class funcItem9(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 1)),
                             (265 + (63 * 2)),
                             53,
                             53)
                            groupstop = 9

                        class funcItem10(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (63 * 2)),
                             (265 + (63 * 2)),
                             53,
                             53)
                            groupstop = 10

                        class funcItem11(funcItem0):
                            __module__ = __name__
                            rect = ((35 + (62 * 3)),
                             (265 + (63 * 2)),
                             53,
                             53)
                            groupstop = 11

                        class StorageScroll(TVScroll):
                            __module__ = __name__
                            rect = (305,
                             261,
                             26,
                             192)
                            pos = 0

                            def OnPosChange():
                                Win_SetRange((uiPawnShopDlg + '.CommitPanel.StorageScroll'), ((((MyDealStorageListCnt - defStorageInPawnCnt) + 1) / 4) + 1))
                                pos = Win_GetPos((uiPawnShopDlg + '.CommitPanel.StorageScroll'))
                                for i in range(defStorageInPawnCnt):
                                    ui = (uiPawnShopDlg + ('.CommitPanel.funcItem%d' % i))
                                    info = g_MyDealStorageList.at((i + (pos * 4)))
                                    if ((None == info) and Win_SetImg((ui + '.itemPic'), '')):
                                        Win_SetText((ui + '.itemNum'), '')



                            class children:
                                __module__ = __name__
                                class blockbtn(TScrollBtn):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      0,
                                      0,
                                      1,
                                      1,
                                      0,
                                      0)]
                                    rect = (2,
                                     0,
                                     26,
                                     42)
                                    bkimage = 'object/ui/common/scl_block.img'

                                class spinup(TSpinDec):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (6,
                                     -17,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_up.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)



                                class spindown(TSpinInc):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (6,
                                     192,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_down.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)





                        class PawnSettings(TStatic):
                            __module__ = __name__
                            visible = 0
                            initlayer = 999999
                            rect = (60,
                             140,
                             226,
                             132)
                            bkimage = 'object/ui/deal/pawnSettingPanel.img'

                            def OnInit():
                                print 'PawnSettings OnInit'


                            class children:
                                __module__ = __name__
                                class confirm(TButton):
                                    __module__ = __name__
                                    initlayer = 999999
                                    rect = (65,
                                     90,
                                     43,
                                     31)
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    bkimage = 'object/ui/common/btn_confirm.img'

                                    def OnClick(this):
                                        global check12
                                        info = g_MyDealStorageList.at(CurrentPropIdx)
                                        iteminfo = info.m_stItem
                                        itemname = info.m_szName
                                        price = int(Win_GetText((uiPawnShopDlg + '.CommitPanel.PawnSettings.srcBill')))
                                        Num = int(Win_GetText((uiPawnShopDlg + '.CommitPanel.PawnSettings.SaleNum')))
                                        if (((not CHECK_PET(info.m_stItem.m_nItemID)) and (Num > info.m_stItem.m_iNumOfItem)) and ui_msgBox(3)):
                                            Win_ShowMsgBox('\xc4\xfa\xc7\xeb\xc7\xf3\xbc\xc4\xca\xdb\xb5\xc4\xca\xfd\xc1\xbf\xd2\xd1\xbe\xad\xb3\xac\xb9\xfd\xc1\xcb\xc4\xfa\xcb\xf9\xd3\xb5\xd3\xd0\xb5\xc4\xca\xfd\xc1\xbf', '', 3, 'UI.SysMsgbox', -1)
                                            return 
                                        interval = 24
                                        check12 = 0
                                        if Win_IsChecked((uiPawnShopDlg + '.CommitPanel.PawnSettings.halfday')):
                                            interval = 12
                                            check12 = 1
                                        if ((price == 0) or ((Num == 0) or (iteminfo.m_nItemID == 0))):
                                            return 
                                        PrepareCommititem = [iteminfo.m_nItemID,
                                         itemname,
                                         price,
                                         Num,
                                         interval,
                                         0]
                                        print ('PrepareCommititem%(1)d,%(2)s,%(3)d,%(4)d,%(5)d' % {'1': iteminfo.m_nItemID,
                                         '2': itemname,
                                         '3': price,
                                         '4': Num,
                                         '5': interval})
                                        RequestCommitGoods2Pawn(Commit2Pawn, PrepareCommititem)
                                        Win_ShowWidget((uiPawnShopDlg + '.CommitPanel.PawnSettings'), 0)
                                        PlaySound(soundUI, 1)



                                class cancel(TButton):
                                    __module__ = __name__
                                    initlayer = 999999
                                    rect = (140,
                                     90,
                                     43,
                                     31)
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    bkimage = 'object/ui/common/btn_cancel.img'

                                    def OnClick(this):
                                        Win_ShowWidget((uiPawnShopDlg + '.CommitPanel.PawnSettings'), 0)
                                        PlaySound(soundUI, 1)



                                class srcBill(TEditID):
                                    __module__ = __name__
                                    initlayer = 999999
                                    maxchar = 9
                                    rect = (89,
                                     14,
                                     77,
                                     14)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    captionrect = (0,
                                     2,
                                     77,
                                     14)
                                    textstyle = dt_right
                                    caption = '0.0'

                                    def OnTab():
                                        Win_SetFocus((uiPawnShopDlg + '.CommitPanel.PawnSettings.SaleNum'))



                                class SaleNum(TEditID):
                                    __module__ = __name__
                                    initlayer = 999999
                                    maxchar = 4
                                    rect = (103,
                                     39,
                                     36,
                                     14)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    captionrect = (0,
                                     2,
                                     36,
                                     14)
                                    textstyle = dt_right
                                    caption = '0.0'

                                    def OnTab():
                                        Win_SetFocus((uiPawnShopDlg + '.CommitPanel.PawnSettings.halfday'))



                                class halfday(TRadio):
                                    __module__ = __name__
                                    rect = (88,
                                     60,
                                     23,
                                     17)
                                    bkimage = 'object/ui/common/btn_ratio.img'
                                    framescheme = [(-1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1),
                                     (0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0)]
                                    bkimagepos = (0,
                                     5)
                                    tipwidget = (uiModifyRoomDlg + '.chooseTip')
                                    groupstop = 1

                                    def OnTab():
                                        Win_SetFocus((uiPawnShopDlg + '.CommitPanel.PawnSettings.aday'))



                                class aday(TRadio):
                                    __module__ = __name__
                                    rect = (148,
                                     60,
                                     23,
                                     17)
                                    bkimage = 'object/ui/common/btn_ratio.img'
                                    framescheme = [(-1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1,
                                      -1),
                                     (0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0)]
                                    bkimagepos = (0,
                                     5)
                                    tipwidget = (uiModifyRoomDlg + '.chooseTip')
                                    groupstop = 2

                                    def OnTab():
                                        Win_SetFocus((uiPawnShopDlg + '.CommitPanel.PawnSettings.srcBill'))





                        class CommittedItem0(TStatic):
                            __module__ = __name__
                            visible = 0
                            initlayer = 999998
                            rect = (21,
                             17,
                             282,
                             32)
                            bkimage = 'object/ui/deal/commiteditem.img'
                            class children:
                                __module__ = __name__
                                class PropName(TLabel,
                                 Static):
                                    __module__ = __name__
                                    rect = (5,
                                     4,
                                     90,
                                     25)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    textEdgeType = 1
                                    textstyle = dt_center
                                    caption = 'abc'

                                class PropNum(TLabel,
                                 Static):
                                    __module__ = __name__
                                    rect = (98,
                                     4,
                                     50,
                                     25)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    textEdgeType = 1
                                    textstyle = dt_center
                                    caption = '123'

                                class interval(TLabel,
                                 Static):
                                    __module__ = __name__
                                    rect = (150,
                                     4,
                                     30,
                                     25)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    textEdgeType = 1
                                    textstyle = dt_center
                                    caption = '12'

                                class price(TLabel,
                                 Static):
                                    __module__ = __name__
                                    rect = (188,
                                     4,
                                     51,
                                     25)
                                    drawcolor = lightColor
                                    textEdgeColor = maskColor
                                    textEdgeType = 1
                                    textstyle = dt_center
                                    caption = '5'

                                class cancel(TButton):
                                    __module__ = __name__
                                    initlayer = 999999
                                    rect = (235,
                                     4,
                                     39,
                                     31)
                                    bkimage = 'object/ui/deal/cancelhorizontal.img'

                                    def OnClick(this):
                                        pos = Win_GetPos((uiPawnShopDlg + '.CommitPanel.CommittedScroll'))
                                        idx = (getMyMidIdx() + pos)
                                        print pos,
                                        print idx
                                        item = g_MyPawnItemList.at(idx)
                                        cancelitem = [item.m_nPropID,
                                         item.m_szPropName,
                                         item.m_nPrice,
                                         item.m_nNum,
                                         item.m_nInterval,
                                         item.m_iSaleIndex]
                                        print item.m_nNum
                                        RequestCommitGoods2Pawn(CancelCommit2Pawn, cancelitem)
                                        PlaySound(soundUI, 1)





                        class CommittedItem1(CommittedItem0):
                            __module__ = __name__
                            rect = (21,
                             (17 + (33 * 1)),
                             282,
                             32)

                        class CommittedItem2(CommittedItem0):
                            __module__ = __name__
                            rect = (21,
                             (17 + (33 * 2)),
                             282,
                             32)

                        class CommittedItem3(CommittedItem0):
                            __module__ = __name__
                            rect = (21,
                             (17 + (33 * 3)),
                             282,
                             32)

                        class CommittedItem4(CommittedItem0):
                            __module__ = __name__
                            rect = (21,
                             (17 + (33 * 4)),
                             282,
                             32)

                        class CommittedItem5(CommittedItem0):
                            __module__ = __name__
                            rect = (21,
                             (17 + (33 * 5)),
                             282,
                             32)

                        class CommittedScroll(TVScroll):
                            __module__ = __name__
                            rect = (305,
                             20,
                             26,
                             192)
                            pos = 0

                            def OnPosChange():
                                scrRange = max((MyPawnItemListCnt - defCommittedCnt), 0)
                                Win_SetRange((uiPawnShopDlg + '.CommitPanel.CommittedScroll'), scrRange)
                                pos = Win_GetPos((uiPawnShopDlg + '.CommitPanel.CommittedScroll'))
                                Cnt = min(defCommittedCnt, MyPawnItemListCnt)
                                for i in range(Cnt):
                                    ui = (uiPawnShopDlg + ('.CommitPanel.CommittedItem%d' % i))
                                    info = g_MyPawnItemList.at((i + pos))
                                    if ((None == info) and Win_SetText((ui + '.PropName'), '')):
                                        Win_SetText((ui + '.PropNum'), '')
                                        Win_SetText((ui + '.interval'), '')
                                        Win_SetText((ui + '.price'), '')
                                        Win_ShowWidget(ui, 0)



                            class children:
                                __module__ = __name__
                                class blockbtn(TScrollBtn):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      0,
                                      0,
                                      1,
                                      1,
                                      0,
                                      0)]
                                    rect = (2,
                                     2,
                                     26,
                                     42)
                                    bkimage = 'object/ui/common/scl_block.img'

                                class spinup(TSpinDec):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (6,
                                     -15,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_up.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)



                                class spindown(TSpinInc):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (6,
                                     191,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_down.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)







                class SearchPropName(TEdit):
                    __module__ = __name__
                    initlayer = 99999
                    rect = (98,
                     44,
                     100,
                     18)
                    captionrect = (0,
                     5,
                     100,
                     12)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    textstyle = (dt_left + dt_bottom)
                    caption = ''
                    maxchar = 30

                    def OnClick(this):
                        Win_SetFocus((uiPawnShopDlg + '.SearchPropName'))



                    def OnTab():
                        Win_SetFocus((uiPawnShopDlg + '.Rank'))



                class Rank(TEditID):
                    __module__ = __name__
                    initlayer = 99999
                    rect = (260,
                     43,
                     24,
                     18)
                    captionrect = (-2,
                     7,
                     26,
                     18)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    textstyle = dt_right
                    maxchar = 3

                    def OnClick(this):
                        Win_SetFocus((uiPawnShopDlg + '.Rank'))



                    def OnTab():
                        Win_SetFocus((uiPawnShopDlg + '.SearchPropName'))



                class updateSearchBtn(TButton):
                    __module__ = __name__
                    rect = (300,
                     38,
                     76,
                     31)
                    bkimage = 'object/ui/deal/updateBtn.img'

                    def OnClick(this):
                        propname = Win_GetText((uiPawnShopDlg + '.SearchPropName'))
                        rank = int(Win_GetText((uiPawnShopDlg + '.Rank')))
                        print ('[updateSearchBtn]propName = %s,rank = %d' % (propname,
                         rank))
                        namelist = [propname,
                         rank]
                        RequestSearchItemByName(namelist)
                        PlaySound(soundUI, 1)



                class residualBill(TEditID):
                    __module__ = __name__
                    editable = 0
                    initlayer = 550001
                    maxchar = 12
                    rect = (684,
                     48,
                     81,
                     16)
                    drawcolor = lightColor
                    textEdgeColor = maskColor
                    captionrect = (2,
                     2,
                     78,
                     16)
                    textstyle = dt_right

                class buyTipDlg(TStatic):
                    __module__ = __name__
                    initlayer = 999999
                    visible = 0
                    rect = (((800 - 368) / 2),
                     ((600 - 326) / 2),
                     368,
                     326)
                    bkimage = 'object/ui/common/dlg_msgBox.img'
                    class children:
                        __module__ = __name__
                        class confirm(TButton):
                            __module__ = __name__
                            rect = (100,
                             280,
                             65,
                             31)
                            bkimage = 'object/ui/common/btn_confirm.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                if ShowMyPawned:
                                    cancelitem = [buyItemInfo[0],
                                     '',
                                     buyItemInfo[1],
                                     buyItemInfo[3],
                                     12,
                                     buyItemInfo[2]]
                                    RequestCommitGoods2Pawn(CancelCommit2Pawn, cancelitem)
                                else:
                                    RequestBuyGoodsInPawnShop(buyItemInfo)
                                Win_ShowWidget((uiPawnShopDlg + '.buyTipDlg'), 0)



                        class cancel(TButton):
                            __module__ = __name__
                            rect = (225,
                             280,
                             65,
                             31)
                            bkimage = 'object/ui/common/btn_cancel.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                Win_ShowWidget((uiPawnShopDlg + '.buyTipDlg'), 0)



                        class prompt(TLabel):
                            __module__ = __name__
                            rect = (42,
                             84,
                             280,
                             130)
                            textEdgeType = -1
                            drawcolor = zoneChooseColor



                class pawnedBtn(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     80,
                     33)
                    hotrect = (271,
                     513,
                     80,
                     33)
                    groupstop = 0
                    initlayer = 600010
                    hotcover = 'object/ui/deal/tab_pawned.img'

                    def OnClick(this):
                        global ShowMyPawned
                        ShowMyPawned = 1
                        ClearWareList()
                        ui_updatePawnTypeList()
                        ui_ShowMyPawnedInWare(0)



                class pawningBtn(TTabWin):
                    __module__ = __name__
                    rect = (0,
                     0,
                     80,
                     33)
                    hotrect = (189,
                     513,
                     80,
                     33)
                    groupstop = 1
                    initlayer = 600010
                    hotcover = 'object/ui/deal/tab_pawning.img'

                    def OnClick(this):
                        global ShowMyPawned
                        ShowMyPawned = 0
                        print 'begin call ui_updatePawnTypeList'
                        ui_updatePawnTypeList()







UI.children.selRoom = UI_children_selRoom

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiSelSect.py`:

```py
defBarNum = 7
defSectNum = 28
sectName = None
chIdx = 0
chAreaIdx = ([0] * 10)
bMatchChannel = 0
sectChkIdx = None
oldPos = 0
zoneList = ['a',
 'b',
 'c']
zoneSpeed = [0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0]
zoneIndex = [0,
 1,
 2,
 3,
 4,
 5,
 6,
 7,
 8,
 9,
 10,
 11,
 12,
 13,
 14,
 15,
 16,
 17,
 18,
 19]
zonePos = 0
defZoneNum = 9
curZone = 0
areaIdx = 0
advert = 3
bClickAdvert = 0
isShowTaskSelDlg = 0
Guide_version = 0
Guide_upper = 0

def SortZonesBySpeed():
    global zoneIndex
    zoneIndex = range(len(zoneList))
    print 'in sort'
    print 'zonespeed',
    print zoneSpeed
    print 'zoneindex',
    print zoneIndex
    for i in range((len(zoneList) - 1)):
        for j in range((i + 1), len(zoneList)):
            if (zoneSpeed[zoneIndex[i]] > zoneSpeed[zoneIndex[j]]):
                t = zoneIndex[i]
                zoneIndex[i] = zoneIndex[j]
                zoneIndex[j] = t


    print 'zoneindex',
    print zoneIndex
    print 'out sort'



def ZoneUIIndex2LogicIndex(uiIndex):
    if (uiIndex >= len(zoneList)):
        return 0
    return zoneIndex[uiIndex]



def NotifyUIRefreshPingZoneResult():
    for i in range(len(zoneList)):
        speed = fetch_ZoneSpeedByZoneName(zoneList[i])
        zoneSpeed[i] = speed

    SortZonesBySpeed()
    doUI('UI.selSect.selServerDlg', 'setList')



def AutoLoginSection():
    doUI('UI.selSect.quickJoin', 'OnClick')



def curZone2areaIdx():
    if (curZone < 0):
        return 0
    areaCnt = Channel().getAreaCnt(chIdx)
    if (curZone >= areaCnt):
        return 0
    sectCnt = Channel().getSectCnt(chIdx, curZone)
    if (sectCnt == 0):
        return 0
    return curZone


class Channel:
    __module__ = __name__

    def getChannelCnt(this):
        return fetch_ChannelCnt()



    def login(this, uin, chIdx, areaIdx, sectIdx):
        global sectName
        sectCnt = this.getSectCnt(chIdx, areaIdx)
        print 'sectCnt=',
        print sectCnt
        info = this.getInfo(sectIdx, sectCnt)
        sectName = info.name
        print 'enter:',
        print sectName
        request_LoginSection(uin, chIdx, areaIdx, sectIdx, curZone)



    def getSectCnt(this, chIdx, areaIdx):
        if ((chIdx >= fetch_ChannelCnt()) or (areaIdx >= sc_getZoneCnt(chIdx))):
            return 0
        return GetSectionCnt(chIdx, areaIdx)



    def getAreaCnt(this, chIdx):
        return sc_getZoneCnt(chIdx)



    def getAreaName(this, chIdx, areaIdx):
        return sc_getZoneName(chIdx, areaIdx)



    def getInfo(this, sectIdx, sectCnt):

        def get(sectIdx, sectCnt):
            if (sectIdx >= sectCnt):
                return None
            info = CNil()
            si = GetSectionInfo(chIdx, areaIdx, sectIdx)
            info.name = si.m_szSectionName
            if ('"' == info.name[0]):
                info.name = info.name[1:]
            while (('"' == info.name[-1]) or (' ' == info.name[-1])):
                info.name = info.name[:-1]

            info.playerNum = (str(si.m_nCurrentNumOfPlayer) + '\xc8\xcb')
            info.fillRate = min(defBarNum, (1 + ((defBarNum * si.m_nCurrentNumOfPlayer) / si.m_nMaxNumOfPlayer)))
            info.isRed = (si.m_nCurrentNumOfPlayer >= (si.m_nMaxNumOfPlayer * 0.90000000000000002))
            if (0 == si.m_nCurrentNumOfPlayer):
                info.fillRate = 0
            return info



        def getFake(sectIdx, sectCnt):
            if (sectIdx >= sectCnt):
                return None
            info = CNil()
            info.name = ('sect name %d' % sectIdx)
            info.playerNum = (str(Rand(10)) + '\xc8\xcb')
            info.fillRate = (1 + Rand(defBarNum))
            return info


        return get(sectIdx, sectCnt)




def restoreMovedSect():
    global sectChkIdx
    if ((sectChkIdx != None) and Win_SetCheck(('UI.selSect.sect%d' % sectChkIdx), False)):
        sectChkIdx = None



def ui_SetGuideInfo(version, upper):
    global Guide_version
    global Guide_upper
    Guide_version = version
    Guide_upper = upper



def ui_GetGuideUpper():
    return Guide_upper


class UI_children_selSect:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)
    bkimage = 'object/ui/bg/bg_selSect.img'
    accel = (('OnAccel_OnF1',
      112,
      0,
      0,
      0),
     ('OnAccel_OnF2',
      113,
      0,
      0,
      0),
     ('OnAccel_OnF3',
      114,
      0,
      0,
      0),
     ('OnAccel_OnF6',
      117,
      0,
      0,
      0),
     ('OnAccel_OnF7',
      118,
      0,
      0,
      0),
     ('OnAccel_OnF8',
      119,
      0,
      0,
      0),
     ('OnAccel_OnF9',
      120,
      0,
      0,
      0),
     ('OnAccel_OnF10',
      121,
      0,
      0,
      0),
     ('OnAccel_OnF12',
      123,
      0,
      0,
      0))

    def OnAccel_OnF1():
        doUI('UI.selSect.helpBtn', 'OnClick')



    def OnAccel_OnF2():
        if ((not Win_IsVisible('UI.SysMsgbox')) and doUI('UI.selSect.quickJoin', 'OnClick')):
            sc_HideWeb('party')



    def OnEnter():
        doUI('UI.selRoom.chatArea.sendBtn', 'OnClick')



    def OnEscape():
        doUI('UI.selSect.leaveBtn', 'OnClick')
        return 1



    def OnInit():
        global curZone
        global bClickAdvert
        global areaIdx
        global zoneList
        global isShowTaskSelDlg
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        sc_HideWeb('kinMatch')
        sc_HideWeb('kinTeam')
        Win_ShowWidget(uiMenuDlg, 0)
        if bClickAdvert:
            bClickAdvert = 0
            JumpHelpWeb('http://qqtang.qq.com')
            sc_web_close()
        Win_Timer('UI.selSect.tipChannel', 5000)
        screenStartIn()
        zoneList = fetch_ZoneNames()
        curZone = fetch_LastZoneIdx()
        areaIdx = curZone2areaIdx()
        if (curZone < 0):
            curZone = 0
            doUI('UI.selSect.selZoneBtn', 'OnClick')
        if bMatchChannel:
            chIdx = 3
        else:
            chIdx = min(fetch_LastChannelIdx(), (Channel().getChannelCnt() - 1))
        Win_SelectSelf(('UI.selSect.channel%d' % (chIdx + 1)))
        Win_SetFocus(('UI.selSect.channel%d' % (chIdx + 1)))
        s = ("doUI( 'UI.selSect.channel%d', 'OnClick')" % (chIdx + 1))
        exec s
        PlayMusic(musicDirAndSection, -1)
        isShowTaskSelDlg = 0



    def OnDenit():
        Win_Timer('UI.selSect.bannerBtn', 0)


    class children:
        __module__ = __name__
        class advertBtn(TButton):
            __module__ = __name__
            initlayer = 9999
            rect = (15,
             52,
             320,
             200)
            framescheme = [(0,
              99,
              0,
              99,
              0,
              99,
              0,
              99)]

            def OnClick(this):
                sc_HideWeb('party')
                url = GetCurAdvert()
                ui_jumpWeb(url)



        class billboard:
            __module__ = __name__
            type = 'MULTIEDIT'
            initlayer = 99999
            rowspace = 2
            editable = 0
            rect = (28,
             255,
             300,
             335)
            drawcolor = (255,
             221,
             214,
             255)
            textEdgeType = -1
            caption = ('    \xca\xca\xb6\xc8\xd3\xce\xcf\xb7\xa3\xac\xd3\xd0\xd2\xe6\xbd\xa1\xbf\xb5   \n\n' + '    QQ\xcc\xc3\xa3\xac \xbc\xb4\xbd\xab\xcd\xc6\xb3\xf6!')

            def OnClickHLink(url):
                ui_jumpWeb(url)



        class startPractice(TButton):
            __module__ = __name__
            rect = (379,
             513,
             51,
             74)
            bkimage = 'object/ui/selSect/btn_practice.img'

            def OnClick(this):
                global practiceMode
                print 'Enter StartPractice'
                restoreMovedSect()
                sectCnt = Channel().getSectCnt(chIdx, areaIdx)
                print 'sectCnt=',
                print sectCnt
                if (sectCnt > 0):
                    sectIdx = Rand(sectCnt)
                    print 'LoginSection',
                    print uin,
                    print chIdx,
                    print sectIdx
                    Channel().login(uin, chIdx, areaIdx, sectIdx)
                    PlaySound(soundMain, 1)
                    practiceMode = 1
                else:
                    PlaySound(soundFail, 1)



        class selZoneBtn(TButton):
            __module__ = __name__
            rect = (445,
             513,
             51,
             74)
            bkimage = 'object/ui/selSect/btn_selZone.img'

            def OnClick(this):
                global zoneList
                areaCnt = Channel().getAreaCnt(chIdx)
                zoneList = fetch_ZoneNames()
                ui_setCapture('UI.selSect.selServerDlg')
                doUI('UI.selSect.selServerDlg', 'setList')
                PlaySound(soundLeave, 1)
                SC_PingZones()



        class quickJoin(TButton):
            __module__ = __name__
            rect = (511,
             513,
             51,
             74)
            bkimage = 'object/ui/selSect/btn_quickJoin.img'

            def OnClick(this):
                restoreMovedSect()
                sectCnt = Channel().getSectCnt(chIdx, areaIdx)
                if (sectCnt > 0):
                    sectIdx = Rand(sectCnt)
                    print 'LoginSection',
                    print uin,
                    print chIdx,
                    print sectIdx
                    Channel().login(uin, chIdx, areaIdx, sectIdx)
                    PlaySound(soundMain, 1)
                else:
                    PlaySound(soundFail, 1)



        class sysSetupBtn(TButton):
            __module__ = __name__
            rect = (577,
             513,
             51,
             74)
            bkimage = 'object/ui/selSect/btn_sysSetup.img'

            def OnClick(this):
                go2setup(uin)



        class leaveBtn(TButton):
            __module__ = __name__
            rect = (717,
             520,
             52,
             48)
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            bkimage = 'object/ui/common/btn_quit.img'

            def OnClick(this):
                LogoutSection(uin)
                PlaySound(soundLeave, 1)
                Quit()



        class channel1(TRadio):
            __module__ = __name__
            framescheme = [(0,
              0,
              0,
              0,
              0,
              0,
              0,
              0),
             (1,
              1,
              1,
              1,
              1,
              1,
              1,
              1)]
            rect = (385,
             59,
             72,
             37)
            bkimage = 'object/ui/selSect/tab_practice.img'
            groupstop = 1

            def OnClick(this):
                global chIdx
                global areaIdx
                global isAutoJustScrollPos
                global bMatchChannel
                me = Win_GetFocusPath()
                restoreMovedSect()
                chIdx = (int(me[-1]) - 1)
                if (chIdx != 3):
                    bMatchChannel = 0
                areaIdx = curZone2areaIdx()
                Win_SetScrollPos('UI.selSect.scroll', 0)
                isAutoJustScrollPos = True
                doUI('UI.selSect.scroll', 'OnPosChange')
                sc_HideWeb('party')



        class channel2(channel1):
            __module__ = __name__
            rect = (454,
             58,
             72,
             37)
            bkimage = 'object/ui/selSect/tab_greenhand.img'
            groupstop = 2

        class channel3(channel1):
            __module__ = __name__
            rect = (524,
             58,
             72,
             37)
            bkimage = 'object/ui/selSect/tab_freedom.img'
            groupstop = 3

        class channel4(channel1):
            __module__ = __name__
            rect = (593,
             58,
             72,
             37)
            groupstop = 4
            bkimage = 'object/ui/selSect/tab_match.img'

        class channel5(channel1):
            __module__ = __name__
            rect = (661,
             59,
             72,
             37)
            groupstop = 5
            bkimage = 'object/ui/selSect/tab_party.img'

            def OnClick(this):
                sc_ShowWeb('party', 364, 95, 426, 495, 'http://qqtang.qq.com/game/event.htm')



        class scroll(TVScroll):
            __module__ = __name__
            rect = (768,
             92,
             26,
             360)
            pos = 0
            pagesize = -defSectNum

            def OnPosChange():
                global isAutoJustScrollPos
                global oldPos
                wCh = 'UI.selSect'
                sectCnt = Channel().getSectCnt(chIdx, areaIdx)
                Win_SetRange((wCh + '.scroll'), (((sectCnt - defSectNum) + 1) / 2))
                if isAutoJustScrollPos:
                    isAutoJustScrollPos = False
                    Win_SetScrollPos((wCh + '.scroll'), 0)
                    redList = []
                    for i in range(sectCnt):
                        info = Channel().getInfo(i, sectCnt)
                        redList.append(info.isRed)

                    saveRedCnt = 999
                    savePos = -1
                    for i in range(((sectCnt - defSectNum) + 1)):
                        redCnt = 0
                        for k in range(defSectNum):
                            if redList[(i + k)]:
                                redCnt += 1

                        if (redCnt > (defSectNum / 2)):
                            if (redCnt < saveRedCnt):
                                saveRedCnt = redCnt
                                savePos = i

                    if ((savePos != -1) and Win_SetScrollPos((wCh + '.scroll'), savePos)):
                        pass
                pos = Win_GetPos((wCh + '.scroll'))
                if ((pos != oldPos) and PlaySound(soundUI, 1)):
                    oldPos = pos
                for i in range(defSectNum):
                    sect = ((wCh + '.sect') + str((i + 1)))
                    info = Channel().getInfo((i + (pos * 2)), sectCnt)
                    if ((None == info) and Win_EnableWidget(sect, 0)):
                        Win_SetText((sect + '.name'), '')
                        Win_ShowWidget((sect + '.serverState'), 0)



            class children:
                __module__ = __name__
                class blockbtn(TScrollBtn):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      1,
                      1,
                      0,
                      0)]
                    rect = (0,
                     0,
                     26,
                     42)
                    bkimage = 'object/ui/common/scl_block.img'



        class sect1(TRadio):
            __module__ = __name__
            groupid = 5
            groupstop = 1
            rect = (383,
             97,
             187,
             26)
            bkimage = 'object/ui/selSect/img_sect.img'
            framescheme = [(-1,
              -1,
              0,
              0,
              -1,
              -1,
              -1,
              -1)]

            def OnClick(this):
                global practiceMode
                me = Win_GetFocusPath()
                if (('' == Win_GetText((me + '.name'))) and PlaySound(soundFail, 1)):
                    return 
                sectIdx = (((Win_GetScrollPos('UI.selSect.scroll') * 2) + getTailNum(me)) - 1)
                print 'LoginSection',
                print uin,
                print chIdx,
                print sectIdx
                Channel().login(uin, chIdx, areaIdx, sectIdx)
                PlaySound(soundMain, 1)
                practiceMode = 0


            class children:
                __module__ = __name__
                class name(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (20,
                     8,
                     150,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeColor = maskColor

                class serverState(TStatic):
                    __module__ = __name__
                    rect = (100,
                     6,
                     63,
                     14)
                    bkimage = 'object/ui/selSect/img_state.img'



        class sect2(sect1):
            __module__ = __name__
            rect = (580,
             97,
             187,
             26)
            groupstop = 2

        class sect3(sect1):
            __module__ = __name__
            rect = (383,
             (97 + 29),
             187,
             26)
            groupstop = 3

        class sect4(sect1):
            __module__ = __name__
            rect = (580,
             (97 + 29),
             187,
             26)
            groupstop = 4

        class sect5(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 2)),
             187,
             26)
            groupstop = 5

        class sect6(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 2)),
             187,
             26)
            groupstop = 6

        class sect7(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 3)),
             187,
             26)
            groupstop = 7

        class sect8(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 3)),
             187,
             26)
            groupstop = 8

        class sect9(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 4)),
             187,
             26)
            groupstop = 9

        class sect10(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 4)),
             187,
             26)
            groupstop = 10

        class sect11(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 5)),
             187,
             26)
            groupstop = 11

        class sect12(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 5)),
             187,
             26)
            groupstop = 12

        class sect13(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 6)),
             187,
             26)
            groupstop = 13

        class sect14(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 6)),
             187,
             26)
            groupstop = 14

        class sect15(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 7)),
             187,
             26)
            groupstop = 15

        class sect16(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 7)),
             187,
             26)
            groupstop = 16

        class sect17(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 8)),
             187,
             26)
            groupstop = 17

        class sect18(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 8)),
             187,
             26)
            groupstop = 18

        class sect19(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 9)),
             187,
             26)
            groupstop = 19

        class sect20(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 9)),
             187,
             26)
            groupstop = 20

        class sect21(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 10)),
             187,
             26)
            groupstop = 21

        class sect22(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 10)),
             187,
             26)
            groupstop = 22

        class sect23(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 11)),
             187,
             26)
            groupstop = 23

        class sect24(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 11)),
             187,
             26)
            groupstop = 24

        class sect25(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 12)),
             187,
             26)
            groupstop = 25

        class sect26(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 12)),
             187,
             26)
            groupstop = 26

        class sect27(sect1):
            __module__ = __name__
            rect = (383,
             (97 + (29 * 13)),
             187,
             26)
            groupstop = 27

        class sect28(sect1):
            __module__ = __name__
            rect = (580,
             (97 + (29 * 13)),
             187,
             26)
            groupstop = 28

        class tipChannel:
            __module__ = __name__
            visible = 0
            type = 'DYLABEL'
            initlayer = 99999
            bkimage = 'object/ui/common/img_tip.img'
            rect = (550,
             40,
             130,
             1)
            captionrect = (4,
             4,
             120,
             1)
            drawcolor = maskColor
            textEdgeType = -1

            def OnInit():
                Win_SetText('UI.selSect.tipChannel', '  \xc7\xeb\xd1\xa1\xd4\xf1\xba\xcf\xca\xca\xb5\xc4\xc6\xb5\xb5\xc0')



            def OnTimer(this):
                if ((Win_GetCurScreen() == 'selSect') and Win_ShowWidget(this, (not Win_IsVisible(this)))):
                    pass
                Win_Timer(this, 5000)



        class selServerDlg(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (500,
             200,
             229,
             331)
            bkimage = 'object/ui/selSect/dlg_selServer.img'

            def OnEnter():
                doUI('UI.selSect.selServerDlg.confirm', 'OnClick')



            def setList():
                for i in range(9):
                    ui = ('UI.selSect.selServerDlg.zone' + str(i))
                    Win_SetValue(ui, 0, value_channel_draw_flag)
                    if (((i + zonePos) >= len(zoneList)) and Win_ShowWidget(ui, 0)):
                        pass



            class children:
                __module__ = __name__
                class scroll(TVScroll):
                    __module__ = __name__
                    rect = (178,
                     60,
                     26,
                     200)
                    pos = 0

                    def OnPosChange():
                        global zonePos
                        ui = 'UI.selSect.selServerDlg'
                        zoneCnt = Channel().getAreaCnt(chIdx)
                        Win_SetRange((ui + '.scroll'), max((zoneCnt - defZoneNum), 0))
                        pos = Win_GetPos((ui + '.scroll'))
                        if ((pos != zonePos) and PlaySound(soundUI, 1)):
                            zonePos = pos
                        doUI(ui, 'setList')


                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              1,
                              1,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             41)
                            bkimage = 'object/ui/common/scl_block.img'



                class confirm(TButton):
                    __module__ = __name__
                    rect = (90,
                     285,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global areaIdx
                        global isAutoJustScrollPos
                        Win_ShowWidget('UI.selSect.selServerDlg', 0)
                        areaIdx = curZone2areaIdx()
                        isAutoJustScrollPos = True
                        Win_SetScrollPos('UI.selSect.scroll', 0)
                        doUI('UI.selSect.scroll', 'OnPosChange')



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (200,
                     4,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.selSect.selServerDlg', False)
                        PlaySound(soundLeave, 1)



                class zone0(TRadio):
                    __module__ = __name__
                    bkcolor = (222,
                     255,
                     36,
                     255)
                    rect = (28,
                     57,
                     142,
                     22)
                    bkimage = 'object/ui/selSect/btn_choose.img'
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      -1,
                      -1)]
                    groupstop = 0

                    def OnClick(this):
                        global curZone
                        curZone = ZoneUIIndex2LogicIndex((getMyIdx() + zonePos))
                        doUI('UI.selSect.selServerDlg', 'setList')
                        me = Win_GetMyPath()
                        PlaySound(soundUI, 1)



                    def OnDBClick():
                        curZone = ZoneUIIndex2LogicIndex((getMyIdx() + zonePos))
                        me = Win_GetMyPath()
                        doUI('UI.selSect.selServerDlg.confirm', 'OnClick')


                    class children:
                        __module__ = __name__
                        class name(TLabel,
                         Static):
                            __module__ = __name__
                            textstyle = (dt_center + dt_vcenter)
                            rect = (0,
                             0,
                             100,
                             22)
                            drawcolor = (255,
                             255,
                             255,
                             255)

                        class speedicon(TStatic):
                            __module__ = __name__
                            rect = (100,
                             4,
                             40,
                             22)
                            bkimage = 'res/uiRes/selSect/netspeed_test.img'



                class zone1(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 1)),
                     142,
                     22)
                    groupstop = 1

                class zone2(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 2)),
                     142,
                     22)
                    groupstop = 2

                class zone3(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 3)),
                     142,
                     22)
                    groupstop = 3

                class zone4(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 4)),
                     142,
                     22)
                    groupstop = 4

                class zone5(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 5)),
                     142,
                     22)
                    groupstop = 5

                class zone6(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 6)),
                     142,
                     22)
                    groupstop = 6

                class zone7(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 7)),
                     142,
                     22)
                    groupstop = 7

                class zone8(zone0):
                    __module__ = __name__
                    rect = (28,
                     (57 + (23 * 8)),
                     142,
                     22)
                    groupstop = 8





UI.children.selSect = UI_children_selSect

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiShop.py`:

```py
isDispNotBuy = False
curMoneyType = 'QB'
defWareCnt = 12
isAllowMixedPay = 1
isAllowQBMixedPay = 1
isAllowPresentMixedPay = 1
removeItemID = 0
curDispWares = ([0] * 12)
wareIDs = []
buyModes = []
itemType = 2
itemSubType = 1
itemCnt = 0
itemPos = [0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0]
disableItemCnt = 0
disableItemPos = 0
activeItemInRecycler = 999999
defRecyclerCnt = 9
g_curLightSpeed = 0
myItemType = 2
myItemLastSelect = -1
bClickSaveEquip = 0
warePos = [[0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0],
 [0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0]]
noneCheck = [[-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1],
 [-1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1]]
wareCheck = noneCheck
Affectionlist = [0,
 0,
 0,
 0,
 0,
 0]
useAffections = {'1': None,
 '2': None,
 '3': None,
 '4': None,
 '5': None,
 '6': None}
useItems = {'platform': None,
 'item': None,
 'card': None,
 'bomb': None,
 'huanying': None,
 'bg': None,
 'frame': None,
 'enter': None,
 'cap': None,
 'fhadorn': None,
 'bhadorn': None,
 'thadorn': None,
 'hair': None,
 'mask': None,
 'eye': None,
 'mouth': None,
 'ear': None,
 'cloth': None,
 'cladorn': None,
 'fpack': None,
 'npack': None,
 'leg': None,
 'foot': None,
 'egg': None,
 'tool': None,
 'costume': None,
 'namecard': None,
 'footprint': None,
 'namecardbound': None,
 'xeffect': None,
 'feffect': None,
 'body': None}
selectedItems = {'bomb': None,
 'huanying': None,
 'bg': None,
 'frame': None,
 'enter': None,
 'cap': None,
 'fhadorn': None,
 'bhadorn': None,
 'thadorn': None,
 'hair': None,
 'mask': None,
 'eye': None,
 'mouth': None,
 'ear': None,
 'cloth': None,
 'cladorn': None,
 'fpack': None,
 'npack': None,
 'leg': None,
 'foot': None,
 'namecard': None,
 'footprint': None,
 'namecardbound': None}
type2MyType = {'bomb': 3,
 'huanying': 3,
 'bg': 3,
 'frame': 3,
 'enter': 3,
 'cap': 4,
 'fhadorn': 4,
 'bhadorn': 4,
 'thadorn': 4,
 'hair': 4,
 'mask': 4,
 'eye': 4,
 'mouth': 4,
 'ear': 4,
 'cloth': 4,
 'cladorn': 4,
 'fpack': 4,
 'npack': 4,
 'leg': 4,
 'foot': 4,
 'namecard': 3,
 'footprint': 4,
 'namecardbound': 3}
g_ItemsNotPreview = ('xeffect',
 'feffect',
 'platform',
 'item',
 'card')
g_ItemsPreview = ('footprint',
 'bomb',
 'huanying')
fruitState = 0
validateState = 0
isStorageVisible = 0
forgeTypeCnt = 0
forgeItemCnt = 0
forgeMeterialCnt = 0
forgeExpand = -1
forgeItemID = 0
defForgeCnt = 16
defForgeMeterCnt = 7
composeTypeCnt = 0
composeItemCnt = 0
composeExpand = -1
composeItemID = 0
defComposeCnt = 16
defComposeMeterCnt = 3
tasksIdList = []
currentTaskIdx = 0
currentEggId = 0
secrecyValidateID = 1
questionCnt = 3
questionNum = 3
currentQuestionID = 0
currentQuestionID1 = 0
currentQuestionID2 = 1
questionIDList = ['1',
 '2',
 '3']
answerList = ['',
 '',
 '']
coorList = ['0',
 '0',
 '0']
coorNum = 3
coorSize = 2
from time import time

def setNudeState():
    global useItems
    for type in equipMap.keys():
        if ((useItems[type] != None) and shopPlayer_wear(type, 0, 0, 0)):
            pass

    for type in g_ItemsPreview:
        if ((useItems[type] != None) and shopPlayer_wear(type, 0, 0, 0)):
            pass

    Win_SetImg('UI.shop.preview.bg', '')
    Win_SetImg('UI.shop.preview.enter', '')
    Win_SetImg('UI.shop.preview.frame', '')
    Win_SetImg('UI.shop.namecardPreview.namecard', '')
    Win_SetImg('UI.shop.namecardPreview.namecardbound', '')
    useItems = {'platform': None,
     'item': None,
     'card': None,
     'bomb': None,
     'huanying': None,
     'bg': None,
     'frame': None,
     'enter': None,
     'cap': None,
     'fhadorn': None,
     'bhadorn': None,
     'thadorn': None,
     'hair': None,
     'mask': None,
     'eye': None,
     'mouth': None,
     'ear': None,
     'cloth': None,
     'cladorn': None,
     'fpack': None,
     'npack': None,
     'leg': None,
     'foot': None,
     'egg': None,
     'tool': None,
     'costume': None,
     'namecard': None,
     'footprint': None,
     'namecardbound': None,
     'xeffect': None,
     'feffect': None,
     'body': None}
    clearChecks()
    for i in range(len(wareCheck)):
        for j in range(len(wareCheck[0])):
            wareCheck[i][j] = -1





def clearChecks():
    for i in range(defWareCnt):
        Win_SetCheck(('UI.shop.ware%d' % (i + 1)), False)
        Win_ShowWidget((('UI.shop.ware%d' % (i + 1)) + '.frame'), 0)




def clearAllChecks():
    for i in range(len(wareCheck)):
        for j in range(len(wareCheck[0])):
            wareCheck[i][j] = -1





def setWareCheck():
    clearChecks()
    idx = (wareCheck[itemType][itemSubType] - warePos[itemType][itemSubType])
    if ((idx in range(1, (defWareCnt + 1))) and Win_SetCheck(('UI.shop.ware%d' % idx), True)):
        Win_ShowWidget((('UI.shop.ware%d' % idx) + '.frame'), 1)



def clearAllPos():
    for i in range(len(warePos)):
        for j in range(len(warePos[i])):
            warePos[i][j] = 0




charIconList = ['xwk',
 'tt',
 'xq',
 'cl',
 'bbl',
 'hy',
 'mly',
 'hwz',
 'boy',
 '',
 '',
 '',
 'kl',
 'nz',
 'wll',
 'yy',
 '',
 'yd',
 'ld',
 'ge',
 'tb',
 'girl']

def useSth(sth, ID, canOff):
    global myItemLastSelect
    ID = int(ID)
    if (not sth.has_key(ID)):
        return 
    desc = sth[ID]
    (type, idx,) = desc[0:2]
    if ((canOff and (useItems[type] == ID)) and unUseWare(ID)):
        return 
    if (canOff and ((type in selectedItems.keys()) and (myItemLastSelect != -1))):
        selectedItems[type] = myItemLastSelect
        myItemLastSelect = -1
    if (not canOff):
        selectedItems[type] = None
    if (type in g_ItemsNotPreview):
        useItems[type] = ID
    elif (type in g_ItemsPreview):
        useItems[type] = ID
        itemInfo = GetItemInfoFromSec(ID)
        shopPlayer_wear(type, idx, itemInfo.m_bItemEffect, itemInfo.m_bItemColor)
    elif ('bg' == type):
        useItems[type] = ID
        Win_SetImg('UI.shop.preview.bg', ('object/bg/bg%d_stand.img' % idx))
    elif ('frame' == type):
        useItems[type] = ID
        Win_SetImg('UI.shop.preview.frame', ('object/frame/frame%d_stand.img' % idx))
    elif ('enter' == type):
        useItems[type] = ID
        Win_SetImg('UI.shop.preview.enter', ('object/enter/enter%d_stand.img' % idx))
    elif ('namecard' == type):
        useItems[type] = ID
        Win_SetImg('UI.shop.namecardPreview.namecard', ('object/namecard/namecard%d_stand.img' % idx))
    elif ('namecardbound' == type):
        useItems[type] = ID
        Win_SetImg('UI.shop.namecardPreview.namecardbound', ('object/namecardbound/namecardbound%d_stand.img' % idx))
    elif equipMap.has_key(type):
        useItems[type] = ID
        pos = equipMap[type]
        if ('cap' == type):
            useItems['hair'] = None
            selectedItems['hair'] = None
            shopPlayer_wear('hair', 0, 0, 0)
        if ('hair' == type):
            useItems['cap'] = None
            selectedItems['cap'] = None
            shopPlayer_wear('cap', 100, 0, 0)
        itemInfo = GetItemInfoFromSec(ID)
        shopPlayer_wear(type, idx, itemInfo.m_bItemEffect, itemInfo.m_bItemColor)
    elif ((ID >= 20000) and (ID < 23000)):
        RoleId = shopPlayer_getRoleIdx()
        if ((GetAllowWear(RoleId, ID) == -1) and NotifyNoWear()):
            return 
        shopPlayer_wear('body', idx, 0, 0)
        if (GetAffectionItem(RoleId, ID) == 0):
            return 
        useItems['body'] = ID
        i = 0
        isExistItem = 0
        for i in range(6):
            if (Affectionlist[i] == ID):
                isExistItem = 1
                j = (i + 1)
                strUI = ('UI.shop.Affection%d' % j)
                Affectionlist[i] = ID
                Win_ShowWidget(strUI, True)
                Win_SetImg(strUI, ('res/uires/icon/body/body%d.img' % ID))
                Win_SetText((strUI + '.ID'), str(ID))
                return 

        i = 0
        for key in useAffections.keys():
            i = (i + 1)
            if (useAffections[key] == None):
                useAffections[key] = ID
                strUI = ('UI.shop.Affection%d' % i)
                j = (i - 1)
                Affectionlist[j] = ID
                Win_ShowWidget(strUI, True)
                Win_SetImg(strUI, ('res/uires/icon/body/body%d.img' % ID))
                Win_SetText((strUI + '.ID'), str(ID))
                return 

    updateSelectedItems()



def unUseWare(ID):
    ID = int(ID)
    if (not itemList.has_key(ID)):
        return 
    desc = itemList[ID]
    (type, idx,) = desc[0:2]
    print 'unUseWare',
    print ID,
    print type,
    print idx
    if (type in selectedItems.keys()):
        selectedItems[type] = None
    updateSelectedItems()
    if (type in g_ItemsNotPreview):
        useItems[type] = None
    elif (type in g_ItemsPreview):
        useItems[type] = None
        shopPlayer_wear(type, 0, 0, 0)
    elif ('bg' == type):
        useItems['bg'] = None
        Win_SetImg('UI.shop.preview.bg', '')
    elif ('frame' == type):
        useItems['frame'] = None
        Win_SetImg('UI.shop.preview.frame', '')
    elif ('enter' == type):
        useItems['enter'] = None
        Win_SetImg('UI.shop.preview.enter', '')
    elif ('namecard' == type):
        useItems['namecard'] = None
        Win_SetImg('UI.shop.namecardPreview.namecard', '')
    elif ('namecardbound' == type):
        useItems['namecardbound'] = None
        Win_SetImg('UI.shop.namecardPreview.namecardbound', '')
    elif equipMap.has_key(type):
        useItems[type] = None
        shopPlayer_wear(type, 0, 0, 0)



def useWare(ID):
    useSth(commodityList, ID, 0)



def useItem(ID):
    useSth(itemList, ID, 1)



def deleteItem(ID):
    if (not itemList.has_key(ID)):
        return 
    desc = itemList[ID]
    (type, idx,) = desc[0:2]
    if ((useItems[type] == ID) and unUseWare(ID)):
        pass
    ChangeItemStatus(uin, ID, 2)



def getCharIconName():
    i = shopPlayer_getRoleIdx()
    if ((i < 1) or (i > 22)):
        return ''
    else:
        return ('object/ui/shop/charIcon/%s.img' % charIconList[(i - 1)])



def day2str(day):
    if (day > 30):
        return (str((day / 30)) + ' \xb8\xf6\xd4\xc2')
    else:
        return (str(day) + ' \xcc\xec')



def clearLightIcon():
    for type in selectedItems.keys():
        Win_ShowWidget(('UI.shop.lighticon.%s' % type), 0)




def clearSelected():
    for type in selectedItems.keys():
        selectedItems[type] = None

    for i in range(15):
        Win_ShowWidget(('UI.shop.item%d.frame' % (i + 1)), 0)




def updateSelectedItems():
    for i in range(15):
        Win_ShowWidget(('UI.shop.item%d.frame' % (i + 1)), 0)

    for type in type2MyType.keys():
        if (((type2MyType[type] == myItemType) and ((selectedItems[type] > itemPos[myItemType]) and (selectedItems[type] <= (itemPos[myItemType] + 15)))) and Win_ShowWidget(('UI.shop.item%d.frame' % (selectedItems[type] - itemPos[myItemType])), 1)):
            pass




def InitPlayerActiveItems():
    RoleID = shopPlayer_getRoleIdx()
    clearLightIcon()
    petsIdList = GetPlayerAllPetsId()
    if ((len(petsIdList) > 0) and Win_ShowWidget('UI.shop.lighticon.pet', 1)):
        pass
    for type in g_ItemsNotPreview:
        ItemID = GetRoleItem(RoleID, type)
        if (ItemID == -1):
            useItems[type] = None
        else:
            useItems[type] = ItemID

    for type in g_ItemsPreview:
        ItemID = GetRoleItem(RoleID, type)
        if (ItemID == -1):
            useItems[type] = None
        else:
            useItems[type] = ItemID
            Win_ShowWidget(('UI.shop.lighticon.%s' % type), 1)
            if itemList.has_key(ItemID):
                desc = itemList[ItemID]
                idx = desc[1]
                itemInfo = GetItemInfoFromSec(ItemID)
                shopPlayer_wear(type, idx, itemInfo.m_bItemEffect, itemInfo.m_bItemColor)

    ItemID = GetRoleItem(RoleID, 'bg')
    if (ItemID == -1):
        useItems['bg'] = None
    else:
        useItems['bg'] = ItemID
        Win_ShowWidget('UI.shop.lighticon.bg', 1)
        if itemList.has_key(ItemID):
            desc = itemList[ItemID]
            idx = desc[1]
            Win_SetImg('UI.shop.preview.bg', ('object/bg/bg%d_stand.img' % idx))
    ItemID = GetRoleItem(RoleID, 'frame')
    if (ItemID == -1):
        useItems['frame'] = None
    else:
        useItems['frame'] = ItemID
        Win_ShowWidget('UI.shop.lighticon.frame', 1)
        if itemList.has_key(ItemID):
            desc = itemList[ItemID]
            idx = desc[1]
            Win_SetImg('UI.shop.preview.frame', ('object/frame/frame%d_stand.img' % idx))
    ItemID = GetRoleItem(RoleID, 'enter')
    if (ItemID == -1):
        useItems['enter'] = None
    else:
        useItems['enter'] = ItemID
        Win_ShowWidget('UI.shop.lighticon.enter', 1)
        if itemList.has_key(ItemID):
            desc = itemList[ItemID]
            idx = desc[1]
            Win_SetImg('UI.shop.preview.enter', ('object/enter/enter%d_stand.img' % idx))
    ItemID = GetRoleItem(RoleID, 'namecard')
    if (ItemID == -1):
        useItems['namecard'] = None
    else:
        useItems['namecard'] = ItemID
        Win_ShowWidget('UI.shop.lighticon.namecard', 1)
        if itemList.has_key(ItemID):
            desc = itemList[ItemID]
            idx = desc[1]
            Win_SetImg('UI.shop.namecardPreview.namecard', ('object/namecard/namecard%d_stand.img' % idx))
    ItemID = GetRoleItem(RoleID, 'namecardbound')
    if (ItemID == -1):
        useItems['namecardbound'] = None
    else:
        useItems['namecardbound'] = ItemID
        Win_ShowWidget('UI.shop.lighticon.namecardbound', 1)
        if itemList.has_key(ItemID):
            desc = itemList[ItemID]
            idx = desc[1]
            Win_SetImg('UI.shop.namecardPreview.namecardbound', ('object/namecardbound/namecardbound%d_stand.img' % idx))
    for type in equipMap.keys():
        ItemID = GetRoleItem(RoleID, type)
        if (ItemID == -1):
            useItems[type] = None
        else:
            useItems[type] = ItemID
            Win_ShowWidget(('UI.shop.lighticon.%s' % type), 1)
            if (not itemList.has_key(ItemID)):
                continue
            desc = itemList[ItemID]
            idx = desc[1]
            itemInfo = GetItemInfoFromSec(ItemID)
            shopPlayer_wear(type, idx, itemInfo.m_bItemEffect, itemInfo.m_bItemColor)

    clearSelected()



def sendActiveItems():
    list = []
    for key in useItems.keys():
        if ((useItems[key] != None) and list.append(useItems[key])):
            pass

    num = len(list)
    ActiveItemStatus(uin, shopPlayer_getRoleIdx(), num, list)



def setItemType(type):
    global myItemType
    global itemType
    Win_ShowWidget('UI.shop.fruitMachine', 0)
    Win_ShowWidget('UI.shop.AD', 0)
    itemType = type
    if (1 < type):
        myItemType = type
    if ((1 == type) and Win_SelectSelf('UI.shop.adviceTab')):
        Win_SelectSelf('UI.shop.subTab1')
        initFruitMachine()
    if ((2 == type) and Win_SelectSelf('UI.shop.functionTab')):
        Win_SelectSelf('UI.shop.subTab1')
        Win_SelectSelf('UI.shop.myFunction')
    if ((3 == type) and Win_SelectSelf('UI.shop.costumeTab')):
        Win_SelectSelf('UI.shop.subTab1')
        Win_SelectSelf('UI.shop.myCostume')
    if ((4 == type) and Win_SelectSelf('UI.shop.equipTab')):
        Win_SelectSelf('UI.shop.subTab1')
        Win_SelectSelf('UI.shop.myEquip')
    if ((5 == type) and Win_SelectSelf('UI.shop.petTab')):
        Win_SelectSelf('UI.shop.subTab1')
        Win_SelectSelf('UI.shop.mypet')
    if ((6 == type) and Win_SelectSelf('UI.shop.purplediamondTab')):
        Win_SelectSelf('UI.shop.subTab1')
        Win_SelectSelf('UI.shop.myturplediamond')
    setItemSubType(1)
    ui_updateAll()
    setWareCheck()



def setItemSubType(subType):
    global itemSubType
    if (((itemType == 1) and (subType == 1)) and initFruitMachine()):
        pass
    if ((subType != 1) and Win_ShowWidget('UI.shop.fruitMachine', 0)):
        Win_ShowWidget('UI.shop.AD', 0)
    itemSubType = subType
    ui_updateWares()
    ui_updateWarePages()
    setWareCheck()



def setDonateDlg():
    i = curBuyWareIdx
    buyMode = buyModes[i][0]
    wareID = wareIDs[i]
    if (wareID > 0):
        curBuyWareID = wareID
        info = WareList().at(itemType, itemSubType, (i + warePos[itemType][itemSubType]))
        ui = 'UI.shop.donateDlg'
        Win_SetText((ui + '.wareName'), info.name)
        Win_SetImg((ui + '.warePic'), info.picName)
        rebate = 100
        memberRebate = 100
        if ((info.rebate >= 0) and (info.rebate < 100)):
            rebate = info.rebate
        if (isLeague and ((info.memberRebate >= 0) and (info.memberRebate < 100))):
            memberRebate = info.memberRebate
    if ((curMoneyType == 'QB') and Win_SetText((ui + '.price'), makeStr(15, ((((info.priceQQ * memberRebate) * rebate) + 9999) / 10000), ' Q\xb1\xd2', 1))):
        pass
    if Win_SetFocus((ui + '.receiveUin')):
        pass


class WareList:
    __module__ = __name__
    items = []

    def getCnt(this, type, subType):
        WareList.items = []
        cnt = fetchCommodityCnt(type, subType)
        for i in range(cnt):
            info = this._WareList__get(type, subType, i)
            if (info.hasClient and (isDispNotBuy or (((curMoneyType == 'QB') and ((info.priceQQ >= 0) or (info.priceGame >= 0))) or (((curMoneyType == 'VNet') and (info.priceQQ >= 0)) or ((curMoneyType == 'TangB') and (info.priceQQTang >= 0)))))):
                if WareList.items.append(info):
                    pass

        return len(WareList.items)



    def at(this, type, subType, wareIdx):
        if (wareIdx >= len(WareList.items)):
            return None
        return WareList.items[wareIdx]



    def __get(this, type, subType, wareIdx):
        info = CNil()
        ci = fetchCommodity(type, subType, wareIdx)
        info.name = ci.m_szCommodityName
        info.ID = ci.m_iCommodityID
        info.priceQQ = int(ci.m_iPriceQQ)
        info.priceGame = ci.m_iPriceQQGame
        info.priceQQTang = ci.m_iPriceQQTang
        info.attribute = ci.m_dwAttribute
        info.memberRebate = ci.m_bMemberRebate
        info.rebate = ci.m_bRebate
        item0 = fetchCommItem(type, subType, wareIdx, 0)
        info.period = item0.m_nAvailPeriod
        info.num = item0.m_iItemNum
        info.ID = max(info.ID, 1)
        if commodityList.has_key(info.ID):
            iconType = commodityList[info.ID][0]
            iconIdx = commodityList[info.ID][1]
            info.picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
             iconType,
             iconIdx))
            info.statement = commodityList[info.ID][3]
            info.hasClient = 1
        else:
            info.picName = 'res/uires/shop/salou.img'
            info.statement = ''
            info.hasClient = 0
        return info




def ui_updateAll():
    ui_updateMyItems()
    ui_updateWares()
    ui_updateWarePages()



def ui_updateWarePages():
    wareCnt = WareList().getCnt(itemType, itemSubType)
    curCnt = warePos[itemType][itemSubType]
    if ((itemType == 1) and (itemSubType == 1)):
        itemShowCnt = 8
    else:
        itemShowCnt = 12
    curPage = ((curCnt / itemShowCnt) + 1)
    if ((0 == (wareCnt % itemShowCnt)) and (0 != wareCnt)):
        totalPage = (wareCnt / itemShowCnt)
    else:
        totalPage = ((wareCnt / itemShowCnt) + 1)
    Win_SetText('UI.shop.warePage', ('%d/%d' % (curPage,
     totalPage)))



def num2chinese(num):
    if ((num < 10000) or ((num % 1000) != 0)):
        return str(num)
    if (0 == (num % 10000)):
        return (str((num / 10000)) + '\xcd\xf2')
    return ((str((num / 10000)) + '\xcd\xf2') + str(((num % 10000) / 1000)))



def makeStr(lenCnt, num, name, isJiao = 0):
    if isJiao:
        s = ((str((num / 10)) + '.') + str((num % 10)))
    else:
        s = num2chinese(num)
    spCnt = ((lenCnt - len(s)) - len(name))
    return ((s + (' ' * spCnt)) + name)



def ui_updateWares():
    global buyModes
    global wareIDs
    if ('shop' != Win_GetCurScreen()):
        return 
    wareCnt = WareList().getCnt(itemType, itemSubType)
    wareIDs = []
    buyModes = []
    setWareCheck()
    if ((itemType == 1) and (itemSubType == 1)):
        itemShowCnt = 8
    else:
        itemShowCnt = 12
    for i in range(12):
        Win_ShowWidget(('UI.shop.attr%d' % (i + 1)), 0)
        Win_SetImg(('UI.shop.attr%d' % (i + 1)), '')

    for i in range(itemShowCnt):
        ware = ('UI.shop.ware' + str((i + 1)))
        Win_EnableWidget(ware, 1)
        info = WareList().at(itemType, itemSubType, (i + warePos[itemType][itemSubType]))
        curDispWares[i] = info
        Win_ShowWidget(('UI.shop.attr%d' % (i + 1)), 0)
        if (((None == info) or ('' == info.name)) and Win_SetText((ware + '.ID'), '')):
            Win_ShowWidget(ware, True)
            Win_SetImg((ware + '.picture'), '')
            Win_SetText((ware + '.name'), '')
            Win_SetText((ware + '.price1'), '')
            Win_SetText((ware + '.price2'), '')
            Win_ShowWidget((ware + '.buyA'), False)
            Win_SetImg(('UI.shop.attr%d' % (i + 1)), '')
            Win_ShowWidget((ware + '.memberPic'), 0)
            Win_SetImg((ware + '.pricePic'), '')
            Win_SetText((ware + '.memberPrice'), '')
            Win_EnableWidget(ware, 0)
            continue
        wareIDs.append(info.ID)
        Win_SetText((ware + '.ID'), str(info.ID))
        Win_ShowWidget(ware, True)
        Win_SetImg((ware + '.picture'), info.picName)
        Win_SetText((ware + '.name'), info.name)
        buyMode = []
        if ((info.priceQQ > 0) and buyMode.append(1)):
            pass
        if ((info.priceGame > 0) and buyMode.append(2)):
            pass
        if ((info.priceQQTang > 0) and buyMode.append(3)):
            pass
        if (len(buyMode) > 2):
            buyMode = buyMode[0:3]
        Win_SetText((ware + '.price1'), '')
        Win_SetText((ware + '.price2'), '')
        Win_ShowWidget(('UI.shop.ware%d.memberPic' % (i + 1)), 1)
        memberRebate = 100
        rebate = 100
        Win_SetImg((ware + '.pricePic'), 'object/ui/shop/ware/originPrice.img')
        if ((info.memberRebate >= 0) and (info.memberRebate < 100)):
            memberRebate = info.memberRebate
        if ((info.rebate >= 0) and (info.rebate < 100)):
            rebate = info.rebate
            Win_SetImg((ware + '.pricePic'), 'object/ui/shop/ware/rebatePrice.img')
        if ((curMoneyType == 'QB') and Win_SetText((ware + '.price2'), makeStr(8, (((info.priceQQ * rebate) + 99) / 100), ' Q\xb1\xd2', 1))):
            Win_SetText((ware + '.memberPrice'), makeStr(8, ((((info.priceQQ * memberRebate) * rebate) + 9999) / 10000), ' Q\xb1\xd2', 1))
        buyModes.append(buyMode)
        if ((0 == len(buyMode)) and Win_ShowWidget((ware + '.buyA'), 0)):
            pass
        for attrVal in range(1, 8):
            if ((info.attribute == attrVal) and Win_SetImg(('UI.shop.attr%d.rebate' % (i + 1)), '')):
                Win_SetImg(('UI.shop.attr%d.rebateH' % (i + 1)), '')
                Win_SetImg(('UI.shop.attr%d.point' % (i + 1)), '')
                Win_SetImg(('UI.shop.attr%d.rebateL' % (i + 1)), '')
                Win_SetImg(('UI.shop.attr%d.rebateWord' % (i + 1)), '')
                Win_SetImg(('UI.shop.attr%d' % (i + 1)), ('object/ui/shop/wareAttr/%s.img' % attrMap[attrVal]))
                Win_ShowWidget(('UI.shop.attr%d' % (i + 1)), 1)

        if ((info.rebate > 0) and (info.rebate < 100)):
            rebateH = (info.rebate / 10)
            rebateL = (info.rebate % 10)
            ui = ('UI.shop.attr%d' % (i + 1))
            Win_SetImg(ui, 'object/ui/shop/wareAttr/bg_rebate.img')
            Win_SetImg((ui + '.rebateWord'), 'object/ui/shop/wareAttr/zhe.img')
            Win_ShowWidget((ui + '.rebateWord'), 1)
            Win_ShowWidget(ui, 1)
            if ((0 == rebateL) and Win_ShowWidget((ui + '.rebateH'), 0)):
                Win_ShowWidget((ui + '.point'), 0)
                Win_ShowWidget((ui + '.rebateL'), 0)
                Win_SetImg((ui + '.rebate'), ('object/ui/shop/wareAttr/%d.img' % rebateH))
                Win_ShowWidget((ui + '.rebate'), 1)



class ItemList:
    __module__ = __name__
    items = []

    def getCnt(this, type):
        global itemCnt
        ItemList.items = []
        cnt = GetEnableItemCnt(type)
        for i in range(cnt):
            info = this._ItemList__get(type, i)
            if (info.hasClient and ItemList.items.append(info)):
                pass

        itemCnt = len(ItemList.items)
        return itemCnt



    def at(this, type, itemIdx):
        if (itemIdx >= len(ItemList.items)):
            return None
        return ItemList.items[itemIdx]



    def __get(this, type, i):
        info = CNil()
        ii = GetEnableItemInfo(type, i)
        id = ii.m_nItemID
        info.ID = id
        info.roleID = ii.m_bItemRoleID
        info.status = ii.m_bItemStatus
        info.buyTime = ii.m_dwBuyTime
        info.effectID = ii.m_bItemEffect
        if itemList.has_key(id):
            info.hasClient = 1
            iconType = itemList[id][0]
            iconIdx = itemList[id][1]
            info.picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
             iconType,
             iconIdx))
        else:
            info.hasClient = 0
            info.picName = 'res/uires/shop/salou.img'
        return info




def updateLightIcon():
    RoleID = shopPlayer_getRoleIdx()
    clearLightIcon()
    for type in g_ItemsPreview:
        ItemID = GetRoleItem(RoleID, type)
        if ((ItemID != -1) and Win_ShowWidget(('UI.shop.lighticon.%s' % type), 1)):
            pass

    ItemID = GetRoleItem(RoleID, 'bg')
    if ((ItemID != -1) and Win_ShowWidget('UI.shop.lighticon.bg', 1)):
        pass
    ItemID = GetRoleItem(RoleID, 'frame')
    if ((ItemID != -1) and Win_ShowWidget('UI.shop.lighticon.frame', 1)):
        pass
    ItemID = GetRoleItem(RoleID, 'enter')
    if ((ItemID != -1) and Win_ShowWidget('UI.shop.lighticon.enter', 1)):
        pass
    ItemID = GetRoleItem(RoleID, 'namecard')
    if ((ItemID != -1) and Win_ShowWidget('UI.shop.lighticon.namecard', 1)):
        pass
    ItemID = GetRoleItem(RoleID, 'namecardbound')
    if ((ItemID != -1) and Win_ShowWidget('UI.shop.lighticon.namecardbound', 1)):
        pass
    for type in equipMap.keys():
        ItemID = GetRoleItem(RoleID, type)
        if ((ItemID != -1) and Win_ShowWidget(('UI.shop.lighticon.%s' % type), 1)):
            pass




def ui_updateMyItems():
    global bClickSaveEquip
    global itemCnt
    itemCnt = ItemList().getCnt(myItemType)
    itemPos[myItemType] = max(itemPos[myItemType], 0)
    for i in range(15):
        itemUI = ('UI.shop.item%d' % (i + 1))
        idx = (itemPos[myItemType] + i)
        Win_SetImg((itemUI + '.hasEquiped'), '')
        Win_SetImg((itemUI + '.hasForged'), '')
        if ((idx >= itemCnt) and Win_ShowWidget(itemUI, False)):
            pass

    updateSelectedItems()
    if (bClickSaveEquip == 1):
        bClickSaveEquip = 0
        updateLightIcon()


class Recycler:
    __module__ = __name__
    items = []

    def getCnt(this):
        global disableItemCnt
        Recycler.items = []
        cnt = GetDisableItemCnt()
        for i in range(cnt):
            info = this._Recycler__get(type, i)
            if (info.hasClient and Recycler.items.append(info)):
                pass

        disableItemCnt = len(Recycler.items)
        return disableItemCnt



    def __get(this, type, i):
        info = CNil()
        ii = GetDisableItemInfo(i)
        id = ii.m_nItemID
        info.status = ii.m_bItemStatus
        info.buyTime = ii.m_dwBuyTime
        if itemList.has_key(id):
            info.hasClient = 1
            iconType = itemList[id][0]
            iconIdx = itemList[id][1]
            info.picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
             iconType,
             iconIdx))
            info.name = itemList[id][2]
        else:
            info.hasClient = 0
            info.picName = 'res/uires/shop/salou.img'
            info.name = ''
        info.ID = id
        return info



    def at(this, itemIdx):
        if (itemIdx >= len(Recycler.items)):
            return None
        return Recycler.items[itemIdx]




def ui_updateRecycler():
    global disableItemCnt
    global activeItemInRecycler
    global disableItemPos
    disableItemCnt = Recycler().getCnt()
    activeItemInRecycler = 999999
    disableItemPos = min(disableItemPos, (disableItemCnt - defRecyclerCnt))
    disableItemPos = max(disableItemPos, 0)
    for i in range(defRecyclerCnt):
        ui = ('UI.shop.recycler.item%d' % i)
        idx = (disableItemPos + i)
        Win_SetCheck(ui, 0)
        if ((idx >= disableItemCnt) and Win_SetText((ui + '.name'), '')):
            Win_EnableWidget(ui, 0)
            continue

    Win_SetPos('UI.shop.recycler.scroll', Win_GetPos('UI.shop.recycler.scroll'))
    doUI('UI.shop.recycler.scroll', 'OnPosChange')



def buyFail(text):
    ui = 'UI.shop.buyFailDlg'
    Win_SetText((ui + '.text'), text)
    Win_ShowWidget(ui, 1)



def ui_refreshState(bState):
    global fruitState
    ui = 'UI.shop.fruitMachine'
    fruitState = bState
    Win_ShowWidget((ui + '.startBtn'), ((fruitState == 0) or (fruitState == 1)))
    Win_EnableWidget((ui + '.startBtn'), (fruitState == 0))
    Win_ShowWidget((ui + '.stopBtn'), ((fruitState == 2) or (fruitState == 3)))
    Win_EnableWidget((ui + '.stopBtn'), (fruitState == 2))
    if (((fruitState == 0) and (Win_GetFocusPath() == ui)) and Win_SetFocus('')):
        Win_SetCapture('')



def ui_refreshItem():
    ui = 'UI.shop.fruitMachine'
    for i in range(3):
        paramList = [i]
        item = HandleFruitMachine(2, paramList)
        picName = 'res/uires/shop/salou.img'
        if commodityList.has_key(item[0]):
            iconType = commodityList[item[0]][0]
            iconIdx = commodityList[item[0]][1]
            picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
             iconType,
             iconIdx))
        Win_SetImg((ui + ('.item%d' % (i + 1))), picName)




def initFruitMachine():
    global bFruitUpdate
    ui = 'UI.shop.fruitMachine'
    IsLucky = IsFruitMechine()
    if ((IsLucky <= 0) and Win_ShowWidget(ui, 0)):
        Win_ShowWidget('UI.shop.AD', 1)
        return 
    if bFruitUpdate:
        bFruitUpdate = 0
        Win_ShowWidget('UI.shop.fruitTip', 1)
        Win_Timer('UI.shop.fruitTip', 20000)
    else:
        Win_ShowWidget('UI.shop.fruitTip', 0)
    Win_ShowWidget(ui, 1)
    ui_refreshState(0)
    paramList = []
    HandleFruitMachine(5, paramList)



def buyFruitMachine():
    BuyCommodity(999, 2, 1, 0)



def ui_startFruitMachine():
    ui = 'UI.shop.fruitMachine'
    Win_ShowWidget((ui + '.frame'), 1)
    Win_ShowWidget((ui + '.light'), 1)
    Win_SetValue((ui + '.light'), 0.14999999999999999, 49)
    paramList = [400,
     150,
     10]
    HandleFruitMachine(1, paramList)
    ui_refreshState(2)



def stopFruitMachine():
    paramList = [450,
     12]
    HandleFruitMachine(3, paramList)
    ui_refreshState(3)



def ui_showFruitResult(resultStr):
    ui = 'UI.shop.fruitResult'
    Win_SetText((ui + '.text'), resultStr)
    ui_setCapture(ui)
    ui = 'UI.shop.fruitMachine'
    Win_ShowWidget((ui + '.light'), 0)
    UpdateMyItem()
    ui_updateMyItems()



def ui_UpdateShopStorage():
    g_StorageList.update()
    UpdateShopStorage()



def UpdateShopStorage():
    if ((totalStorageCnt == 0) and Win_SetText((uiShopStorageDlg + '.storagePage'), '1/1')):
        pass
    for i in range(defShopStorageCnt):
        ui = (uiShopStorageDlg + ('.storageItem%d' % i))
        idx = (i + shopStoragePos)
        if ((idx >= totalStorageCnt) and Win_SetImg(ui, '')):
            Win_SetText((ui + '.itemNum'), '')
            continue
        info = g_StorageList.at(idx).m_stItem
        Win_SetImg(ui, ('res/uires/icon/item/item%d.img' % info.m_nItemID))
        Win_SetText((ui + '.itemNum'), ('%4d' % info.m_iNumOfItem))



class forgeTypeList:
    __module__ = __name__
    items = []

    def clear(this):
        global forgeTypeCnt
        forgeTypeList.items = []
        forgeTypeCnt = 0



    def update(this):
        global forgeTypeCnt
        forgeTypeList.items = GetForgeType()
        forgeTypeCnt = len(forgeTypeList.items)
        return forgeTypeCnt



    def at(this, itemIdx):
        if (itemIdx >= len(forgeTypeList.items)):
            return None
        return forgeTypeList.items[itemIdx]



class forgeItemList:
    __module__ = __name__
    items = []

    def clear(this):
        global forgeItemCnt
        forgeItemList.items = []
        forgeItemCnt = 0



    def update(this):
        global forgeItemCnt
        forgeItemList.items = GetForgeItem(forgeExpand)
        forgeItemCnt = len(forgeItemList.items)
        return forgeItemCnt



    def at(this, itemIdx):
        if (itemIdx >= len(forgeItemList.items)):
            return None
        return forgeItemList.items[itemIdx]



class forgeMeterialList:
    __module__ = __name__
    items = []

    def clear(this):
        global forgeMeterialCnt
        forgeMeterialList.items = []
        forgeMeterialCnt = 0



    def update(this):
        global forgeMeterialCnt
        forgeMeterialList.items = GetForgeMeterial(forgeItemID)
        forgeMeterialCnt = len(forgeMeterialList.items)
        return forgeMeterialCnt



    def at(this, itemIdx):
        if (itemIdx >= len(forgeMeterialList.items)):
            return None
        return forgeMeterialList.items[itemIdx]



g_ForgeTypeList = forgeTypeList()
g_ForgeItemList = forgeItemList()
g_ForgeMeterialList = forgeMeterialList()

def ui_UpdateForgeType():
    global forgeItemID
    global forgeExpand
    g_ForgeMeterialList.clear()
    g_ForgeItemList.clear()
    g_ForgeTypeList.update()
    forgeExpand = -1
    forgeItemID = 0
    Win_SetPos((uiForgeDlg + '.itemScroll'), 0)
    doUI((uiForgeDlg + '.itemScroll'), 'OnPosChange')
    Win_SetPos((uiForgeDlg + '.materialScroll'), 0)
    doUI((uiForgeDlg + '.materialScroll'), 'OnPosChange')
    Win_SetImg((uiForgeDlg + '.curItemIcon'), '')
    Win_SetText((uiForgeDlg + '.curItemName'), '')
    Win_SetText((uiForgeDlg + '.curItemInfo'), '')
    Win_SetText((uiForgeDlg + '.forgeInfo'), '', value_channel_listitem_num)


class composeTypeList:
    __module__ = __name__
    items = []

    def clear(this):
        global composeTypeCnt
        composeTypeList.items = []
        composeTypeCnt = 0



    def update(this):
        global composeTypeCnt
        composeTypeList.items = GetCombineType()
        composeTypeCnt = len(composeTypeList.items)
        return composeTypeCnt



    def at(this, itemIdx):
        if (itemIdx >= len(composeTypeList.items)):
            return None
        return composeTypeList.items[itemIdx]



class composeItemList:
    __module__ = __name__
    items = []

    def clear(this):
        global composeItemCnt
        composeItemList.items = []
        composeItemCnt = 0



    def update(this):
        global composeItemCnt
        composeItemList.items = GetCombineItem(composeExpand)
        composeItemCnt = len(composeItemList.items)
        return composeItemCnt



    def at(this, itemIdx):
        if (itemIdx >= len(composeItemList.items)):
            return None
        return composeItemList.items[itemIdx]



class composeMeterialList:
    __module__ = __name__
    items = []

    def clear(this):
        global composeMeterialCnt
        composeMeterialList.items = []
        composeMeterialCnt = 0



    def update(this):
        global composeMeterialCnt
        composeMeterialList.items = GetCombineMeterial(composeItemID)
        composeMeterialCnt = len(composeMeterialList.items)
        return composeMeterialCnt



    def at(this, itemIdx):
        if (itemIdx >= len(composeMeterialList.items)):
            return None
        return composeMeterialList.items[itemIdx]



g_ComposeTypeList = composeTypeList()
g_ComposeItemList = composeItemList()
g_ComposeMeterialList = composeMeterialList()

def ui_UpdateComposeType():
    global composeExpand
    global composeItemID
    g_ComposeMeterialList.clear()
    g_ComposeItemList.clear()
    g_ComposeTypeList.update()
    composeExpand = -1
    composeItemID = 0
    Win_SetPos((uiComposeDlg + '.itemScroll'), 0)
    doUI((uiComposeDlg + '.itemScroll'), 'OnPosChange')
    for i in range(defComposeMeterCnt):
        Win_SetImg((uiComposeDlg + ('.meterialList.meterialIcon%d' % i)), '')
        Win_SetText((uiComposeDlg + ('.meterialList.meterialInfo%d' % i)), '')

    Win_SetImg((uiComposeDlg + '.curItemIcon'), '')
    Win_SetText((uiComposeDlg + '.curItemName'), '')
    Win_SetText((uiComposeDlg + '.curItemInfo'), '')
    Win_SetText((uiComposeDlg + '.composeInfo'), '', value_channel_listitem_num)



def ui_ReceiveForgeResult(result, info):
    g_ForgeItemList.update()
    doUI((uiForgeDlg + '.itemScroll'), 'OnPosChange')
    g_ForgeMeterialList.update()
    doUI((uiForgeDlg + '.materialScroll'), 'OnPosChange')
    Win_SetColorText((uiForgeDlg + '.forgeInfo'), info, value_channel_itemtext, 255, 250, 236)



def ui_ReceiveComResult(result, info):
    g_ComposeItemList.update()
    doUI((uiComposeDlg + '.itemScroll'), 'OnPosChange')
    g_ComposeMeterialList.update()
    for i in range(defComposeMeterCnt):
        materialInfo = g_ComposeMeterialList.at(i)
        Win_SetImg((uiComposeDlg + ('.meterialList.meterialIcon%d' % i)), ('res/uires/icon/item/item%d.img' % materialInfo.iMaterialID))
        Win_SetText((uiComposeDlg + ('.meterialList.meterialInfo%d' % i)), (materialInfo.szMaterialName + ('\n\n%d/%d' % (materialInfo.unHadMatNum,
         materialInfo.unNeedMatlNum))))

    Win_SetColorText((uiComposeDlg + '.composeInfo'), info, value_channel_itemtext, 255, 250, 236)


g_AvatarForgePage = [[0,
  0,
  0,
  0],
 5]
g_AvatarRevertPage = [[0,
  0,
  0,
  0],
 5]
g_AvatarMaterialPage = [0,
 5]
g_AvatarForgeCurrentType = 0
g_ForgeDragInfo = [-1,
 -1,
 '']
g_ForgeInfo = [-1,
 -1,
 -1,
 -1]
g_Operator = (1,
 3,
 4)
class AvatarForge:
    __module__ = __name__
    AvatarList = [[],
     []]

    def update(this):
        global g_AvatarTypeList
        AvatarForge.AvatarList = [[],
         []]
        g_AvatarTypeList = GetAvatarForgeType()
        for i in range(len(g_AvatarTypeList)):
            tempAvatarList = GetAvatarForgeItem(i)
            AvatarForge.AvatarList[0].append(tempAvatarList[0])
            AvatarForge.AvatarList[1].append(tempAvatarList[1])




    def at(this, ForgeorRevert, typeIdx, itemIdx):
        return AvatarForge.AvatarList[ForgeorRevert][typeIdx][itemIdx]



    def getItemCnt(this, ForgeorRevert, typeIdx):
        if (typeIdx < len(AvatarForge.AvatarList[ForgeorRevert])):
            return len(AvatarForge.AvatarList[ForgeorRevert][typeIdx])
        return 0



    def addAvatar(this, ForgeorRevert, typeIdx, itemID):
        for i in range(len(AvatarForge.AvatarList[ForgeorRevert][typeIdx])):
            if (AvatarForge.AvatarList[ForgeorRevert][typeIdx][i].m_nItemID == itemID):
                AvatarForge.AvatarList[ForgeorRevert][typeIdx][i] = GetItemInfoFromSec(itemID)
                return 

        AvatarForge.AvatarList[ForgeorRevert][typeIdx].append(GetItemInfoFromSec(itemID))



    def removeAvatar(this, ForgeorRevert, typeIdx, itemID):
        for i in range(len(AvatarForge.AvatarList[ForgeorRevert][typeIdx])):
            if ((AvatarForge.AvatarList[ForgeorRevert][typeIdx][i].m_nItemID == itemID) and AvatarForge.AvatarList[ForgeorRevert][typeIdx].remove(AvatarForge.AvatarList[ForgeorRevert][typeIdx][i])):
                return 




g_AvatarForge = AvatarForge()

def ui_updateForgePage():
    forgePage1 = ((g_AvatarForgePage[0][g_AvatarForgeCurrentType] + g_AvatarForgePage[1]) / g_AvatarForgePage[1])
    itemCnt = g_AvatarForge.getItemCnt(0, g_AvatarForgeCurrentType)
    if ((itemCnt != 0) and ((itemCnt % g_AvatarForgePage[1]) == 0)):
        forgePage2 = (itemCnt / g_AvatarForgePage[1])
    else:
        forgePage2 = ((itemCnt / g_AvatarForgePage[1]) + 1)
    Win_SetText((uiAvatarForgeDlg + '.forgePage'), ('%d/%d' % (forgePage1,
     forgePage2)))
    revertPage1 = ((g_AvatarRevertPage[0][g_AvatarForgeCurrentType] + g_AvatarRevertPage[1]) / g_AvatarRevertPage[1])
    itemCnt = g_AvatarForge.getItemCnt(1, g_AvatarForgeCurrentType)
    if ((itemCnt != 0) and ((itemCnt % g_AvatarRevertPage[1]) == 0)):
        revertPage2 = (itemCnt / g_AvatarRevertPage[1])
    else:
        revertPage2 = ((itemCnt / g_AvatarRevertPage[1]) + 1)
    Win_SetText((uiAvatarForgeDlg + '.revertPage'), ('%d/%d' % (revertPage1,
     revertPage2)))



def ui_showAvatar():
    ui_updateForgePage()
    sourceIdx = g_AvatarForgePage[0][g_AvatarForgeCurrentType]
    itemCnt = g_AvatarForge.getItemCnt(0, g_AvatarForgeCurrentType)
    for i in range(g_AvatarForgePage[1]):
        itemIdx = (i + sourceIdx)
        if (itemIdx < itemCnt):
            itemID = g_AvatarForge.at(0, g_AvatarForgeCurrentType, itemIdx).m_nItemID
            if itemList.has_key(itemID):
                iconType = itemList[itemID][0]
                iconIdx = itemList[itemID][1]
                picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                 iconType,
                 iconIdx))
            else:
                picName = 'res/uires/shop/salou.img'
            Win_SetImg((uiAvatarForgeDlg + ('.forgeItem%d' % i)), picName)
            Win_EnableWidget((uiAvatarForgeDlg + ('.forgeItem%d' % i)), 1)
        else:
            Win_SetImg((uiAvatarForgeDlg + ('.forgeItem%d' % i)), '')
            Win_EnableWidget((uiAvatarForgeDlg + ('.forgeItem%d' % i)), 0)

    sourceIdx = g_AvatarRevertPage[0][g_AvatarForgeCurrentType]
    itemCnt = g_AvatarForge.getItemCnt(1, g_AvatarForgeCurrentType)
    for i in range(g_AvatarRevertPage[1]):
        itemIdx = (i + sourceIdx)
        if (itemIdx < itemCnt):
            itemID = g_AvatarForge.at(1, g_AvatarForgeCurrentType, itemIdx).m_nItemID
            if itemList.has_key(itemID):
                iconType = itemList[itemID][0]
                iconIdx = itemList[itemID][1]
                picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                 iconType,
                 iconIdx))
            else:
                picName = 'res/uires/shop/salou.img'
            Win_SetImg((uiAvatarForgeDlg + ('.revertItem%d' % i)), picName)
            Win_EnableWidget((uiAvatarForgeDlg + ('.revertItem%d' % i)), 1)
        else:
            Win_SetImg((uiAvatarForgeDlg + ('.revertItem%d' % i)), '')
            Win_EnableWidget((uiAvatarForgeDlg + ('.revertItem%d' % i)), 0)




def ui_addAvatar(ForgeorRevert, typeIdx, itemID):
    g_AvatarForge.addAvatar(ForgeorRevert, typeIdx, itemID)



def ui_removeAvatar(ForgeorRevert, typeIdx, itemID):
    g_AvatarForge.removeAvatar(ForgeorRevert, typeIdx, itemID)


class AvatarForgeMaterial:
    __module__ = __name__
    MaterialList = []

    def update(this):
        AvatarForgeMaterial.MaterialList = GetAvatarForgeMaterial()



    def getMaterialCnt(this):
        return len(AvatarForgeMaterial.MaterialList)



    def at(this, itemIdx):
        return AvatarForgeMaterial.MaterialList[itemIdx]



    def addMaterial(this, itemID):
        for i in range(len(AvatarForgeMaterial.MaterialList)):
            if (AvatarForgeMaterial.MaterialList[i].m_stItem.m_nItemID == itemID):
                AvatarForgeMaterial.MaterialList[i] = GetItemInfoInStorage(itemID)
                return 

        AvatarForgeMaterial.MaterialList.append(GetItemInfoInStorage(itemID))



    def removeMaterial(this, itemID):
        for i in range(len(AvatarForgeMaterial.MaterialList)):
            if ((AvatarForgeMaterial.MaterialList[i].m_stItem.m_nItemID == itemID) and AvatarForgeMaterial.MaterialList.remove(AvatarForgeMaterial.MaterialList[i])):
                return 




g_AvatarForgeMaterial = AvatarForgeMaterial()

def ui_updateMaterialPage():
    materialPage1 = ((g_AvatarMaterialPage[0] + g_AvatarMaterialPage[1]) / g_AvatarMaterialPage[1])
    itemCnt = g_AvatarForgeMaterial.getMaterialCnt()
    if ((itemCnt != 0) and ((itemCnt % g_AvatarMaterialPage[1]) == 0)):
        materialPage2 = (itemCnt / g_AvatarMaterialPage[1])
    else:
        materialPage2 = ((itemCnt / g_AvatarMaterialPage[1]) + 1)
    Win_SetText((uiAvatarForgeDlg + '.materialPage'), ('%d/%d' % (materialPage1,
     materialPage2)))



def ui_showMaterial():
    ui_updateMaterialPage()
    sourceIdx = g_AvatarMaterialPage[0]
    itemCnt = g_AvatarForgeMaterial.getMaterialCnt()
    for i in range(g_AvatarMaterialPage[1]):
        itemIdx = (i + sourceIdx)
        if (itemIdx < itemCnt):
            info = g_AvatarForgeMaterial.at(itemIdx)
            Win_SetImg((uiAvatarForgeDlg + ('.materialItem%d' % i)), ('res/uires/icon/item/item%d.img' % info.m_stItem.m_nItemID))
            Win_SetText((uiAvatarForgeDlg + ('.materialItem%d.itemNum' % i)), str(info.m_stItem.m_iNumOfItem))
            Win_ShowWidget((uiAvatarForgeDlg + ('.materialItem%d' % i)), 1)
        else:
            Win_ShowWidget((uiAvatarForgeDlg + ('.materialItem%d' % i)), 0)




def ui_addMaterial(itemID):
    g_AvatarForgeMaterial.addMaterial(itemID)



def ui_removeMaterial(itemID):
    g_AvatarForgeMaterial.removeMaterial(itemID)



def ui_InitForgeDlg():
    global g_ForgeInfo
    global g_AvatarForgeCurrentType
    global g_AvatarForgePage
    global g_AvatarMaterialPage
    global g_AvatarRevertPage
    global g_ForgeDragInfo
    g_AvatarForgePage = [[0,
      0,
      0,
      0],
     5]
    g_AvatarRevertPage = [[0,
      0,
      0,
      0],
     5]
    g_AvatarMaterialPage = [0,
     5]
    g_AvatarForgeCurrentType = 0
    g_ForgeDragInfo = [-1,
     -1,
     '']
    g_ForgeInfo = [-1,
     -1,
     -1,
     -1]
    ui_UpdateAvatarForge()
    ui_showMaterial()
    ui_showAvatar()
    AvatarForge_wear(0, 0, 0)
    AvatarForge_Pos(100, 394)
    Win_SelectSelf((uiAvatarForgeDlg + '.forgeType0'))
    Win_SetCheck((uiAvatarForgeDlg + '.forgeType0'), 1)
    Win_SetImg((uiAvatarForgeDlg + '.sourceMaterial'), '')
    Win_SetImg((uiAvatarForgeDlg + '.sourceAvatar'), '')
    Win_ShowWidget(uiForgeConfirmDlg, 0)



def ui_UpdateAvatarForge():
    g_AvatarForge.update()
    g_AvatarForgeMaterial.update()



def ui_UpdateAvatarEffect(itemID, effectIdx, colorIdx, result, info):
    global g_ForgeInfo
    if itemList.has_key(itemID):
        desc = itemList[itemID]
        (type, idx,) = desc[0:2]
        if ((useItems[type] == itemID) and shopPlayer_wear(type, idx, effectIdx, colorIdx)):
            pass
    AvatarForge_wear(itemID, effectIdx, colorIdx)
    AvatarForge_Pos(100, 394)
    g_ForgeInfo = [-1,
     -1,
     -1,
     itemID]
    Win_SetImg((uiAvatarForgeDlg + '.sourceMaterial'), '')
    Win_SetImg((uiAvatarForgeDlg + '.sourceAvatar'), '')
    Win_ShowWidget(uiForgeConfirmDlg, 0)
    Win_SetColorText((uiAvatarForgeDlg + '.forgeInfo'), info, value_channel_itemtext, 255, 250, 236)



def UpdateTaskSysUi():
    global tasksIdList

    def ClearTaskUi():
        global tasksIdList
        tasksIdList = []
        for i in range(6):
            taskBtn = (uiTaskDlg + ('.taskBtn%d.taskCtrBtn' % i))
            Win_EnableWidget(taskBtn, 0)



    ClearTaskUi()
    tasksIdList = GetAllTaskId()
    for i in range(len(tasksIdList)):
        taskStatus = GetState(tasksIdList[i])
        taskBtn = (uiTaskDlg + ('.taskBtn%d.taskCtrBtn' % i))
        taskNameBtn = (uiTaskDlg + ('.taskBtn%d.taskNameBtn' % i))
        Win_SetText(taskNameBtn, GetTaskName(tasksIdList[i]))
        if ((taskStatus == 0) and Win_EnableWidget(taskBtn, 1)):
            Win_SetImg(taskBtn, 'object/ui/task/btn_startTask.img')

    UpdateCurTaskPanel()



def UpdateCurTaskPanel():
    if (currentTaskIdx >= len(tasksIdList)):
        return 
    curTaskId = tasksIdList[currentTaskIdx]
    imgPath = ('object/ui/task/' + GetTaskMark(curTaskId))
    Win_SetImg((uiTaskDlg + '.taskMark'), imgPath)
    Win_SetText((uiTaskDlg + '.taskName'), GetTaskName(curTaskId))
    imgPath = ('res/uires/icon/npcIcon/' + GetNpcImgPath(curTaskId))
    Win_SetImg((uiTaskDlg + '.npcPic'), imgPath)
    Win_SetText((uiTaskDlg + '.taskIntroduction'), GetTaskDescription(curTaskId))
    Win_SetText((uiTaskDlg + '.deadLine'), GetTaskDeadLineStr(curTaskId))
    Win_SetText((uiTaskDlg + '.progressDes'), GetProgressDes(curTaskId))
    Win_SetText((uiTaskDlg + '.awardDes'), GetAwardDescription(curTaskId))
    itemId = GetAwardId(curTaskId)
    if itemList.has_key(itemId):
        iconType = itemList[itemId][0]
        iconIdx = itemList[itemId][1]
        Win_SetImg((uiTaskDlg + '.awardPic'), ('res/uires/icon/%s/%s%d.img' % (iconType,
         iconType,
         iconIdx)))
    else:
        Win_SetImg((uiTaskDlg + '.awardPic'), '')
    Win_ShowWidget(uiTaskDlg, 1)
    PlaySound(soundUI, 1)



def NotifyBreakEggResult(bSuccess, showItemId, strInfo):
    global currentEggId
    print 'NotifyBreakEggResult'
    currentEggId = -1
    Win_SetText('UI.shop.breakEggDlg.description', strInfo)
    Win_SetImg('UI.shop.breakEggDlg.eggPic', '')
    if ((bSuccess > 0) and itemList.has_key(showItemId)):
        iconType = itemList[showItemId][0]
        iconIdx = itemList[showItemId][1]
        Win_SetImg('UI.shop.breakEggDlg.eggPic', ('res/uires/icon/%s/%s%d.img' % (iconType,
         iconType,
         iconIdx)))
    ui = 'UI.shop.breakEggDlg.hammer'
    Win_EnableWidget((ui + '1'), 0)
    Win_SetImg((ui + '1.hammerPic'), 'res/uiRes/icon/platform/platform9011.img')
    Win_SetText((ui + '1.hammerCnt'), str(GetItemLeaveCount(9011)))
    Win_EnableWidget((ui + '2'), 0)
    Win_SetImg((ui + '2.hammerPic'), 'res/uiRes/icon/platform/platform9012.img')
    Win_SetText((ui + '2.hammerCnt'), str(GetItemLeaveCount(9012)))
    Win_EnableWidget((ui + '3'), 0)
    Win_SetImg((ui + '3.hammerPic'), 'res/uiRes/icon/platform/platform9013.img')
    Win_SetText((ui + '3.hammerCnt'), str(GetItemLeaveCount(9013)))
    Win_ShowWidget('UI.shop.breakEggDlg', 1)
    if ((bSuccess > 0) and PlaySound('X12_01.wav', 1)):
        Win_SetImg('UI.shop.breakEggDlg.resultPic', 'object/ui/shop/breakEgg/success.img')



def setLRPosition():
    print 'itemType,itemSubType:  ',
    print itemType,
    print itemSubType
    if (((itemType == 1) and (itemSubType == 1)) and Win_Move2Pos('UI.shop.left', 258, 375)):
        Win_Move2Pos('UI.shop.right', 383, 375)
        Win_Move2Pos('UI.shop.warePage', 288, 381)



def ui_refreshLightspeed(accel):
    global g_curLightSpeed
    ui = 'UI.shop.fruitMachine'
    g_curLightSpeed = Win_GetValue((ui + '.light'), 49)
    g_curLightSpeed = (g_curLightSpeed + (accel * 0.001))
    Win_SetValue((ui + '.light'), g_curLightSpeed, 49)



def resetFruitMachine():
    ui = 'UI.shop.fruitMachine'
    Win_ShowWidget((ui + '.frame'), 0)
    Win_EnableWidget((ui + '.startBtn'), 1)



def hideWareForFruitMachine():
    ui = 'UI.shop'
    if (((itemType == 1) and (itemSubType == 1)) and Win_ShowWidget((ui + '.ware9'), 0)):
        Win_ShowWidget((ui + '.ware10'), 0)
        Win_ShowWidget((ui + '.ware11'), 0)
        Win_ShowWidget((ui + '.ware12'), 0)
        Win_ShowWidget((ui + '.attr9'), 0)
        Win_ShowWidget((ui + '.attr10'), 0)
        Win_ShowWidget((ui + '.attr11'), 0)
        Win_ShowWidget((ui + '.attr12'), 0)


btn = ['UI.shop.defaultSecrecyValidateDlg.secrecyQuestionRad',
 'UI.shop.defaultSecrecyValidateDlg.mobileMessageRad',
 'UI.shop.defaultSecrecyValidateDlg.secrecyCardRad',
 'UI.shop.defaultSecrecyValidateDlg.mobileTokenRad',
 'UI.shop.defaultSecrecyValidateDlg.telephoneIVRRad']
validateDlg = ['UI.shop.secrecyQuestionDlg',
 'UI.shop.mobileMessageDlg',
 'UI.shop.secrecyCardDlg',
 'UI.shop.mobileTokenDlg',
 'UI.shop.telephoneIVRDlg']

def SetValidateState():
    global validateState
    validateState = 0



def showDefaultPaymentMode(defaultID):
    global secrecyValidateID
    global validateState
    validateState = 1
    secrecyValidateID = defaultID
    ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
    for i in range(5):
        if (((i + 1) == defaultID) and Win_SetCheck(btn[i], 1)):
            pass




def showErrorResult(secValidateID, resultContent):
    if ((secValidateID > 0) and Win_ShowWidget(validateDlg[(secValidateID - 1)], 0)):
        CancelVerify()



def VerifyTimeout():
    Win_ShowWidget('UI.shop.defaultSecrecyValidateDlg', 0)
    for i in range(5):
        Win_ShowWidget(validateDlg[i], 0)

    showErrorResult(0, '\xb6\xd4\xb2\xbb\xc6\xf0\xa3\xac\xc4\xfa\xb5\xc4\xb2\xd9\xd7\xf7\xb3\xac\xca\xb1!')



def showSecrecyValidateDlg(secValidateID):
    global currentQuestionID
    global coorNum
    global coorSize
    global currentQuestionID2
    global currentQuestionID1
    global questionCnt
    global questionNum
    for i in range(5):
        if (((i + 1) == secValidateID) and ui_setCapture(validateDlg[i])):
            pass

    uiDlg = validateDlg[(secValidateID - 1)]
    if ((1 == secValidateID) and Win_SetText((uiDlg + '.questionDlg1.answerText'), '')):
        Win_SetText((uiDlg + '.questionDlg2.answerText'), '')
        Win_SetText((uiDlg + '.questionDlg3.answerText'), '')
        Win_ShowWidget((uiDlg + '.questionDlg1'), 0)
        Win_ShowWidget((uiDlg + '.questionDlg2'), 0)
        Win_ShowWidget((uiDlg + '.questionDlg3'), 0)
        Win_ShowWidget((uiDlg + '.changeQuestion1'), 0)
        Win_ShowWidget((uiDlg + '.changeQuestion2'), 0)
        questionInfo = GetQuestionData()
        questionCnt = int(questionInfo.m_bQuestionCount)
        if ((questionCnt == 0) and showErrorResult(secValidateID, '\xb6\xd4\xb2\xbb\xc6\xf0\xa3\xac\xce\xb4\xc4\xdc\xb3\xc9\xb9\xa6\xbb\xf1\xc8\xa1\xc3\xdc\xb1\xa3\xce\xca\xcc\xe2\xd1\xe9\xd6\xa4\xd0\xc5\xcf\xa2\xa3\xac\xb4\xcb\xb4\xce\xcf\xfb\xb7\xd1\xca\xa7\xb0\xdc')):
            return 
        questionNum = int(questionInfo.m_bQuestionNum)
        for j in range(questionCnt):
            info = GetTheQuestionData(j)
            questionIDList[j] = info.m_cQuestionId

        if (questionNum > 1):
            for j in range(questionNum):
                Win_ShowWidget(((uiDlg + '.questionDlg') + str((j + 1))), 1)
                info = GetTheQuestionData(j)
                question = info.m_szQuestionDes
                Win_SetText((((uiDlg + '.questionDlg') + str((j + 1))) + '.question'), question)

            if ((2 == questionNum) and Win_ShowWidget((uiDlg + '.changeQuestion1'), 1)):
                Win_ShowWidget((uiDlg + '.changeQuestion2'), 1)
            currentQuestionID1 = 0
            currentQuestionID2 = 1
        else:
            if ((1 == questionNum) and Win_ShowWidget((uiDlg + '.questionDlg2'), 1)):
                Win_ShowWidget((uiDlg + '.changeQuestion2'), 1)
                question = GetTheQuestionData(0).m_szQuestionDes
                Win_SetText((uiDlg + '.questionDlg2.question'), question)
                currentQuestionID = 0


class UI_children_shop:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)
    bkimage = 'object/ui/bg/bg_shop.img'
    accel = (('OnAccel_OnF1',
      112,
      0,
      0,
      0),
     ('OnAccel_OnF2',
      113,
      0,
      0,
      0),
     ('OnAccel_OnF3',
      114,
      0,
      0,
      0),
     ('OnAccel_OnF5',
      116,
      0,
      0,
      0),
     ('OnAccel_OnF7',
      118,
      0,
      0,
      0),
     ('OnAccel_OnF8',
      119,
      0,
      0,
      0),
     ('OnAccel_OnF9',
      120,
      0,
      0,
      0),
     ('OnAccel_OnF11',
      122,
      0,
      0,
      0),
     ('OnAccel_OnF12',
      123,
      0,
      0,
      0))

    def OnAccel_OnF1():
        doUI('UI.shop.help', 'OnClick')



    def OnEscape():
        doUI('UI.shop.leaveBtn', 'OnClick')



    def OnAccel_act():
        print '<act>'
        sc_shopPlayer_act(6)



    def OnAccel_stand():
        print '<Win>'
        shopPlayer_stand()



    def OnAccel_jump():
        print '<Win>'
        shopPlayer_jump()



    def OnAccel_freeze():
        print '<Win>'
        shopPlayer_freeze()



    def OnAccel_die():
        print '<Win>'
        shopPlayer_die()



    def OnAccel_changeColor():
        print 'C'
        shopPlayer_changeColor()



    def OnAccel_win():
        print '<Win>'
        shopPlayer_win()



    def OnAccel_putBomb():
        print '<bomb>'
        shopPlayer_putBomb()



    def OnAccel_down():
        print '<Down>'
        shopPlayer_walk(3)



    def OnAccel_left():
        shopPlayer_walk(2)



    def OnAccel_right():
        shopPlayer_walk(0)



    def OnAccel_up():
        shopPlayer_walk(1)



    def OnAccel_keyUp():
        shopPlayer_stop()



    def OnInit():
        global isAllowPresentMixedPay
        global itemType
        global mark_shopPetTab
        global myItemType
        global itemSubType
        global isAllowMixedPay
        global curMoneyType
        global mark_task
        global secrecyValidateID
        global isAllowQBMixedPay
        print 'shop init'
        secrecyValidateID = 1
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        sc_HideWeb('kinMatch')
        sc_HideWeb('kinTeam')
        Win_ShowWidget(uiMenuDlg, 0)
        Win_SetCheck('UI.shop.buyDlg.checkRectQD.checkBtn', 1)
        Win_SetCheck('UI.shop.buyDlg.checkRectQB.checkBtn', 1)
        Win_SetCheck('UI.shop.donateDlg.checkRectQBPresent.checkBtn', 1)
        isAllowMixedPay = 1
        isAllowQBMixedPay = 1
        isAllowPresentMixedPay = 1
        Win_ShowWidget(uiRefineDlg, 0)
        if (isStorageVisible and doUI('UI.shop.storageBtn', 'OnClick')):
            pass
        UpdateMyItem()
        ui_refreshItem()
        ui_updateTicket()
        initFruitMachine()
        if ((loginType == 1) or (loginType == 2)):
            curMoneyType = 'VNet'
            Win_ShowWidget('UI.shop.useQBRad', False)
        else:
            curMoneyType = 'QB'
            Win_ShowWidget('UI.shop.useVNetRad', False)
        itemType = 1
        itemSubType = 1
        myItemType = 2
        Win_SelectSelf('UI.shop.adviceTab')
        doUI('UI.shop.adviceTab', 'OnClick')
        Win_SelectSelf('UI.shop.myFunction')
        clearAllPos()
        ui_updateAll()
        screenStartIn()
        InitPlayerActiveItems()
        if ((curMoneyType == 'QB') and Win_SelectSelf('UI.shop.useQBRad')):
            Win_SetCheck('UI.shop.useQBRad', 1)
        LoadShopKeyboardLayout()
        Win_SetImg('UI.shop.charIcon', getCharIconName())
        InitTaskSys()
        Win_ShowWidget(uiTaskDlg, 0)
        if (mark_task and doUI('UI.shop.taskBtn', 'OnClick')):
            mark_task = 0
        if ((IsShowStorageDlg > 0) and doUI('UI.shop.storageBtn', 'OnClick')):
            pass
        if (mark_shopPetTab > 0):
            mark_shopPetTab = 0
            doUI('UI.shop.petTab', 'OnClick')



    def OnDenit():
        global IsShowStorageDlg
        IsShowStorageDlg = 0
        UnInitTaskSys()


    class children:
        __module__ = __name__
        class defaultSecrecyValidateDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (190,
                     40,
                     200,
                     12)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xc7\xeb\xd1\xa1\xd4\xf1\xd1\xe9\xd6\xa4\xb7\xbd\xca\xbd'

                class secrecyQuestionRad(TRadio):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = ((50 + 10),
                     70,
                     50,
                     25)
                    bkimage = 'object/ui/shop/secrecyValidate/btn_Ratio.img'
                    groupstop = 0

                    def OnClick(this):
                        global secrecyValidateID
                        secrecyValidateID = 1



                class secrecyQuestionLabel(TLabel):
                    __module__ = __name__
                    rect = ((75 + 10),
                     75,
                     80,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xce\xca\xcc\xe2\xd1\xe9\xd6\xa4'

                class mobileMessageRad(secrecyQuestionRad):
                    __module__ = __name__
                    rect = ((50 + 10),
                     100,
                     50,
                     25)
                    groupstop = 1

                    def OnClick(this):
                        global secrecyValidateID
                        secrecyValidateID = 2



                class mobileMessageLabel(secrecyQuestionLabel):
                    __module__ = __name__
                    rect = ((75 + 10),
                     105,
                     200,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xca\xd6\xbb\xfa\xd1\xe9\xd6\xa4'

                class secrecyCardRad(secrecyQuestionRad):
                    __module__ = __name__
                    rect = ((50 + 10),
                     130,
                     50,
                     25)
                    groupstop = 2

                    def OnClick(this):
                        global secrecyValidateID
                        secrecyValidateID = 3



                class secrecyCardLabel(secrecyQuestionLabel):
                    __module__ = __name__
                    rect = ((75 + 10),
                     135,
                     200,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xbf\xa8\xd1\xe9\xd6\xa4'

                class mobileTokenRad(secrecyQuestionRad):
                    __module__ = __name__
                    rect = ((50 + 10),
                     160,
                     50,
                     25)
                    groupstop = 3

                    def OnClick(this):
                        global secrecyValidateID
                        secrecyValidateID = 4



                class mobileTokenLabel(secrecyQuestionLabel):
                    __module__ = __name__
                    rect = ((75 + 10),
                     165,
                     200,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xc1\xee\xc5\xc6\xd1\xe9\xd6\xa4'

                class telephoneIVRRad(secrecyQuestionRad):
                    __module__ = __name__
                    rect = ((50 + 10),
                     190,
                     50,
                     25)
                    groupstop = 4

                    def OnClick(this):
                        global secrecyValidateID
                        secrecyValidateID = 5



                class telephoneIVRLabel(secrecyQuestionLabel):
                    __module__ = __name__
                    rect = ((75 + 10),
                     195,
                     200,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xb5\xe7\xbb\xb0\xd1\xe9\xd6\xa4'

                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        showSecrecyValidateDlg(secrecyValidateID)
                        Win_ShowWidget('UI.shop.defaultSecrecyValidateDlg', 0)



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.defaultSecrecyValidateDlg', 0)





        class secrecyQuestionDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (150,
                     40,
                     250,
                     20)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xb8\xf9\xbe\xdd\xc4\xfa\xb5\xc4\xd1\xa1\xd4\xf1\xa3\xac\xd0\xe8\xbd\xf8\xd0\xd0\xcf\xfb\xb7\xd1\xd1\xe9\xd6\xa4'

                class IDText(TLabel):
                    __module__ = __name__
                    rect = (50,
                     70,
                     200,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xce\xca\xcc\xe2\xd1\xe9\xd6\xa4'

                class questionDlg1(TStatic):
                    __module__ = __name__
                    rect = (50,
                     90,
                     250,
                     45)
                    class children:
                        __module__ = __name__
                        class questionLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             5,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xce\xca\xcc\xe2:'

                        class question(TLabel):
                            __module__ = __name__
                            rect = (30,
                             5,
                             350,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xc4\xfa\xc9\xd0\xce\xb4\xc9\xe8\xd6\xc3\xce\xca\xcc\xe2'

                        class answerLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             25,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xb4\xf0\xb0\xb8'

                        class answerText(TEdit):
                            __module__ = __name__
                            rect = (30,
                             21,
                             220,
                             24)
                            captionrect = (4,
                             5,
                             200,
                             14)
                            maxchar = 150
                            bkimage = 'object/ui/shop/secrecyValidate/txt_long.img'
                            textEdgeType = -1



                class changeQuestion1(THyperLink):
                    __module__ = __name__
                    rect = (300,
                     115,
                     60,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xbb\xbb\xb8\xf6\xce\xca\xcc\xe2'

                    def OnClick(this):
                        global currentQuestionID1
                        print ('before(%d,%d)' % (currentQuestionID1,
                         currentQuestionID2))
                        for i in range(questionCnt):
                            if ((i != currentQuestionID1) and (i != currentQuestionID2)):
                                currentQuestionID1 = i
                                break

                        print ('after(%d,%d)' % (currentQuestionID1,
                         currentQuestionID2))
                        question = GetTheQuestionData(currentQuestionID1).m_szQuestionDes
                        Win_SetText('UI.shop.secrecyQuestionDlg.questionDlg1.question', question)



                class questionDlg2(TStatic):
                    __module__ = __name__
                    rect = (50,
                     135,
                     250,
                     45)
                    class children:
                        __module__ = __name__
                        class questionLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             5,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xce\xca\xcc\xe2:'

                        class question(TLabel):
                            __module__ = __name__
                            rect = (30,
                             5,
                             350,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)

                        class answerLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             25,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xb4\xf0\xb0\xb8'

                        class answerText(TEdit):
                            __module__ = __name__
                            rect = (30,
                             21,
                             220,
                             24)
                            captionrect = (4,
                             5,
                             200,
                             14)
                            maxchar = 150
                            bkimage = 'object/ui/shop/secrecyValidate/txt_long.img'
                            textEdgeType = -1



                class changeQuestion2(THyperLink):
                    __module__ = __name__
                    rect = (300,
                     160,
                     60,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xbb\xbb\xb8\xf6\xce\xca\xcc\xe2'

                    def OnClick(this):
                        global currentQuestionID2
                        global currentQuestionID
                        if (1 == questionNum):
                            for i in range(questionCnt):
                                if (i == currentQuestionID):
                                    currentQuestionID = ((i + 1) % 3)
                                    break

                            question2ID = currentQuestionID
                        if (2 == questionNum):
                            for i in range(questionCnt):
                                if ((i != currentQuestionID1) and (i != currentQuestionID2)):
                                    currentQuestionID2 = i
                                    break

                            question2ID = currentQuestionID2
                        question = GetTheQuestionData(question2ID).m_szQuestionDes
                        Win_SetText('UI.shop.secrecyQuestionDlg.questionDlg2.question', question)



                class questionDlg3(TStatic):
                    __module__ = __name__
                    rect = (50,
                     180,
                     350,
                     45)
                    class children:
                        __module__ = __name__
                        class questionLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             5,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xce\xca\xcc\xe2:'

                        class question(TLabel):
                            __module__ = __name__
                            rect = (30,
                             5,
                             350,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)

                        class answerLabel(TLabel):
                            __module__ = __name__
                            rect = (0,
                             25,
                             30,
                             12)
                            drawcolor = (40,
                             40,
                             40,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            caption = '\xb4\xf0\xb0\xb8'

                        class answerText(TEdit):
                            __module__ = __name__
                            rect = (30,
                             21,
                             220,
                             24)
                            captionrect = (4,
                             5,
                             200,
                             14)
                            maxchar = 150
                            bkimage = 'object/ui/shop/secrecyValidate/txt_long.img'
                            textEdgeType = -1



                class forwardBtn(TButton):
                    __module__ = __name__
                    rect = (140,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_forward.img'

                    def OnClick(this):
                        ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
                        Win_ShowWidget('UI.shop.secrecyQuestionDlg', 0)



                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        realQuestionID = ['1',
                         '2',
                         '3']
                        realQuestionID[0] = questionIDList[currentQuestionID1]
                        realQuestionID[1] = questionIDList[currentQuestionID2]
                        for i in range(questionNum):
                            if ((i != currentQuestionID1) and (i != currentQuestionID2)):
                                realQuestionID[2] = questionIDList[i]

                        if (questionNum == 1):
                            answer = Win_GetText('UI.shop.secrecyQuestionDlg.questionDlg2.answerText')
                            if ((len(answer) == 0) and showErrorResult(0, '\xb4\xf0\xb0\xb8\xb2\xbb\xc4\xdc\xce\xaa\xbf\xd5\xa3\xac\xc7\xeb\xba\xcb\xca\xb5\xba\xf3\xd6\xd8\xd0\xc2\xca\xe4\xc8\xeb\xb4\xf0\xb0\xb8')):
                                pass
                        else:
                            for i in range(questionNum):
                                answer = Win_GetText((('UI.shop.secrecyQuestionDlg.questionDlg' + str((i + 1))) + '.answerText'))
                                if ((len(answer) == 0) and showErrorResult(0, (('\xb5\xda' + str((i + 1))) + '\xb8\xf6\xce\xca\xcc\xe2\xb5\xc4\xb4\xf0\xb0\xb8\xb2\xbb\xc4\xdc\xce\xaa\xbf\xd5\xa3\xac\xc7\xeb\xba\xcb\xca\xb5\xba\xf3\xd6\xd8\xd0\xc2\xca\xe4\xc8\xeb\xb4\xf0\xb0\xb8'))):
                                    return 

                            for i in range(questionNum):
                                answer = Win_GetText((('UI.shop.secrecyQuestionDlg.questionDlg' + str((i + 1))) + '.answerText'))
                                SetAnswerData(questionNum, realQuestionID[i], len(answer), answer)

                            Win_ShowWidget('UI.shop.secrecyQuestionDlg', 0)



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.secrecyQuestionDlg', 0)





        class mobileMessageDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (150,
                     40,
                     250,
                     12)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xb8\xf9\xbe\xdd\xc4\xfa\xb5\xc4\xd1\xa1\xd4\xf1\xa3\xac\xd0\xe8\xbd\xf8\xd0\xd0\xcf\xfb\xb7\xd1\xd1\xe9\xd6\xa4'

                class IDText(TLabel):
                    __module__ = __name__
                    rect = (50,
                     70,
                     200,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xca\xd6\xbb\xfa\xb7\xa2\xb6\xcc\xd0\xc5\xd1\xe9\xd6\xa4'

                class labelNumber(TLabel):
                    __module__ = __name__
                    rect = (50,
                     100,
                     102,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc4\xfa\xb5\xc4\xc3\xdc\xb1\xa3\xca\xd6\xbb\xfa\xba\xc5\xca\xc7:'

                class mobileNumber(TLabel):
                    __module__ = __name__
                    rect = (155,
                     100,
                     100,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)

                class contentLabel1(TLabel):
                    __module__ = __name__
                    rect = (50,
                     125,
                     300,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)

                class checkCodeLabel(TLabel):
                    __module__ = __name__
                    rect = (50,
                     165,
                     200,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc7\xeb\xca\xe4\xc8\xeb\xc4\xfa\xca\xd5\xb5\xbd\xb5\xc4\xd1\xe9\xd6\xa4\xc2\xeb\xbb\xd8\xb8\xb4'

                class checkCodeText(TEditCharNum):
                    __module__ = __name__
                    caption = ''
                    editable = 1
                    textstyle = 0
                    rect = (50,
                     182,
                     200,
                     24)
                    captionrect = (4,
                     5,
                     50,
                     14)
                    maxchar = 8
                    bkimage = 'object/ui/shop/secrecyValidate/txt_long.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                class checkCodeIndex(TLabel):
                    __module__ = __name__
                    rect = (50,
                     212,
                     300,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xd1\xe9\xd6\xa4\xc2\xeb\xca\xc7\xc4\xfa\xb7\xa2\xcb\xcd\xb6\xcc\xd0\xc5\xba\xf3\xca\xd5\xb5\xbd\xb5\xc48\xce\xbb\xca\xfd\xd7\xd6\xbb\xd8\xb8\xb4'

                class forwardBtn(TButton):
                    __module__ = __name__
                    rect = (140,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_forward.img'

                    def OnClick(this):
                        ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
                        Win_ShowWidget('UI.shop.mobileMessageDlg', 0)



                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        text = Win_GetText('UI.shop.mobileMessageDlg.checkCodeText')
                        if ((len(text) < 8) and showErrorResult(0, '\xc4\xfa\xc3\xbb\xd3\xd0\xca\xe4\xc8\xeb\xbb\xf2\xca\xe4\xc8\xeb\xb5\xc4\xd1\xe9\xd6\xa4\xc2\xeb\xb2\xbb\xb9\xbb8\xce\xbb\xa3\xac\xc7\xeb\xba\xcb\xca\xb5\xba\xf3\xd6\xd8\xd0\xc2\xca\xe4\xc8\xeb')):
                            pass



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.mobileMessageDlg', 0)





        class secrecyCardDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (150,
                     40,
                     250,
                     12)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xb8\xf9\xbe\xdd\xc4\xfa\xb5\xc4\xd1\xa1\xd4\xf1\xa3\xac\xd0\xe8\xbd\xf8\xd0\xd0\xcf\xfb\xb7\xd1\xd1\xe9\xd6\xa4'

                class IDText(TLabel):
                    __module__ = __name__
                    rect = (50,
                     70,
                     200,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xbf\xa8\xd1\xe9\xd6\xa4'

                class licenseLabel(TLabel):
                    __module__ = __name__
                    rect = (50,
                     100,
                     110,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc4\xfa\xb5\xc4\xc3\xdc\xb1\xa3\xbf\xa8\xd0\xf2\xc1\xd0\xba\xc5:'

                class licenseText(licenseLabel):
                    __module__ = __name__
                    rect = (160,
                     100,
                     100,
                     12)

                class cardPosLabel(licenseLabel):
                    __module__ = __name__
                    rect = (50,
                     150,
                     100,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xbf\xa8\xce\xbb\xd6\xc3:'

                class cardPos1(licenseLabel):
                    __module__ = __name__
                    rect = (123,
                     150,
                     30,
                     12)

                class cardPos2(licenseLabel):
                    __module__ = __name__
                    rect = (164,
                     150,
                     30,
                     12)

                class cardPos3(licenseLabel):
                    __module__ = __name__
                    rect = (203,
                     150,
                     30,
                     12)

                class cardNumberLabel(licenseLabel):
                    __module__ = __name__
                    rect = (50,
                     180,
                     70,
                     12)
                    caption = '\xc3\xdc\xb1\xa3\xbf\xa8\xca\xfd\xd7\xd6:'

                class cardNumber1(TEditCharNum):
                    __module__ = __name__
                    caption = ''
                    editable = 1
                    textstyle = 0
                    rect = (120,
                     175,
                     30,
                     24)
                    captionrect = (6,
                     5,
                     30,
                     14)
                    maxchar = 2
                    bkimage = 'object/ui/shop/secrecyValidate/txt_small.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                class cardNumber2(cardNumber1):
                    __module__ = __name__
                    rect = (158,
                     175,
                     30,
                     24)

                class cardNumber3(cardNumber1):
                    __module__ = __name__
                    rect = (196,
                     175,
                     30,
                     24)

                class resetCardLink(THyperLink):
                    __module__ = __name__
                    rect = (270,
                     181,
                     100,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    URL = 'https://mibaoka.qq.com/cgi-bin/index'
                    caption = '\xd6\xd8\xd0\xc2\xc9\xe8\xd6\xc3\xc3\xdc\xb1\xa3\xbf\xa8'

                class forwardBtn(TButton):
                    __module__ = __name__
                    rect = (140,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_forward.img'

                    def OnClick(this):
                        ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
                        Win_ShowWidget('UI.shop.secrecyCardDlg', 0)



                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        ui = 'UI.shop.secrecyCardDlg'
                        cardValue = ['',
                         '',
                         '',
                         '']
                        for i in range(coorNum):
                            cardValue[i] = Win_GetText(((ui + '.cardNumber') + str((i + 1))))
                            if ((len(cardValue[i]) != coorSize) and showErrorResult(0, (((('\xc4\xfa\xca\xe4\xc8\xeb\xb5\xc4\xb5\xda' + str((i + 1))) + '\xb8\xf6\xc3\xdc\xb1\xa3\xbf\xa8\xca\xfd\xd7\xd6\xce\xde\xd0\xa7\xa3\xac\xc7\xeb\xca\xe4\xc8\xeb') + str(coorSize)) + '\xce\xbb\xc3\xdc\xb1\xa3\xca\xfd\xd7\xd6'))):
                                return 

                        cardCoorList = ''
                        cardPwdList = ''
                        pwdLen = 0
                        for i in range(coorNum):
                            cardCoorList = (cardCoorList + coorList[i])
                            cardPwdList = (cardPwdList + cardValue[i])
                            pwdLen = (pwdLen + len(cardValue[i]))

                        SetCardData(coorNum, coorSize, cardCoorList, pwdLen, cardPwdList)
                        Win_ShowWidget('UI.shop.secrecyCardDlg', 0)



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.secrecyCardDlg', 0)





        class mobileTokenDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (150,
                     40,
                     250,
                     12)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xb8\xf9\xbe\xdd\xc4\xfa\xb5\xc4\xd1\xa1\xd4\xf1\xa3\xac\xd0\xe8\xbd\xf8\xd0\xd0\xcf\xfb\xb7\xd1\xd1\xe9\xd6\xa4'

                class IDText(TLabel):
                    __module__ = __name__
                    rect = (50,
                     85,
                     200,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xc1\xee\xc5\xc6\xd1\xe9\xd6\xa4'

                class tokenLabel(TLabel):
                    __module__ = __name__
                    rect = (50,
                     120,
                     350,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc7\xeb\xc4\xfa\xb6\xd4\xd5\xd5\xc4\xfa\xca\xd6\xbb\xfa\xc9\xcf\xb5\xc4\xc3\xdc\xb1\xa3\xc1\xee\xc5\xc6\xc8\xed\xbc\xfe\xa3\xac\xb0\xb4\xd5\xd5\xcf\xd4\xca\xbe\xb5\xc46\xce\xbb\xca\xfd\xd7\xd6\xca\xe4\xc8\xeb'

                class tokenText(TEditCharNum):
                    __module__ = __name__
                    textstyle = 0
                    editable = 1
                    rect = (50,
                     140,
                     274,
                     24)
                    captionrect = (4,
                     5,
                     50,
                     14)
                    maxchar = 6
                    bkimage = 'object/ui/shop/secrecyValidate/txt_long.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                class forwardBtn(TButton):
                    __module__ = __name__
                    rect = (140,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_forward.img'

                    def OnClick(this):
                        ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
                        Win_ShowWidget('UI.shop.mobileTokenDlg', 0)



                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        text = Win_GetText('UI.shop.mobileTokenDlg.tokenText')
                        if ((len(text) < 6) and showErrorResult(0, '\xc4\xfa\xc3\xbb\xd3\xd0\xca\xe4\xc8\xeb\xbb\xf2\xca\xe4\xc8\xeb\xb5\xc4Token\xc2\xeb\xb2\xbb\xb9\xbb6\xce\xbb,\xc7\xeb\xba\xcb\xca\xb5\xba\xf3\xd6\xd8\xd0\xc2\xca\xe4\xc8\xeb')):
                            pass



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.mobileTokenDlg', 0)





        class telephoneIVRDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = 999999
            rect = (219,
             91,
             450,
             315)
            bkimage = 'object/ui/shop/secrecyValidate/dlg_DefaultSecrecyValidate.img'
            class children:
                __module__ = __name__
                class title(TLabel):
                    __module__ = __name__
                    rect = (150,
                     40,
                     250,
                     12)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (66,
                     95,
                     133,
                     255)
                    caption = '\xb8\xf9\xbe\xdd\xc4\xfa\xb5\xc4\xd1\xa1\xd4\xf1\xa3\xac\xd0\xe8\xbd\xf8\xd0\xd0\xcf\xfb\xb7\xd1\xd1\xe9\xd6\xa4'

                class IDText(TLabel):
                    __module__ = __name__
                    rect = (50,
                     70,
                     200,
                     12)
                    drawcolor = (0,
                     0,
                     255,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    caption = '\xc3\xdc\xb1\xa3\xb5\xe7\xbb\xb0\xd1\xe9\xd6\xa4'

                class telephoneNumLabel(TLabel):
                    __module__ = __name__
                    rect = (50,
                     120,
                     300,
                     12)
                    drawcolor = (40,
                     40,
                     40,
                     255)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)

                class telephoneIVRLabel(telephoneNumLabel):
                    __module__ = __name__
                    rect = (50,
                     140,
                     350,
                     12)

                class forwardBtn(TButton):
                    __module__ = __name__
                    rect = (140,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_forward.img'

                    def OnClick(this):
                        ui_setCapture('UI.shop.defaultSecrecyValidateDlg')
                        Win_ShowWidget('UI.shop.telephoneIVRDlg', 0)



                class nextBtn(TButton):
                    __module__ = __name__
                    rect = (221,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_next.img'

                    def OnClick(this):
                        SetIVRResult()
                        Win_ShowWidget('UI.shop.telephoneIVRDlg', 0)



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (327,
                     264,
                     80,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/secrecyValidate/btn_cancel.img'

                    def OnClick(this):
                        CancelVerify()
                        Win_ShowWidget('UI.shop.telephoneIVRDlg', 0)





        class errorResultDlg(TStatic):
            __module__ = __name__
            darkBG = 1
            visible = 0
            initlayer = (999999 + 1)
            rect = (219,
             91,
             363,
             338)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            class children:
                __module__ = __name__
                class content(TLabel):
                    __module__ = __name__
                    rect = (35,
                     100,
                     300,
                     30)
                    drawcolor = lightColor
                    textEdgeType = 1
                    textEdgeColor = (40,
                     40,
                     40,
                     255)
                    caption = ''

                class confirmBtn(TButton):
                    __module__ = __name__
                    rect = (150,
                     275,
                     41,
                     41)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/common/btn_confirm.img'

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.errorResultDlg', 0)





        class useQBRad(TRadio):
            __module__ = __name__
            initlayer = -9999
            rect = (438,
             3,
             92,
             30)
            bkimage = 'object/ui/shop/rad_QB.img'
            (groupid, groupstop,) = (77,
             1)

            def OnClick(this):
                global curMoneyType
                PlaySound(soundUI, 1)
                curMoneyType = 'QB'
                clearAllChecks()
                clearAllPos()
                ui_updateWares()
                ui_updateWarePages()



        class useTangBRad(useQBRad):
            __module__ = __name__
            initlayer = -9999
            groupstop = 2
            rect = (535,
             3,
             92,
             30)
            bkimage = 'object/ui/shop/rad_TangB.img'

            def OnClick(this):
                global curMoneyType
                PlaySound(soundUI, 1)
                curMoneyType = 'TangB'
                clearAllChecks()
                clearAllPos()
                ui_updateWares()
                ui_updateWarePages()



        class useVNetRad(useQBRad):
            __module__ = __name__
            initlayer = -9999
            rect = (438,
             0,
             95,
             23)
            bkimage = 'object/ui/shop/rad_VNet.img'
            groupstop = 3

            def OnClick(this):
                global curMoneyType
                PlaySound(soundUI, 1)
                curMoneyType = 'VNet'
                clearAllChecks()
                ui_updateWares()
                ui_updateWarePages()



        class sugarMoney:
            __module__ = __name__
            rect = (679,
             32,
             110,
             13)
            type = 'NUMLABEL'
            bkimage = 'object/ui/common/numberMoney.img'
            textsize = 10
            textwidth = 9
            textheight = 13

            def OnInit():
                (qb, game, sugar,) = getMoney()
                if ((-1 == sugar) and Win_SetText('UI.shop.sugarMoney', '')):
                    pass



        class shopTicket:
            __module__ = __name__
            rect = (699,
             8,
             110,
             13)
            type = 'NUMLABEL'
            bkimage = 'object/ui/common/numberMoney.img'
            textsize = 10
            textwidth = 9
            textheight = 13
            textstyle = dt_left

            def OnInit():
                if ((QQTTicket < 0) and Win_SetText('UI.shop.shopTicket', '')):
                    pass



        class functionTab(TTabWin):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (82,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_func.img'
            groupstop = 1

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xb9\xa6\xc4\xdc\xb5\xc0\xbe\xdf')
                Win_SetText('UI.shop.subTab2', '\xd3\xce\xcf\xb7\xb5\xc0\xbe\xdf')
                Win_SetText('UI.shop.subTab3', '\xc6\xe4 \xcb\xfc')
                Win_SetText('UI.shop.subTab4', '\xbf\xe1\xb1\xc8\xb1\xa6\xca\xaf')
                Win_SetText('UI.shop.subTab5', '')
                setItemType(2)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class adviceTab(functionTab):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (16,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_advice.img'
            groupstop = 0

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xd0\xc2\xc6\xb7\xcd\xc6\xbc\xf6')
                Win_SetText('UI.shop.subTab2', '\xb5\xcd\xbc\xdb\xb4\xd9\xcf\xfa')
                Win_SetText('UI.shop.subTab3', '\xcc\xd7\xd7\xb0\xc8\xc8\xc2\xf4')
                Win_SetText('UI.shop.subTab4', '\xcf\xb5\xc1\xd0\xd5\xb9\xca\xbe')
                Win_SetText('UI.shop.subTab5', '')
                setItemType(1)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class costumeTab(functionTab):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (149,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_adorn.img'
            groupstop = 2

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xcc\xc7 \xc5\xdd')
                Win_SetText('UI.shop.subTab2', '\xbb\xc3 \xd3\xb0')
                Win_SetText('UI.shop.subTab3', '\xb1\xb3 \xbe\xb0')
                Win_SetText('UI.shop.subTab4', '\xb1\xdf\xbf\xf2\xc8\xeb\xb3\xa1')
                Win_SetText('UI.shop.subTab5', '\xc3\xfb \xc6\xac')
                setItemType(3)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class equipTab(functionTab):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (216,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_equip.img'
            groupstop = 3

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xcd\xb7 \xb2\xbf')
                Win_SetText('UI.shop.subTab2', '\xd5\xfd \xc3\xe6')
                Win_SetText('UI.shop.subTab3', '\xb1\xb3 \xc3\xe6')
                Win_SetText('UI.shop.subTab4', '\xc9\xed \xcc\xe5')
                Win_SetText('UI.shop.subTab5', '\xbd\xc5 \xd3\xa1')
                setItemType(4)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class petTab(functionTab):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (283,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_pet.img'
            groupstop = 4

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xb3\xe8\xce\xef\xca\xb3\xc6\xb7')
                Win_SetText('UI.shop.subTab2', '\xb3\xe8\xce\xef\xbc\xbc\xc4\xdc')
                Win_SetText('UI.shop.subTab3', '\xb3\xe8\xce\xef\xbf\xa8\xc6\xac')
                Win_SetText('UI.shop.subTab4', '')
                Win_SetText('UI.shop.subTab5', '')
                setItemType(5)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class purplediamondTab(functionTab):
            __module__ = __name__
            initlayer = 999
            rect = (0,
             0,
             1,
             1)
            hotrect = (350,
             7,
             63,
             28)
            hotcover = 'object/ui/shop/tab_zizuan.img'
            groupstop = 5

            def OnClick(this):
                Win_SetText('UI.shop.subTab1', '\xd7\xa8\xca\xf4\xb5\xc0\xbe\xdf')
                Win_SetText('UI.shop.subTab2', '')
                Win_SetText('UI.shop.subTab3', '')
                Win_SetText('UI.shop.subTab4', '')
                Win_SetText('UI.shop.subTab5', '')
                setItemType(6)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)
                updateSelectedItems()



        class subTab1(TRadio):
            __module__ = __name__
            framescheme = [(0,
              0,
              0,
              0,
              0,
              0,
              0,
              0),
             (1,
              1,
              1,
              1,
              1,
              1,
              1,
              1)]
            groupid = 2
            groupstop = 0
            rect = (21,
             44,
             57,
             25)
            bkimage = 'object/ui/shop/tab_sub.img'
            captionrect = (0,
             4,
             57,
             12)
            drawcolor = (106,
             94,
             86,
             255)
            textEdgeColor = lightColor
            textEdgeType = 0
            textstyle = dt_center

            def OnClick(this):
                Win_SetFocus()
                setItemSubType(1)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)



        class subTab2(subTab1):
            __module__ = __name__
            groupstop = 1
            rect = (84,
             44,
             57,
             25)

            def OnClick(this):
                Win_SetFocus()
                setItemSubType(2)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)



        class subTab3(subTab1):
            __module__ = __name__
            groupstop = 2
            rect = (147,
             44,
             57,
             25)

            def OnClick(this):
                Win_SetFocus()
                setItemSubType(3)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)



        class subTab4(subTab1):
            __module__ = __name__
            groupstop = 3
            rect = (210,
             44,
             57,
             25)

            def OnClick(this):
                Win_SetFocus()
                setItemSubType(4)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)



        class subTab5(subTab1):
            __module__ = __name__
            groupstop = 4
            rect = (273,
             44,
             57,
             25)

            def OnClick(this):
                Win_SetFocus()
                setItemSubType(5)
                hideWareForFruitMachine()
                setLRPosition()
                PlaySound(soundUI, 1)



        class ware1(TCheck):
            __module__ = __name__
            initlayer = 2
            rect = (16,
             84,
             198,
             72)
            bkimage = 'object/ui/shop/img_ware.img'
            framescheme = [(1,
              1,
              1,
              1,
              1,
              1,
              1,
              1),
             (0,
              0,
              0,
              0,
              0,
              0,
              0,
              0)]
            groupstop = 1
            tipwidget = 'UI.shop.description'

            def OnMouseMoveIn():
                ui = 'UI.shop.description'
                i = (getMyMidIdx() - 1)
                wareID = wareIDs[i]
                if (wareID > 0):
                    statement = curDispWares[i].statement
                    info = WareList().at(itemType, itemSubType, (warePos[itemType][itemSubType] + i))
                    Win_ShowWidget(ui, 1)
                    Win_SetText(ui, (statement[0:34] + '......'))
                    me = Win_GetMyPath()
                    winrect = Win_GetRect(me, value_channel_winrect)
                    caprect = Win_GetRect(ui, value_channel_captionrect)
                    Win_Move2Pos(ui, (winrect[0] + 70), ((winrect[1] + caprect[3]) - 10))
                else:
                    Win_ShowWidget(ui, 0)
                    return 



            def OnClick(me):
                ID = Win_GetText((me + '.ID'))
                if (Win_IsChecked(me) and clearChecks()):
                    Win_SetCheck(me, True)
                    useWare(ID)
                    wareCheck[itemType][itemSubType] = (getMyIdx() + warePos[itemType][itemSubType])
                    Win_ShowWidget((me + '.frame'), 1)
                Win_SetFocus()


            class children:
                __module__ = __name__
                class frame(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = -999
                    rect = (0,
                     0,
                     1,
                     1)
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    bkimage = 'object/ui/shop/img_wareFrame.img'

                class ID(TString):
                    __module__ = __name__
                    caption = '-1'

                class picture(TStatic):
                    __module__ = __name__
                    bkImgFlag = dt_center
                    rect = (3,
                     3,
                     66,
                     66)

                class name(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (80,
                     (70 - 60),
                     (227 - 114),
                     12)
                    drawcolor = (255,
                     255,
                     0,
                     255)

                class pricePic(TStatic):
                    __module__ = __name__
                    rect = (((97 - 19) - 6),
                     ((104 - 55) - 20),
                     24,
                     12)

                class price1(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (((97 - 19) - 6),
                     ((104 - 55) - 20),
                     24,
                     12)
                    drawcolor = (255,
                     255,
                     255,
                     255)
                    textstyle = dt_left
                    textLineType = 1

                class price2(TLabel,
                 Static):
                    __module__ = __name__
                    rect = ((((97 - 19) - 6) + 31),
                     ((104 - 55) - 20),
                     48,
                     12)
                    drawcolor = (255,
                     255,
                     255,
                     255)
                    caption = ''
                    textstyle = dt_right

                class memberPic(TStatic):
                    __module__ = __name__
                    rect = (((97 - 19) - 6),
                     50,
                     27,
                     12)
                    bkimage = 'object/ui/shop/wareAttr/memberPic.img'

                class memberPrice(TLabel,
                 Static):
                    __module__ = __name__
                    rect = ((((97 - 19) - 6) + 25),
                     50,
                     ((178 - 144) + 20),
                     12)
                    drawcolor = (255,
                     255,
                     255,
                     255)
                    textstyle = dt_right

                class buyA(TButton):
                    __module__ = __name__
                    initlayer = -99
                    rect = (158,
                     25,
                     36,
                     42)
                    bkimage = 'object/ui/shop/btn_buy.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        global curBuyWareID
                        global execStr
                        global curBuyWareIdx
                        if SC_ClickBuyBtn():
                            i = (getMyMidIdx() - 1)
                            wareID = wareIDs[i]
                            buyMode = buyModes[i][0]
                            if (wareID > 0):
                                curBuyWareIdx = i
                                execStr = ('BuyCommodity(%d, 2, %d, 0)' % (wareID,
                                 buyMode))
                                curBuyWareID = wareID
                                name = Win_GetText(('UI.shop.ware%d.name' % (i + 1)))
                                fee = Win_GetText(('UI.shop.ware%d.price1' % (i + 1)))
                                fee2 = Win_GetText(('UI.shop.ware%d.price2' % (i + 1)))
                                statement = curDispWares[i].statement
                                info = WareList().at(itemType, itemSubType, (warePos[itemType][itemSubType] + i))
                                if (curDispWares[i].period >= 0):
                                    periodStr = day2str(curDispWares[i].period)
                                    txt = ((('\xca\xb9\xd3\xc3\xca\xb1\xbc\xe4: %s\n' % periodStr) + '\xc9\xcc\xc6\xb7\xc3\xe8\xca\xf6: ') + statement)
                                else:
                                    numStr = (str(info.num) + ' \xb8\xf6')
                                    txt = ((('\xb5\xc0\xbe\xdf\xca\xfd\xc1\xbf: %s\n' % numStr) + '\xc9\xcc\xc6\xb7\xc3\xe8\xca\xf6: ') + statement)
                                ui = 'UI.shop.buyDlg'
                                Win_SetText((ui + '.name'), name)
                                rebate = 100
                                memberRebate = 100
                                if ((info.rebate >= 0) and (info.rebate < 100)):
                                    rebate = info.rebate
                                if ((isLeague or isQQMember) and ((info.memberRebate >= 0) and (info.memberRebate < 100))):
                                    memberRebate = info.memberRebate
                            if ((curMoneyType == 'QB') and Win_SetText((ui + '.price1'), makeStr(15, ((((info.priceQQ * memberRebate) * rebate) + 9999) / 10000), ' Q\xb1\xd2', 1))):
                                Win_SetText((ui + '.price2'), makeStr(15, ((((info.priceQQ * memberRebate) * rebate) + 999) / 1000), '\xbf\xe1\xb1\xc8\xb1\xa6\xca\xaf'))
                                Win_SetText((ui + '.price3'), makeStr(15, ((((info.priceGame * memberRebate) * rebate) + 9999) / 10000), 'Q\xb5\xe3'))
                            Win_SetText((ui + '.txt'), txt)
                            Win_ShowWidget((ui + '.buy2Btn'), (curMoneyType == 'QB'))
                            Win_ShowWidget((ui + '.price2'), (curMoneyType == 'QB'))
                            Win_ShowWidget((ui + '.buy3Btn'), (curMoneyType == 'QB'))
                            Win_ShowWidget((ui + '.price3'), (curMoneyType == 'QB'))
                            desc = commodityList[curBuyWareID]
                            (type, idx,) = desc[0:2]
                            if (((type == 'xeffect') or (type == 'feffect')) and Win_SetImg((ui + '.preview'), ((('object/xeffect/' + type) + str(idx)) + '_pre.img'))):
                                Win_ShowWidget((ui + '.preview'), True)
                            Win_EnableWidget((ui + '.donateBtn'), ((curMoneyType != 'VNet') or (loginType == 0)))
                            ui_setCapture(ui)





        class ware2(ware1):
            __module__ = __name__
            rect = (217,
             84,
             198,
             72)
            groupstop = 2
            initlayer = 1

        class ware3(ware1):
            __module__ = __name__
            rect = (16,
             (84 + 73),
             198,
             72)
            groupstop = 3
            initlayer = 4

        class ware4(ware1):
            __module__ = __name__
            rect = (217,
             (84 + 73),
             198,
             72)
            groupstop = 4
            initlayer = 3

        class ware5(ware1):
            __module__ = __name__
            rect = (16,
             (84 + (73 * 2)),
             198,
             72)
            groupstop = 5
            initlayer = 6

        class ware6(ware1):
            __module__ = __name__
            rect = (217,
             (84 + (73 * 2)),
             198,
             72)
            groupstop = 6
            initlayer = 5

        class ware7(ware1):
            __module__ = __name__
            rect = (16,
             (84 + (73 * 3)),
             198,
             72)
            groupstop = 7
            initlayer = 8

        class ware8(ware1):
            __module__ = __name__
            rect = (217,
             (84 + (73 * 3)),
             198,
             72)
            groupstop = 8
            initlayer = 7

        class ware9(ware1):
            __module__ = __name__
            rect = (16,
             (84 + (73 * 4)),
             198,
             72)
            groupstop = 9
            initlayer = 10

        class ware10(ware1):
            __module__ = __name__
            rect = (217,
             (84 + (73 * 4)),
             198,
             72)
            groupstop = 10
            initlayer = 9

        class ware11(ware1):
            __module__ = __name__
            rect = (16,
             (84 + (73 * 5)),
             198,
             72)
            groupstop = 11
            initlayer = 12

        class ware12(ware1):
            __module__ = __name__
            rect = (217,
             (84 + (73 * 5)),
             198,
             72)
            groupstop = 12
            initlayer = 11

        class attr1(TStatic):
            __module__ = __name__
            initlayer = 99999
            visible = 1
            rect = (174,
             55,
             61,
             57)
            bkimage = ''
            class children:
                __module__ = __name__
                class rebate(TStatic):
                    __module__ = __name__
                    rect = (20,
                     27,
                     11,
                     15)
                    bkimage = ''

                class rebateH(TStatic):
                    __module__ = __name__
                    rect = (5,
                     27,
                     11,
                     15)
                    bkimage = ''

                class point(TStatic):
                    __module__ = __name__
                    rect = (16,
                     27,
                     11,
                     15)
                    bkimage = 'object/ui/shop/wareAttr/point.img'

                class rebateL(TStatic):
                    __module__ = __name__
                    rect = (23,
                     27,
                     11,
                     15)
                    bkimage = ''

                class rebateWord(TStatic):
                    __module__ = __name__
                    rect = (35,
                     27,
                     18,
                     18)
                    bkimage = 'object/ui/shop/wareAttr/zhe.img'



        class attr2(attr1):
            __module__ = __name__
            rect = (374,
             55,
             61,
             57)

        class attr3(attr1):
            __module__ = __name__
            rect = (174,
             (55 + 73),
             61,
             57)

        class attr4(attr1):
            __module__ = __name__
            rect = (374,
             (55 + 73),
             61,
             57)

        class attr5(attr1):
            __module__ = __name__
            rect = (174,
             (55 + (73 * 2)),
             61,
             57)

        class attr6(attr1):
            __module__ = __name__
            rect = (374,
             (55 + (73 * 2)),
             61,
             57)

        class attr7(attr1):
            __module__ = __name__
            rect = (174,
             (55 + (73 * 3)),
             61,
             57)

        class attr8(attr1):
            __module__ = __name__
            rect = (374,
             (55 + (73 * 3)),
             61,
             57)

        class attr9(attr1):
            __module__ = __name__
            rect = (174,
             (55 + (73 * 4)),
             61,
             57)

        class attr10(attr1):
            __module__ = __name__
            rect = (374,
             (55 + (73 * 4)),
             61,
             57)

        class attr11(attr1):
            __module__ = __name__
            rect = (174,
             (55 + (73 * 5)),
             61,
             57)

        class attr12(attr1):
            __module__ = __name__
            rect = (374,
             (55 + (73 * 5)),
             61,
             57)

        class description:
            __module__ = __name__
            type = 'DYLABEL'
            initlayer = 99999999
            rect = (0,
             0,
             130,
             1)
            captionrect = (4,
             4,
             120,
             1)
            bkimage = 'object/ui/common/img_tip.img'
            textEdgeType = -1
            drawcolor = maskColor

        class warePage:
            __module__ = __name__
            initlayer = 100000
            type = 'NUMLABEL'
            rect = (290,
             378,
             100,
             24)
            bkimage = 'object/ui/common/number2.img'
            textstyle = dt_center
            textsize = 19
            textwidth = 19
            textheight = 24

        class left(TButton):
            __module__ = __name__
            initlayer = 100000
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (260,
             372,
             33,
             35)
            bkimage = 'object/ui/common/btn_left.img'

            def OnClick(this):
                if ((itemType == 1) and (itemSubType == 1)):
                    itemShowCnt = 8
                else:
                    itemShowCnt = 12
                if (warePos[itemType][itemSubType] >= itemShowCnt):
                    warePos[itemType][itemSubType] -= itemShowCnt
                    ui_updateWares()
                    PlaySound(soundUI, 1)
                else:
                    PlaySound(soundFail, 1)
                ui_updateWarePages()



        class right(TButton):
            __module__ = __name__
            initlayer = 100000
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (380,
             372,
             33,
             35)
            bkimage = 'object/ui/common/btn_right.img'

            def OnClick(this):
                if ((itemType == 1) and (itemSubType == 1)):
                    itemShowCnt = 8
                else:
                    itemShowCnt = 12
                wareCnt = WareList().getCnt(itemType, itemSubType)
                if ((warePos[itemType][itemSubType] + itemShowCnt) < wareCnt):
                    warePos[itemType][itemSubType] += itemShowCnt
                    ui_updateWares()
                    PlaySound(soundUI, 1)
                else:
                    PlaySound(soundFail, 1)
                ui_updateWarePages()



        class buyDlg(TDlg):
            __module__ = __name__
            darkBG = 1
            initlayer = 999999
            visible = 0
            rect = (((800 - 327) / 2),
             ((600 - 378) / 2),
             327,
             378)
            bkimage = 'object/ui/shop/dlg_buy.img'

            def OnEscape():
                doUI('UI.shop.buyDlg.closeBtn', 'OnClick')


            class children:
                __module__ = __name__
                class name(TLabel,
                 Static):
                    __module__ = __name__
                    drawcolor = lightColor
                    textEdgeType = -1
                    rect = (35,
                     28,
                     250,
                     28)
                    textstyle = (dt_center + dt_vcenter)

                class txt(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (35,
                     65,
                     250,
                     115)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    rowspace = 2

                class price1(TLabel,
                 Static):
                    __module__ = __name__
                    initlayer = -99
                    rect = (100,
                     246,
                     150,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_right

                class checkRectQB(TStatic):
                    __module__ = __name__
                    rect = (20,
                     272,
                     250,
                     15)
                    initlayer = -100
                    class children:
                        __module__ = __name__
                        class checkBtn(TStdCheck):
                            __module__ = __name__
                            rect = (6,
                             0,
                             12,
                             15)
                            bkimagepos = (0,
                             5)

                            def OnClick(this):
                                global isAllowQBMixedPay
                                ui = 'UI.shop.buyDlg.checkRectQB'
                                if Win_IsChecked((ui + '.checkBtn')):
                                    isAllowQBMixedPay = 1
                                else:
                                    isAllowQBMixedPay = 0
                                PlaySound(soundUI, 1)



                        class text(TLabel):
                            __module__ = __name__
                            rect = (22,
                             2,
                             200,
                             15)
                            drawcolor = (0,
                             0,
                             255,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            textstyle = dt_right
                            caption = '\xc8\xf4Q\xb1\xd2\xb2\xbb\xd7\xe3\xca\xb1,\xd3\xc3Q\xb5\xe3\xd6\xa7\xb8\xb6\xb2\xbb\xd7\xe3\xb2\xbf\xb7\xd6\xb7\xd1\xd3\xc3'



                class price2(TLabel,
                 Static):
                    __module__ = __name__
                    initlayer = -99
                    rect = (100,
                     305,
                     150,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_right

                class price3(TLabel,
                 Static):
                    __module__ = __name__
                    initlayer = -99
                    rect = (100,
                     186,
                     150,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_right

                class checkRectQD(TStatic):
                    __module__ = __name__
                    rect = (20,
                     214,
                     250,
                     15)
                    initlayer = -100
                    class children:
                        __module__ = __name__
                        class checkBtn(TStdCheck):
                            __module__ = __name__
                            rect = (6,
                             0,
                             12,
                             15)
                            bkimagepos = (0,
                             5)

                            def OnClick(this):
                                global isAllowMixedPay
                                ui = 'UI.shop.buyDlg.checkRectQD'
                                if Win_IsChecked((ui + '.checkBtn')):
                                    isAllowMixedPay = 1
                                else:
                                    isAllowMixedPay = 0
                                PlaySound(soundUI, 1)



                        class text(TLabel):
                            __module__ = __name__
                            rect = (22,
                             2,
                             200,
                             15)
                            drawcolor = (0,
                             0,
                             255,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            textstyle = dt_right
                            caption = '\xc8\xf4Q\xb5\xe3\xb2\xbb\xd7\xe3\xca\xb1,\xd3\xc3Q\xb1\xd2\xd6\xa7\xb8\xb6\xb2\xbb\xd7\xe3\xb2\xbf\xb7\xd6\xb7\xd1\xd3\xc3'



                class preview(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (12,
                     251,
                     149,
                     270)
                    alphafactor = 1.0
                    minalphafactor = 0.0

                class buy1Btn(TButton):
                    __module__ = __name__
                    rect = (260,
                     234,
                     33,
                     34)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/btn_buy.img'

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyDlg', 0)
                        PlaySound(soundLeave, 1)
                        if ((curMoneyType == 'QB') and BuyCommodity(curBuyWareID, 2, 1, isAllowQBMixedPay)):
                            pass



                class buy2Btn(buy1Btn):
                    __module__ = __name__
                    rect = (260,
                     290,
                     33,
                     34)

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyDlg', 0)
                        PlaySound(soundLeave, 1)
                        BuyCommodity(curBuyWareID, 2, 6, 0)



                class buy3Btn(buy1Btn):
                    __module__ = __name__
                    rect = (260,
                     177,
                     33,
                     40)

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyDlg', 0)
                        PlaySound(soundLeave, 1)
                        BuyCommodity(curBuyWareID, 2, 7, isAllowMixedPay)



                class requireBtn(TButton):
                    __module__ = __name__
                    enable = 0
                    rect = (27,
                     328,
                     63,
                     31)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/btn_require.img'

                class donateBtn(TButton):
                    __module__ = __name__
                    enable = 1
                    rect = (100,
                     328,
                     63,
                     31)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/btn_donate.img'

                    def OnClick(this):
                        setDonateDlg()
                        ui_setCapture('UI.shop.donateDlg')



                class closeBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (190,
                     328,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_close.img'

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyDlg', 0)
                        PlaySound(soundLeave, 1)





        class buyFailDlg(TDlg):
            __module__ = __name__
            darkBG = 1
            initlayer = 999999
            visible = 0
            rect = (((800 - 368) / 2),
             ((600 - 326) / 2),
             368,
             326)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            class children:
                __module__ = __name__
                class close(TButton):
                    __module__ = __name__
                    rect = (93,
                     280,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_close.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyFailDlg', 0)



                class QB(TButton):
                    __module__ = __name__
                    rect = (200,
                     278,
                     87,
                     31)
                    bkimage = 'object/ui/shop/btn_addQB.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.buyFailDlg', 0)
                        ui_jumpWeb('http://pay.qq.com/')



                class text:
                    __module__ = __name__
                    type = 'LABEL'
                    rowspace = 2
                    rect = (45,
                     85,
                     270,
                     120)
                    bkimagepos = (0,
                     0)
                    textsize = 12
                    textstyle = (dt_left + dt_top)
                    textEdgeType = -1
                    drawcolor = zoneChooseColor



        class donateDlg(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 327) / 2),
             ((600 - 378) / 2),
             327,
             378)
            bkimage = 'object/ui/shop/dlg_donate.img'
            class children:
                __module__ = __name__
                class price(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (110,
                     82,
                     100,
                     12)
                    drawcolor = maskColor
                    textEdgeType = -1
                    textstyle = dt_left

                class receiveUin(TEditID):
                    __module__ = __name__
                    rect = (110,
                     106,
                     100,
                     12)
                    drawcolor = (255,
                     255,
                     255,
                     255)
                    textEdgeColor = (255,
                     1,
                     255,
                     0)

                    def OnTab():
                        Win_SetFocus('UI.shop.donateDlg.text')



                class checkRectQBPresent(TStatic):
                    __module__ = __name__
                    rect = (20,
                     128,
                     250,
                     15)
                    initlayer = -100
                    class children:
                        __module__ = __name__
                        class checkBtn(TStdCheck):
                            __module__ = __name__
                            rect = (6,
                             0,
                             12,
                             15)
                            bkimagepos = (0,
                             5)

                            def OnClick(this):
                                global isAllowPresentMixedPay
                                ui = 'UI.shop.donateDlg.checkRectQBPresent'
                                if Win_IsChecked((ui + '.checkBtn')):
                                    isAllowPresentMixedPay = 1
                                else:
                                    isAllowPresentMixedPay = 0
                                PlaySound(soundUI, 1)



                        class text(TLabel):
                            __module__ = __name__
                            rect = (20,
                             2,
                             200,
                             15)
                            drawcolor = (0,
                             0,
                             255,
                             255)
                            textEdgeColor = (255,
                             0,
                             0,
                             0)
                            textstyle = dt_left
                            caption = '\xc8\xf4Q\xb1\xd2\xb2\xbb\xd7\xe3,\xd3\xc3Q\xb5\xe3\xd6\xa7\xb8\xb6\xb2\xbb\xd7\xe3\xb2\xbf\xb7\xd6\xb7\xd1\xd3\xc3'



                class text:
                    __module__ = __name__
                    type = 'MULTIEDIT'
                    maxchar = 100
                    rect = (45,
                     190,
                     235,
                     80)
                    drawcolor = zoneChooseColor
                    bkcolor = (0,
                     0,
                     0,
                     0)
                    textEdgeColor = (255,
                     0,
                     0,
                     0)
                    textsize = 12
                    rowspace = 4
                    editable = 1
                    returnflag = 1
                    maxline = 5
                    richmode = 0
                    accel = (('OnAccel_FocusPaste',
                      86,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCut',
                      88,
                      17,
                      0,
                      0),
                     ('OnAccel_FocusCopy',
                      67,
                      17,
                      0,
                      0))

                    def OnAccel_FocusPaste():
                        Win_FocusOnPaste()



                    def OnAccel_FocusCut():
                        Win_FocusOnCut()



                    def OnAccel_FocusCopy():
                        Win_FocusOnCopy()



                class warePic(TStatic):
                    __module__ = __name__
                    bkImgFlag = dt_center
                    rect = (233,
                     72,
                     66,
                     66)

                class wareName(TLabel,
                 Static):
                    __module__ = __name__
                    rect = (216,
                     140,
                     100,
                     20)
                    drawcolor = (255,
                     255,
                     0,
                     255)
                    textstyle = dt_center

                class confirm(TButton):
                    __module__ = __name__
                    rect = (87,
                     329,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui = 'UI.shop.donateDlg'
                        recUin = Win_GetText((ui + '.receiveUin'))
                        text = Win_GetText((ui + '.text'))
                        Win_ShowWidget('UI.shop.donateDlg', 0)
                        Win_ShowWidget('UI.shop.buyDlg', 0)
                        PlaySound(soundLeave, 1)
                        if ((curMoneyType == 'QB') and PresentCommodity(int(recUin), curBuyWareID, len(text), text, 2, 1, isAllowPresentMixedPay)):
                            pass



                class cancel(TButton):
                    __module__ = __name__
                    rect = (188,
                     329,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.donateDlg', 0)
                        ui_setCapture('UI.shop.buyDlg')





        class charUpBtn(TButton):
            __module__ = __name__
            initlayer = -9999
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (440,
             35,
             33,
             35)
            bkimage = 'object/ui/common/btn_left.img'

            def OnClick(this):
                setNudeState()
                shopPlayer_changeRole(-1, 1)
                Win_SetImg('UI.shop.charIcon', getCharIconName())
                PlaySound(soundUI, 1)
                InitPlayerActiveItems()
                Win_SetFocus()



        class charDownBtn(charUpBtn):
            __module__ = __name__
            initlayer = -9999
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (595,
             35,
             33,
             35)
            bkimage = 'object/ui/common/btn_right.img'

            def OnClick(this):
                setNudeState()
                shopPlayer_changeRole(1, 1)
                Win_SetImg('UI.shop.charIcon', getCharIconName())
                PlaySound(soundUI, 1)
                InitPlayerActiveItems()
                Win_SetFocus()



        class charIcon(TStatic):
            __module__ = __name__
            initlayer = -99999
            rect = (476,
             37,
             66,
             27)

        class preview(TStatic):
            __module__ = __name__
            initlayer = -999
            rect = (351,
             92,
             275,
             95)
            class children:
                __module__ = __name__
                class bg(TStatic):
                    __module__ = __name__
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    bkImgFlag = dt_center
                    framespeed = 0.25
                    initlayer = -9999
                    rect = (94,
                     11,
                     96,
                     96)

                class bgCover(TStatic):
                    __module__ = __name__
                    initlayer = -999
                    rect = (0,
                     0,
                     275,
                     95)

                class enter(TStatic):
                    __module__ = __name__
                    bkImgFlag = (dt_center | eBkImgPlayOnce)
                    framespeed = 0.25
                    initlayer = 999
                    framespeed = 0.25
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    rect = (94,
                     11,
                     96,
                     96)

                class frame(TStatic):
                    __module__ = __name__
                    bkImgFlag = dt_center
                    initlayer = 999
                    framespeed = 0.25
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    rect = (94,
                     11,
                     96,
                     96)

                class demo(TStatic):
                    __module__ = __name__
                    initlayer = 9999
                    rect = ((563 - 508),
                     (123 - 138),
                     46,
                     62)
                    callbackdraw = 'SC_shopDemo_draw'



        class lighticon(TStatic):
            __module__ = __name__
            initlayer = -99999
            rect = (556,
             94,
             232,
             25)
            class children:
                __module__ = __name__
                class cap(TStatic):
                    __module__ = __name__
                    rect = (0,
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_cap.img'

                class fhadorn(cap):
                    __module__ = __name__
                    None

                class bhadorn(cap):
                    __module__ = __name__
                    None

                class thadorn(cap):
                    __module__ = __name__
                    None

                class hair(cap):
                    __module__ = __name__
                    None

                class mask(TStatic):
                    __module__ = __name__
                    rect = (23,
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_face.img'

                class eye(mask):
                    __module__ = __name__
                    None

                class mouth(mask):
                    __module__ = __name__
                    None

                class cladorn(TStatic):
                    __module__ = __name__
                    rect = ((23 * 2),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_cloth.img'

                class ear(cladorn):
                    __module__ = __name__
                    None

                class foot(cladorn):
                    __module__ = __name__
                    None

                class leg(cladorn):
                    __module__ = __name__
                    None

                class cloth(cladorn):
                    __module__ = __name__
                    None

                class npack(TStatic):
                    __module__ = __name__
                    rect = ((23 * 3),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_back.img'

                class fpack(npack):
                    __module__ = __name__
                    None

                class footprint(TStatic):
                    __module__ = __name__
                    rect = ((23 * 4),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_foot.img'

                class bomb(TStatic):
                    __module__ = __name__
                    rect = ((1 + (23 * 5)),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_bomb.img'

                class huanying(TStatic):
                    __module__ = __name__
                    rect = ((23 * 6),
                     2,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_huanying.img'

                class bg(TStatic):
                    __module__ = __name__
                    rect = ((23 * 7),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_bg.img'

                class frame(bg):
                    __module__ = __name__
                    None

                class enter(bg):
                    __module__ = __name__
                    None

                class namecard(TStatic):
                    __module__ = __name__
                    rect = ((23 * 8),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_namecard.img'

                class namecardbound(namecard):
                    __module__ = __name__
                    None

                class pet(TStatic):
                    __module__ = __name__
                    rect = ((23 * 9),
                     1,
                     1,
                     1)
                    bkimage = 'object/ui/shop/lightIcon/dlg_pet.img'



        class cancelEquip(TButton):
            __module__ = __name__
            initlayer = -99999
            rect = (720,
             143,
             63,
             31)
            bkimage = 'object/ui/shop/btn_cancelEquip.img'
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]

            def OnClick(this):
                setNudeState()
                clearSelected()
                PlaySound(soundUI, 1)



        class saveEquip(TButton):
            __module__ = __name__
            initlayer = -99999
            rect = (720,
             181,
             63,
             31)
            bkimage = 'object/ui/shop/btn_saveEquip.img'
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]

            def OnClick(this):
                global bClickSaveEquip
                sendActiveItems()
                clearSelected()
                bClickSaveEquip = 1
                PlaySound(soundLeave, 1)



        class namecardPreview(TStatic):
            __module__ = __name__
            initlayer = -9999
            rect = (468,
             217,
             310,
             25)
            class children:
                __module__ = __name__
                class namecard(TStatic):
                    __module__ = __name__
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    initlayer = -100
                    rect = (7,
                     1,
                     1,
                     1)

                class namecardbound(TStatic):
                    __module__ = __name__
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    rect = (7,
                     1,
                     1,
                     1)



        class myFunction(TTabWin):
            __module__ = __name__
            initlayer = -9999
            hotrect = (436,
             243,
             57,
             30)
            hotcover = 'object/ui/shop/tab_itemFunc.img'
            groupid = 1
            groupstop = 0

            def OnClick(this):
                doUI('UI.shop.functionTab', 'OnClick')
                setLRPosition()



        class myCostume(myFunction):
            __module__ = __name__
            hotrect = (495,
             243,
             57,
             30)
            hotcover = 'object/ui/shop/tab_itemAdorn.img'
            groupstop = 1

            def OnClick(this):
                doUI('UI.shop.costumeTab', 'OnClick')
                setLRPosition()



        class myEquip(myFunction):
            __module__ = __name__
            hotrect = (554,
             243,
             57,
             30)
            hotcover = 'object/ui/shop/tab_itemEquip.img'
            groupstop = 2

            def OnClick(this):
                doUI('UI.shop.equipTab', 'OnClick')
                setLRPosition()



        class mypet(myFunction):
            __module__ = __name__
            hotrect = (613,
             243,
             57,
             30)
            hotcover = 'object/ui/shop/tab_itemPet.img'
            groupstop = 3

            def OnClick(this):
                doUI('UI.shop.petTab', 'OnClick')
                setLRPosition()



        class myturplediamond(myFunction):
            __module__ = __name__
            hotrect = (672,
             243,
             57,
             30)
            hotcover = 'object/ui/shop/tab_itemZizuan.img'
            groupstop = 4

            def OnClick(this):
                doUI('UI.shop.purplediamondTab', 'OnClick')
                setLRPosition()



        class item1(TCheck):
            __module__ = __name__
            rect = (441,
             285,
             66,
             66)

            def OnClick(me):
                global myItemLastSelect
                ID = Win_GetText((me + '.ID'))
                myItemLastSelect = (itemPos[myItemType] + getTailNum(Win_GetMyPath()))
                useItem(ID)



            def OnRClick():
                global currentEggId
                me = Win_GetMyPath()
                itemID = int(Win_GetText((me + '.ID')))
                if ((itemID > 9000) and (itemID < 9011)):
                    currentEggId = itemID
                    if itemList.has_key(itemID):
                        iconType = itemList[itemID][0]
                        iconIdx = itemList[itemID][1]
                        Win_SetImg('UI.shop.breakEggDlg.eggPic', ('res/uires/icon/%s/%s%d.img' % (iconType,
                         iconType,
                         iconIdx)))
                        Win_SetText('UI.shop.breakEggDlg.description', itemList[itemID][3])
                    else:
                        currentEggId = 0
                        Win_SetImg('UI.shop.breakEggDlg.eggPic', '')
                        Win_SetText('UI.shop.breakEggDlg.description', '')
                    ui = 'UI.shop.breakEggDlg.hammer'
                    Win_EnableWidget((ui + '1'), 1)
                    Win_SetImg((ui + '1.hammerPic'), 'res/uiRes/icon/platform/platform9011.img')
                    Win_SetText((ui + '1.hammerCnt'), str(GetItemLeaveCount(9011)))
                    Win_EnableWidget((ui + '2'), 1)
                    Win_SetImg((ui + '2.hammerPic'), 'res/uiRes/icon/platform/platform9012.img')
                    Win_SetText((ui + '2.hammerCnt'), str(GetItemLeaveCount(9012)))
                    Win_EnableWidget((ui + '3'), 1)
                    Win_SetImg((ui + '3.hammerPic'), 'res/uiRes/icon/platform/platform9013.img')
                    Win_SetText((ui + '3.hammerCnt'), str(GetItemLeaveCount(9013)))
                    Win_SetImg('UI.shop.breakEggDlg.resultPic', '')
                    ui_setCapture('UI.shop.breakEggDlg')
                    PlaySound(soundUI, 1)
                    return 
                if itemList.has_key(itemID):
                    name = itemList[itemID][2]
                    statement = itemList[itemID][3]
                    idx = ((itemPos[myItemType] + getTailNum(Win_GetMyPath())) - 1)
                    info = ItemList().at(myItemType, idx)
                    leftTime = GetItemLeaveTime(itemID)
                    ui = 'UI.shop.repairDlg'
                    if ((leftTime >= 0) and Win_SetText((ui + '.time'), (str(leftTime) + '     \xcc\xec'))):
                        pass
                    price = GetRepairPrice(itemID)
                    Win_SetText((ui + '.price'), (str(price) + '   \xcc\xc7\xb1\xd2'))
                    Win_SetText((ui + '.title'), name)
                    Win_SetText((ui + '.text'), statement)
                    Win_SetText((ui + '.ID'), str(itemID))
                    ui_setCapture(ui)


            class children:
                __module__ = __name__
                class ID(TString):
                    __module__ = __name__
                    caption = '-1'

                class frame(TStatic):
                    __module__ = __name__
                    visible = 0
                    initlayer = -999
                    rect = (-3,
                     -3,
                     1,
                     1)
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    bkimage = 'object/ui/shop/img_wareFrame.img'

                class picture(TStatic):
                    __module__ = __name__
                    bkImgFlag = dt_center
                    rect = (32,
                     31,
                     1,
                     1)
                    bkimage = ''

                class hasEquiped(TStatic):
                    __module__ = __name__
                    initlayer = 11111
                    rect = (13,
                     40,
                     40,
                     17)
                    bkimage = ''

                class hasForged(TStatic):
                    __module__ = __name__
                    rect = (40,
                     3,
                     12,
                     12)

                class number(TLabel):
                    __module__ = __name__
                    initlayer = 11111
                    rect = (40,
                     3,
                     24,
                     12)
                    textEdgeType = 0
                    drawcolor = (135,
                     249,
                     255,
                     255)
                    textEdgeColor = maskColor



        class item2(item1):
            __module__ = __name__
            rect = ((442 + 69),
             285,
             66,
             66)

        class item3(item1):
            __module__ = __name__
            rect = ((442 + (69 * 2)),
             285,
             66,
             66)

        class item4(item1):
            __module__ = __name__
            rect = ((442 + (69 * 3)),
             285,
             66,
             66)

        class item5(item1):
            __module__ = __name__
            rect = ((442 + (69 * 4)),
             285,
             66,
             66)

        class item6(item1):
            __module__ = __name__
            rect = (441,
             354,
             66,
             66)

        class item7(item1):
            __module__ = __name__
            rect = ((442 + 69),
             354,
             66,
             66)

        class item8(item1):
            __module__ = __name__
            rect = ((442 + (69 * 2)),
             354,
             66,
             66)

        class item9(item1):
            __module__ = __name__
            rect = ((442 + (69 * 3)),
             354,
             66,
             66)

        class item10(item1):
            __module__ = __name__
            rect = ((442 + (69 * 4)),
             354,
             66,
             66)

        class item11(item1):
            __module__ = __name__
            rect = (441,
             423,
             66,
             66)

        class item12(item1):
            __module__ = __name__
            rect = ((442 + 69),
             423,
             66,
             66)

        class item13(item1):
            __module__ = __name__
            rect = ((442 + (69 * 2)),
             423,
             66,
             66)

        class item14(item1):
            __module__ = __name__
            rect = ((442 + (69 * 3)),
             423,
             66,
             66)

        class item15(item1):
            __module__ = __name__
            rect = ((442 + (69 * 4)),
             423,
             66,
             66)

        class myLeft(TButton):
            __module__ = __name__
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (717,
             490,
             33,
             35)
            bkimage = 'object/ui/common/btn_left.img'

            def OnClick(this):
                itemPos[myItemType] = max((itemPos[myItemType] - 15), 0)
                ui_updateMyItems()
                PlaySound(soundUI, 1)



        class myRight(TButton):
            __module__ = __name__
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            rect = (749,
             490,
             33,
             35)
            bkimage = 'object/ui/common/btn_right.img'

            def OnClick(this):
                if ((itemPos[myItemType] + 15) >= itemCnt):
                    return 
                itemPos[myItemType] = (itemPos[myItemType] + 15)
                ui_updateMyItems()
                PlaySound(soundUI, 1)



        class storageBtn(TButton):
            __module__ = __name__
            rect = (442,
             493,
             63,
             31)
            bkimage = 'object/ui/shop/btn_storage.img'
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]

            def OnClick(this):
                global step
                global IsShowStorageDlg
                global isStorageVisible
                IsShowStorageDlg = 0
                if ((0 == isStorageVisible) and Win_ShowWidget(uiRefineDlg, 0)):
                    isStorageVisible = 1
                    step = 30
                    Win_Timer(uiShopStorageDlg, 1)
                    ui_UpdateShopStorage()
                PlaySound(soundUI, 1)



        class storageDlg(TStatic):
            __module__ = __name__
            rect = (0,
             (0 - 598),
             427,
             598)
            initlayer = 999999
            bkimage = 'object/ui/storage/dlg_shopStorage.img'

            def OnTimer(this):
                Win_MovePos(uiShopStorageDlg, 0, step)
                if ((isStorageVisible and (Win_GetY(uiShopStorageDlg) >= 0)) and Win_Move2Pos(uiShopStorageDlg, 0, 0)):
                    Win_Timer(uiShopStorageDlg, 0)


            class children:
                __module__ = __name__
                class cleanUpBtn(TButton):
                    __module__ = __name__
                    rect = (10,
                     561,
                     63,
                     31)
                    bkimage = 'object/ui/storage/btn_cleanUp.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        RequestSettleStorage()
                        ui_UpdateShopStorage()



                class crossBtn(TButton):
                    __module__ = __name__
                    rect = (399,
                     5,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        doUI('UI.shop.storageBtn', 'OnClick')



                class storageLeft(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (246,
                     558,
                     33,
                     35)
                    bkimage = 'object/ui/common/btn_left.img'

                    def OnClick(this):
                        global shopStoragePos
                        shopStoragePos = max((shopStoragePos - defShopStorageCnt), 0)
                        UpdateShopStorage()
                        PlaySound(soundUI, 1)



                class storageRight(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (365,
                     558,
                     33,
                     35)
                    bkimage = 'object/ui/common/btn_right.img'

                    def OnClick(this):
                        global shopStoragePos
                        if ((shopStoragePos + defShopStorageCnt) >= totalStorageCnt):
                            return 
                        shopStoragePos = (shopStoragePos + defShopStorageCnt)
                        UpdateShopStorage()
                        PlaySound(soundUI, 1)



                class storagePage:
                    __module__ = __name__
                    type = 'NUMLABEL'
                    rect = (280,
                     560,
                     80,
                     24)
                    bkimage = 'object/ui/common/number2.img'
                    textstyle = dt_center
                    textsize = 16
                    textwidth = 19
                    textheight = 24

                class storageDescription:
                    __module__ = __name__
                    type = 'DYLABEL'
                    initlayer = 99999
                    rect = (0,
                     0,
                     130,
                     1)
                    captionrect = (4,
                     4,
                     120,
                     1)
                    bkimage = 'object/ui/common/img_tip.img'
                    textEdgeType = -1
                    drawcolor = maskColor

                class storageItem0(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0)]
                    rect = (14,
                     47,
                     55,
                     55)
                    bkImgFlag = dt_center
                    tipwidget = (uiShopStorageDlg + '.storageDescription')

                    def OnRClick():
                        global curStorageID
                        me = getMyIdx2()
                        info = g_StorageList.at((me + shopStoragePos)).m_stItem
                        if IsBook(info.m_nItemID):
                            curStorageID = info.m_nItemID
                            ui_msgBox(1)
                            Win_ShowMsgBox('   \xc4\xe3\xc8\xb7\xc8\xcf\xd2\xaa\xd1\xa7\xcf\xb0\xb8\xc3\xbe\xed\xd6\xe1\xc2\xf0?', '', 0, 'UI.SysMsgbox', -5)



                    def OnMouseMoveIn():
                        me = Win_GetMyPath()
                        idx = (getMyIdx2() + shopStoragePos)
                        if (idx >= totalStorageCnt):
                            return 
                        info = g_StorageList.at(idx)
                        ui = (uiShopStorageDlg + '.storageDescription')
                        Win_SetText(ui, ((info.m_szName + '\n') + info.m_szDescrip))
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))


                    class children:
                        __module__ = __name__
                        class itemNum(TLabel):
                            __module__ = __name__
                            rect = (30,
                             40,
                             24,
                             12)
                            drawcolor = zoneChooseColor
                            textEdgeType = 0
                            textEdgeColor = maskColor



                class storageItem1(storageItem0):
                    __module__ = __name__
                    rect = ((14 + 63),
                     47,
                     55,
                     55)

                class storageItem2(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     47,
                     55,
                     55)

                class storageItem3(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     47,
                     55,
                     55)

                class storageItem4(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     47,
                     55,
                     55)

                class storageItem5(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     47,
                     55,
                     55)

                class storageItem6(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem7(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem8(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem9(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem10(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem11(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 1)),
                     55,
                     55)

                class storageItem12(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem13(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem14(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem15(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem16(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem17(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 2)),
                     55,
                     55)

                class storageItem18(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem19(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem20(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem21(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem22(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem23(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 3)),
                     55,
                     55)

                class storageItem24(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem25(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem26(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem27(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem28(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem29(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 4)),
                     55,
                     55)

                class storageItem30(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem31(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem32(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem33(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem34(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem35(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 5)),
                     55,
                     55)

                class storageItem36(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem37(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem38(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem39(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem40(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem41(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 6)),
                     55,
                     55)

                class storageItem42(storageItem0):
                    __module__ = __name__
                    rect = (14,
                     (47 + (63 * 7)),
                     55,
                     55)

                class storageItem43(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 1)),
                     (47 + (63 * 7)),
                     55,
                     55)

                class storageItem44(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 2)),
                     (47 + (63 * 7)),
                     55,
                     55)

                class storageItem45(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 3)),
                     (47 + (63 * 7)),
                     55,
                     55)

                class storageItem46(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 4)),
                     (47 + (63 * 7)),
                     55,
                     55)

                class storageItem47(storageItem0):
                    __module__ = __name__
                    rect = ((14 + (63 * 5)),
                     (47 + (63 * 7)),
                     55,
                     55)



        class recyclerBtn(TButton):
            __module__ = __name__
            rect = (512,
             493,
             63,
             31)
            bkimage = 'object/ui/shop/btn_recycler.img'
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]

            def OnClick(this):
                ui_setCapture('UI.shop.recycler')
                ui_updateRecycler()



        class forgeBtn(TButton):
            __module__ = __name__
            rect = (582,
             493,
             63,
             31)
            bkimage = 'object/ui/shop/btn_forge.img'
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]

            def OnClick(this):
                if (Win_IsVisible(uiRefineDlg) and Win_ShowWidget(uiRefineDlg, 0)):
                    pass
                PlaySound(soundUI, 1)



        class repairDlg(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 262) / 2),
             ((600 - 308) / 2),
             262,
             308)
            bkimage = 'object/ui/shop/dlg_repair.img'
            class children:
                __module__ = __name__
                class ID(TLabel):
                    __module__ = __name__
                    visible = 0
                    rect = (0,
                     0,
                     0,
                     0)

                class title(TLabel):
                    __module__ = __name__
                    rect = (37,
                     48,
                     250,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_center

                class text(TLabel):
                    __module__ = __name__
                    rect = (37,
                     80,
                     250,
                     120)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1

                class time(TLabel):
                    __module__ = __name__
                    rect = (100,
                     225,
                     190,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_right

                class price(TLabel):
                    __module__ = __name__
                    rect = (100,
                     269,
                     190,
                     12)
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = dt_right

                class repairBtn(TButton):
                    __module__ = __name__
                    rect = (30,
                     309,
                     63,
                     31)
                    bkimage = 'object/ui/shop/btn_repair.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.repairDlg', False)
                        PlaySound(soundUI, 1)
                        RepairCommodity(int(Win_GetText('UI.shop.repairDlg.ID')), 2, 3)



                class deleteBtn(TButton):
                    __module__ = __name__
                    rect = (102,
                     309,
                     63,
                     31)
                    bkimage = 'object/ui/shop/btn_collect.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui = 'UI.shop.repairDlg'
                        itemID = Win_GetText((ui + '.ID'))
                        itemName = Win_GetText((ui + '.title'))
                        ui = 'UI.shop.deleteItemDlg'
                        Win_SetText((ui + '.itemID'), itemID)
                        Win_SetText((ui + '.text'), ('\xc8\xb7\xca\xb5\xd2\xaa\xb0\xd1"%s"\xb5\xc0\xbe\xdf\xb7\xc5\xc8\xeb\xca\xd5\xb2\xd8\xb9\xf1\xd6\xd0\xc2\xf0?' % itemName))
                        ui_setCapture(ui)
                        PlaySound(soundUI, 1)



                class removeBtn(TButton):
                    __module__ = __name__
                    visible = 0
                    rect = (11,
                     225,
                     69,
                     29)

                    def OnClick(this):
                        global removeItemID
                        ui = 'UI.shop.repairDlg'
                        itemID = Win_GetText((ui + '.ID'))
                        name = Win_GetText((ui + '.title'))
                        removeItemID = int(itemID)
                        Win_ShowWidget('UI.shop.repairDlg', False)
                        PlaySound(soundUI, 1)
                        ui_msgBox(0)
                        Win_ShowMsgBox(('\xc8\xb7\xc8\xcf\xd2\xaa\xc9\xbe\xb3\xfd\xb5\xc0\xbe\xdf"%s"\xc2\xf0?' % name), '\xc9\xbe\xb3\xfd\xb5\xc0\xbe\xdf', 0, 'UI.SysMsgbox', -4)



                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (236,
                     309,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_close.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.repairDlg', False)
                        PlaySound(soundLeave, 1)





        class deleteItemDlg(TDlg):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (((800 - 368) / 2),
             ((600 - 198) / 2),
             368,
             326)
            bkimage = 'object/ui/common/dlg_msgBox.img'
            class children:
                __module__ = __name__
                class itemID(TString):
                    __module__ = __name__
                    caption = '-1'

                class text(TLabel):
                    __module__ = __name__
                    rowspace = 2
                    rect = (40,
                     82,
                     280,
                     130)
                    textsize = 12
                    textstyle = (dt_left + dt_top)
                    textEdgeType = -1
                    drawcolor = zoneChooseColor

                class confirm(TButton):
                    __module__ = __name__
                    rect = (100,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_confirm.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui = 'UI.shop.deleteItemDlg'
                        itemID = int(Win_GetText((ui + '.itemID')))
                        deleteItem(itemID)
                        Win_ShowWidget(ui, 0)
                        Win_ShowWidget('UI.shop.repairDlg', 0)



                class cancel(TButton):
                    __module__ = __name__
                    rect = (225,
                     280,
                     65,
                     31)
                    bkimage = 'object/ui/common/btn_cancel.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui = 'UI.shop.deleteItemDlg'
                        Win_ShowWidget(ui, 0)
                        PlaySound(soundLeave, 1)





        class recycler(TDlg):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (((800 - 229) / 2),
             ((600 - 370) / 2),
             229,
             370)
            bkimage = 'object/ui/shop/img_recycler.img'
            class children:
                __module__ = __name__
                class item0(TRadio):
                    __module__ = __name__
                    rect = (30,
                     80,
                     142,
                     22)
                    groupstop = 0
                    framescheme = [(0,
                      0,
                      0,
                      0,
                      -1,
                      -1,
                      -1,
                      -1),
                     (0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      -1,
                      -1)]
                    bkimage = 'object/ui/selSect/btn_choose.img'

                    def OnClick(this):
                        global activeItemInRecycler
                        idx = getTailNum(this)
                        activeItemInRecycler = (disableItemPos + idx)


                    class children:
                        __module__ = __name__
                        class name:
                            __module__ = __name__
                            type = 'LABEL'
                            style = wgtstyle_static
                            rect = (0,
                             0,
                             142,
                             22)
                            drawcolor = zoneChooseColor
                            textEdgeType = -1
                            textstyle = (dt_center + dt_vcenter)



                class item1(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 1)),
                     142,
                     22)
                    groupstop = 1

                class item2(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 2)),
                     142,
                     22)
                    groupstop = 2

                class item3(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 3)),
                     142,
                     22)
                    groupstop = 3

                class item4(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 4)),
                     142,
                     22)
                    groupstop = 4

                class item5(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 5)),
                     142,
                     22)
                    groupstop = 5

                class item6(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 6)),
                     142,
                     22)
                    groupstop = 6

                class item7(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 7)),
                     142,
                     22)
                    groupstop = 7

                class item8(item0):
                    __module__ = __name__
                    rect = (30,
                     (80 + (23 * 8)),
                     142,
                     22)
                    groupstop = 8

                class scroll(TVScroll):
                    __module__ = __name__
                    rect = (178,
                     81,
                     26,
                     200)
                    pos = 0

                    def OnPosChange():
                        global disableItemPos
                        ui = 'UI.shop.recycler'
                        Win_SetRange((ui + '.scroll'), max((disableItemCnt - defRecyclerCnt), 0))
                        pos = Win_GetPos((ui + '.scroll'))
                        if ((pos != disableItemPos) and PlaySound(soundUI, 1)):
                            disableItemPos = pos
                            for i in range(defRecyclerCnt):
                                ui = ('UI.shop.recycler.item%d' % i)
                                idx = (disableItemPos + i)
                                if ((idx >= disableItemCnt) and Win_SetText((ui + '.name'), '')):
                                    Win_EnableWidget(ui, 0)
                                    continue
                                Win_SetCheck(ui, (idx == activeItemInRecycler))



                    class children:
                        __module__ = __name__
                        class blockbtn(TScrollBtn):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              0,
                              0,
                              1,
                              1,
                              0,
                              0)]
                            rect = (0,
                             0,
                             26,
                             42)
                            bkimage = 'object/ui/common/scl_block.img'



                class resumeBtn(TButton):
                    __module__ = __name__
                    rect = (83,
                     323,
                     69,
                     29)
                    bkimage = 'object/ui/shop/btn_resume.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        info = Recycler().at(activeItemInRecycler)
                        if ((info != None) and ChangeItemStatus(uin, info.ID, 0)):
                            pass



                class cross(TButton):
                    __module__ = __name__
                    rect = (200,
                     4,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        ui = 'UI.shop.recycler'
                        Win_ShowWidget(ui, 0)
                        PlaySound(soundLeave, 1)





        class joinMember(TButton):
            __module__ = __name__
            rect = (509,
             540,
             48,
             50)
            bkimage = 'object/ui/shop/btn_joinMember.img'

            def OnClick(this):
                Navigate(0)



        class leaveBtn(TButton):
            __module__ = __name__
            rect = (733,
             543,
             41,
             41)
            framescheme = [(0,
              0,
              2,
              2,
              3,
              3,
              1,
              1)]
            bkimage = 'object/ui/common/btn_return.img'

            def OnClick(this):
                setNudeState()
                LeaveShop()
                PlaySound(soundLeave, 1)



        class depositQB(TButton):
            __module__ = __name__
            rect = (447,
             540,
             48,
             50)
            bkimage = 'object/ui/shop/btn_depositQB.img'

            def OnClick(this):
                ui_jumpWeb('http://pay.qq.com/zft/paycenter_qb.shtml')



        class taskBtn(TButton):
            __module__ = __name__
            rect = (571,
             540,
             48,
             50)
            bkimage = 'object/ui/task/btn_task.img'
            framescheme = [(0,
              0,
              1,
              1,
              2,
              2,
              -1,
              -1)]

            def OnClick(this):
                if (Win_IsVisible(uiTaskDlg) and Win_ShowWidget(uiTaskDlg, 0)):
                    PlaySound(soundUI, 1)



        class taskDlg(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 300000
            rect = (401,
             12,
             400,
             500)
            bkimage = 'object/ui/task/dlg_task.img'
            class children:
                __module__ = __name__
                class crossBtn(TButton):
                    __module__ = __name__
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    rect = (354,
                     35,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'

                    def OnClick(this):
                        Win_ShowWidget(uiTaskDlg, 0)
                        PlaySound(soundUI, 1)



                class taskMark(TStatic):
                    __module__ = __name__
                    initlayer = 2
                    rect = (49,
                     40,
                     37,
                     32)
                    bkImgFlag = dt_center
                    bkimage = 'object/ui/task/bg_taskLevel1.img'

                class taskName(TLabel):
                    __module__ = __name__
                    initlayer = 2
                    rect = (100,
                     52,
                     180,
                     25)
                    drawcolor = (255,
                     255,
                     255,
                     255)
                    textstyle = dt_left
                    textsize = 12
                    caption = ''

                class npcPic(TStatic):
                    __module__ = __name__
                    initlayer = 2
                    bkImgFlag = dt_center
                    rect = (38,
                     75,
                     97,
                     129)
                    bkimage = 'res/uiRes/icon/npcIcon/npcIcon1.img'

                class taskIntroduction(TLabel):
                    __module__ = __name__
                    textstyle = (dt_left + dt_top)
                    initlayer = 2
                    rect = (146,
                     90,
                     215,
                     85)
                    drawcolor = (102,
                     71,
                     39,
                     230)
                    textEdgeType = -1
                    caption = ''

                class deadLine(TLabel):
                    __module__ = __name__
                    textstyle = dt_left
                    initlayer = 2
                    drawcolor = (102,
                     71,
                     39,
                     255)
                    textEdgeType = -1
                    rect = (220,
                     215,
                     180,
                     25)
                    caption = ''

                class progressDes(TLabel):
                    __module__ = __name__
                    textstyle = (dt_left + dt_top)
                    initlayer = 2
                    drawcolor = (102,
                     71,
                     39,
                     255)
                    textEdgeType = -1
                    rect = (70,
                     235,
                     275,
                     50)
                    caption = ''

                class awardPic(TStatic):
                    __module__ = __name__
                    initlayer = 2
                    rect = (73,
                     295,
                     75,
                     75)
                    bkImgFlag = dt_center
                    bkimage = 'res/uiRes/icon/bomb/bomb5.img'

                class awardDes(TLabel):
                    __module__ = __name__
                    textstyle = (dt_left + dt_top)
                    initlayer = 2
                    drawcolor = (229,
                     217,
                     184,
                     255)
                    textEdgeType = -1
                    rect = (160,
                     330,
                     190,
                     40)
                    caption = ''

                class taskBtn0(TCheck):
                    __module__ = __name__
                    initlayer = 2
                    groupstop = 1
                    bkimage = ''
                    rect = (68,
                     387,
                     138,
                     33)
                    class children:
                        __module__ = __name__
                        class taskNameBtn(TButton):
                            __module__ = __name__
                            initlayer = 2
                            rect = (0,
                             0,
                             107,
                             25)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/task/btn_taskName.img'
                            drawcolor = (102,
                             71,
                             39,
                             230)
                            textEdgeType = -1
                            textstyle = dt_center
                            caption = '\xce\xde\xc8\xce\xce\xf1'

                            def OnClick(this):
                                global currentTaskIdx
                                idx = getMyMidIdx()
                                if (idx != currentTaskIdx):
                                    currentTaskIdx = idx
                                    UpdateCurTaskPanel()



                        class taskCtrBtn(TButton):
                            __module__ = __name__
                            initlayer = 2
                            rect = (108,
                             1,
                             30,
                             30)
                            bkimage = 'object/ui/task/btn_startTask.img'

                            def OnClick(this):
                                global currentTaskIdx
                                idx = getMyMidIdx()
                                print idx,
                                print currentTaskIdx
                                if (idx != currentTaskIdx):
                                    currentTaskIdx = idx
                                    UpdateCurTaskPanel()
                                RequestDoTask(tasksIdList[currentTaskIdx])





                class taskBtn1(taskBtn0):
                    __module__ = __name__
                    rect = ((68 + 145),
                     387,
                     138,
                     33)
                    groupstop = 2

                class taskBtn2(taskBtn0):
                    __module__ = __name__
                    rect = (68,
                     (387 + 35),
                     138,
                     33)
                    groupstop = 3

                class taskBtn3(taskBtn0):
                    __module__ = __name__
                    rect = ((68 + 145),
                     (387 + 35),
                     138,
                     33)
                    groupstop = 4

                class taskBtn4(taskBtn0):
                    __module__ = __name__
                    rect = (68,
                     (387 + (35 * 2)),
                     138,
                     33)
                    groupstop = 5

                class taskBtn5(taskBtn0):
                    __module__ = __name__
                    rect = ((68 + 145),
                     (387 + (35 * 2)),
                     138,
                     33)
                    groupstop = 6



        class fruitMachine(TDlg):
            __module__ = __name__
            initlayer = 200000
            rect = (15,
             (114 + (73 * 4)),
             398,
             170)
            bkimage = 'object/ui/shop/luckyStar/img_luckyStar.img'
            bkimagepos = (-15,
             -52)
            tipwidget = 'UI.shop.fruitMachine.tip'
            class children:
                __module__ = __name__
                class frame(TStatic):
                    __module__ = __name__
                    initlayer = -1000
                    visible = 0
                    rect = (81,
                     56,
                     80,
                     80)
                    bkimage = 'object/ui/shop/luckyStar/frame.img'

                class item1(TStatic):
                    __module__ = __name__
                    rect = (13,
                     63,
                     64,
                     64)
                    bkimage = ''
                    bkImgFlag = dt_center

                class item2(item1):
                    __module__ = __name__
                    rect = (88,
                     63,
                     64,
                     64)
                    bkimage = ''

                class item3(item1):
                    __module__ = __name__
                    rect = (163,
                     63,
                     64,
                     64)
                    bkimage = ''

                class startBtn(TButton):
                    __module__ = __name__
                    initlayer = 300000
                    rect = (309,
                     108,
                     75,
                     65)
                    bkimage = 'object/ui/shop/luckyStar/btn_startLuck.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    tipwidget = 'UI.shop.fruitMachine.tip'

                    def OnClick(this):
                        buyFruitMachine()



                class stopBtn(TButton):
                    __module__ = __name__
                    initlayer = 300000
                    visible = 0
                    rect = (309,
                     108,
                     75,
                     65)
                    bkimage = 'object/ui/shop/luckyStar/btn_stopLuck.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    tipwidget = 'UI.shop.fruitMachine.tip'

                    def OnClick(this):
                        stopFruitMachine()



                class tip(TTip):
                    __module__ = __name__
                    visible = 0
                    initlayer = 200000
                    rect = (-15,
                     182,
                     1,
                     1)
                    bkimage = 'object/ui/shop/luckyStar/tip.img'
                    bkImgFlag = 5

                class lightback(TStatic):
                    __module__ = __name__
                    rect = (7,
                     19,
                     210,
                     125)
                    bkimage = 'object/ui/shop/luckyStar/img_lightback.img'

                class light(TStatic):
                    __module__ = __name__
                    initlayer = 10000
                    framescheme = [(0,
                      6,
                      0,
                      6,
                      0,
                      6,
                      0,
                      6)]
                    visible = 0
                    rect = (7,
                     19,
                     210,
                     125)
                    bkimage = 'object/ui/shop/luckyStar/img_light.img'



        class AD(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 200000
            rect = (6,
             (71 + (73 * 4)),
             398,
             144)
            bkimage = 'object/ui/shop/advert.img'

        class fruitResult(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (((800 - 363) / 2),
             ((600 - 418) / 2),
             363,
             338)
            bkimage = 'object/ui/shop/dlg_luckResult.img'
            class children:
                __module__ = __name__
                class text(TLabel):
                    __module__ = __name__
                    rect = (54,
                     113,
                     255,
                     100)
                    editable = 0
                    drawcolor = zoneChooseColor
                    textEdgeType = -1
                    textstyle = (dt_center + dt_vcenter)

                class closeBtn(TButton):
                    __module__ = __name__
                    rect = (((363 - 43) / 2),
                     295,
                     43,
                     31)
                    bkimage = 'object/ui/common/btn_close.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget('UI.shop.fruitResult', 0)
                        resetFruitMachine()
                        PlaySound(soundLeave, 1)





        class fruitTip(TTip):
            __module__ = __name__
            rect = (55,
             315,
             1,
             1)
            bkimage = 'object/ui/shop/luckyStar/tip_luckyStar.img'

            def OnTimer(this):
                ui = this
                Win_Timer(ui, 0)
                Win_SetValue(ui, 0.050000000000000003, 41)
                Win_SetValue(ui, 2, 901)



        class refineDlg(TStatic):
            __module__ = __name__
            visible = 0
            initlayer = 999999
            rect = (2,
             2,
             427,
             587)
            class children:
                __module__ = __name__
                class crossBtn(TButton):
                    __module__ = __name__
                    initlayer = 21000
                    rect = (400,
                     5,
                     22,
                     22)
                    bkimage = 'object/ui/common/btn_cross.img'
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]

                    def OnClick(this):
                        Win_ShowWidget(uiRefineDlg, 0)
                        PlaySound(soundLeave, 1)



                class forgeTab(TTabWin):
                    __module__ = __name__
                    initlayer = 21000
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (119,
                     2,
                     93,
                     27)
                    hotcover = 'object/ui/forge/tab_forge.img'
                    groupstop = 0

                    def OnClick(this):
                        Win_ShowWidget(uiAvatarForgeDlg, 1)
                        Win_ShowWidget(uiComposeDlg, 0)
                        PlaySound(soundUI, 1)



                class composeTab(TTabWin):
                    __module__ = __name__
                    initlayer = 21000
                    rect = (0,
                     0,
                     1,
                     1)
                    hotrect = (20,
                     2,
                     93,
                     27)
                    hotcover = 'object/ui/forge/tab_compose.img'
                    groupstop = 1

                    def OnClick(this):
                        Win_ShowWidget(uiAvatarForgeDlg, 0)
                        Win_ShowWidget(uiComposeDlg, 1)
                        PlaySound(soundUI, 1)



                class AvatarForgeDlg(TStatic):
                    __module__ = __name__
                    visible = 1
                    rect = (0,
                     0,
                     427,
                     587)
                    bkimage = 'object/ui/forge/dlg_avatarforge.img'
                    class children:
                        __module__ = __name__
                        class materialDescription:
                            __module__ = __name__
                            type = 'DYLABEL'
                            initlayer = 2000000
                            rect = (0,
                             0,
                             130,
                             1)
                            captionrect = (4,
                             4,
                             120,
                             1)
                            bkimage = 'object/ui/common/img_tip.img'
                            textEdgeType = -1
                            drawcolor = maskColor

                        class materialItem0(TButton):
                            __module__ = __name__
                            rect = (18,
                             47,
                             56,
                             56)
                            dragtype = 7
                            bkImgFlag = dt_center
                            tipwidget = (uiAvatarForgeDlg + '.materialDescription')

                            def OnBeginItemDrag():
                                info = g_AvatarForgeMaterial.at((g_AvatarMaterialPage[0] + getMyIdx2()))
                                g_ForgeDragInfo[0] = 2
                                g_ForgeDragInfo[1] = info.m_stItem.m_nItemID
                                g_ForgeDragInfo[2] = ('res/uires/icon/item/item%d.img' % info.m_stItem.m_nItemID)
                                path = Win_GetMyPath()
                                Win_SetDragImg(path, g_ForgeDragInfo[2])



                            def OnMouseMoveIn():
                                me = Win_GetMyPath()
                                itemIdx = (getMyIdx2() + g_AvatarMaterialPage[0])
                                if (itemIdx >= g_AvatarForgeMaterial.getMaterialCnt()):
                                    return 
                                info = g_AvatarForgeMaterial.at(itemIdx)
                                ui = (uiAvatarForgeDlg + '.materialDescription')
                                Win_SetText(ui, ((info.m_szName + '\n') + info.m_szDescrip))
                                winrect = Win_GetRect(me, value_channel_winrect)
                                caprect = Win_GetRect(ui, value_channel_captionrect)
                                Win_Move2Pos(ui, (winrect[0] + 50), (winrect[1] + caprect[3]))



                            def OnDBClick():
                                idx = getMyIdx2()
                                itemIdx = (idx + g_AvatarMaterialPage[0])
                                info = g_AvatarForgeMaterial.at(itemIdx)
                                g_ForgeInfo[0] = info.m_stItem.m_nItemID
                                Win_SetImg((uiAvatarForgeDlg + '.sourceMaterial'), ('res/uires/icon/item/item%d.img' % g_ForgeInfo[0]))


                            class children:
                                __module__ = __name__
                                class itemNum(TLabel):
                                    __module__ = __name__
                                    rect = (30,
                                     40,
                                     24,
                                     12)
                                    drawcolor = zoneChooseColor
                                    textEdgeType = 0
                                    textEdgeColor = maskColor



                        class materialItem1(materialItem0):
                            __module__ = __name__
                            rect = ((18 + 61),
                             47,
                             56,
                             56)

                        class materialItem2(materialItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 2)),
                             47,
                             56,
                             56)

                        class materialItem3(materialItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 3)),
                             47,
                             56,
                             56)

                        class materialItem4(materialItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 4)),
                             47,
                             56,
                             56)

                        class materialPage:
                            __module__ = __name__
                            type = 'NUMLABEL'
                            rect = (320,
                             51,
                             62,
                             18)
                            bkimage = 'object/ui/common/number4.img'
                            textstyle = dt_center
                            textsize = 16
                            textwidth = 16
                            textheight = 18

                        class materialLeft(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (320,
                             70,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_left.img'

                            def OnClick(this):
                                g_AvatarMaterialPage[0] = max((g_AvatarMaterialPage[0] - g_AvatarMaterialPage[1]), 0)
                                ui_showMaterial()
                                PlaySound(soundUI, 1)



                        class materialRight(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (354,
                             70,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_right.img'

                            def OnClick(this):
                                if ((g_AvatarMaterialPage[0] + g_AvatarMaterialPage[1]) >= g_AvatarForgeMaterial.getMaterialCnt()):
                                    return 
                                g_AvatarMaterialPage[0] = (g_AvatarMaterialPage[0] + g_AvatarMaterialPage[1])
                                ui_showMaterial()
                                PlaySound(soundUI, 1)



                        class forgeType0(TTabWin):
                            __module__ = __name__
                            rect = (0,
                             0,
                             1,
                             1)
                            hotrect = (15,
                             115,
                             57,
                             30)
                            hotcover = 'object/ui/forge/tab_forgetype0.img'
                            groupstop = 0

                            def OnClick(this):
                                global g_AvatarForgeCurrentType
                                g_AvatarForgeCurrentType = getMyIdx2()
                                ui_showAvatar()
                                PlaySound(soundUI, 1)



                        class forgeType1(forgeType0):
                            __module__ = __name__
                            hotrect = ((15 + 61),
                             115,
                             57,
                             30)
                            hotcover = 'object/ui/forge/tab_forgetype1.img'
                            groupstop = 1

                        class forgeType2(forgeType0):
                            __module__ = __name__
                            hotrect = ((15 + (61 * 2)),
                             115,
                             57,
                             30)
                            hotcover = 'object/ui/forge/tab_forgetype2.img'
                            groupstop = 2

                        class forgeType3(forgeType0):
                            __module__ = __name__
                            hotrect = ((15 + (61 * 3)),
                             115,
                             57,
                             30)
                            hotcover = 'object/ui/forge/tab_forgetype3.img'
                            groupstop = 3

                        class forgeItem0(TButton):
                            __module__ = __name__
                            dragtype = 7
                            rect = (18,
                             150,
                             56,
                             56)
                            bkImgFlag = dt_center

                            def OnClick(this):
                                idx = (getMyIdx2() + g_AvatarForgePage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(0, g_AvatarForgeCurrentType, idx).m_nItemID
                                useItem(itemID)



                            def OnRClick():
                                idx = (getMyIdx2() + g_AvatarForgePage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(0, g_AvatarForgeCurrentType, idx).m_nItemID
                                if itemList.has_key(itemID):
                                    name = itemList[itemID][2]
                                    statement = itemList[itemID][3]
                                    leftTime = GetItemLeaveTime(itemID)
                                    ui = 'UI.shop.repairDlg'
                                    if ((leftTime >= 0) and Win_SetText((ui + '.time'), (str(leftTime) + '     \xcc\xec'))):
                                        pass
                                    price = GetRepairPrice(itemID)
                                    Win_SetText((ui + '.price'), (str(price) + '   \xcc\xc7\xb1\xd2'))
                                    Win_SetText((ui + '.title'), name)
                                    Win_SetText((ui + '.text'), statement)
                                    Win_SetText((ui + '.ID'), str(itemID))
                                    ui_setCapture(ui)



                            def OnDBClick():
                                idx = (getMyIdx2() + g_AvatarForgePage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(0, g_AvatarForgeCurrentType, idx).m_nItemID
                                if itemList.has_key(itemID):
                                    iconType = itemList[itemID][0]
                                    iconIdx = itemList[itemID][1]
                                    picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                                     iconType,
                                     iconIdx))
                                else:
                                    picName = 'res/uires/shop/salou.img'
                                g_ForgeInfo[1] = itemID
                                Win_SetImg((uiAvatarForgeDlg + '.sourceAvatar'), picName)
                                g_ForgeInfo[3] = -1
                                AvatarForge_wear(0, 0, 0)



                            def OnBeginItemDrag():
                                g_ForgeDragInfo[0] = 0
                                g_ForgeDragInfo[1] = g_AvatarForge.at(0, g_AvatarForgeCurrentType, (g_AvatarForgePage[0][g_AvatarForgeCurrentType] + getMyIdx2())).m_nItemID
                                if itemList.has_key(g_ForgeDragInfo[1]):
                                    iconType = itemList[g_ForgeDragInfo[1]][0]
                                    iconIdx = itemList[g_ForgeDragInfo[1]][1]
                                    picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                                     iconType,
                                     iconIdx))
                                else:
                                    picName = 'res/uires/shop/salou.img'
                                g_ForgeDragInfo[2] = picName
                                path = Win_GetMyPath()
                                Win_SetDragImg(path, picName)



                        class forgeItem1(forgeItem0):
                            __module__ = __name__
                            rect = ((18 + 61),
                             150,
                             56,
                             56)

                        class forgeItem2(forgeItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 2)),
                             150,
                             56,
                             56)

                        class forgeItem3(forgeItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 3)),
                             150,
                             56,
                             56)

                        class forgeItem4(forgeItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 4)),
                             150,
                             56,
                             56)

                        class forgePage:
                            __module__ = __name__
                            type = 'NUMLABEL'
                            rect = (320,
                             154,
                             62,
                             18)
                            bkimage = 'object/ui/common/number4.img'
                            textstyle = dt_center
                            textsize = 16
                            textwidth = 16
                            textheight = 18

                        class forgeLeft(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (320,
                             175,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_left.img'

                            def OnClick(this):
                                g_AvatarForgePage[0][g_AvatarForgeCurrentType] = max((g_AvatarForgePage[0][g_AvatarForgeCurrentType] - g_AvatarForgePage[1]), 0)
                                ui_showAvatar()
                                PlaySound(soundUI, 1)



                        class forgeRight(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (354,
                             175,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_right.img'

                            def OnClick(this):
                                if ((g_AvatarForgePage[0][g_AvatarForgeCurrentType] + g_AvatarForgePage[1]) >= g_AvatarForge.getItemCnt(0, g_AvatarForgeCurrentType)):
                                    return 
                                g_AvatarForgePage[0][g_AvatarForgeCurrentType] = (g_AvatarForgePage[0][g_AvatarForgeCurrentType] + g_AvatarForgePage[1])
                                ui_showAvatar()
                                PlaySound(soundUI, 1)



                        class revertItem0(TButton):
                            __module__ = __name__
                            dragtype = 7
                            rect = (18,
                             220,
                             56,
                             56)
                            bkImgFlag = dt_center

                            def OnClick(this):
                                idx = (getMyIdx2() + g_AvatarRevertPage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(1, g_AvatarForgeCurrentType, idx).m_nItemID
                                useItem(itemID)



                            def OnRClick():
                                idx = (getMyIdx2() + g_AvatarRevertPage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(1, g_AvatarForgeCurrentType, idx).m_nItemID
                                if itemList.has_key(itemID):
                                    name = itemList[itemID][2]
                                    statement = itemList[itemID][3]
                                    leftTime = GetItemLeaveTime(itemID)
                                    ui = 'UI.shop.repairDlg'
                                    if ((leftTime >= 0) and Win_SetText((ui + '.time'), (str(leftTime) + '     \xcc\xec'))):
                                        pass
                                    price = GetRepairPrice(itemID)
                                    Win_SetText((ui + '.price'), (str(price) + '   \xcc\xc7\xb1\xd2'))
                                    Win_SetText((ui + '.title'), name)
                                    Win_SetText((ui + '.text'), statement)
                                    Win_SetText((ui + '.ID'), str(itemID))
                                    ui_setCapture(ui)



                            def OnDBClick():
                                idx = (getMyIdx2() + g_AvatarRevertPage[0][g_AvatarForgeCurrentType])
                                itemID = g_AvatarForge.at(1, g_AvatarForgeCurrentType, idx).m_nItemID
                                if itemList.has_key(itemID):
                                    iconType = itemList[itemID][0]
                                    iconIdx = itemList[itemID][1]
                                    picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                                     iconType,
                                     iconIdx))
                                else:
                                    picName = 'res/uires/shop/salou.img'
                                g_ForgeInfo[1] = itemID
                                Win_SetImg((uiAvatarForgeDlg + '.sourceAvatar'), picName)
                                g_ForgeInfo[3] = -1
                                AvatarForge_wear(0, 0, 0)



                            def OnBeginItemDrag():
                                g_ForgeDragInfo[0] = 0
                                g_ForgeDragInfo[1] = g_AvatarForge.at(1, g_AvatarForgeCurrentType, (g_AvatarRevertPage[0][g_AvatarForgeCurrentType] + getMyIdx2())).m_nItemID
                                if itemList.has_key(g_ForgeDragInfo[1]):
                                    iconType = itemList[g_ForgeDragInfo[1]][0]
                                    iconIdx = itemList[g_ForgeDragInfo[1]][1]
                                    picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                                     iconType,
                                     iconIdx))
                                else:
                                    picName = 'res/uires/shop/salou.img'
                                g_ForgeDragInfo[2] = picName
                                path = Win_GetMyPath()
                                Win_SetDragImg(path, picName)



                        class revertItem1(revertItem0):
                            __module__ = __name__
                            rect = ((18 + 61),
                             220,
                             56,
                             56)

                        class revertItem2(revertItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 2)),
                             220,
                             56,
                             56)

                        class revertItem3(revertItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 3)),
                             220,
                             56,
                             56)

                        class revertItem4(revertItem0):
                            __module__ = __name__
                            rect = ((18 + (61 * 4)),
                             220,
                             56,
                             56)

                        class revertPage:
                            __module__ = __name__
                            type = 'NUMLABEL'
                            rect = (320,
                             224,
                             62,
                             18)
                            bkimage = 'object/ui/common/number4.img'
                            textstyle = dt_center
                            textsize = 16
                            textwidth = 16
                            textheight = 18

                        class revertLeft(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (320,
                             244,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_left.img'

                            def OnClick(this):
                                g_AvatarRevertPage[0][g_AvatarForgeCurrentType] = max((g_AvatarRevertPage[0][g_AvatarForgeCurrentType] - g_AvatarRevertPage[1]), 0)
                                ui_showAvatar()
                                PlaySound(soundUI, 1)



                        class revertRight(TButton):
                            __module__ = __name__
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            rect = (354,
                             244,
                             33,
                             35)
                            bkimage = 'object/ui/common/btn_right.img'

                            def OnClick(this):
                                if ((g_AvatarRevertPage[0][g_AvatarForgeCurrentType] + g_AvatarRevertPage[1]) >= g_AvatarForge.getItemCnt(1, g_AvatarForgeCurrentType)):
                                    return 
                                g_AvatarRevertPage[0][g_AvatarForgeCurrentType] = (g_AvatarRevertPage[0][g_AvatarForgeCurrentType] + g_AvatarRevertPage[1])
                                ui_showAvatar()
                                PlaySound(soundUI, 1)



                        class sourceMaterial(TButton):
                            __module__ = __name__
                            dragtype = 7
                            rect = [208,
                             303,
                             62,
                             62]
                            bkImgFlag = dt_center

                            def OnDragItemDrop():
                                if ((g_ForgeDragInfo[0] == 2) and (g_ForgeDragInfo[1] >= 0)):
                                    g_ForgeInfo[0] = g_ForgeDragInfo[1]
                                    path = Win_GetMyPath()
                                    Win_SetImg(path, g_ForgeDragInfo[2])



                        class sourceAvatar(TButton):
                            __module__ = __name__
                            dragtype = 7
                            rect = [208,
                             371,
                             62,
                             62]
                            bkImgFlag = dt_center

                            def OnDragItemDrop():
                                if (((g_ForgeDragInfo[0] == 0) or (g_ForgeDragInfo[0] == 1)) and (g_ForgeDragInfo[1] >= 0)):
                                    g_ForgeInfo[1] = g_ForgeDragInfo[1]
                                    path = Win_GetMyPath()
                                    Win_SetImg(path, g_ForgeDragInfo[2])
                                    AvatarForge_wear(0, 0, 0)



                        class destAvatar(TButton):
                            __module__ = __name__
                            rect = [50,
                             311,
                             100,
                             100]
                            callbackdraw = 'SC_AvatarForge_draw'

                            def OnClick(this):
                                if ((g_ForgeInfo[3] > 0) and useItem(g_ForgeInfo[3])):
                                    pass



                            def OnDBClick():
                                itemID = g_ForgeInfo[3]
                                if ((itemID > 0) and itemList.has_key(itemID)):
                                    iconType = itemList[itemID][0]
                                    iconIdx = itemList[itemID][1]
                                    picName = ('res/uires/icon/%s/%s%d.img' % (iconType,
                                     iconType,
                                     iconIdx))
                                g_ForgeInfo[1] = itemID
                                if Win_SetImg((uiAvatarForgeDlg + '.sourceAvatar'), picName):
                                    pass
                                g_ForgeInfo[3] = -1
                                AvatarForge_wear(0, 0, 0)



                        class forgeBtn(TButton):
                            __module__ = __name__
                            rect = [288,
                             300,
                             103,
                             47]
                            bkimage = 'object/ui/forge/btn_avatarforge.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                errorTip = ''
                                if ((g_ForgeInfo[1] <= 0) and (g_ForgeInfo[0] <= 0)):
                                    errorTip = '\xc7\xeb\xd1\xa1\xd4\xf1\xd2\xaa\xb6\xcd\xd4\xec\xb5\xc4\xd7\xb0\xb1\xb8\xba\xcd\xb6\xcd\xd4\xec\xcb\xf9\xd0\xe8\xd2\xaa\xb5\xc4\xb2\xc4\xc1\xcf!'
                                elif (g_ForgeInfo[1] <= 0):
                                    errorTip = '\xc7\xeb\xd1\xa1\xd4\xf1\xd2\xaa\xb6\xcd\xd4\xec\xb5\xc4\xd7\xb0\xb1\xb8!'
                                elif (g_ForgeInfo[0] <= 0):
                                    errorTip = '\xc7\xeb\xd1\xa1\xd4\xf1\xb6\xcd\xd4\xec\xcb\xf9\xd0\xe8\xd2\xaa\xb5\xc4\xb2\xc4\xc1\xcf!'
                                else:
                                    itemInfo = GetItemInfoFromSec(g_ForgeInfo[1])
                                    if ((itemInfo.m_bItemEffect > 0) and (itemInfo.m_bItemColor > 0)):
                                        errorTip = '\xb8\xc3\xd7\xb0\xb1\xb8\xd2\xd1\xb1\xbb\xb6\xcd\xd4\xec,\xc7\xeb\xcf\xc8\xbb\xb9\xd4\xad\xbb\xf2\xb2\xf0\xb7\xd6\xba\xf3\xd4\xd9\xbd\xf8\xd0\xd0\xb6\xcd\xd4\xec!'
                                if ((errorTip != '') and Win_SetColorText((uiAvatarForgeDlg + '.forgeInfo'), errorTip, value_channel_itemtext, 255, 0, 0)):
                                    return 
                                g_ForgeInfo[2] = g_Operator[0]
                                if itemList.has_key(g_ForgeInfo[1]):
                                    itemName = itemList[g_ForgeInfo[1]][2]
                                else:
                                    itemName = '\xb8\xc3\xb5\xc0\xbe\xdf'
                                materialInfo = GetItemInfoInStorage(g_ForgeInfo[0])
                                materialName = materialInfo.m_szName
                                if (len(materialName) == 0):
                                    materialName = '\xb8\xc3\xb2\xc4\xc1\xcf'
                                Win_SetText((uiForgeConfirmDlg + '.forgeText'), ('\xc8\xb7\xc8\xcf\xca\xb9\xd3\xc3 "%s" \xb6\xcd\xd4\xec "%s" \xa3\xa1' % (materialName,
                                 itemName)))
                                ui_setCapture(uiForgeConfirmDlg)
                                PlaySound(soundUI, 1)



                        class splitBtn(TButton):
                            __module__ = __name__
                            rect = [288,
                             347,
                             103,
                             47]
                            bkimage = 'object/ui/forge/btn_avatarsplit.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                errorTip = ''
                                if (g_ForgeInfo[1] <= 0):
                                    errorTip = '\xc7\xeb\xd1\xa1\xd4\xf1\xd2\xaa\xb2\xf0\xb7\xd6\xb5\xc4\xd7\xb0\xb1\xb8!'
                                else:
                                    itemInfo = GetItemInfoFromSec(g_ForgeInfo[1])
                                    if (itemInfo.m_bItemEffect <= 0):
                                        errorTip = '\xb8\xc3\xd7\xb0\xb1\xb8\xce\xb4\xb1\xbb\xb6\xcd\xd4\xec,\xcb\xf9\xd2\xd4\xb2\xbb\xc4\xdc\xb2\xf0\xb7\xd6!'
                                    elif (itemInfo.m_bItemColor == 0):
                                        errorTip = '\xb8\xc3\xd7\xb0\xb1\xb8\xd2\xd1\xb1\xbb\xb2\xf0\xb7\xd6!'
                                if ((errorTip != '') and Win_SetColorText((uiAvatarForgeDlg + '.forgeInfo'), errorTip, value_channel_itemtext, 255, 0, 0)):
                                    return 
                                g_ForgeInfo[2] = g_Operator[2]
                                if itemList.has_key(g_ForgeInfo[1]):
                                    itemName = itemList[g_ForgeInfo[1]][2]
                                else:
                                    itemName = '\xb8\xc3\xb5\xc0\xbe\xdf'
                                splitInfo = GetSplitInfo()
                                Win_SetText((uiForgeConfirmDlg + '.forgeText'), ('\xb2\xf0\xb7\xd6 "%s" \xbd\xab\xbb\xa8\xb7\xd1\xc4\xfa %d %s\xa3\xac\xc7\xeb\xb5\xe3\xbb\xf7\xc8\xb7\xc8\xcf\xa3\xa1' % (itemName,
                                 splitInfo[1],
                                 splitInfo[2])))
                                ui_setCapture(uiForgeConfirmDlg)
                                PlaySound(soundUI, 1)



                        class revertBtn(TButton):
                            __module__ = __name__
                            rect = [288,
                             394,
                             103,
                             47]
                            bkimage = 'object/ui/forge/btn_avatarrevert.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                errorTip = ''
                                if (g_ForgeInfo[1] <= 0):
                                    errorTip = '\xc7\xeb\xd1\xa1\xd4\xf1\xd2\xaa\xbb\xb9\xd4\xad\xb5\xc4\xd7\xb0\xb1\xb8!'
                                else:
                                    itemInfo = GetItemInfoFromSec(g_ForgeInfo[1])
                                    if (itemInfo.m_bItemEffect <= 0):
                                        errorTip = '\xb8\xc3\xd7\xb0\xb1\xb8\xce\xb4\xb1\xbb\xb6\xcd\xd4\xec,\xcb\xf9\xd2\xd4\xb2\xbb\xc4\xdc\xbb\xb9\xd4\xad!'
                                if ((errorTip != '') and Win_SetColorText((uiAvatarForgeDlg + '.forgeInfo'), errorTip, value_channel_itemtext, 255, 0, 0)):
                                    return 
                                g_ForgeInfo[2] = g_Operator[1]
                                if itemList.has_key(g_ForgeInfo[1]):
                                    itemName = itemList[g_ForgeInfo[1]][2]
                                else:
                                    itemName = '\xb8\xc3\xb5\xc0\xbe\xdf'
                                revertInfo = GetRevertInfo()
                                Win_SetText((uiForgeConfirmDlg + '.forgeText'), ('\xbb\xb9\xd4\xad "%s" \xbd\xab\xbb\xa8\xb7\xd1\xc4\xfa %d %s\xa3\xac\xc7\xeb\xb5\xe3\xbb\xf7\xc8\xb7\xc8\xcf\xa3\xa1' % (itemName,
                                 revertInfo[1],
                                 revertInfo[2])))
                                ui_setCapture(uiForgeConfirmDlg)
                                PlaySound(soundUI, 1)



                        class forgeInfo:
                            __module__ = __name__
                            type = 'TEXTLIST'
                            rect = (20,
                             469,
                             380,
                             90)
                            rowspace = 6
                            textfont = 1
                            textEdgeType = -1
                            scrollspace = 18
                            maxline = 30
                            class children:
                                __module__ = __name__
                                class chatScroll(TVScroll):
                                    __module__ = __name__
                                    extendstyle = 0
                                    rect = (364,
                                     13,
                                     26,
                                     55)
                                    class children:
                                        __module__ = __name__
                                        class blockbtn(TScrollBtn):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              1,
                                              1,
                                              0,
                                              0)]
                                            rect = (1,
                                             0,
                                             26,
                                             42)
                                            bkimage = 'object/ui/common/scl_block.img'

                                        class spinup(TSpinInc):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              2,
                                              2,
                                              3,
                                              3,
                                              1,
                                              1)]
                                            rect = (5,
                                             -17,
                                             18,
                                             18)
                                            bkimage = 'object/ui/forge/scl_up.img'

                                            def OnClick(this):
                                                PlaySound(soundUI, 1)



                                        class spindown(TSpinDec):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              2,
                                              2,
                                              3,
                                              3,
                                              1,
                                              1)]
                                            rect = (5,
                                             55,
                                             18,
                                             18)
                                            bkimage = 'object/ui/forge/scl_down.img'

                                            def OnClick(this):
                                                PlaySound(soundUI, 1)









                class forgeConfirmDlg(TDlg):
                    __module__ = __name__
                    visible = 0
                    initlayer = 200000
                    rect = (100,
                     200,
                     225,
                     122)
                    bkimage = 'object/ui/forge/dlg_forgeconfirm.img'
                    class children:
                        __module__ = __name__
                        class forgeText(TLabel,
                         Static):
                            __module__ = __name__
                            rect = (10,
                             10,
                             180,
                             28)
                            textEdgeType = -1
                            drawcolor = (135,
                             113,
                             87,
                             255)

                        class confirmBtn(TButton):
                            __module__ = __name__
                            rect = (70,
                             55,
                             93,
                             50)
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]
                            bkimage = 'object/ui/forge/btn_forgeconfirm.img'

                            def OnClick(this):
                                if ((g_ForgeInfo[2] == g_Operator[0]) and RequestAvatarForge(g_ForgeInfo[1], g_ForgeInfo[0], g_ForgeInfo[2])):
                                    pass
                                Win_ShowWidget(uiForgeConfirmDlg, 0)
                                PlaySound(soundLeave, 1)



                        class crossBtn(TButton):
                            __module__ = __name__
                            rect = (198,
                             6,
                             22,
                             22)
                            bkimage = 'object/ui/common/btn_cross.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                Win_ShowWidget(uiForgeConfirmDlg, 0)
                                PlaySound(soundLeave, 1)





                class composeDlg(TStatic):
                    __module__ = __name__
                    visible = 0
                    rect = (0,
                     0,
                     427,
                     587)
                    bkimage = 'object/ui/forge/dlg_forge.img'
                    class children:
                        __module__ = __name__
                        class itemList0(TButton):
                            __module__ = __name__
                            rect = (20,
                             70,
                             132,
                             19)
                            bkimage = 'object/ui/forge/btn_type.img'
                            textEdgeColor = (80,
                             80,
                             80,
                             255)
                            teststyle = dt_left

                            def OnClick(this):
                                global composeItemCnt
                                global composeExpand
                                global composeItemID
                                pos = Win_GetPos((uiComposeDlg + '.itemScroll'))
                                idx = (getMyIdx2() + pos)
                                if (idx < composeExpand):
                                    composeExpand = idx
                                    g_ComposeItemList.update()
                                    doUI((uiComposeDlg + '.itemScroll'), 'OnPosChange')
                                elif (idx == composeExpand):
                                    composeExpand = -1
                                    composeItemCnt = 0
                                    doUI((uiComposeDlg + '.itemScroll'), 'OnPosChange')
                                elif ((composeExpand >= 0) and (idx <= (composeExpand + composeItemCnt))):
                                    composeItemID = g_ComposeItemList.at(((idx - composeExpand) - 1)).iPropID
                                    g_ComposeMeterialList.update()
                                    Win_SetImg((uiComposeDlg + '.curItemIcon'), ('res/uires/icon/item/item%d.img' % composeItemID))
                                    Win_SetText((uiComposeDlg + '.curItemName'), g_ComposeItemList.at(((idx - composeExpand) - 1)).szPropName)
                                    Win_SetText((uiComposeDlg + '.curItemInfo'), g_ComposeItemList.at(((idx - composeExpand) - 1)).szPropDescription)
                                    for i in range(defComposeMeterCnt):
                                        materialInfo = g_ComposeMeterialList.at(i)
                                        Win_SetImg((uiComposeDlg + ('.meterialList.meterialIcon%d' % i)), ('res/uires/icon/item/item%d.img' % materialInfo.iMaterialID))
                                        Win_SetText((uiComposeDlg + ('.meterialList.meterialInfo%d' % i)), (materialInfo.szMaterialName + ('\n\n%d/%d' % (materialInfo.unHadMatNum,
                                         materialInfo.unNeedMatlNum))))

                                elif (idx < (composeTypeCnt + composeItemCnt)):
                                    composeExpand = (idx - composeItemCnt)
                                    g_ComposeItemList.update()
                                    doUI((uiComposeDlg + '.itemScroll'), 'OnPosChange')



                        class itemList1(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 1)),
                             132,
                             19)

                        class itemList2(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 2)),
                             132,
                             19)

                        class itemList3(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 3)),
                             132,
                             19)

                        class itemList4(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 4)),
                             132,
                             19)

                        class itemList5(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 5)),
                             132,
                             19)

                        class itemList6(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 6)),
                             132,
                             19)

                        class itemList7(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 7)),
                             132,
                             19)

                        class itemList8(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 8)),
                             132,
                             19)

                        class itemList9(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 9)),
                             132,
                             19)

                        class itemList10(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 10)),
                             132,
                             19)

                        class itemList11(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 11)),
                             132,
                             19)

                        class itemList12(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 12)),
                             132,
                             19)

                        class itemList13(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 13)),
                             132,
                             19)

                        class itemList14(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 14)),
                             132,
                             19)

                        class itemList15(itemList0):
                            __module__ = __name__
                            rect = (20,
                             (70 + (20 * 15)),
                             132,
                             19)

                        class itemScroll(TVScroll):
                            __module__ = __name__
                            rect = (155,
                             82,
                             26,
                             300)
                            pos = 0

                            def OnPosChange():
                                pos = Win_GetPos((uiComposeDlg + '.itemScroll'))
                                sclRange = composeTypeCnt
                                if (composeExpand >= 0):
                                    sclRange += composeItemCnt
                                Win_SetRange((uiComposeDlg + '.itemScroll'), max((sclRange - defComposeCnt), 0))
                                for i in range(defComposeCnt):
                                    idx = (pos + i)
                                    Win_SetDrawColor((uiComposeDlg + ('.itemList%d' % i)), 255, 255, 255, 255)
                                    if ((idx <= composeExpand) and Win_SetImg((uiComposeDlg + ('.itemList%d' % i)), 'object/ui/forge/btn_type.img')):
                                        Win_SetText((uiComposeDlg + ('.itemList%d' % i)), g_ComposeTypeList.at(idx))



                            class children:
                                __module__ = __name__
                                class blockbtn(TScrollBtn):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      0,
                                      0,
                                      1,
                                      1,
                                      0,
                                      0)]
                                    rect = (0,
                                     0,
                                     26,
                                     42)
                                    bkimage = 'object/ui/common/scl_block.img'

                                class spinup(TSpinDec):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (5,
                                     -17,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_up.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)



                                class spindown(TSpinInc):
                                    __module__ = __name__
                                    framescheme = [(0,
                                      0,
                                      2,
                                      2,
                                      3,
                                      3,
                                      1,
                                      1)]
                                    rect = (5,
                                     301,
                                     18,
                                     18)
                                    bkimage = 'object/ui/forge/scl_down.img'

                                    def OnClick(this):
                                        PlaySound(soundUI, 1)





                        class curItemIcon(TStatic):
                            __module__ = __name__
                            rect = (188,
                             84,
                             66,
                             66)
                            bkImgFlag = dt_center

                        class curItemName(TLabel):
                            __module__ = __name__
                            rect = (270,
                             67,
                             120,
                             12)
                            textEdgeType = -1

                        class curItemInfo(TLabel):
                            __module__ = __name__
                            rect = (270,
                             87,
                             120,
                             60)
                            textEdgeType = -1

                        class meterialList(TStatic):
                            __module__ = __name__
                            rect = (189,
                             200,
                             200,
                             212)
                            bkimage = 'object/ui/forge/dlg_meterial.img'
                            class children:
                                __module__ = __name__
                                class meterialIcon0(TStatic):
                                    __module__ = __name__
                                    rect = (0,
                                     -5,
                                     66,
                                     66)
                                    bkImgFlag = dt_center

                                class meterialIcon1(meterialIcon0):
                                    __module__ = __name__
                                    rect = (0,
                                     60,
                                     66,
                                     66)

                                class meterialIcon2(meterialIcon0):
                                    __module__ = __name__
                                    rect = (0,
                                     129,
                                     66,
                                     66)

                                class meterialInfo0(TLabel):
                                    __module__ = __name__
                                    rect = (80,
                                     20,
                                     100,
                                     40)
                                    drawcolor = (255,
                                     255,
                                     255,
                                     255)
                                    textEdgeType = -1
                                    caption = 'abc\n\n123'

                                class meterialInfo1(meterialInfo0):
                                    __module__ = __name__
                                    rect = (80,
                                     90,
                                     100,
                                     40)

                                class meterialInfo2(meterialInfo0):
                                    __module__ = __name__
                                    rect = (80,
                                     160,
                                     100,
                                     40)



                        class composeInfo:
                            __module__ = __name__
                            type = 'TEXTLIST'
                            rect = (20,
                             430,
                             380,
                             90)
                            drawcolor = zoneChooseColor
                            rowspace = 6
                            textfont = 1
                            textEdgeType = -1
                            scrollspace = 18
                            maxline = 30
                            class children:
                                __module__ = __name__
                                class chatScroll(TVScroll):
                                    __module__ = __name__
                                    extendstyle = 0
                                    rect = (366,
                                     13,
                                     26,
                                     55)
                                    class children:
                                        __module__ = __name__
                                        class blockbtn(TScrollBtn):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              0,
                                              0,
                                              1,
                                              1,
                                              0,
                                              0)]
                                            rect = (0,
                                             0,
                                             26,
                                             42)
                                            bkimage = 'object/ui/common/scl_block.img'

                                        class spinup(TSpinInc):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              2,
                                              2,
                                              3,
                                              3,
                                              1,
                                              1)]
                                            rect = (5,
                                             -17,
                                             18,
                                             18)
                                            bkimage = 'object/ui/forge/scl_up.img'

                                            def OnClick(this):
                                                PlaySound(soundUI, 1)



                                        class spindown(TSpinDec):
                                            __module__ = __name__
                                            framescheme = [(0,
                                              0,
                                              2,
                                              2,
                                              3,
                                              3,
                                              1,
                                              1)]
                                            rect = (5,
                                             55,
                                             18,
                                             18)
                                            bkimage = 'object/ui/forge/scl_down.img'

                                            def OnClick(this):
                                                PlaySound(soundUI, 1)







                        class composeBtn(TButton):
                            __module__ = __name__
                            rect = (152,
                             523,
                             102,
                             50)
                            bkimage = 'object/ui/forge/btn_startCompose.img'
                            framescheme = [(0,
                              0,
                              2,
                              2,
                              3,
                              3,
                              1,
                              1)]

                            def OnClick(this):
                                if ((composeItemID <= 0) and Win_SetText((uiComposeDlg + '.forgeInfo'), '\xc7\xeb\xcf\xc8\xd1\xa1\xd4\xf1\xd0\xe8\xd2\xaa\xba\xcf\xb3\xc9\xb5\xc4\xce\xef\xc6\xb7', value_channel_itemtext)):
                                    return 







        class breakEggDlg(TDlg):
            __module__ = __name__
            initlayer = 999999
            visible = 0
            rect = (((800 - 262) / 2),
             ((600 - 408) / 2),
             262,
             308)
            bkimage = 'object/ui/shop/breakEgg/dlg_breakEgg.img'
            darkBG = 1
            class children:
                __module__ = __name__
                class description(TLabel):
                    __module__ = __name__
                    rect = (24,
                     90,
                     302,
                     60)
                    drawcolor = (255,
                     255,
                     0,
                     255)
                    textEdgeType = 0
                    textstyle = (dt_left + dt_top)
                    textsize = 12
                    caption = ''

                class eggPic(TStatic):
                    __module__ = __name__
                    rect = (151,
                     135,
                     83,
                     79)

                class resultPic(TStatic):
                    __module__ = __name__
                    rect = (10,
                     60,
                     200,
                     150)
                    bkimage = ''

                class hammer1(TButton):
                    __module__ = __name__
                    visible = 1
                    rect = (17,
                     230,
                     83,
                     79)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/breakEgg/btn_hammerFrame1.img'
                    tipwidget = 'UI.shop.description'

                    def OnMouseMoveIn():
                        ui = 'UI.shop.description'
                        idx = getMyIdx2()
                        hammerId = 0
                        if (idx == 1):
                            hammerId = 9011
                        elif (idx == 2):
                            hammerId = 9012
                        elif (idx == 3):
                            hammerId = 9013
                        Win_ShowWidget(ui, 1)
                        Win_SetText(ui, itemList[hammerId][3])
                        me = Win_GetMyPath()
                        winrect = Win_GetRect(me, value_channel_winrect)
                        caprect = Win_GetRect(ui, value_channel_captionrect)
                        Win_Move2Pos(ui, (winrect[0] + 70), ((winrect[1] + caprect[3]) - 10))



                    def OnClick(this):
                        idx = getMyIdx2()
                        hammerId = 0
                        if (idx == 1):
                            hammerId = 9011
                        elif (idx == 2):
                            hammerId = 9012
                        elif (idx == 3):
                            hammerId = 9013
                        cnt = GetItemLeaveCount(hammerId)
                        if ((cnt > 0) and RequestBreakEgg(currentEggId, hammerId)):
                            ui = 'UI.shop.breakEggDlg.hammer'
                            Win_EnableWidget((ui + '1'), 0)
                            Win_EnableWidget((ui + '2'), 0)
                            Win_EnableWidget((ui + '3'), 0)


                    class children:
                        __module__ = __name__
                        class hammerPic(TStatic):
                            __module__ = __name__
                            rect = (10,
                             10,
                             83,
                             79)
                            bkimage = ''

                        class hammerCnt(TLabel):
                            __module__ = __name__
                            rect = (50,
                             0,
                             30,
                             16)
                            drawcolor = (255,
                             255,
                             255,
                             255)
                            textstyle = dt_center
                            textsize = 12
                            caption = ''



                class hammer2(hammer1):
                    __module__ = __name__
                    rect = ((17 + 89),
                     230,
                     83,
                     79)
                    bkimage = 'object/ui/shop/breakEgg/btn_hammerFrame2.img'

                class hammer3(hammer1):
                    __module__ = __name__
                    rect = ((17 + (89 * 2)),
                     230,
                     83,
                     79)
                    bkimage = 'object/ui/shop/breakEgg/btn_hammerFrame3.img'

                class title(TStatic):
                    __module__ = __name__
                    rect = (32,
                     10,
                     200,
                     100)
                    framescheme = [(0,
                      99,
                      0,
                      99,
                      0,
                      99,
                      0,
                      99)]
                    bkimage = 'object/ui/shop/breakEgg/title.img'

                class closeBtn(TButton):
                    __module__ = __name__
                    visible = 1
                    rect = (287,
                     255,
                     48,
                     33)
                    framescheme = [(0,
                      0,
                      2,
                      2,
                      3,
                      3,
                      1,
                      1)]
                    bkimage = 'object/ui/shop/breakEgg/btn_close.img'

                    def OnClick(this):
                        currentEggId = 0
                        Win_ShowWidget('UI.shop.breakEggDlg', 0)
                        PlaySound(soundUI, 1)







UI.children.shop = UI_children_shop

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiTemplate.py`:

```py
class Static:
    __module__ = __name__
    style = wgtstyle_static

class TWidget:
    __module__ = __name__
    type = 'WIDGET'

class TStatic:
    __module__ = __name__
    type = 'WIDGET'
    style = wgtstyle_static

class TCheck:
    __module__ = __name__
    type = 'CHECK'

class TStdCheck:
    __module__ = __name__
    type = 'CHECK'
    framescheme = [(-1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1),
     (0,
      0,
      0,
      0,
      0,
      0,
      0,
      0)]
    rect = (0,
     0,
     40,
     16)
    bkimage = 'object/ui/common/btn_check.img'

class TDlg:
    __module__ = __name__
    type = 'DIALOG'

class TEdit:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_normal
    drawcolor = (0,
     0,
     0,
     255)
    bkcolor = (255,
     255,
     255,
     0)
    focuscolor = (0,
     0,
     0,
     0)

class TStaticEdit(TEdit):
    __module__ = __name__
    style = wgtstyle_static

class TEditBox:
    __module__ = __name__
    type = 'EDIT'
    editable = 0
    textstyle = (dt_left + dt_center)
    drawcolor = (0,
     0,
     0,
     255)

class TEditPoint:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_number
    editable = 0
    bkcolor = (255,
     255,
     255,
     0)
    drawcolor = (0,
     0,
     0,
     255)
    step = 1
    textstyle = 5
    minvalue = 0
    maxvalue = ui_initmaxpoint

class TEditNum:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_number
    editable = 0
    bkcolor = (255,
     255,
     255,
     0)
    drawcolor = (0,
     0,
     0,
     255)
    step = 1
    textstyle = 5

class TEditCharNum:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_charNumber
    editable = 0
    bkcolor = (255,
     255,
     255,
     0)
    drawcolor = (0,
     0,
     0,
     255)
    step = 1
    textstyle = 5

class TEditPassword:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_coder
    drawcolor = (255,
     255,
     255,
     255)
    focuscolor = (0,
     0,
     0,
     255)
    maxchar = 16
    textsize = 12

class TEditID:
    __module__ = __name__
    type = 'EDIT'
    editmethod = edit_number
    drawcolor = (255,
     255,
     255,
     255)
    focuscolor = (0,
     0,
     0,
     255)
    maxchar = 10
    textsize = 12

class TKeyEdit:
    __module__ = __name__
    type = 'KEYEDIT'

class TLabel:
    __module__ = __name__
    type = 'LABEL'
    textsize = 12
    textstyle = (dt_left + dt_top)
    drawcolor = (0,
     0,
     0,
     255)

class TPicLabel:
    __module__ = __name__
    type = 'PICLABEL'
    textsize = 0

class TRadio:
    __module__ = __name__
    type = 'CHECK'
    groupid = 8
    extendstyle = ui_btn_style_radio

class TRichEdit:
    __module__ = __name__
    type = 'RICHEDIT'
    maxchar = 800
    drawcolor = (0,
     0,
     0,
     255)
    textsize = 12
    textfont = 1
    editmethod = edit_talk

class TSpinUp:
    __module__ = __name__
    type = 'SPIN'
    style = wgtstyle_primary

class TSpinDown:
    __module__ = __name__
    type = 'SPIN'

class TSpinInc:
    __module__ = __name__
    type = 'SPIN'
    style = wgtstyle_primary

class TSpinDec:
    __module__ = __name__
    type = 'SPIN'

class TSpinUpScroll(TSpinUp):
    __module__ = __name__
    rect = (0,
     0,
     16,
     16)
    textstyle = 1
    aligntype = (aligntype_father + aligntype_winrect)
    alignstyle = (alignstyle_top_out + alignstyle_hcenter)
    marginh = 0
    marginv = 0

class TSpinDownScroll(TSpinDown):
    __module__ = __name__
    rect = (0,
     0,
     16,
     16)
    aligntype = (aligntype_father + aligntype_winrect)
    alignstyle = (alignstyle_bottom_out + alignstyle_hcenter)
    marginh = 0
    marginv = 0

class TString:
    __module__ = __name__
    type = 'LABEL'
    visible = 0

class TPoser:
    __module__ = __name__
    type = 'POSER'
    style = wgtstyle_static
    rect = (0,
     0,
     800,
     600)

class TButton:
    __module__ = __name__
    type = 'BUTTON'

class THyperLink:
    __module__ = __name__
    type = 'HYPERLINK'

class TVScroll:
    __module__ = __name__
    type = 'SCROLLBAR'
    style = wgtstyle_vertical
    extendstyle = 2

class TScrollBtn:
    __module__ = __name__
    type = 'BUTTON'
    moveable = 1

class TTabWin:
    __module__ = __name__
    rect = (0,
     0,
     0,
     0)
    type = 'TABWIN'
    groupid = 0

class TStaticCheck:
    __module__ = __name__
    type = 'CHECK'
    style = wgtstyle_static


#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/PythonCode/uiWeb.py`:

```py
class UI_children_web:
    __module__ = __name__
    type = 'SCREEN'
    rect = (0,
     0,
     800,
     600)
    bkimage = 'object/ui/web/bg_web.img'
    accel = ()

    def OnInit():
        Win_ShowWidget(uiGuideBar, 0)
        Win_ShowWidget(uiSocialityDlg, 0)
        sc_HideWeb('kinMatch')
        sc_HideWeb('kinTeam')
        Win_ShowWidget(uiMenuDlg, 0)
        return 



    def OnDenit():
        print 'OnDenit() web'
        sc_web_close()
        print 'sc_closeWeb()'



    def OnEnter():
        return 



    def OnEscape():
        return 


    class children:
        __module__ = __name__
        class bg(TStatic):
            __module__ = __name__
            initlayer = -9999

        class leaveBtn(TButton):
            __module__ = __name__
            rect = (705,
             (573 - 569),
             58,
             19)
            bkimage = 'object/ui/web/btn_leave.img'

            def OnClick(this):
                PlaySound(soundLeave, 1)
                GotoUIScreen(screenEnterWeb)



        class backwardBtn(TButton):
            __module__ = __name__
            rect = (13,
             (571 - 567),
             58,
             19)
            bkimage = 'object/ui/web/btn_backward.img'

            def OnClick(this):
                PlaySound(soundUI, 1)
                sc_web_goBack()
                print 'sc_web_goBack()'



        class forwardBtn(TButton):
            __module__ = __name__
            rect = (89,
             (571 - 567),
             58,
             19)
            bkimage = 'object/ui/web/btn_forward.img'

            def OnClick(this):
                PlaySound(soundUI, 1)
                sc_web_goForward()
                print 'sc_web_goForward()'





UI.children.web = UI_children_web

#+++ okay decompyling
# decompiled 1 files: 1 okay, 0 failed, 0 verify failed

```

`QQTang CheatEngine/QQTEncoder.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/

#pragma once
#pragma pack(1)
#include "Maple.hpp"
#define PQQTEncoder CQQTEncoder*

namespace QQTangCheatEngine
{
	class CQQTEncoderBase
	{
		public:
		virtual void FunA ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void FunB ( INT32 a ) = 0;
		virtual void FunC ( INT32 a ) = 0;
		virtual DWORD FunD ( INT32 a, INT32 b ) = 0;
		virtual INT32 EnCoder (
			_In_ LPVOID pQQTEncoder,
			_In_ GameID gameid,
			_Out_ LPVOID pEnPackage,
			_Out_ LPDWORD pEncodeSize,
			_In_ LPVOID pDePackage,
			_In_ BOOL IsEncode ) = 0;

		virtual INT32 ToNetValue (
			_In_ LPVOID pQQTEncoder,
			_In_ GameID gameid,
			_Out_ LPVOID pEnPackage,
			_Out_ PDWORD pEncodeSize,
			_In_ LPVOID pDePackage,
			_In_ BOOL IsEncode ) = 0;

		virtual DWORD FunE ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
	};

	class CQQTEncoder :public CQQTEncoderBase
	{
		public:
		void FunA ( INT32 a, INT32 b, INT32 c ) { }
		void FunB ( INT32 a ) { }
		void FunC ( INT32 a ) { }
		DWORD FunD ( INT32 a, INT32 b ) { }
		INT32 EnCoder (
			_In_ LPVOID pQQTEncoder,
			_In_ GameID gameid,
			_Out_ LPVOID pEnPackage,
			_Out_ LPDWORD pEncodeSize,
			_In_ LPVOID pDePackage,
			_In_ BOOL IsEncode )
		{
		}

		INT32 ToNetValue (
			_In_ LPVOID pQQTEncoder,
			_In_ GameID gameid,
			_Out_ LPVOID pEnPackage,
			_Out_ PDWORD pEncodeSize,
			_In_ LPVOID pDePackage,
			_In_ BOOL IsEncode )
		{
		}


		DWORD FunE ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) { }

	};

}
```

`QQTang CheatEngine/QQTSection.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#define PQQTSection CQQTSection*


namespace QQTangCheatEngine
{
	class CQQTSectionBase
	{
		virtual void Fun_00 ( INT32 a ) = 0;
		virtual void SendDataToServer ( _In_ INT32 PackageSize, _In_ LPVOID pPackage ) = 0;
		virtual void Fun_02 ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void Fun_03 ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
		virtual void Fun_04 ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void Fun_05 ( INT32 a ) = 0;
		virtual void Fun_06 ( INT32 a ) = 0;
		virtual void Fun_07 ( INT32 a ) = 0;
		virtual void Fun_08 ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
		virtual void Fun_09 ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void Fun_10 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_11 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_12 ( INT32 a ) = 0;
		virtual void Fun_13 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_14 ( INT32 a ) = 0;
		virtual void Fun_15 ( INT32 a ) = 0;
		virtual void Fun_16 ( INT32 a ) = 0;
		virtual void Fun_17 ( ) = 0;
		virtual void Fun_18 ( ) = 0;
		virtual void Fun_19 ( INT32 a ) = 0;
		virtual void Fun_20 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_21 ( INT32 a ) = 0;
		virtual void Fun_22 ( ) = 0;
		virtual void Fun_23 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_24 ( INT32 a, INT32 b ) = 0;
		virtual void Fun_25 ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void Fun_26 ( ) = 0;
   

	};

	class CQQTSection :public CQQTSectionBase
	{
		public:
		void Fun_00 ( INT32 a ) {}
		void SendDataToServer ( _In_ INT32 PackageSize, _In_ LPVOID pPackage ) { }
		void Fun_02 ( INT32 a, INT32 b, INT32 c ) {}
		void Fun_03 ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) {}
		void Fun_04 ( INT32 a, INT32 b, INT32 c ) {}
		void Fun_05 ( INT32 a ) {}
		void Fun_06 ( INT32 a ) {}
		void Fun_07 ( INT32 a ) {}
		void Fun_08 ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) {}
		void Fun_09 ( INT32 a, INT32 b, INT32 c ) {}
		void Fun_10 ( INT32 a, INT32 b ) {}
		void Fun_11 ( INT32 a, INT32 b ) {}
		void Fun_12 ( INT32 a ) {}
		void Fun_13 ( INT32 a, INT32 b ) {}
		void Fun_14 ( INT32 a ) {}
		void Fun_15 ( INT32 a ) {}
		void Fun_16 ( INT32 a ) {}
		void Fun_17 ( ) {}
		void Fun_18 ( ) {}
		void Fun_19 ( INT32 a ) {}
		void Fun_20 ( INT32 a, INT32 b ) {}
		void Fun_21 ( INT32 a ) {}
		void Fun_22 ( ) {}
		void Fun_23 ( INT32 a, INT32 b ) {}
		void Fun_24 ( INT32 a, INT32 b ) {}
		void Fun_25 ( INT32 a, INT32 b, INT32 c ) {}
		void Fun_26 ( ) {}
	};
}


```

`QQTang CheatEngine/QQTang CheatEngine.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2EAA7EC3-1E1E-4766-84BB-CAD01EFB678D}</ProjectGuid>
    <RootNamespace>QQTangCheatEngine</RootNamespace>
    <SccProjectName>Svn</SccProjectName>
    <SccAuxPath>Svn</SccAuxPath>
    <SccLocalPath>Svn</SccLocalPath>
    <SccProvider>SubversionScc</SccProvider>
    <WindowsTargetPlatformVersion>10.0.16299.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <ConfigurationType>Utility</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateMapFile>true</GenerateMapFile>
      <SubSystem>Windows</SubSystem>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Boss.hpp" />
    <ClInclude Include="CCall.hpp" />
    <ClInclude Include="EncodeMember.hpp" />
    <ClInclude Include="GameBomb.hpp" />
    <ClInclude Include="GameBox.hpp" />
    <ClInclude Include="GameFloor.hpp" />
    <ClInclude Include="GameInfo.hpp" />
    <ClInclude Include="GameItem.hpp" />
    <ClInclude Include="GameManager.hpp" />
    <ClInclude Include="GameUI.hPP" />
    <ClInclude Include="NPCItem.hpp" />
    <ClInclude Include="NPC.hpp" />
    <ClInclude Include="Player.hpp" />
    <ClInclude Include="QQTangCheatEngine.hpp" />
    <ClInclude Include="QQTangClient.hpp" />
    <ClInclude Include="Maple.hpp" />
    <ClInclude Include="MessageLayer.hpp" />
    <ClInclude Include="QQTangEnum.hpp" />
    <ClInclude Include="QQTangPackage.hpp" />
    <ClInclude Include="QQTEncoder.hpp" />
    <ClInclude Include="QQTSection.hpp" />
    <ClInclude Include="RoomInfo.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="PythonCode\levelCFG.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiConst.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiFunc.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiGame.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiLogin.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiLogo.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiMain.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiRoom.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiSelRoom.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiSelSect.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiShop.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiTemplate.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
    <None Include="PythonCode\uiWeb.py">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</DeploymentContent>
      <FileType>Text</FileType>
    </None>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`QQTang CheatEngine/QQTang CheatEngine.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="QQTang">
      <UniqueIdentifier>{d82ecd4d-9424-42a2-bf8f-f617aaeb6f4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="System">
      <UniqueIdentifier>{6c14ca09-c868-4e79-b567-45592da97dd7}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Enum">
      <UniqueIdentifier>{c770c978-6c46-4402-aabc-301dea308ad3}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client">
      <UniqueIdentifier>{6a143d64-cd5f-41da-9a05-c8d72dcf41ce}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Package">
      <UniqueIdentifier>{e55a99b5-5a90-4e25-bdfa-cbf1b14ba9dc}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\GameItem">
      <UniqueIdentifier>{f9636910-9f6d-4b0b-9264-57dd8da1c319}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\GameUI">
      <UniqueIdentifier>{9494ccf6-662c-4195-9986-ea7246ccbef9}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\GFX">
      <UniqueIdentifier>{1fef0f48-5cee-4eca-aa4c-58e9f19eef4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\MessageLayer">
      <UniqueIdentifier>{846860a4-9ce7-41d9-8914-200a275c9e47}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\Room">
      <UniqueIdentifier>{de27796c-4e1a-4f9e-855a-582cd38a28a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\Encoder">
      <UniqueIdentifier>{c9115326-7366-4644-b5e4-0ebd67c05f6a}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Client\Section">
      <UniqueIdentifier>{845793c1-90a0-4113-a7f9-8a7dfc523d01}</UniqueIdentifier>
    </Filter>
    <Filter Include="QQTang\Call">
      <UniqueIdentifier>{cea7ec94-de2e-4afa-83a6-118640d52724}</UniqueIdentifier>
    </Filter>
    <Filter Include="PythonCode">
      <UniqueIdentifier>{039d2b12-a5ee-458f-ab4b-aab99755919d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Maple.hpp">
      <Filter>System</Filter>
    </ClInclude>
    <ClInclude Include="EncodeMember.hpp">
      <Filter>QQTang\Client\Encoder</Filter>
    </ClInclude>
    <ClInclude Include="QQTEncoder.hpp">
      <Filter>QQTang\Client\Encoder</Filter>
    </ClInclude>
    <ClInclude Include="Boss.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="QQTangEnum.hpp">
      <Filter>QQTang\Enum</Filter>
    </ClInclude>
    <ClInclude Include="QQTangPackage.hpp">
      <Filter>QQTang\Package</Filter>
    </ClInclude>
    <ClInclude Include="QQTangClient.hpp">
      <Filter>QQTang\Client</Filter>
    </ClInclude>
    <ClInclude Include="GameBomb.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="GameBox.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="GameFloor.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="GameItem.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="NPC.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="NPCItem.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="Player.hpp">
      <Filter>QQTang\Client\GameItem</Filter>
    </ClInclude>
    <ClInclude Include="QQTSection.hpp">
      <Filter>QQTang\Client\Section</Filter>
    </ClInclude>
    <ClInclude Include="RoomInfo.hpp">
      <Filter>QQTang\Client\Room</Filter>
    </ClInclude>
    <ClInclude Include="MessageLayer.hpp">
      <Filter>QQTang\Client\MessageLayer</Filter>
    </ClInclude>
    <ClInclude Include="GameManager.hpp">
      <Filter>QQTang\Client\MessageLayer</Filter>
    </ClInclude>
    <ClInclude Include="GameInfo.hpp">
      <Filter>QQTang\Client\MessageLayer</Filter>
    </ClInclude>
    <ClInclude Include="QQTangCheatEngine.hpp">
      <Filter>System</Filter>
    </ClInclude>
    <ClInclude Include="CCall.hpp">
      <Filter>QQTang\Call</Filter>
    </ClInclude>
    <ClInclude Include="GameUI.hPP">
      <Filter>QQTang\Client\GameUI</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="PythonCode\levelCFG.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiConst.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiFunc.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiGame.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiLogin.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiLogo.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiMain.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiRoom.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiSelRoom.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiSelSect.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiShop.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiTemplate.py">
      <Filter>PythonCode</Filter>
    </None>
    <None Include="PythonCode\uiWeb.py">
      <Filter>PythonCode</Filter>
    </None>
  </ItemGroup>
</Project>
```

`QQTang CheatEngine/QQTangCheatEngine.hpp`:

```hpp
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "RoomInfo.hpp"
#include "GameUI.hPP"
#include "CCall.hpp"
namespace QQTangCheatEngine
{


    class CQQTangCheatEngine
    {
    private:
        PMessageLayer m_pMessageLayer;
        PGameManager m_pGameManager;
        PRoom m_pRoom;
        CCall m_call;
        PGameUI m_pGameUI;
    public:
        CQQTangCheatEngine ( )
        {
            m_pMessageLayer = CMessageLayer::GetMessageLayer ( );
            m_pRoom = CRoom::GetRoom ( );
            m_pGameManager = m_pMessageLayer->GetGameManager ( );
            m_pGameUI = CGameUI::GetGameUI ( );
        }


        void GetDisPlayAddress ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
             for ( int i = 0; i<0xffff; i++ )
            {
                auto p = m_pGameManager->GetGameDispose ( )->GetGameDisplayInfo ( ( GameID ) ( i ) );
                if ( p != nullptr )
                {
                    m_pGameUI->GameDebugPrintf ( "%08X" , p->GetDisplayAddr ( ) );
                }
            }

        }

        void FullScreenBoxExplode ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
           
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            PMapBox lpMapBox = lpGameInfo->GetMapBox ( );
            PMap lpMap = lpGameInfo->GetMap ( );


            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );

            vector<CEXPLODEINFO::CBoxExplode>vecBoxExplode;
            vecBoxExplode.reserve ( MaxMapX*MaxMapY );

            for ( INT32 y = 0; y < MaxMapY; y++ )
            {
                for ( INT32 x = 0; x < MaxMapX; x++ )
                {
                    //墙壁
                    ItemByBox BoxID = lpMapBox->GetBoxID ( x , y );
                    CEXPLODEINFO::CBoxExplode BoxExplode;
                    if ( BoxID != BOX_COMMON_00 )
                    {
                        BoxExplode.m_BoxID = BoxID;
                        BoxExplode.m_BoxX = ( INT8 ) x;
                        BoxExplode.m_BoxY = ( INT8 ) y;
                        vecBoxExplode.push_back ( BoxExplode );
                    }
                    //地图上的另外一种墙壁 比如野外的草丛.WC 猪 
                    BoxID = lpMap->GetBoxID ( x , y );
                    if ( BoxID != BOX_COMMON_00 )
                    {
                        BoxExplode.m_BoxID = BoxID;
                        BoxExplode.m_BoxX = ( INT8 ) x;
                        BoxExplode.m_BoxY = ( INT8 ) y;
                        vecBoxExplode.push_back ( BoxExplode );
                    }
                }
            }

            if ( vecBoxExplode.empty ( ) )
            {
                return;
            }

            CEXPLODEINFO ExplodeInfo;
            memset ( &ExplodeInfo , 0 , sizeof ( CEXPLODEINFO ) );
            ExplodeInfo.m_PlayerID = lpGameInfo->GetPlayerInfo ( )->GetArbitrator ( )->GetIDFromServer ( );
            ExplodeInfo.m_GameTime = lpGameInfo->GetGameTime ( );
            CEXPLODEINFO::CBoxExplode* pBoxExplode = ExplodeInfo.m_BoxExplode;
            for ( vector<CEXPLODEINFO::CBoxExplode>::const_iterator it = vecBoxExplode.begin ( ); it != vecBoxExplode.end ( ); it++ )
            {

                memcpy ( pBoxExplode , ( const void* ) ( it._Ptr ) , sizeof ( CEXPLODEINFO::CBoxExplode ) );
                pBoxExplode++;
                ExplodeInfo.m_BoxExplodeSize++;
                if ( ExplodeInfo.m_BoxExplodeSize == 32 )
                {
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    pBoxExplode = ExplodeInfo.m_BoxExplode;
                    ExplodeInfo.m_BoxExplodeSize = 0;
                }
            }
            if ( ExplodeInfo.m_BoxExplodeSize != 0 )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
            }
        }

        void FullScreenBombExplode ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }

            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            INT32 GameTime = lpGameInfo->GetGameTime ( );
            INT16 PlayerID = lpGameInfo->GetPlayerInfo ( )->GetArbitrator ( )->GetIDFromServer ( );


            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );
            vector<CEXPLODEINFO::CBombExplode>vecBombExplode ( MaxMapY *MaxMapX );
            vector<CEXPLODEINFO::CBombExplode>::iterator it = vecBombExplode.begin ( );

            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    it->m_BombY = ( INT8 ) y;
                    it->m_BombUp = ( INT8 ) y;
                    it->m_BombDown = ( INT8 ) y;
                    it->m_BombX = ( INT8 ) x;
                    it->m_BombLeft = ( INT8 ) x;
                    it->m_BombRigth = ( INT8 ) x;
                    it->m_BombMode = 0x15;
                    it->m_BomberID = PlayerID;
                    it->m_BombTime = GameTime;
                    it++;
                }
            }

            CEXPLODEINFO ExplodeInfo;
            memset ( &ExplodeInfo , 0 , sizeof ( CEXPLODEINFO ) );
            ExplodeInfo.m_PlayerID = PlayerID;
            ExplodeInfo.m_GameTime = GameTime;

            CEXPLODEINFO::CBombExplode* pBombExplode = ExplodeInfo.m_BombExplode;
            for ( vector<CEXPLODEINFO::CBombExplode>::const_iterator it = vecBombExplode.begin ( ); it != vecBombExplode.end ( ); it++ )
            {
                memcpy ( pBombExplode , ( const void * ) ( it._Ptr ) , sizeof ( CEXPLODEINFO::CBombExplode ) );
                pBombExplode++;
                ExplodeInfo.m_BombExplodeSize++;
                if ( ExplodeInfo.m_BombExplodeSize == 32 )
                {
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    ExplodeInfo.m_BombExplodeSize = 0;
                    pBombExplode = ExplodeInfo.m_BombExplode;
                }
            }
            if ( ExplodeInfo.m_BombExplodeSize != 0 )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
            }
        }

        void FullScreenPropExplode ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }

            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );

            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );

            vector<CEXPLODEINFO::CPropExplode>vecPropExplode;
            vecPropExplode.reserve ( MaxMapY*MaxMapX );

            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    CVector<PGameItem>&vecGameItem = lpGameInfo->GetMapItem ( )->FindGameItem ( y , x );
                    vector<PGameItem>::const_iterator it;
                    for ( it = vecGameItem.GetVecInfo ( )->begin ( ); it != vecGameItem.GetVecInfo ( )->end ( ); it++ )
                    {
                        CEXPLODEINFO::CPropExplode PropExplode;
                        PropExplode.m_PropID = ( *it )->GetItemID ( );
                        PropExplode.m_PropX = ( INT8 ) x;
                        PropExplode.m_PropY = ( INT8 ) y;
                        vecPropExplode.push_back ( PropExplode );
                    }
                }
            }
            if ( vecPropExplode.empty ( ) )
            {
                return;
            }
            CEXPLODEINFO ExplodeInfo;
            memset ( &ExplodeInfo , 0 , sizeof ( CEXPLODEINFO ) );
            ExplodeInfo.m_PlayerID = lpGameInfo->GetPlayerInfo ( )->GetArbitrator ( )->GetIDFromServer ( );
            ExplodeInfo.m_GameTime = lpGameInfo->GetGameTime ( );
            CEXPLODEINFO::CPropExplode* pPropExplode = ExplodeInfo.m_PropExplode;
            vector<CEXPLODEINFO::CPropExplode>::const_iterator it;
            for ( it = vecPropExplode.begin ( ); it != vecPropExplode.end ( ); it++ )
            {
                memcpy ( pPropExplode , ( const void* ) ( it._Ptr ) , sizeof ( CEXPLODEINFO::CPropExplode ) );
                pPropExplode++;
                ExplodeInfo.m_PropExplodeSize++;
                if ( ExplodeInfo.m_PropExplodeSize == 32 )
                {
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                    ExplodeInfo.m_PropExplodeSize = 0;
                    pPropExplode = ExplodeInfo.m_PropExplode;
                }
            }
            if ( ExplodeInfo.m_PropExplodeSize != 0 )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_EXPLODEINFO , ExplodeInfo );
            }
        }

        void FullScreenCreateBox ( ItemByBox BoxID )
        {
            //判断在不在游戏
            if ( m_pGameManager == NULL )
            {
                return;
            }

            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            //获取箱子数据
            PMapBox lpMapBox = lpGameInfo->GetMapBox ( );
            //获取游戏场景的XY
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );

            //存放箱子信息的 并预留一定的大小
            vector<CCREATEBOX::CREATEBOXINFO>vecCreateBoxInfo;
            vecCreateBoxInfo.reserve ( MaxMapX*MaxMapY );

            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    //判断xy上是否有箱子
                    if ( BOX_COMMON_00 != lpMapBox->GetBoxID ( x , y ) )
                    {
                        continue;
                    }
                    //填充数据
                    CCREATEBOX::CREATEBOXINFO CreateBoxInfo;
                    //箱子x
                    CreateBoxInfo.m_BoxX = ( INT8 ) x;
                    //箱子y
                    CreateBoxInfo.m_BoxY = ( INT8 ) y;
                    //箱子id
                    CreateBoxInfo.m_BoxID = ( INT16 ) BoxID;
                    //箱子数据
                    CreateBoxInfo.m_BoxCode = lpGameInfo->GetBoxCode ( )->GetCode ( y , x );
                    //保存
                    vecCreateBoxInfo.push_back ( CreateBoxInfo );
                }
            }
            //判断有没有数据
            if ( vecCreateBoxInfo.empty ( ) )
            {
                return;
            }
            CCREATEBOX CreateBox;
            //初始化CreateBox
            memset ( &CreateBox , 0 , sizeof ( CCREATEBOX ) );
            CCREATEBOX::CREATEBOXINFO* pCreateBoxInfo = CreateBox.m_CreateBoxInfo;
            //填充数据包
            for ( vector<CCREATEBOX::CREATEBOXINFO>::const_iterator it = vecCreateBoxInfo.begin ( ); it != vecCreateBoxInfo.end ( ); it++ )
            {
                memcpy ( pCreateBoxInfo , ( const void* ) ( it._Ptr ) , sizeof ( CCREATEBOX::CREATEBOXINFO ) );
                pCreateBoxInfo++;
                CreateBox.m_CreateBoxSize++;
                //每次发送16个
                if ( CreateBox.m_CreateBoxSize == 16 )
                {
                    //发送给玩家
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_CREATEBOX , CreateBox );
                    //本地显示
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_CREATEBOX , CreateBox );
                    CreateBox.m_CreateBoxSize = 0;
                    pCreateBoxInfo = CreateBox.m_CreateBoxInfo;
                }
            }
            //剩余的不足16个的也要发送
            if ( CreateBox.m_CreateBoxSize != 0 )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_CREATEBOX , CreateBox );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_CREATEBOX , CreateBox );
            }
        }

        void FullScreenGetProp ( )
        {
            //开始游戏了嘛?
            if ( m_pGameManager == NULL )
            {
                return;
            }

            //获取游戏场景的XY
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );

            //存放道具信息的 并预留一定的大小
            vector<CNPCGETITEM>vecNPCGetItem;
            vecNPCGetItem.reserve ( MaxMapX*MaxMapY );

            //填充数据包
            CNPCGETITEM NPCGetItem;
            //游戏时间
            NPCGetItem.m_GameTime = lpGameInfo->GetGameTime ( );
            //玩家ID
            NPCGetItem.m_PlayerID = lpGameInfo->GetPlayerInfo ( )->GetMySelf ( )->GetIDFromServer ( );

            //全场枚举道具
            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    //寻找道具 返回XY上的所有道具信息
                    CVector<PGameItem>&vecGameItem = lpGameInfo->GetMapItem ( )->FindGameItem ( y , x );

                    //分析当前XY上的道具信息
                    for each ( PGameItem obj in *( vecGameItem.GetVecInfo ( ) ) )
                    {
                        //道具ID
                        NPCGetItem.m_PropID = obj->GetItemID ( );
                        //道具所在的X坐标值
                        NPCGetItem.m_GeterX = obj->GetItemInPlayerX ( );
                        //道具所在的Y坐标值
                        NPCGetItem.m_GeterY = obj->GetItemInPlayerY ( );

                        if ( NPCGetItem.IsPropToServer ( ) )
                        {
                            //这些道具是需要通知服务器
                            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCGETITEM , &NPCGetItem );
                        }
                        //保存
                        vecNPCGetItem.push_back ( NPCGetItem );
                    }
                }
            }

            //有道具嘛?
            if ( vecNPCGetItem.empty ( ) )
            {
                return;
            }

            for ( vector<CNPCGETITEM>::const_iterator it = vecNPCGetItem.begin ( ); it != vecNPCGetItem.end ( ); it++ )
            {
                //循环发送给其他客户端
                m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCGETITEM , *it );
                //本地显示
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCGETITEM , *it );
            }
        }

        void FullScreenGetServerProp ( )
        {
            //开始游戏了嘛?
            if ( m_pGameManager == NULL )
            {
                return;
            }

            //游戏数据
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );

            //填充数据包
            CNPCGETITEM NPCGetItem;
            NPCGetItem.m_PlayerID =
                lpGameInfo->GetPlayerInfo ( )->GetMySelf ( )->GetIDFromServer ( );

            //枚举BOSS
            vector<PBoss>* pvecBoss = lpGameInfo->GetBossList ( );
            for ( vector<PBoss>::const_iterator it = pvecBoss->begin ( );
                it != pvecBoss->end ( ); it++ )
            {
                //BOSS内部有两个存放道具的vector
                CVector < CItemByDrop >* pvecItem =
                    ( *it )->GetNPCItem ( )->GetvecFirstItemByDrop ( );

                //枚举第一个
                for ( vector<CItemByDrop>::iterator item = pvecItem->GetVecInfo ( )->begin ( );
                    item != pvecItem->GetVecInfo ( )->end ( ); item++ )
                {

                    NPCGetItem.m_PropID = item->GetItemID ( );
                    if ( NPCGetItem.IsPropToServer ( ) )
                    {
                        //是服务器道具且有N个这样的道具 都一起发送给服务器
                        for ( int i = 0; i < item->GetItemSize ( ); i++ )
                        {
                            m_pMessageLayer->SetDataToServerEx
                                ( GameID::C2S_NPCGETITEM , &NPCGetItem );
                        }
                    }
                }
                //第二个
                pvecItem = ( *it )->GetNPCItem ( )->GetvecNextItemByDrop ( );
                for ( vector<CItemByDrop>::iterator item = pvecItem->GetVecInfo ( )->begin ( );
                    item != pvecItem->GetVecInfo ( )->end ( ); item++ )
                {
                    //同上
                    NPCGetItem.m_PropID = item->GetItemID ( );
                    if ( NPCGetItem.IsPropToServer ( ) )
                    {
                        for ( int i = 0; i < item->GetItemSize ( ); i++ )
                        {
                            m_pMessageLayer->SetDataToServerEx
                                ( GameID::C2S_NPCGETITEM , &NPCGetItem );
                        }
                    }
                }
            }


            //小鸟(飞机)内部的道具
            vector<ItemByGame>* pvecFlyItem = lpGameInfo->GetFlyItem ( );
            for ( vector<ItemByGame>::iterator item = pvecFlyItem->begin ( );
                item != pvecFlyItem->end ( ); item++ )
            {
                //同上
                NPCGetItem.m_PropID = *item;
                if ( NPCGetItem.IsPropToServer ( ) )
                {
                    m_pMessageLayer->SetDataToServerEx
                        ( GameID::C2S_NPCGETITEM , &NPCGetItem );
                }
            }

            //获取游戏场景的XY
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );

            //全场枚举道具
            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    //寻找道具 返回XY上的所有道具信息
                    CVector<PGameItem>&vecGameItem =
                        lpGameInfo->GetMapItem ( )->FindGameItem ( y , x );

                    //分析当前XY上的道具是服务器道具
                    for each ( PGameItem obj in *( vecGameItem.GetVecInfo ( ) ) )
                    {
                        NPCGetItem.m_PropID = obj->GetItemID ( );
                        //判断下是不是服务器道具
                        if ( NPCGetItem.IsPropToServer ( ) )
                        {
                            //发送
                            m_pMessageLayer->SetDataToServerEx
                                ( GameID::C2S_NPCGETITEM , &NPCGetItem );
                        }
                    }
                }
            }

        }

        //第一次飞机还没完成 第二个就跟上了...
        void FullScreenPlaneDropProp ( ItemByGame PropID )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            vector<CDROPPROPINFO::CDROPPROP>vecDropItem ( MaxMapY*MaxMapX );
            vector<CDROPPROPINFO::CDROPPROP>::iterator it = vecDropItem.begin ( );
            for ( int x = 0; x < MaxMapX; x++ )
            {
                for ( int y = 0; y < MaxMapY; y++ )
                {
                    it->m_PropID = PropID;
                    it->m_PropX = ( INT8 ) x;
                    it->m_PropY = ( INT8 ) y;
                    it++;
                }
            }
            CPLANEDROPITEM PlaneDropItem;
            memset ( &PlaneDropItem , 0 , sizeof ( CPLANEDROPITEM ) );
            PlaneDropItem.m_GameTime = lpGameInfo->GetGameTime ( );
            CDROPPROPINFO::CDROPPROP* lpDropProp = PlaneDropItem.m_DropItemInfo.m_DropProp;
            for ( vector<CDROPPROPINFO::CDROPPROP>::const_iterator it = vecDropItem.begin ( ); it != vecDropItem.end ( ); it++ )
            {
                memcpy ( lpDropProp , ( const void* ) ( it._Ptr ) , sizeof ( CDROPPROPINFO::CDROPPROP ) );
                lpDropProp++;
                PlaneDropItem.m_DropItemInfo.m_DropPropSize++;
                if ( PlaneDropItem.m_DropItemInfo.m_DropPropSize == 0x20 )
                {
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_PLANEDROPITEM , PlaneDropItem );
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_PLANEDROPITEM , PlaneDropItem );
                    lpDropProp = PlaneDropItem.m_DropItemInfo.m_DropProp;
                    PlaneDropItem.m_DropItemInfo.m_DropPropSize = 0;
                }
            }
            if ( 0 != PlaneDropItem.m_DropItemInfo.m_DropPropSize )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_PLANEDROPITEM , PlaneDropItem );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_PLANEDROPITEM , PlaneDropItem );
            }
        }

        void FullScreenGameDropBomb ( ItemByGame PropID )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            vector<CDROPPROPINFO::CDROPPROP>vecDropItem ( MaxMapY*MaxMapX );
            vector<CDROPPROPINFO::CDROPPROP>::iterator it = vecDropItem.begin ( );
            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    it->m_PropID = PropID;
                    it->m_PropX = ( INT8 ) x;
                    it->m_PropY = ( INT8 ) y;
                    it++;
                }
            }
            CGAMEDROPBOMB GameDropBomb;
            memset ( &GameDropBomb , 0 , sizeof ( CGAMEDROPBOMB ) );
            GameDropBomb.m_GameTime = lpGameInfo->GetGameTime ( );
            GameDropBomb.m_PlayerID = lpGameInfo->GetPlayerInfo ( )->GetArbitrator ( )->GetIDFromServer ( );
            CDROPPROPINFO::CDROPPROP* pDropProp = GameDropBomb.m_DropPropInfo.m_DropProp;
            for ( vector<CDROPPROPINFO::CDROPPROP>::const_iterator it = vecDropItem.begin ( ); it != vecDropItem.end ( ); it++ )
            {
                memcpy ( pDropProp , ( const void* ) ( it._Ptr ) , sizeof ( CDROPPROPINFO::CDROPPROP ) );
                pDropProp++;
                GameDropBomb.m_DropPropInfo.m_DropPropSize++;
                if ( GameDropBomb.m_DropPropInfo.m_DropPropSize == 0x20 )
                {
                    m_pMessageLayer->SetDataToClient ( GameID::P2P_GAMEDROPBOMB , GameDropBomb );
                    m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_GAMEDROPBOMB , GameDropBomb );
                    GameDropBomb.m_DropPropInfo.m_DropPropSize = 0;
                    pDropProp = GameDropBomb.m_DropPropInfo.m_DropProp;
                }
            }
            if ( GameDropBomb.m_DropPropInfo.m_DropPropSize )
            {
                m_pMessageLayer->SetDataToClient ( GameID::P2P_GAMEDROPBOMB , GameDropBomb );
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_GAMEDROPBOMB , GameDropBomb );
            }
        }

        void FullScreenPlayBomb ( NPCINDEX Index )
        {
            //判断在游戏嘛
            if ( m_pGameManager == NULL )
            {
                return;
            }

            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            //地图上没有泡泡 就不执行
            if ( 0 == lpGameInfo->GetMapBomb ( )->GetMapBombCount ( ) )
            {
                return;
            }
            //要飞向哪个玩家
            PPlyaer lpPlayer = lpGameInfo->AtPlayer ( Index );
            if ( lpPlayer == NULL )
            {
                return;
            }
            //填充数据包
            CPLAYBOMB PlayBomb;
            //游戏时间
            PlayBomb.m_GameTime = ( INT16 ) lpGameInfo->GetGameTime ( );
            PlayBomb.m_PlayerFace = lpPlayer->GetPlayerFace ( );
            //玩家id
            PlayBomb.m_PlayerID = lpPlayer->GetIDFromServer ( );
            //泡泡位置
            PlayBomb.m_NewYX = CLocation ( lpPlayer->GetPlayerInMapX ( ) , lpPlayer->GetPlayerInMapY ( ) );

            INT32 MaxMapX = lpGameInfo->GetMapItem ( )->GetMaxMapX ( );
            INT32 MaxMapY = lpGameInfo->GetMapItem ( )->GetMaxMapY ( );
            vector<CPLAYBOMB>vecPlayBomb;
            //存放泡泡信息的 并预留一定的大小
            vecPlayBomb.reserve ( MaxMapX*MaxMapY );

            for ( INT32 x = 0; x < MaxMapX; x++ )
            {
                for ( INT32 y = 0; y < MaxMapY; y++ )
                {
                    //泡泡位置和人物位置一样还用移动？
                    if ( x == ( INT32 ) PlayBomb.m_NewYX.GetX ( ) && y == ( INT32 ) PlayBomb.m_NewYX.GetY ( ) )
                    {
                        continue;
                    }
                    //获取泡泡信息
                    CVector<PGameBomb>&vecGameBomb = lpGameInfo->GetMapBomb ( )->FindGameBomb ( y , x );
                    vector<PGameBomb>::const_iterator it;
                    //填充数据包
                    for ( it = vecGameBomb.GetVecInfo ( )->begin ( ); it != vecGameBomb.GetVecInfo ( )->end ( ); it++ )
                    {
                        //泡泡id
                        PlayBomb.m_BomberID = ( *it )->GetBomberID ( );
                        //游戏时间
                        PlayBomb.m_BombTime = ( *it )->GetGameTime ( );
                        //威力
                        PlayBomb.m_BombPower = ( INT8 ) ( *it )->GetBombPower ( );
                        //原来位置
                        PlayBomb.m_OldYX = *( ( *it )->GetBombXY ( ) );
                        //保存
                        vecPlayBomb.push_back ( PlayBomb );
                    }
                }
            }
            //没有数据就不发了
            if ( vecPlayBomb.empty ( ) )
            {
                return;
            }

            for ( vector<CPLAYBOMB>::const_iterator it = vecPlayBomb.begin ( ); it != vecPlayBomb.end ( ); it++ )
            {
                //发送数据包
                m_pMessageLayer->SetDataToClient ( GameID::P2P_PLAYBOMB , *it );
                //本地显示
                m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_PLAYBOMB , *it );
            }
        }

        void BossSkill ( NPCINDEX Index , SkillByBoss skillid , ItemByGame Itemid )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            PPlyaer lpPlayer = lpGameInfo->AtPlayer ( Index );
            if ( lpPlayer == NULL )
            {
                return;
            }
            CBOSSSKILL Skill;
            memset ( &Skill , 0 , sizeof ( CBOSSSKILL ) );
            Skill.m_GameTime = lpGameInfo->GetGameTime ( );
            Skill.m_PlayerID = lpPlayer->GetIDFromServer ( );
            Skill.m_PlayerX = ( INT16 ) lpPlayer->GetNPCX ( );
            Skill.m_PlayerY = ( INT16 ) lpPlayer->GetNPCY ( );
            Skill.m_SkillID = skillid;

            //TODO: 掉道具的没加哦 
            switch ( skillid )
            {
                case QQTangCheatEngine::SKILL_DROPITEMD:
                case QQTangCheatEngine::SKILL_DROPITEMC:
                case QQTangCheatEngine::SKILL_DROPITEMA:
                case QQTangCheatEngine::SKILL_DROPITEMB:
                    break;
                case QQTangCheatEngine::SKILL_DROPBOMB:
                    break;
            }
            m_pMessageLayer->SetDataToClient ( GameID::P2P_BOSSSKILL , Skill );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_BOSSSKILL , Skill );
        }


        //直接胜利 比武不行...
        void SuperWinGame ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            //INT32 GameTime = lpGameInfo->GetGameTime ( );
            PPlyaer pPlayer = lpGameInfo->GetPlayerInfo ( )->GetMySelf ( );
            switch ( m_pGameManager->GetGameModleInfo ( )->GetGameModle ( ) )
            {
                case QQTangCheatEngine::MODLE_TANK:
                {
                    CTANKROOMEXPLODE TankRoomExplode;
                    var lpGameRoom = lpGameInfo->GetTankRoomA ( );
                    if ( NULL != lpGameRoom )
                    {
                        if ( lpGameRoom->GetRoomColor ( ) == pPlayer->GetPlayerTeamColor ( ) )
                        {
                            lpGameRoom = lpGameInfo->GetTankRoomB ( );
                        }
                        //TankRoomExplode.m_GameTime = GameTime;
                        TankRoomExplode.m_PlayerID = pPlayer->GetIDFromServer ( );
                        TankRoomExplode.m_TankColor = lpGameRoom->GetRoomColor ( );
                        TankRoomExplode.m_TankHP = ( INT16 ) ( -lpGameRoom->GetTaskHp ( ) );
                        m_pMessageLayer->SetDataToServerEx ( GameID::C2S_TANKROOMEXPLODE , &TankRoomExplode );
                    }
                }
                case QQTangCheatEngine::MODLE_COMMON:
                case QQTangCheatEngine::MODLE_BOX:
                case QQTangCheatEngine::MODLE_BOMB:
                case QQTangCheatEngine::MODLE_MACHINE:
                case QQTangCheatEngine::MODLE_PVE:
                {
                    //倒的循环 BOSS先屎然后再我们挂
                    for ( vector<PPlyaer>::const_reverse_iterator rit = lpGameInfo->GetPlayerList ( )->rbegin ( );
                        rit != lpGameInfo->GetPlayerList ( )->rend ( ); rit++ )
                    {

                        CNPCDIE npcdie;
                        npcdie.m_PlayerID = ( *rit )->GetIDFromServer ( );
                        //npcdie.m_GameTime = GameTime;
                        m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCDIE , &npcdie );
                    }
                    break;
                }
                case QQTangCheatEngine::MODLE_MATCH:
                {
                    CINJELLY InJelly;
                    //InJelly.m_GameTime = GameTime;
                    InJelly.m_HadAvatar = false;

                    CNPCSAVE npcsave;
                    //npcsave.m_GameTime = GameTime;


                    for ( vector<PPlyaer>::const_iterator it = lpGameInfo->GetPlayerList ( )->begin ( );
                        it != lpGameInfo->GetPlayerList ( )->end ( ); it++ )
                    {
                        if ( ( *it )->GetPlayerTeamColor ( ) != pPlayer->GetPlayerTeamColor ( ) )
                        {
                            INT16 PlayerID = ( *it )->GetIDFromServer ( );
                            // 							InJelly.m_PlayerX = ( INT16 ) ( *it )->GetNPCX ( );
                            // 							InJelly.m_PlayerY = ( INT16 ) ( *it )->GetNPCY ( );
                            InJelly.m_PlayerID = PlayerID;

                            npcsave.m_DeadID = PlayerID;
                            npcsave.m_PlayerID = PlayerID;
                            // 							npcsave.m_SaverX = ( INT16 ) ( *it )->GetNPCX ( );
                            // 							npcsave.m_SaverY = ( INT16 ) ( *it )->GetNPCY ( );
                            for ( int i = 0; i < 100; i++ )
                            {
                                m_pMessageLayer->SetDataToServerEx ( GameID::C2S_INJELLY , &InJelly );
                                // 								m_pMessageLayer->SetDataToClient ( GameID::C2S_INJELLY, InJelly );
                                // 								m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::C2S_INJELLY, InJelly );

                                m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCSAVE , &npcsave );
                                // 								m_pMessageLayer->SetDataToClient ( GameID::C2S_NPCSAVE, npcsave );
                                // 								m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::C2S_NPCSAVE, npcsave );
                            }
                        }
                    }
                    break;
                }
                case QQTangCheatEngine::MODLE_TREASURE:
                {
                    CNPCGETITEM NpcGetItem;
                    // 					NpcGetItem.m_GameTime = GameTime;
                    NpcGetItem.m_PlayerID = pPlayer->GetIDFromServer ( );
                    NpcGetItem.m_PropID = ItemByGame::GAME_LVBAOSHI;
                    for ( int i = 0; i < 44 / 3 + 1; i++ )
                    {
                        m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCGETITEM , &NpcGetItem );
                    }
                    break;
                }
                case QQTangCheatEngine::MODLE_SCULPTURE:
                {
                    var lpGameRoom = lpGameInfo->GetSculptureRoomA ( );
                    if ( lpGameRoom != NULL )
                    {
                        if ( lpGameRoom->GetRoomColor ( ) != pPlayer->GetPlayerTeamColor ( ) )
                        {
                            lpGameRoom = lpGameInfo->GetSculptureRoomB ( );
                        }
                        CGETBUNINROOM GetBunInRoom;
                        GetBunInRoom.m_GameIDType = 0;
                        //						GetBunInRoom.m_GameTime = GameTime;
                        GetBunInRoom.m_PlayerID = pPlayer->GetIDFromServer ( );
                        GetBunInRoom.m_SculptureType = 15;
                        GetBunInRoom.m_PlayerX = lpGameRoom->GetRoomXY ( )->GetPlayerX ( );
                        GetBunInRoom.m_PlayerY = lpGameRoom->GetRoomXY ( )->GetPlayerY ( );
                        for ( INT32 i = 0; i < 4; i++ )
                        {
                            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_GETBUNINROOM , &GetBunInRoom );
                        }
                    }
                    break;
                }
                case QQTangCheatEngine::MODLE_BUN:
                {
                    auto lpGameRoomA = lpGameInfo->GetBunRoomA ( );
                    if ( lpGameRoomA != NULL )
                    {
                        CGETBUNINROOM GetBunInRoom;
                        GetBunInRoom.m_GameIDType = 0;
                        // 						GetBunInRoom.m_GameTime = GameTime;
                        GetBunInRoom.m_PlayerID = pPlayer->GetIDFromServer ( );
                        if ( lpGameRoomA->GetRoomColor ( ) != pPlayer->GetPlayerTeamColor ( ) )
                        {
                            GetBunInRoom.m_BunColor = lpGameRoomA->GetRoomColor ( );
                        }
                        else
                        {
                            GetBunInRoom.m_BunColor = lpGameInfo->GetBunRoomB ( )->GetRoomColor ( );
                        }
                        for ( INT32 i = 0; i < 4; i++ )
                        {
                            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_GETBUNINROOM , &GetBunInRoom );
                        }
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
        }

        void PlayerInjelly ( NPCINDEX Index )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( Index );
            if ( pPlayer == NULL )
            {
                return;
            }
            CINJELLY InJelly;
            InJelly.m_PlayerID = pPlayer->GetIDFromServer ( );
            InJelly.m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
            InJelly.m_PlayerX = ( INT16 ) ( pPlayer->GetNPCX ( ) );
            InJelly.m_PlayerY = ( INT16 ) ( pPlayer->GetNPCY ( ) );
            InJelly.m_HadAvatar = pPlayer->GetAvatarInfo ( ) != NULL;
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_INJELLY , &InJelly );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_INJELLY , InJelly );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_INJELLY , InJelly );
        }

        void PlayerKill ( NPCINDEX KillIndex , NPCINDEX DeadIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pKiller = m_pGameManager->GetGameInfo ( )->AtPlayer ( KillIndex );
            if ( pKiller == NULL )
            {
                return;
            }
            PPlyaer pDead = m_pGameManager->GetGameInfo ( )->AtPlayer ( DeadIndex );
            if ( pDead == NULL )
            {
                return;
            }
            CNPCKILL NpcKill;
            NpcKill.m_PlayerID = pKiller->GetIDFromServer ( );
            NpcKill.m_GameTime = pKiller->GetGameInfo ( )->GetGameTime ( );
            NpcKill.m_KillerX = ( INT16 ) pDead->GetNPCX ( );
            NpcKill.m_KillerY = ( INT16 ) pDead->GetNPCY ( );
            NpcKill.m_DaedID = pDead->GetIDFromServer ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCKILL , &NpcKill );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCKILL , NpcKill );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCKILL , NpcKill );
        }

        void PlayerSave ( NPCINDEX SaveIndex , NPCINDEX DeadIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pSaver = m_pGameManager->GetGameInfo ( )->AtPlayer ( SaveIndex );
            if ( pSaver == NULL )
            {
                return;
            }
            PPlyaer pDead = m_pGameManager->GetGameInfo ( )->AtPlayer ( DeadIndex );
            if ( pDead == NULL )
            {
                return;
            }
            CNPCSAVE NpcSave;
            NpcSave.m_PlayerID = pSaver->GetIDFromServer ( );
            NpcSave.m_GameTime = pSaver->GetGameInfo ( )->GetGameTime ( );
            NpcSave.m_DeadID = pDead->GetIDFromServer ( );
            NpcSave.m_SaverX = ( INT16 ) pSaver->GetNPCX ( );
            NpcSave.m_SaverY = ( INT16 ) pSaver->GetNPCY ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCSAVE , &NpcSave );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCSAVE , NpcSave );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCSAVE , NpcSave );
        }

        void PlayerSave ( NPCINDEX SaveIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pSaver = m_pGameManager->GetGameInfo ( )->GetPlayerInfo ( )->GetMySelf ( );
            CNPCSAVE NpcSave;
            NpcSave.m_PlayerID = pSaver->GetIDFromServer ( );
            NpcSave.m_GameTime = pSaver->GetGameInfo ( )->GetGameTime ( );
            NpcSave.m_DeadID = pSaver->GetIDFromServer ( );
            NpcSave.m_SaverX = ( INT16 ) pSaver->GetNPCX ( );
            NpcSave.m_SaverY = ( INT16 ) pSaver->GetNPCY ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCSAVE , &NpcSave );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCSAVE , NpcSave );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCSAVE , NpcSave );
        }

        void PlayerDead ( NPCINDEX DeadIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pDead = m_pGameManager->GetGameInfo ( )->AtPlayer ( DeadIndex );
            if ( pDead == NULL )
            {
                return;
            }
            CNPCDIE NpcDie;
            NpcDie.m_PlayerID = pDead->GetIDFromServer ( );
            NpcDie.m_GameTime = pDead->GetGameInfo ( )->GetGameTime ( );
            NpcDie.m_PlayerY = ( INT16 ) pDead->GetNPCX ( );
            NpcDie.m_PlayerX = ( INT16 ) pDead->GetNPCY ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCDIE , &NpcDie );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCDIE , NpcDie );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCDIE , NpcDie );
        }

        void PlayerRelive ( NPCINDEX ReliverIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            var pReliver = m_pGameManager->GetGameInfo ( )->AtPlayer ( ReliverIndex );
            if ( pReliver == NULL )
            {
                return;
            }
            CNPCRELIVE NpcRelive;
            NpcRelive.m_PlayerID = pReliver->GetIDFromServer ( );
            NpcRelive.m_GameTime = pReliver->GetGameInfo ( )->GetGameTime ( );
            NpcRelive.m_ReliveX = ( INT8 ) pReliver->GetReLiveX ( );
            NpcRelive.m_ReliveY = ( INT8 ) pReliver->GetReLiveY ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::C2S_NPCRELIVE , &NpcRelive );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCRELIVE , NpcRelive );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCRELIVE , NpcRelive );
        }

        void AvatarDisapper ( NPCINDEX PlayerIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( PlayerIndex );
            if ( pPlayer == NULL )
            {
                return;
            }
            CNPCAVATARDISAPPEAR NpcVatar;
            NpcVatar.m_PlayerID = pPlayer->GetIDFromServer ( );
            NpcVatar.m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
            NpcVatar.m_PlayerX = ( INT16 ) pPlayer->GetNPCX ( );
            NpcVatar.m_PlayerY = ( INT16 ) pPlayer->GetNPCY ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::P2P_NPCAVATARDISAPPEAR , &NpcVatar );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCAVATARDISAPPEAR , NpcVatar );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCAVATARDISAPPEAR , NpcVatar );
        }

        void PlayLoseHp ( NPCINDEX PlayerIndex , INT16 IsAdd )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( PlayerIndex );
            if ( pPlayer == NULL )
            {
                return;
            }
            CNPCHPLOSS NpcLoss;
            NpcLoss.m_PlayerID = pPlayer->GetIDFromServer ( );
            NpcLoss.m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
            NpcLoss.m_PlayerX = ( INT16 ) pPlayer->GetNPCX ( );
            NpcLoss.m_PlayerY = ( INT16 ) pPlayer->GetNPCY ( );
            NpcLoss.m_HadAvatar = pPlayer->GetItemInfo ( )->GetAvatar ( );

            NpcLoss.m_Hp = ( INT16 ) -pPlayer->GetNPCItem ( )->GetHP ( )->GetValue ( TRUE );
            NpcLoss.m_Hp *= IsAdd;
            m_pMessageLayer->SetDataToServerEx ( GameID::P2P_NPCHPLOSS , &NpcLoss );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCHPLOSS , NpcLoss );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCHPLOSS , NpcLoss );
        }

        void PlayerLayBomb ( NPCINDEX PlayerIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( PlayerIndex );
            if ( pPlayer == NULL )
            {
                return;
            }
            CLAYOUTBOMB NpcLayBomb;
            NpcLayBomb.m_PlayerID = pPlayer->GetIDFromClinet ( );
            NpcLayBomb.m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
            NpcLayBomb.m_BombY = ( INT8 ) pPlayer->GetPlayerInMapY ( );
            NpcLayBomb.m_BombX = ( INT8 ) pPlayer->GetPlayerInMapX ( );
            NpcLayBomb.m_BombPower = ( INT16 ) pPlayer->GetNPCItem ( )->GetBombPower ( );
            NpcLayBomb.m_IsHide = pPlayer->IsItemUsing ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::P2P_LAYOUTBOMB , &NpcLayBomb );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_LAYOUTBOMB , NpcLayBomb );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_LAYOUTBOMB , NpcLayBomb );

        }

        void PlayerLayoutBomb ( NPCINDEX Index , CLocation& Location )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( Index );
            if ( pPlayer == NULL )
            {
                return;
            }
            CLAYOUTBOMB NpcLayBomb;
            NpcLayBomb.m_PlayerID = pPlayer->GetIDFromClinet ( );
            NpcLayBomb.m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
            NpcLayBomb.m_BombY = ( INT8 ) Location.GetY ( );
            NpcLayBomb.m_BombX = ( INT8 ) Location.GetX ( );
            NpcLayBomb.m_BombPower = ( INT16 ) pPlayer->GetNPCItem ( )->GetBombPower ( );
            NpcLayBomb.m_IsHide = pPlayer->IsItemUsing ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::P2P_LAYOUTBOMB , &NpcLayBomb );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_LAYOUTBOMB , NpcLayBomb );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_LAYOUTBOMB , NpcLayBomb );

        }

        void PlayerCopyBomb ( NPCINDEX pdestIndex , NPCINDEX pscrIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pDestPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( pdestIndex );
            if ( pDestPlayer == NULL )
            {
                return;
            }
            PPlyaer pScrPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( pscrIndex );
            if ( pScrPlayer == NULL )
            {
                return;
            }
            CLAYOUTBOMB NpcCopyBomb;
            NpcCopyBomb.m_PlayerID = pScrPlayer->GetIDFromClinet ( );
            NpcCopyBomb.m_GameTime = pDestPlayer->GetGameInfo ( )->GetGameTime ( );
            NpcCopyBomb.m_BombY = ( INT8 ) pDestPlayer->GetPlayerInMapY ( );
            NpcCopyBomb.m_BombX = ( INT8 ) pDestPlayer->GetPlayerInMapX ( );
            NpcCopyBomb.m_BombPower = ( INT16 ) pDestPlayer->GetNPCItem ( )->GetBombPower ( );
            NpcCopyBomb.m_IsHide = pDestPlayer->IsItemUsing ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::P2P_LAYOUTBOMB , &NpcCopyBomb );
            m_pMessageLayer->SetDataToClient ( GameID::P2P_LAYOUTBOMB , NpcCopyBomb );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_LAYOUTBOMB , NpcCopyBomb );

        }

        void PlayerExpre ( NPCINDEX PlayerIndex , PlayerExpression Expression )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PGameInfo lpGameInfo = m_pGameManager->GetGameInfo ( );
            PPlyaer pDestPlayer = lpGameInfo->AtPlayer ( PlayerIndex );
            if ( pDestPlayer == NULL )
            {
                return;
            }
            CNPCEXPRESSION NpcExpre;
            NpcExpre.m_PlayerID = pDestPlayer->GetIDFromServer ( );
            NpcExpre.m_GameTime = lpGameInfo->GetGameTime ( );
            NpcExpre.m_Expression = Expression;
            m_pMessageLayer->SetDataToClient ( GameID::P2P_NPCEXPRESSION , NpcExpre );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_NPCEXPRESSION , NpcExpre );
        }

        void PlayerQuit ( NPCINDEX PlayerIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pDestPlayer = m_pGameManager->GetGameInfo ( )->AtPlayer ( PlayerIndex );
            if ( pDestPlayer == NULL )
            {
                return;
            }
            CNOTIFYPLAYERQUITGAME NpcQuit;
            NpcQuit.m_PlayerID = pDestPlayer->GetIDFromServer ( );
            m_pMessageLayer->SetDataToClient ( GameID::S2C_NOTIFYPLAYERQUITGAME , NpcQuit );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::S2C_NOTIFYPLAYERQUITGAME , NpcQuit );

        }

        void NotifyGameOver ( )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            //TODO:
            CNOTIFYGAMEOVER GameOver;
            m_pMessageLayer->SetDataToClient ( GameID::S2C_NOTIFYGAMEOVER , GameOver );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::S2C_NOTIFYGAMEOVER , GameOver );
        }

        void NotifyNewAribitration ( NPCINDEX PlayerIndex )
        {
            if ( m_pGameManager == NULL )
            {
                return;
            }
            PPlyaer pPlayer = m_pGameManager->GetGameInfo ( )->GetPlayerList ( )->at ( PlayerIndex );
            CNOTIFYNEWARBITRATION NewArbitration;
            NewArbitration.m_PlayerID = pPlayer->GetIDFromServer ( );
            m_pMessageLayer->SetDataToServerEx ( GameID::S2C_NOTIFYNEWARBITRATION , &NewArbitration );
            m_pMessageLayer->SetDataToClient ( GameID::S2C_NOTIFYNEWARBITRATION , NewArbitration );
            m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::S2C_NOTIFYNEWARBITRATION , NewArbitration );

        }

        void CreateRoom ( )
        {
            m_call.CreateRoom ( );
        }

        void StartGame ( )
        {
            m_call.StartGame ( );
        }

        void UseObject ( ItemByPVE ObjectID , INT32 PetID )
        {
            m_call.UseObject ( ObjectID , PetID );
        }

        void SelRoomSpeak ( INT32 nsize , char *szBuffer )
        {
            m_call.SelRoomSpeak ( nsize , szBuffer );
        }

        void RoomSpeak ( INT32 nsize , char *szBuffer )
        {
            m_call.RoomSpeak ( nsize , szBuffer );
        }

        void SetRoomMsg ( char* szInRoomName , char* szOutRoomName , char* szPassWord )
        {
            m_call.SetRoomMsg ( szInRoomName , szOutRoomName , szPassWord );
        }

        void OperateDoor ( INT32 Index , INT32 nsize )
        {
            m_call.OperateDoor ( Index , nsize );
        }

        void SelMap ( MapID MapId , GameModle nsize )
        {
            m_call.SelMap ( MapId , nsize );
        }

        void SelRoomModal ( RoomType nType )
        {
            m_call.SelRoomModal ( nType );
        }

        void EnterRoom ( INT32 SelSect , INT32 RoomID , char* szPassword )
        {
            m_call.EnterRoom ( SelSect * 400 + RoomID - 1 , szPassword );
        }

        void EnterSelRoom ( PinDao pindao , QuYu quyu , INT32 SelSect )
        {
            m_call.EnterSelRoom ( 0 , pindao , quyu , SelSect );
        }

        void MsgBox ( char* szText , char* szCaption )
        {
            m_call.MsgBox ( szText , szCaption );
        }

        void NoticeBoard ( char* szText , char* szCaption )
        {
            m_call.NoticeBoard ( szText , szCaption );
        }

        void ReleasePet ( INT32 PetID )
        {
            m_call.ReleasePet ( PetID );
        }

        void ModifyRoomID ( INT32 NewRoomID )
        {
            m_call.ModifyRoomID ( NewRoomID );
        }

        void ModifyPlayModle ( INT32 nsize , PlayerModle NewPlayModle )
        {
            m_call.ModifyPlayModle ( nsize , NewPlayModle );
        }

        void EnterRandRoom ( )
        {
            m_call.EnterRandRoom ( );
        }

        void LeaveRoom ( )
        {
            m_call.LeaveRoom ( );
        }

        void LeaveGame ( )
        {
            m_call.LeaveGame ( );
        }

        void LeaveSelRoom ( )
        {
            m_call.LeaveSelRoom ( );
        }

        void QuitGame ( )
        {
            m_call.QuitGame ( );
        }

        void CarryPet ( INT32 PetID )
        {
            m_call.CarryPet ( PetID );
        }

        void ModifyColor ( INT32 nsize , TeamColor color )
        {
            m_call.ModifyColor ( nsize , color );
        }

        void ModifyChatRoomMap ( INT32 MapId )
        {
            m_call.ModifyChatRoomMap ( MapId );
        }

        //TODO:
        // 		void PlayerTransDoor ( NPCINDEX pdestIndex )
        // 		{
        // 			if ( m_pGameManager == NULL )
        // 			{
        // 				return;
        // 			}
        // 			PPlyaer lpPlayer = m_pGameManager->GetGameInfo ( )->GetPlayerList ( )->at ( pdestIndex );
        // 			CTRANSDOOR TRANSDOOR;
        // 			TRANSDOOR.m_GameTime = m_pGameManager->GetGameInfo ( )->GetGameTime ( );
        // 			TRANSDOOR.m_PlayerID = lpPlayer->GetIDFromServer ( );
        // 			TRANSDOOR.m_TranType = 0xa;
        // 			TRANSDOOR.TX = ( INT16 ) lpPlayer->GetNPCX ( );
        // 			TRANSDOOR.TY = ( INT16 ) lpPlayer->GetNPCY ( );
        // 			TRANSDOOR.RY = ( INT16 ) lpPlayer->GetNPCX ( );
        // 			TRANSDOOR.RX = ( INT16 ) lpPlayer->GetNPCY ( );
        // 			m_pMessageLayer->SetDataToClient ( GameID::P2P_TRANSDOOR, TRANSDOOR );
        // 			m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_TRANSDOOR, TRANSDOOR );
        // 
        // 		}
        // 		void PlayerMachineArtillery ()
        // 		{
        // 			if ( m_pGameManager == NULL )
        // 			{
        // 				return;
        // 			}
        // 			CMACHINEARTILLERY MACHINEARTILLERY;
        // 			MACHINEARTILLERY.m_GameTime = m_pGameManager->GetGameInfo ( )->GetGameTime ( );
        // 			MACHINEARTILLERY.m_PlayerID = m_pGameManager->GetGameInfo ( )->GetPlayerInfo ( )->GetArbitrator ( )->GetIDFromServer ( );
        // 			MACHINEARTILLERY.m_BombLength = 0xf;
        // 			MACHINEARTILLERY.m_BombType = 0xe;
        // 			MACHINEARTILLERY.m_BombSize = 0x1;
        // 			MACHINEARTILLERY.m_BombX = ( INT8 ) m_pGameManager->GetGameInfo ( )->GetPlayerInfo ( )->GetArbitrator ( )->GetPlayerInMapX ( );
        // 			MACHINEARTILLERY.m_BombY = ( INT8 ) m_pGameManager->GetGameInfo ( )->GetPlayerInfo ( )->GetArbitrator ( )->GetPlayerInMapY ( );
        // 			m_pMessageLayer->SetDataToClient ( GameID::P2P_MACHINEARTILLERY, MACHINEARTILLERY );
        // 			m_pGameManager->GetGameDispose ( )->GameDispose ( GameID::P2P_MACHINEARTILLERY, MACHINEARTILLERY );
        // 
        // 		}


 
    };
}

```

`QQTang CheatEngine/QQTangClient.hpp`:

```hpp
/************************************************************************/
/*
功能说明:全局类
创建人:Maple
创建日期:2014年9月1日
修改日期:
*/
/************************************************************************/
#pragma  once
#pragma  pack(1)
#include "Maple.hpp"
#define DefineOffset(OFFSETNAME,OFFSETVALUE) \
UINT32 OFFSETNAME = OFFSETVALUE;

#define InitOffset(OFFSETNAME,BASEADDRESS) \
OFFSETNAME = OFFSETNAME + (UINT32)BASEADDRESS;

#define UI_selRoom_chatArea_chatPanel_chatList "UI.selRoom.chatArea.chatPanel.chatList"
#define  UI_room_chatArea_chatPanel_chatList "UI.room.chatArea.chatPanel.chatList"
#define  UI_game_chatList "UI.game.chatList"
#define  UI_shop_refineDlg_AvatarForgeDlg_forgeInfo "UI.shop.refineDlg.AvatarForgeDlg.forgeInfo"
#define  UI_SysMsgbox "UI.SysMsgbox"
#define  UI_shop_refineDlg_composeDlg_composeInfo "UI.shop.refineDlg.composeDlg.composeInfo"

namespace QQTangCheatEngine
{
    class CQQTangClient
    {
    private:
        char szQQTangClientFullPath [ MAX_PATH ];
        char szQQTangClientPath [ MAX_PATH ];
    public:


        DefineOffset ( m_DisPlayAddress , OFFSET_DISPLAYADDRESS )

        DefineOffset ( m_ModuleBase , OFFSET_ADDRESS )

            DefineOffset ( m_MessageLayer , OFFSET_MESSAGELAYER )

            DefineOffset ( m_DataToServer , OFFSET_DATATOSETVER )

            DefineOffset ( m_DataToClient , OFFSET_DATATOCLIENT )

            DefineOffset ( m_GetTimeSub , OFFSET_GETTIMESUB )

            DefineOffset ( m_FindGameItem , OFFSET_FINDGAMEITEM )

            DefineOffset ( m_FindGameBomb , OFFSET_FINDGAMEBOMB )

            DefineOffset ( m_FindSculptureItem , OFFSET_FINDSCULPTUREITEM )

            DefineOffset ( m_GameDispose , OFFSET_GAMEDISPOSE )

            DefineOffset ( m_SendDataToPlayer , OFFSET_SENDDATATOPLAYER )

            DefineOffset ( m_CheckDataToServer , OFFSET_CHECKDATATOSERVER )

            DefineOffset ( m_GameUI , OFFSET_GAMEUI )

            DefineOffset ( m_Room , OFFSET_ROOM )

            DefineOffset ( m_CreateRoom , OFFSET_CREATEROOM )

            DefineOffset ( m_StartGame , OFFSET_STARTGAME )

            DefineOffset ( m_UseObject , OFFSET_USEOBJECT )

            DefineOffset ( m_SelRoomSpeak , OFFSET_SELROOMSPEAK )

            DefineOffset ( m_RoomSpeak , OFFSET_ROOMSPEAK )

            DefineOffset ( m_SetRoomMsg , OFFSET_SETROOMMSG )

            DefineOffset ( m_OperateDoor , OFFSET_OPERATEDOOR )

            DefineOffset ( m_SelMap , OFFSET_SELMAP )

            DefineOffset ( m_SelRoomType , OFFSET_SELROOMTYPE )

            DefineOffset ( m_EnterRoom , OFFSET_ENTERROOM )

            DefineOffset ( m_EnterSelRoom , OFFSET_ENTERSELROOM )

            DefineOffset ( m_MsgBox , OFFSET_MSGBOX )

            DefineOffset ( m_NoticeBoard , OFFSET_NOTICEBOARD )

            DefineOffset ( m_ReleasePet , OFFSET_RELEASEPET )

            DefineOffset ( m_ModifyRoomID , OFFSET_MODIFYROOMID )

            DefineOffset ( m_ModifyPlayModle , OFFSET_MODIFYPLAYMODLE )

            DefineOffset ( m_EnterRandRoom , OFFSET_ENTERRANDROOM )

            DefineOffset ( m_LeaveRoom , OFFSET_LEAVEROOM )

            DefineOffset ( m_LeaveGame , OFFSET_LEAVEGAME )

            DefineOffset ( m_LeaveSelRoom , OFFSET_LEAVESELROOM )

            DefineOffset ( m_QuitGame , OFFSET_QUITGAME )

            DefineOffset ( m_CarryPet , OFFSET_CARRYPET )

            DefineOffset ( m_StopCarryPet , OFFSET_STOPCARRYPET )

            DefineOffset ( m_ModifyColor , OFFSET_MODIFYPLAYERCOLOR )

            DefineOffset ( m_ModifyChatRoomMap , OFFSET_MODIFYCHATROOMMAP )

            CQQTangClient ( )
        {
            //完整路径

            GetModuleFileName ( NULL , szQQTangClientFullPath , MAX_PATH );
            strcpy ( szQQTangClientPath , szQQTangClientFullPath );
            strrchr ( szQQTangClientPath , '\\' ) [ 1 ] = '\0';
            //基址
            HMODULE hModule = GetClientHandle ( );
            //偏移
            InitOffset ( m_ModuleBase , hModule )

                InitOffset ( m_DisPlayAddress , hModule )

                InitOffset ( m_MessageLayer , hModule )

                InitOffset ( m_DataToServer , hModule )

                InitOffset ( m_DataToClient , hModule )

                InitOffset ( m_GetTimeSub , hModule )

                InitOffset ( m_FindGameItem , hModule )

                InitOffset ( m_FindGameBomb , hModule )

                InitOffset ( m_FindSculptureItem , hModule )

                InitOffset ( m_GameDispose , hModule )

                InitOffset ( m_SendDataToPlayer , hModule )

                InitOffset ( m_CheckDataToServer , hModule )

                InitOffset ( m_GameUI , hModule )

                InitOffset ( m_Room , hModule )

                InitOffset ( m_CreateRoom , hModule )

                InitOffset ( m_StartGame , hModule )

                InitOffset ( m_UseObject , hModule )

                InitOffset ( m_SelRoomSpeak , hModule )

                InitOffset ( m_RoomSpeak , hModule )

                InitOffset ( m_SetRoomMsg , hModule )

                InitOffset ( m_OperateDoor , hModule )

                InitOffset ( m_SelMap , hModule )

                InitOffset ( m_SelRoomType , hModule )

                InitOffset ( m_EnterRoom , hModule )

                InitOffset ( m_EnterSelRoom , hModule )

                InitOffset ( m_MsgBox , hModule )

                InitOffset ( m_NoticeBoard , hModule )

                InitOffset ( m_ReleasePet , hModule )

                InitOffset ( m_ModifyRoomID , hModule )

                InitOffset ( m_ModifyPlayModle , hModule )

                InitOffset ( m_EnterRandRoom , hModule )

                InitOffset ( m_LeaveRoom , hModule )

                InitOffset ( m_LeaveGame , hModule )

                InitOffset ( m_LeaveSelRoom , hModule )

                InitOffset ( m_QuitGame , hModule )

                InitOffset ( m_CarryPet , hModule )

                InitOffset ( m_StopCarryPet , hModule )

                InitOffset ( m_ModifyColor , hModule )

                InitOffset ( m_ModifyChatRoomMap , hModule )
        }

        void  CanOpenNext ( )
        {
            if ( szQQTangClientPath [ 0 ] == '\0' )
            {
                return;
            }
            char szFullPath [ MAX_PATH ];
            wsprintf ( szFullPath , "%s%s" , szQQTangClientPath , "update.cfg" );
            char szTimeInfo [ 16 ];
            wsprintf ( szTimeInfo , "%08X" , GetTickCount ( ) );
            if ( 0 == WritePrivateProfileString ( "public" , "app" , szTimeInfo , szFullPath ) )
            {
                return;
            }

            //查找所有的可能是QT的窗口
            while ( TRUE )
            {
                HWND hQQTang = FindWindow ( NULL , "qqtmydir" );
                if ( hQQTang == NULL )
                {
                    break;
                }
                //可能会堵塞
                SendMessage ( hQQTang , WM_SETTEXT , NULL , ( LPARAM ) szTimeInfo );
            }

            return;
        }

        static  void  DebugPrint ( const char* lpszFmt , ... )
        {
            char szOutPutText [ 2048 ];
            va_list args;
            va_start ( args , lpszFmt );
            wvsprintfA ( szOutPutText , ( LPCSTR ) lpszFmt , args );
            OutputDebugStringA ( szOutPutText );
            va_end ( args );
            return;
        }

        static  HMODULE GetClientHandle ( )
        {
            HMODULE hModule;
            _asm
            {
                mov	eax , dword ptr fs : [0x18];
                mov	eax , dword ptr ds : [eax + 0x30];
                mov	eax , dword ptr ds : [eax + 0x8];
                mov hModule , eax;
            }

            return hModule;
        }

        static  PINT8 Algorithm (
            _In_ const PINT8 lpKeyOfEncode ,
            _In_ BOOL IsEncode ,
            _Inout_ PINT8 lpItemOfEncode ,
            _In_ UINT32 ItemSizeof )
        {
            for ( UINT32 i = 0; i < ItemSizeof; i++ )
            {
                if ( IsEncode )
                {
                    lpItemOfEncode [ i ] ^= i;
                }
                lpItemOfEncode [ i ] ^= lpKeyOfEncode [ i % 4 ];
                if ( !IsEncode )
                {
                    lpItemOfEncode [ i ] ^= i;
                }
            }
            return lpItemOfEncode;
        }
    };


    enum MyEnum
    {
        CQQTangClientSize = sizeof ( CQQTangClient ) ,
    };
    CQQTangClient g_QQTangClient;
}
```

`QQTang CheatEngine/QQTangEnum.hpp`:

```hpp
/************************************************************************/
/*
功能说明:枚举常量 枚举名全部大写
创建人:maple
创建日期:2014年9月1日
修改人:VinDa
修改日期:2014年9月3日13:21:21
*/
/************************************************************************/
#pragma  once
#pragma  pack(1)

namespace QQTangCheatEngine
{

	//QQT 地址偏移 默认 0x400000 + 偏移
	enum  QQTangAddress
	{
		OFFSET_ADDRESS = 0,

		OFFSET_MESSAGELAYER = 0X00406A78,
		OFFSET_DATATOSETVER = 0X001A33C1,
		OFFSET_DATATOCLIENT = 0X001A2F4C,
		OFFSET_GETTIMESUB = 0X001A53DE,
		OFFSET_FINDGAMEITEM = 0X001D9B59,
		OFFSET_FINDGAMEBOMB = 0X001D3BD3,
		OFFSET_FINDSCULPTUREITEM = 0X001E3AFD,
		OFFSET_GAMEDISPOSE = 0X004C64AE,
        OFFSET_DISPLAYADDRESS = 0x01DD98F,
		OFFSET_SENDDATATOPLAYER = 0X0B7C01A,
		OFFSET_CHECKDATATOSERVER = 0X0B614B0,
		OFFSET_GAMEUI = 0x3FA410,

		OFFSET_MOUSEX = 0X045F284,
		OFFSET_MOUSEY = 0X045F288,
		OFFSET_ROOM = 0x045F7B8,
		OFFSET_CREATEROOM = 0X014E550,
		OFFSET_STARTGAME = 0x013C5C0,
		OFFSET_USEOBJECT = 0x0150080,
		OFFSET_SELROOMSPEAK = 0x08E5B0,
		OFFSET_ROOMSPEAK = 0x08E2E0,
		OFFSET_SETROOMMSG = 0x014E5C0,
		OFFSET_OPERATEDOOR = 0x013C340,
		OFFSET_SELMAP = 0x013C390,
		OFFSET_SELROOMTYPE = 0x08BCE0,
		OFFSET_ENTERROOM = 0x014DB90,
		OFFSET_ENTERSELROOM = 0x012D570,
		OFFSET_MSGBOX = 0x013205C,
		OFFSET_NOTICEBOARD = 0x08B6E0,
		OFFSET_RELEASEPET = 0x09994,
		OFFSET_CARRYPET = 0x012C7E,
		OFFSET_STOPCARRYPET = 0x0DF26,
		OFFSET_MODIFYROOMID = 0x013C6F0,
		OFFSET_MODIFYPLAYMODLE = 0x013C2F0,
		OFFSET_ENTERRANDROOM = 0x08EC90,
		OFFSET_LEAVEROOM = 0x0A371,
		OFFSET_LEAVEGAME = 0X05AE7,
		OFFSET_LEAVESELROOM = 0x01259E,
		OFFSET_QUITGAME = 0x08DB60,
		OFFSET_MODIFYPLAYERCOLOR = 0x013C2A0,
		OFFSET_MODIFYCHATROOMMAP = 0x013C580,

	};

	//游戏道具
	enum ItemByGame
	{
		//泡泡
		GAME_BOOM = 1,
		//威力
		GAME_POWER = 2,
		//速度
		GAME_SPEED = 3,
		//隐型泡泡
		GAME_PAOPAOYINGXING = 4,
		//问号
		GAME_WENHAO = 5,
		//泡泡全满
		GAME_BOOMFULL = 6,
		//威力全满
		GAME_POWERFULL = 7,
		//速度全满
		GAME_SPEEDFULL = 8,
		//电网
		GAME_DIANWANG = 21,
		//香蕉
		GAME_XIANGJIAO = 23,
		//叉子
		GAME_CHAZI = 24,
		//慢慢胶
		GAME_MANMANJIAO = 25,
		//氧气瓶
		GAME_YANGQIPING = 26,
		//飞标
		GAME_FEIBIAO = 27,
		//溜冰鞋
		GAME_LIUBINGXIE = 47,
		//透视镜
		GAME_TOUSHIJING = 61,
		//招财猫钱袋（机械里）
		GAME_ZHAOCAIMAO = 80,
		//铜币
		GAME_TONGBI = 81,
		//银币
		GAME_YINBI = 82,
		//金币
		GAME_JINBI = 83,
		//钱袋
		GAME_QIANDAI = 84,
		//1000TB宝箱
		GAME_BAOXIANG1000TB = 85,
		//20经验
		GAME_JINGYAN20 = 86,
		//50经验
		GAME_JINGYAN50 = 87,
		//100经验
		GAME_JINGYAN100 = 88,
		//200经验
		GAME_JINGYAN200 = 89,
		//红钻石(宝箱)
		GAME_HONGZUANSHI = 91,
		//蓝钻石(宝箱)
		GAME_LANZUANSHI = 92,
		//1000TB
		GAME_TANGBI1000 = 93,
		//500TB
		GAME_TANGBI500 = 94,
		//空宝箱
		GAME_KONGBAOXIANG = 95,
		//玫瑰
		GAME_MEIGUI1 = 96,
		//绿水晶
		GAME_LVSHUIJING = 97,
		//酷比
		GAME_KUBI = 98,
		//幽灵
		GAME_YOULING = 101,
		//咕咕鸟
		GAME_GUGUNIAO = 104,
		//疾风
		GAME_JIFENG = 107,
		//糖果王
		GAME_TANGGUOWANG = 108,
		//熊猫宝宝
		GAME_XIONGMAOBAOBAO = 109,
		//小魔鬼
		GAME_XIAOMOGUI = 110,
		//大螃蟹
		GAME_DAPANGXIE = 114,
		//斧头帮主
		GAME_FUTOUBANGZHU = 115,
		//乌龟
		GAME_WUGUI = 116,
		//爱心
		GAME_AIXIN = 117,
		//叉子(糖果战)
		GAME_TANGGUOCHAZI = 119,
		//盾牌(糖果战)
		GAME_TANGGUODUNPAI = 120,
		//红宝石(夺宝)
		GAME_HONGBAOSHI = 150,
		//黄宝石(夺宝)
		GAME_HUANGBAOSHI = 151,
		//绿宝石(夺宝)
		GAME_LVBAOSHI = 152,
		//英雄石头1
		GAME_STONE1 = 160,
		//英雄石头2
		GAME_STONE2 = 161,
		//英雄石头3
		GAME_STONE3 = 162,
		//英雄石头4
		GAME_STONE4 = 163,
		//英雄石头5
		GAME_STONE5 = 164,
		//英雄石头6
		GAME_STONE6 = 165,
		//铁板(机械里)
		GAME_JIXIETIEBAN = 201,
		//冰块
		GAME_BINGKUAI = 203,
		//沼泽
		GAME_ZHAOZE = 204,
		//紫钻石(宝箱)
		GAME_ZIZUANSHI = 211,
		//血瓶子
		GAME_XUEPINGZI = 212,
		//黄螺丝
		GAME_HUANGLUOSI = 213,
		//玫瑰
		GAME_MEIGUI2 = 402,
		//日记
		GAME_DIARY = 403,
		//红色炸弹(推箱子)
		GAME_HONGSEZHADAN = 801,
		//随机物品(推箱子)
		GAME_UNKNOW1 = 802,
		//随机物品(推箱子)
		GAME_UNKNOW2 = 807,
		// 		//电网
		// 		GAME_DIANWANG = 41,
		//香蕉
		// 		GAME_XIANGJIAO = 42,
		// 		//慢慢胶
		// 		GAME_MANMANJIAO = 43,
		//飞镖
		// 		GAME_FEIBIAO = 44,
		//斧头
		// 		GAME_FUTOU = 46,
		//冲天炮
		// 		GAME_CHONGTIANPAO = 48,
		//红色炸弹
		// 		GAME_HONGSEZHADAN = 49,
		//氧气瓶
		// 		GAME_YANGQIPING = 62,
		//叉子
		// 		GAME_CHAZI = 63,
		//定时器
		// 		GAME_DINGSHIQI = 64,
		//英雄石头
		// 		GAME_STONE = 66,
		//乌龟
		// 		GAME_WUGUI = 118,
		//咕咕鸟
		// 		GAME_GUGUNIAO = 41,
		//小魔鬼
		// 		GAME_XIAOMOGUI = 42,
		//幽灵
		// 		GAME_YOULING = 43,
		//熊猫宝宝
		// 		GAME_XIONGMAOBAOBAO = 44,
		//疾风
		// 		GAME_JIFENG = 45,
		// 		//糖果王
		// 		GAME_TANGGUOWANG = 46,
		// 		//大螃蟹
		// 		GAME_DAPANGXIE = 54,
		//斧头帮主
		// 		GAME_FUTOUBANGZHU = 55,
		//乌龟
		// 		GAME_WUGUI = 58,
		//超级火焰药水
		GAME_CHAOJIHUOYANYAOSHUI = 20003,
		//超级糖浆
		GAME_CHAOJITANGJIANG = 20006,
		//透明泡泡药水
		GAME_TOUMINGPAOPAOYAOSHUI = 20007,
		//冲刺药水
		GAME_CHONGCIYAOSHUI = 20019,
		//万能药剂
		GAME_WANNENGYAOJI = 20020,
		//超强的泻药
		GAME_CHAOQIANGDEXIEYAO = 20027,
		//嘲笑药水
		GAME_CHAOXIAOYAOSHUI = 20028,
		//小体力药水
		GAME_XIAOTILIYAOSHUI = 20044,
		//中体力药水
		GAME_ZHONGTILIYAOSHUI = 20045,
		//大体力药水
		GAME_DATILIYAOSHUI = 20043,
		//无敌药剂
		GAME_WUDIYAOJI = 20047,
		//火焰抵抗药剂
		GAME_HUOYANDIKANGYAOJI = 20035,
		//寒冰抵抗药剂
		HANBINGDIKANGYAOJI = 20033,
		//闪电抵抗药剂
		GAME_SHANDIANDIKANGYAOJI = 20042,
		//解毒药
		GAME_JIEDUYAO = 20037,
		//力量药水
		GAME_LILIANGYAOSHUI = 20039,
		//消失药水
		GAME_XIAOSHIYAOSHUI = 20049,
		//玫瑰药水
		GAME_MEIGUIYAOSHUI = 20040,
		//过期的牛奶
		GAME_GUOQIDENIUNAI = 20032,
		//眩晕陷阱
		GAME_XUANYUNXIANJING = 20008,
		//减速陷阱
		GAME_JIANSUXIANJING = 20009,
		//反向陷阱
		GAME_FANXIANGXIANJING = 20010,
		//爆炸陷阱
		GAME_BAOZHAXIANJING = 20018,
		//攻击陷阱
		GAME_GONGJIXIANJING = 20031,
		//力量护符
		GAME_LILIANGHUFU = 20011,
		//急速护符
		GAME_JISUHUFU = 20012,
		//穿墙护符
		GAME_CHUANQIANGHUFU = 20013,
		//探测护符
		GAME_TANCEHUFU = 20014,
		//生命护符
		GAME_SHENGMINGHUFU = 20026,
		//抵御护符
		GAME_DIYUHUFU = 20021,
		//恶魔卷轴
		GAME_EMOJUANZHOU = 20015,
		//恐怖卷轴
		GAME_KONGBUJUANZHOU = 20016,
		//冰冻卷轴
		GAME_BINGDONGJUANZHOU = 20017,
		//变身卷轴
		GAME_BIANSHENJUANZHOU = 20025,
		//电动钻头
		GAME_DIANDONGZUANTOU = 20023,
		//叉子
		GAME_PVECHAZI = 20022,
		//飞镖
		GAME_PVEFEIBIAO = 20024,
		//急救包
		GAME_JIJIUBAO = 20036,
		//医疗包
		GAME_YILIAOBAO = 20050,
		//盖亚之种
		GAME_GAIYAZHIZHONG = 20030,
		//酷比的力量
		GAME_KUBIDELILIANG = 20038,
		//无限的糖浆
		GAME_WUXIANDETANGJIANG = 20048,
		//黑萎草
		GAME_HEIWEICAO = 20034,
		//赤水晶
		GAME_CHISHUIJING = 20051,
		//橙水晶
		GAME_CHENGSHUIJING = 20052,
		//黄水晶
		GAME_HUANGSHUIJING = 20053,
		//绿水晶
		GAME_LUSHUIJING = 20054,
		//青水晶
		GAME_QINGSHUIJING = 20055,
		//蓝水晶
		GAME_LANSHUIJING = 20056,
		//紫水晶
		GAME_ZISHUIJING = 20057,
		//糖币加加1级
		GAME_TANGBIJIAJIA1JI = 27001,
		//糖币加加2级
		GAME_TANGBIJIAJIA2JI = 27002,
		//糖币加加3级
		GAME_TANGBIJIAJIA3JI = 27003,
		//糖币加加4级
		GAME_TANGBIJIAJIA4JI = 27004,
		//糖币加加5级
		GAME_TANGBIJIAJIA5JI = 27005,
		//糖币加加6级
		GAME_TANGBIJIAJIA6JI = 27006,
		//糖币加加7级
		GAME_TANGBIJIAJIA7JI = 27007,
		//糖币加加8级
		GAME_TANGBIJIAJIA8JI = 27008,
		//糖币加加9级
		GAME_TANGBIJIAJIA9JI = 27009,
		//糖币加加10级
		GAME_TANGBIJIAJIA10JI = 27010,
		//勇气加加1级
		GAME_YONGQIJIAJIA1JI = 27011,
		//勇气加加2级
		GAME_YONGQIJIAJIA2JI = 27012,
		//勇气加加3级
		GAME_YONGQIJIAJIA3JI = 27013,
		//勇气加加4级
		GAME_YONGQIJIAJIA4JI = 27014,
		//勇气加加5级
		GAME_YONGQIJIAJIA5JI = 27015,
		//勇气加加6级
		GAME_YONGQIJIAJIA6JI = 27016,
		//勇气加加7级
		GAME_YONGQIJIAJIA7JI = 27017,
		//勇气加加8级
		GAME_YONGQIJIAJIA8JI = 27018,
		//勇气加加9级
		GAME_YONGQIJIAJIA9JI = 27019,
		//勇气加加10级
		GAME_YONGQIJIAJIA10JI = 27020,
		//积分加加1级
		GAME_JIFENJIAJIA1JI = 27021,
		//积分加加2级
		GAME_JIFENJIAJIA2JI = 27022,
		//积分加加3级
		GAME_JIFENJIAJIA3JI = 27023,
		//积分加加4级
		GAME_JIFENJIAJIA4JI = 27024,
		//积分加加5级
		GAME_JIFENJIAJIA5JI = 27025,
		//积分加加6级
		GAME_JIFENJIAJIA6JI = 27026,
		//积分加加7级
		GAME_JIFENJIAJIA7JI = 27027,
		//积分加加8级
		GAME_JIFENJIAJIA8JI = 27028,
		//积分加加9级
		GAME_JIFENJIAJIA9JI = 27029,
		//积分加加10级
		GAME_JIFENJIAJIA10JI = 27030,
		//声望加加1级
		GAME_SHENGWANGJIAJIA1JI = 27031,
		//声望加加2级
		GAME_SHENGWANGJIAJIA2JI = 27032,
		//声望加加3级
		GAME_SHENGWANGJIAJIA3JI = 27033,
		//声望加加4级
		GAME_SHENGWANGJIAJIA4JI = 27034,
		//声望加加5级
		GAME_SHENGWANGJIAJIA5JI = 27035,
		//声望加加6级
		GAME_SHENGWANGJIAJIA6JI = 27036,
		//声望加加7级
		GAME_SHENGWANGJIAJIA7JI = 27037,
		//声望加加8级
		GAME_SHENGWANGJIAJIA8JI = 27038,
		//声望加加9级
		GAME_SHENGWANGJIAJIA9JI = 27039,
		//声望加加10级
		GAME_SHENGWANGJIAJIA10JI = 27040,
		//材料多多1级
		GAME_CAILIAODUODUO1JI = 27041,
		//材料多多2级
		GAME_CAILIAODUODUO2JI = 27042,
		//材料多多3级
		GAME_CAILIAODUODUO3JI = 27041,
		//材料多多4级
		GAME_CAILIAODUODUO4JI = 27044,
		//材料多多5级
		GAME_CAILIAODUODUO5JI = 27045,
		//材料多多6级
		GAME_CAILIAODUODUO6JI = 27046,
		//材料多多7级
		GAME_CAILIAODUODUO7JI = 27047,
		//材料多多8级
		GAME_CAILIAODUODUO8JI = 27048,
		//材料多多9级
		GAME_CAILIAODUODUO9JI = 27049,
		//材料多多10级
		GAME_CAILIAODUODUO10JI = 27050,
		//积分多多1级
		GAME_JIFENDUODUO1JI = 27051,
		//积分多多2级
		GAME_JIFENDUODUO2JI = 27052,
		//积分多多3级
		GAME_JIFENDUODUO3JI = 27053,
		//积分多多4级
		GAME_JIFENDUODUO4JI = 27054,
		//积分多多5级
		GAME_JIFENDUODUO5JI = 27055,
		//积分多多6级
		GAME_JIFENDUODUO6JI = 27056,
		//积分多多7级
		GAME_JIFENDUODUO7JI = 27057,
		//积分多多8级
		GAME_JIFENDUODUO8JI = 27058,
		//积分多多9级
		GAME_JIFENDUODUO9JI = 27059,
		//积分多多10级
		GAME_JIFENDUODUO10JI = 27060,
		//体力药水
		GAME_TILIYAOSHUI = 26001,
		//宠物粮食小
		GAME_CHONGWULIANGSHIXIAO = 26002,
		//宠物粮食中
		GAME_CHONGWULIANGSHIZHONG = 26003,
		//宠物粮食大
		GAME_CHONGWULIANGSHIDA = 26004,
		//心情棒棒糖小
		GAME_XINQINGBANGBANGTANGXIAO = 26005,
		//心情棒棒糖中
		GAME_XINQINGBANGBANGTANGZHONG = 26006,
		//心情棒棒糖大
		GAME_XINQINGBANGBANGTANGDA = 26007,
		//花生仁巧克力
		GAME_HUASHENGRENQIAOKELI = 26008,
		//松子仁巧克力
		GAME_SONGZIRENQIAOKELI = 26009,
		//榛子仁巧克力
		GAME_ZHENZIRENQIAOKELI = 26010,
		//普通的酷比
		GAME_PUTONGDEKUBI = 28001,
		//富有的酷比
		GAME_FUYOUDEKUBI = 28002,
		//尊崇的酷比
		GAME_ZUNCHONGDEKUBI = 28003,
		//普通的米多
		GAME_PUTONGDEMIDUO = 28004,
		//勇敢的米多
		GAME_YONGGANDEMIDUO = 28005,
		//勤劳的米多
		GAME_QINLAODEMIDUO = 28006,
		//普通的猪
		GAME_PUTONGDEZHU = 28007,
		//布鲁斯
		GAME_BULUSI = 28008,
		//普通的恶魔
		GAME_PUTONGDEEMO = 28009,
		//显赫的恶魔
		GAME_XIANHEDEEMO = 28010,
		//幸运的恶魔
		GAME_XINGYUNDEEMO = 28011,
		//琪琪
		GAME_QIQI = 28012,
		//恩佐
		GAME_ENZUO = 28013,
		//绿色结婚礼花
		GAME_LUSEJIEHUNLIHUA = 20062,
		//心型结婚礼花
		GAME_XINXINGJIEHUNLIHUA = 20063,
		//QQ堂礼花
		GAME_QQTANGLIHUA = 20064,
		//单人探险卡
		GAME_DANRENTANXIANKA = 99,
		//防踢卡
		GAME_FANGTIKA = 100,
		//复活卡
		GAME_FUHUOKA = 20100,
		//大复活卡
		GAME_DAFUHUOKA = 20101,
		//红色结婚礼花
		GAME_HONGSEJIEHUNLIHUA = 20058,
		//蓝色结婚礼花
		GAME_LANSEJIEHUNLIHUA = 20059,
		//紫色结婚礼花
		GAME_ZISEJIEHUNLIHUA = 20060,
		//黄色结婚礼花
		GAME_HUANGSEJIEHUNLIHUA = 20061,
		//爱情酷比
		GAME_AIQINGKUBI = 28014,
		//爱情米多
		GAME_AIQINGMIDUO = 28015,
		//黑暗火焰精灵
		GAME_HEIANHUOYANJINGLING = 28016,
		//光明火焰精灵
		GAME_GUANGMINGHUOYANJINGLING = 28017,
		//小菜娃
		GAME_XIAOCAIWA = 28018,
		//透明的瓶子
		GAME_TOUMINGDEPINGZI = 30001,
		//煮药的罐子
		GAME_ZHUYAODEGUANZI = 30002,
		//大容量的瓶子
		GAME_DARONGLIANGDEPINGZI = 30003,
		//封印瓶
		GAME_FENGYINPING = 30004,
		//空瓶5
		GAME_KONGPING = 30005,
		//潘多拉魔瓶
		GAME_PANDUOLAMOPING = 30006,
		//草药
		GAME_CAOYAO = 30007,
		//珍贵的草药
		GAME_ZHENGUIDECAOYAO = 30008,
		//奇怪的草药
		GAME_QIGUAIDECAOYAO = 30009,
		//毒草药
		GAME_DUCAOYAO = 30010,
		//黑萎草叶子
		GAME_HEIWEICAOYEZI = 30011,
		//药草6
		GAME_YAOCAO = 30012,
		//未成熟的蔬菜
		GAME_WEICHENGSHUDESHUCAI = 30013,
		//成熟的蔬菜
		GAME_CHENGSHUDESHUCAI = 30014,
		//巨大的蔬菜
		GAME_JUDADESHUCAI = 30015,
		//美味的蔬菜
		GAME_MEIWEIDESHUCAI = 30016,
		//蔬菜5
		GAME_SHUCAI5 = 30017,
		//蔬菜6
		GAME_SHUCAI6 = 30018,
		//小珍珠
		GAME_XIAOZHENZHU = 30031,
		//大珍珠
		GAME_DAZHENZHU = 30032,
		//发光的珍珠
		GAME_FAGUANGDEZHENZHU = 30033,
		//怪物的内核
		GAME_GUAIWUDENEIHE = 30034,
		//夜光珠
		GAME_YEGUANGZHU = 30035,
		//珍珠6
		GAME_ZHENZHU = 30036,
		//羽毛1
		GAME_YUMAO1 = 30037,
		//掉落的羽毛
		GAME_DIAOLUODEYUMAO = 30038,
		//羽毛3
		GAME_YUMAO3 = 30039,
		//好看的羽毛
		GAME_HAOKANDEYUMAO = 30040,
		//凤凰的羽毛
		GAME_FENGHUANGDEYUMAO = 30041,
		//羽毛6
		GAME_YUMAO6 = 30042,
		//小碎屑
		GAME_XIAOSUIXIE = 30043,
		//冰沫
		GAME_BINGMO = 30044,
		//散落的灰尘
		GAME_SANLUODEHUICHEN = 30045,
		//矿石粉沫
		GAME_KUANGSHIFENMO = 30046,
		//火药粉沫
		GAME_HUOYAOFENMO = 30047,
		//粉末6
		GAME_FENMO = 30048,
		//木材1
		GAME_MUCAI = 30049,
		//湿木头
		GAME_SHIMUTOU = 30050,
		//大树枝
		GAME_DASHUZHI = 30051,
		//坚硬的木头
		GAME_JIANYINGDEMUTOU = 30052,
		//木材5
		GAME_MUCAI5 = 30053,
		//木材6
		GAME_MUCAI6 = 30054,
		//金属1
		GAME_JINSHU1 = 30055,
		//铁矿石
		GAME_TIEKUANGSHI = 30056,
		//银矿石
		GAME_YINKUANGSHI = 30057,
		//金矿石
		GAME_JINKUANGSHI = 30058,
		//珍惜矿石
		GAME_ZHENXIKUANGSHI = 30059,
		//金属6
		GAME_JINSHU6 = 30060,
		//果实1
		GAME_GUOSHI1 = 30061,
		//果实2
		GAME_GUOSHI2 = 30062,
		//果实3
		GAME_GUOSHI3 = 30063,
		//神奇果实
		GAME_SHENQIGUOSHI = 30064,
		//恶魔的果实
		GAME_EMODEGUOSHI = 30065,
		//果实6
		GAME_GUOSHI6 = 30066,
		//魔法元素1
		GAME_MOFAYUANSU1 = 30067,
		//魔法元素2
		GAME_MOFAYUANSU2 = 30068,
		//魔法碎屑
		GAME_MOFASUIXIE = 30069,
		//魔法碎片
		GAME_MOFASUIPIAN = 30070,
		//魔法元素
		GAME_MOFAYUANSU = 30071,
		//魔法元素6
		GAME_MOFAYUANSU6 = 30072,
		//纸张1
		GAME_ZHIZHANG1 = 30073,
		//纸张2
		GAME_ZHIZHANG2 = 30074,
		//纸张3
		GAME_ZHIZHANG3 = 30075,
		//手纸
		GAME_SHOUZHI = 30076,
		//硬纸板
		GAME_YINGZHIBAN = 30077,
		//纸张6
		GAME_ZHIZHANG6 = 30078,
		//刀具1
		GAME_DAOJU1 = 30079,
		//刀具2
		GAME_DAOJU2 = 30080,
		//水果刀
		GAME_SHUIGUODAO = 30081,
		//锋利的小刀
		GAME_FENGLIDEXIAODAO = 30082,
		//狩猎刀
		GAME_SHOULIEDAO = 30083,
		//刀具6
		GAME_DAOJU6 = 30084,
		//宝石1
		GAME_BAOSHI1 = 30085,
		//宝石2
		GAME_BAOSHI2 = 30086,
		//宝石3
		GAME_BAOSHI3 = 30087,
		//宝石4
		GAME_BAOSHI4 = 30088,
		//宝石5
		GAME_BAOSHI5 = 30089,
		//宝石6
		GAME_BAOSHI6 = 30090,
		//干净的雨水
		GAME_GANJINGDEYUSHUI = 30091,
		//纯净水
		GAME_CHUNJINGSHUI = 30092,
		//植物的汁液
		GAME_ZHIWUDEZHIYE = 30093,
		//融化的雪水
		GAME_RONGHUADEXUESHUI = 30094,
		//神秘水
		GAME_SHENMISHUI = 30095,
		//水珠6
		GAME_SHUIZHU6 = 30096,
		//变异水晶
		GAME_BIANYISHUIJING = 30097,
		//超级火焰药水合成书
		GAME_CHAOJIHUOYANYAOSHUIHECHENGSHU = 24003,
		//超级糖浆合成书
		GAME_CHAOJITANGJIANGHECHENGSHU = 24006,
		//透明泡泡药水合成书
		GAME_TOUMINGPAOPAOYAOSHUIHECHENGSHU = 24007,
		//冲刺药水合成书
		GAME_CHONGCIYAOSHUIHECHENGSHU = 24019,
		//万能药剂合成书
		GAME_WANNENGYAOJIHECHENGSHU = 24020,
		//超强的泻药合成书
		GAME_CHAOQIANGDEXIEYAOHECHENGSHU = 24027,
		//嘲笑药水合成书
		GAME_CHAOXIAOYAOSHUIHECHENGSHU = 24028,
		//小体力药水合成书
		GAME_XIAOTILIYAOSHUIHECHENGSHU = 24044,
		//中体力药水合成书
		GAME_ZHONGTILIYAOSHUIHECHENGSHU = 24045,
		//大体力药水合成书
		GAME_DATILIYAOSHUIHECHENGSHU = 24043,
		//无敌药剂合成书
		GAME_WUDIYAOJIHECHENGSHU = 24047,
		//火焰抵抗药剂合成书
		GAME_HUOYANDIKANGYAOJIHECHENGSHU = 24035,
		//寒冰抵抗药剂合成书
		GAME_HANBINGDIKANGYAOJIHECHENGSHU = 24033,
		//闪电抵抗药剂合成书
		GAME_SHANDIANDIKANGYAOJIHECHENGSHU = 24042,
		//解毒药合成书
		GAME_JIEDUYAOHECHENGSHU = 24037,
		//力量药水合成书
		GAME_LILIANGYAOSHUIHECHENGSHU = 24039,
		//消失药水合成书
		GAME_XIAOSHIYAOSHUIHECHENGSHU = 24049,
		//玫瑰药水合成书
		GAME_MEIGUIYAOSHUIHECHENGSHU = 24040,
		//过期的牛奶合成书
		GAME_GUOQIDENIUNAIHECHENGSHU = 24032,
		//眩晕陷阱合成书
		GAME_XUANYUNXIANJINGHECHENGSHU = 24008,
		//减速陷阱合成书
		GAME_JIANSUXIANJINGHECHENGSHU = 24009,
		//反向陷阱合成书
		GAME_FANXIANGXIANJINGHECHENGSHU = 24010,
		//爆炸陷阱合成书
		GAME_BAOZHAXIANJINGHECHENGSHU = 24018,
		//攻击陷阱合成书
		GAME_GONGJIXIANJINGHECHENGSHU = 24031,
		//力量护符合成书
		GAME_LILIANGHUFUHECHENGSHU = 24011,
		//急速护符合成书
		GAME_JISUHUFUHECHENGSHU = 24012,
		//穿墙护符合成书
		GAME_CHUANQIANGHUFUHECHENGSHU = 24013,
		//探测护符合成书
		GAME_TANCEHUFUHECHENGSHU = 24014,
		//生命护符合成书
		GAME_SHENGMINGHUFUHECHENGSHU = 24026,
		//抵御护符合成书
		GAME_DIYUHUFUHECHENGSHU = 24021,
		//恶魔卷轴合成书
		GAME_EMOJUANZHOUHECHENGSHU = 24015,
		//恐怖卷轴合成书
		GAME_KONGBUJUANZHOUHECHENGSHU = 24016,
		//冰冻卷轴合成书
		GAME_BINGDONGJUANZHOUHECHENGSHU = 24017,
		//变身卷轴合成书
		GAME_BIANSHENJUANZHOUHECHENGSHU = 24025,
		//电动钻头合成书
		GAME_DIANDONGZUANTOUHECHENGSHU = 24023,
		//叉子合成书
		GAME_CHAZIHECHENGSHU = 24022,
		//飞镖合成书
		GAME_FEIBIAOHECHENGSHU = 24024,
		//急救包合成书
		GAME_JIJIUBAOHECHENGSHU = 24036,
		//医疗包合成书
		GAME_YILIAOBAOHECHENGSHU = 24050,
		//盖亚之种合成书
		GAME_GAIYAZHIZHONGHECHENGSHU = 24030,
		//酷比的力量合成书
		GAME_KUBIDELILIANGHECHENGSHU = 24038,
		//无限的糖浆合成书
		GAME_WUXIANDETANGJIANGHECHENGSHU = 24048,
		//黑萎草合成书
		GAME_HEIWEICAOHECHENGSHU = 24034,
		//赤水晶合成书
		GAME_CHISHUIJINGHECHENGSHU = 24051,
		//橙水晶合成书
		GAME_CHENGSHUIJINGHECHENGSHU = 24052,
		//黄水晶合成书
		GAME_HUANGSHUIJINGHECHENGSHU = 24053,
		//绿水晶合成书
		GAME_LUSHUIJINGHECHENGSHU = 24054,
		//青水晶合成书
		GAME_QINGSHUIJINGHECHENGSHU = 24055,
		//蓝水晶合成书
		GAME_LANSHUIJINGHECHENGSHU = 24056,
		//紫水晶合成书
		GAME_ZISHUIJINGHECHENGSHU = 24057,
		//红色礼花合成书
		GAME_HONGSELIHUAHECHENGSHU = 24058,
		//蓝色礼花合成书
		GAME_LANSELIHUAHECHENGSHU = 24059,
		//紫色礼花合成书
		GAME_ZISELIHUAHECHENGSHU = 24060,
		//黄色礼花合成书
		GAME_HUANGSELIHUAHECHENGSHU = 24061,
		//绿色礼花合成书
		GAME_LUSELIHUAHECHENGSHU = 24062,
		//心型礼花合成书
		GAME_XINXINGLIHUAHECHENGSHU = 24063,
		//QQ堂礼花合成书
		GAME_QQTANGLIHUAHECHENGSHU = 24064





	};

	//获取的道具 名称中文拼音
	enum ItemByGet
	{
		//泡泡
		GET_BOOM = 1,
		//威力
		GET_POWER = 2,
		//速度
		GET_SPEED = 3,
		//隐型泡泡
		GET_PAOPAOYINGXING = 4,
		//问号
		GET_WENHAO = 5,
		//泡泡全满
		GET_BOOMFULL = 6,
		//威力全满
		GET_POWERFULL = 7,
		//速度全满
		GET_SPEEDFULL = 8,
		//电网
		GET_DIANWANG = 21,
		//香蕉
		GET_XIANGJIAO = 23,
		//叉子
		GET_CHAZI = 24,
		//慢慢胶
		GET_MANMANJIAO = 25,
		//氧气瓶
		GET_YANGQIPING = 26,
		//飞标
		GET_FEIBIAO = 27,
		//溜冰鞋
		GET_LIUBINGXIE = 47,
		//透视镜
		GET_TOUSHIJING = 61,
		//招财猫钱袋（机械里）
		GET_ZHAOCAIMAO = 80,
		//铜币
		GET_TONGBI = 81,
		//银币
		GET_YINBI = 82,
		//金币
		GET_JINBI = 83,
		//钱袋
		GET_QIANDAI = 84,
		//1000TB宝箱
		GET_BAOXIANG1000TB = 85,
		//20经验
		GET_JINGYAN20 = 86,
		//50经验
		GET_JINGYAN50 = 87,
		//100经验
		GET_JINGYAN100 = 88,
		//200经验
		GET_JINGYAN200 = 89,
		//红钻石(宝箱)
		GET_HONGZUANSHI = 91,
		//蓝钻石(宝箱)
		GET_LANZUANSHI = 92,
		//1000TB
		GET_TANGBI1000 = 93,
		//500TB
		GET_TANGBI500 = 94,
		//空宝箱
		GET_KONGBAOXIANG = 95,
		//玫瑰
		GET_MEIGUI1 = 96,
		//绿水晶
		GET_LVSHUIJING = 97,
		//酷比
		GET_KUBI = 98,
		//幽灵
		GET_YOULING = 101,
		//咕咕鸟
		GET_GUGUNIAO = 104,
		//疾风
		GET_JIFENG = 107,
		//糖果王
		GET_TANGGUOWANG = 108,
		//熊猫宝宝
		GET_XIONGMAOBAOBAO = 109,
		//小魔鬼
		GET_XIAOMOGUI = 110,
		//大螃蟹
		GET_DAPANGXIE = 114,
		//斧头帮主
		GET_FUTOUBANGZHU = 115,
		//乌龟
		GET_WUGUI = 116,
		//爱心
		GET_AIXIN = 117,
		//叉子(糖果战)
		GET_TANGGUOCHAZI = 119,
		//盾牌(糖果战)
		GET_TANGGUODUNPAI = 120,
		//红宝石(夺宝)
		GET_HONGBAOSHI = 150,
		//黄宝石(夺宝)
		GET_HUANGBAOSHI = 151,
		//绿宝石(夺宝)
		GET_LVBAOSHI = 152,
		//英雄石头1
		GET_STONE1 = 160,
		//英雄石头2
		GET_STONE2 = 161,
		//英雄石头3
		GET_STONE3 = 162,
		//英雄石头4
		GET_STONE4 = 163,
		//英雄石头5
		GET_STONE5 = 164,
		//英雄石头6
		GET_STONE6 = 165,
		//铁板(机械里)
		GET_JIXIETIEBAN = 201,
		//冰块
		GET_BINGKUAI = 203,
		//沼泽
		GET_ZHAOZE = 204,
		//紫钻石(宝箱)
		GET_ZIZUANSHI = 211,
		//血瓶子
		GET_XUEPINGZI = 212,
		//黄螺丝
		GET_HUANGLUOSI = 213,
		//玫瑰
		GET_MEIGUI2 = 402,
		//红色炸弹(推箱子)
		GET_HONGSEZHADAN = 801,
		//随机物品(推箱子)
		GET_UNKNOW1 = 802,
		//随机物品(推箱子)
		GET_UNKNOW2 = 807,



	};

	//使用的道具 名称中文拼音
	enum ItemBySet
	{
		//电网
		SET_DIANWANG = 41,
		//香蕉
		SET_XIANGJIAO = 42,
		//慢慢胶
		SET_MANMANJIAO = 43,
		//飞镖
		SET_FEIBIAO = 44,
		//斧头
		SET_FUTOU = 46,
		//冲天炮
		SET_CHONGTIANPAO = 48,
		//红色炸弹
		SET_HONGSEZHADAN = 49,
		//氧气瓶
		SET_YANGQIPING = 62,
		//叉子
		SET_CHAZI = 63,
		//定时器
		SET_DINGSHIQI = 64,
		//英雄石头
		SET_STONE = 66,
		//乌龟
		SET_WUGUI = 118,
	};

	//变身 名称中文拼音
	enum ItemByAvatar
	{
		//咕咕鸟
		AVATAR_GUGUNIAO = 41,
		//小魔鬼
		AVATAR_XIAOMOGUI = 42,
		//幽灵
		AVATAR_YOULING = 43,
		//熊猫宝宝
		AVATAR_XIONGMAOBAOBAO = 44,
		//疾风
		AVATAR_JIFENG = 45,
		//糖果王
		AVATAR_TANGGUOWANG = 46,
		//大螃蟹
		AVATAR_DAPANGXIE = 54,
		//斧头帮主
		AVATAR_FUTOUBANGZHU = 55,
		//乌龟
		AVATAR_WUGUI = 58
	};

	//团队颜色
	enum TeamColor
	{
		//红色
		COLOR_RED = 1,
		//蓝色
		COLOR_BLUE = 2,
		//黄色
		COLOR_YELLOW = 3,
		//绿色
		COLOR_GREEN = 4,
		//粉红
		COLOR_PEACH = 5,
		//橙色
		COLOR_ORANGE = 6,
		//紫色
		COLOR_PURPLE = 7,
		//灰色
		COLOR_ASHY = 8,
	};

	//玩家状态
	enum PlayerStatus
	{
		//默认
		STATUS_NORMAL = 1,
		//进泡
		STATUS_LAYINBOMB = 3,
		//屎亡
		STATUS_DIE = 4,
		//胜利
		STATUS_WIN = 6,
		//退出
		STATUS_EXIT = 8,
		//石化
		STATUS_PETRIFACT = 10
	};

	//UI类型
	enum UIModle
	{
		//登陆界面
		UI_LOGIN = 0,
		//小区界面
		UI_SELSECT = 1,
		//大厅界面
		UI_SELROOM = 2,
		//房间界面
		UI_ROOM = 3,
		//网页界面?
		UI_WEB = 4,
		//游戏界面
		UI_GAME = 5,
		//练习场界面
		UI_PRACTICE = 6,
		//商店界面
		UI_SHOP = 7
	};

	//玩家模型 中文拼音
	enum PlayerModle
	{
		//悟空   
		MODLE_WUKONG = 1,
		//泰坦    
		MODLE_TAITAN = 2,
		//小倩    
		MODLE_XIAOQIAN = 3,
		//春丽   
		MODLE_CHUNLI = 4,
		//波波丽  
		MODLE_BOBOLI = 5,
		//火影
		MODLE_HUOYING = 6,
		//玛丽亚  
		MODLE_MALIYA = 7,
		//海王子
		MODLE_HAIWANGZI = 8,
		//毛毛
		MODLE_MAOMAO = 9,
		//包子
		MODLE_BAOZI = 10,
		//斧头小子
		MODLE_FUTOUXIAOZI = 11,
		//菜包子
		MODLE_CAIBAOZI = 12,
		//可乐
		MODLE_KELE = 13,
		//哪吒
		MODLE_NAZHA = 14,
		//乌拉拉
		MODLE_WULALA = 15,
		//丫丫
		MODLE_YAYA = 16,
		//伊丹
		MODLE_YIDAN = 17,
		//克莉斯
		MODLE_KELISI = 18,
		//杰王子
		MODLE_JIEWANGZI = 19,
		//多吉
		MODLE_DUOJI = 20,
		//泰比
		MODLE_TAIBI = 21,
		//阿沙
		MODLE_ASHA = 22,
		//问号
		MODLE_WENHAO = 23,
	};

	//BOSS模型 中文拼音
	enum BossModle
	{

		//格里芬
		MODLE_GELIFEN = 24,
		//紫小怪物
		MODLE_ZIXIAOGUAIWU = 25,
		//红中怪物
		MODLE_HONGZHONGGUAIWU = 26,
		//蓝大怪物
		MODLE_LANDAGUAIWU = 27,
		//圣诞格里芬
		MODLE_SHENGDANGELIFEN = 28,
		//小年兽
		MODLE_XIAONIANSHOU = 29,
		//鬼仆格里芬
		MODLE_GUIPUGELIFEN = 30,
		//大年兽
		MODLE_DANIANSHOU = 31,
		//海盗水手
		MODLE_HAIDAOSHUISHOU = 32,
		//海盗大副
		MODLE_HAIDAODAFU = 33,
		//虎克船长
		MODLE_HUKECHUANCHANG = 34,
		//足球BOSS
		MODLE_ZUQIU1 = 35,
		//足球BOSS
		MODLE_ZUQIU2 = 36,
		//咕咕鸟
		MODLE_GUGUNIAO = 41,
		//小恶魔
		MODLE_XIAOEMO = 42,
		//幽灵
		MODLE_YOULING = 43,
		//熊猫
		MODLE_XIONGMAO = 44,
		//疾风
		MODLE_JIFENG = 45,
		//糖果王
		MODLE_TANGGUOWANG = 46,
		//大螃蟹
		MODLE_DAPANGXIE = 54,
		//斧头帮
		MODLE_FUTOUBANG = 55,
		//龟壳
		MODLE_GUIKE = 58,
		//骷髅骑士
		MODLE_KULOUQISHI = 67,
		//暗之傀儡
		MODLE_ANZHIKUILEI = 68,
		//毒之傀儡
		MODLE_DUZHIKUILEI = 69,
		//火之傀儡
		MODLE_HUOZHIKUILEI = 70,
		//傀儡木偶
		MODLE_KUILEIMUOU = 71,
		//冰霜之王
		MODLE_BINGSHUANGZHIWANG = 72,
		//腐烂木偶
		MODLE_FULANMUOU = 73,
		//黑桃K队长
		MODLE_HEITAODUICHANG = 74,
		//红桃K魔法师战士
		MODLE_HONGTAOMOFASHIZHANSHI = 75,
		//蓝魔法女巫
		MODLE_LANMOFANUWU = 76,
		//冰霜骷髅魔法师
		MODLE_BINGSHUANGKULOUMOFASHI = 77,
		//红魔法女巫
		MODLE_HONGMOFANUWU = 78,
		//火焰骷髅魔法师
		MODLE_HUOYANKULOUMOFASHI = 79,
		//雷电骷髅魔法师
		MODLE_LEIDIANKULOUMOFASHI = 81,
		//冰霜战士
		MODLE_BINGSHUANGZHANSHI = 82,
		//冰之傀儡
		MODLE_BINGZHIKUILEI = 83,
		//死神蓝
		MODLE_SISHENLAN = 84,
		//死神红
		MODLE_SISHENHONG = 85,
		//机械母鸡
		MODLE_JIXIEMUJI = 101,
		//巨型母鸡
		MODLE_JUXINGMUJI = 102,
		//机械蜘蛛
		MODLE_JIXIEZHIZHU = 103,
		//巨型机械蜘蛛
		MODLE_JUXINGJIXIEZHIZHU = 104,
		//闹钟机器人
		MODLE_NAOZHONGJIQIREN = 105,
		//大闹钟
		MODLE_DANAOZHONG = 106,
		//宇航机器人
		MODLE_YUHANGJIQIREN = 107,
		//大雄宇航机器人
		MODLE_DAXIONGYUHANGJIQIREN = 108,
		//冰之傀儡
		MODLE_BINGZHIKUILEI1 = 109,
		//火子傀儡
		MODLE_HUOZIKUILEI = 110,
		//扑克牌
		MODLE_PUKEPAI = 111,
		//毒之傀儡
		MODLE_DUZHIKUILEI1 = 112,
		//扑克牌队长
		MODLE_PUKEPAIDUICHANG = 113,
		//火焰骷髅魔法师
		MODLE_HUOYANKULOUMOFASHI1 = 114,
		//冰霜骷髅魔法师
		MODLE_BINGSHUANGKULOUMOFASHI1 = 115,
		//雷电骷髅魔法师
		MODLE_LEIDIANKULOUMOFASHI1 = 116,
		//女巫红
		MODLE_NUWUHONG = 117,
		//骷髅骑士
		MODLE_KULOUQISHI1 = 118,
		//女巫蓝
		MODLE_NUWULAN = 119,
		//流光龙
		MODLE_LIUGUANGLONG = 120,
		//流光龙
		MODLE_LIUGUANGLONG1 = 121,
		//火焰巨人
		MODLE_HUOYANJUREN = 122,
		//暗影巨人
		MODLE_ANYINGJUREN = 123,
		//火焰龙
		MODLE_HUOYANLONG = 124,
		//暗影龙
		MODLE_ANYINGLONG = 125,
		//绿毛虫
		MODLE_LUMAOCHONG = 126,
		//彩虹虫
		MODLE_CAIHONGCHONG = 127,
		//小绿花
		MODLE_XIAOLUHUA = 128,
		//大红花
		MODLE_DAHONGHUA = 129,
		//莲蓬树
		MODLE_LIANPENGSHU = 130,
		//大树
		MODLE_DASHU = 131,
		//石巨人
		MODLE_SHIJUREN = 132,
		//鼹鼠
		MODLE_YANSHU = 133,
		//紫蝴蝶
		MODLE_ZIHUDIE = 134,
		//雪巨人
		MODLE_XUEJUREN = 135,
		//冰巨人
		MODLE_BINGJUREN = 136,
		//丑小鸭
		MODLE_CHOUXIAOYA = 137,
		//精锐的恶魔兵
		MODLE_JINGRUIDEEMOBING = 138,
		//天使酷比
		MODLE_TIANSHIKUBI = 139,
		//极地棉袄蜥蜴
		MODLE_JIDIMIANAOXIYI = 140,
		//极地熊
		MODLE_JIDIXIONG = 141,
		//冰虫
		MODLE_BINGCHONG = 142,
		//冰之魂
		MODLE_BINGZHIHUN = 143,
		//冰冻青菜
		MODLE_BINGDONGQINGCAI = 144,
	};

	//游戏类型 普通 功夫 水面 比武 等 包括 道具场以及探险 
	enum GameModle
	{
		//普通
		MODLE_COMMON = 1,
		//MATCH 比武
		MODLE_MATCH = 4,

		//TREASURE 夺宝
		MODLE_TREASURE = 5,

		//SCULPTURE 英雄
		MODLE_SCULPTURE = 6,

		//WATER 水面
		MODLE_WATER = 1,

		//FIELD 野外
		MODLE_FIELD = 1,

		// TOWN 中国城
		MODLE_TOWN = 1,

		//DESERT 沙漠
		MODLE_DESERT = 1,

		//MINE 矿洞
		MODLE_MINE = 1,

		//SNOW 雪地
		MODLE_SNOW = 1,

		//TANK 糖果战
		MODLE_TANK = 13,

		//BOMB 足球
		MODLE_BOMB = 2,

		//BUN 抢包子
		MODLE_BUN = 3,

		//PIG 功夫
		MODLE_PIG = 1,

		//MACHINE 机器
		MODLE_MACHINE = 7,

		//BOX 箱子
		MODLE_BOX = 8,

		//新手教程
		MODLE_PRACTICE = 9,

		//PVE 探险
		MODLE_PVE = 12,
	};

	//玩家表情
	enum PlayerExpression
	{
		//嘿嘿
		EXPRESSION_PKEY = 1,
		//寒
		EXPRESSION_OKEY = 2,
		//爱心
		EXPRESSION_IKEY = 3,
		//呜呜
		EXPRESSION_UKEY = 4,
		//气
		EXPRESSION_YKEY = 5,
		//9我
		EXPRESSION_TKEY = 6,
	};

	//地图ID
	enum MapID
	{
		//水面
		MAP_WATER01_4 = 1,
		MAP_WATER02_4 = 2,
		MAP_WATER03_8 = 3,
		MAP_WATER04_8 = 4,
		MAP_WATER05_8 = 5,
		MAP_WATER06_8 = 6,
		MAP_WATER07_8 = 7,
		MAP_WATER08_8 = 8,
		MAP_WATER09_8 = 9,
		MAP_WATER10_8 = 10,
		MAP_WATER11_8 = 11,
		MAP_WATER12_8 = 12,
		MAP_WATER13_8 = 13,
		MAP_WATER14_8 = 14,
		MAP_WATER15_8 = 15,
		MAP_WATER12_8_0 = 16,
		MAP_WATER16_8 = 17,
		MAP_WATER17_8 = 18,
		MAP_WATER18_8 = 19,
		MAP_WATER19_8 = 20,
		MAP_WATER20_8 = 21,
		MAP_WATER21_8 = 22,
		MAP_WATER22_8 = 23,
		MAP_WATER23_8 = 24,
		MAP_WATER25_4 = 25,
		MAP_WATER26_8 = 26,
		MAP_WATER27_8 = 27,
		MAP_WATER28_8 = 28,
		//野外
		MAP_FIELD01_4 = 101,
		MAP_FIELD02_6 = 102,
		MAP_FIELD03_8 = 103,
		MAP_FIELD04_8 = 104,
		MAP_FIELD05_8 = 105,
		MAP_FIELD06_8 = 106,
		MAP_FIELD07_8 = 107,
		MAP_FIELD08_8 = 108,
		MAP_FIELD09_8 = 109,
		MAP_FIELD10_8 = 110,
		MAP_FIELD11_8 = 111,
		MAP_FIELD12_8 = 112,
		MAP_FIELD13_8 = 113,
		MAP_FIELD14_8 = 114,
		MAP_FIELD15_8 = 115,
		MAP_FIELD16_8 = 116,
		MAP_FIELD17_8 = 117,
		MAP_FIELD18_8 = 118,
		MAP_FIELD19_8 = 119,
		MAP_FIELD20_8 = 120,
		MAP_FIELD21_8 = 121,
		MAP_FIELD22_8 = 122,
		MAP_FIELD23_8 = 123,
		MAP_FIELD24_4 = 124,
		MAP_FIELD25_4 = 125,
		MAP_FIELD26_4 = 126,
		MAP_FIELD27_8 = 127,
		MAP_FIELD28_4 = 128,
		//景德镇
		MAP_TOWN01_4 = 201,
		MAP_TOWN02_4 = 202,
		MAP_TOWN14_8 = 203,
		MAP_TOWN04_8 = 204,
		MAP_TOWN05_8 = 205,
		MAP_TOWN06_8 = 206,
		MAP_TOWN07_8 = 207,
		MAP_TOWN08_8 = 208,
		MAP_TOWN09_8 = 209,
		MAP_TOWN10_8 = 210,
		MAP_TOWN11_8 = 211,
		MAP_TOWN12_8 = 212,
		MAP_TOWN13_8 = 213,
		MAP_TOWN11_8_0 = 214,
		MAP_TOWN15_8 = 215,
		MAP_TOWN12_8_0 = 216,
		MAP_TOWN16_8 = 217,
		MAP_TOWN17_8 = 218,
		MAP_TOWN16_8_0 = 219,
		MAP_TOWN17_8_0 = 220,
		MAP_TOWN18_8 = 221,
		MAP_TOWN19_8 = 222,
		MAP_TOWN20_8 = 223,
		MAP_TOWN21_8 = 224,
		MAP_TOWN22_8 = 225,
		MAP_TOWN23_4 = 226,
		MAP_TOWN24_8 = 227,
		MAP_TOWN28_8 = 228,
		MAP_TOWN29_4 = 229,
		MAP_TOWN30_6 = 230,
		MAP_TOWN31_4 = 231,
		//沙漠
		MAP_DESERT01_4 = 301,
		MAP_DESERT02_4 = 302,
		MAP_DESERT03_4 = 303,
		MAP_DESERT04_8 = 304,
		MAP_DESERT05_8 = 305,
		MAP_DESERT06_8 = 306,
		MAP_DESERT07_4 = 307,
		MAP_DESERT08_6 = 308,
		MAP_DESERT09_8 = 309,
		MAP_DESERT10_8 = 310,
		MAP_DESERT11_8 = 311,
		MAP_DESERT12_8 = 312,
		MAP_DESERT13_8 = 313,
		MAP_DESERT14_8 = 314,
		MAP_DESERT11_8_0 = 315,
		MAP_DESERT09_8_0 = 316,
		MAP_DESERT15_8 = 317,
		MAP_DESERT04_8_0 = 318,
		MAP_DESERT16_8 = 319,
		MAP_DESERT17_8 = 320,
		MAP_DESERT18_8 = 321,
		MAP_DESERT19_6 = 322,
		MAP_DESERT20_8 = 323,
		MAP_DESERT21_8 = 324,
		MAP_DESERT22_8 = 325,
		MAP_DESERT26_6 = 326,
		MAP_DESERT27_8 = 327,
		MAP_DESERT28_8 = 328,
		MAP_DESERT29_8 = 329,
		//矿井
		MAP_MINE01_4 = 401,
		MAP_MINE02_4 = 402,
		MAP_MINE03_4 = 403,
		MAP_MINE04_8 = 404,
		MAP_MINE05_8 = 405,
		MAP_MINE06_8 = 406,
		MAP_MINE07_8 = 407,
		MAP_MINE08_8 = 408,
		MAP_MINE09_8 = 409,
		MAP_MINE10_4 = 410,
		MAP_MINE11_8 = 411,
		MAP_MINE12_8 = 412,
		MAP_MINE13_8 = 413,
		MAP_MINE14_8 = 414,
		MAP_MINE15_8 = 415,
		MAP_MINE16_4 = 416,
		MAP_MINE17_8 = 417,
		MAP_MINE18_8 = 418,
		MAP_MINE19_8 = 419,
		MAP_MINE20_4 = 420,
		MAP_MINE21_8 = 421,
		MAP_MINE22_4 = 422,
		MAP_MINE23_8 = 423,
		MAP_MINE24_8 = 424,
		MAP_MINE25_4 = 425,
		MAP_MINE26_8 = 426,
		//雪地
		MAP_SNOW01_4 = 501,
		MAP_SNOW02_6 = 502,
		MAP_SNOW03_8 = 503,
		MAP_SNOW04_8 = 504,
		MAP_SNOW05_8 = 505,
		MAP_SNOW06_8 = 506,
		MAP_SNOW07_8 = 507,
		MAP_SNOW08_8 = 508,
		MAP_SNOW09_8 = 509,
		MAP_SNOW10_8 = 510,
		MAP_SNOW11_8 = 511,
		MAP_SNOW12_8 = 512,
		MAP_SNOW13_8 = 513,
		MAP_SNOW14_8 = 514,
		MAP_SNOW15_8 = 515,
		MAP_SNOW16_8 = 516,
		MAP_SNOW17_8 = 517,
		MAP_SNOW18_8 = 518,
		MAP_SNOW08_8_0 = 519,
		MAP_SNOW19_8 = 520,
		MAP_SNOW20_8 = 521,
		MAP_SNOW21_4 = 522,
		MAP_SNOW22_8 = 523,
		MAP_SNOW23_8 = 524,
		MAP_SNOW24_6 = 525,
		//足球
		MAP_BOMB01_8 = 701,
		MAP_BOMB02_8 = 702,
		MAP_BOMB03_8 = 703,
		MAP_BOMB04_8 = 704,
		//包子
		MAP_BUN01_8 = 801,
		MAP_BUN02_8 = 802,
		MAP_BUN03_8 = 803,
		MAP_BUN04_8 = 804,
		MAP_BUN05_8 = 805,
		MAP_BUN06_8 = 806,
		MAP_BUN07_8 = 807,
		MAP_BUN08_8 = 808,
		MAP_BUN09_8 = 809,
		MAP_BUN10_8 = 810,
		MAP_BUN11_8 = 811,
		MAP_BUN12_8 = 812,
		MAP_BUN13_8 = 813,
		MAP_BUN14_8 = 814,
		MAP_BUN15_8 = 815,
		MAP_BUN16_8 = 816,
		MAP_BUN17_8 = 817,
		MAP_BUN18_8 = 818,
		MAP_BUN19_8 = 819,
		MAP_BUN20_8 = 820,
		MAP_BUN21_4 = 821,
		MAP_BUN22_4 = 822,
		MAP_BUN23_8 = 823,
		MAP_BUN24_8 = 824,
		MAP_BUN25_6 = 825,
		MAP_BUN26_8 = 826,
		MAP_BUN27_8 = 827,
		MAP_BUN28_8 = 828,
		MAP_BUN29_8 = 829,
		MAP_BUN30_6 = 830,
		MAP_BUN31_8 = 831,
		//功夫
		MAP_PIG01_4 = 901,
		MAP_PIG02_6 = 902,
		MAP_PIG03_8 = 903,
		MAP_PIG04_8 = 904,
		MAP_PIG05_8 = 905,
		MAP_PIG06_8 = 906,
		MAP_PIG07_8 = 907,
		MAP_PIG08_8 = 908,
		MAP_PIG09_8 = 909,
		MAP_PIG10_8 = 910,
		MAP_PIG11_8 = 911,
		MAP_PIG05_8_0 = 912,
		MAP_PIG12_8 = 913,
		MAP_PIG13_8 = 914,
		MAP_PIG14_6 = 915,
		MAP_PIG15_8 = 916,
		MAP_PIG16_4 = 917,
		MAP_PIG17_8 = 918,
		MAP_PIG18_4 = 919,
		MAP_PIG20_8 = 920,
		MAP_PIG21_4 = 921,
		MAP_PIG22_4 = 922,
		MAP_PIG23_8 = 923,
		//比武
		MAP_MATCH01_2 = 1001,
		MAP_MATCH02_2 = 1002,
		MAP_MATCH03_4 = 1003,
		MAP_MATCH04_4 = 1004,
		MAP_MATCH05_6 = 1005,
		MAP_MATCH06_6 = 1006,
		MAP_MATCH07_8 = 1007,
		MAP_MATCH08_8 = 1008,
		MAP_MATCH09_8 = 1009,
		MAP_MATCH10_8 = 1010,
		MAP_MATCH01_2_0 = 1011,
		MAP_MATCH09_8_0 = 1012,
		MAP_MATCH11_8 = 1013,
		MAP_MATCH12_8 = 1014,
		MAP_MATCH13_8 = 1015,
		MAP_MATCH14_6 = 1016,
		MAP_MATCH15_6 = 1017,
		MAP_MATCH16_8 = 1018,
		MAP_MATCH17_8 = 1019,
		MAP_MATCH18_8 = 1020,
		MAP_MATCH19_6 = 1021,
		MAP_MATCH20_4 = 1022,
		MAP_MATCH21_4 = 1023,
		MAP_MATCH22_4 = 1024,
		MAP_MATCH23_8 = 1025,
		MAP_MATCH24_8 = 1026,
		//夺宝
		MAP_TREASURE01_4 = 1101,
		MAP_TREASURE02_6 = 1102,
		MAP_TREASURE03_8 = 1103,
		MAP_TREASURE04_8 = 1104,
		MAP_TREASURE05_8 = 1105,
		MAP_TREASURE06_8 = 1106,
		MAP_TREASURE07_8 = 1107,
		MAP_TREASURE08_8 = 1108,
		MAP_TREASURE09_8 = 1109,
		MAP_TREASURE10_8 = 1110,
		MAP_TREASURE11_8 = 1111,
		MAP_TREASURE12_8 = 1112,
		MAP_TREASURE13_8 = 1113,
		MAP_TREASURE05_8_0 = 1114,
		MAP_TREASURE14_8 = 1115,
		MAP_TREASURE15_6 = 1116,
		MAP_TREASURE16_8 = 1117,
		MAP_TREASURE17_8 = 1118,
		MAP_TREASURE18_8 = 1119,
		MAP_TREASURE19_4 = 1120,
		MAP_TREASURE20_4 = 1121,
		MAP_TREASURE22_4 = 1122,
		MAP_TREASURE23_4 = 1123,
		MAP_TREASURE24_8 = 1124,
		MAP_TREASURE25_4 = 1125,
		//英雄
		MAP_SCULPTURE01_8 = 1201,
		MAP_SCULPTURE02_8 = 1202,
		MAP_SCULPTURE03_8 = 1203,
		MAP_SCULPTURE04_8 = 1204,
		MAP_SCULPTURE05_8 = 1205,
		MAP_SCULPTURE06_8 = 1206,
		MAP_SCULPTURE07_8 = 1207,
		MAP_SCULPTURE08_8 = 1208,
		MAP_SCULPTURE09_8 = 1209,
		MAP_SCULPTURE10_8 = 1210,
		MAP_SCULPTURE11_8 = 1211,
		MAP_SCULPTURE13_8 = 1212,
		MAP_SCULPTURE12_8 = 1212,
		MAP_SCULPTURE14_8 = 1213,
		MAP_SCULPTURE15_8 = 1214,
		MAP_SCULPTURE16_8 = 1215,
		MAP_SCULPTURE17_8 = 1216,
		MAP_SCULPTURE18_6 = 1217,
		MAP_SCULPTURE19_4 = 1218,
		//机器
		MAP_MACHINE01_6 = 1301,
		MAP_MACHINE02_6 = 1302,
		MAP_MACHINE03_8 = 1303,
		MAP_MACHINE04_8 = 1304,
		MAP_MACHINE05_8 = 1305,
		MAP_MACHINE06_8 = 1306,
		MAP_MACHINE07_8 = 1307,
		MAP_MACHINE08_8 = 1308,
		MAP_MACHINE09_8 = 1309,
		MAP_MACHINE10_8 = 1310,
		MAP_MACHINE11_8 = 1311,
		//推箱子
		MAP_BOX01_8 = 1401,
		MAP_BOX02_8 = 1402,
		MAP_BOX03_8 = 1403,
		MAP_BOX04_8 = 1404,
		MAP_BOX05_6 = 1405,
		MAP_BOX06_6 = 1406,
		MAP_BOX07_8 = 1407,
		MAP_BOX08_8 = 1408,
		MAP_BOX09_8 = 1409,
		//练习
		MAP_TUTORIAL01_1 = 1501,
		MAP_TUTORIAL02_2 = 1502,
		MAP_TUTORIAL03_1 = 1503,
		MAP_TUTORIAL04_1 = 1504,
		//探险
		MAP_PVE1_1 = 1601,
		MAP_PVE1_2 = 1602,
		MAP_PVE1_3 = 1603,
		MAP_PVE1_4 = 1604,
		MAP_PVE1_5 = 1605,
		MAP_PVE1_6 = 1606,
		MAP_PVE2_1 = 1607,
		MAP_PVE2_2 = 1608,
		MAP_PVE2_3 = 1609,
		MAP_PVE2_4 = 1610,
		MAP_PVE2_5 = 1611,
		MAP_PVE3_1 = 1612,
		MAP_PVE3_2 = 1613,
		MAP_PVE3_3 = 1614,
		MAP_PVE3_4 = 1615,
		MAP_PVE4_1 = 1616,
		MAP_PVE4_2 = 1617,
		MAP_PVE4_3 = 1618,
		MAP_PVE4_4 = 1619,
		MAP_PVE4_5 = 1620,
		MAP_PVE4_6 = 1621,
		MAP_PVE4_7 = 1622,
		MAP_PVE5_1 = 1623,
		MAP_PVE5_2 = 1624,
		MAP_PVE5_3 = 1625,
		MAP_PVE5_4 = 1626,
		MAP_PVE5_5 = 1627,
		MAP_PVE6_1 = 1628,
		MAP_PVE6_2 = 1629,
		MAP_PVE6_3 = 1630,
		MAP_PVE6_4 = 1631,
		MAP_PVE6_5 = 1632,
		MAP_PVE7_1 = 1633,
		MAP_PVE7_2 = 1634,
		MAP_PVE7_3 = 1635,
		MAP_PVE7_4 = 1636,
		MAP_PVE8_1 = 1637,
		MAP_PVE8_2 = 1638,
		MAP_PVE8_3 = 1639,
		MAP_PVE9_1 = 1640,
		MAP_PVE9_2 = 1641,
		MAP_PVE9_3 = 1642,
		MAP_PVE10_1 = 1643,
		MAP_PVE10_2 = 1644,
		MAP_PVE10_3 = 1645,
		MAP_PVE11_1 = 1646,
		MAP_PVE11_2 = 1647,
		MAP_PVE11_3 = 1648,
		MAP_PVE12_1 = 1649,
		MAP_PVE12_2 = 1650,
		//糖果战
		MAP_TANK01_8 = 1701,
		MAP_TANK02_8 = 1702,
		MAP_TANK03_8 = 1703,
		MAP_TANK04_8 = 1704,
		MAP_TANK05_8 = 1705,
		MAP_TANK06_8 = 1706,
		MAP_TANK07_8 = 1707,
		MAP_TANK08_8 = 1708,
		//?
		MAP_CONTEST01_8 = 4001,
		MAP_CONTEST02_8 = 4002,
		MAP_CONTEST03_8 = 4003,
		MAP_CONTEST04_8 = 4004,
	};


	//游戏ID
	enum GameID
	{
		//玩家到玩家
		P2P_ID = 0,
		//玩家移动 房间里
		P2P_PLAYERMOVEINROOM = 0xBB8,
		//玩家放泡泡 房间里
		P2P_PLAYERLAYOUTBOMBINROOM = 0xBB9,
		//加密
		D2E_ENCODE = 0xBBA,
		//玩家移动数据包
		P2P_NPCMOVE = 0xFA2,
		//放泡泡
		P2P_LAYOUTBOMB = 0xFA3,
		//爆炸信息
		P2P_EXPLODEINFO = 0xFA4,
		//进果冻
		P2P_INJELLY = 0xFA5,
		//NPC屎亡
		P2P_NPCDIE = 0xFA7,
		//通知KO玩家
		P2P_NOTIFYNPCKILL = 0xFA8,
		//KO玩家
		P2P_NPCKILL = 0xFA9,
		//通知玩家救人
		P2P_NOTIFYNPCSAVE = 0xFAA,
		//玩家救人
		P2P_NPCSAVE = 0xFAB,
		//通知获取道具
		P2P_NOTIFYNPCGETITEM = 0xFAC,
		//获取道具
		P2P_NPCGETITEM = 0xFAD,
		//飞机爆道具
		P2P_PLANEDROPITEM = 0xFAE,
		//通知使用技能
		P2P_NOTIFYNPCUSESKILL = 0xFAF,
		//通知使用道具
		P2P_NOTIFYNPCUSEPROP = 0xFAF,
		//使用技能
		P2P_NPCUSESKILL = 0xFB0,
		//使用道具
		P2P_NPCUSEPROP = 0xFB0,
		//通知推箱子
		P2P_NOTIFYPUSHBOX = 0xFB2,
		//推箱子
		P2P_PUSHBOX = 0xFB3,
		//通知踢泡泡
		P2P_NOTIFYPLAYBOMB = 0xFB4,
		//踢泡泡
		P2P_PLAYBOMB = 0x139C,

		//玩家固定位置
		P2P_PLAYERFIXED = 0xFB5,
		//通知包子出房间
		P2P_NOTIFYGETBUNOUTROOM = 0xFB6,
		//包子出房间
		P2P_GETBUNOUTROOM = 0xFB7,
		//通知包子进房间
		P2P_NOTIFYGETBUNINROOM = 0xFB8,
		//包子进房间
		P2P_GETBUNINROOM = 0xFB9,
		//玩家复活
		P2P_NPCRELIVE = 0xFBA,
		//推箱子爆炸
		P2P_PUSHBOXEXPLODE = 0xFBE,
		//玩家变身结束
		P2P_NPCAVATARDISAPPEAR = 0x10E0,
		//足球飞泡泡
		P2P_GAMEDROPBOMB = 0x10E1,

		//机械
		P2P_MACHINE0x10EF = 0x10EF,
		P2P_MACHINE0x10F0 = 0x10F0,
		P2P_MACHINE0x10F1 = 0x10F1,
		P2P_MACHINE0x10F2 = 0x10F2,
		//机械大炮
		P2P_MACHINEARTILLERY = 0x10F3,
		//玩家掉血
		P2P_NPCHPLOSS = 0x10F4,

		P2P_NOTIFYMACHINE0x10F5 = 0x10F5,
		P2P_MACHINE0x10F6 = 0x10F6,

		//机械新道具
		P2P_MACHINECREATEPROP = 0x10F7,
		//机械泡泡
		P2P_PUSHBOX0x1159 = 0x1159,
		P2P_MACHINE0x115A = 0x115A,
		//机械 显示火焰秘籍(长龙 天牢 凤 闪避 踢爆)
		P2P_MACHINESKILL = 0x115B,
		P2P_NOTIFYMACHINESKILL = 0x115C,
		//机械大炮
		P2P_MACHINEARTILLERY115D = 0x115D,
		//通知推箱子
		P2P_NOTIFYPUSHBOXMOVE = 0x115E,
		//推箱子
		P2P_PUSHBOXMOVE = 0x115F,

		P2P_BOXEXPLODE0x1162 = 0x1162,
		P2P_NOTIFYBOXEXPLODE = 0x1163,
		P2P_PUSHBOX0x1166 = 0x1166,
		P2P_PUSHBOX0x1167 = 0x1167,

		//创建箱子
		P2P_CREATEBOX = 0x1168,
		//BOSS 技能
		P2P_BOSSSKILL = 0x1169,
		//BOSS 说话
		P2P_BOSSSPEAK = 0x116A,
		//BOSS爆道具
		P2P_BOSSDROPITEM = 0x116B,
		//位置跨门
		P2P_TRANSDOOR = 0x1176,
		//玩家表情
		P2P_NPCEXPRESSION = 0x1194,
		//创建BOSS
		P2P_CREATEBOSS = 0x1389,
		//探险出现BOSS
		P2P_NEXTSHOWBOSS = 0x138C,

		//服务器到客户端
		S2C_ID = 0,
		//通知玩家退出
		S2C_NOTIFYPLAYERQUITGAME = 0x10EC,
		//通知游戏结束
		S2C_NOTIFYGAMEOVER = 0xFBB,
		//通知新仲裁
		S2C_NOTIFYNEWARBITRATION = 0xFB1,
		S2C_0x1160 = 0x1160,
		S2C_0x1161 = 0x1161,
		//使用道具调整位置
		S2C_0xADJUSTPOSITION = 0x1175,
		//显示BOSS
		S2C_PVEBOSSDISPOSE = 0x138A,

		//客户端到服务器
		C2S_ID = 0,
		//爆炸信息
		C2S_EXPLODEINFO = 0xFA4,
		//进果冻
		C2S_INJELLY = 0xFA5,
		//NPC屎亡
		C2S_NPCDIE = 0xFA7,
		//KO玩家
		C2S_NPCKILL = 0xFA9,
		//玩家救人
		C2S_NPCSAVE = 0xFAB,
		//通知获取道具
		C2S_NOTIFYNPCGETITEM = 0xFAC,
		//获取道具
		C2S_NPCGETITEM = 0xFAD,
		//包子进房间
		C2S_GETBUNINROOM = 0xFB9,
		//玩家复活
		C2S_NPCRELIVE = 0xFBA,
		C2S_CHECKCLIENT1 = 0x10EB,
		C2S_CHECKCLIENT2 = 0x1173,
		C2S_CHECKCLIENT3 = 0x1174,
		//探险进图
		C2S_NEXTPVEMAP = 0x1178,
		//糖果站房子爆炸
		C2S_TANKROOMEXPLODE = 0x15B3,

	};

	//玩家方向
	enum PlayerDirection
	{
		//右
		DIRECTION_RIGHT = 0,
		//上
		DIRECTION_UP = 1,
		//左
		DIRECTION_LEFT = 2,
		//下
		DIRECTION_DOWN = 3,
		//停
		DIRECTION_STOP = 4
	};

	//探险道具
	enum ItemByPVE
	{
		//超级火焰药水
		PVE_CHAOJIHUOYANYAOSHUI = 20003,
		//超级糖浆
		PVE_CHAOJITANGJIANG = 20006,
		//透明泡泡药水
		PVE_TOUMINGPAOPAOYAOSHUI = 20007,
		//冲刺药水
		PVE_CHONGCIYAOSHUI = 20019,
		//万能药剂
		PVE_WANNENGYAOJI = 20020,
		//超强的泻药
		PVE_CHAOQIANGDEXIEYAO = 20027,
		//嘲笑药水
		PVE_CHAOXIAOYAOSHUI = 20028,
		//小体力药水
		PVE_XIAOTILIYAOSHUI = 20044,
		//中体力药水
		PVE_ZHONGTILIYAOSHUI = 20045,
		//大体力药水
		PVE_DATILIYAOSHUI = 20043,
		//无敌药剂
		PVE_WUDIYAOJI = 20047,
		//火焰抵抗药剂
		PVE_HUOYANDIKANGYAOJI = 20035,
		//寒冰抵抗药剂
		PVE_HANBINGDIKANGYAOJI = 20033,
		//闪电抵抗药剂
		PVE_SHANDIANDIKANGYAOJI = 20042,
		//解毒药
		PVE_JIEDUYAO = 20037,
		//力量药水
		PVE_LILIANGYAOSHUI = 20039,
		//消失药水
		PVE_XIAOSHIYAOSHUI = 20049,
		//玫瑰药水
		PVE_MEIGUIYAOSHUI = 20040,
		//过期的牛奶
		PVE_GUOQIDENIUNAI = 20032,
		//眩晕陷阱
		PVE_XUANYUNXIANJING = 20008,
		//减速陷阱
		JIANSUXIANJING = 20009,
		//反向陷阱
		PVE_FANXIANGXIANJING = 20010,
		//爆炸陷阱
		PVE_BAOZHAXIANJING = 20018,
		//攻击陷阱
		PVE_GONGJIXIANJING = 20031,
		//力量护符
		PVE_LILIANGHUFU = 20011,
		//急速护符
		PVE_JISUHUFU = 20012,
		//穿墙护符
		PVE_CHUANQIANGHUFU = 20013,
		//探测护符
		PVE_TANCEHUFU = 20014,
		//生命护符
		PVE_SHENGMINGHUFU = 20026,
		//抵御护符
		PVE_DIYUHUFU = 20021,
		//恶魔卷轴
		PVE_EMOJUANZHOU = 20015,
		//恐怖卷轴
		PVE_KONGBUJUANZHOU = 20016,
		//冰冻卷轴
		PVE_BINGDONGJUANZHOU = 20017,
		//变身卷轴
		PVE_BIANSHENJUANZHOU = 20025,
		//电动钻头
		PVE_DIANDONGZUANTOU = 20023,
		//叉子
		PVE_CHAZI = 20022,
		//飞镖
		PVE_FEIBIAO = 20024,
		//急救包
		PVE_JIJIUBAO = 20036,
		//医疗包
		PVE_YILIAOBAO = 20050,
		//盖亚之种
		PVE_GAIYAZHIZHONG = 20030,
		//酷比的力量
		PVE_KUBIDELILIANG = 20038,
		//无限的糖浆
		PVE_WUXIANDETANGJIANG = 20048,
		//黑萎草
		PVE_HEIWEICAO = 20034,
		//赤水晶
		PVE_CHISHUIJING = 20051,
		//橙水晶
		PVE_CHENGSHUIJING = 20052,
		//黄水晶
		PVE_HUANGSHUIJING = 20053,
		//绿水晶
		PVE_LUSHUIJING = 20054,
		//青水晶
		PVE_QINGSHUIJING = 20055,
		//蓝水晶
		PVE_LANSHUIJING = 20056,
		//紫水晶
		PVE_ZISHUIJING = 20057,
		//糖币加加1级
		PVE_TANGBIJIAJIA1JI = 27001,
		//糖币加加2级
		PVE_TANGBIJIAJIA2JI = 27002,
		//糖币加加3级
		PVE_TANGBIJIAJIA3JI = 27003,
		//糖币加加4级
		PVE_TANGBIJIAJIA4JI = 27004,
		//糖币加加5级
		PVE_TANGBIJIAJIA5JI = 27005,
		//糖币加加6级
		PVE_TANGBIJIAJIA6JI = 27006,
		//糖币加加7级
		PVE_TANGBIJIAJIA7JI = 27007,
		//糖币加加8级
		PVE_TANGBIJIAJIA8JI = 27008,
		//糖币加加9级
		PVE_TANGBIJIAJIA9JI = 27009,
		//糖币加加10级
		PVE_TANGBIJIAJIA10JI = 27010,
		//勇气加加1级
		PVE_YONGQIJIAJIA1JI = 27011,
		//勇气加加2级
		PVE_YONGQIJIAJIA2JI = 27012,
		//勇气加加3级
		PVE_YONGQIJIAJIA3JI = 27013,
		//勇气加加4级
		PVE_YONGQIJIAJIA4JI = 27014,
		//勇气加加5级
		PVE_YONGQIJIAJIA5JI = 27015,
		//勇气加加6级
		PVE_YONGQIJIAJIA6JI = 27016,
		//勇气加加7级
		PVE_YONGQIJIAJIA7JI = 27017,
		//勇气加加8级
		PVE_YONGQIJIAJIA8JI = 27018,
		//勇气加加9级
		PVE_YONGQIJIAJIA9JI = 27019,
		//勇气加加10级
		PVE_YONGQIJIAJIA10JI = 27020,
		//积分加加1级
		PVE_JIFENJIAJIA1JI = 27021,
		//积分加加2级
		PVE_JIFENJIAJIA2JI = 27022,
		//积分加加3级
		PVE_JIFENJIAJIA3JI = 27023,
		//积分加加4级
		PVE_JIFENJIAJIA4JI = 27024,
		//积分加加5级
		PVE_JIFENJIAJIA5JI = 27025,
		//积分加加6级
		PVE_JIFENJIAJIA6JI = 27026,
		//积分加加7级
		PVE_JIFENJIAJIA7JI = 27027,
		//积分加加8级
		PVE_JIFENJIAJIA8JI = 27028,
		//积分加加9级
		PVE_JIFENJIAJIA9JI = 27029,
		//积分加加10级
		PVE_JIFENJIAJIA10JI = 27030,
		//声望加加1级
		PVE_SHENGWANGJIAJIA1JI = 27031,
		//声望加加2级
		PVE_SHENGWANGJIAJIA2JI = 27032,
		//声望加加3级
		PVE_SHENGWANGJIAJIA3JI = 27033,
		//声望加加4级
		PVE_SHENGWANGJIAJIA4JI = 27034,
		//声望加加5级
		PVE_SHENGWANGJIAJIA5JI = 27035,
		//声望加加6级
		PVE_SHENGWANGJIAJIA6JI = 27036,
		//声望加加7级
		PVE_SHENGWANGJIAJIA7JI = 27037,
		//声望加加8级
		PVE_SHENGWANGJIAJIA8JI = 27038,
		//声望加加9级
		PVE_SHENGWANGJIAJIA9JI = 27039,
		//声望加加10级
		PVE_SHENGWANGJIAJIA10JI = 27040,
		//材料多多1级
		PVE_CAILIAODUODUO1JI = 27041,
		//材料多多2级
		PVE_CAILIAODUODUO2JI = 27042,
		//材料多多3级
		PVE_CAILIAODUODUO3JI = 27041,
		//材料多多4级
		PVE_CAILIAODUODUO4JI = 27044,
		//材料多多5级
		PVE_CAILIAODUODUO5JI = 27045,
		//材料多多6级
		PVE_CAILIAODUODUO6JI = 27046,
		//材料多多7级
		PVE_CAILIAODUODUO7JI = 27047,
		//材料多多8级
		PVE_CAILIAODUODUO8JI = 27048,
		//材料多多9级
		PVE_CAILIAODUODUO9JI = 27049,
		//材料多多10级
		PVE_CAILIAODUODUO10JI = 27050,
		//积分多多1级
		PVE_JIFENDUODUO1JI = 27051,
		//积分多多2级
		PVE_JIFENDUODUO2JI = 27052,
		//积分多多3级
		PVE_JIFENDUODUO3JI = 27053,
		//积分多多4级
		PVE_JIFENDUODUO4JI = 27054,
		//积分多多5级
		PVE_JIFENDUODUO5JI = 27055,
		//积分多多6级
		PVE_JIFENDUODUO6JI = 27056,
		//积分多多7级
		PVE_JIFENDUODUO7JI = 27057,
		//积分多多8级
		PVE_JIFENDUODUO8JI = 27058,
		//积分多多9级
		PVE_JIFENDUODUO9JI = 27059,
		//积分多多10级
		PVE_JIFENDUODUO10JI = 27060,
		//体力药水
		PVE_TILIYAOSHUI = 26001,
		//宠物粮食小
		PVE_CHONGWULIANGSHIXIAO = 26002,
		//宠物粮食中
		PVE_CHONGWULIANGSHIZHONG = 26003,
		//宠物粮食大
		PVE_CHONGWULIANGSHIDA = 26004,
		//心情棒棒糖小
		PVE_XINQINGBANGBANGTANGXIAO = 26005,
		//心情棒棒糖中
		PVE_XINQINGBANGBANGTANGZHONG = 26006,
		//心情棒棒糖大
		PVE_XINQINGBANGBANGTANGDA = 26007,
		//花生仁巧克力
		PVE_HUASHENGRENQIAOKELI = 26008,
		//松子仁巧克力
		PVE_SONGZIRENQIAOKELI = 26009,
		//榛子仁巧克力
		PVE_ZHENZIRENQIAOKELI = 26010,
		//普通的酷比
		PVE_PUTONGDEKUBI = 28001,
		//富有的酷比
		PVE_FUYOUDEKUBI = 28002,
		//尊崇的酷比
		PVE_ZUNCHONGDEKUBI = 28003,
		//普通的米多
		PVE_PUTONGDEMIDUO = 28004,
		//勇敢的米多
		PVE_YONGGANDEMIDUO = 28005,
		//勤劳的米多
		PVE_QINLAODEMIDUO = 28006,
		//普通的猪
		PVE_PUTONGDEZHU = 28007,
		//布鲁斯
		PVE_BULUSI = 28008,
		//普通的恶魔
		PVE_PUTONGDEEMO = 28009,
		//显赫的恶魔
		PVE_XIANHEDEEMO = 28010,
		//幸运的恶魔
		PVE_XINGYUNDEEMO = 28011,
		//琪琪
		PVE_QIQI = 28012,
		//恩佐
		PVE_ENZUO = 28013,
		//绿色结婚礼花
		PVE_LUSEJIEHUNLIHUA = 20062,
		//心型结婚礼花
		PVE_XINXINGJIEHUNLIHUA = 20063,
		//QQ堂礼花
		PVE_QQTANGLIHUA = 20064,
		//单人探险卡
		PVE_DANRENTANXIANKA = 99,
		//防踢卡
		PVE_FANGTIKA = 100,
		//复活卡
		PVE_FUHUOKA = 20100,
		//大复活卡
		PVE_DAFUHUOKA = 20101,
		//红色结婚礼花
		PVE_HONGSEJIEHUNLIHUA = 20058,
		//蓝色结婚礼花
		PVE_LANSEJIEHUNLIHUA = 20059,
		//紫色结婚礼花
		PVE_ZISEJIEHUNLIHUA = 20060,
		//黄色结婚礼花
		PVE_HUANGSEJIEHUNLIHUA = 20061,
		//爱情酷比
		PVE_AIQINGKUBI = 28014,
		//爱情米多
		PVE_AIQINGMIDUO = 28015,
		//黑暗火焰精灵
		PVE_HEIANHUOYANJINGLING = 28016,
		//光明火焰精灵
		PVE_GUANGMINGHUOYANJINGLING = 28017,
		//小菜娃
		PVE_XIAOCAIWA = 28018,
		//透明的瓶子
		PVE_TOUMINGDEPINGZI = 30001,
		//煮药的罐子
		PVE_ZHUYAODEGUANZI = 30002,
		//大容量的瓶子
		PVE_DARONGLIANGDEPINGZI = 30003,
		//封印瓶
		PVE_FENGYINPING = 30004,
		//空瓶5
		PVE_KONGPING = 30005,
		//潘多拉魔瓶
		PVE_PANDUOLAMOPING = 30006,
		//草药
		PVE_CAOYAO = 30007,
		//珍贵的草药
		PVE_ZHENGUIDECAOYAO = 30008,
		//奇怪的草药
		PVE_QIGUAIDECAOYAO = 30009,
		//毒草药
		PVE_DUCAOYAO = 30010,
		//黑萎草叶子
		PVE_HEIWEICAOYEZI = 30011,
		//药草6
		PVE_YAOCAO = 30012,
		//未成熟的蔬菜
		PVE_WEICHENGSHUDESHUCAI = 30013,
		//成熟的蔬菜
		PVE_CHENGSHUDESHUCAI = 30014,
		//巨大的蔬菜
		PVE_JUDADESHUCAI = 30015,
		//美味的蔬菜
		PVE_MEIWEIDESHUCAI = 30016,
		//蔬菜5
		PVE_SHUCAI5 = 30017,
		//蔬菜6
		PVE_SHUCAI6 = 30018,
		//小珍珠
		PVE_XIAOZHENZHU = 30031,
		//大珍珠
		PVE_DAZHENZHU = 30032,
		//发光的珍珠
		PVE_FAGUANGDEZHENZHU = 30033,
		//怪物的内核
		PVE_GUAIWUDENEIHE = 30034,
		//夜光珠
		PVE_YEGUANGZHU = 30035,
		//珍珠6
		PVE_ZHENZHU = 30036,
		//羽毛1
		PVE_YUMAO1 = 30037,
		//掉落的羽毛
		PVE_DIAOLUODEYUMAO = 30038,
		//羽毛3
		PVE_YUMAO3 = 30039,
		//好看的羽毛
		PVE_HAOKANDEYUMAO = 30040,
		//凤凰的羽毛
		PVE_FENGHUANGDEYUMAO = 30041,
		//羽毛6
		PVE_YUMAO6 = 30042,
		//小碎屑
		PVE_XIAOSUIXIE = 30043,
		//冰沫
		PVE_BINGMO = 30044,
		//散落的灰尘
		PVE_SANLUODEHUICHEN = 30045,
		//矿石粉沫
		PVE_KUANGSHIFENMO = 30046,
		//火药粉沫
		PVE_HUOYAOFENMO = 30047,
		//粉末6
		PVE_FENMO = 30048,
		//木材1
		PVE_MUCAI = 30049,
		//湿木头
		PVE_SHIMUTOU = 30050,
		//大树枝
		PVE_DASHUZHI = 30051,
		//坚硬的木头
		PVE_JIANYINGDEMUTOU = 30052,
		//木材5
		PVE_MUCAI5 = 30053,
		//木材6
		PVE_MUCAI6 = 30054,
		//金属1
		PVE_JINSHU1 = 30055,
		//铁矿石
		PVE_TIEKUANGSHI = 30056,
		//银矿石
		PVE_YINKUANGSHI = 30057,
		//金矿石
		PVE_JINKUANGSHI = 30058,
		//珍惜矿石
		PVE_ZHENXIKUANGSHI = 30059,
		//金属6
		PVE_JINSHU6 = 30060,
		//果实1
		PVE_GUOSHI1 = 30061,
		//果实2
		PVE_GUOSHI2 = 30062,
		//果实3
		PVE_GUOSHI3 = 30063,
		//神奇果实
		PVE_SHENQIGUOSHI = 30064,
		//恶魔的果实
		PVE_EMODEGUOSHI = 30065,
		//果实6
		PVE_GUOSHI6 = 30066,
		//魔法元素1
		PVE_MOFAYUANSU1 = 30067,
		//魔法元素2
		PVE_MOFAYUANSU2 = 30068,
		//魔法碎屑
		PVE_MOFASUIXIE = 30069,
		//魔法碎片
		PVE_MOFASUIPIAN = 30070,
		//魔法元素
		PVE_MOFAYUANSU = 30071,
		//魔法元素6
		PVE_MOFAYUANSU6 = 30072,
		//纸张1
		PVE_ZHIZHANG1 = 30073,
		//纸张2
		PVE_ZHIZHANG2 = 30074,
		//纸张3
		PVE_ZHIZHANG3 = 30075,
		//手纸
		PVE_SHOUZHI = 30076,
		//硬纸板
		PVE_YINGZHIBAN = 30077,
		//纸张6
		PVE_ZHIZHANG6 = 30078,
		//刀具1
		PVE_DAOJU1 = 30079,
		//刀具2
		PVE_DAOJU2 = 30080,
		//水果刀
		PVE_SHUIGUODAO = 30081,
		//锋利的小刀
		PVE_FENGLIDEXIAODAO = 30082,
		//狩猎刀
		PVE_SHOULIEDAO = 30083,
		//刀具6
		PVE_DAOJU6 = 30084,
		//宝石1
		PVE_BAOSHI1 = 30085,
		//宝石2
		PVE_BAOSHI2 = 30086,
		//宝石3
		PVE_BAOSHI3 = 30087,
		//宝石4
		PVE_BAOSHI4 = 30088,
		//宝石5
		PVE_BAOSHI5 = 30089,
		//宝石6
		PVE_BAOSHI6 = 30090,
		//干净的雨水
		PVE_GANJINGDEYUSHUI = 30091,
		//纯净水
		PVE_CHUNJINGSHUI = 30092,
		//植物的汁液
		PVE_ZHIWUDEZHIYE = 30093,
		//融化的雪水
		PVE_RONGHUADEXUESHUI = 30094,
		//神秘水
		PVE_SHENMISHUI = 30095,
		//水珠6
		PVE_SHUIZHU6 = 30096,
		//变异水晶
		PVE_BIANYISHUIJING = 30097,
		//超级火焰药水合成书
		PVE_CHAOJIHUOYANYAOSHUIHECHENGSHU = 24003,
		//超级糖浆合成书
		PVE_CHAOJITANGJIANGHECHENGSHU = 24006,
		//透明泡泡药水合成书
		PVE_TOUMINGPAOPAOYAOSHUIHECHENGSHU = 24007,
		//冲刺药水合成书
		PVE_CHONGCIYAOSHUIHECHENGSHU = 24019,
		//万能药剂合成书
		PVE_WANNENGYAOJIHECHENGSHU = 24020,
		//超强的泻药合成书
		PVE_CHAOQIANGDEXIEYAOHECHENGSHU = 24027,
		//嘲笑药水合成书
		PVE_CHAOXIAOYAOSHUIHECHENGSHU = 24028,
		//小体力药水合成书
		PVE_XIAOTILIYAOSHUIHECHENGSHU = 24044,
		//中体力药水合成书
		PVE_ZHONGTILIYAOSHUIHECHENGSHU = 24045,
		//大体力药水合成书
		PVE_DATILIYAOSHUIHECHENGSHU = 24043,
		//无敌药剂合成书
		PVE_WUDIYAOJIHECHENGSHU = 24047,
		//火焰抵抗药剂合成书
		PVE_HUOYANDIKANGYAOJIHECHENGSHU = 24035,
		//寒冰抵抗药剂合成书
		PVE_HANBINGDIKANGYAOJIHECHENGSHU = 24033,
		//闪电抵抗药剂合成书
		PVE_SHANDIANDIKANGYAOJIHECHENGSHU = 24042,
		//解毒药合成书
		PVE_JIEDUYAOHECHENGSHU = 24037,
		//力量药水合成书
		PVE_LILIANGYAOSHUIHECHENGSHU = 24039,
		//消失药水合成书
		PVE_XIAOSHIYAOSHUIHECHENGSHU = 24049,
		//玫瑰药水合成书
		PVE_MEIGUIYAOSHUIHECHENGSHU = 24040,
		//过期的牛奶合成书
		PVE_GUOQIDENIUNAIHECHENGSHU = 24032,
		//眩晕陷阱合成书
		PVE_XUANYUNXIANJINGHECHENGSHU = 24008,
		//减速陷阱合成书
		PVE_JIANSUXIANJINGHECHENGSHU = 24009,
		//反向陷阱合成书
		PVE_FANXIANGXIANJINGHECHENGSHU = 24010,
		//爆炸陷阱合成书
		PVE_BAOZHAXIANJINGHECHENGSHU = 24018,
		//攻击陷阱合成书
		PVE_GONGJIXIANJINGHECHENGSHU = 24031,
		//力量护符合成书
		PVE_LILIANGHUFUHECHENGSHU = 24011,
		//急速护符合成书
		PVE_JISUHUFUHECHENGSHU = 24012,
		//穿墙护符合成书
		PVE_CHUANQIANGHUFUHECHENGSHU = 24013,
		//探测护符合成书
		PVE_TANCEHUFUHECHENGSHU = 24014,
		//生命护符合成书
		PVE_SHENGMINGHUFUHECHENGSHU = 24026,
		//抵御护符合成书
		PVE_DIYUHUFUHECHENGSHU = 24021,
		//恶魔卷轴合成书
		PVE_EMOJUANZHOUHECHENGSHU = 24015,
		//恐怖卷轴合成书
		PVE_KONGBUJUANZHOUHECHENGSHU = 24016,
		//冰冻卷轴合成书
		PVE_BINGDONGJUANZHOUHECHENGSHU = 24017,
		//变身卷轴合成书
		PVE_BIANSHENJUANZHOUHECHENGSHU = 24025,
		//电动钻头合成书
		PVE_DIANDONGZUANTOUHECHENGSHU = 24023,
		//叉子合成书
		PVE_CHAZIHECHENGSHU = 24022,
		//飞镖合成书
		PVE_FEIBIAOHECHENGSHU = 24024,
		//急救包合成书
		PVE_JIJIUBAOHECHENGSHU = 24036,
		//医疗包合成书
		PVE_YILIAOBAOHECHENGSHU = 24050,
		//盖亚之种合成书
		PVE_GAIYAZHIZHONGHECHENGSHU = 24030,
		//酷比的力量合成书
		PVE_KUBIDELILIANGHECHENGSHU = 24038,
		//无限的糖浆合成书
		PVE_WUXIANDETANGJIANGHECHENGSHU = 24048,
		//黑萎草合成书
		PVE_HEIWEICAOHECHENGSHU = 24034,
		//赤水晶合成书
		PVE_CHISHUIJINGHECHENGSHU = 24051,
		//橙水晶合成书
		PVE_CHENGSHUIJINGHECHENGSHU = 24052,
		//黄水晶合成书
		PVE_HUANGSHUIJINGHECHENGSHU = 24053,
		//绿水晶合成书
		PVE_LUSHUIJINGHECHENGSHU = 24054,
		//青水晶合成书
		PVE_QINGSHUIJINGHECHENGSHU = 24055,
		//蓝水晶合成书
		PVE_LANSHUIJINGHECHENGSHU = 24056,
		//紫水晶合成书
		PVE_ZISHUIJINGHECHENGSHU = 24057,
		//红色礼花合成书
		PVE_HONGSELIHUAHECHENGSHU = 24058,
		//蓝色礼花合成书
		PVE_LANSELIHUAHECHENGSHU = 24059,
		//紫色礼花合成书
		PVE_ZISELIHUAHECHENGSHU = 24060,
		//黄色礼花合成书
		PVE_HUANGSELIHUAHECHENGSHU = 24061,
		//绿色礼花合成书
		PVE_LUSELIHUAHECHENGSHU = 24062,
		//心型礼花合成书
		PVE_XINXINGLIHUAHECHENGSHU = 24063,
		//QQ堂礼花合成书
		PVE_QQTANGLIHUAHECHENGSHU = 24064
	};

	//boss技能
	enum SkillByPVE
	{
		Skill_XXX = 0,
	};

	enum SkillByBoss:INT16
	{
		SKILL_XXXX = 0,

		//爆道具
		SKILL_DROPITEMA = 1,
		//石化波
		SKILL_PETRIFACT = 2,
		//反向
		SKILL_REVERSE = 3,
		//爆道具
		SKILL_DROPITEMB = 4,
		//禁止放泡泡
		SKILL_DISLAYOUTBOMB = 5,
		//爆泡泡
		SKILL_DROPBOMB = 6,
		//发呆
		SKILL_NOTHINGA = 7,
		//允许放泡泡
		SKILL_LAYOUTBOMB = 8,
		//发呆
		SKILL_NOTHINGB = 9,
		//爆道具
		SKILL_DROPITEMC = 10,
		//无敌
		SKILL_UNBEATABLE = 11,
		//爆道具
		SKILL_DROPITEMD = 12,

	};

	//玩家
	enum NPCINDEX:size_t
	{
		NPC_ARBITRATOR = 0xfffffffe,
		NPC_MYSELF = 0xffffffff,
		NPC_00 = 0,
		NPC_01,
		NPC_02,
		NPC_03,
		NPC_04,
		NPC_05,
		NPC_06,
		NPC_07,
		NPC_08,
		NPC_09,
		NPC_10,
		NPC_11,
		NPC_12,
		NPC_13,
		NPC_14,
		NPC_15 = 15,

	};

	//箱子
	enum ItemByBox
	{
		BOX_COMMON_00 = 0,

		BOX_DESERT_01 = 1001,
		BOX_DESERT_02 = 1002,
		BOX_DESERT_03 = 1003,
		BOX_DESERT_04 = 1004,
		BOX_DESERT_05 = 1005,
		BOX_DESERT_06 = 1006,
		BOX_DESERT_07 = 1007,
		BOX_DESERT_08 = 1008,
		BOX_DESERT_09 = 1009,
		BOX_DESERT_10 = 1010,
		BOX_DESERT_11 = 1113,
		BOX_DESERT_12 = 1114,
		BOX_DESERT_13 = 1115,
		BOX_DESERT_14 = 1116,
		BOX_DESERT_15 = 1117,
		BOX_DESERT_16 = 1118,
		BOX_DESERT_17 = 1119,
		BOX_DESERT_18 = 1120,
		BOX_DESERT_19 = 1121,
		BOX_DESERT_20 = 1122,
		BOX_DESERT_21 = 1123,
		BOX_DESERT_22 = 1124,
		BOX_DESERT_23 = 1125,
		BOX_DESERT_24 = 1126,
		BOX_DESERT_25 = 1127,
		BOX_DESERT_26 = 1128,
		BOX_DESERT_27 = 1129,
		BOX_DESERT_28 = 1130,
		BOX_DESERT_29 = 1131,
		BOX_DESERT_30 = 1132,
		BOX_DESERT_31 = 1133,
		BOX_DESERT_32 = 1134,
		BOX_DESERT_33 = 1135,
		BOX_DESERT_34 = 1136,
		BOX_DESERT_35 = 1137,
		BOX_DESERT_36 = 1138,
		BOX_DESERT_37 = 1139,
		BOX_DESERT_38 = 1140,
		BOX_DESERT_39 = 1141,

		BOX_SNOW_01 = 2011,
		BOX_SNOW_02 = 2012,
		BOX_SNOW_03 = 2002,
		BOX_SNOW_04 = 2004,
		BOX_SNOW_05 = 2005,
		BOX_SNOW_06 = 2006,
		BOX_SNOW_07 = 2007,
		BOX_SNOW_08 = 2003,
		BOX_SNOW_09 = 2008,
		BOX_SNOW_10 = 2014,
		BOX_SNOW_11 = 2015,
		BOX_SNOW_12 = 2016,
		BOX_SNOW_13 = 2019,
		BOX_SNOW_14 = 2040,
		BOX_SNOW_15 = 2041,

		BOX_TOWN_01 = 3004,
		BOX_TOWN_02 = 3005,
		BOX_TOWN_03 = 3007,
		BOX_TOWN_04 = 3008,
		BOX_TOWN_05 = 3009,
		BOX_TOWN_06 = 3010,
		BOX_TOWN_07 = 3011,
		BOX_TOWN_08 = 3012,
		BOX_TOWN_09 = 3013,
		BOX_TOWN_10 = 3014,
		BOX_TOWN_11 = 3015,
		BOX_TOWN_12 = 3017,
		BOX_TOWN_13 = 3018,
		BOX_TOWN_14 = 3019,
		BOX_TOWN_15 = 3020,
		BOX_TOWN_16 = 3022,
		BOX_TOWN_17 = 3023,
		BOX_TOWN_18 = 3024,
		BOX_TOWN_19 = 3025,
		BOX_TOWN_20 = 3026,
		BOX_TOWN_21 = 3060,
		BOX_TOWN_22 = 3061,
		BOX_TOWN_23 = 3120,
		BOX_TOWN_24 = 3121,
		BOX_TOWN_25 = 3122,
		BOX_TOWN_26 = 3050,
		BOX_TOWN_27 = 3058,
		BOX_TOWN_28 = 3051,
		BOX_TOWN_29 = 3054,
		BOX_TOWN_30 = 3055,
		BOX_TOWN_31 = 3056,

		BOX_MINE_01 = 4015,
		BOX_MINE_02 = 4027,
		BOX_MINE_03 = 4051,
		BOX_MINE_04 = 4004,
		BOX_MINE_05 = 4005,
		BOX_MINE_06 = 4006,
		BOX_MINE_07 = 4007,
		BOX_MINE_08 = 4008,
		BOX_MINE_09 = 4012,
		BOX_MINE_10 = 4013,
		BOX_MINE_11 = 4014,
		BOX_MINE_12 = 4016,
		BOX_MINE_13 = 4017,
		BOX_MINE_14 = 4018,
		BOX_MINE_15 = 4019,
		BOX_MINE_16 = 4020,
		BOX_MINE_17 = 4021,
		BOX_MINE_18 = 4022,
		BOX_MINE_19 = 4023,
		BOX_MINE_20 = 4024,
		BOX_MINE_21 = 4025,
		BOX_MINE_22 = 4026,
		BOX_MINE_23 = 4028,
		BOX_MINE_24 = 4029,
		BOX_MINE_25 = 4040,
		BOX_MINE_26 = 4041,
		BOX_MINE_27 = 4042,
		BOX_MINE_28 = 4043,
		BOX_MINE_29 = 4044,
		BOX_MINE_30 = 4045,
		BOX_MINE_31 = 4046,
		BOX_MINE_32 = 4047,
		BOX_MINE_33 = 4048,
		BOX_MINE_34 = 4049,
		BOX_MINE_35 = 4050,
		BOX_MINE_36 = 4052,
		BOX_MINE_37 = 4053,
		BOX_MINE_38 = 4054,
		BOX_MINE_39 = 4055,
		BOX_MINE_40 = 4057,
		BOX_MINE_41 = 4058,
		BOX_MINE_42 = 4059,
		BOX_MINE_43 = 4060,
		BOX_MINE_44 = 4070,
		BOX_MINE_45 = 4071,
		BOX_MINE_46 = 4072,
		BOX_MINE_47 = 4083,

		BOX_WATER_01 = 5003,
		BOX_WATER_02 = 5004,
		BOX_WATER_03 = 5005,
		BOX_WATER_04 = 5006,
		BOX_WATER_05 = 5007,
		BOX_WATER_06 = 5008,
		BOX_WATER_07 = 5009,
		BOX_WATER_08 = 5010,
		BOX_WATER_09 = 5011,
		BOX_WATER_10 = 5012,
		BOX_WATER_11 = 5013,
		BOX_WATER_12 = 5014,
		BOX_WATER_13 = 5015,
		BOX_WATER_14 = 5016,
		BOX_WATER_15 = 5017,
		BOX_WATER_16 = 5018,
		BOX_WATER_17 = 5020,
		BOX_WATER_18 = 5021,
		BOX_WATER_19 = 5023,

		BOX_FIELD_01 = 6002,
		BOX_FIELD_02 = 6003,
		BOX_FIELD_03 = 6004,
		BOX_FIELD_04 = 6005,
		BOX_FIELD_05 = 6006,
		BOX_FIELD_06 = 6007,
		BOX_FIELD_07 = 6008,
		BOX_FIELD_08 = 6009,
		BOX_FIELD_09 = 6010,
		BOX_FIELD_10 = 6011,
		BOX_FIELD_11 = 6012,
		BOX_FIELD_12 = 6013,
		BOX_FIELD_13 = 6014,
		BOX_FIELD_14 = 6015,
		BOX_FIELD_15 = 6016,

		BOX_BOMB_01 = 7003,
		BOX_BOMB_02 = 7004,
		BOX_BOMB_03 = 7005,
		BOX_BOMB_04 = 7006,
		BOX_BOMB_05 = 7007,
		BOX_BOMB_06 = 7008,
		BOX_BOMB_07 = 7010,
		BOX_BOMB_08 = 7011,

		BOX_BUN_01 = 8001,
		BOX_BUN_02 = 8002,
		BOX_BUN_03 = 8003,
		BOX_BUN_04 = 8004,
		BOX_BUN_05 = 8005,
		BOX_BUN_06 = 8006,
		BOX_BUN_07 = 8007,
		BOX_BUN_08 = 8008,
		BOX_BUN_09 = 8009,
		BOX_BUN_10 = 8010,
		BOX_BUN_11 = 8012,
		BOX_BUN_12 = 8014,
		BOX_BUN_13 = 8018,
		BOX_BUN_14 = 8019,
		BOX_BUN_15 = 8021,
		BOX_BUN_16 = 8022,
		BOX_BUN_17 = 8023,

		BOX_PIG_01 = 9003,
		BOX_PIG_02 = 9004,
		BOX_PIG_03 = 9005,
		BOX_PIG_04 = 9006,
		BOX_PIG_05 = 9007,
		BOX_PIG_06 = 9008,
		BOX_PIG_07 = 9009,
		BOX_PIG_08 = 9010,
		BOX_PIG_09 = 9011,
		BOX_PIG_10 = 9012,
		BOX_PIG_11 = 9013,
		BOX_PIG_12 = 9014,

		BOX_TREASURE_01 = 10004,
		BOX_TREASURE_02 = 10007,
		BOX_TREASURE_03 = 10008,
		BOX_TREASURE_04 = 10017,
		BOX_TREASURE_05 = 10009,
		BOX_TREASURE_06 = 10012,
		BOX_TREASURE_07 = 10002,
		BOX_TREASURE_08 = 10003,
		BOX_TREASURE_09 = 10005,
		BOX_TREASURE_10 = 10006,
		BOX_TREASURE_11 = 10013,
		BOX_TREASURE_12 = 10014,
		BOX_TREASURE_13 = 10015,
		BOX_TREASURE_14 = 10016,

		BOX_MATCH_01 = 11002,
		BOX_MATCH_02 = 11003,
		BOX_MATCH_03 = 11004,
		BOX_MATCH_04 = 11005,
		BOX_MATCH_05 = 11006,
		BOX_MATCH_06 = 11007,
		BOX_MATCH_07 = 11008,
		BOX_MATCH_08 = 11009,

		BOX_SCULPTURE_01 = 12002,
		BOX_SCULPTURE_02 = 12003,
		BOX_SCULPTURE_03 = 12004,
		BOX_SCULPTURE_04 = 12008,
		BOX_SCULPTURE_05 = 12009,
		BOX_SCULPTURE_06 = 12010,
		BOX_SCULPTURE_07 = 12011,
		BOX_SCULPTURE_08 = 12012,
		BOX_SCULPTURE_09 = 12021,
		BOX_SCULPTURE_10 = 12022,

		BOX_MACHINE_01 = 13009,
		BOX_MACHINE_02 = 13010,
		BOX_MACHINE_03 = 13011,
		BOX_MACHINE_04 = 13012,
		BOX_MACHINE_05 = 13014,
		BOX_MACHINE_06 = 13016,
		BOX_MACHINE_07 = 13017,
		BOX_MACHINE_08 = 13050,
		BOX_MACHINE_09 = 13054,
		BOX_MACHINE_10 = 13055,
		BOX_MACHINE_11 = 13056,
		BOX_MACHINE_12 = 13057,
		BOX_MACHINE_13 = 13007,
		BOX_MACHINE_14 = 13008,
		BOX_MACHINE_15 = 13013,
		BOX_MACHINE_16 = 13020,
		BOX_MACHINE_17 = 13021,
		BOX_MACHINE_18 = 13022,
		BOX_MACHINE_19 = 13024,
		BOX_MACHINE_20 = 13034,
		BOX_MACHINE_21 = 13035,
		BOX_MACHINE_22 = 13037,
		BOX_MACHINE_23 = 13038,
		BOX_MACHINE_24 = 13039,
		BOX_MACHINE_25 = 13040,
		BOX_MACHINE_26 = 13036,
		BOX_MACHINE_27 = 13042,
		BOX_MACHINE_28 = 13043,
		BOX_MACHINE_29 = 13044,
		BOX_MACHINE_30 = 13045,
		BOX_MACHINE_31 = 13046,
		BOX_MACHINE_32 = 13058,
		BOX_MACHINE_33 = 13059,
		BOX_MACHINE_34 = 13060,
		BOX_MACHINE_35 = 13061,
		BOX_MACHINE_36 = 13062,
		BOX_MACHINE_37 = 13063,
		BOX_MACHINE_38 = 13064,
		BOX_MACHINE_39 = 13065,
		BOX_MACHINE_40 = 13066,
		BOX_MACHINE_41 = 13067,
		BOX_MACHINE_42 = 13068,
		BOX_MACHINE_43 = 13069,
		BOX_MACHINE_44 = 13070,
		BOX_MACHINE_45 = 13071,
		BOX_MACHINE_46 = 13072,
		BOX_MACHINE_47 = 13073,
		BOX_MACHINE_48 = 13074,
		BOX_MACHINE_49 = 13075,
		BOX_MACHINE_50 = 13076,
		BOX_MACHINE_51 = 13077,
		BOX_MACHINE_52 = 13078,
		BOX_MACHINE_53 = 13079,

		BOX_BOX_01 = 14007,
		BOX_BOX_02 = 14010,
		BOX_BOX_03 = 14011,
		BOX_BOX_04 = 14109,
		BOX_BOX_05 = 14112,
		BOX_BOX_06 = 14110,
		BOX_BOX_07 = 14022,
		BOX_BOX_08 = 14023,
		BOX_BOX_09 = 14024,
		BOX_BOX_10 = 14025,
		BOX_BOX_11 = 14026,
		BOX_BOX_12 = 14027,
		BOX_BOX_13 = 14028,
		BOX_BOX_14 = 14029,
		BOX_BOX_15 = 14030,
		BOX_BOX_16 = 14031,
		BOX_BOX_17 = 14032,
		BOX_BOX_18 = 14033,
		BOX_BOX_19 = 14036,
		BOX_BOX_20 = 14038,
		BOX_BOX_21 = 14039,
		BOX_BOX_22 = 14040,
		BOX_BOX_23 = 14041,
		BOX_BOX_24 = 14042,
		BOX_BOX_25 = 14043,
		BOX_BOX_26 = 14044,
		BOX_BOX_27 = 14045,
		BOX_BOX_28 = 14046,
		BOX_BOX_29 = 14047,
		BOX_BOX_30 = 14048,
		BOX_BOX_31 = 14049,
		BOX_BOX_32 = 14100,
		BOX_BOX_33 = 14103,
		BOX_BOX_34 = 14104,
		BOX_BOX_35 = 14105,
		BOX_BOX_36 = 14106,
		BOX_BOX_37 = 14107,
		BOX_BOX_38 = 14108,
		BOX_BOX_39 = 14113,
		BOX_BOX_40 = 14114,
		BOX_BOX_41 = 14115,
		BOX_BOX_42 = 14116,
		BOX_BOX_43 = 14117,
		BOX_BOX_44 = 14118,
		BOX_BOX_45 = 14119,
		BOX_BOX_46 = 14120,
		BOX_BOX_47 = 14121,
		BOX_BOX_48 = 14122,
		BOX_BOX_49 = 14123,
		BOX_BOX_50 = 14124,
		BOX_BOX_51 = 14125,
		BOX_BOX_52 = 14126,
		BOX_BOX_53 = 14127,
		BOX_BOX_54 = 14111,

		BOX_PRACTICE_01 = 15010,
		BOX_PRACTICE_02 = 15021,
		BOX_PRACTICE_03 = 15003,
		BOX_PRACTICE_04 = 15004,
		BOX_PRACTICE_05 = 15005,
		BOX_PRACTICE_06 = 15006,
		BOX_PRACTICE_07 = 15007,
		BOX_PRACTICE_08 = 15009,
		BOX_PRACTICE_09 = 15011,
		BOX_PRACTICE_10 = 15012,
		BOX_PRACTICE_11 = 15013,
		BOX_PRACTICE_12 = 15014,
		BOX_PRACTICE_13 = 15015,
		BOX_PRACTICE_14 = 15016,
		BOX_PRACTICE_15 = 15017,
		BOX_PRACTICE_16 = 15018,
		BOX_PRACTICE_17 = 15020,
		BOX_PRACTICE_18 = 15002,
		BOX_PRACTICE_19 = 15008,

		BOX_COMMON_01 = 17068,
		BOX_COMMON_02 = 17054,
		BOX_COMMON_03 = 17103,
		BOX_COMMON_04 = 17104,
		BOX_COMMON_05 = 17109,
		BOX_COMMON_06 = 17059,
		BOX_COMMON_07 = 17060,
		BOX_COMMON_08 = 17061,
		BOX_COMMON_09 = 17018,
		BOX_COMMON_10 = 17019,
		BOX_COMMON_11 = 17021,
		BOX_COMMON_12 = 17022,
		BOX_COMMON_13 = 17023,
		BOX_COMMON_14 = 17024,
		BOX_COMMON_15 = 17025,
		BOX_COMMON_16 = 17026,
		BOX_COMMON_17 = 17027,
		BOX_COMMON_18 = 17028,
		BOX_COMMON_19 = 17029,
		BOX_COMMON_20 = 17039,
		BOX_COMMON_21 = 17046,
		BOX_COMMON_22 = 17047,
		BOX_COMMON_23 = 17048,
		BOX_COMMON_24 = 17050,
		BOX_COMMON_25 = 17056,
		BOX_COMMON_26 = 17063,
		BOX_COMMON_27 = 17067,
		BOX_COMMON_28 = 17069,
		BOX_COMMON_29 = 17070,
		BOX_COMMON_30 = 17072,
		BOX_COMMON_31 = 17073,
		BOX_COMMON_32 = 17074,
		BOX_COMMON_33 = 17075,
		BOX_COMMON_34 = 17076,
		BOX_COMMON_35 = 17077,
		BOX_COMMON_36 = 17078,
		BOX_COMMON_37 = 17079,
		BOX_COMMON_38 = 17080,
		BOX_COMMON_39 = 17081,
		BOX_COMMON_40 = 17082,
		BOX_COMMON_41 = 17083,
		BOX_COMMON_42 = 17100,
		BOX_COMMON_43 = 17101,
		BOX_COMMON_44 = 17102,
		BOX_COMMON_45 = 17058,
		BOX_COMMON_46 = 17051,
		BOX_COMMON_47 = 17052,
		BOX_COMMON_48 = 17053,
		BOX_COMMON_49 = 17055,
		BOX_COMMON_50 = 17057,
		BOX_COMMON_51 = 17062,
		BOX_COMMON_52 = 17064,
		BOX_COMMON_53 = 17065,
		BOX_COMMON_54 = 17066,
		BOX_COMMON_55 = 17105,
		BOX_COMMON_56 = 17106,
		BOX_COMMON_57 = 17107,
		BOX_COMMON_58 = 17108,
		BOX_COMMON_59 = 17110,
		BOX_COMMON_60 = 17111,
		BOX_COMMON_61 = 17112,
		BOX_COMMON_62 = 17113,
		BOX_COMMON_63 = 17114,
		BOX_COMMON_64 = 17115,

		BOX_PVE_01 = 18002,
		BOX_PVE_02 = 18003,
		BOX_PVE_03 = 18004,
		BOX_PVE_04 = 18005,
		BOX_PVE_05 = 18006,
		BOX_PVE_06 = 18007,
		BOX_PVE_07 = 18008,
		BOX_PVE_08 = 18009,
		BOX_PVE_09 = 18020,
		BOX_PVE_10 = 18021,
		BOX_PVE_11 = 18022,
		BOX_PVE_12 = 18023,
		BOX_PVE_13 = 18024,
		BOX_PVE_14 = 18025,
		BOX_PVE_15 = 18026,
		BOX_PVE_16 = 18027,
		BOX_PVE_17 = 18028,
		BOX_PVE_18 = 18101,
		BOX_PVE_19 = 18102,
		BOX_PVE_20 = 18103,
		BOX_PVE_21 = 18104,
		BOX_PVE_22 = 18105,
		BOX_PVE_23 = 18106,
		BOX_PVE_24 = 18107,
		BOX_PVE_25 = 18108,
		BOX_PVE_26 = 18109,
		BOX_PVE_27 = 18111,
		BOX_PVE_28 = 18112,
		BOX_PVE_29 = 18229,
		BOX_PVE_30 = 18230,
		BOX_PVE_31 = 18231,
		BOX_PVE_32 = 18232,
		BOX_PVE_33 = 18233,
		BOX_PVE_34 = 18234,
		BOX_PVE_35 = 18235,
		BOX_PVE_36 = 18236,
		BOX_PVE_37 = 18237,
		BOX_PVE_38 = 18238,
		BOX_PVE_39 = 18239,
		BOX_PVE_40 = 18240,
		BOX_PVE_41 = 18241,
	};

	//地面
	enum  ItemByFloor
	{
		FLOOR_COMMON_001 = 0x03F3,
		FLOOR_COMMON_002 = 0x03F4,
		FLOOR_COMMON_003 = 0x07D1,
		FLOOR_COMMON_004 = 0x07DD,
		FLOOR_COMMON_005 = 0x07E1,
		FLOOR_COMMON_006 = 0x07E2,
		FLOOR_COMMON_007 = 0x07E4,
		FLOOR_COMMON_008 = 0x07E5,
		FLOOR_COMMON_009 = 0x07E6,
		FLOOR_COMMON_010 = 0x07E7,
		FLOOR_COMMON_011 = 0x07E8,
		FLOOR_COMMON_012 = 0x07E9,
		FLOOR_COMMON_013 = 0x07EA,
		FLOOR_COMMON_014 = 0x07EB,
		FLOOR_COMMON_015 = 0x07EC,
		FLOOR_COMMON_016 = 0x07ED,
		FLOOR_COMMON_017 = 0x07EE,
		FLOOR_COMMON_018 = 0x07EF,
		FLOOR_COMMON_019 = 0x07F0,
		FLOOR_COMMON_020 = 0x07F1,
		FLOOR_COMMON_021 = 0x07F2,
		FLOOR_COMMON_022 = 0x07F3,
		FLOOR_COMMON_023 = 0x07F4,
		FLOOR_COMMON_024 = 0x07F5,
		FLOOR_COMMON_025 = 0x07F6,
		FLOOR_COMMON_026 = 0x07F7,
		FLOOR_COMMON_027 = 0x07FA,
		FLOOR_COMMON_028 = 0x07FB,
		FLOOR_COMMON_029 = 0x07FC,
		FLOOR_COMMON_030 = 0x07FD,
		FLOOR_COMMON_031 = 0x07FE,
		FLOOR_COMMON_032 = 0x07FF,
		FLOOR_COMMON_033 = 0x0800,
		FLOOR_COMMON_034 = 0x0801,
		FLOOR_COMMON_035 = 0x0BB9,
		FLOOR_COMMON_036 = 0x0BBA,
		FLOOR_COMMON_037 = 0x0BBB,
		FLOOR_COMMON_038 = 0x0BED,
		FLOOR_COMMON_039 = 0x0BF1,
		FLOOR_COMMON_040 = 0x0BF3,
		FLOOR_COMMON_041 = 0x0FA1,
		FLOOR_COMMON_042 = 0x0FA2,
		FLOOR_COMMON_043 = 0x0FA3,
		FLOOR_COMMON_044 = 0x0FA9,
		FLOOR_COMMON_045 = 0x0FAA,
		FLOOR_COMMON_046 = 0x0FAB,
		FLOOR_COMMON_047 = 0x0FBE,
		FLOOR_COMMON_048 = 0x0FBF,
		FLOOR_COMMON_049 = 0x0FC0,
		FLOOR_COMMON_050 = 0x0FC1,
		FLOOR_COMMON_051 = 0x0FC2,
		FLOOR_COMMON_052 = 0x0FC3,
		FLOOR_COMMON_053 = 0x0FC4,
		FLOOR_COMMON_054 = 0x0FC5,
		FLOOR_COMMON_055 = 0x0FC6,
		FLOOR_COMMON_056 = 0x0FC7,
		FLOOR_COMMON_057 = 0x0FD8,
		FLOOR_COMMON_058 = 0x1389,
		FLOOR_COMMON_059 = 0x138A,
		FLOOR_COMMON_060 = 0x139B,
		FLOOR_COMMON_061 = 0x1771,
		FLOOR_COMMON_062 = 0x1781,
		FLOOR_COMMON_063 = 0x1782,
		FLOOR_COMMON_064 = 0x1783,
		FLOOR_COMMON_065 = 0x1784,
		FLOOR_COMMON_066 = 0x1785,
		FLOOR_COMMON_067 = 0x1786,
		FLOOR_COMMON_068 = 0x1787,
		FLOOR_COMMON_069 = 0x1788,
		FLOOR_COMMON_070 = 0x1B59,
		FLOOR_COMMON_071 = 0x1B5A,
		FLOOR_COMMON_072 = 0x1B64,
		FLOOR_COMMON_073 = 0x1B65,
		FLOOR_COMMON_074 = 0x1F4B,
		FLOOR_COMMON_075 = 0x1F4D,
		FLOOR_COMMON_076 = 0x1F4F,
		FLOOR_COMMON_077 = 0x1F50,
		FLOOR_COMMON_078 = 0x1F51,
		FLOOR_COMMON_079 = 0x2329,
		FLOOR_COMMON_080 = 0x232A,
		FLOOR_COMMON_081 = 0x2711,
		FLOOR_COMMON_082 = 0x271A,
		FLOOR_COMMON_083 = 0x271B,
		FLOOR_COMMON_084 = 0x2AF9,
		FLOOR_COMMON_085 = 0x2EE1,
		FLOOR_COMMON_086 = 0x2EE5,
		FLOOR_COMMON_087 = 0x2EE6,
		FLOOR_COMMON_088 = 0x2EE7,
		FLOOR_COMMON_089 = 0x2EF4,
		FLOOR_COMMON_090 = 0x32C9,
		FLOOR_COMMON_091 = 0x32CA,
		FLOOR_COMMON_092 = 0x32CB,
		FLOOR_COMMON_093 = 0x32CC,
		FLOOR_COMMON_094 = 0x32CD,
		FLOOR_COMMON_095 = 0x32CE,
		FLOOR_COMMON_096 = 0x32D7,
		FLOOR_COMMON_097 = 0x32F7,
		FLOOR_COMMON_098 = 0x32F8,
		FLOOR_COMMON_099 = 0x32F9,
		FLOOR_COMMON_100 = 0x32FB,
		FLOOR_COMMON_101 = 0x32FC,
		FLOOR_COMMON_102 = 0x32FD,
		FLOOR_COMMON_103 = 0x36B1,
		FLOOR_COMMON_104 = 0x36B2,
		FLOOR_COMMON_105 = 0x36B3,
		FLOOR_COMMON_106 = 0x36B4,
		FLOOR_COMMON_107 = 0x36BC,
		FLOOR_COMMON_108 = 0x36BF,
		FLOOR_COMMON_109 = 0x36C0,
		FLOOR_COMMON_110 = 0x36C1,
		FLOOR_COMMON_111 = 0x36D2,
		FLOOR_COMMON_112 = 0x36D3,
		FLOOR_COMMON_113 = 0x36D5,
		FLOOR_COMMON_114 = 0x3715,
		FLOOR_COMMON_115 = 0x3716,
		FLOOR_COMMON_116 = 0x3A99,
		FLOOR_COMMON_117 = 0x3AAB,
		FLOOR_COMMON_118 = 0x3AAF,
		FLOOR_COMMON_119 = 0x4269,
		FLOOR_COMMON_120 = 0x4286,
		FLOOR_COMMON_121 = 0x4289,
		FLOOR_COMMON_122 = 0x428D,
		FLOOR_COMMON_123 = 0x428E,
		FLOOR_COMMON_124 = 0x4290,
		FLOOR_COMMON_125 = 0x4295,
		FLOOR_COMMON_126 = 0x42AF,
		FLOOR_COMMON_127 = 0x42E1,
		FLOOR_COMMON_128 = 0x42E2,
		FLOOR_COMMON_129 = 0x42E3,
		FLOOR_COMMON_130 = 0x42E4,
		FLOOR_COMMON_131 = 0x42E5,
		FLOOR_COMMON_132 = 0x42E6,
		FLOOR_COMMON_133 = 0x42E7,
		FLOOR_COMMON_134 = 0x42E8,
		FLOOR_COMMON_135 = 0x42EA,
		FLOOR_COMMON_136 = 0x42EB,
		FLOOR_COMMON_137 = 0x42EC,
		FLOOR_COMMON_138 = 0x42ED,
		FLOOR_COMMON_139 = 0x42EE,
		FLOOR_COMMON_140 = 0x42EF,
		FLOOR_COMMON_141 = 0x42F0,
		FLOOR_COMMON_142 = 0x42F1,
		FLOOR_COMMON_143 = 0x4719,
		FLOOR_COMMON_144 = 0x471A,
		FLOOR_COMMON_145 = 0x471B,
		FLOOR_COMMON_146 = 0x471C,
		FLOOR_COMMON_147 = 0x471D,
		FLOOR_COMMON_148 = 0x471E,
		FLOOR_COMMON_149 = 0x471F,
		FLOOR_COMMON_150 = 0x4720,
		FLOOR_COMMON_151 = 0x4721,
		FLOOR_COMMON_152 = 0x4722,
		FLOOR_COMMON_153 = 0x4723,
		FLOOR_COMMON_154 = 0x4724,
		FLOOR_COMMON_155 = 0x4725,
		FLOOR_COMMON_156 = 0x4726,
		FLOOR_COMMON_157 = 0x4727,
		FLOOR_COMMON_158 = 0x4728,
		FLOOR_COMMON_159 = 0x4729,
		FLOOR_COMMON_160 = 0x472A,
		FLOOR_COMMON_161 = 0x472B,
		FLOOR_COMMON_162 = 0x472C,
		FLOOR_COMMON_163 = 0x472D,
		FLOOR_COMMON_164 = 0x472E,
		FLOOR_COMMON_165 = 0x472F,
		FLOOR_COMMON_166 = 0x4730,
		FLOOR_COMMON_167 = 0x4731,
		FLOOR_COMMON_168 = 0x4732,
		FLOOR_COMMON_169 = 0x4733,
		FLOOR_COMMON_170 = 0x4734,
	};

	enum BombStatus
	{
		BOMB_FLOOR = 1,
		BOMB_FLY = 3,
		BOMB_EXPLODE = 0,
	};

	enum RoomType
	{
		ROOM_JINGJI = 0,
		ROOM_DAOJUCHANG = 1,
		ROOM_PVE = 2,
		ROOM_QIANGBAOCHANG = 3,
		ROOM_CHAT = 4,
	};

	enum PinDao
	{
		PINDAO_PRACTIVE = 0,
		PINDAO_FRESHMEN = 1,
		PINDAO_FREE = 2,
		PINDAO_ACTION = 3,
		PINDAO_MATCH = 4,
	};

	enum QuYu
	{
		QUYU_EAST = 0,
		QUYU_SOUTH = 1,
		QUYU_WEST = 2,
		QUYU_NORTH = 3,
	};
}
```

`QQTang CheatEngine/QQTangPackage.hpp`:

```hpp
/************************************************************************/
/*
功能说明:数据包
创建人:maple
创建日期:2014年9月2日
修改日期:
*/
/************************************************************************/
#pragma once
#pragma  pack(1) 
#include "Maple.hpp"
#include "MessageLayer.hpp"

#define InitPackage(ClassName)\
ClassName ( )\
{\
memset ( this, 0, sizeof ( ClassName) );\
}

namespace QQTangCheatEngine
{	
	//BASE
	class CDROPPROPINFO
	{
		public:
		INT8 m_DropPropSize;
		class CDROPPROP
		{
			public:
			ItemByGame m_PropID;
			INT8 m_PropY;
			INT8 m_PropX;
		}m_DropProp [ 0x40 ];

	};
	class CPACKAGEBASE
	{
		public:
		INT16 m_PlayerID;
		INT32 m_GameTime;
	};

	//
	class CSendPackageInGame :public CPACKAGEBASE
	{
		public:


		INT32 m_GetTickCount;
		GameID m_GameID;
		INT16 m_Length;
		INT32 m_SendCount;
		UINT8 m_byPackage [ 0x2028 ];
	};

	class CSendPackageInRoom
	{
		public:
		INT32 m_GetTickCount;
		INT16 m_GameID;
		INT16 m_Length;
		INT32 m_SendCount;
		UINT8 m_byPackage [ 0xFF4 ];
		 
	};
 
	class CALLPLAYERINFOINROOM
	{
		public:
		INT32 m_PlayerCount;
		UINT32 m_QQ [ 8 ];
		INT16 m_PlayerID [ 8 ];
	};

	// 	//玩家移动 房间里
	// 	P2P_PLAYERMOVEINROOM = 0xBB8,
	class CPLAYERMOVEINROOM
	{
		public:
		INT8 m_PlayerNO;
		INT32 m_PlayerX;
		INT32 m_PlayerY;
		INT32 m_PlayerFace;
		float m_PlayerMove;
	};

	// 	//玩家放泡泡 房间里
	// 	P2P_PLAYERLAYOUTBOMBINROOM = 0xBB9,
	class CPLAYERLAYOUTBOMBINROOM
	{
		public:
		UINT8 m_PlayerNO;
		INT32 m_PlayerX;
		INT32 m_PlayerY;
	};

	// 	//玩家移动数据包
	// 	P2P_NPCMOVE = 0xFA2,
	class npcmove
	{

	};


	// 	//放泡泡
	// 	P2P_LAYOUTBOMB = 0xFA3,
	class CLAYOUTBOMB :public CPACKAGEBASE
	{
		public:
		UINT32 m_BombType;
		INT8 m_BombY;
		INT8 m_BombX;
		INT16 m_BombPower;
		bool m_IsHide;

		public:
		CLAYOUTBOMB(){}
		//放泡泡
		CLAYOUTBOMB ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromClinet ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_BombY = ( INT8 ) pPlayer->GetPlayerInMapY ( );
			m_BombX = ( INT8 ) pPlayer->GetPlayerInMapX ( );
			m_BombPower = ( INT16 ) pPlayer->GetNPCItem ( )->GetBombPower ( );
			m_IsHide = pPlayer->IsItemUsing ( );
		}
		//复制泡泡
		CLAYOUTBOMB ( PPlyaer pdest, PPlyaer pscr )
		{
			m_PlayerID = pscr->GetIDFromClinet ( );
			m_GameTime = pdest->GetGameInfo ( )->GetGameTime ( );
			m_BombY = ( INT8 ) pdest->GetPlayerInMapY ( );
			m_BombX = ( INT8 ) pdest->GetPlayerInMapX ( );
			m_BombPower = ( INT16 ) pdest->GetNPCItem ( )->GetBombPower ( );
			m_IsHide = pdest->IsItemUsing ( );
		}
		//放泡泡指定位置
		CLAYOUTBOMB ( PPlyaer pPlayer, CLocation& XY )
		{
			m_PlayerID = pPlayer->GetIDFromClinet ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_BombY = ( INT8 ) XY.GetY ( );
			m_BombX = ( INT8 ) XY.GetX ( );
			m_BombPower = ( INT16 ) pPlayer->GetNPCItem ( )->GetBombPower ( );
			m_IsHide = pPlayer->IsItemUsing ( );
		}


	};

	// 	//爆炸信息
	// 	P2P_EXPLODEINFO = 0xFA4,
	class CEXPLODEINFO :public CPACKAGEBASE
	{
		public:
		INT8 m_BombExplodeSize;
		class CBombExplode
		{
			public:
			INT16 m_BomberID;
			INT32 m_BombTime;
			INT8 m_BombMode;
			INT8 m_BombY;
			INT8 m_BombX;
			INT8 m_BombUp;
			INT8 m_BombDown;
			INT8 m_BombLeft;
			INT8 m_BombRigth;
		}m_BombExplode [ 64 ];

		INT8 m_BoxExplodeSize;
		class CBoxExplode
		{
			public:
			INT16 m_BoxID;
			INT8 m_BoxY;
			INT8 m_BoxX;
		}m_BoxExplode [ 32 ];

		INT8 m_PropExplodeSize;
		class CPropExplode
		{
			public:
			ItemByGame m_PropID;
			INT8 m_PropY;
			INT8 m_PropX;
		}m_PropExplode [ 32 ];
		CEXPLODEINFO ( ) { }
		CEXPLODEINFO ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
		}

	};
	enum 
	{
		CEXPLODEINFOSIZE = sizeof ( CEXPLODEINFO ),
	};

	// 	//进果冻
	// 	P2P_INJELLY = 0xFA5,
	class CINJELLY :public CPACKAGEBASE
	{
		public:
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		bool m_HadAvatar;
		public:
		CINJELLY ( ){ }
		CINJELLY ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_PlayerX = ( INT16 ) ( pPlayer->GetNPCX ( ) );
			m_PlayerY = ( INT16 ) ( pPlayer->GetNPCY ( ) );
			m_HadAvatar = pPlayer->GetAvatarInfo ( ) != NULL;
		}
	};

	// 	//NPC屎亡
	// 	P2P_NPCDIE = 0xFA7,
	class CNPCDIE :public CPACKAGEBASE
	{
		public:
		INT16 m_PlayerY;
		INT16 m_PlayerX;

		CDROPPROPINFO m_DropPropInfo;
		CNPCDIE(){}
		CNPCDIE ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_PlayerY = ( INT16 ) pPlayer->GetNPCX ( );
			m_PlayerX = ( INT16 ) pPlayer->GetNPCY ( );

		};
	};

	// 	//通知KO玩家
	// 	P2P_NOTIFYNPCKILL = 0xFA8,
	// 	//KO玩家
	// 	P2P_NPCKILL = 0xFA9,
#define CNOTIFYNPCKILL CNPCKILL
	class CNPCKILL :public CPACKAGEBASE
	{
		public:
		INT16 m_DaedID;
		INT16 m_KillerX;
		INT16 m_KillerY;
		CDROPPROPINFO m_DropPropInfo;
		CNPCKILL(){}
		CNPCKILL ( PPlyaer pKiller, PPlyaer pDaedID )
		{
			m_PlayerID = pKiller->GetIDFromServer ( );
			m_GameTime = pKiller->GetGameInfo ( )->GetGameTime ( );
			m_KillerX = ( INT16 ) pDaedID->GetNPCX ( );
			m_KillerY = ( INT16 ) pDaedID->GetNPCY ( );
			m_DaedID = pDaedID->GetIDFromServer ( );
		}
	};

	// 	//通知玩家救人
	// 	P2P_NOTIFYNPCSAVE = 0xFAA,
	// 	//玩家救人
	// 	P2P_NPCSAVE = 0xFAB,
#define CNOTIFYNPCSAVE CNPCSAVE
	class CNPCSAVE :public CPACKAGEBASE
	{
		public:
		INT16 m_DeadID;
		INT16 m_SaverX;
		INT16 m_SaverY;
		//自己9刷分
		CNPCSAVE(){}

		CNPCSAVE ( PPlyaer pSaver )
		{
			m_PlayerID = pSaver->GetIDFromServer ( );
			m_GameTime = pSaver->GetGameInfo ( )->GetGameTime ( );
			m_DeadID = pSaver->GetIDFromServer ( );
			m_SaverX = ( INT16 ) pSaver->GetNPCX ( );
			m_SaverY = ( INT16 ) pSaver->GetNPCY ( );
		}
		//9别人
		CNPCSAVE ( PPlyaer pSaver, PPlyaer pDead )
		{
			m_PlayerID = pSaver->GetIDFromServer ( );
			m_GameTime = pSaver->GetGameInfo ( )->GetGameTime ( );
			m_DeadID = pDead->GetIDFromServer ( );
			m_SaverX = ( INT16 ) pSaver->GetNPCX ( );
			m_SaverY = ( INT16 ) pSaver->GetNPCY ( );
		}
	};

	// 	//通知获取道具
	// 	P2P_NOTIFYNPCGETITEM = 0xFAC,
	//	//获取道具
	//	P2P_NPCGETITEM = 0xFAD,
#define CNOTIFYNPCGETITEM NPCGETITEM
	class CNPCGETITEM :public CPACKAGEBASE
	{
		public:
		ItemByGame m_PropID;
		union 
		{
			struct 
			{
				INT16 m_GeterX;
				INT16 m_GeterY;
			};
			struct
			{
				INT16 m_ItemX;
				INT16 m_ItemY;
			};
		};

		CNPCGETITEM ( ) { }
		CNPCGETITEM ( PPlyaer pGeter, ItemByGame propid )
		{
			m_PlayerID = pGeter->GetIDFromClinet ( );
			m_GameTime = pGeter->GetGameInfo ( )->GetGameTime ( );
			m_GeterX = (INT16)pGeter->GetNPCX ( );
			m_GeterY = (INT16)pGeter->GetNPCY ( );
			m_PropID = propid;
		}
		CNPCGETITEM ( PPlyaer pGeter, PGameItem pProp )
		{
			m_PlayerID = pGeter->GetIDFromClinet ( );
			m_GameTime = pGeter->GetGameInfo ( )->GetGameTime ( );
			m_PropID = pProp->GetItemID ( );
			m_GeterX = pProp->GetItemInPlayerX ( );
			m_GeterY = pProp->GetItemInPlayerY ( );
		}
		BOOL IsPropToServer ( )
		{
			switch ( m_PropID )
			{
				//81
				case QQTangCheatEngine::GAME_TONGBI:
				{
					return TRUE;
				}
					//82
				case QQTangCheatEngine::GAME_YINBI:
				{
					return TRUE;
				}
					//83
				case QQTangCheatEngine::GAME_JINBI:
				{
					return TRUE;
				}
					//84
				case QQTangCheatEngine::GAME_QIANDAI:
				{
					return TRUE;
				}
					//85
				case QQTangCheatEngine::GAME_BAOXIANG1000TB:
				{
					return TRUE;
				}
					//91
				case QQTangCheatEngine::GAME_HONGZUANSHI:
				{
					return TRUE;
				}
					//92
				case QQTangCheatEngine::GAME_LANZUANSHI:
				{
					return TRUE;
				}
					//211
				case QQTangCheatEngine::GAME_ZIZUANSHI:
				{
					return TRUE;
				}
					//212
				case QQTangCheatEngine::GAME_XUEPINGZI:
				{
					return TRUE;
				}
					//213
				case QQTangCheatEngine::GAME_HUANGLUOSI:
				{
					return TRUE;
				}
					//93
				case QQTangCheatEngine::GAME_TANGBI1000:
				{
					return TRUE;
				}
					//94
				case QQTangCheatEngine::GAME_TANGBI500:
				{
					return TRUE;
				}
					//86
				case QQTangCheatEngine::GAME_JINGYAN20:
				{
					return TRUE;
				}
					//87
				case QQTangCheatEngine::GAME_JINGYAN50:
				{
					return TRUE;
				}
					//88
				case QQTangCheatEngine::GAME_JINGYAN100:
				{
					return TRUE;
				}
					//89
				case QQTangCheatEngine::GAME_JINGYAN200:
				{
					return TRUE;
				}
					//96
				case QQTangCheatEngine::GAME_MEIGUI1:
				{
					return TRUE;
				}
					//97
				case QQTangCheatEngine::GAME_LVSHUIJING:
				{
					return TRUE;
				}
					//98
				case QQTangCheatEngine::GAME_KUBI:
				{
					return TRUE;
				}
					//150
				case QQTangCheatEngine::GAME_HONGBAOSHI:
				{
					return TRUE;
				}
					//151
				case QQTangCheatEngine::GAME_HUANGBAOSHI:
				{
					return TRUE;
				}
					//152
				case QQTangCheatEngine::GAME_LVBAOSHI:
				{
					return TRUE;
				}
					//402
				case QQTangCheatEngine::GAME_MEIGUI2:
				{
					return TRUE;
				}
					//403
				case QQTangCheatEngine::GAME_DIARY:
				{
					return TRUE;
				}
			}

			if ( ( m_PropID < 400 || m_PropID > 1000 ) &&
				 ( m_PropID <= 24000 || m_PropID >= 24500 ) &&
				 ( m_PropID <= 30000 || m_PropID >= 32000 ) &&
				 ( m_PropID < 25001 || m_PropID > 29000 ) &&
				 ( m_PropID < 9001 || m_PropID > 9010 ) )
			{
				return FALSE;
			}
			return TRUE;
		}
	};

	// 	//飞机爆道具
	// 	P2P_PLANEDROPITEM = 0xFAE,
	class CPLANEDROPITEM
	{
		public:
		INT32 m_GameTime;
		CDROPPROPINFO m_DropItemInfo;

		INT8 m_DropItemSize;
		class CDropItemInfoEx
		{
			ItemByGame m_PropItem;
			ItemByGame m_PropItemEx;
			INT8 m_PropY;
			INT8 m_PropX;
		}m_DropItemInfoEx [ 0x20 ];

	};

	// 	//通知使用技能
	// 	P2P_NOTIFYNPCUSESKILL = 0xFAF,
	// 	//通知使用道具
	// 	P2P_NOTIFYNPCUSEPROP = 0xFAF,
	// 	//使用技能
	// 	P2P_NPCUSESKILL = 0xFB0,
	// 	//使用道具
	// 	P2P_NPCUSEPROP = 0xFB0,
#define CNOTIFYNPCUSESKILL CNPCUSEPROP
#define CNOTIFYNPCUSEPROP CNPCUSEPROP
#define CNPCUSESKILL CNPCUSEPROP
	class CNPCUSEPROP :public CPACKAGEBASE
	{
		public:
		union
		{
			INT32 m_PropID;
			INT32 m_SkillID;
		};
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		BOOL m_GlobalSkill;
		INT32 m_PlayerFace;
		INT32 m_SkillY;
		INT32 m_SkillX;

	};
	enum
	{
		CNPCUSEPROPSIZE = sizeof ( CNPCUSEPROP ),
	};


#define CNOTIFYPUSHBOX cpushbox
	class cpushbox
	{

	};

	// 	//玩家固定位置
	// 	P2P_PLAYERFIXED = 0xFB5,
	class CPLAYERFIXED :public CPACKAGEBASE
	{
		public:
		ItemByGame m_PropID;
		INT16 m_PlyaerX;
		INT16 m_PlayerY;
		INT32 m_v1;
		INT32 m_v2;
		INT32 m_v3;
		INT32 m_v4;
		//INT16 m_v2;
	};

	// 	//通知包子出房间
	// 	P2P_NOTIFYGETBUNOUTROOM = 0xFB6,
	// 		//包子出房间
	// 		P2P_GETBUNOUTROOM = 0xFB7,
	// 		//通知包子进房间
	// 		P2P_NOTIFYGETBUNINROOM = 0xFB8,
	// 		//包子进房间
	// 		P2P_GETBUNINROOM = 0xFB9,
#define  CNOTIFYGETBUNOUTROOM CGETBUNOUTROOM
#define  CNOTIFYGETBUNINROOM CGETBUNOUTROOM
#define  CGETBUNINROOM CGETBUNOUTROOM
	class CGETBUNOUTROOM :public CPACKAGEBASE
	{
		public:
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		INT8 m_GameIDType;
		union
		{
			UINT8 m_BunColor;
			UINT8 m_SculptureType;
		};
	};
	enum
	{
		CGETBUNOUTROOMSIZE = sizeof ( CGETBUNOUTROOM ),
	};

	// 	//玩家复活
	// 	P2P_NPCRELIVE = 0xFBA,
	class CNPCRELIVE :public CPACKAGEBASE
	{
		public:
		INT8 m_ReliveX;
		INT8 m_ReliveY;
		CNPCRELIVE() {}
		CNPCRELIVE ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_ReliveX = ( INT8 ) pPlayer->GetReLiveX ( );
			m_ReliveY = ( INT8 ) pPlayer->GetReLiveY ( );
		}
	};

	// 	//推箱子爆炸
	// 	P2P_PUSHBOXEXPLODE = 0xFBE,
	class cpushboxexplode
	{

	};

	// 	//玩家变身结束
	// 	P2P_NPCAVATARDISAPPEAR = 0x10E0,
	class CNPCAVATARDISAPPEAR :public CPACKAGEBASE
	{
		public:
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		CNPCAVATARDISAPPEAR(){}
		CNPCAVATARDISAPPEAR ( PPlyaer pPlayer )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_PlayerX = ( INT16 ) pPlayer->GetNPCX ( );
			m_PlayerY = ( INT16 ) pPlayer->GetNPCY ( );
		}
	};

	// 	//足球飞泡泡
	// 	P2P_GAMEDROPBOMB = 0x10E1,
	class cgamedropbomb
	{

	};

	// 	//玩家掉血
	// 	P2P_NPCHPLOSS = 0x10F4,
	class CNPCHPLOSS :public CPACKAGEBASE
	{
		public:
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		bool m_HadAvatar;
		INT16 m_Hp;
		CNPCHPLOSS(){}
		CNPCHPLOSS ( PPlyaer pPlayer, INT16 IsAdd )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
			m_PlayerX = ( INT16 ) pPlayer->GetNPCX ( );
			m_PlayerY = ( INT16 ) pPlayer->GetNPCY ( );
			m_HadAvatar = pPlayer->GetItemInfo ( )->GetAvatar ( );

			m_Hp = ( INT16 ) -pPlayer->GetNPCItem ( )->GetHP ( )->GetValue ( TRUE );
			m_Hp *= IsAdd;
		}
	};

	// 	//创建箱子
	// 	P2P_CREATEBOX = 0x1168,
	class CCREATEBOX
	{
		public:
		INT8 m_CreateBoxSize;
		class CREATEBOXINFO
		{
			public:
			INT16 m_BoxID;
			INT32 m_BoxCode;
			INT8 m_BoxY;
			INT8 m_BoxX;
		}m_CreateBoxInfo [ 0x20 ];
	};

	// 	//BOSS 技能
	// 	P2P_BOSSSKILL = 0x1169,
	class CBOSSSKILL :public CPACKAGEBASE
	{
		public:
		short m_PlayerX;
		short m_PlayerY;
		SkillByBoss m_SkillID;
		CDROPPROPINFO m_DropPropInfo;
	};
 
	// 	//BOSS 说话
	// 	P2P_BOSSSPEAK = 0x116A,
	class CBOSSSPEAK
	{
		public:
		INT16 m_PlayerID;
		INT16 m_Length;
		char szText [ 0x200 ];
		CBOSSSPEAK ( PPlyaer pPlayer, char* pszText )
		{
			m_PlayerID = pPlayer->GetIDFromServer ( );
			m_Length = strlen ( pszText );
			strcpy ( szText, pszText );
		}
	};

	// 	//BOSS爆道具
	// 	P2P_BOSSDROPITEM = 0x116B,
	class CBOSSDROPITEM
	{
		public:
		INT16 m_BossID;
		INT16 m_BossX;
		INT16 m_BossY;
		CDROPPROPINFO m_DropPropInfo;
	};

	// 	//位置跨门
	// 	P2P_TRANSDOOR = 0x1176,
	class CTRANSDOOR
	{
		public:
		INT16 m_TranType;
		INT16 m_PlayerID;
		INT32 m_GameTime;
		INT16 TX;
		INT16 TY;
		INT16 RX;
		INT16 RY;
	};

	// 	//玩家表情
	// 	P2P_NPCEXPRESSION = 0x1194,
	class CNPCEXPRESSION :public CPACKAGEBASE
	{
		public:
		PlayerExpression m_Expression;
		CNPCEXPRESSION(){}
		CNPCEXPRESSION(PPlyaer pPlayer, PlayerExpression Expression)
		{
			m_PlayerID = pPlayer->GetIDFromServer();
			m_GameTime = pPlayer->GetGameInfo()->GetGameTime();
			m_Expression = Expression;
		}
	};

	// 	//创建BOSS
	// 	P2P_CREATEBOSS = 0x1389,
	class CCREATEBOSS
	{
		public:
		INT32 m_define;
		INT16 m_BossID;
		UINT8 m_Model;
		UINT8 m_Color;
		INT32 m_Status;
		INT16 m_BOSSX;
		INT16 m_BOSSY;
		INT16 m_Hp;

		INT32 m_MinSpeed;
		INT32 m_MinBomb;
		INT16 m_MinPower;
		CDROPPROPINFO m_DropPropItemA [ 0xA ];
		INT8 m_bytes [ 0x4C ];
		INT32 m_defineA;
		CDROPPROPINFO m_DropPropItemB [ 0xA ];
		INT16 m_Size;
		INT32 m_SizeInfo [ 0xA ];
		INT8 m_bytesA [ 0x84 ];

	};

	// 	//通知玩家退出
	// 	S2C_NOTIFYPLAYERQUITGAME = 0x10EC,
	class CNOTIFYPLAYERQUITGAME
	{
		public:
		INT16 m_PlayerID;
		CNOTIFYPLAYERQUITGAME(){}
		CNOTIFYPLAYERQUITGAME(PPlyaer pPlayer)
		{
			m_PlayerID = pPlayer->GetIDFromServer();
		}
	};



	// 		//通知游戏结束
	// 	S2C_NOTIFYGAMEOVER = 0xFBB,
	class CNOTIFYGAMEOVER
	{
		public:
		CNOTIFYGAMEOVER(){}

	};

	// 		//通知新仲裁
	// 	S2C_NOTIFYNEWARBITRATION = 0xFB1,
	class CNOTIFYNEWARBITRATION
	{
		public:
		INT16 m_PlayerID;
		CNOTIFYNEWARBITRATION(){}
	};


	// 	//使用道具调整位置
	// 	S2C_0xADJUSTPOSITION = 0x1175,
	class CADJUSTPOSITION
	{
		public:
		INT16 m_PlayerID;
		ItemByGame m_PropID;
		INT16 m_PlayerX;
		INT16 m_PlayerY;
		INT32 m_GameTime;
		UINT8 m_PlayerFace;
	};


	// 	//探险进图
	// 	C2S_NEXTPVEMAP = 0x1178,
	class CNEXTPVEMAP :public CPACKAGEBASE
	{
		public:
		INT32 m_ContinueID = 0;
		INT32 m_MapIndex = 0;

	};

	//	//糖果站房子爆炸
	//	C2S_TANKROOMEXPLODE = 0x15B3,
	class CTANKROOMEXPLODE :public CPACKAGEBASE
	{
		public:
		INT16 m_TankColor = 0;
		INT16 m_TankHP = 0;
		CTANKROOMEXPLODE(){}
		CTANKROOMEXPLODE ( PPlyaer pMySelf )
		{
			auto *pRoom = pMySelf->GetGameInfo ( )->GetTankRoomA ( );
			if ( pRoom->GetRoomColor ( ) == pMySelf->GetPlayerTeamColor ( ) )
			{
				pRoom = pMySelf->GetGameInfo ( )->GetTankRoomB ( );
			}
			m_TankColor = pRoom->GetRoomColor ( );
			m_TankHP = -pRoom->GetTaskHp ( );
		}
	};

// 	//足球飞泡泡
// 	P2P_GAMEDROPBOMB = 0x10E1,
	class CGAMEDROPBOMB :public CPACKAGEBASE
	{
		public:
		INT8 m_DropBombSize;
		class CDROPBOMBINFO
		{
			INT32 m_BombType;
			INT8 m_BombPower;
			INT8 m_BombY;
			INT8 m_BombX;
		}m_DropBombInfo [ 0x20 ];
		CDROPPROPINFO m_DropPropInfo;
	};
// 	class CNOTIFYMACHINESKILL
// 	{
// 		protected:
// 		UINT8 EncodeOfPlayerFace;
// 		bool isMachineSkill;
// 		UINT8 XY;
// 		INT16 PlayerID;
// 		public:
// 		CNOTIFYMACHINESKILL ( CMessageLayer* pLayer, CPlayer* pPlayer )
// 		{
// 			PlayerID = pPlayer->GetIDFromClinet ( );
// 
// 			EncodeOfPlayerFace = pPlayer->GetPlayerFace ( );;
// 			EncodeOfPlayerFace <<= 4;
// 			EncodeOfPlayerFace += ( UINT8 ) pLayer->GetTimeSub ( );
// 
// 			isMachineSkill = pPlayer->GetGameInfo ( )->
// 				GetMachineSkill ( ) == pPlayer->GetPlayerTeamColor ( );
// 
// 			XY = ( INT8 ) pPlayer->GetPlayerInMapY ( );
// 			XY <<= 4;
// 			XY += pPlayer->GetPlayerInMapX ( );
// 		}
// 	};
// 
// 	class CMACHINESKILL :public CNOTIFYMACHINESKILL
// 	{
// 		public:
// 		CMACHINESKILL ( CMessageLayer* pLayer, CPlayer* pPlayer ) :
// 			CNOTIFYMACHINESKILL ( pLayer, pPlayer )
// 		{
// 			UINT8 byEncode = EncodeOfPlayerFace & 0xF;
// 			INT8 Encode = ( INT8 ) ( EncodeOfPlayerFace >> 4 );
// 			if ( byEncode > -1 && byEncode < 8 && !pPlayer->IsPlayerYear ( PlayerID ) )
// 			{
// 				EncodeOfPlayerFace = ( UINT8 ) ( ( Encode << 4 ) + 9 );
// 			}
// 			if ( byEncode < 8 )
// 			{
// 				bool IsSkill;
// 				if ( isMachineSkill )
// 				{
// 					IsSkill = ( Encode == 0 );
// 				}
// 				else
// 				{
// 					IsSkill = ( Encode == 2 );
// 				}
// 				if ( !IsSkill )
// 				{
// 					EncodeOfPlayerFace = ( UINT8 ) ( ( Encode << 4 ) + 9 );
// 				}
// 			}
// 		}
// 	};
// 
// 	class CNOTIFYBOXEXPLODE :public CPACKAGEBASE
// 	{
// 		public:
// 		INT16 m_PlayerX;
// 		INT16 m_PlayerY;
// 		INT16 m_BoxID;
// 		INT32 m_PushBox;
// 		INT8 m_BoxX;
// 		INT8 m_BoxY;
// 		public:
// 		CNOTIFYBOXEXPLODE ( PPlyaer pPlayer )
// 		{
// 			m_PlayerID = pPlayer->GetIDFromClinet ( );
// 			m_GameTime = pPlayer->GetGameInfo ( )->GetGameTime ( );
// 			m_PlayerX = ( INT16 ) pPlayer->GetPlayerX ( );
// 			m_PlayerY = ( INT16 ) pPlayer->GetPlayerY ( );
// 		}
// 		void SetGameBox ( PGameBox pGamebox )
// 		{
// 			m_BoxID = pGamebox->GetBoxID ( );
// 			m_PushBox = pGamebox->GetPushBox ( );
// 			m_BoxX = pGamebox->GetLocation ( )->GetX ( );
// 			m_BoxY = pGamebox->GetLocation ( )->GetY ( );
// 		}
// 	};


// 	//机械大炮
// 	P2P_MACHINEARTILLERY = 0x10F3,
	class CMACHINEARTILLERY:public CPACKAGEBASE
	{
		public:
		INT8 m_BombSize;
		INT32 m_BombType;
		INT8 m_BombLength;
		INT8 m_BombY;
		INT8 m_BombX;
	};


// 	//踢泡泡
// 	P2P_PLAYBOMB = 0xFB4,
	class CPLAYBOMB
	{
		public:
		//0 1
		INT16 m_PlayerID;
		//2 3
		INT16 m_GameTime;
		// 4 5 6 7
		CLocation m_OldYX;
		//8 9 A B
		CLocation m_NewYX;
		//C
		UINT8 m_PlayerFace;
		//D E
		INT16 m_BomberID;
		//F 10 11 12
		INT32 m_BombTime;
		// 13
		INT8 m_BombPower;
	};

}



```

`QQTang CheatEngine/RoomInfo.hpp`:

```hpp
/*********************************************************************** /
/*
功能说明:
创建人:maple
创建日期:2014年9月2日
修改人:
修改日期:
*/
/************************************************************************/
#pragma once
#pragma pack(1)
#include "Maple.hpp"
#include "QQTEncoder.hpp"
#include "QQTangPackage.hpp"

#define PRoomInfo CRoomInfo*
#define PRoom CRoom*
namespace QQTangCheatEngine
{
	class CRoom4Base
	{
		//48 个fun
		virtual void Fun00 ( ) = 0;
		virtual void Fun01 ( ) = 0;
		virtual void Fun02 ( ) = 0;
		virtual void Fun03 ( ) = 0;
		virtual void Fun04 ( ) = 0;
		virtual void Fun05 ( ) = 0;
		virtual void Fun06 ( ) = 0;
		virtual void Fun07 ( ) = 0;
		virtual void Fun08 ( ) = 0;
		virtual void Fun09 ( ) = 0;

		virtual void Fun10 ( ) = 0;
		virtual void Fun11 ( ) = 0;
		virtual void Fun12 ( ) = 0;
		virtual void Fun13 ( ) = 0;
		virtual void Fun14 ( ) = 0;
		virtual void Fun15 ( ) = 0;
		virtual void Fun16 ( ) = 0;
		virtual void Fun17 ( ) = 0;
		virtual void Fun18 ( ) = 0;
		virtual void Fun19 ( ) = 0;

		virtual void Fun20 ( ) = 0;
		virtual void Fun21 ( ) = 0;
		virtual void Fun22 ( ) = 0;
		virtual void Fun23 ( ) = 0;
		virtual void Fun24 ( ) = 0;
		virtual void Fun25 ( ) = 0;
		virtual void Fun26 ( ) = 0;
		virtual void Fun27 ( ) = 0;
		virtual void Fun28 ( ) = 0;
		virtual void Fun29 ( ) = 0;

		virtual void Fun30 ( ) = 0;
		virtual void Fun31 ( ) = 0;
		virtual void Fun32 ( ) = 0;
		virtual void Fun33 ( ) = 0;
		virtual void Fun34 ( ) = 0;
		virtual void Fun35 ( ) = 0;
		virtual void Fun36 ( ) = 0;
		virtual void Fun37 ( ) = 0;
		virtual void Fun38 ( ) = 0;
		virtual void Fun39 ( ) = 0;

		virtual void Fun40 ( ) = 0;
		virtual void Fun41 ( ) = 0;
		virtual void Fun42 ( ) = 0;
		virtual void Fun43 ( ) = 0;
		virtual void Fun44 ( ) = 0;
		virtual void Fun45 ( ) = 0;
		virtual void Fun46 ( ) = 0;
		virtual void Fun47 ( ) = 0;

		public:
	};
	class CRoomInfoBase
	{
		public:
		virtual void FunA ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void FunB ( INT32 a ) = 0;
		virtual void FunC ( INT32 a ) = 0;
		virtual void FunD ( INT32 a, INT32 b ) = 0;

		virtual void FunE ( INT32 a ) = 0;
		virtual void FunF ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f, INT32 g ) = 0;
		virtual void FunG ( INT32 a ) = 0;
		virtual void FunH ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;

		virtual void FunI ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void SendDataToClient ( LPVOID pRoomInfo, DWORD dwPackageSize, LPVOID pPackage, INT32 PackageType ) = 0;

		virtual void FunK ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f ) = 0;
		virtual void FunL ( INT32 a, INT32 b, INT32 c, INT32 d ) = 0;
		virtual void FunM ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void FunN ( INT32 a, INT32 b, INT32 c, INT32 e, INT32 f ) = 0;
		virtual void FunO ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f ) = 0;
		virtual void FunP ( INT32 a, INT32 b, INT32 c ) = 0;
		virtual void FunQ ( INT32 a, INT32 b ) = 0;
		virtual void FunR ( INT32 a ) = 0;
		virtual void FunS ( INT32 a, INT32 b, INT32 c, INT32 e, INT32 f ) = 0;

	};

	class CCBase
	{
		public:
		virtual void Fun_1 ( ) = 0;
		virtual void Fun_2 ( INT32 a ) = 0;
		virtual void Fun_3 ( INT32 A ) = 0;
		virtual void Fun_4 ( ) = 0;
		virtual void Fun_5 ( INT32 A ) = 0;
		virtual void Fun_6 ( ) = 0;
		virtual void Fun_7 ( ) = 0;
		virtual void Fun_8 ( ) = 0;
		virtual void Fun_9 ( ) = 0;
		virtual void Fun_A ( INT32 A ) = 0;
		virtual void Fun_B ( INT32 A ) = 0;
		virtual void Fun_C ( ) = 0;
		virtual void Fun_D ( ) = 0;
		virtual void Fun_E ( ) = 0;
		virtual void Fun_F ( INT32 A ) = 0;
		virtual void Fun_G ( ) = 0;
		virtual void Fun_H ( ) = 0;
		virtual void Fun_I ( ) = 0;

	};
	class C4Base
	{
		public:
		virtual void FunG ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
		virtual void FunH ( ) = 0;
		virtual void FunI ( INT32 A ) = 0;
	};

	class CPlayerInfoInRoomBase
	{
		public:
		virtual void FunA ( ) = 0;
		virtual void FunB ( INT32 a, INT32 b ) = 0;
		virtual void FunC ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f, INT32 g ) = 0;
		virtual void FunD ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
		virtual void FunE ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) = 0;
		virtual void FunF ( INT32 a ) = 0;
	};

	class CRoomInfo :public CRoomInfoBase
	{
		private:
		class CRoom4 :public CRoom4Base
		{
			private:
			INT32 m_0x8;
			INT32 m_0xC;
			INT32 m_0x10;
			INT32 m_0x14;
			INT32 m_0x18;
			INT32 m_0x1C;
			public:
			void Fun00 ( ) { }
			void Fun01 ( ) { }
			void Fun02 ( ) { }
			void Fun03 ( ) { }
			void Fun04 ( ) { }
			void Fun05 ( ) { }
			void Fun06 ( ) { }
			void Fun07 ( ) { }
			void Fun08 ( ) { }
			void Fun09 ( ) { }

			void Fun10 ( ) { }
			void Fun11 ( ) { }
			void Fun12 ( ) { }
			void Fun13 ( ) { }
			void Fun14 ( ) { }
			void Fun15 ( ) { }
			void Fun16 ( ) { }
			void Fun17 ( ) { }
			void Fun18 ( ) { }
			void Fun19 ( ) { }

			void Fun20 ( ) { }
			void Fun21 ( ) { }
			void Fun22 ( ) { }
			void Fun23 ( ) { }
			void Fun24 ( ) { }
			void Fun25 ( ) { }
			void Fun26 ( ) { }
			void Fun27 ( ) { }
			void Fun28 ( ) { }
			void Fun29 ( ) { }

			void Fun30 ( ) { }
			void Fun31 ( ) { }
			void Fun32 ( ) { }
			void Fun33 ( ) { }
			void Fun34 ( ) { }
			void Fun35 ( ) { }
			void Fun36 ( ) { }
			void Fun37 ( ) { }
			void Fun38 ( ) { }
			void Fun39 ( ) { }

			void Fun40 ( ) { }
			void Fun41 ( ) { }
			void Fun42 ( ) { }
			void Fun43 ( ) { }
			void Fun44 ( ) { }
			void Fun45 ( ) { }
			void Fun46 ( ) { }
			void Fun47 ( ) { }
		}m_Room4;
		class CRoom20
		{
			private:
			INT32 m_20;
			INT32 m_24;
			INT32 m_28;
			INT32 m_2C;
			INT32 m_30;
			INT32 m_34;
			INT32 m_38;

			INT32 m_3C;
			INT32 m_40;
			INT32 m_44;
			INT32 m_48;
			INT32 m_4C;
			INT32 m_50;
			INT32 m_54;
			INT32 m_58;
			INT32 m_5C;
			INT32 m_60;
			INT32 m_64;
			INT32 m_68;
			public:
		}m_Room20;
		class CPlayerInfoInRoom :public CPlayerInfoInRoomBase
		{
			private:
			class C4 :public C4Base
			{
				private:
				INT32 m_0x8;
				class CC :public CCBase
				{
					private:
					INT32 m_0x10;
					INT8 m_0x14 [ 0x400 ];
					INT16 m_0x414;
					INT16 m_0x416;
					INT32 m_0x418;
					INT32 m_0x41C;
					INT16 m_0x420;
					INT16 m_0x422;
					CIpAddress m_IP;
					INT16 m_Port;
					INT16 m_0x42A;


					public:
					void Fun_1 ( ) { }
					void Fun_2 ( INT32 a ) { }
					void Fun_3 ( INT32 A ) { }
					void Fun_4 ( ) { }
					void Fun_5 ( INT32 A ) { }
					void Fun_6 ( ) { }
					void Fun_7 ( ) { }
					void Fun_8 ( ) { }
					void Fun_9 ( ) { }
					void Fun_A ( INT32 A ) { }
					void Fun_B ( INT32 A ) { }
					void Fun_C ( ) { }
					void Fun_D ( ) { }
					void Fun_E ( ) { }
					void Fun_F ( INT32 A ) { }
					void Fun_G ( ) { }
					void Fun_H ( ) { }
					void Fun_I ( ) { }
					CIpAddress* GetIP ( )
					{
						return &m_IP;
					}
					INT16 GetPort ( )
					{
						return m_Port;
					}
				}m_0xC;
				INT32 m_0x42C;
				INT32 m_0x430;
				INT32 m_0x434;
				INT16 m_0x438;
				INT16 m_0x43A;
				public:
				void FunG ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) { }
				void FunH ( ) { }
				void FunI ( INT32 A ) { }
			}m_C4;
			INT32 m_0x43C;
			INT32 m_0x440;
			INT32 m_0x444;
			INT32 m_0x448;
			INT32 m_0x44C;
			INT32 m_0x450;
			INT32 m_0x454;
			INT32 m_0x458;
			INT16 m_0x45C;
			INT16 m_0x45E;
			INT32 m_0x460;
			INT32 m_0x464;
			INT32 m_0x468;
			INT32 m_0x46C;
			INT16 m_0x470;
			INT16 m_0x472;
			INT32 m_0x474;
			INT16 m_0x478;
			INT16 m_0x47A;
			INT32 m_0x47C;
			INT32 m_0x480;
			INT16 m_0x484;
			INT16 m_0x486;
			//0x488
			class C488
			{
				INT32 m_0x488;
				INT32 m_0x48C;

				INT32 m_0x490;
				INT32 m_0x494;
				INT32 m_0x498;
				INT32 m_0x49C;

				INT32 m_0x4A0;
				INT32 m_0x4A4;
				INT32 m_0x4A8;
				INT32 m_0x4AC;

				INT32 m_0x4B0;
				INT32 m_0x4B4;
				INT32 m_0x4B8;
				INT32 m_0x4BC;

				INT32 m_0x4C0;
				INT32 m_0x4C4;
				INT32 m_0x4C8;
				INT32 m_0x4CC;



				//0x4D0
				UINT32 m_PlayerQQ;
				//0x4D4
				INT16 m_IDFromServer;
				INT16 m_0x4D6;
				INT8 m_0x4D8 [ 0x3FB0 ];
				INT32 m_0x4000;
				INT32 m_0x4004;
				public:
				//0x4D0
				UINT32 GetPlayerQQ ( )
				{
					return m_PlayerQQ;
				}
				//0x4D4
				INT16 GetIDFromServer ( )
				{
					return m_IDFromServer;
				}
			}m_0x488;
			//0x4490
			class C4490
			{
				INT8 m_4490 [ 0x400 ];
				INT32 m_4890;
				INT16 m_4894;
				INT16 m_4896;

			}m_0x4490;

			INT32 m_0x4898;
			INT32 m_0x489C;
			INT16 m_0x48A0;
			INT8 m_0x48A2 [ 0x284 ];
			INT16 m_0x4B26;

			public:
			void FunA ( ) { }
			void FunB ( INT32 a, INT32 b ) { }
			void FunC ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f, INT32 g ) { }
			void FunD ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) { }
			void FunE ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) { }
			void FunF ( INT32 a ) { }

			template<typename T>
			void SendDataToPlayer ( _In_ T& Package )
			{
				typedef void ( __thiscall *pSendDataToPlayer )
					(
					_In_ CPlayerInfoInRoom* ThisClass,
					_In_ DWORD dwPackageSize,
					_In_ T& package
					);
				pSendDataToPlayer pToPlayer = ( pSendDataToPlayer ) ( g_QQTangClient.m_SendDataToPlayer );
				pToPlayer ( this, sizeof ( T ), Package );
			}

			template<typename T>
			void CheckDataToServer
				(
				_In_ T& CheckDataPackage,
				_In_ CALLPLAYERINFOINROOM&  AllPlayerInfoInRoom
				)
			{
				typedef void ( __thiscall *pCheckDataToServer )
					(
					_In_ CPlayerInfoInRoom* ThisClass,
					_In_ DWORD dwPackageSize,
					_In_ T& CkPackage,
					_In_ CAllPlayerInfoInRoom& AllPlayerPackage
					);

				pCheckDataToServer pToServer = ( pCheckDataToServer ) ( g_QQTangClient.m_CheckDataToServer );
				pToServer ( this, sizeof ( T ), CheckDataPackage, AllPlayerInfoInRoom );
			}
		}m_PlayerInfoInRoom [ 8 ];



		public:
		CPlayerInfoInRoom* GetPlayerInfoInRoom ( )
		{
			return m_PlayerInfoInRoom;
		}

		void FunA ( INT32 a, INT32 b, INT32 c ) { }
		void FunB ( INT32 a ) { }
		void FunC ( INT32 a ) { }
		void FunD ( INT32 a, INT32 b ) { }
		void FunE ( INT32 a ) { }
		void FunF ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f, INT32 g ) { }
		void FunG ( INT32 a ) { }
		void FunH ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e ) { }
		void FunI ( INT32 a, INT32 b, INT32 c ) { }
		void SendDataToClient ( LPVOID pRoomInfo, DWORD dwPackageSize, LPVOID pPackage, INT32 PackageType )
		{
		}

		void FunK ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f ) { }
		void FunL ( INT32 a, INT32 b, INT32 c, INT32 d ) { }
		void FunM ( INT32 a, INT32 b, INT32 c ) { }
		void FunN ( INT32 a, INT32 b, INT32 c, INT32 e, INT32 f ) { }
		void FunO ( INT32 a, INT32 b, INT32 c, INT32 d, INT32 e, INT32 f ) { }
		void FunP ( INT32 a, INT32 b, INT32 c ) { }
		void FunQ ( INT32 a, INT32 b ) { }
		void FunR ( INT32 a ) { }
		void FunS ( INT32 a, INT32 b, INT32 c, INT32 e, INT32 f ) { }
	};

	class CRoom :public IBaseClass
	{
		private:
		class CRoomHeader
		{
			private:
			UINT8  m_0x0 [ 0x230 ];
			LPVOID m_PlayerInfo [ 0x2E ];
			UINT8 m_MySelfNO;
			UINT8 m_bytes [ 3 ];
			DWORD m_2EC;
			DWORD m_2F0;
			DWORD m_2F4;
			DWORD m_2F8;
			DWORD m_2FC;
			DWORD m_300;
			DWORD m_304;
			DWORD m_308;
			PRoomInfo m_pRoomInfo;
			PQQTEncoder m_pQQTEncoder;
			public:
			PRoomInfo GetRoomInfo ( )
			{
				return m_pRoomInfo;
			}
			PQQTEncoder GetQQTEncoder ( )
			{
				return m_pQQTEncoder;
			}
			UINT8 GetMeSelfNO ( )
			{
				return m_MySelfNO;
			}
		}*m_RoomHeader;
		public:
		static CRoom* GetRoom ( )
		{
			return ( CRoom* ) ( *( PUINT32 ) ( g_QQTangClient.m_Room ) );
		}
		CRoomHeader* GetRoomHeader ( )
		{
			return m_RoomHeader;
		}
		PRoomInfo GetRoomInfo ( )
		{
			return m_RoomHeader->GetRoomInfo ( );
		}
		PQQTEncoder GetQQTEncoder ( )
		{
			return m_RoomHeader->GetQQTEncoder ( );
		}

		template<typename T>
		void SetDataToClientInRoom ( GameID gameid, T& GamePackage)
		{
			if ( GetQQTEncoder ( ) == 0 || GetRoomInfo ( ) == 0 )
			{
				return;
			}
			CSendPackageInRoom* pSendPackage = new CSendPackageInRoom ( );
			PUINT8 pPackage = new UINT8 [ 0x1000 ];
			if ( pSendPackage == NULL || pPackage == NULL )
			{
				return;
			}
			memset ( pSendPackage, NULL, sizeof ( CSendPackageInRoom ) );
			pSendPackage->m_GameID = ( INT16 ) gameid;
			pSendPackage->m_Length = sizeof(T);
			pSendPackage->m_GetTickCount = GetTickCount ( );
			pSendPackage->m_SendCount = 1;
			memcpy ( pSendPackage->m_byPackage, &GamePackage, sizeof ( T ) );
			
			DWORD PackageLength;
			if ( GetQQTEncoder ( )->EnCoder (
				GetQQTEncoder ( ), GameID::D2E_ENCODE, pPackage,
				&PackageLength, pSendPackage, TRUE ) < 0 )
			{
				return;
			}
			GetRoomInfo ( )->SendDataToClient ( GetRoomInfo ( ), PackageLength, pPackage, 2 );
			delete pSendPackage;
			delete [ ] pPackage;
		}

		template<typename T>
		void SetDataToClientInGame ( GameID gameid, T& GamePackage )
		{
			if ( GetQQTEncoder ( ) == 0 || GetRoomInfo ( ) == 0 )
			{
				return;
			}
		}
		void* InitBase ( bool Destroy ) { return NULL; }

	};



}


```

`README.md`:

```md
# QQTangCheatEngine

#QQTang Game Cheat Engine

#TAOCODE的已经挂掉，现在迁移到github 

#因为VS的版本已经升级到VS2017 仅仅在 WIN10 vs2017下编译通过

#还能不能用 我就不知道拉

#最后更新日期 2018年5月9日16点56分

```

`SkinSharpByStaticLib/SkinH.h`:

```h
/*在Stdafx.h文件中加入如下语句
#include "SkinH.h"
#pragma comment(lib, "Detours.lib")
#pragma comment(lib, "SkinH_ST.lib")

**************** 根据编译选项在链接选项中做如下设置 ***********
下表显示根据要使用的运行时库应忽略的库。
若要使用第一行运行时库    请忽略第2行的这些库 
单线程 (libc.lib) 
libcmt.lib、msvcrt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib
多线程 (libcmt.lib) 
libc.lib、msvcrt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib
使用 DLL 的多线程 (msvcrt.lib) 
libc.lib、libcmt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib
调试单线程 (libcd.lib) 
libc.lib、libcmt.lib、msvcrt.lib、libcmtd.lib、msvcrtd.lib
调试多线程 (libcmtd.lib) 
libc.lib、libcmt.lib、msvcrt.lib、libcd.lib、msvcrtd.lib
使用 DLL 的调试多线程 (msvcrtd.lib) 
libc.lib、libcmt.lib、msvcrt.lib、libcd.lib、libcmtd.lib
**************************************************************/
#ifndef SKIN_H
#define SKIN_H

///ERROR CODE//////////////////////// 
#define		SRET_OK					0
#define		SRET_ERROR				1
#define		SRET_ERROR_FILE			2
#define		SRET_ERROR_PARAM		3
#define		SRET_ERROR_CREATE		4
#define		SRET_ERROR_FORMAT		5
#define		SRET_ERROR_VERSION		6
#define		SRET_ERROR_PASSWORD		7
#define		SRET_ERROR_INVALID		8
//////////////////////////////////////

//接口列表
extern "C"
{
	 /*
		功能:	静态库初始化
		返回值:	成功返回0, 失败返回非0
	 */
	int __stdcall SkinH_Init(HINSTANCE hInstance);


	/*
		功能:	静态库卸载
		返回值:	成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_Free();


	/*
	 	功能:	加载程序当前目录下的文件名skinh.she皮肤进行换肤
	 	返回值:	成功返回0, 失败返回非0
	 */
	int __stdcall SkinH_Attach();
	

	/*
		功能:	加载指定路径的皮肤进行换肤
		返回值: 成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_AttachEx(
						LPCTSTR strSkinFile,	//皮肤文件路径
						LPCTSTR strPassword		//皮肤密钥
						);

	/*
		功能:	加载指定路径的皮肤进行换肤并指定相应的色调，饱和度，亮度
		返回值: 成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_AttachExt(
						LPCTSTR strSkinFile,	//皮肤文件路径
						LPCTSTR strPassword,	//皮肤密钥
						int nHue,				//色调，	取值范围0-360, 默认值0
						int nSat,				//饱和度，	取值范围0-256, 默认值0
						int nBri				//亮度，	取值范围0-256, 默认值0
						);
	
	/*
		功能:	加载指定资源进行换肤并指定相应的色调，饱和度，亮度
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_AttachRes(
						LPBYTE	pShe,			//资源皮肤数据指针
						DWORD	dwSize,			//资源皮肤数据长度
						LPCTSTR strPassword,	//皮肤密钥
						int nHue,				//色调，	取值范围0-360, 默认值0
						int nSat,				//饱和度，	取值范围0-256, 默认值0
						int nBri				//亮度，	取值范围0-256, 默认值0
						);

	/*
		功能:	加载指定皮肤资源进行换肤并指定相应的色调，饱和度，亮度
		返回值: 成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_AttachResEx(
						LPCTSTR lpName,			//资源名
						LPCTSTR lpType,			//资源类型
						LPCTSTR strPassword,	//皮肤密钥
						int nHue,				//色调，	取值范围0-360, 默认值0
						int nSat,				//饱和度，	取值范围0-256, 默认值0
						int nBri				//亮度，	取值范围0-256, 默认值0
						);

 

	/*
		功能:	卸载换肤	
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_Detach();

	/*
		功能:	卸载指定句柄的窗体或者控件的皮肤	
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_DetachEx(
						HWND hWnd				//指定卸载皮肤的窗体或控件的句柄
						);
	
	/*
		功能:	设置指定窗体的透明度
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetWindowAlpha(
						HWND hWnd,				//窗体的句柄 
						int nAlpha				//透明度
						);

	/*
		功能:	调整当前皮肤的色调，饱和度，亮度
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_AdjustHSV(
						int nHue,				//色调，	取值范围0-360, 默认值0
						int nSat,				//饱和度，	取值范围0-256, 默认值0
						int nBri				//亮度，	取值范围0-256, 默认值0
						);
	
	/*
		功能:	获取指定窗口或控件在nX,nY处的颜色值 
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_GetColor(
						HWND hWnd,				//指定窗体或控件的句柄
						int nX,					//横坐标
						int nY					//纵坐标
						);
	
	/*
		功能:	指定窗体和控件的换肤类型
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_Map(
						HWND hWnd,				//指定窗体或控件的句柄 
						int nType				//换肤类型
						);

	//换肤类型
	#define TYPE_UNKNOWN				0		//未知类型
	#define TYPE_ANIMATE				1001	//动画控件 
	#define TYPE_CHECKBOX				1002	//复选框
	#define TYPE_COMBOBOX				1003	//组合框
	#define TYPE_COMBOLBOX				1004	//组合下拉框
	#define TYPE_CONTROLBAR				1005	//控件栏
	#define TYPE_DATETIME				1006	//日期控件
	#define TYPE_EDITBOX				1007	//文本框
	#define TYPE_GROUPBOX				1008	//分组框
	#define TYPE_HEADERCTRL				1009	//列头控件
	#define TYPE_HOTKEY					1010	//热键控件
	#define TYPE_IPADDRESS				1011	//IP地址控件
	#define TYPE_LABEL					1012	//标签控件
	#define TYPE_LISTBOX				1013	//列表框
	#define TYPE_LISTVIEW				1014	//列表视图
	#define TYPE_MDICLIENT				1015	//MDI客户区
	#define TYPE_MENU					1016	//菜单
	#define TYPE_MONTHCAL				1017	//月历控件

	#define TYPE_PICTURE				1018	//图片框
	#define TYPE_PROGRESS				1019	//进度条
	#define TYPE_PUSHBUTTON				1020	//普通按钮
	#define TYPE_RADIOBUTTON			1021	//单选框

	#define TYPE_REBAR					1022	//重组栏
	#define TYPE_RICHEDIT				1023	//富文本框
	#define TYPE_SCROLLBAR				1024	//滚动条
	#define TYPE_SCROLLCTRL				1025	//内置滚动条的控件
	#define TYPE_SPINCTRL				1026	//调节器
	#define TYPE_STATUSBAR				1027	//状态栏
	#define TYPE_TABCTRL				1028	//选择夹
	#define TYPE_TOOLBAR				1029	//工具栏
	#define TYPE_TOOLBARWND				1030	//MFC工具栏窗体
	#define TYPE_TRACKBAR				1031	//滑条控件
	#define TYPE_TREEVIEW				1032	//树形视图
	#define TYPE_WINDOW					1034	//标准窗体
	#define TYPE_COMCTRL				1036	//通用换肤
	#define TYPE_PAINTCTRL				1037	//通用换肤

	/*
		功能:	设置Aero特效
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetAero(
						int bAero				//1为开启特效,0为关闭特效 
						);
	

	/*
		功能:	设置Aero特效参数
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_AdjustAero(
						int nAlpha,				//透明度,   0-255, 默认值0
						int nShwDark,			//亮度,     0-255, 默认值0
						int nShwSharp,			//锐度,	    0-255, 默认值0 
						int nShwSize,			//阴影大小, 2-19,  默认值2
						int nX,					//水平偏移, 0-25,  默认值0 (目前不支持)
						int nY,					//垂直偏移, 0-25,  默认值0 (目前不支持)
						int nRed,				//红色分量, 0-255, 默认值 -1
						int nGreen,				//绿色分量, 0-255, 默认值 -1 
						int nBlue				//蓝色分量, 0-255, 默认值 -1 
						);
	
	/*
		功能:	设置窗体是否可以移动
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetWindowMovable(
						HWND hWnd,				//窗口句柄 
						BOOL bMovable			//0为不可移动, 1为可移动
						);
	
	/*
		功能:	设置控件的背景色(目前仅对单选框, 复选框, 分组框有效)
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetBackColor(
						HWND hWnd,				//控件句柄
						int nRed,				//红色分量
						int nGreen,				//绿色分量
						int nBlue				//蓝色分量
						);
	
	/*
		功能:	设置控件的文本颜色色(目前仅对单选框,复选框,分组框有效)
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetForeColor(
						HWND hWnd,				//控件句柄
						int nRed,				//红色分量
						int nGreen,				//绿色分量
						int nBlue				//蓝色分量
						);

	/*
		功能:	用于填充表格或者列表控件数据时，重复绘制影响执行效率问题
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_LockUpdate(
						HWND hWnd,				//指定窗体或控件的句柄 
						int bUpdate				//1为锁定绘制，0为解锁绘制 
						);
	
	/*
		功能:	设置菜单透明度
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetMenuAlpha(
						int nAlpha				//菜单透明度，取值范围 0 - 255
						);

	/*
		功能:	绘制指定设备上下文的元素
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_NineBlt(
						HDC hDtDC,				//目标设备上下文
						int left,				//左上角水平坐标
						int top,				//左上角垂直坐标
						int right,				//右下角水平坐标
						int bottom,				//右下角垂直坐标
						int nMRect				//元素id
						);

	/*
		功能:	设置标题菜单栏
		返回值: 成功返回0, 失败返回非0	
	*/
	int __stdcall SkinH_SetTitleMenuBar(
						HWND hWnd, 	//窗口句柄
						BOOL bEnable,	//是否设置 1为设置， 0 为取消 
						int nTMenuY, 	//菜单栏高度
						int nTopOffs, 	//顶部偏移
						int nRightOffs 	//右部偏移
						);

	
	/*
		功能:	设置控件的字体
		返回值: 成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_SetFont(
						HWND hWnd,		//控件的句柄
						HFONT hFont		//字体句柄
						);
		
		
	/*
		功能:	设置控件的字体
		返回值: 成功返回0, 失败返回非0
	*/
	int __stdcall SkinH_SetFontEx(
						HWND hWnd,		//控件的句柄
						LPCTSTR szFace,	//字体名称
						int nHeight,	//字体高度
						int nWidth,		//字体宽度
						int nWeight,	//字体磅数
						int nItalic,	//是否斜体
						int nUnderline,	//是否下划线
						int nStrikeOut	//是否删除线
						);

}
#endif
```

`zlib1/WinMain.cpp`:

```cpp

#include "WinMain.h"


BOOL WINAPI DllMain (
	_In_ HINSTANCE hInstance,
	_In_ DWORD fdwReason,
	_In_ LPVOID lpReserved )
{
	if ( fdwReason == DLL_PROCESS_ATTACH )
	{
		g_QQTangClient.CanOpenNext ( );
		SkinH_Init ( hInstance );
		SkinH_AttachResExByDll ( hInstance, MAKEINTRESOURCE ( IDR_SHE ), RT_RCDATA, NULL, 0, 0, 0 );
		CreateDialogParam ( hInstance, MAKEINTRESOURCE ( IDD_WinMain ), NULL, ( DLGPROC ) WinMainProc, NULL );
	}
	return TRUE;

	//skin 
	_mbsstr ( ( unsigned char * ) NULL, ( unsigned char * ) NULL );
	_mbscmp ( NULL, NULL );
}


int SkinH_AttachResExByDll (
	_In_ HINSTANCE hInstance,
	_In_ LPCTSTR lpName,			//资源名
	_In_ LPCTSTR lpType,			//资源类型
	_In_ LPCTSTR strPassword,	//皮肤密钥
	_In_ int nHue,				//色调，	取值范围0-360, 默认值0
	_In_ int nSat,				//饱和度，	取值范围0-256, 默认值0
	_In_ int nBri				//亮度，	取值范围0-256, 默认值0
	)
{
	HRSRC hRsrc = FindResourceA ( hInstance, lpName, lpType );
	if ( hRsrc == 0 )
	{
		return SRET_ERROR_PARAM;
	}
	HGLOBAL hGlobal = LoadResource ( hInstance, hRsrc );
	LPVOID lpSHE = LockResource ( hGlobal );
	DWORD dwFileSize = SizeofResource ( hInstance, hRsrc );
	return SkinH_AttachRes ( ( LPBYTE ) lpSHE, dwFileSize, NULL, 0, 0, 0 );
}


BOOL CALLBACK WinMainProc ( _In_ HWND hWnd , _In_ UINT32 uMsg , _In_ WPARAM wParam , _In_ LPARAM lParam )
{
	switch ( uMsg )
	{
		case WM_INITDIALOG:
		{
			return TRUE;
		}
		case WM_COMMAND:
		{
			CQQTangCheatEngine Engine;
			switch ( wParam & 0xFFFF )
			{
				
				case IDC_btnTest:
				{
					Engine.FullScreenBoxExplode();
					break;
				}
				case IDC_btnBomb:
				{
					Engine.FullScreenBombExplode();
					break;
				}
				case IDC_btnProp:
				{
					Engine.FullScreenPropExplode();
					break;
				}
				case IDC_btnCreateBox:
				{
					Engine.FullScreenCreateBox ( ItemByBox::BOX_FIELD_02 );
					break;
				}
				case IDC_btnrelive:
				{
					Engine.FullScreenPlayBomb ( NPC_00 );
					break;
				}
				default:
					break;
			}
			return TRUE;
		}
		case WM_CLOSE:
		{
			SkinH_Free ( );
			EndDialog ( hWnd, NULL );
			return TRUE;
		}
		default:
		{ 
			return FALSE;
		}
	}
}
```

`zlib1/WinMain.h`:

```h
#pragma once
#pragma pack(1)

#include "QQTangCheatEngine.hpp"
using namespace QQTangCheatEngine;

#include "SkinH.h"
 
#include <mbstring.h>
#pragma comment(lib, "Detours.lib")
#pragma comment(lib, "SkinH_ST.lib")
#include "resource.h"

BOOL WINAPI DllMain (
	_In_ HINSTANCE hInstance,
	_In_ DWORD fdwReason,
	_In_ LPVOID lpReserved );

BOOL CALLBACK WinMainProc ( _In_ HWND hWnd, _In_ UINT32 uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam );

int  SkinH_AttachResExByDll (
	_In_ HINSTANCE hInstance,
	_In_ LPCTSTR lpName,			//资源名
	_In_ LPCTSTR lpType,			//资源类型
	_In_ LPCTSTR strPassword,	//皮肤密钥
	_In_ int nHue,				//色调，	取值范围0-360, 默认值0
	_In_ int nSat,				//饱和度，	取值范围0-256, 默认值0
	_In_ int nBri				//亮度，	取值范围0-256, 默认值0
	);

```

`zlib1/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 zlib1.rc 使用
//
#define IDD_WinMain                     101
#define IDR_RCDATA1                     102
#define IDR_SHE                         102
#define IDC_btnTest                     1001
#define IDC_btnBomb                     1002
#define IDC_bomb2                       1003
#define IDC_btnProp                     1003
#define IDC_BUTTON1                     1004
#define IDC_btnCreateBox                1004
#define IDC_BUTTON2                     1005
#define IDC_btnrelive                   1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`zlib1/zlib1.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_WinMain DIALOGEX 0, 0, 151, 89
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "CoolSummer"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "box",IDC_btnTest,16,14,50,14
    PUSHBUTTON      "bomb",IDC_btnBomb,77,15,52,15
    PUSHBUTTON      "prop",IDC_btnProp,17,33,48,15
    PUSHBUTTON      "CreateBox",IDC_btnCreateBox,78,34,50,14
    PUSHBUTTON      "relive",IDC_btnrelive,20,54,44,14
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_WinMain, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 144
        TOPMARGIN, 7
        BOTTOMMARGIN, 82
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// RCDATA
//

IDR_SHE                 RCDATA                  "..\\SkinSharpByStaticLib\\skinh.she"
#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`zlib1/zlib1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9DA95A37-01AB-4A9E-A5C0-5BAB1EEE24BF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>
    </RootNamespace>
    <SccProjectName>Svn</SccProjectName>
    <SccAuxPath>Svn</SccAuxPath>
    <SccLocalPath>Svn</SccLocalPath>
    <SccProvider>SubversionScc</SccProvider>
    <WindowsTargetPlatformVersion>10.0.16299.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;ZLIB1_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;ZLIB1_EXPORTS;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>
      </SDLCheck>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DisableSpecificWarnings>4996;4049;4099</DisableSpecificWarnings>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>zlib1.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(solutiondir)QQTang CheatEngine;$(solutiondir)SkinSharpByStaticLib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <BrowseInformation>true</BrowseInformation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>zlib1Code\zlib.def</ModuleDefinitionFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <GenerateMapFile>true</GenerateMapFile>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <AdditionalLibraryDirectories>$(solutiondir)Release;$(solutiondir)SkinSharpByStaticLib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>Detours.lib;SkinH_ST.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>MSVCRT.lib</IgnoreSpecificDefaultLibraries>
    </Link>
    <Bscmake>
      <PreserveSbr>true</PreserveSbr>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
    <ClInclude Include="WinMain.h" />
    <ClInclude Include="zlib1Code\crc32.h" />
    <ClInclude Include="zlib1Code\deflate.h" />
    <ClInclude Include="zlib1Code\gzguts.h" />
    <ClInclude Include="zlib1Code\inffast.h" />
    <ClInclude Include="zlib1Code\inffixed.h" />
    <ClInclude Include="zlib1Code\inflate.h" />
    <ClInclude Include="zlib1Code\inftrees.h" />
    <ClInclude Include="zlib1Code\trees.h" />
    <ClInclude Include="zlib1Code\zconf.h" />
    <ClInclude Include="zlib1Code\zlib.h" />
    <ClInclude Include="zlib1Code\zutil.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WinMain.cpp" />
    <ClCompile Include="zlib1Code\adler32.cpp" />
    <ClCompile Include="zlib1Code\compress.cpp" />
    <ClCompile Include="zlib1Code\crc32.cpp" />
    <ClCompile Include="zlib1Code\deflate.cpp" />
    <ClCompile Include="zlib1Code\gzclose.cpp" />
    <ClCompile Include="zlib1Code\gzlib.cpp" />
    <ClCompile Include="zlib1Code\gzread.cpp" />
    <ClCompile Include="zlib1Code\gzwrite.cpp" />
    <ClCompile Include="zlib1Code\infback.cpp" />
    <ClCompile Include="zlib1Code\inffast.cpp" />
    <ClCompile Include="zlib1Code\inflate.cpp" />
    <ClCompile Include="zlib1Code\inftrees.cpp" />
    <ClCompile Include="zlib1Code\trees.cpp" />
    <ClCompile Include="zlib1Code\uncompr.cpp" />
    <ClCompile Include="zlib1Code\zutil.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\SkinSharpByStaticLib\skinh.she" />
    <None Include="zlib1Code\zlib.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="zlib1.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`zlib1/zlib1.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="zlib1Code">
      <UniqueIdentifier>{f7cfd396-3e99-4f8f-a637-c4d447aca75d}</UniqueIdentifier>
    </Filter>
    <Filter Include="zlib1Code\CODE">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="zlib1Code\H">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="zlib1Code\crc32.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\deflate.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\gzguts.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\inffast.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\inffixed.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\inflate.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\inftrees.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\trees.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\zconf.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\zlib.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="zlib1Code\zutil.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
    <ClInclude Include="WinMain.h" />
    <ClInclude Include="resource.h">
      <Filter>zlib1Code\H</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="zlib1Code\adler32.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\compress.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\crc32.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\deflate.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\gzclose.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\gzlib.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\gzread.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\gzwrite.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\infback.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\inffast.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\inflate.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\inftrees.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\trees.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\uncompr.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="zlib1Code\zutil.cpp">
      <Filter>zlib1Code\CODE</Filter>
    </ClCompile>
    <ClCompile Include="WinMain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="zlib1Code\zlib.def">
      <Filter>zlib1Code</Filter>
    </None>
    <None Include="..\SkinSharpByStaticLib\skinh.she" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="zlib1.rc" />
  </ItemGroup>
</Project>
```

`zlib1/zlib1Code/adler32.cpp`:

```cpp
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"

#define local static

local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));

#define BASE 65521      /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* use NO_DIVIDE if your processor does not do division in hardware --
   try it both ways to see which is faster */
#ifdef NO_DIVIDE
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
   (thank you to John Reiser for pointing this out) */
#  define CHOP(a) \
    do { \
        unsigned long tmp = a >> 16; \
        a &= 0xffffUL; \
        a += (tmp << 4) - tmp; \
    } while (0)
#  define MOD28(a) \
    do { \
        CHOP(a); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#  define MOD(a) \
    do { \
        CHOP(a); \
        MOD28(a); \
    } while (0)
#  define MOD63(a) \
    do { /* this assumes a is not negative */ \
        z_off64_t tmp = a >> 32; \
        a &= 0xffffffffL; \
        a += (tmp << 8) - (tmp << 5) + tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#  define MOD28(a) a %= BASE
#  define MOD63(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(
    uLong adler,
    const Bytef *buf,
    uInt len)
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
        if (sum2 >= BASE)
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
        MOD28(sum2);            /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}

/* ========================================================================= */
local uLong adler32_combine_( 
    uLong adler1,
    uLong adler2,
	z_off64_t len2 )
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    /* for negative len, return invalid adler32 as a clue for debugging */
    if (len2 < 0)
        return 0xffffffffUL;

    /* the derivation of this formula is left as an exercise for the reader */
    MOD63(len2);                /* assumes len2 >= 0 */
    rem = (unsigned)len2;
    sum1 = adler1 & 0xffff;
    sum2 = rem * sum1;
    MOD(sum2);
    sum1 += (adler2 & 0xffff) + BASE - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
    if (sum2 >= BASE) sum2 -= BASE;
    return sum1 | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32_combine( 
    uLong adler1,
    uLong adler2,
    z_off_t len2)
{
    return adler32_combine_(adler1, adler2, len2);
}

uLong ZEXPORT adler32_combine64(
    uLong adler1,
    uLong adler2,
    z_off64_t len2)
{
    return adler32_combine_(adler1, adler2, len2);
}

```

`zlib1/zlib1Code/compress.cpp`:

```cpp
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 ( 
    Bytef *dest,
    uLongf *destLen,
    const Bytef *source,
    uLong sourceLen,
    int level)
{
    z_stream stream;
    int err;

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress ( 
    Bytef *dest,
    uLongf *destLen,
    const Bytef *source,
    uLong sourceLen)
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}

/* ===========================================================================
     If the default memLevel or windowBits for deflateInit() is changed, then
   this function needs to be updated.
 */
uLong ZEXPORT compressBound (
    uLong sourceLen)
{
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13;
}

```

`zlib1/zlib1Code/crc32.cpp`:

```cpp
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
 * tables for updating the shift register in one step with three exclusive-ors
 * instead of four steps with four exclusive-ors.  This results in about a
 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
 */

/* @(#) $Id$ */

/*
  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
  protection on the static variables used to control the first-use generation
  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
  first call get_crc_table() to initialize the tables before allowing more than
  one thread to use crc32().

  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
 */

#ifdef MAKECRCH
#  include <stdio.h>
#  ifndef DYNAMIC_CRC_TABLE
#    define DYNAMIC_CRC_TABLE
#  endif /* !DYNAMIC_CRC_TABLE */
#endif /* MAKECRCH */

#include "zutil.h"      /* for STDC and FAR definitions */

#define local static

/* Definitions for doing the crc four data bytes at a time. */
#if !defined(NOBYFOUR) && defined(Z_U4)
#  define BYFOUR
#endif
#ifdef BYFOUR
   local unsigned long crc32_little OF((unsigned long,
                        const unsigned char FAR *, unsigned));
   local unsigned long crc32_big OF((unsigned long,
                        const unsigned char FAR *, unsigned));
#  define TBLS 8
#else
#  define TBLS 1
#endif /* BYFOUR */

/* Local functions for crc concatenation */
local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                         unsigned long vec));
local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));


#ifdef DYNAMIC_CRC_TABLE

local volatile int crc_table_empty = 1;
local z_crc_t FAR crc_table[TBLS][256];
local void make_crc_table OF((void));
#ifdef MAKECRCH
   local void write_table OF((FILE *, const z_crc_t FAR *));
#endif /* MAKECRCH */
/*
  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The first table is simply the CRC of all possible eight bit values.  This is
  all the information needed to generate CRCs on data a byte at a time for all
  combinations of CRC register values and incoming bytes.  The remaining tables
  allow for word-at-a-time CRC calculation for both big-endian and little-
  endian machines, where a word is four bytes.
*/
local void make_crc_table()
{
    z_crc_t c;
    int n, k;
    z_crc_t poly;                       /* polynomial exclusive-or pattern */
    /* terms of polynomial defining this crc (except x^32): */
    static volatile int first = 1;      /* flag to limit concurrent making */
    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

    /* See if another task is already doing this (not thread-safe, but better
       than nothing -- significantly reduces duration of vulnerability in
       case the advice about DYNAMIC_CRC_TABLE is ignored) */
    if (first) {
        first = 0;

        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
        poly = 0;
        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
            poly |= (z_crc_t)1 << (31 - p[n]);

        /* generate a crc for every 8-bit value */
        for (n = 0; n < 256; n++) {
            c = (z_crc_t)n;
            for (k = 0; k < 8; k++)
                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
            crc_table[0][n] = c;
        }

#ifdef BYFOUR
        /* generate crc for each value followed by one, two, and three zeros,
           and then the byte reversal of those as well as the first table */
        for (n = 0; n < 256; n++) {
            c = crc_table[0][n];
            crc_table[4][n] = ZSWAP32(c);
            for (k = 1; k < 4; k++) {
                c = crc_table[0][c & 0xff] ^ (c >> 8);
                crc_table[k][n] = c;
                crc_table[k + 4][n] = ZSWAP32(c);
            }
        }
#endif /* BYFOUR */

        crc_table_empty = 0;
    }
    else {      /* not first */
        /* wait for the other guy to finish (not efficient, but rare) */
        while (crc_table_empty)
            ;
    }

#ifdef MAKECRCH
    /* write out CRC tables to crc32.h */
    {
        FILE *out;

        out = fopen("crc32.h", "w");
        if (out == NULL) return;
        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
        fprintf(out, "local const z_crc_t FAR ");
        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
        write_table(out, crc_table[0]);
#  ifdef BYFOUR
        fprintf(out, "#ifdef BYFOUR\n");
        for (k = 1; k < 8; k++) {
            fprintf(out, "  },\n  {\n");
            write_table(out, crc_table[k]);
        }
        fprintf(out, "#endif\n");
#  endif /* BYFOUR */
        fprintf(out, "  }\n};\n");
        fclose(out);
    }
#endif /* MAKECRCH */
}

#ifdef MAKECRCH
local void write_table(out, table)
    FILE *out;
    const z_crc_t FAR *table;
{
    int n;

    for (n = 0; n < 256; n++)
        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                (unsigned long)(table[n]),
                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
}
#endif /* MAKECRCH */

#else /* !DYNAMIC_CRC_TABLE */
/* ========================================================================
 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
 */
#include "crc32.h"
#endif /* DYNAMIC_CRC_TABLE */

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const z_crc_t FAR * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */
    return (const z_crc_t FAR *)crc_table;
}

/* ========================================================================= */
#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1

/* ========================================================================= */
unsigned long ZEXPORT crc32( 
    unsigned long crc,
    const unsigned char FAR *buf,
    uInt len)
{
    if (buf == Z_NULL) return 0UL;

#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */

#ifdef BYFOUR
    if (sizeof(void *) == sizeof(ptrdiff_t)) {
        z_crc_t endian;

        endian = 1;
        if (*((unsigned char *)(&endian)))
            return crc32_little(crc, buf, len);
        else
            return crc32_big(crc, buf, len);
    }
#endif /* BYFOUR */
    crc = crc ^ 0xffffffffUL;
    while (len >= 8) {
        DO8;
        len -= 8;
    }
    if (len) do {
        DO1;
    } while (--len);
    return crc ^ 0xffffffffUL;
}

#ifdef BYFOUR

/* ========================================================================= */
#define DOLIT4 c ^= *buf4++; \
        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4

/* ========================================================================= */
local unsigned long crc32_little( 
    unsigned long crc,
    const unsigned char FAR *buf,
    unsigned len)
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = (z_crc_t)crc;
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    while (len >= 32) {
        DOLIT32;
        len -= 32;
    }
    while (len >= 4) {
        DOLIT4;
        len -= 4;
    }
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    } while (--len);
    c = ~c;
    return (unsigned long)c;
}

/* ========================================================================= */
#define DOBIG4 c ^= *++buf4; \
        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4

/* ========================================================================= */
local unsigned long crc32_big( 
    unsigned long crc,
    const unsigned char FAR *buf,
    unsigned len)
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = ZSWAP32((z_crc_t)crc);
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    buf4--;
    while (len >= 32) {
        DOBIG32;
        len -= 32;
    }
    while (len >= 4) {
        DOBIG4;
        len -= 4;
    }
    buf4++;
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    } while (--len);
    c = ~c;
    return (unsigned long)(ZSWAP32(c));
}

#endif /* BYFOUR */

#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */

/* ========================================================================= */
local unsigned long gf2_matrix_times( 
    unsigned long *mat,
    unsigned long vec)
{
    unsigned long sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

/* ========================================================================= */
local void gf2_matrix_square( 
    unsigned long *square,
    unsigned long *mat)
{
    int n;

    for (n = 0; n < GF2_DIM; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

/* ========================================================================= */
local uLong crc32_combine_( 
    uLong crc1,
    uLong crc2,
    z_off64_t len2)
{
    int n;
    unsigned long row;
    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */

    /* degenerate case (also disallow negative lengths) */
    if (len2 <= 0)
        return crc1;

    /* put operator for one zero bit in odd */
    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
    row = 1;
    for (n = 1; n < GF2_DIM; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* apply len2 zeros to crc1 (first square will put the operator for one
       zero byte, eight zero bits, in even) */
    do {
        /* apply zeros operator for this bit of len2 */
        gf2_matrix_square(even, odd);
        if (len2 & 1)
            crc1 = gf2_matrix_times(even, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
        if (len2 == 0)
            break;

        /* another iteration of the loop with odd and even swapped */
        gf2_matrix_square(odd, even);
        if (len2 & 1)
            crc1 = gf2_matrix_times(odd, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
    } while (len2 != 0);

    /* return combined crc */
    crc1 ^= crc2;
    return crc1;
}

/* ========================================================================= */
uLong ZEXPORT crc32_combine(
    uLong crc1,
    uLong crc2,
    z_off_t len2)
{
    return crc32_combine_(crc1, crc2, len2);
}

uLong ZEXPORT crc32_combine64(
    uLong crc1,
    uLong crc2,
    z_off64_t len2)
{
    return crc32_combine_(crc1, crc2, len2);
}

```

`zlib1/zlib1Code/crc32.h`:

```h
/* crc32.h -- tables for rapid CRC calculation
 * Generated automatically by crc32.c
 */

local const z_crc_t FAR crc_table[TBLS][256] =
{
  {
    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
    0x2d02ef8dUL
#ifdef BYFOUR
  },
  {
    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
    0x9324fd72UL
  },
  {
    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
    0xbe9834edUL
  },
  {
    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
    0xde0506f1UL
  },
  {
    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
    0x8def022dUL
  },
  {
    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
    0x72fd2493UL
  },
  {
    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
    0xed3498beUL
  },
  {
    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
    0xf10605deUL
#endif
  }
};

```

`zlib1/zlib1Code/deflate.cpp`:

```cpp
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://tools.ietf.org/html/rfc1951
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

const char deflate_copyright[] =
   " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
#ifndef FASTEST
local block_state deflate_slow   OF((deflate_state *s, int flush));
#endif
local block_state deflate_rle    OF((deflate_state *s, int flush));
local block_state deflate_huff   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

#ifdef FASTEST
local const config configuration_table[2] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
#else
local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
#endif

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

#ifndef NO_DUMMY_DECL
struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
#endif

/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_( 
    z_streamp strm,
    int level,
    const char *version,
    int stream_size)
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_( 
    z_streamp strm,
    int  level,
    int  method,
    int  windowBits,
    int  memLevel,
    int  strategy,
    const char *version,
    int stream_size)
{
    deflate_state *s;
    int wrap = 1;
    static const char my_version[] = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
        return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif

    if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
    }
#ifdef GZIP
    else if (windowBits > 15) {
        wrap = 2;       /* write gzip wrapper instead */
        windowBits -= 16;
    }
#endif
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->wrap = wrap;
    s->gzhead = Z_NULL;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->high_water = 0;      /* nothing written to s->window yet */

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        s->status = FINISH_STATE;
        strm->msg = ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary ( 
    z_streamp strm,
    const Bytef *dictionary,
    uInt  dictLength)
{
    deflate_state *s;
    uInt str, n;
    int wrap;
    unsigned avail;
    z_const unsigned char *next;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
        return Z_STREAM_ERROR;
    s = strm->state;
    wrap = s->wrap;
    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
        return Z_STREAM_ERROR;

    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
    if (wrap == 1)
        strm->adler = adler32(strm->adler, dictionary, dictLength);
    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */
    if (dictLength >= s->w_size) {
        if (wrap == 0) {            /* already empty otherwise */
            CLEAR_HASH(s);
            s->strstart = 0;
            s->block_start = 0L;
            s->insert = 0;
        }
        dictionary += dictLength - s->w_size;  /* use the tail */
        dictLength = s->w_size;
    }

    /* insert dictionary into window and hash */
    avail = strm->avail_in;
    next = strm->next_in;
    strm->avail_in = dictLength;
    strm->next_in = (z_const Bytef *)dictionary;
    fill_window(s);
    while (s->lookahead >= MIN_MATCH) {
        str = s->strstart;
        n = s->lookahead - (MIN_MATCH-1);
        do {
            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
            s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
            s->head[s->ins_h] = (Pos)str;
            str++;
        } while (--n);
        s->strstart = str;
        s->lookahead = MIN_MATCH-1;
        fill_window(s);
    }
    s->strstart += s->lookahead;
    s->block_start = (long)s->strstart;
    s->insert = s->lookahead;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    strm->next_in = next;
    strm->avail_in = avail;
    s->wrap = wrap;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateResetKeep ( 
	z_streamp strm )
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
        return Z_STREAM_ERROR;
    }

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->wrap < 0) {
        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
    }
    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
    strm->adler =
#ifdef GZIP
        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
#endif
        adler32(0L, Z_NULL, 0);
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset ( 
    z_streamp strm)
{
    int ret;

    ret = deflateResetKeep(strm);
    if (ret == Z_OK)
        lm_init(strm->state);
    return ret;
}

/* ========================================================================= */
int ZEXPORT deflateSetHeader ( 
    z_streamp strm,
    gz_headerp head)
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
    strm->state->gzhead = head;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePending (
    unsigned *pending,
    int *bits,
    z_streamp strm)
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (pending != Z_NULL)
        *pending = strm->state->pending;
    if (bits != Z_NULL)
        *bits = strm->state->bi_valid;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePrime (
    z_streamp strm,
    int bits,
    int value)
{
    deflate_state *s;
    int put;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
        return Z_BUF_ERROR;
    do {
        put = Buf_size - s->bi_valid;
        if (put > bits)
            put = bits;
        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
        s->bi_valid += put;
        _tr_flush_bits(s);
        value >>= put;
        bits -= put;
    } while (bits);
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(
    z_streamp strm,
    int level,
    int strategy)
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        /* Flush the last buffer: */
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* ========================================================================= */
int ZEXPORT deflateTune(
    z_streamp strm,
    int good_length,
    int max_lazy,
    int nice_length,
    int max_chain)
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    s->good_match = good_length;
    s->max_lazy_match = max_lazy;
    s->nice_match = nice_length;
    s->max_chain_length = max_chain;
    return Z_OK;
}

/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds for
 * every combination of windowBits and memLevel.  But even the conservative
 * upper bound of about 14% expansion does not seem onerous for output buffer
 * allocation.
 */
uLong ZEXPORT deflateBound( 
	z_streamp strm,
    uLong sourceLen)
{
    deflate_state *s;
    uLong complen, wraplen;
    Bytef *str;

    /* conservative upper bound for compressed data */
    complen = sourceLen +
              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

    /* if can't get parameters, return conservative bound plus zlib wrapper */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return complen + 6;

    /* compute wrapper length */
    s = strm->state;
    switch (s->wrap) {
    case 0:                                 /* raw deflate */
        wraplen = 0;
        break;
    case 1:                                 /* zlib wrapper */
        wraplen = 6 + (s->strstart ? 4 : 0);
        break;
    case 2:                                 /* gzip wrapper */
        wraplen = 18;
        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
            if (s->gzhead->extra != Z_NULL)
                wraplen += 2 + s->gzhead->extra_len;
            str = s->gzhead->name;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            str = s->gzhead->comment;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            if (s->gzhead->hcrc)
                wraplen += 2;
        }
        break;
    default:                                /* for compiler happiness */
        wraplen = 6;
    }

    /* if not default parameters, return conservative bound */
    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
        return complen + wraplen;

    /* default settings: return tight bound for that case */
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13 - 6 + wraplen;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB ( 
	deflate_state *s,
    uInt b)
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending( 
    z_streamp strm)
{
    unsigned len;
    deflate_state *s = strm->state;

    _tr_flush_bits(s);
    len = s->pending;
    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, s->pending_out, len);
    strm->next_out  += len;
    s->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    s->pending -= len;
    if (s->pending == 0) {
        s->pending_out = s->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate ( 
    z_streamp strm,
    int flush)
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        flush > Z_BLOCK || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
        (s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the header */
    if (s->status == INIT_STATE) {
#ifdef GZIP
        if (s->wrap == 2) {
            strm->adler = crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (s->gzhead == Z_NULL) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, OS_CODE);
                s->status = BUSY_STATE;
            }
            else {
                put_byte(s, (s->gzhead->text ? 1 : 0) +
                            (s->gzhead->hcrc ? 2 : 0) +
                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
                            (s->gzhead->name == Z_NULL ? 0 : 8) +
                            (s->gzhead->comment == Z_NULL ? 0 : 16)
                        );
                put_byte(s, (Byte)(s->gzhead->time & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, s->gzhead->os & 0xff);
                if (s->gzhead->extra != Z_NULL) {
                    put_byte(s, s->gzhead->extra_len & 0xff);
                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                }
                if (s->gzhead->hcrc)
                    strm->adler = crc32(strm->adler, s->pending_buf,
                                        s->pending);
                s->gzindex = 0;
                s->status = EXTRA_STATE;
            }
        }
        else
#endif
        {
            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
            uInt level_flags;

            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                level_flags = 0;
            else if (s->level < 6)
                level_flags = 1;
            else if (s->level == 6)
                level_flags = 2;
            else
                level_flags = 3;
            header |= (level_flags << 6);
            if (s->strstart != 0) header |= PRESET_DICT;
            header += 31 - (header % 31);

            s->status = BUSY_STATE;
            putShortMSB(s, header);

            /* Save the adler32 of the preset dictionary: */
            if (s->strstart != 0) {
                putShortMSB(s, (uInt)(strm->adler >> 16));
                putShortMSB(s, (uInt)(strm->adler & 0xffff));
            }
            strm->adler = adler32(0L, Z_NULL, 0);
        }
    }
#ifdef GZIP
    if (s->status == EXTRA_STATE) {
        if (s->gzhead->extra != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */

            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size)
                        break;
                }
                put_byte(s, s->gzhead->extra[s->gzindex]);
                s->gzindex++;
            }
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (s->gzindex == s->gzhead->extra_len) {
                s->gzindex = 0;
                s->status = NAME_STATE;
            }
        }
        else
            s->status = NAME_STATE;
    }
    if (s->status == NAME_STATE) {
        if (s->gzhead->name != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->name[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0) {
                s->gzindex = 0;
                s->status = COMMENT_STATE;
            }
        }
        else
            s->status = COMMENT_STATE;
    }
    if (s->status == COMMENT_STATE) {
        if (s->gzhead->comment != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->comment[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0)
                s->status = HCRC_STATE;
        }
        else
            s->status = HCRC_STATE;
    }
    if (s->status == HCRC_STATE) {
        if (s->gzhead->hcrc) {
            if (s->pending + 2 > s->pending_buf_size)
                flush_pending(strm);
            if (s->pending + 2 <= s->pending_buf_size) {
                put_byte(s, (Byte)(strm->adler & 0xff));
                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
                strm->adler = crc32(0L, Z_NULL, 0);
                s->status = BUSY_STATE;
            }
        }
        else
            s->status = BUSY_STATE;
    }
#endif

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s->last_flush = -1;
            return Z_OK;
        }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
               flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
                        (*(configuration_table[s->level].func))(s, flush));

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
            if (strm->avail_out == 0) {
                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
            }
            return Z_OK;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
        }
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                    if (s->lookahead == 0) {
                        s->strstart = 0;
                        s->block_start = 0L;
                        s->insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm->avail_out == 0) {
              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
              return Z_OK;
            }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->wrap <= 0) return Z_STREAM_END;

    /* Write the trailer */
#ifdef GZIP
    if (s->wrap == 2) {
        put_byte(s, (Byte)(strm->adler & 0xff));
        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
        put_byte(s, (Byte)(strm->total_in & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
    }
    else
#endif
    {
        putShortMSB(s, (uInt)(strm->adler >> 16));
        putShortMSB(s, (uInt)(strm->adler & 0xffff));
    }
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd ( 
    z_streamp strm)
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE &&
        status != EXTRA_STATE &&
        status != NAME_STATE &&
        status != COMMENT_STATE &&
        status != HCRC_STATE &&
        status != BUSY_STATE &&
        status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy ( 
	z_streamp dest,
    z_streamp source)
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif /* MAXSEG_64K */
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf( 
	z_streamp strm,
	Bytef *buf,
    unsigned size)
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    zmemcpy(buf, strm->next_in, len);
    if (strm->state->wrap == 1) {
        strm->adler = adler32(strm->adler, buf, len);
    }
#ifdef GZIP
    else if (strm->state->wrap == 2) {
        strm->adler = crc32(strm->adler, buf, len);
    }
#endif
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init ( 
    deflate_state *s)
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->insert = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifndef FASTEST
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
#endif
}

#ifndef FASTEST
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
local uInt longest_match( 
	deflate_state *s,
    IPos cur_match)                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}
#endif /* ASMV */

#else /* FASTEST */

/* ---------------------------------------------------------------------------
 * Optimized version for FASTEST only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
}

#endif /* FASTEST */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
                start, match, length);
        do {
            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
        } while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif /* DEBUG */

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window( 
    deflate_state *s)
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (sizeof(int) <= 2) {
            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                more = wsize;

            } else if (more == (unsigned)(-1)) {
                /* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 && lookahead == 1 (input done a byte at time)
                 */
                more--;
            }
        }

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
            n = s->hash_size;
            p = &s->head[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
            } while (--n);

            n = wsize;
#ifndef FASTEST
            p = &s->prev[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
                /* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */
            } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) break;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead + s->insert >= MIN_MATCH) {
            uInt str = s->strstart - s->insert;
            s->ins_h = s->window[str];
            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
            while (s->insert) {
                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
                s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
                s->head[s->ins_h] = (Pos)str;
                str++;
                s->insert--;
                if (s->lookahead + s->insert < MIN_MATCH)
                    break;
            }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
    if (s->high_water < s->window_size) {
        ulg curr = s->strstart + (ulg)(s->lookahead);
        ulg init;

        if (s->high_water < curr) {
            /* Previous high water mark below current data -- zero WIN_INIT
             * bytes or up to end of window, whichever is less.
             */
            init = s->window_size - curr;
            if (init > WIN_INIT)
                init = WIN_INIT;
            zmemzero(s->window + curr, (unsigned)init);
            s->high_water = curr + init;
        }
        else if (s->high_water < (ulg)curr + WIN_INIT) {
            /* High water mark at or above current data, but below current data
             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
             * to end of window, whichever is less.
             */
            init = (ulg)curr + WIN_INIT - s->high_water;
            if (init > s->window_size - s->high_water)
                init = s->window_size - s->high_water;
            zmemzero(s->window + s->high_water, (unsigned)init);
            s->high_water += init;
        }
    }

    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
           "not enough room for search");
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, last) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s->strstart - s->block_start), \
                (last)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, last) { \
   FLUSH_BLOCK_ONLY(s, last); \
   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(  
	deflate_state *s,
    int flush)
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
        Assert(s->block_start >= 0L, "block gone");

        s->strstart += s->lookahead;
        s->lookahead = 0;

        /* Emit a stored block if pending_buf will be full: */
        max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */
            s->lookahead = (uInt)(s->strstart - max_start);
            s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
        }
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if ((long)s->strstart > s->block_start)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(  
	deflate_state *s,
    int flush)
{
    IPos hash_head;       /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++;
            } else
#endif
            {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

#ifndef FASTEST
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow( 
	deflate_state *s,
    int flush)
{
    IPos hash_head;          /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
#if TOO_FAR <= 32767
                || (s->match_length == MIN_MATCH &&
                    s->strstart - s->match_start > TOO_FAR)
#endif
                )) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                           s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
            if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}
#endif /* FASTEST */

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
local block_state deflate_rle( 
	deflate_state *s,
    int flush)
{
    int bflush;             /* set if current block must be flushed */
    uInt prev;              /* byte at distance one to match */
    Bytef *scan, *strend;   /* scan goes up to strend for length of run */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s->lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s->match_length = 0;
        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
            scan = s->window + s->strstart - 1;
            prev = *scan;
            if (prev == *++scan && prev == *++scan && prev == *++scan) {
                strend = s->window + s->strstart + MAX_MATCH;
                do {
                } while (prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         scan < strend);
                s->match_length = MAX_MATCH - (int)(strend - scan);
                if (s->match_length > s->lookahead)
                    s->match_length = s->lookahead;
            }
            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->strstart - 1, s->match_length);

            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;
            s->strstart += s->match_length;
            s->match_length = 0;
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
local block_state deflate_huff( 
	deflate_state *s,
    int flush)
{
    int bflush;             /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we have a literal to write. */
        if (s->lookahead == 0) {
            fill_window(s);
            if (s->lookahead == 0) {
                if (flush == Z_NO_FLUSH)
                    return need_more;
                break;      /* flush the current block */
            }
        }

        /* Output a literal byte */
        s->match_length = 0;
        Tracevv((stderr,"%c", s->window[s->strstart]));
        _tr_tally_lit (s, s->window[s->strstart], bflush);
        s->lookahead--;
        s->strstart++;
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

```

`zlib1/zlib1Code/deflate.h`:

```h
/* deflate.h -- internal compression state
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef DEFLATE_H
#define DEFLATE_H

#include "zutil.h"

/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip encoding
   should be left enabled. */
#ifndef NO_GZIP
#  define GZIP
#endif

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define Buf_size 16
/* size of bit buffer in bi_buf */

#define INIT_STATE    42
#define EXTRA_STATE   69
#define NAME_STATE    73
#define COMMENT_STATE 91
#define HCRC_STATE   103
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    uInt   pending;      /* nb of bytes in the pending buffer */
    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
    gz_headerp  gzhead;  /* gzip header information to write */
    uInt   gzindex;      /* where in extra, name, or comment */
    Byte  method;        /* can only be DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to suppress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    uInt insert;        /* bytes at end of window left to insert */

#ifdef DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

    ulg high_water;
    /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

#define WIN_INIT MAX_MATCH
/* Number of bytes after end of data in window to initialize in order to avoid
   memory checker errors from longest match routines */

        /* in trees.c */
void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
                        ulg stored_len, int last));
void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
                        ulg stored_len, int last));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch ZLIB_INTERNAL _length_code[];
  extern uch ZLIB_INTERNAL _dist_code[];
#else
  extern const uch ZLIB_INTERNAL _length_code[];
  extern const uch ZLIB_INTERNAL _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length)
#endif

#endif /* DEFLATE_H */

```

`zlib1/zlib1Code/gzclose.cpp`:

```cpp
/* gzclose.c -- zlib gzclose() function
 * Copyright (C) 2004, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* gzclose() is in a separate file so that it is linked in only if it is used.
   That way the other gzclose functions can be used instead to avoid linking in
   unneeded compression or decompression routines. */
int ZEXPORT gzclose(
    gzFile file)
{
#ifndef NO_GZCOMPRESS
    gz_statep state;

    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
#else
    return gzclose_r(file);
#endif
}

```

`zlib1/zlib1Code/gzguts.h`:

```h
/* gzguts.h -- zlib internal header definitions for gz* operations
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#ifdef _LARGEFILE64_SOURCE
#  ifndef _LARGEFILE_SOURCE
#    define _LARGEFILE_SOURCE 1
#  endif
#  ifdef _FILE_OFFSET_BITS
#    undef _FILE_OFFSET_BITS
#  endif
#endif

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include <stdio.h>
#include "zlib.h"
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#  include <limits.h>
#endif
#include <fcntl.h>

#ifdef _WIN32
#  include <stddef.h>
#endif

#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
#  include <io.h>
#endif

#ifdef WINAPI_FAMILY
#  define open _open
#  define read _read
#  define write _write
#  define close _close
#endif

#ifdef NO_DEFLATE       /* for compatibility with old definition */
#  define NO_GZCOMPRESS
#endif

#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
   but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
#         define vsnprintf _vsnprintf
#      endif
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#  ifdef VMS
#    define NO_vsnprintf
#  endif
#  ifdef __OS400__
#    define NO_vsnprintf
#  endif
#  ifdef __MVS__
#    define NO_vsnprintf
#  endif
#endif

/* unlike snprintf (which is required in C99, yet still not supported by
   Microsoft more than a decade later!), _snprintf does not guarantee null
   termination of the result -- however this is only used in gzlib.c where
   the result is assured to fit in the space provided */
#ifdef _MSC_VER
#  define snprintf _snprintf
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

/* gz* functions always use library allocation functions */
#ifndef STDC
  extern voidp  malloc OF((uInt size));
  extern void   free   OF((voidpf ptr));
#endif

/* get errno and strerror definition */
#if defined UNDER_CE
#  include <windows.h>
#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
#else
#  ifndef NO_STRERROR
#    include <errno.h>
#    define zstrerror() strerror(errno)
#  else
#    define zstrerror() "stdio error (consult errno)"
#  endif
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
#endif

/* default memLevel */
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif

/* default i/o buffer size -- double this for output when reading (this and
   twice this must be able to fit in an unsigned type) */
#define GZBUFSIZE 8192

/* gzip modes, also provide a little integrity check on the passed structure */
#define GZ_NONE 0
#define GZ_READ 7247
#define GZ_WRITE 31153
#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */

/* values for gz_state how */
#define LOOK 0      /* look for a gzip header */
#define COPY 1      /* copy input directly */
#define GZIP 2      /* decompress a gzip stream */

/* internal gzip file state data structure */
typedef struct {
        /* exposed contents for gzgetc() macro */
    struct gzFile_s x;      /* "x" for exposed */
                            /* x.have: number of bytes available at x.next */
                            /* x.next: next output data to deliver or write */
                            /* x.pos: current position in uncompressed data */
        /* used for both reading and writing */
    int mode;               /* see gzip modes above */
    int fd;                 /* file descriptor */
    char *path;             /* path or fd for error messages */
    unsigned size;          /* buffer size, zero if not allocated yet */
    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
    unsigned char *in;      /* input buffer */
    unsigned char *out;     /* output buffer (double-sized when reading) */
    int direct;             /* 0 if processing gzip, 1 if transparent */
        /* just for reading */
    int how;                /* 0: get header, 1: copy, 2: decompress */
    z_off64_t start;        /* where the gzip data started, for rewinding */
    int eof;                /* true if end of input file reached */
    int past;               /* true if read requested past end */
        /* just for writing */
    int level;              /* compression level */
    int strategy;           /* compression strategy */
        /* seek request */
    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
    int seek;               /* true if seek request pending */
        /* error information */
    int err;                /* error code */
    char *msg;              /* error message */
        /* zlib inflate or deflate stream */
    z_stream strm;          /* stream structure in-place (not a pointer) */
} gz_state;
typedef gz_state FAR *gz_statep;

/* shared functions */
void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
#if defined UNDER_CE
char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
#endif

/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
   value -- needed when comparing unsigned to z_off64_t, which is signed
   (possible z_off64_t types off_t, off64_t, and long are all signed) */
#ifdef INT_MAX
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
#else
unsigned ZLIB_INTERNAL gz_intmax OF((void));
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
#endif

```

`zlib1/zlib1Code/gzlib.cpp`:

```cpp
/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

#if defined(_WIN32) && !defined(__BORLANDC__)
#  define LSEEK _lseeki64
#else
#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
#  define LSEEK lseek64
#else
#  define LSEEK lseek
#endif
#endif

/* Local functions */
local void gz_reset OF((gz_statep));
local gzFile gz_open OF((const void *, int, const char *));

#if defined UNDER_CE

/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */
char ZLIB_INTERNAL *gz_strwinerror (error)
     DWORD error;
{
    static char buf[1024];

    wchar_t *msgbuf;
    DWORD lasterr = GetLastError();
    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        error,
        0, /* Default language */
        (LPVOID)&msgbuf,
        0,
        NULL);
    if (chars != 0) {
        /* If there is an \r\n appended, zap it.  */
        if (chars >= 2
            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
            chars -= 2;
            msgbuf[chars] = 0;
        }

        if (chars > sizeof (buf) - 1) {
            chars = sizeof (buf) - 1;
            msgbuf[chars] = 0;
        }

        wcstombs(buf, msgbuf, chars + 1);
        LocalFree(msgbuf);
    }
    else {
        sprintf(buf, "unknown win32 error (%ld)", error);
    }

    SetLastError(lasterr);
    return buf;
}

#endif /* UNDER_CE */

/* Reset gzip file state */
local void gz_reset( 
    gz_statep state)
{
    state->x.have = 0;              /* no output data available */
    if (state->mode == GZ_READ) {   /* for reading ... */
        state->eof = 0;             /* not at end of file */
        state->past = 0;            /* have not read past end yet */
        state->how = LOOK;          /* look for gzip header */
    }
    state->seek = 0;                /* no seek request pending */
    gz_error(state, Z_OK, NULL);    /* clear error */
    state->x.pos = 0;               /* no uncompressed data yet */
    state->strm.avail_in = 0;       /* no input data yet */
}

/* Open a gzip file either by name or file descriptor. */
local gzFile gz_open( 
	const void *path,
	int fd,
    const char *mode)
{
    gz_statep state;
    size_t len;
    int oflag;
#ifdef O_CLOEXEC
    int cloexec = 0;
#endif
#ifdef O_EXCL
    int exclusive = 0;
#endif

    /* check input */
    if (path == NULL)
        return NULL;

    /* allocate gzFile structure to return */
    state = (gz_statep)malloc(sizeof(gz_state));
    if (state == NULL)
        return NULL;
    state->size = 0;            /* no buffers allocated yet */
    state->want = GZBUFSIZE;    /* requested buffer size */
    state->msg = NULL;          /* no error message yet */

    /* interpret mode */
    state->mode = GZ_NONE;
    state->level = Z_DEFAULT_COMPRESSION;
    state->strategy = Z_DEFAULT_STRATEGY;
    state->direct = 0;
    while (*mode) {
        if (*mode >= '0' && *mode <= '9')
            state->level = *mode - '0';
        else
            switch (*mode) {
            case 'r':
                state->mode = GZ_READ;
                break;
#ifndef NO_GZCOMPRESS
            case 'w':
                state->mode = GZ_WRITE;
                break;
            case 'a':
                state->mode = GZ_APPEND;
                break;
#endif
            case '+':       /* can't read and write at the same time */
                free(state);
                return NULL;
            case 'b':       /* ignore -- will request binary anyway */
                break;
#ifdef O_CLOEXEC
            case 'e':
                cloexec = 1;
                break;
#endif
#ifdef O_EXCL
            case 'x':
                exclusive = 1;
                break;
#endif
            case 'f':
                state->strategy = Z_FILTERED;
                break;
            case 'h':
                state->strategy = Z_HUFFMAN_ONLY;
                break;
            case 'R':
                state->strategy = Z_RLE;
                break;
            case 'F':
                state->strategy = Z_FIXED;
                break;
            case 'T':
                state->direct = 1;
                break;
            default:        /* could consider as an error, but just ignore */
                ;
            }
        mode++;
    }

    /* must provide an "r", "w", or "a" */
    if (state->mode == GZ_NONE) {
        free(state);
        return NULL;
    }

    /* can't force transparent read */
    if (state->mode == GZ_READ) {
        if (state->direct) {
            free(state);
            return NULL;
        }
        state->direct = 1;      /* for empty file */
    }

    /* save the path name for error messages */
#ifdef _WIN32
    if (fd == -2) {
        len = wcstombs(NULL, (const wchar_t*)path, 0);
        if (len == (size_t)-1)
            len = 0;
    }
    else
#endif
        len = strlen((const char *)path);
    state->path = (char *)malloc(len + 1);
    if (state->path == NULL) {
        free(state);
        return NULL;
    }
#ifdef _WIN32
    if (fd == -2)
        if (len)
			wcstombs ( state->path, ( const wchar_t* ) path, len + 1 );
        else
            *(state->path) = 0;
    else
#endif
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
        snprintf(state->path, len + 1, "%s", (const char *)path);
#else
        strcpy(state->path, path);
#endif

    /* compute the flags for open() */
    oflag =
#ifdef O_LARGEFILE
        O_LARGEFILE |
#endif
#ifdef O_BINARY
        O_BINARY |
#endif
#ifdef O_CLOEXEC
        (cloexec ? O_CLOEXEC : 0) |
#endif
        (state->mode == GZ_READ ?
         O_RDONLY :
         (O_WRONLY | O_CREAT |
#ifdef O_EXCL
          (exclusive ? O_EXCL : 0) |
#endif
          (state->mode == GZ_WRITE ?
           O_TRUNC :
           O_APPEND)));

    /* open the file with the appropriate flags (or just use fd) */
    state->fd = fd > -1 ? fd : (
#ifdef _WIN32
		fd == -2 ? _wopen ( ( const wchar_t* ) path, oflag, 0666 ) :
#endif
        open((const char *)path, oflag, 0666));
    if (state->fd == -1) {
        free(state->path);
        free(state);
        return NULL;
    }
    if (state->mode == GZ_APPEND)
        state->mode = GZ_WRITE;         /* simplify later checks */

    /* save the current position for rewinding (only if reading) */
    if (state->mode == GZ_READ) {
        state->start = LSEEK(state->fd, 0, SEEK_CUR);
        if (state->start == -1) state->start = 0;
    }

    /* initialize stream */
    gz_reset(state);

    /* return stream */
    return (gzFile)state;
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen( 
    const char *path,
    const char *mode)
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen64( 
    const char *path,
    const char *mode)
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzdopen( 
	int fd,
    const char *mode)
{
    char *path;         /* identifier for error messages */
    gzFile gz;

    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
        return NULL;
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd); /* for debugging */
#else
    sprintf(path, "<fd:%d>", fd);   /* for debugging */
#endif
    gz = gz_open(path, fd, mode);
    free(path);
    return gz;
}

/* -- see zlib.h -- */
#ifdef _WIN32
gzFile ZEXPORT gzopen_w( 
	const wchar_t *path,
    const char *mode)
{
    return gz_open(path, -2, mode);
}
#endif

/* -- see zlib.h -- */
int ZEXPORT gzbuffer( 
	gzFile file,
    unsigned size)
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* make sure we haven't already allocated memory */
    if (state->size != 0)
        return -1;

    /* check and set requested size */
    if (size < 2)
        size = 2;               /* need two bytes to check magic header */
    state->want = size;
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzrewind(  
    gzFile file)
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* back up and start over */
    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
        return -1;
    gz_reset(state);
    return 0;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzseek64(
	gzFile file,
	z_off64_t offset,
    int whence)
{
    unsigned n;
    z_off64_t ret;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* check that there's no error */
    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;

    /* can only seek from start or relative to current position */
    if (whence != SEEK_SET && whence != SEEK_CUR)
        return -1;

    /* normalize offset to a SEEK_CUR specification */
    if (whence == SEEK_SET)
        offset -= state->x.pos;
    else if (state->seek)
        offset += state->skip;
    state->seek = 0;

    /* if within raw area while reading, just go there */
    if (state->mode == GZ_READ && state->how == COPY &&
            state->x.pos + offset >= 0) {
        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
        if (ret == -1)
            return -1;
        state->x.have = 0;
        state->eof = 0;
        state->past = 0;
        state->seek = 0;
        gz_error(state, Z_OK, NULL);
        state->strm.avail_in = 0;
        state->x.pos += offset;
        return state->x.pos;
    }

    /* calculate skip amount, rewinding if needed for back seek when reading */
    if (offset < 0) {
        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
            return -1;
        offset += state->x.pos;
        if (offset < 0)                     /* before start of file! */
            return -1;
        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
            return -1;
    }

    /* if reading, skip what's in output buffer (one less gzgetc() check) */
    if (state->mode == GZ_READ) {
        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
            (unsigned)offset : state->x.have;
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        offset -= n;
    }

    /* request skip (if not zero) */
    if (offset) {
        state->seek = 1;
        state->skip = offset;
    }
    return state->x.pos + offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzseek( 
	gzFile file,
	z_off_t offset,
    int whence)
{
    z_off64_t ret;

    ret = gzseek64(file, (z_off64_t)offset, whence);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gztell64( 
	gzFile file)
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* return position */
    return state->x.pos + (state->seek ? state->skip : 0);
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gztell( 
    gzFile file)
{
    z_off64_t ret;

    ret = gztell64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzoffset64( 
    gzFile file)
{
    z_off64_t offset;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* compute and return effective offset in file */
    offset = LSEEK(state->fd, 0, SEEK_CUR);
    if (offset == -1)
        return -1;
    if (state->mode == GZ_READ)             /* reading */
        offset -= state->strm.avail_in;     /* don't count buffered input */
    return offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzoffset( 
    gzFile file)
{
    z_off64_t ret;

    ret = gzoffset64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
int ZEXPORT gzeof( 
    gzFile file)
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return 0;

    /* return end-of-file state */
    return state->mode == GZ_READ ? state->past : 0;
}

/* -- see zlib.h -- */
const char * ZEXPORT gzerror( 
	gzFile file,
    int *errnum)
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return NULL;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return NULL;

    /* return error information */
    if (errnum != NULL)
        *errnum = state->err;
    return state->err == Z_MEM_ERROR ? "out of memory" :
                                       (state->msg == NULL ? "" : state->msg);
}

/* -- see zlib.h -- */
void ZEXPORT gzclearerr( 
    gzFile file)
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return;

    /* clear error and end-of-file */
    if (state->mode == GZ_READ) {
        state->eof = 0;
        state->past = 0;
    }
    gz_error(state, Z_OK, NULL);
}

/* Create an error message in allocated memory and set state->err and
   state->msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */
void ZLIB_INTERNAL gz_error( 
	gz_statep state,
	int err,
    const char *msg)
{
    /* free previously allocated message and clear */
    if (state->msg != NULL) {
        if (state->err != Z_MEM_ERROR)
            free(state->msg);
        state->msg = NULL;
    }

    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
    if (err != Z_OK && err != Z_BUF_ERROR)
        state->x.have = 0;

    /* set error code, and if no message, then done */
    state->err = err;
    if (msg == NULL)
        return;

    /* for an out of memory error, return literal string when requested */
    if (err == Z_MEM_ERROR)
        return;

    /* construct error message with path */
    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
            NULL) {
        state->err = Z_MEM_ERROR;
        return;
    }
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
             "%s%s%s", state->path, ": ", msg);
#else
    strcpy(state->msg, state->path);
    strcat(state->msg, ": ");
    strcat(state->msg, msg);
#endif
    return;
}

#ifndef INT_MAX
/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) >> 1 */
unsigned ZLIB_INTERNAL gz_intmax()
{
    unsigned p, q;

    p = 1;
    do {
        q = p;
        p <<= 1;
        p++;
    } while (p > q);
    return q >> 1;
}
#endif

```

`zlib1/zlib1Code/gzread.cpp`:

```cpp
/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
local int gz_avail OF((gz_statep));
local int gz_look OF((gz_statep));
local int gz_decomp OF((gz_statep));
local int gz_fetch OF((gz_statep));
local int gz_skip OF((gz_statep, z_off64_t));

/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state->fd, and update state->eof, state->err, and state->msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */
local int gz_load( 
    gz_statep state,
	unsigned char *buf,
	unsigned len,
    unsigned *have)
{
    int ret;

    *have = 0;
    do {
        ret = read(state->fd, buf + *have, len - *have);
        if (ret <= 0)
            break;
        *have += ret;
    } while (*have < len);
    if (ret < 0) {
        gz_error(state, Z_ERRNO, zstrerror());
        return -1;
    }
    if (ret == 0)
        state->eof = 1;
    return 0;
}

/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm->avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */
local int gz_avail( 
    gz_statep state)
{
    unsigned got;
    z_streamp strm = &(state->strm);

    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;
    if (state->eof == 0) {
        if (strm->avail_in) {       /* copy what's there to the start */
            unsigned char *p = state->in;
            unsigned const char *q = strm->next_in;
            unsigned n = strm->avail_in;
            do {
                *p++ = *q++;
            } while (--n);
        }
        if (gz_load(state, state->in + strm->avail_in,
                    state->size - strm->avail_in, &got) == -1)
            return -1;
        strm->avail_in += got;
        strm->next_in = state->in;
    }
    return 0;
}

/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
   If this is the first time in, allocate required memory.  state->how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */
local int gz_look( 
    gz_statep state)
{
    z_streamp strm = &(state->strm);

    /* allocate read buffers and inflate memory */
    if (state->size == 0) {
        /* allocate buffers */
        state->in = (unsigned char *)malloc(state->want);
        state->out = (unsigned char *)malloc(state->want << 1);
        if (state->in == NULL || state->out == NULL) {
            if (state->out != NULL)
                free(state->out);
            if (state->in != NULL)
                free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        state->size = state->want;

        /* allocate inflate memory */
        state->strm.zalloc = Z_NULL;
        state->strm.zfree = Z_NULL;
        state->strm.opaque = Z_NULL;
        state->strm.avail_in = 0;
        state->strm.next_in = Z_NULL;
        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
            free(state->out);
            free(state->in);
            state->size = 0;
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* get at least the magic bytes in the input buffer */
    if (strm->avail_in < 2) {
        if (gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0)
            return 0;
    }

    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
       a logical dilemma here when considering the case of a partially written
       gzip file, to wit, if a single 31 byte is written, then we cannot tell
       whether this is a single-byte file, or just a partially written gzip
       file -- for here we assume that if a gzip file is being written, then
       the header will be written in a single operation, so that reading a
       single byte is sufficient indication that it is not a gzip file) */
    if (strm->avail_in > 1 &&
            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
        inflateReset(strm);
        state->how = GZIP;
        state->direct = 0;
        return 0;
    }

    /* no gzip header -- if we were decoding gzip before, then this is trailing
       garbage.  Ignore the trailing garbage and finish. */
    if (state->direct == 0) {
        strm->avail_in = 0;
        state->eof = 1;
        state->x.have = 0;
        return 0;
    }

    /* doing raw i/o, copy any leftover input to output -- this assumes that
       the output buffer is larger than the input buffer, which also assures
       space for gzungetc() */
    state->x.next = state->out;
    if (strm->avail_in) {
        memcpy(state->x.next, strm->next_in, strm->avail_in);
        state->x.have = strm->avail_in;
        strm->avail_in = 0;
    }
    state->how = COPY;
    state->direct = 1;
    return 0;
}

/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state->x.have and state->x.next point to the just decompressed
   data.  If the gzip stream completes, state->how is reset to LOOK to look for
   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   on success, -1 on failure. */
local int gz_decomp( 
    gz_statep state)
{
    int ret = Z_OK;
    unsigned had;
    z_streamp strm = &(state->strm);

    /* fill output buffer up to end of deflate stream */
    had = strm->avail_out;
    do {
        /* get more input for inflate() */
        if (strm->avail_in == 0 && gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0) {
            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
            break;
        }

        /* decompress and handle errors */
        ret = inflate(strm, Z_NO_FLUSH);
        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
            gz_error(state, Z_STREAM_ERROR,
                     "internal error: inflate stream corrupt");
            return -1;
        }
        if (ret == Z_MEM_ERROR) {
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
            gz_error(state, Z_DATA_ERROR,
                     strm->msg == NULL ? "compressed data error" : strm->msg);
            return -1;
        }
    } while (strm->avail_out && ret != Z_STREAM_END);

    /* update available output */
    state->x.have = had - strm->avail_out;
    state->x.next = strm->next_out - state->x.have;

    /* if the gzip stream completed successfully, look for another */
    if (ret == Z_STREAM_END)
        state->how = LOOK;

    /* good decompression */
    return 0;
}

/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state->how.  If state->how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */
local int gz_fetch( 
    gz_statep state)
{
    z_streamp strm = &(state->strm);

    do {
        switch(state->how) {
        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
            if (gz_look(state) == -1)
                return -1;
            if (state->how == LOOK)
                return 0;
            break;
        case COPY:      /* -> COPY */
            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
                    == -1)
                return -1;
            state->x.next = state->out;
            return 0;
        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
            strm->avail_out = state->size << 1;
            strm->next_out = state->out;
            if (gz_decomp(state) == -1)
                return -1;
        }
    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
    return 0;
}

/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
local int gz_skip( 
	gz_statep state,
    z_off64_t len)
{
    unsigned n;

    /* skip over len bytes or reach end-of-file, whichever comes first */
    while (len)
        /* skip over whatever is in output buffer */
        if (state->x.have) {
            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
                (unsigned)len : state->x.have;
            state->x.have -= n;
            state->x.next += n;
            state->x.pos += n;
            len -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && state->strm.avail_in == 0)
            break;

        /* need more data to skip -- load up output buffer */
        else {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
        }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzread( 
	gzFile file,
	voidp buf,
    unsigned len)
{
    unsigned got, n;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return -1;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* get len bytes to buf, or less than len if at the end */
    got = 0;
    do {
        /* first just try copying data from the output buffer */
        if (state->x.have) {
            n = state->x.have > len ? len : state->x.have;
            memcpy(buf, state->x.next, n);
            state->x.next += n;
            state->x.have -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && strm->avail_in == 0) {
            state->past = 1;        /* tried to read past end */
            break;
        }

        /* need output data -- for small len or new stream load up our output
           buffer */
        else if (state->how == LOOK || len < (state->size << 1)) {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
            continue;       /* no progress yet -- go back to copy above */
            /* the copy above assures that we will leave with space in the
               output buffer, allowing at least one gzungetc() to succeed */
        }

        /* large len -- read directly into user buffer */
        else if (state->how == COPY) {      /* read directly */
            if (gz_load(state, (unsigned char *)buf, len, &n) == -1)
                return -1;
        }

        /* large len -- decompress directly into user buffer */
        else {  /* state->how == GZIP */
            strm->avail_out = len;
            strm->next_out = (unsigned char *)buf;
            if (gz_decomp(state) == -1)
                return -1;
            n = state->x.have;
            state->x.have = 0;
        }

        /* update progress */
        len -= n;
        buf = (char *)buf + n;
        got += n;
        state->x.pos += n;
    } while (len);

    /* return number of bytes read into user buffer (will fit in int) */
    return (int)got;
}

/* -- see zlib.h -- */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#else
#  undef gzgetc
#endif
int ZEXPORT gzgetc( 
    gzFile file)
{
    int ret;
    unsigned char buf[1];
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* try output buffer (no need to check for skip request) */
    if (state->x.have) {
        state->x.have--;
        state->x.pos++;
        return *(state->x.next)++;
    }

    /* nothing there -- try gzread() */
    ret = gzread(file, buf, 1);
    return ret < 1 ? -1 : buf[0];
}

int ZEXPORT gzgetc_( 
gzFile file)
{
    return gzgetc(file);
}

/* -- see zlib.h -- */
int ZEXPORT gzungetc( 
	int c,
    gzFile file)
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* can't push EOF */
    if (c < 0)
        return -1;

    /* if output buffer empty, put byte at end (allows more pushing) */
    if (state->x.have == 0) {
        state->x.have = 1;
        state->x.next = state->out + (state->size << 1) - 1;
        state->x.next[0] = c;
        state->x.pos--;
        state->past = 0;
        return c;
    }

    /* if no room, give up (must have already done a gzungetc()) */
    if (state->x.have == (state->size << 1)) {
        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
        return -1;
    }

    /* slide output data if needed and insert byte before existing data */
    if (state->x.next == state->out) {
        unsigned char *src = state->out + state->x.have;
        unsigned char *dest = state->out + (state->size << 1);
        while (src > state->out)
            *--dest = *--src;
        state->x.next = dest;
    }
    state->x.have++;
    state->x.next--;
    state->x.next[0] = c;
    state->x.pos--;
    state->past = 0;
    return c;
}

/* -- see zlib.h -- */
char * ZEXPORT gzgets( 
	gzFile file,
	char *buf,
    int len)
{
    unsigned left, n;
    char *str;
    unsigned char *eol;
    gz_statep state;

    /* check parameters and get internal structure */
    if (file == NULL || buf == NULL || len < 1)
        return NULL;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return NULL;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return NULL;
    }

    /* copy output bytes up to new line or len - 1, whichever comes first --
       append a terminating zero to the string (we don't check for a zero in
       the contents, let the user worry about that) */
    str = buf;
    left = (unsigned)len - 1;
    if (left) do {
        /* assure that something is in the output buffer */
        if (state->x.have == 0 && gz_fetch(state) == -1)
            return NULL;                /* error */
        if (state->x.have == 0) {       /* end of file */
            state->past = 1;            /* read past end */
            break;                      /* return what we have */
        }

        /* look for end-of-line in current output buffer */
        n = state->x.have > left ? left : state->x.have;
        eol = (unsigned char *)memchr(state->x.next, '\n', n);
        if (eol != NULL)
            n = (unsigned)(eol - state->x.next) + 1;

        /* copy through end-of-line, or remainder if not found */
        memcpy(buf, state->x.next, n);
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        left -= n;
        buf += n;
    } while (left && eol == NULL);

    /* return terminated string, or if nothing, end of file */
    if (buf == str)
        return NULL;
    buf[0] = 0;
    return str;
}

/* -- see zlib.h -- */
int ZEXPORT gzdirect( 
    gzFile file)
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* if the state is not known, but we can find out, then do so (this is
       mainly for right after a gzopen() or gzdopen()) */
    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
        (void)gz_look(state);

    /* return 1 if transparent, 0 if processing a gzip stream */
    return state->direct;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_r( 
    gzFile file)
{
    int ret, err;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're reading */
    if (state->mode != GZ_READ)
        return Z_STREAM_ERROR;

    /* free memory and close file */
    if (state->size) {
        inflateEnd(&(state->strm));
        free(state->out);
        free(state->in);
    }
    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
    gz_error(state, Z_OK, NULL);
    free(state->path);
    ret = close(state->fd);
    free(state);
    return ret ? Z_ERRNO : err;
}

```

`zlib1/zlib1Code/gzwrite.cpp`:

```cpp
/* gzwrite.c -- zlib functions for writing gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_init OF((gz_statep));
local int gz_comp OF((gz_statep, int));
local int gz_zero OF((gz_statep, z_off64_t));

/* Initialize state for writing a gzip file.  Mark initialization by setting
   state->size to non-zero.  Return -1 on failure or 0 on success. */
local int gz_init( 
    gz_statep state)
{
    int ret;
    z_streamp strm = &(state->strm);

    /* allocate input buffer */
    state->in = (unsigned char *)malloc(state->want);
    if (state->in == NULL) {
        gz_error(state, Z_MEM_ERROR, "out of memory");
        return -1;
    }

    /* only need output buffer and deflate state if compressing */
    if (!state->direct) {
        /* allocate output buffer */
        state->out = (unsigned char *)malloc(state->want);
        if (state->out == NULL) {
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }

        /* allocate deflate memory, set up for gzip compression */
        strm->zalloc = Z_NULL;
        strm->zfree = Z_NULL;
        strm->opaque = Z_NULL;
        ret = deflateInit2(strm, state->level, Z_DEFLATED,
                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
        if (ret != Z_OK) {
            free(state->out);
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* mark state as initialized */
    state->size = state->want;

    /* initialize write buffer if compressing */
    if (!state->direct) {
        strm->avail_out = state->size;
        strm->next_out = state->out;
        state->x.next = strm->next_out;
    }
    return 0;
}

/* Compress whatever is at avail_in and next_in and write to the output file.
   Return -1 if there is an error writing to the output file, otherwise 0.
   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
   then the deflate() state is reset to start a new gzip stream.  If gz->direct
   is true, then simply write to the output file without compressing, and
   ignore flush. */
local int gz_comp( 
	gz_statep state,
    int flush)
{
    int ret, got;
    unsigned have;
    z_streamp strm = &(state->strm);

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return -1;

    /* write directly if requested */
    if (state->direct) {
        got = write(state->fd, strm->next_in, strm->avail_in);
        if (got < 0 || (unsigned)got != strm->avail_in) {
            gz_error(state, Z_ERRNO, zstrerror());
            return -1;
        }
        strm->avail_in = 0;
        return 0;
    }

    /* run deflate() on provided input until it produces no more output */
    ret = Z_OK;
    do {
        /* write out current buffer contents if full, or if flushing, but if
           doing Z_FINISH then don't write until we get to Z_STREAM_END */
        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
            (flush != Z_FINISH || ret == Z_STREAM_END))) {
            have = (unsigned)(strm->next_out - state->x.next);
            if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
                         (unsigned)got != have)) {
                gz_error(state, Z_ERRNO, zstrerror());
                return -1;
            }
            if (strm->avail_out == 0) {
                strm->avail_out = state->size;
                strm->next_out = state->out;
            }
            state->x.next = strm->next_out;
        }

        /* compress */
        have = strm->avail_out;
        ret = deflate(strm, flush);
        if (ret == Z_STREAM_ERROR) {
            gz_error(state, Z_STREAM_ERROR,
                      "internal error: deflate stream corrupt");
            return -1;
        }
        have -= strm->avail_out;
    } while (have);

    /* if that completed a deflate stream, allow another to start */
    if (flush == Z_FINISH)
        deflateReset(strm);

    /* all done, no errors */
    return 0;
}

/* Compress len zeros to output.  Return -1 on error, 0 on success. */
local int gz_zero( 
	gz_statep state,
    z_off64_t len)
{
    int first;
    unsigned n;
    z_streamp strm = &(state->strm);

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return -1;

    /* compress len zeros (len guaranteed > 0) */
    first = 1;
    while (len) {
        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
            (unsigned)len : state->size;
        if (first) {
            memset(state->in, 0, n);
            first = 0;
        }
        strm->avail_in = n;
        strm->next_in = state->in;
        state->x.pos += n;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return -1;
        len -= n;
    }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzwrite( 
	gzFile file,
	voidpc buf,
    unsigned len)
{
    unsigned put = len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return 0;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* for small len, copy to input buffer, otherwise compress directly */
    if (len < state->size) {
        /* copy to input buffer, compress when full */
        do {
            unsigned have, copy;

            if (strm->avail_in == 0)
                strm->next_in = state->in;
            have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
            copy = state->size - have;
            if (copy > len)
                copy = len;
            memcpy(state->in + have, buf, copy);
            strm->avail_in += copy;
            state->x.pos += copy;
            buf = (const char *)buf + copy;
            len -= copy;
            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
                return 0;
        } while (len);
    }
    else {
        /* consume whatever's left in the input buffer */
        if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;

        /* directly compress user buffer to file */
        strm->avail_in = len;
        strm->next_in = (z_const Bytef *)buf;
        state->x.pos += len;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;
    }

    /* input was all buffered or compressed (put will fit in int) */
    return (int)put;
}

/* -- see zlib.h -- */
int ZEXPORT gzputc( 
	gzFile file,
    int c)
{
    unsigned have;
    unsigned char buf[1];
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return -1;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* try writing to input buffer for speed (state->size == 0 if buffer not
       initialized) */
    if (state->size) {
        if (strm->avail_in == 0)
            strm->next_in = state->in;
        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
        if (have < state->size) {
            state->in[have] = c;
            strm->avail_in++;
            state->x.pos++;
            return c & 0xff;
        }
    }

    /* no room in buffer or not initialized, use gz_write() */
    buf[0] = c;
    if (gzwrite(file, buf, 1) != 1)
        return -1;
    return c & 0xff;
}

/* -- see zlib.h -- */
int ZEXPORT gzputs( 
    gzFile file,
	const char *str)
{
    int ret;
    unsigned len;

    /* write string */
    len = (unsigned)strlen(str);
    ret = gzwrite(file, str, len);
    return ret == 0 && len != 0 ? -1 : ret;
}

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#include <stdarg.h>

/* -- see zlib.h -- */
int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_vsnprintf
#  ifdef HAS_vsprintf_void
    (void)vsprintf((char *)(state->in), format, va);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = vsprintf((char *)(state->in), format, va);
#  endif
#else
#  ifdef HAS_vsnprintf_void
    (void)vsnprintf((char *)(state->in), size, format, va);
    len = strlen((char *)(state->in));
#  else
    len = vsnprintf((char *)(state->in), size, format, va);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
{
    va_list va;
    int ret;

    va_start(va, format);
    ret = gzvprintf(file, format, va);
    va_end(va);
    return ret;
}

#else /* !STDC && !Z_HAVE_STDARG_H */

/* -- see zlib.h -- */
int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that can really pass pointer in ints */
    if (sizeof(int) != sizeof(void *))
        return 0;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_snprintf
#  ifdef HAS_sprintf_void
    sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
                  a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#else
#  ifdef HAS_snprintf_void
    snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6, a7, a8,
             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    len = strlen((char *)(state->in));
#  else
    len = snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6,
                   a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18,
                   a19, a20);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

#endif

/* -- see zlib.h -- */
int ZEXPORT gzflush( 
	gzFile file,
    int flush)
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* check flush parameter */
    if (flush < 0 || flush > Z_FINISH)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* compress remaining data with requested flush */
    gz_comp(state, flush);
    return state->err;
}

/* -- see zlib.h -- */
int ZEXPORT gzsetparams( 
	gzFile file,
int level,
    int strategy)
{
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* if no change is requested, then do nothing */
    if (level == state->level && strategy == state->strategy)
        return Z_OK;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* change compression parameters for subsequent input */
    if (state->size) {
        /* flush previous input with previous parameters before changing */
        if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)
            return state->err;
        deflateParams(strm, level, strategy);
    }
    state->level = level;
    state->strategy = strategy;
    return Z_OK;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_w( 
    gzFile file)
{
    int ret = Z_OK;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're writing */
    if (state->mode != GZ_WRITE)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            ret = state->err;
    }

    /* flush, free memory, and close file */
    if (gz_comp(state, Z_FINISH) == -1)
        ret = state->err;
    if (state->size) {
        if (!state->direct) {
            (void)deflateEnd(&(state->strm));
            free(state->out);
        }
        free(state->in);
    }
    gz_error(state, Z_OK, NULL);
    free(state->path);
    if (close(state->fd) == -1)
        ret = Z_ERRNO;
    free(state);
    return ret;
}

```

`zlib1/zlib1Code/infback.cpp`:

```cpp
/* infback.c -- inflate using a call-back interface
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
   This code is largely copied from inflate.c.  Normally either infback.o or
   inflate.o would be linked into an application--not both.  The interface
   with inffast.c is retained so that optimized assembler-coded versions of
   inflate_fast() can be used with either inflate.c or infback.c.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));

/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */
int ZEXPORT inflateBackInit_( 
z_streamp strm,
int windowBits,
unsigned char FAR *window,
const char *version,
int stream_size)
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL || window == Z_NULL ||
        windowBits < 8 || windowBits > 15)
        return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
    strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
                                               sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->dmax = 32768U;
    state->wbits = windowBits;
    state->wsize = 1U << windowBits;
    state->window = window;
    state->wnext = 0;
    state->whave = 0;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables( 
struct inflate_state FAR *state)
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

/* Macros for inflateBack(): */

/* Load returned state from inflate_fast() */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Set state from registers for inflate_fast() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Assure that some input is available.  If input is requested, but denied,
   then return a Z_BUF_ERROR from inflateBack(). */
#define PULL() \
    do { \
        if (have == 0) { \
            have = in(in_desc, &next); \
            if (have == 0) { \
                next = Z_NULL; \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflateBack()
   with an error if there is no input available. */
#define PULLBYTE() \
    do { \
        PULL(); \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflateBack() with
   an error. */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/* Assure that some output space is available, by writing out the window
   if it's full.  If the write fails, return from inflateBack() with a
   Z_BUF_ERROR. */
#define ROOM() \
    do { \
        if (left == 0) { \
            put = state->window; \
            left = state->wsize; \
            state->whave = left; \
            if (out(out_desc, put, left)) { \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */
int ZEXPORT inflateBack( 
	z_streamp strm,
	in_func in,
	void FAR *in_desc,
	out_func out,
void FAR *out_desc)
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    /* Check that the strm exists and that the state was initialized */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* Reset the state */
    strm->msg = Z_NULL;
    state->mode = TYPE;
    state->last = 0;
    state->whave = 0;
    next = strm->next_in;
    have = next != Z_NULL ? strm->avail_in : 0;
    hold = 0;
    bits = 0;
    put = state->window;
    left = state->wsize;

    /* Inflate until end of block marked as last */
    for (;;)
        switch (state->mode) {
        case TYPE:
            /* determine and dispatch block type */
            if (state->last) {
                BYTEBITS();
                state->mode = DONE;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;

        case STORED:
            /* get and verify stored block length */
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();

            /* copy stored block from input to output */
            while (state->length != 0) {
                copy = state->length;
                PULL();
                ROOM();
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;

        case TABLE:
            /* get dynamic table entries descriptor */
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));

            /* get code length code lengths (not a typo) */
            state->have = 0;
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));

            /* get length and distance code code lengths */
            state->have = 0;
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = (unsigned)(state->lens[state->have - 1]);
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;

        case LEN:
            /* use inflate_fast() if we have enough input and output */
            if (have >= 6 && left >= 258) {
                RESTORE();
                if (state->whave < state->wsize)
                    state->whave = state->wsize - left;
                inflate_fast(strm, state->wsize);
                LOAD();
                break;
            }

            /* get a literal, length, or end-of-block code */
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            state->length = (unsigned)here.val;

            /* process literal */
            if (here.op == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                ROOM();
                *put++ = (unsigned char)(state->length);
                left--;
                state->mode = LEN;
                break;
            }

            /* process end of block */
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }

            /* invalid code */
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }

            /* length code -- get extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));

            /* get distance code */
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;

            /* get distance extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
            }
            if (state->offset > state->wsize - (state->whave < state->wsize ?
                                                left : 0)) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));

            /* copy match from window to output */
            do {
                ROOM();
                copy = state->wsize - state->offset;
                if (copy < left) {
                    from = put + copy;
                    copy = left - copy;
                }
                else {
                    from = put - state->offset;
                    copy = left;
                }
                if (copy > state->length) copy = state->length;
                state->length -= copy;
                left -= copy;
                do {
                    *put++ = *from++;
                } while (--copy);
            } while (state->length != 0);
            break;

        case DONE:
            /* inflate stream terminated properly -- write leftover output */
            ret = Z_STREAM_END;
            if (left < state->wsize) {
                if (out(out_desc, state->window, state->wsize - left))
                    ret = Z_BUF_ERROR;
            }
            goto inf_leave;

        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;

        default:                /* can't happen, but makes compilers happy */
            ret = Z_STREAM_ERROR;
            goto inf_leave;
        }

    /* Return unused input */
  inf_leave:
    strm->next_in = next;
    strm->avail_in = have;
    return ret;
}

int ZEXPORT inflateBackEnd( 
z_streamp strm)
{
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

```

`zlib1/zlib1Code/inffast.cpp`:

```cpp
/* inffast.c -- fast decoding
 * Copyright (C) 1995-2008, 2010, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifndef ASMINF

/* Allow machine dependent optimization for post-increment or pre-increment.
   Based on testing to date,
   Pre-increment preferred for:
   - PowerPC G3 (Adler)
   - MIPS R5000 (Randers-Pehrson)
   Post-increment preferred for:
   - none
   No measurable difference:
   - Pentium III (Anderson)
   - M68060 (Nikl)
 */
#ifdef POSTINC
#  define OFF 0
#  define PUP(a) *(a)++
#else
#  define OFF 1
#  define PUP(a) *++(a)
#endif

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state->mode == LEN
        strm->avail_in >= 6
        strm->avail_out >= 258
        start >= strm->avail_out
        state->bits < 8

   On return, state->mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm->avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void ZLIB_INTERNAL inflate_fast( 
	z_streamp strm,
unsigned start)         /* inflate()'s starting value for strm->avail_out */
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *in;      /* local strm->next_in */
    z_const unsigned char FAR *last;    /* have enough input while in < last */
    unsigned char FAR *out;     /* local strm->next_out */
    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
    unsigned char FAR *end;     /* while out < end, enough space available */
#ifdef INFLATE_STRICT
    unsigned dmax;              /* maximum distance from zlib header */
#endif
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
    unsigned long hold;         /* local strm->hold */
    unsigned bits;              /* local strm->bits */
    code const FAR *lcode;      /* local strm->lencode */
    code const FAR *dcode;      /* local strm->distcode */
    unsigned lmask;             /* mask for first level of length codes */
    unsigned dmask;             /* mask for first level of distance codes */
    code here;                  /* retrieved table entry */
    unsigned op;                /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    wnext = state->wnext;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", here.val));
            PUP(out) = (unsigned char)(here.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(here.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
                hold >>= op;
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
            }
            here = dcode[hold & dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op & 16) {                      /* distance base */
                dist = (unsigned)(here.val);
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
#ifdef INFLATE_STRICT
                if (dist > dmax) {
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
                        if (state->sane) {
                            strm->msg =
                                (char *)"invalid distance too far back";
                            state->mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len <= op - whave) {
                            do {
                                PUP(out) = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            PUP(out) = 0;
                        } while (--op > whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                PUP(out) = PUP(from);
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window - OFF;
                    if (wnext == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext < op) {      /* wrap around window */
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = window - OFF;
                            if (wnext < len) {  /* some from start of window */
                                op = wnext;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
                                } while (--op);
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += wnext - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
                else {
                    from = out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    } while (len > 2);
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
                here = dcode[here.val + (hold & ((1U << op) - 1))];
                goto dodist;
            }
            else {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            here = lcode[here.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    in -= len;
    bits -= len << 3;
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
    state->bits = bits;
    return;
}

/*
   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
   - Using bit fields for code structure
   - Different op definition to avoid & for extra bits (do & for table bits)
   - Three separate decoding do-loops for direct, window, and wnext == 0
   - Special case for distance > 1 copies to do overlapped load and store copy
   - Explicit branch predictions (based on measured branch probabilities)
   - Deferring match copy and interspersed it with decoding subsequent codes
   - Swapping literal/length else
   - Swapping window/direct else
   - Larger unrolled copy loops (three is about right)
   - Moving len -= 3 statement into middle of loop
 */

#endif /* !ASMINF */

```

`zlib1/zlib1Code/inffast.h`:

```h
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-2003, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));

```

`zlib1/zlib1Code/inffixed.h`:

```h
    /* inffixed.h -- table for decoding fixed codes
     * Generated automatically by makefixed().
     */

    /* WARNING: this file should *not* be used by applications.
       It is part of the implementation of this library and is
       subject to change. Applications should only use zlib.h.
     */

    static const code lenfix[512] = {
        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
        {0,9,255}
    };

    static const code distfix[32] = {
        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
        {22,5,193},{64,5,0}
    };

```

`zlib1/zlib1Code/inflate.cpp`:

```cpp
/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state->bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common wnext == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifdef MAKEFIXED
#  ifndef BUILDFIXED
#    define BUILDFIXED
#  endif
#endif

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));
local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
                           unsigned copy));
#ifdef BUILDFIXED
   void makefixed OF((void));
#endif
local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                              unsigned len));

int ZEXPORT inflateResetKeep( 
	z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    if (state->wrap)        /* to support ill-conceived Java test suite */
        strm->adler = state->wrap & 1;
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
    state->head = Z_NULL;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    state->sane = 1;
    state->back = -1;
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}

int ZEXPORT inflateReset( 
z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->wsize = 0;
    state->whave = 0;
    state->wnext = 0;
    return inflateResetKeep(strm);
}

int ZEXPORT inflateReset2( 
	z_streamp strm,
int windowBits)
{
    int wrap;
    struct inflate_state FAR *state;

    /* get the state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    }
    else {
        wrap = (windowBits >> 4) + 1;
#ifdef GUNZIP
        if (windowBits < 48)
            windowBits &= 15;
#endif
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15))
        return Z_STREAM_ERROR;
    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
        ZFREE(strm, state->window);
        state->window = Z_NULL;
    }

    /* update state and reset the rest of it */
    state->wrap = wrap;
    state->wbits = (unsigned)windowBits;
    return inflateReset(strm);
}

int ZEXPORT inflateInit2_( 
	z_streamp strm,
	int windowBits,
	const char *version,
int stream_size)
{
    int ret;
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->window = Z_NULL;
    ret = inflateReset2(strm, windowBits);
    if (ret != Z_OK) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
    }
    return ret;
}

int ZEXPORT inflateInit_( 
	z_streamp strm,
	const char *version,
int stream_size)
{
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

int ZEXPORT inflatePrime( 
	z_streamp strm,
	int bits,
int value)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (bits < 0) {
        state->hold = 0;
        state->bits = 0;
        return Z_OK;
    }
    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
    value &= (1L << bits) - 1;
    state->hold += value << state->bits;
    state->bits += bits;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables( 
struct inflate_state FAR *state)
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

#ifdef MAKEFIXED
#include <stdio.h>

/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out > inffixed.h
 */
void makefixed()
{
    unsigned low, size;
    struct inflate_state state;

    fixedtables(&state);
    puts("    /* inffixed.h -- table for decoding fixed codes");
    puts("     * Generated automatically by makefixed().");
    puts("     */");
    puts("");
    puts("    /* WARNING: this file should *not* be used by applications.");
    puts("       It is part of the implementation of this library and is");
    puts("       subject to change. Applications should only use zlib.h.");
    puts("     */");
    puts("");
    size = 1U << 9;
    printf("    static const code lenfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 7) == 0) printf("\n        ");
        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
               state.lencode[low].bits, state.lencode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
    size = 1U << 5;
    printf("\n    static const code distfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 6) == 0) printf("\n        ");
        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
               state.distcode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
}
#endif /* MAKEFIXED */

/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */
local int updatewindow( 
	z_streamp strm,
	const Bytef *end,
unsigned copy)
{
    struct inflate_state FAR *state;
    unsigned dist;

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
        state->wnext = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state->wsize) {
        zmemcpy(state->window, end - state->wsize, state->wsize);
        state->wnext = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->wnext;
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->wnext, end - copy, dist);
        copy -= dist;
        if (copy) {
            zmemcpy(state->window, end - copy, copy);
            state->wnext = copy;
            state->whave = state->wsize;
        }
        else {
            state->wnext += dist;
            if (state->wnext == state->wsize) state->wnext = 0;
            if (state->whave < state->wsize) state->whave += dist;
        }
    }
    return 0;
}

/* Macros for inflate(): */

/* check function to use adler32() for zlib or crc32() for gzip */
#ifdef GUNZIP
#  define UPDATE(check, buf, len) \
    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
#else
#  define UPDATE(check, buf, len) adler32(check, buf, len)
#endif

/* check macros for header crc */
#ifdef GUNZIP
#  define CRC2(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)

#  define CRC4(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        hbuf[2] = (unsigned char)((word) >> 16); \
        hbuf[3] = (unsigned char)((word) >> 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)
#endif

/* Load registers with state in inflate() for speed */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Restore state from registers in inflate() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */
#define PULLBYTE() \
    do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want < need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm->avail_in or strm->avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm->next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */

int ZEXPORT inflate( 
	z_streamp strm,
int flush)
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned in, out;           /* save starting available input and output */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
#ifdef GUNZIP
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
            if (state->wbits == 0)
                state->wbits = len;
            else if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = TIME;
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
            state->mode = OS;
        case OS:
            NEEDBITS(16);
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
                    next += copy;
                    state->length -= copy;
                }
                if (state->length) goto inf_leave;
            }
            state->length = 0;
            state->mode = NAME;
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
            state->mode = COMMENT;
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = ZSWAP32(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = TYPE;
        case TYPE:
            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
        case TYPEDO:
            if (state->last) {
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN_;             /* decode codes */
                if (flush == Z_TREES) {
                    DROPBITS(2);
                    goto inf_leave;
                }
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
            state->mode = COPY_;
            if (flush == Z_TREES) goto inf_leave;
        case COPY_:
            state->mode = COPY;
        case COPY:
            copy = state->length;
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
                break;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (const code FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN_;
            if (flush == Z_TREES) goto inf_leave;
        case LEN_:
            state->mode = LEN;
        case LEN:
            if (have >= 6 && left >= 258) {
                RESTORE();
                inflate_fast(strm, out);
                LOAD();
                if (state->mode == TYPE)
                    state->back = -1;
                break;
            }
            state->back = 0;
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            state->length = (unsigned)here.val;
            if ((int)(here.op) == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                state->mode = LIT;
                break;
            }
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->back = -1;
                state->mode = TYPE;
                break;
            }
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(here.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->was = state->length;
            state->mode = DIST;
        case DIST:
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;
            state->extra = (unsigned)(here.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
#ifdef INFLATE_STRICT
            if (state->offset > state->dmax) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->whave) {
                    if (state->sane) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    Trace((stderr, "inflate.c too far\n"));
                    copy -= state->whave;
                    if (copy > state->length) copy = state->length;
                    if (copy > left) copy = left;
                    left -= copy;
                    state->length -= copy;
                    do {
                        *put++ = 0;
                    } while (--copy);
                    if (state->length == 0) state->mode = LEN;
                    break;
#endif
                }
                if (copy > state->wnext) {
                    copy -= state->wnext;
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->wnext - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
            left--;
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     ZSWAP32(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
        case LENGTH:
            if (state->wrap && state->flags) {
                NEEDBITS(32);
                if (hold != (state->total & 0xffffffffUL)) {
                    strm->msg = (char *)"incorrect length check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
        }

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
            (state->mode < CHECK || flush != Z_FINISH)))
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0) +
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}

int ZEXPORT inflateEnd( 
	z_streamp strm)
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) ZFREE(strm, state->window);
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

int ZEXPORT inflateGetDictionary( 
	z_streamp strm,
	Bytef *dictionary,
uInt *dictLength)
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* copy dictionary */
    if (state->whave && dictionary != Z_NULL) {
        zmemcpy(dictionary, state->window + state->wnext,
                state->whave - state->wnext);
        zmemcpy(dictionary + state->whave - state->wnext,
                state->window, state->wnext);
    }
    if (dictLength != Z_NULL)
        *dictLength = state->whave;
    return Z_OK;
}

int ZEXPORT inflateSetDictionary( 
	z_streamp strm,
	const Bytef *dictionary,
uInt dictLength)
{
    struct inflate_state FAR *state;
    unsigned long dictid;
    int ret;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->wrap != 0 && state->mode != DICT)
        return Z_STREAM_ERROR;

    /* check for correct dictionary identifier */
    if (state->mode == DICT) {
        dictid = adler32(0L, Z_NULL, 0);
        dictid = adler32(dictid, dictionary, dictLength);
        if (dictid != state->check)
            return Z_DATA_ERROR;
    }

    /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary + dictLength, dictLength);
    if (ret) {
        state->mode = MEM;
        return Z_MEM_ERROR;
    }
    state->havedict = 1;
    Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK;
}

int ZEXPORT inflateGetHeader( 
	z_streamp strm,
gz_headerp head)
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

    /* save header structure */
    state->head = head;
    head->done = 0;
    return Z_OK;
}

/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */
local unsigned syncsearch( 
	unsigned FAR *have,
	const unsigned char FAR *buf,
unsigned len)
{
    unsigned got;
    unsigned next;

    got = *have;
    next = 0;
    while (next < len && got < 4) {
        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
            got++;
        else if (buf[next])
            got = 0;
        else
            got = 4 - got;
        next++;
    }
    *have = got;
    return next;
}

int ZEXPORT inflateSync( 
z_streamp strm)
{
    unsigned len;               /* number of bytes to look at or looked at */
    unsigned long in, out;      /* temporary to save total_in and total_out */
    unsigned char buf[4];       /* to restore bit buffer to byte string */
    struct inflate_state FAR *state;

    /* check parameters */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

    /* if first time, start search in bit buffer */
    if (state->mode != SYNC) {
        state->mode = SYNC;
        state->hold <<= state->bits & 7;
        state->bits -= state->bits & 7;
        len = 0;
        while (state->bits >= 8) {
            buf[len++] = (unsigned char)(state->hold);
            state->hold >>= 8;
            state->bits -= 8;
        }
        state->have = 0;
        syncsearch(&(state->have), buf, len);
    }

    /* search available input */
    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
    strm->avail_in -= len;
    strm->next_in += len;
    strm->total_in += len;

    /* return no joy or set up to restart inflate() on a new block */
    if (state->have != 4) return Z_DATA_ERROR;
    in = strm->total_in;  out = strm->total_out;
    inflateReset(strm);
    strm->total_in = in;  strm->total_out = out;
    state->mode = TYPE;
    return Z_OK;
}

/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint( 
z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    return state->mode == STORED && state->bits == 0;
}

int ZEXPORT inflateCopy( 
	z_streamp dest,
z_streamp source)
{
    struct inflate_state FAR *state;
    struct inflate_state FAR *copy;
    unsigned char FAR *window;
    unsigned wsize;

    /* check input */
    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)source->state;

    /* allocate space */
    copy = (struct inflate_state FAR *)
           ZALLOC(source, 1, sizeof(struct inflate_state));
    if (copy == Z_NULL) return Z_MEM_ERROR;
    window = Z_NULL;
    if (state->window != Z_NULL) {
        window = (unsigned char FAR *)
                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
        if (window == Z_NULL) {
            ZFREE(source, copy);
            return Z_MEM_ERROR;
        }
    }

    /* copy state */
    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
    if (state->lencode >= state->codes &&
        state->lencode <= state->codes + ENOUGH - 1) {
        copy->lencode = copy->codes + (state->lencode - state->codes);
        copy->distcode = copy->codes + (state->distcode - state->codes);
    }
    copy->next = copy->codes + (state->next - state->codes);
    if (window != Z_NULL) {
        wsize = 1U << state->wbits;
        zmemcpy(window, state->window, wsize);
    }
    copy->window = window;
    dest->state = (struct internal_state FAR *)copy;
    return Z_OK;
}

int ZEXPORT inflateUndermine( 
	z_streamp strm,
int subvert)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->sane = !subvert;
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    return Z_OK;
#else
    state->sane = 1;
    return Z_DATA_ERROR;
#endif
}

long ZEXPORT inflateMark( 
z_streamp strm)
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
    state = (struct inflate_state FAR *)strm->state;
    return ((long)(state->back) << 16) +
        (state->mode == COPY ? state->length :
            (state->mode == MATCH ? state->was - state->length : 0));
}

```

`zlib1/zlib1Code/inflate.h`:

```h
/* inflate.h -- internal inflate state definition
 * Copyright (C) 1995-2009 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip decoding
   should be left enabled. */
#ifndef NO_GZIP
#  define GUNZIP
#endif

/* Possible inflate modes between inflate() calls */
typedef enum {
    HEAD,       /* i: waiting for magic header */
    FLAGS,      /* i: waiting for method and flags (gzip) */
    TIME,       /* i: waiting for modification time (gzip) */
    OS,         /* i: waiting for extra flags and operating system (gzip) */
    EXLEN,      /* i: waiting for extra length (gzip) */
    EXTRA,      /* i: waiting for extra bytes (gzip) */
    NAME,       /* i: waiting for end of file name (gzip) */
    COMMENT,    /* i: waiting for end of comment (gzip) */
    HCRC,       /* i: waiting for header crc (gzip) */
    DICTID,     /* i: waiting for dictionary check value */
    DICT,       /* waiting for inflateSetDictionary() call */
        TYPE,       /* i: waiting for type bits, including last-flag bit */
        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
        STORED,     /* i: waiting for stored size (length and complement) */
        COPY_,      /* i/o: same as COPY below, but only first time in */
        COPY,       /* i/o: waiting for input or output to copy stored block */
        TABLE,      /* i: waiting for dynamic block table lengths */
        LENLENS,    /* i: waiting for code length code lengths */
        CODELENS,   /* i: waiting for length/lit and distance code lengths */
            LEN_,       /* i: same as LEN below, but only first time in */
            LEN,        /* i: waiting for length/lit/eob code */
            LENEXT,     /* i: waiting for length extra bits */
            DIST,       /* i: waiting for distance code */
            DISTEXT,    /* i: waiting for distance extra bits */
            MATCH,      /* o: waiting for output space to copy string */
            LIT,        /* o: waiting for output space to write literal */
    CHECK,      /* i: waiting for 32-bit check value */
    LENGTH,     /* i: waiting for 32-bit length (gzip) */
    DONE,       /* finished check, done -- remain here until reset */
    BAD,        /* got a data error -- remain here until reset */
    MEM,        /* got an inflate() memory error -- remain here until reset */
    SYNC        /* looking for synchronization bytes to restart inflate() */
} inflate_mode;

/*
    State transitions between above modes -

    (most modes can go to BAD or MEM on error -- not shown for clarity)

    Process header:
        HEAD -> (gzip) or (zlib) or (raw)
        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
                  HCRC -> TYPE
        (zlib) -> DICTID or TYPE
        DICTID -> DICT -> TYPE
        (raw) -> TYPEDO
    Read deflate blocks:
            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
            STORED -> COPY_ -> COPY -> TYPE
            TABLE -> LENLENS -> CODELENS -> LEN_
            LEN_ -> LEN
    Read deflate codes in fixed or dynamic block:
                LEN -> LENEXT or LIT or TYPE
                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
                LIT -> LEN
    Process trailer:
        CHECK -> LENGTH -> DONE
 */

/* state maintained between inflate() calls.  Approximately 10K bytes. */
struct inflate_state {
    inflate_mode mode;          /* current inflate mode */
    int last;                   /* true if processing last block */
    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
    int havedict;               /* true if dictionary provided */
    int flags;                  /* gzip header method and flags (0 if zlib) */
    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
    unsigned long check;        /* protected copy of check value */
    unsigned long total;        /* protected copy of output count */
    gz_headerp head;            /* where to save gzip header information */
        /* sliding window */
    unsigned wbits;             /* log base 2 of requested window size */
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if needed */
        /* bit accumulator */
    unsigned long hold;         /* input bit accumulator */
    unsigned bits;              /* number of bits in "in" */
        /* for string and stored block copying */
    unsigned length;            /* literal or length of data to copy */
    unsigned offset;            /* distance back to copy string from */
        /* for table and code decoding */
    unsigned extra;             /* extra bits needed */
        /* fixed and dynamic code tables */
    code const FAR *lencode;    /* starting table for length/literal codes */
    code const FAR *distcode;   /* starting table for distance codes */
    unsigned lenbits;           /* index bits for lencode */
    unsigned distbits;          /* index bits for distcode */
        /* dynamic table building */
    unsigned ncode;             /* number of code length code lengths */
    unsigned nlen;              /* number of length code lengths */
    unsigned ndist;             /* number of distance code lengths */
    unsigned have;              /* number of code lengths in lens[] */
    code FAR *next;             /* next available space in codes[] */
    unsigned short lens[320];   /* temporary storage for code lengths */
    unsigned short work[288];   /* work area for code table building */
    code codes[ENOUGH];         /* space for code tables */
    int sane;                   /* if false, allow invalid distance too far */
    int back;                   /* bits back of last unprocessed length/lit */
    unsigned was;               /* initial length of match */
};

```

`zlib1/zlib1Code/inftrees.cpp`:

```cpp
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"

#define MAXBITS 15

const char inflate_copyright[] =
   " inflate 1.2.8 Copyright 1995-2013 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/*
   Build a set of tables to decode the provided canonical Huffman code.
   The code lengths are lens[0..codes-1].  The result starts at *table,
   whose indices are 0..2^bits-1.  work is a writable array of at least
   lens shorts, which is used as a work area.  type is the type of code
   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int ZLIB_INTERNAL inflate_table( 
	codetype type,
	unsigned short FAR *lens,
	unsigned codes,
	code FAR * FAR *table,
	unsigned FAR *bits,
	unsigned short FAR *work)
{
    unsigned len;               /* a code's length in bits */
    unsigned sym;               /* index of code symbols */
    unsigned min, max;          /* minimum and maximum code lengths */
    unsigned root;              /* number of index bits for root table */
    unsigned curr;              /* number of index bits for current table */
    unsigned drop;              /* code bits to drop for sub-table */
    int left;                   /* number of prefix codes available */
    unsigned used;              /* code entries in table used */
    unsigned huff;              /* Huffman code */
    unsigned incr;              /* for incrementing code, index */
    unsigned fill;              /* index for replicating entries */
    unsigned low;               /* low bits for current root entry */
    unsigned mask;              /* mask for low root bits */
    code here;                  /* table entry for duplication */
    code FAR *next;             /* next available space in table */
    const unsigned short FAR *base;     /* base value table to use */
    const unsigned short FAR *extra;    /* extra bits table to use */
    int end;                    /* use base and extra for symbol > end */
    unsigned short count[MAXBITS+1];    /* number of codes of each length */
    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0};
    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64};

    /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.

       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.

       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
        if (count[max] != 0) break;
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        here.op = (unsigned char)64;    /* invalid code marker */
        here.bits = (unsigned char)1;
        here.val = (unsigned short)0;
        *(*table)++ = here;             /* make a table to force an error */
        *(*table)++ = here;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++)
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

    /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
    }

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type == LENS && used > ENOUGH_LENS) ||
        (type == DISTS && used > ENOUGH_DISTS))
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        here.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
            here.op = (unsigned char)0;
            here.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            here.op = (unsigned char)(extra[work[sym]]);
            here.val = base[work[sym]];
        }
        else {
            here.op = (unsigned char)(32 + 64);         /* end of block */
            here.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = here;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
        }
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
            if (len == max) break;
            len = lens[work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if ((type == LENS && used > ENOUGH_LENS) ||
                (type == DISTS && used > ENOUGH_DISTS))
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
            (*table)[low].bits = (unsigned char)root;
            (*table)[low].val = (unsigned short)(next - *table);
        }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
    if (huff != 0) {
        here.op = (unsigned char)64;            /* invalid code marker */
        here.bits = (unsigned char)(len - drop);
        here.val = (unsigned short)0;
        next[huff] = here;
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}

```

`zlib1/zlib1Code/inftrees.h`:

```h
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-2005, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Structure for decoding tables.  Each entry provides either the
   information needed to do the operation requested by the code that
   indexed that table entry, or it provides a pointer to another
   table that indexes more bits of the code.  op indicates whether
   the entry is a pointer to another table, a literal, a length or
   distance, an end-of-block, or an invalid code.  For a table
   pointer, the low four bits of op is the number of index bits of
   that table.  For a length or distance, the low four bits of op
   is the number of extra bits to get after the code.  bits is
   the number of bits in this code or part of the code to drop off
   of the bit buffer.  val is the actual byte to output in the case
   of a literal, the base length or distance, or the offset from
   the current table to the next table.  Each entry is four bytes. */
typedef struct {
    unsigned char op;           /* operation, extra bits, table bits */
    unsigned char bits;         /* bits in this part of the code */
    unsigned short val;         /* offset in table or code value */
} code;

/* op values as set by inflate_table():
    00000000 - literal
    0000tttt - table link, tttt != 0 is the number of table index bits
    0001eeee - length or distance, eeee is the number of extra bits
    01100000 - end of block
    01000000 - invalid code
 */

/* Maximum size of the dynamic table.  The maximum number of code structures is
   1444, which is the sum of 852 for literal/length codes and 592 for distance
   codes.  These values were found by exhaustive searches using the program
   examples/enough.c found in the zlib distribtution.  The arguments to that
   program are the number of symbols, the initial root table size, and the
   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
   The initial root table size (9 or 6) is found in the fifth argument of the
   inflate_table() calls in inflate.c and infback.c.  If the root table size is
   changed, then these maximum sizes would be need to be recalculated and
   updated. */
#define ENOUGH_LENS 852
#define ENOUGH_DISTS 592
#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)

/* Type of code to build for inflate_table() */
typedef enum {
    CODES,
    LENS,
    DISTS
} codetype;

int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
                             unsigned codes, code FAR * FAR *table,
                             unsigned FAR *bits, unsigned short FAR *work));

```

`zlib1/zlib1Code/trees.cpp`:

```cpp
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * detect_data_type() function provided freely by Cosmin Truta, 2006
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, const ct_data *ltree,
                              const ct_data *dtree));
local int  detect_data_type OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (ush)value << s->bi_valid;
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= (ush)value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (ush)val << s->bi_valid;\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (ush)(value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
#endif

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
            "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
        fprintf(header, "%2u%s", _dist_code[i],
                SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header,
        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
        fprintf(header, "%2u%s", _length_code[i],
                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
        fprintf(header, "%1u%s", base_length[i],
                SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "%5u%s", base_dist[i],
                SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void ZLIB_INTERNAL _tr_init( 
    deflate_state *s)
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block( 
    deflate_state *s)
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap( 
	deflate_state *s,
	ct_data *tree,  /* the tree to restore */
    int k)             /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen( 
	deflate_state *s,
    tree_desc *desc)    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if ((unsigned) tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes ( 
	ct_data *tree,             /* the tree to decorate */
	int max_code,              /* largest code with non zero frequency */
    ushf *bl_count)            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree( 
    deflate_state *s,
    tree_desc *desc) /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
                                s->depth[n] : s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree ( 
	deflate_state *s,
	ct_data *tree,   /* the tree to be scanned */
    int max_code)    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree ( 
	deflate_state *s,
	ct_data *tree, /* the tree to be scanned */
    int max_code)       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree( 
    deflate_state *s)
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees( 
	deflate_state *s,
    int lcodes, 
	int dcodes, 
	int blcodes) /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void ZLIB_INTERNAL _tr_stored_block( 
	deflate_state *s,
	charf *buf,       /* input block */
	ulg stored_len,   /* length of input block */
    int last)         /* one if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
 */
void ZLIB_INTERNAL _tr_flush_bits( 
    deflate_state *s)
{
    bi_flush(s);
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
void ZLIB_INTERNAL _tr_align( 
    deflate_state *s)
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void ZLIB_INTERNAL _tr_flush_block( 
	deflate_state *s,
	charf *buf,       /* input block, or NULL if too old */
	ulg stored_len,   /* length of input block */
    int last)         /* one if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

        /* Check if the file is binary or text */
        if (s->strm->data_type == Z_UNKNOWN)
            s->strm->data_type = detect_data_type(s);

        /* Construct the literal and distance trees */
        build_tree(s, (tree_desc *)(&(s->l_desc)));
        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));

        build_tree(s, (tree_desc *)(&(s->d_desc)));
        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s->opt_len+3+7)>>3;
        static_lenb = (s->static_len+3+7)>>3;

        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                s->last_lit));

        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+last, 3);
        compress_block(s, (const ct_data *)static_ltree,
                       (const ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+last, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (const ct_data *)s->dyn_ltree,
                       (const ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (last) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int ZLIB_INTERNAL _tr_tally ( 
	deflate_state *s,
	unsigned dist,  /* distance of matched string */
    unsigned lc)    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block( 
	deflate_state *s,
	const ct_data *ltree, /* literal tree */
    const ct_data *dtree) /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
               "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
local int detect_data_type( 
    deflate_state *s)
{
    /* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    unsigned long black_mask = 0xf3ffc07fUL;
    int n;

    /* Check for non-textual ("black-listed") bytes. */
    for (n = 0; n <= 31; n++, black_mask >>= 1)
        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
            return Z_BINARY;

    /* Check for textual ("white-listed") bytes. */
    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
            || s->dyn_ltree[13].Freq != 0)
        return Z_TEXT;
    for (n = 32; n < LITERALS; n++)
        if (s->dyn_ltree[n].Freq != 0)
            return Z_TEXT;

    /* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
    return Z_BINARY;
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse( 
	unsigned code, /* the value to invert */
    int len)       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(
    deflate_state *s)
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup( 
    deflate_state *s)
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block( 
	deflate_state *s,
	charf    *buf,    /* the input data */
	unsigned len,     /* its length */
    int      header)  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */

    if (header) {
        put_short(s, (ush)len);
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}

```

`zlib1/zlib1Code/trees.h`:

```h
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};


```

`zlib1/zlib1Code/uncompr.cpp`:

```cpp
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-2003, 2010 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress ( 
	Bytef *dest,
	uLongf *destLen,
	const Bytef *source,
    uLong sourceLen)
{
    z_stream stream;
    int err;

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
            return Z_DATA_ERROR;
        return err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}

```

`zlib1/zlib1Code/zconf.h`:

```h
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2013 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#ifndef ZCONF_H
#define ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 * Even better than compiling with -DZ_PREFIX would be to use configure to set
 * this permanently in zconf.h using "./configure --zprefix".
 */
#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
#  define Z_PREFIX_SET

/* all linked symbols */
#  define _dist_code            z__dist_code
#  define _length_code          z__length_code
#  define _tr_align             z__tr_align
#  define _tr_flush_bits        z__tr_flush_bits
#  define _tr_flush_block       z__tr_flush_block
#  define _tr_init              z__tr_init
#  define _tr_stored_block      z__tr_stored_block
#  define _tr_tally             z__tr_tally
#  define adler32               z_adler32
#  define adler32_combine       z_adler32_combine
#  define adler32_combine64     z_adler32_combine64
#  ifndef Z_SOLO
#    define compress              z_compress
#    define compress2             z_compress2
#    define compressBound         z_compressBound
#  endif
#  define crc32                 z_crc32
#  define crc32_combine         z_crc32_combine
#  define crc32_combine64       z_crc32_combine64
#  define deflate               z_deflate
#  define deflateBound          z_deflateBound
#  define deflateCopy           z_deflateCopy
#  define deflateEnd            z_deflateEnd
#  define deflateInit2_         z_deflateInit2_
#  define deflateInit_          z_deflateInit_
#  define deflateParams         z_deflateParams
#  define deflatePending        z_deflatePending
#  define deflatePrime          z_deflatePrime
#  define deflateReset          z_deflateReset
#  define deflateResetKeep      z_deflateResetKeep
#  define deflateSetDictionary  z_deflateSetDictionary
#  define deflateSetHeader      z_deflateSetHeader
#  define deflateTune           z_deflateTune
#  define deflate_copyright     z_deflate_copyright
#  define get_crc_table         z_get_crc_table
#  ifndef Z_SOLO
#    define gz_error              z_gz_error
#    define gz_intmax             z_gz_intmax
#    define gz_strwinerror        z_gz_strwinerror
#    define gzbuffer              z_gzbuffer
#    define gzclearerr            z_gzclearerr
#    define gzclose               z_gzclose
#    define gzclose_r             z_gzclose_r
#    define gzclose_w             z_gzclose_w
#    define gzdirect              z_gzdirect
#    define gzdopen               z_gzdopen
#    define gzeof                 z_gzeof
#    define gzerror               z_gzerror
#    define gzflush               z_gzflush
#    define gzgetc                z_gzgetc
#    define gzgetc_               z_gzgetc_
#    define gzgets                z_gzgets
#    define gzoffset              z_gzoffset
#    define gzoffset64            z_gzoffset64
#    define gzopen                z_gzopen
#    define gzopen64              z_gzopen64
#    ifdef _WIN32
#      define gzopen_w              z_gzopen_w
#    endif
#    define gzprintf              z_gzprintf
#    define gzvprintf             z_gzvprintf
#    define gzputc                z_gzputc
#    define gzputs                z_gzputs
#    define gzread                z_gzread
#    define gzrewind              z_gzrewind
#    define gzseek                z_gzseek
#    define gzseek64              z_gzseek64
#    define gzsetparams           z_gzsetparams
#    define gztell                z_gztell
#    define gztell64              z_gztell64
#    define gzungetc              z_gzungetc
#    define gzwrite               z_gzwrite
#  endif
#  define inflate               z_inflate
#  define inflateBack           z_inflateBack
#  define inflateBackEnd        z_inflateBackEnd
#  define inflateBackInit_      z_inflateBackInit_
#  define inflateCopy           z_inflateCopy
#  define inflateEnd            z_inflateEnd
#  define inflateGetHeader      z_inflateGetHeader
#  define inflateInit2_         z_inflateInit2_
#  define inflateInit_          z_inflateInit_
#  define inflateMark           z_inflateMark
#  define inflatePrime          z_inflatePrime
#  define inflateReset          z_inflateReset
#  define inflateReset2         z_inflateReset2
#  define inflateSetDictionary  z_inflateSetDictionary
#  define inflateGetDictionary  z_inflateGetDictionary
#  define inflateSync           z_inflateSync
#  define inflateSyncPoint      z_inflateSyncPoint
#  define inflateUndermine      z_inflateUndermine
#  define inflateResetKeep      z_inflateResetKeep
#  define inflate_copyright     z_inflate_copyright
#  define inflate_fast          z_inflate_fast
#  define inflate_table         z_inflate_table
#  ifndef Z_SOLO
#    define uncompress            z_uncompress
#  endif
#  define zError                z_zError
#  ifndef Z_SOLO
#    define zcalloc               z_zcalloc
#    define zcfree                z_zcfree
#  endif
#  define zlibCompileFlags      z_zlibCompileFlags
#  define zlibVersion           z_zlibVersion

/* all zlib typedefs in zlib.h and zconf.h */
#  define Byte                  z_Byte
#  define Bytef                 z_Bytef
#  define alloc_func            z_alloc_func
#  define charf                 z_charf
#  define free_func             z_free_func
#  ifndef Z_SOLO
#    define gzFile                z_gzFile
#  endif
#  define gz_header             z_gz_header
#  define gz_headerp            z_gz_headerp
#  define in_func               z_in_func
#  define intf                  z_intf
#  define out_func              z_out_func
#  define uInt                  z_uInt
#  define uIntf                 z_uIntf
#  define uLong                 z_uLong
#  define uLongf                z_uLongf
#  define voidp                 z_voidp
#  define voidpc                z_voidpc
#  define voidpf                z_voidpf

/* all zlib structs in zlib.h and zconf.h */
#  define gz_header_s           z_gz_header_s
#  define internal_state        z_internal_state

#endif

#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif
#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
#  define OS2
#endif
#if defined(_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
#    ifndef SYS16BIT
#      define SYS16BIT
#    endif
#  endif
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#ifdef SYS16BIT
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#ifdef __STDC_VERSION__
#  ifndef STDC
#    define STDC
#  endif
#  if __STDC_VERSION__ >= 199901L
#    ifndef STDC99
#      define STDC99
#    endif
#  endif
#endif
#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
#  define STDC
#endif
#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
#  define STDC
#endif
#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
#  define STDC
#endif
#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
#  define STDC
#endif

#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const       /* note: need a more gentle solution here */
#  endif
#endif

#if defined(ZLIB_CONST) && !defined(z_const)
#  define z_const const
#else
#  define z_const
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

#ifndef Z_ARG /* function prototypes for stdarg */
#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
#    define Z_ARG(args)  args
#  else
#    define Z_ARG(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#ifdef SYS16BIT
#  if defined(M_I86SM) || defined(M_I86MM)
     /* MSC small or medium model */
#    define SMALL_MEDIUM
#    ifdef _MSC_VER
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#  if (defined(__SMALL__) || defined(__MEDIUM__))
     /* Turbo C small or medium model */
#    define SMALL_MEDIUM
#    ifdef __BORLANDC__
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#endif

#if defined(WINDOWS) || defined(WIN32)
   /* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    */
#  ifdef ZLIB_DLL
#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
#      ifdef ZLIB_INTERNAL
#        define ZEXTERN extern __declspec(dllexport)
#      else
#        define ZEXTERN extern __declspec(dllimport)
#      endif
#    endif
#  endif  /* ZLIB_DLL */
   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    */
#  ifdef ZLIB_WINAPI
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
     /* No need for _export, use ZLIB.DEF instead. */
     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
#    define ZEXPORT WINAPI
#    ifdef WIN32
#      define ZEXPORTVA WINAPIV
#    else
#      define ZEXPORTVA FAR CDECL
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  ifdef ZLIB_DLL
#    ifdef ZLIB_INTERNAL
#      define ZEXPORT   __declspec(dllexport)
#      define ZEXPORTVA __declspec(dllexport)
#    else
#      define ZEXPORT   __declspec(dllimport)
#      define ZEXPORTVA __declspec(dllimport)
#    endif
#  endif
#endif

#ifndef ZEXTERN
#  define ZEXTERN extern
#endif
#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif

#ifndef FAR
#  define FAR
#endif

#if !defined(__MACTYPES__)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void const *voidpc;
   typedef void FAR   *voidpf;
   typedef void       *voidp;
#else
   typedef Byte const *voidpc;
   typedef Byte FAR   *voidpf;
   typedef Byte       *voidp;
#endif

#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
#  include <limits.h>
#  if (UINT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned
#  elif (ULONG_MAX == 0xffffffffUL)
#    define Z_U4 unsigned long
#  elif (USHRT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned short
#  endif
#endif

#ifdef Z_U4
   typedef Z_U4 z_crc_t;
#else
   typedef unsigned long z_crc_t;
#endif

#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_UNISTD_H
#endif

#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_STDARG_H
#endif

#ifdef STDC
#  ifndef Z_SOLO
#    include <sys/types.h>      /* for off_t */
#  endif
#endif

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
#    include <stdarg.h>         /* for va_list */
#  endif
#endif

#ifdef _WIN32
#  ifndef Z_SOLO
#    include <stddef.h>         /* for wchar_t */
#  endif
#endif

/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
 * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
 * though the former does not conform to the LFS document), but considering
 * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
 * equivalently requesting no 64-bit operations
 */
#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
#  undef _LARGEFILE64_SOURCE
#endif

#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
#  define Z_HAVE_UNISTD_H
#endif
#ifndef Z_SOLO
#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
#    ifdef VMS
#      include <unixio.h>       /* for off_t */
#    endif
#    ifndef z_off_t
#      define z_off_t off_t
#    endif
#  endif
#endif

#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
#  define Z_LFS64
#endif

#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
#  define Z_LARGE64
#endif

#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
#  define Z_WANT64
#endif

#if !defined(SEEK_SET) && !defined(Z_SOLO)
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif

#ifndef z_off_t
#  define z_off_t long
#endif

#if !defined(_WIN32) && defined(Z_LARGE64)
#  define z_off64_t off64_t
#else
#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
#    define z_off64_t __int64
#  else
#    define z_off64_t z_off_t
#  endif
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
  #pragma map(deflateInit_,"DEIN")
  #pragma map(deflateInit2_,"DEIN2")
  #pragma map(deflateEnd,"DEEND")
  #pragma map(deflateBound,"DEBND")
  #pragma map(inflateInit_,"ININ")
  #pragma map(inflateInit2_,"ININ2")
  #pragma map(inflateEnd,"INEND")
  #pragma map(inflateSync,"INSY")
  #pragma map(inflateSetDictionary,"INSEDI")
  #pragma map(compressBound,"CMBND")
  #pragma map(inflate_table,"INTABL")
  #pragma map(inflate_fast,"INFA")
  #pragma map(inflate_copyright,"INCOPY")
#endif

#endif /* ZCONF_H */

```

`zlib1/zlib1Code/zlib.def`:

```def
;
; Slightly modified version of ../nt/zlib.dnt :-)
;

LIBRARY zlib1
;DESCRIPTION	"Zlib compression library for OS/2"
;CODE		PRELOAD MOVEABLE DISCARDABLE
;DATA		PRELOAD MOVEABLE MULTIPLE

EXPORTS
    adler32
    compress
    crc32
    deflate
    deflateCopy
    deflateEnd
    deflateInit2_
    deflateInit_
    deflateParams
    deflateReset
    deflateSetDictionary
    gzclose
    gzdopen
    gzerror
    gzflush
    gzopen
    gzread
    gzwrite
    inflate
    inflateEnd
    inflateInit2_
    inflateInit_
    inflateReset
    inflateSetDictionary
    inflateSync
    uncompress
    zlibVersion
    gzprintf
    gzputc
    gzgetc
    gzseek
    gzrewind
    gztell
    gzeof
    gzsetparams
    zError
    inflateSyncPoint
    get_crc_table
    compress2
    gzputs
    gzgets

```

`zlib1/zlib1Code/zlib.h`:

```h
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.8, April 28th, 2013

  Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
*/

#ifndef ZLIB_H
#define ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.2.8"
#define ZLIB_VERNUM 0x1280
#define ZLIB_VER_MAJOR 1
#define ZLIB_VER_MINOR 2
#define ZLIB_VER_REVISION 8
#define ZLIB_VER_SUBREVISION 0

/*
    The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed data.
  This version of the library supports only one compression method (deflation)
  but other algorithms will be added later and will have the same stream
  interface.

    Compression can be done in a single step if the buffers are large enough,
  or can be done by repeated calls of the compression function.  In the latter
  case, the application must provide more input and/or consume the output
  (providing more output space) before each call.

    The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

    The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

    This library can optionally read and write gzip streams in memory as well.

    The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

    The library does not install any signal handler.  The decoder checks
  the consistency of the compressed data, so the library should never crash
  even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    z_const Bytef *next_in;     /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total number of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total number of bytes output so far */

    z_const char *msg;  /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: binary or text */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*/
typedef struct gz_header_s {
    int     text;       /* true if compressed data believed to be text */
    uLong   time;       /* modification time */
    int     xflags;     /* extra flags (not used when writing a gzip file) */
    int     os;         /* operating system */
    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    uInt    extra_max;  /* space at extra (only when reading header) */
    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    uInt    name_max;   /* space at name (only when reading header) */
    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    uInt    comm_max;   /* space at comment (only when reading header) */
    int     hcrc;       /* true if there was or will be a header crc */
    int     done;       /* true when done reading gzip header (not used
                           when writing a gzip file) */
} gz_header;

typedef gz_header FAR *gz_headerp;

/*
     The application must update next_in and avail_in when avail_in has dropped
   to zero.  It must update next_out and avail_out when avail_out has dropped
   to zero.  The application must initialize zalloc, zfree and opaque before
   calling the init function.  All other fields are set by the compression
   library and must not be updated by the application.

     The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree.  This can be useful for custom
   memory management.  The compression library attaches no meaning to the
   opaque value.

     zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

     On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this if
   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   returned by zalloc for objects of exactly 65536 bytes *must* have their
   offset normalized to zero.  The default allocation function provided by this
   library ensures this (see zutil.c).  To reduce memory requirements and avoid
   any allocation of 64K objects, at the expense of compression ratio, compile
   the library with -DMAX_WBITS=14 (see zconf.h).

     The fields total_in and total_out can be used for statistics or progress
   reports.  After compression, total_in holds the total size of the
   uncompressed data and may be saved for use in the decompressor (particularly
   if the decompressor wants to decompress everything in a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6
/* Allowed flush values; see deflate() and inflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_RLE                 3
#define Z_FIXED               4
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_TEXT     1
#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN  2
/* Possible values of the data_type field (though see inflate()) */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */


                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is not
   compatible with the zlib.h header file used by the application.  This check
   is automatically made by deflateInit and inflateInit.
 */

/*
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression.  The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at all
   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   requests a default compromise between speed and compression (currently
   equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if level is not a valid compression level, or
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   if there is no error message.  deflateInit does not perform any compression:
   this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows.  deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).  Some
    output may be provided even if flush is not set.

    Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating avail_in or avail_out accordingly; avail_out should
  never be zero before the call.  The application can consume the compressed
  output when it wants, for example when the output buffer is full (avail_out
  == 0), or after each call of deflate().  If deflate returns Z_OK and with
  zero avail_out, it must be called again after making room in the output
  buffer because there might be more output pending.

    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
  decide how much data to accumulate before producing output, in order to
  maximize compression.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far.  (In
  particular avail_in is zero after the call if enough output space has been
  provided before the call.) Flushing may degrade compression for some
  compression algorithms and so it should be used only when necessary.  This
  completes the current deflate block and follows it with an empty stored block
  that is three bits plus filler bits to the next byte, followed by four bytes
  (00 00 ff ff).

    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
  output buffer, but the output is not aligned to a byte boundary.  All of the
  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
  This completes the current deflate block and follows it with an empty fixed
  codes block that is 10 bits long.  This assures that enough bytes are output
  in order for the decompressor to finish the block before the empty fixed code
  block.

    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
  seven bits of the current block are held to be written as the next byte after
  the next deflate block is completed.  In this case, the decompressor may not
  be provided enough bits at this point in order to complete decompression of
  the data provided so far to the compressor.  It may need to wait for the next
  block to be emitted.  This is for advanced applications that need to control
  the emission of deflate blocks.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
  compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six to avoid repeated flush markers due to
  avail_out == 0 on return.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there was
  enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error.  After
  deflate has returned Z_STREAM_END, the only possible operations on the stream
  are deflateReset or deflateEnd.

    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step.  In this case, avail_out must be at least the
  value returned by deflateBound (see below).  Then deflate is guaranteed to
  return Z_STREAM_END.  If not enough output space is provided, deflate will
  not return Z_STREAM_END, and it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update strm->data_type if it can make a good guess about
  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
  binary.  This field is only for information purposes and does not affect the
  compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
  fatal, and deflate() can be called again with more input and more output
  space to continue compressing.
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded).  In the error case, msg
   may be set but then points to a static string (which must not be
   deallocated).
*/


/*
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression.  The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
   exact value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit() does not process any header information -- that is deferred
   until inflate() is called.
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows.  inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing will
    resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there is
    no more input data or no more space in the output buffer (see below about
    the flush parameter).

    Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating the next_* and avail_* values accordingly.  The
  application can consume the uncompressed output when it wants, for example
  when the output buffer is full (avail_out == 0), or after each call of
  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
  called again after making room in the output buffer because there might be
  more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer.  Z_BLOCK requests that inflate()
  stop if and when it gets to the next deflate block boundary.  When decoding
  the zlib or gzip format, this will cause inflate() to return immediately
  after the header and before the first block.  When doing a raw inflate,
  inflate() will go ahead and process the first block, and will return when it
  gets to the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  Also to assist in this, on return inflate() will set strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64 if
  inflate() is currently decoding the last block in the deflate stream, plus
  128 if inflate() returned immediately after decoding an end-of-block code or
  decoding the complete header up to just before the first byte of the deflate
  stream.  The end-of-block will not be indicated until all of the uncompressed
  data from that block has been written to strm->next_out.  The number of
  unused bits may in general be greater than seven, except when bit 7 of
  data_type is set, in which case the number of unused bits will be less than
  eight.  data_type is set as noted here every time inflate() returns for all
  flush options, and so can be used to determine the amount of currently
  consumed input in bits.

    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
  end of each deflate block header is reached, before any actual data in that
  block is decoded.  This allows the caller to determine the length of the
  deflate block header for later use in random access within a deflate block.
  256 is added to the value of strm->data_type when inflate() returns
  immediately after reaching the end of the deflate block header.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error.  However if all decompression is to be performed in a single step (a
  single call of inflate), the parameter flush should be set to Z_FINISH.  In
  this case all pending input is processed and all pending output is flushed;
  avail_out must be large enough to hold all of the uncompressed data for the
  operation to complete.  (The size of the uncompressed data may have been
  saved by the compressor for this purpose.) The use of Z_FINISH is not
  required to perform an inflation in one step.  However it may be used to
  inform inflate that a faster approach can be used for the single inflate()
  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
  stream completes, which reduces inflate's memory footprint.  If the stream
  does not complete, either because not all of the stream is provided or not
  enough output space is provided, then a sliding window will be allocated and
  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
  been used.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call.  So the effects of the flush parameter in this implementation are
  on the return value of inflate() as noted below, when inflate() returns early
  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
  memory for a sliding window when Z_FINISH is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the Adler-32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below.  At the end of the stream, inflate() checks that its computed adler32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically, if requested when
  initializing with inflateInit2().  Any information contained in the gzip
  header is not retained, so applications that need that information should
  instead use raw inflate, see inflateInit2() below, or inflateBack() and
  perform their own processing of the gzip header and trailer.  When processing
  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
  producted so far.  The CRC-32 is checked against the gzip trailer.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing.  If Z_DATA_ERROR is returned, the application may
  then call inflateSync() to look for a good compression block if a partial
  recovery of the data is desired.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent.  In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/


                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options.  The
   fields next_in, zalloc, zfree and opaque must be initialized before by the
   caller.

     The method parameter is the compression method.  It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library.  Larger values of this parameter result in better
   compression at the expense of memory usage.  The default value is 15 if
   deflateInit is used instead.

     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   determines the window size.  deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute an adler32 check value.

     windowBits can also be greater than 15 for optional gzip encoding.  Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper.  The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero), no
   header crc, and the operating system will be set to 255 (unknown).  If a
   gzip stream is being written, strm->adler is a crc32 instead of an adler32.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state.  memLevel=1 uses minimum memory but is
   slow and reduces compression ratio; memLevel=9 uses maximum memory for
   optimal speed.  The default value is 8.  See zconf.h for total memory usage
   as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm.  Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding).  Filtered data consists mostly of small values with a somewhat
   random distribution.  In this case, the compression algorithm is tuned to
   compress them better.  The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   strategy parameter only affects the compression ratio but not the
   correctness of the compressed output even if it is not set appropriately.
   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   decoder for special applications.

     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   set to null if there is no error message.  deflateInit2 does not perform any
   compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output.  When using the zlib format, this
   function must be called immediately after deflateInit, deflateInit2 or
   deflateReset, and before any call of deflate.  When doing raw deflate, this
   function must be called either before any call of deflate, or immediately
   after the completion of a deflate block, i.e. after all input has been
   consumed and all output has been delivered when using any of the flush
   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   compressor and decompressor must use exactly the same dictionary (see
   inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary.  Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size
   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   useful should be put at the end of the dictionary, not at the front.  In
   addition, the current implementation of deflate will use at most the window
   size minus 262 bytes of the provided dictionary.

     Upon return of this function, strm->adler is set to the adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor.  (The adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   adler32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if not at a block boundary for raw deflate).  deflateSetDictionary does
   not perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter.  The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and can
   consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.  The
   stream will keep the same compression level and any other attributes that
   may have been set by deflateInit2.

     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                      int level,
                                      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different strategy.
   If the compression level is changed, the input available so far is
   compressed with the old level (and may be flushed); the new level will take
   effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to be
   compressed and flushed.  In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
   strm->avail_out was zero.
*/

ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
                                    int good_length,
                                    int max_lazy,
                                    int nice_length,
                                    int max_chain));
/*
     Fine tune deflate's internal compression parameters.  This should only be
   used by someone who understands the algorithm used by zlib's deflate for
   searching for the best matching string, and even then only by the most
   fanatic optimizer trying to squeeze out the last compressed bit for their
   specific input data.  Read the deflate.c source code for the meaning of the
   max_lazy, good_length, nice_length, and max_chain parameters.

     deflateTune() can be called after deflateInit() or deflateInit2(), and
   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */

ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                       uLong sourceLen));
/*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit() or
   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   to allocate an output buffer for deflation in a single pass, and so would be
   called before deflate().  If that first deflate() call is provided the
   sourceLen input bytes, an output buffer allocated to the size returned by
   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   to return Z_STREAM_END.  Note that it is possible for the compressed size to
   be larger than the value returned by deflateBound() if flush options other
   than Z_FINISH or Z_NO_FLUSH are used.
*/

ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
                                       unsigned *pending,
                                       int *bits));
/*
     deflatePending() returns the number of bytes and bits of output that have
   been generated, but not yet provided in the available output.  The bytes not
   provided would be due to the available output space having being consumed.
   The number of bits of output not provided are between 0 and 7, where they
   await more bits to join them in order to fill out a full byte.  If pending
   or bits are Z_NULL, then those values are not set.

     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
 */

ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     deflatePrime() inserts bits in the deflate output stream.  The intent
   is that this function is used to start off the deflate output with the bits
   leftover from a previous deflate stream when appending to it.  As such, this
   function can only be used for raw deflate, and must be used before the first
   deflate() call after a deflateInit2() or deflateReset().  bits must be less
   than or equal to 16, and that many of the least significant bits of value
   will be inserted in the output.

     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     deflateSetHeader() provides gzip header information for when a gzip
   stream is requested by deflateInit2().  deflateSetHeader() may be called
   after deflateInit2() or deflateReset() and before the first call of
   deflate().  The text, time, os, extra field, name, and comment information
   in the provided gz_header structure are written to the gzip header (xflag is
   ignored -- the extra flags are set according to the compression level).  The
   caller must assure that, if not Z_NULL, name and comment are terminated with
   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   available there.  If hcrc is true, a gzip header crc is included.  Note that
   the current versions of the command-line version of gzip (up through version
   1.3.x) do not support header crc's, and will report that it is a "multi-part
   gzip file" and give up.

     If deflateSetHeader is not used, the default gzip header has text false,
   the time set to zero, and os set to 255, with no extra, name, or comment
   fields.  The gzip header is returned to the default state by deflateReset().

     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter.  The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library.  The default value is 15 if inflateInit is used
   instead.  windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used.  If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be zero to request that inflate use the window size in
   the zlib header of the compressed stream.

     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   determines the window size.  inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream.  This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values.  If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an adler32 or a crc32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is.  Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding.  Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   crc32 instead of an adler32.

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit2 does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit2() does not process any header information -- that is
   deferred until inflate() is called.
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence.  This function must be called immediately after a call of inflate,
   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   can be determined from the adler32 value returned by that call of inflate.
   The compressor and decompressor must use exactly the same dictionary (see
   deflateSetDictionary).  For raw inflate, this function can be called at any
   time to set the dictionary.  If the provided dictionary is smaller than the
   window and there is already data in the window, then the provided dictionary
   will amend what's there.  The application must insure that the dictionary
   that was used for compression is provided.

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect adler32 value).  inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by inflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If inflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/*
     Skips invalid compressed data until a possible full flush point (see above
   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   available input is skipped.  No output is provided.

     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   All full flush points have this pattern, but not all occurrences of this
   pattern are full flush points.

     inflateSync returns Z_OK if a possible full flush point has been found,
   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   In the success case, the application may save the current current value of
   total_in which indicates where valid compressed data was found.  In the
   error case, the application may repeatedly call inflateSync, providing more
   input each time, until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.  The
   stream will keep attributes that may have been set by inflateInit2.

     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
                                      int windowBits));
/*
     This function is the same as inflateReset, but it also permits changing
   the wrap and window size requests.  The windowBits parameter is interpreted
   the same as it is for inflateInit2.

     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   the windowBits parameter is invalid.
*/

ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     This function inserts bits in the inflate input stream.  The intent is
   that this function is used to start inflating at a bit position in the
   middle of a byte.  The provided bits will be used before any bytes are used
   from next_in.  This function should only be used with raw inflate, and
   should be used before the first inflate() call after inflateInit2() or
   inflateReset().  bits must be less than or equal to 16, and that many of the
   least significant bits of value will be inserted in the input.

     If bits is negative, then the input stream bit buffer is emptied.  Then
   inflatePrime() can be called again to put bits in the buffer.  This is used
   to clear out bits leftover after feeding inflate a block description prior
   to feeding inflate codes.

     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
/*
     This function returns two values, one in the lower 16 bits of the return
   value, and the other in the remaining upper bits, obtained by shifting the
   return value down 16 bits.  If the upper value is -1 and the lower value is
   zero, then inflate() is currently decoding information outside of a block.
   If the upper value is -1 and the lower value is non-zero, then inflate is in
   the middle of a stored block, with the lower value equaling the number of
   bytes from the input remaining to copy.  If the upper value is not -1, then
   it is the number of bits back from the current bit position in the input of
   the code (literal or length/distance pair) currently being processed.  In
   that case the lower value is the number of bytes already emitted for that
   code.

     A code is being processed if inflate is waiting for more input to complete
   decoding of the code, or if it has completed decoding but is waiting for
   more output space to write the literal or match data.

     inflateMark() is used to mark locations in the input data for random
   access, which may be at bit positions, and to note those cases where the
   output of a code may span boundaries of random access blocks.  The current
   location in the input stream can be determined from avail_in and data_type
   as noted in the description for the Z_BLOCK flush parameter for inflate.

     inflateMark returns the value noted above or -1 << 16 if the provided
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     inflateGetHeader() requests that gzip header information be stored in the
   provided gz_header structure.  inflateGetHeader() may be called after
   inflateInit2() or inflateReset(), and before the first call of inflate().
   As inflate() processes the gzip stream, head->done is zero until the header
   is completed, at which time head->done is set to one.  If a zlib stream is
   being decoded, then head->done is set to -1 to indicate that there will be
   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   used to force inflate() to return immediately after header processing is
   complete and before any actual data is decompressed.

     The text, time, xflags, and os fields are filled in with the gzip header
   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   contains the maximum number of bytes to write to extra.  Once done is true,
   extra_len contains the actual extra field length, and extra contains the
   extra field, or that field truncated if extra_max is less than extra_len.
   If name is not Z_NULL, then up to name_max characters are written there,
   terminated with a zero unless the length is greater than name_max.  If
   comment is not Z_NULL, then up to comm_max characters are written there,
   terminated with a zero unless the length is greater than comm_max.  When any
   of extra, name, or comment are not Z_NULL and the respective field is not
   present in the header, then that field is set to Z_NULL to signal its
   absence.  This allows the use of deflateSetHeader() with the returned
   structure to duplicate the header.  However if those fields are set to
   allocated memory, then the application will need to save those pointers
   elsewhere so that they can be eventually freed.

     If inflateGetHeader is not used, then the header information is simply
   discarded.  The header is always checked for validity, including the header
   CRC if present.  inflateReset() will reset the process to discard the header
   information.  The application would need to call inflateGetHeader() again to
   retrieve the header from the next gzip stream.

     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                        unsigned char FAR *window));

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   allocated, or Z_VERSION_ERROR if the version of the library does not match
   the version of the header file.
*/

typedef unsigned (*in_func) OF((void FAR *,
                                z_const unsigned char FAR * FAR *));
typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                    in_func in, void FAR *in_desc,
                                    out_func out, void FAR *out_desc));
/*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is potentially more efficient than
   inflate() for file i/o applications, in that it avoids copying between the
   output and the sliding window by simply making the window itself the output
   buffer.  inflate() can be faster on modern CPUs when used with large
   buffers.  inflateBack() trusts the application to not change the output
   buffer passed by the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free the
   allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects only
   the raw deflate stream to decompress.  This is different from the normal
   behavior of inflate(), which expects either a zlib or gzip header and
   trailer around the deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero--buf is ignored in that
   case--and inflateBack() will return a buffer error.  inflateBack() will call
   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
   should return zero on success, or non-zero on failure.  If out() returns
   non-zero, inflateBack() will return with an error.  Neither in() nor out()
   are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   in the deflate stream (in which case strm->msg is set to indicate the nature
   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   In the case of Z_BUF_ERROR, an input or output error can be distinguished
   using strm->next_in which will be Z_NULL only if in() returned an error.  If
   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   non-zero.  (in() will always be called before out(), so strm->next_in is
   assured to be defined if out() returns non-zero.) Note that inflateBack()
   cannot return Z_OK.
*/

ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
/*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*/

ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
/* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 */

#ifndef Z_SOLO

                        /* utility functions */

/*
     The following utility functions are implemented on top of the basic
   stream-oriented functions.  To simplify the interface, some default options
   are assumed (compression level and memory usage, standard memory allocation
   functions).  The source code of these utility functions can be modified if
   you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed buffer.

     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer.  The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer.  Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
/*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before a
   compress() or compress2() call to allocate the destination buffer.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data.  (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit, destLen
   is the actual size of the uncompressed buffer.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
   the case where there is not enough room, uncompress() will fill the output
   buffer with the uncompressed data up to that point.
*/

                        /* gzip file access functions */

/*
     This library supports reading and writing files in gzip (.gz) format with
   an interface similar to that of stdio, using the functions that start with
   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
   wrapper, documented in RFC 1952, wrapped around a deflate stream.
*/

typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */

/*
ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));

     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
   for fixed code compression as in "wb9F".  (See the description of
   deflateInit2 for more information about the strategy parameter.)  'T' will
   request transparent writing or appending with no compression and not using
   the gzip format.

     "a" can be used instead of "w" to request that the gzip stream that will
   be written be appended to the file.  "+" will result in an error, since
   reading and writing to the same gzip file is not supported.  The addition of
   "x" when writing will create the file exclusively, which fails if the file
   already exists.  On systems that support it, the addition of "e" when
   reading or writing will set the flag to close the file on an execve() call.

     These functions, as well as gzip, will read and decode a sequence of gzip
   streams in a file.  The append function of gzopen() can be used to create
   such a file.  (Also see gzflush() for another way to do this.)  When
   appending, gzopen does not test whether the file begins with a gzip stream,
   nor does it look for the end of the gzip streams to begin appending.  gzopen
   will simply append a gzip stream to the existing file.

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.  When
   reading, this will be detected automatically by looking for the magic two-
   byte gzip header.

     gzopen returns NULL if the file could not be opened, if there was
   insufficient memory to allocate the gzFile state, or if an invalid mode was
   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
   errno can be checked to determine if the reason gzopen failed was that the
   file could not be opened.
*/

ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
/*
     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
   are obtained from calls like open, dup, creat, pipe or fileno (if the file
   has been previously opened with fopen).  The mode parameter is as in gzopen.

     The next call of gzclose on the returned gzFile will also close the file
   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
   mode);.  The duplicated descriptor should be saved to avoid a leak, since
   gzdopen does not close fd if it fails.  If you are using fileno() to get the
   file descriptor from a FILE *, then you will have to use dup() to avoid
   double-close()ing the file descriptor.  Both gzclose() and fclose() will
   close the associated file descriptor, so they need to have different file
   descriptors.

     gzdopen returns NULL if there was insufficient memory to allocate the
   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
   used until the next gz* read, write, seek, or close operation, so gzdopen
   will not detect if fd is invalid (unless fd is -1).
*/

ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
/*
     Set the internal buffer size used by this library's functions.  The
   default buffer size is 8192 bytes.  This function must be called after
   gzopen() or gzdopen(), and before any other calls that read or write the
   file.  The buffer memory allocation is always deferred to the first read or
   write.  Two buffers are allocated, either both of the specified size when
   writing, or one of the specified size and the other twice that size when
   reading.  A larger buffer size of, for example, 64K or 128K bytes will
   noticeably increase the speed of decompression (reading).

     The new buffer size also affects the maximum length for gzprintf().

     gzbuffer() returns 0 on success, or -1 on failure, such as being called
   too late.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy.  See the description
   of deflateInit2 for the meaning of these parameters.

     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.  If
   the input file is not in gzip format, gzread copies the given number of
   bytes into the buffer directly from the file.

     After reaching the end of a gzip stream in the input, gzread will continue
   to read, looking for another gzip stream.  Any number of gzip streams may be
   concatenated in the input file, and will all be decompressed by gzread().
   If something other than a gzip stream is encountered after a gzip stream,
   that remaining trailing garbage is ignored (and no error is returned).

     gzread can be used to read a gzip file that is being concurrently written.
   Upon reaching the end of the input, gzread will return with the available
   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
   gzclearerr can be used to clear the end of file indicator in order to permit
   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
   middle of a gzip stream.  Note that gzread does not return -1 in the event
   of an incomplete gzip stream.  This error is deferred until gzclose(), which
   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
   stream.  Alternatively, gzerror can be used before gzclose to detect this
   case.

     gzread returns the number of uncompressed bytes actually read, less than
   len for end of file, or -1 for error.
*/

ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
                                voidpc buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes written or 0 in case of
   error.
*/

ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the arguments to the compressed file under
   control of the format string, as in fprintf.  gzprintf returns the number of
   uncompressed bytes actually written, or 0 in case of error.  The number of
   uncompressed bytes written is limited to 8191, or one less than the buffer
   size given to gzbuffer().  The caller should assure that this limit is not
   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
   nothing written.  In this case, there may also be a buffer overflow with
   unpredictable consequences, which is possible only if zlib was compiled with
   the insecure functions sprintf() or vsprintf() because the secure snprintf()
   or vsnprintf() functions were not available.  This can be determined using
   zlibCompileFlags().
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
     Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.

     gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
     Reads bytes from the compressed file until len-1 characters are read, or a
   newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  If any characters are read or if len == 1, the
   string is terminated with a null character.  If no characters are read due
   to an end-of-file or len < 1, then the buffer is left untouched.

     gzgets returns buf which is a null-terminated string, or it returns NULL
   for end-of-file or in case of error.  If there was an error, the contents at
   buf are indeterminate.
*/

ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
/*
     Writes c, converted to an unsigned char, into the compressed file.  gzputc
   returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
/*
     Reads one byte from the compressed file.  gzgetc returns this byte or -1
   in case of end of file or error.  This is implemented as a macro for speed.
   As such, it does not do all of the checking the other functions do.  I.e.
   it does not check to see if file is NULL, nor whether the structure file
   points to has been clobbered or not.
*/

ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
/*
     Push one character back onto the stream to be read as the first character
   on the next read.  At least one character of push-back is allowed.
   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
   fail if c is -1, and may fail if a character has been pushed but not read
   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
   The pushed character will be discarded if the stream is repositioned with
   gzseek() or gzrewind().
*/

ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file.  The parameter flush
   is as in the deflate() function.  The return value is the zlib error number
   (see function gzerror below).  gzflush is only permitted when writing.

     If the flush parameter is Z_FINISH, the remaining data is written and the
   gzip stream is completed in the output.  If gzwrite() is called again, a new
   gzip stream will be started in the output.  gzread() is able to read such
   concatented gzip streams.

     gzflush should be called only when strictly necessary because it will
   degrade compression if called too often.
*/

/*
ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
                                   z_off_t offset, int whence));

     Sets the starting position for the next gzread or gzwrite on the given
   compressed file.  The offset represents a number of bytes in the
   uncompressed data stream.  The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.

     If the file is opened for reading, this function is emulated but can be
   extremely slow.  If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

     gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

/*
ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));

     Returns the starting position for the next gzread or gzwrite on the given
   compressed file.  This position represents a number of bytes in the
   uncompressed data stream, and is zero when starting, even if appending or
   reading a gzip stream from the middle of a file using gzdopen().

     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

/*
ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));

     Returns the current offset in the file being read or written.  This offset
   includes the count of bytes that precede the gzip stream, for example when
   appending or when using gzdopen() for reading.  When reading, the offset
   does not include as yet unused buffered input.  This information can be used
   for a progress indicator.  On error, gzoffset() returns -1.
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns true (1) if the end-of-file indicator has been set while reading,
   false (0) otherwise.  Note that the end-of-file indicator is set only if the
   read tried to go past the end of the input, but came up short.  Therefore,
   just like feof(), gzeof() may return false even if there is no more data to
   read, in the event that the last read request was for the exact number of
   bytes remaining in the input file.  This will happen if the input file size
   is an exact multiple of the buffer size.

     If gzeof() returns true, then the read functions will return no more data,
   unless the end-of-file indicator is reset by gzclearerr() and the input file
   has grown since the previous end of file was detected.
*/

ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
/*
     Returns true (1) if file is being copied directly while reading, or false
   (0) if file is a gzip stream being decompressed.

     If the input file is empty, gzdirect() will return true, since the input
   does not contain a gzip stream.

     If gzdirect() is used immediately after gzopen() or gzdopen() it will
   cause buffers to be allocated to allow reading the file to determine if it
   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
   gzdirect().

     When writing, gzdirect() returns true (1) if transparent writing was
   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
   gzdirect() is not needed when writing.  Transparent writing must be
   explicitly requested, so the application already knows the answer.  When
   linking statically, using gzdirect() will include all of the zlib code for
   gzip file reading and decompression, which may not be desired.)
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file and
   deallocates the (de)compression state.  Note that once file is closed, you
   cannot call gzerror with file, since its structures have been deallocated.
   gzclose must not be called more than once on the same file, just as free
   must not be called more than once on the same allocation.

     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
   last read ended in the middle of a gzip stream, or Z_OK on success.
*/

ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
/*
     Same as gzclose(), but gzclose_r() is only for use when reading, and
   gzclose_w() is only for use when writing or appending.  The advantage to
   using these instead of gzclose() is that they avoid linking in zlib
   compression or decompression code that is not used when only reading or only
   writing respectively.  If gzclose() is used, then both compression and
   decompression code will be included the application when linking to a static
   zlib library.
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the given
   compressed file.  errnum is set to zlib error number.  If an error occurred
   in the file system and not in the compression library, errnum is set to
   Z_ERRNO and the application may consult errno to get the exact error code.

     The application must not modify the returned string.  Future calls to
   this function may invalidate the previously returned string.  If file is
   closed, then the string previously returned by gzerror will no longer be
   available.

     gzerror() should be used to distinguish errors from end-of-file for those
   functions above that do not distinguish those cases in their return values.
*/

ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
/*
     Clears the error and end-of-file flags for file.  This is analogous to the
   clearerr() function in stdio.  This is useful for continuing to read a gzip
   file that is being written concurrently.
*/

#endif /* !Z_SOLO */

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the compression
   library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum.  If buf is Z_NULL, this function returns the
   required initial value for the checksum.

     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster.

   Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

/*
ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
                                          z_off_t len2));

     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
   that the z_off_t type (like off_t) is a signed integer.  If len2 is
   negative, the result has no meaning or utility.
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32.  If buf is Z_NULL, this function returns the required
   initial value for the crc.  Pre- and post-conditioning (one's complement) is
   performed within this function so it shouldn't be done by the application.

   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/

/*
ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));

     Combine two CRC-32 check values into one.  For two sequences of bytes,
   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
   len2.
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window,
                                         const char *version,
                                         int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                      (int)sizeof(z_stream))
#define inflateBackInit(strm, windowBits, window) \
        inflateBackInit_((strm), (windowBits), (window), \
                      ZLIB_VERSION, (int)sizeof(z_stream))

#ifndef Z_SOLO

/* gzgetc() macro and its supporting function and exposed data structure.  Note
 * that the real internal state is much larger than the exposed structure.
 * This abbreviated structure exposes just enough for the gzgetc() macro.  The
 * user should not mess with these exposed elements, since their names or
 * behavior could change in the future, perhaps even capriciously.  They can
 * only be used by the gzgetc() macro.  You have been warned.
 */
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    z_off64_t pos;
};
ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#  define z_gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
#else
#  define gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
#endif

/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
 * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
 * both are true, the application gets the *64 functions, and the regular
 * functions are changed to 64 bits) -- in case these are set on systems
 * without large file support, _LFS64_LARGEFILE must also be true
 */
#ifdef Z_LARGE64
   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
#endif

#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
#  ifdef Z_PREFIX_SET
#    define z_gzopen z_gzopen64
#    define z_gzseek z_gzseek64
#    define z_gztell z_gztell64
#    define z_gzoffset z_gzoffset64
#    define z_adler32_combine z_adler32_combine64
#    define z_crc32_combine z_crc32_combine64
#  else
#    define gzopen gzopen64
#    define gzseek gzseek64
#    define gztell gztell64
#    define gzoffset gzoffset64
#    define adler32_combine adler32_combine64
#    define crc32_combine crc32_combine64
#  endif
#  ifndef Z_LARGE64
     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#  endif
#else
   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
#endif

#else /* Z_SOLO */

   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));

#endif /* !Z_SOLO */

/* hack for buggy compilers */
#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;};
#endif

/* undocumented functions */
ZEXTERN const char   * ZEXPORT zError           OF((int));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
#if defined(_WIN32) && !defined(Z_SOLO)
ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
                                            const char *mode));
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
                                                  const char *format,
                                                  va_list va));
#  endif
#endif

#ifdef __cplusplus
}
#endif

#endif /* ZLIB_H */

```

`zlib1/zlib1Code/zutil.cpp`:

```cpp
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"
#ifndef Z_SOLO
#  include "gzguts.h"
#endif

#ifndef NO_DUMMY_DECL
struct internal_state      {int dummy;}; /* for buggy compilers */
#endif

z_const char * const z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

uLong ZEXPORT zlibCompileFlags()
{
    uLong flags;

    flags = 0;
    switch ((int)(sizeof(uInt))) {
    case 2:     break;
    case 4:     flags += 1;     break;
    case 8:     flags += 2;     break;
    default:    flags += 3;
    }
    switch ((int)(sizeof(uLong))) {
    case 2:     break;
    case 4:     flags += 1 << 2;        break;
    case 8:     flags += 2 << 2;        break;
    default:    flags += 3 << 2;
    }
    switch ((int)(sizeof(voidpf))) {
    case 2:     break;
    case 4:     flags += 1 << 4;        break;
    case 8:     flags += 2 << 4;        break;
    default:    flags += 3 << 4;
    }
    switch ((int)(sizeof(z_off_t))) {
    case 2:     break;
    case 4:     flags += 1 << 6;        break;
    case 8:     flags += 2 << 6;        break;
    default:    flags += 3 << 6;
    }
#ifdef DEBUG
    flags += 1 << 8;
#endif
#if defined(ASMV) || defined(ASMINF)
    flags += 1 << 9;
#endif
#ifdef ZLIB_WINAPI
    flags += 1 << 10;
#endif
#ifdef BUILDFIXED
    flags += 1 << 12;
#endif
#ifdef DYNAMIC_CRC_TABLE
    flags += 1 << 13;
#endif
#ifdef NO_GZCOMPRESS
    flags += 1L << 16;
#endif
#ifdef NO_GZIP
    flags += 1L << 17;
#endif
#ifdef PKZIP_BUG_WORKAROUND
    flags += 1L << 20;
#endif
#ifdef FASTEST
    flags += 1L << 21;
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifdef NO_vsnprintf
    flags += 1L << 25;
#    ifdef HAS_vsprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_vsnprintf_void
    flags += 1L << 26;
#    endif
#  endif
#else
    flags += 1L << 24;
#  ifdef NO_snprintf
    flags += 1L << 25;
#    ifdef HAS_sprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_snprintf_void
    flags += 1L << 26;
#    endif
#  endif
#endif
    return flags;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int ZLIB_INTERNAL z_verbose = verbose;

void ZLIB_INTERNAL z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError( 
    int err)
{
    return ERR_MSG(err);
}

#if defined(_WIN32_WCE)
    /* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */
    int errno = 0;
#endif

#ifndef HAVE_MEMCPY

void ZLIB_INTERNAL zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int ZLIB_INTERNAL zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void ZLIB_INTERNAL zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifndef Z_SOLO

#ifdef SYS16BIT

#ifdef __TURBOC__
/* Turbo C in 16-bit mode */

#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}

#endif /* __TURBOC__ */


#ifdef M_I86
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* M_I86 */

#endif /* SYS16BIT */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf ZLIB_INTERNAL zcalloc ( 
	voidpf opaque,
	unsigned items,
    unsigned size)
{
    if (opaque) items += size - size; /* make compiler happy */
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                              (voidpf)calloc(items, size);
}

void ZLIB_INTERNAL zcfree ( 
    voidpf opaque,
    voidpf ptr)
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */

#endif /* !Z_SOLO */

```

`zlib1/zlib1Code/zutil.h`:

```h
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2013 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef ZUTIL_H
#define ZUTIL_H

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include "zlib.h"

#if defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#endif

#ifdef Z_SOLO
   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
         /* Allow compilation with ANSI keywords only enabled */
         void _Cdecl farfree( void *block );
         void *_Cdecl farmalloc( unsigned long nbytes );
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
#    endif
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef OS2
#  define OS_CODE  0x06
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
#    endif
#  endif
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#ifdef WIN32
#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
#    define OS_CODE  0x0b
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0f
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
       typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

#if defined(__BORLANDC__) && !defined(MSDOS)
  #pragma warn -8004
  #pragma warn -8008
  #pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

        /* common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#if defined(pyr) || defined(Z_SOLO)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int ZLIB_INTERNAL z_verbose;
   extern void ZLIB_INTERNAL z_error OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

#ifndef Z_SOLO
   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
                                    unsigned size));
   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

#endif /* ZUTIL_H */

```