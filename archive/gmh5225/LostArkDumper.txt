Project Path: arc_gmh5225_LostArkDumper_k2s56twa

Source Tree:

```txt
arc_gmh5225_LostArkDumper_k2s56twa
├── LICENSE
├── LoaDumper
│   ├── Blowfish.cs
│   ├── ExtractLPK.cs
│   ├── LoaDumper.csproj
│   ├── ObjectSerialize.cs
│   ├── PacketDumper.cs
│   ├── Program.cs
│   ├── Region.cs
│   ├── Seed.cs
│   └── SigScan.cs
├── LoaDumper.sln
└── README.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 shalzuth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LoaDumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33205.214
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LoaDumper", "LoaDumper\LoaDumper.csproj", "{3AE57349-EB92-4115-AD17-65A99B2498FC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3AE57349-EB92-4115-AD17-65A99B2498FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3AE57349-EB92-4115-AD17-65A99B2498FC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3AE57349-EB92-4115-AD17-65A99B2498FC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3AE57349-EB92-4115-AD17-65A99B2498FC}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {77C63F10-E316-4E0B-8CB4-FD56BFF0DCC9}
	EndGlobalSection
EndGlobal

```

`LoaDumper/Blowfish.cs`:

```cs
using System.Security.Cryptography;
using System.Text;

namespace LoaDumper
{
    internal class Blowfish
    {
        private const int Rounds = 16;

        //SBLOCKS
        private uint[] _bfS0 = null!;
        private uint[] _bfS1 = null!;
        private uint[] _bfS2 = null!;
        private uint[] _bfS3 = null!;

        private uint[] _bfP = null!;

        //KEY
        private byte[] _key = null!;

        //HALF-BLOCKS
        private uint _xlPar;
        private uint _xrPar;

        //Initialization Vector for CBC and CTR mode
        private byte[] _initVector = null!;
        private bool _ivSet;

        //For compatibility with the javascript crypto library

        /// <summary>
        /// Constructor for hex key
        /// </summary>
        /// <param name="hexKey">Cipher key as a hex string</param>
        public Blowfish(string hexKey)
        {
            SetupKey(Convert.FromHexString(hexKey));
        }

        /// <summary>
        /// Constructor for byte key
        /// </summary>
        /// <param name="cipherKey">Cipher key as a byte array</param>
        public Blowfish(byte[] cipherKey)
        {
            SetupKey(cipherKey);
        }

        /// <summary>
        /// Encrypts a string in CBC mode
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext with IV appended to front</returns>
        public string Encrypt_CBC(string pt)
        {
            if (!_ivSet)
                SetRandomIV();
            return ByteToHex(_initVector) + ByteToHex(Encrypt_CBC(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string in CBC mode
        /// </summary>
        /// <param name="ct">Ciphertext with IV appended to front</param>
        /// <returns>Plaintext</returns>
        public string Decrypt_CBC(string ct)
        {
            IV = Convert.FromHexString(ct[..16]);
            return Encoding.ASCII.GetString(Decrypt_CBC(Convert.FromHexString(ct[16..]))).Replace("\0", "");
        }

        /// <summary>
        /// Decrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="ct">Ciphertext data to decrypt</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_CBC(byte[] ct)
        {
            return Crypt_CBC(ct, true);
        }

        /// <summary>
        /// Encrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext</returns>
        public byte[] Encrypt_CBC(byte[] pt)
        {
            return Crypt_CBC(pt, false);
        }

        /// <summary>
        /// Encrypt a string in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext to encrypt as ascii string</param>
        /// <returns>hex value of encrypted data</returns>
        public string Encrypt_ECB(string pt)
        {
            return ByteToHex(Encrypt_ECB(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string (ECB)
        /// </summary>
        /// <param name="ct">hHex string of the ciphertext</param>
        /// <returns>Plaintext ascii string</returns>
        public string Decrypt_ECB(string ct)
        {
            return Encoding.ASCII.GetString(Decrypt_ECB(Convert.FromHexString(ct))).Replace("\0", "");
        }

        /// <summary>
        /// Encrypts a byte array in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext data</param>
        /// <returns>Ciphertext bytes</returns>
        public byte[] Encrypt_ECB(byte[] pt)
        {
            return Crypt_ECB(pt, false);
        }

        /// <summary>
        /// Decrypts a byte array (ECB)
        /// </summary>
        /// <param name="ct">Ciphertext byte array</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_ECB(byte[] ct)
        {
            return Crypt_ECB(ct, true);
        }

        /// <summary>
        /// Encrypts a string (CTR)
        /// </summary>
        /// <param name="pt">The plaintext to encrypt</param>
        /// <returns>The ciphertext</returns>
        public string Encrypt_CTR(string pt)
        {
            if (!_ivSet)
                SetRandomIV();
            return ByteToHex(_initVector) + ByteToHex(Crypt_CTR(Encoding.ASCII.GetBytes(pt), 2));
        }

        /// <summary>
        /// Decrypt a string (CTR)
        /// </summary>
        /// <param name="ct">The ciphertext to decrypt</param>
        /// <returns>The plaintext</returns>
        public string Decrypt_CTR(string ct)
        {
            IV = Convert.FromHexString(ct[..16]);
            return Encoding.ASCII.GetString(Crypt_CTR(Convert.FromHexString(ct[16..]), 2)).Replace("\0", "");
        }

        /// <summary>
        /// Initialization vector for CBC mode.
        /// </summary>
        public byte[] IV
        {
            get => _initVector;
            set
            {
                if (value.Length == 8)
                {
                    _initVector = value;
                    _ivSet = true;
                }
                else
                {
                    throw new Exception("Invalid IV size.");
                }
            }
        }

        /// <summary>
        /// This parameters controls the 64 bits split into 2 uint32 values.
        /// The non standard way is to not reverse the order of the splitted bytes 
        /// </summary>
        public bool NonStandard { get; set; }

        /// <summary>
        /// Parameter ensuring the endianness of the cypher.
        /// Setting this parameter as true on little endian systems ensures compatibility with big endian systems
        /// </summary>
        public bool CompatMode { get; set; }

        /// <summary>
        /// Creates and sets a random initialization vector.
        /// </summary>
        /// <returns>The random IV</returns>
        public byte[] SetRandomIV()
        {
            _initVector = RandomNumberGenerator.GetBytes(8);
            _ivSet = true;
            return _initVector;
        }

        /// <summary>
        /// Sets up the S-blocks and the key
        /// </summary>
        /// <param name="cipherKey">Block cipher key (1-448 bits)</param>
        private void SetupKey(byte[] cipherKey)
        {
            _bfP = SetupP();
            //set up the S blocks
            _bfS0 = SetupS0();
            _bfS1 = SetupS1();
            _bfS2 = SetupS2();
            _bfS3 = SetupS3();

            _key = new byte[cipherKey.Length]; // 448 bits
            if (cipherKey.Length > 56)
            {
                throw new Exception("Key too long. 56 bytes required.");
            }

            Buffer.BlockCopy(cipherKey, 0, _key, 0, cipherKey.Length);
            var j = 0;
            for (var i = 0; i < 18; i++)
            {
                var d = (uint)(((_key[j % cipherKey.Length] * 256 + _key[(j + 1) % cipherKey.Length]) * 256 +
                                 _key[(j + 2) % cipherKey.Length]) * 256 + _key[(j + 3) % cipherKey.Length]);
                _bfP[i] ^= d;
                j = (j + 4) % cipherKey.Length;
            }

            _xlPar = 0;
            _xrPar = 0;
            for (var i = 0; i < 18; i += 2)
            {
                Encipher();
                _bfP[i] = _xlPar;
                _bfP[i + 1] = _xrPar;
            }

            for (var i = 0; i < 256; i += 2)
            {
                Encipher();
                _bfS0[i] = _xlPar;
                _bfS0[i + 1] = _xrPar;
            }

            for (var i = 0; i < 256; i += 2)
            {
                Encipher();
                _bfS1[i] = _xlPar;
                _bfS1[i + 1] = _xrPar;
            }

            for (var i = 0; i < 256; i += 2)
            {
                Encipher();
                _bfS2[i] = _xlPar;
                _bfS2[i + 1] = _xrPar;
            }

            for (var i = 0; i < 256; i += 2)
            {
                Encipher();
                _bfS3[i] = _xlPar;
                _bfS3[i + 1] = _xrPar;
            }
        }

        /// <summary>
        /// Encrypts or decrypts data in ECB mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_ECB(byte[] text, bool decrypt)
        {
            var paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            var plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            var block = new byte[8];
            for (var i = 0; i < plainText.Length; i += 8)
            {
                Buffer.BlockCopy(plainText, i, block, 0, 8);
                if (decrypt)
                {
                    BlockDecrypt(ref block);
                }
                else
                {
                    BlockEncrypt(ref block);
                }

                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }

            return plainText;
        }

        public byte[] Crypt_CTR(byte[] text, int numThreads)
        {
            if (!_ivSet)
            {
                throw new Exception("IV not set.");
            }

            var input = new byte[8];
            var counter = new byte[8];
            var paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            var plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            var block = new byte[8];
            for (var i = 0; i < plainText.Length; i += 8)
            {
                for (var x = 0; x < 8; x++)
                {
                    input[x] = (byte)(counter[x] ^ _initVector[x]);
                }

                Buffer.BlockCopy(plainText, i, block, 0, 8);
                BlockEncrypt(ref input);
                XorBlock(ref block, input);
                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }

            return plainText;
        }

        /// <summary>
        /// Encrypts or decrypts data in CBC mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_CBC(byte[] text, bool decrypt)
        {
            if (!_ivSet)
            {
                throw new Exception("IV not set.");
            }

            var paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            var plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            var block = new byte[8];
            var preblock = new byte[8];
            var iv = new byte[8];
            Buffer.BlockCopy(_initVector, 0, iv, 0, 8);
            if (!decrypt)
            {
                for (var i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);
                    XorBlock(ref block, iv);
                    BlockEncrypt(ref block);
                    Buffer.BlockCopy(block, 0, iv, 0, 8);
                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }
            else
            {
                for (var i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);

                    Buffer.BlockCopy(block, 0, preblock, 0, 8);
                    BlockDecrypt(ref block);
                    XorBlock(ref block, iv);
                    Buffer.BlockCopy(preblock, 0, iv, 0, 8);

                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }

            return plainText;
        }

        /// <summary>
        /// XoR encrypts two 8 bit blocks
        /// </summary>
        /// <param name="block">8 bit block 1</param>
        /// <param name="iv">8 bit block 2</param>
        private static void XorBlock(ref byte[] block, IReadOnlyList<byte> iv)
        {
            for (var i = 0; i < block.Length; i++)
            {
                block[i] ^= iv[i];
            }
        }

        /// <summary>
        /// Encrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to encrypt</param>
        private void BlockEncrypt(ref byte[] block)
        {
            SetBlock(block);
            Encipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Decrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to decrypt</param>
        private void BlockDecrypt(ref byte[] block)
        {
            SetBlock(block);
            Decipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Splits the block into the two uint values
        /// </summary>
        /// <param name="block">the 64 bit block to setup</param>
        private void SetBlock(byte[] block)
        {
            var block1 = new byte[4];
            var block2 = new byte[4];
            Buffer.BlockCopy(block, 0, block1, 0, 4);
            Buffer.BlockCopy(block, 4, block2, 0, 4);
            //split the block
            if (BitConverter.IsLittleEndian && CompatMode)
            {
                _xlPar = BitConverter.ToUInt32(block1, 0);
                _xrPar = BitConverter.ToUInt32(block2, 0);
            }
            else if (!BitConverter.IsLittleEndian && CompatMode)
            {
                Array.Reverse(block1);
                Array.Reverse(block2);
                _xlPar = BitConverter.ToUInt32(block1, 0);
                _xrPar = BitConverter.ToUInt32(block2, 0);
            }
            else if (NonStandard)
            {
                _xrPar = BitConverter.ToUInt32(block1, 0);
                _xlPar = BitConverter.ToUInt32(block2, 0);
            }
            else
            {
                //ToUInt32 requires the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
                _xlPar = BitConverter.ToUInt32(block1, 0);
                _xrPar = BitConverter.ToUInt32(block2, 0);
            }
        }

        /// <summary>
        /// Converts the two uint values into a 64 bit block
        /// </summary>
        /// <param name="block">64 bit buffer to receive the block</param>
        private void GetBlock(ref byte[] block)
        {
            var block1 = new byte[4];
            var block2 = new byte[4];
            if (BitConverter.IsLittleEndian && CompatMode)
            {
                block1 = BitConverter.GetBytes(_xlPar);
                block2 = BitConverter.GetBytes(_xrPar);
            }
            else if (!BitConverter.IsLittleEndian && CompatMode)
            {
                block1 = BitConverter.GetBytes(_xlPar);
                block2 = BitConverter.GetBytes(_xrPar);

                Array.Reverse(block1);
                Array.Reverse(block2);
            }
            else if (NonStandard)
            {
                block1 = BitConverter.GetBytes(_xrPar);
                block2 = BitConverter.GetBytes(_xlPar);
            }
            else
            {
                block1 = BitConverter.GetBytes(_xlPar);
                block2 = BitConverter.GetBytes(_xrPar);

                //GetBytes returns the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
            }

            //join the block
            Buffer.BlockCopy(block1, 0, block, 0, 4);
            Buffer.BlockCopy(block2, 0, block, 4, 4);
        }

        /// <summary>
        /// Runs the blowfish algorithm (standard 16 rounds)
        /// </summary>
        private void Encipher()
        {
            _xlPar ^= _bfP[0];
            for (uint i = 0; i < Rounds; i += 2)
            {
                _xrPar = Round(_xrPar, _xlPar, i + 1);
                _xlPar = Round(_xlPar, _xrPar, i + 2);
            }

            _xrPar ^= _bfP[17];

            //swap the blocks
            (_xlPar, _xrPar) = (_xrPar, _xlPar);
        }

        /// <summary>
        /// Runs the blowfish algorithm in reverse (standard 16 rounds)
        /// </summary>
        private void Decipher()
        {
            _xlPar ^= _bfP[17];
            for (uint i = 16; i > 0; i -= 2)
            {
                _xrPar = Round(_xrPar, _xlPar, i);
                _xlPar = Round(_xlPar, _xrPar, i - 1);
            }

            _xrPar ^= _bfP[0];

            //swap the blocks
            (_xlPar, _xrPar) = (_xrPar, _xlPar);
        }

        /// <summary>
        /// one round of the blowfish algorithm
        /// </summary>
        /// <param name="a">See spec</param>
        /// <param name="b">See spec</param>
        /// <param name="n">See spec</param>
        /// <returns></returns>
        private uint Round(uint a, uint b, uint n)
        {
            var x1 = (_bfS0[WordByte0(b)] + _bfS1[WordByte1(b)]) ^ _bfS2[WordByte2(b)];
            var x2 = x1 + _bfS3[WordByte3(b)];
            var x3 = x2 ^ _bfP[n];
            return x3 ^ a;
        }

        //SBLOCKS ARE THE HEX DIGITS OF PI. 
        //The amount of hex digits can be increased if you want to experiment with more rounds and longer key lengths

        //Increase the size of this array when increasing the number of rounds
        private static uint[] SetupP()
        {
            return new uint[]
            {
                0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0,
                0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
                0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b
            };
        }

        private static uint[] SetupS0()
        {
            return new uint[]
            {
                0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,
                0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
                0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658,
                0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
                0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,
                0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
                0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6,
                0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
                0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c,
                0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
                0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1,
                0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
                0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a,
                0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
                0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
                0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
                0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706,
                0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
                0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b,
                0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
                0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c,
                0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
                0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a,
                0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
                0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,
                0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
                0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8,
                0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
                0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33,
                0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
                0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0,
                0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
                0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777,
                0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
                0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,
                0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
                0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e,
                0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
                0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9,
                0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
                0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f,
                0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
                0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
            };
        }

        private static uint[] SetupS1()
        {
            return new uint[]
            {
                0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d,
                0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
                0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65,
                0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
                0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9,
                0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
                0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d,
                0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
                0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
                0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
                0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908,
                0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
                0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124,
                0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
                0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908,
                0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
                0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b,
                0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
                0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,
                0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
                0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d,
                0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
                0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5,
                0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
                0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96,
                0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
                0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca,
                0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
                0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,
                0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
                0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054,
                0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
                0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea,
                0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
                0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646,
                0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
                0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea,
                0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
                0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
                0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
                0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd,
                0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
                0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
            };
        }

        private static uint[] SetupS2()
        {
            return new uint[]
            {
                0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7,
                0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
                0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
                0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
                0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4,
                0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
                0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec,
                0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
                0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332,
                0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
                0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58,
                0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
                0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,
                0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
                0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60,
                0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
                0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99,
                0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
                0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74,
                0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
                0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3,
                0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
                0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,
                0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
                0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa,
                0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
                0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086,
                0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
                0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24,
                0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
                0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84,
                0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
                0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
                0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
                0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe,
                0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
                0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0,
                0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
                0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188,
                0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
                0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8,
                0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
                0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
            };
        }

        private static uint[] SetupS3()
        {
            return new uint[]
            {
                0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742,
                0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
                0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79,
                0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
                0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a,
                0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
                0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,
                0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
                0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797,
                0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
                0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6,
                0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
                0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba,
                0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
                0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5,
                0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
                0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,
                0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
                0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd,
                0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
                0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb,
                0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
                0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc,
                0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
                0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc,
                0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
                0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
                0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
                0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a,
                0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
                0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b,
                0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
                0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e,
                0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
                0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623,
                0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
                0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,
                0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
                0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3,
                0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
                0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c,
                0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
                0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
            };
        }

        //gets the first byte in a uint
        private static byte WordByte0(uint w)
        {
            return (byte)(w / 256 / 256 / 256 % 256);
        }

        //gets the second byte in a uint
        private static byte WordByte1(uint w)
        {
            return (byte)(w / 256 / 256 % 256);
        }

        //gets the third byte in a uint
        private static byte WordByte2(uint w)
        {
            return (byte)(w / 256 % 256);
        }

        //gets the fourth byte in a uint
        private static byte WordByte3(uint w)
        {
            return (byte)(w % 256);
        }

        //converts a byte array to a hex string
        private static string ByteToHex(byte[] bytes)
        {
            var s = new StringBuilder();
            foreach (var b in bytes)
                s.Append(b.ToString("x2"));
            return s.ToString();
        }
    }
}
```

`LoaDumper/ExtractLPK.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Data.SQLite;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace LoaDumper
{
    internal class ExtractLPK
    {
        static void DumpAll(SQLiteConnection connect, String k, Dictionary<String, String> d, String language = "")
        {
            using (SQLiteCommand fmd = connect.CreateCommand())
            {
                fmd.CommandType = System.Data.CommandType.Text;
                fmd.CommandText = @"SELECT * FROM GameMsg" + language + " WHERE KEY LIKE '%" + k + "%'";
                var r = fmd.ExecuteReader();
                while (r.Read())
                {
                    d.Add(Convert.ToString(r["KEY"]), Convert.ToString(r["MSG"]));
                }
            }
        }
        public static Byte[] Dump(String lpkPath, String blowfish, String aes, String fileToDump = "")
        {
            //var lpkPath = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\EFGame\config.lpk";// args[0];
            //lpkPath = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\EFGame\data.lpk";// args[0];
            //lpkPath = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\EFGame\ReleasePC\Packages\0G1MAN0P84NX8I1MZZESXGZ.upk";// args[0];
            // lpkPath = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\EFGame\leveldata2.lpk";// args[0];

            using var fileStream = new FileStream(lpkPath, FileMode.Open, FileAccess.Read);
            using var binaryReader = new BinaryReader(fileStream);
            var numFiles = binaryReader.ReadInt32();
            const int entrySize = 528;
            var entriesSize = numFiles * entrySize;
            var dataOffset = entriesSize + 8;

            var bytes = binaryReader.ReadBytes(entriesSize);
            var bf = new Blowfish(Encoding.UTF8.GetBytes(blowfish)) { NonStandard = false, CompatMode = true };
            var decryptedBytes = bf.Decrypt_ECB(bytes);
            using var binaryReader2 = new BinaryReader(new MemoryStream(decryptedBytes));

            for (var i = 1; i <= numFiles; i++)
            {
                var fileNameLength = binaryReader2.ReadInt32();
                var fileName = new string(binaryReader2.ReadChars(fileNameLength));
                var filePath = new string(fileName).Replace("\\..\\", "").TrimStart('\\');
                var fileInfo = new FileInfo(Path.Combine("Output", filePath));
                binaryReader2.BaseStream.Seek(entrySize * i, SeekOrigin.Begin);
                binaryReader2.BaseStream.Seek(-12, SeekOrigin.Current);
                var rawSize = binaryReader2.ReadInt32();
                var encryptedSize = binaryReader2.ReadInt32();
                var compressedSize = binaryReader2.ReadInt32();

                binaryReader.BaseStream.Seek(dataOffset, SeekOrigin.Begin);
                dataOffset += encryptedSize;
                if (!filePath.Contains(fileToDump)) continue;
                if (fileToDump == "") continue;
                var encryptedBytes = binaryReader.ReadBytes(encryptedSize);
                if (compressedSize != 0)
                {
                    var decryptedFileData = bf.Decrypt_ECB(encryptedBytes);
                    var compressedStream = new MemoryStream(decryptedFileData);
                    using var decompressor = new ZLibStream(compressedStream, CompressionMode.Decompress);
                    var finalStream = new MemoryStream();
                    decompressor.CopyTo(finalStream);
                    return finalStream.ToArray();
                }
                else
                {
                    using var a = Aes.Create();
                    a.KeySize = 256;
                    a.BlockSize = 128;
                    a.Mode = CipherMode.CBC;
                    a.Padding = PaddingMode.None;
                    a.Key = SHA256.HashData(Encoding.ASCII.GetBytes(Convert.ToHexString(GetDbKey(fileInfo.Name, aes)).ToLower()));
                    a.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

                    var blockOffset = 0;
                    var blockCount = encryptedSize / 1024;
                    for (var j = 0; j < blockCount; j++)
                    {
                        using var dec = a.CreateDecryptor();
                        dec.TransformBlock(encryptedBytes, blockOffset, 1024, encryptedBytes, blockOffset);
                        blockOffset += 1024;
                    }
                    return encryptedBytes;
                }
            }
            Console.WriteLine("err");
            return new Byte[0];
        }

        static byte[] GetDbKey(string fileName, string key)
        {
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
            fileNameWithoutExtension = fileNameWithoutExtension[(fileNameWithoutExtension.IndexOf('_') + 1)..];
            Console.WriteLine(fileNameWithoutExtension);
            var hashedName = MD5.HashData(Encoding.Unicode.GetBytes(fileNameWithoutExtension));
            //var xorKey = Convert.FromHexString("1069d88738c5c75f82b44a1f0a382762");
            //var xorKey = Convert.FromHexString("ee36ace0d87a9eaea565e6884a058b63");
            //var xorKey = Convert.FromHexString("6310ba0b09cac5e67474c324052bbf48");
            var xorKey = Convert.FromHexString(key);
            for (var i = 0; i < hashedName.Length; i++) hashedName[i] ^= xorKey[15 - i];
            Array.Reverse(hashedName, 0, hashedName.Length);
            return hashedName;
        }
        public static void ExtractDb(String basePath, Region region2, String installDir, String blowfish, String aes)
        {
            var region = region2.ToString();
            //File.WriteAllBytes("EFTable_Item.db", new DumpStaticFile().Dump("EFTable_Item.db"));
            var regionPad = region2 == Region.Korea ? "kr" : "";
            File.WriteAllBytes("EFTable_GameMsg" + region + ".db", Dump(installDir + @"EFGame\data2" + regionPad + ".lpk", blowfish, aes, "EFTable_GameMsg.db"));
            var englishDict = new Dictionary<string, string>();
            var language = "";
            if (region2 == Region.Steam) language = "_English";
            using (SQLiteConnection connect = new SQLiteConnection(@"Data Source=EFTable_GameMsg" + region + ".db"))
            {
                connect.Open();
                DumpAll(connect, "tip.name.monster", englishDict, language);
                //DumpAll(connect, "tip.name.ability");
                DumpAll(connect, "tip.name.skill_", englishDict, language);
                //DumpAll(connect, "tip.name.skillbuff_", englishDict);
            }
            File.WriteAllBytes(basePath + "Resources\\GameMsg" + language + ".bin", ObjectSerialize.Serialize(englishDict));

            //if (region2 != Region.Korea) return;

            File.WriteAllBytes("EFTable_Npc" + region + ".db", Dump(installDir + @"EFGame\data2.lpk", blowfish, aes, "EFTable_Npc.db"));
            var npc = new Dictionary<string, Tuple<String, String>>();
            using (SQLiteConnection connect = new SQLiteConnection(@"Data Source=EFTable_Npc" + region + ".db"))
            {
                connect.Open();
                using (SQLiteCommand fmd = connect.CreateCommand())
                {
                    fmd.CommandType = System.Data.CommandType.Text;
                    fmd.CommandText = @"SELECT * FROM Npc";
                    var r = fmd.ExecuteReader();
                    while (r.Read())
                    {
                        npc.Add(Convert.ToString(r["PrimaryKey"]), new Tuple<string, string>(Convert.ToString(r["Name"]), Convert.ToString(r["Comment"])));
                    }
                }
            }
            File.WriteAllBytes(basePath + "Resources\\Npc.bin", ObjectSerialize.Serialize(npc));

            File.WriteAllBytes("EFTable_Skill" + region + ".db", Dump(installDir + @"EFGame\data2.lpk", blowfish, aes, "EFTable_Skill.db"));
            var skill = new Dictionary<int, String[]>();
            using (SQLiteConnection connect = new SQLiteConnection(@"Data Source=EFTable_Skill" + region + ".db"))
            {
                connect.Open();
                using (SQLiteCommand fmd = connect.CreateCommand())
                {
                    fmd.CommandType = System.Data.CommandType.Text;
                    fmd.CommandText = @"SELECT * FROM Skill GROUP BY PrimaryKey";
                    var r = fmd.ExecuteReader();
                    while (r.Read())
                    {
                        skill.Add(int.Parse(Convert.ToString(r["PrimaryKey"])), new string[] { Convert.ToString(r["Name"]), Convert.ToString(r["Comment"]), Convert.ToString(r["LearnClass"]), Convert.ToString(r["Icon"]), Convert.ToString(r["IconIndex"]) });
                    }
                }
            }
            File.WriteAllBytes(basePath + "Resources\\Skill.bin", ObjectSerialize.Serialize(skill));

            File.WriteAllBytes("EFTable_SkillEffect" + region + ".db", Dump(installDir + @"EFGame\data2.lpk", blowfish, aes, "EFTable_SkillEffect.db"));
            var skillEffect = new Dictionary<int, String>();
            using (SQLiteConnection connect = new SQLiteConnection(@"Data Source=EFTable_SkillEffect" + region + ".db"))
            {
                connect.Open();
                using (SQLiteCommand fmd = connect.CreateCommand())
                {
                    fmd.CommandType = System.Data.CommandType.Text;
                    fmd.CommandText = @"SELECT * FROM SkillEffect GROUP BY PrimaryKey";
                    var r = fmd.ExecuteReader();
                    while (r.Read())
                    {
                        skillEffect.Add(int.Parse(Convert.ToString(r["PrimaryKey"])), Convert.ToString(r["Comment"]));
                    }
                }
            }
            File.WriteAllBytes(basePath + "Resources\\SkillEffect.bin", ObjectSerialize.Serialize(skillEffect));

            File.WriteAllBytes("EFTable_SkillBuff" + region + ".db", Dump(installDir + @"EFGame\data2.lpk", blowfish, aes, "EFTable_SkillBuff.db"));
            var skillBuff = new Dictionary<uint, String>();
            using (SQLiteConnection connect = new SQLiteConnection(@"Data Source=EFTable_SkillBuff" + region + ".db"))
            {
                connect.Open();
                using (SQLiteCommand fmd = connect.CreateCommand())
                {
                    fmd.CommandType = System.Data.CommandType.Text;
                    fmd.CommandText = @"SELECT * FROM SkillBuff GROUP BY PrimaryKey";
                    var r = fmd.ExecuteReader();
                    while (r.Read())
                    {
                        if (!skillBuff.ContainsKey(uint.Parse(Convert.ToString(r["PrimaryKey"]))))
                            skillBuff.Add(uint.Parse(Convert.ToString(r["PrimaryKey"])), Convert.ToString(r["Comment"]));
                    }
                }
            }
            File.WriteAllBytes(basePath + "Resources\\SkillBuff.bin", ObjectSerialize.Serialize(skillBuff));
        }
    }
}

```

`LoaDumper/LoaDumper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Gee.External.Capstone" Version="2.3.0" />
    <PackageReference Include="IronSnappy" Version="1.3.0" />
    <PackageReference Include="System.Data.SQLite.Core" Version="1.0.117" />
  </ItemGroup>

</Project>

```

`LoaDumper/ObjectSerialize.cs`:

```cs
using System.Runtime.Serialization.Formatters.Binary;
using System.IO.Compression;

namespace LoaDumper
{
    // copy/paste https://stackoverflow.com/questions/36276851/serialize-and-deserialize-dictionary-to-binary
    public static class ObjectSerialize
    {
        public static byte[] Serialize(this Object obj)
        {
            if (obj == null) return null;
            using (var memoryStream = new MemoryStream())
            {
                var binaryFormatter = new BinaryFormatter();
                binaryFormatter.Serialize(memoryStream, obj);
                var compressed = Compress(memoryStream.ToArray());
                return compressed;
            }
        }

        public static Object DeSerialize(this byte[] arrBytes)
        {
            using (var memoryStream = new MemoryStream())
            {
                var binaryFormatter = new BinaryFormatter();
                var decompressed = Decompress(arrBytes);
                memoryStream.Write(decompressed, 0, decompressed.Length);
                memoryStream.Seek(0, SeekOrigin.Begin);
                return binaryFormatter.Deserialize(memoryStream);
            }
        }

        public static byte[] Compress(byte[] input)
        {
            byte[] compressesData;

            using (var outputStream = new MemoryStream())
            {
                using (var zip = new GZipStream(outputStream, CompressionMode.Compress)) zip.Write(input, 0, input.Length);
                compressesData = outputStream.ToArray();
            }
            return compressesData;
        }

        public static byte[] Decompress(byte[] input)
        {
            byte[] decompressedData;
            using (var outputStream = new MemoryStream())
            {
                using (var inputStream = new MemoryStream(input))
                using (var zip = new GZipStream(inputStream, CompressionMode.Decompress))
                    zip.CopyTo(outputStream);
                decompressedData = outputStream.ToArray();
            }
            return decompressedData;
        }
    }
}

```

`LoaDumper/PacketDumper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Gee.External.Capstone;
using LoaDumper;

namespace LoaDumper
{
    public class PacketDumper
    {
        static String FasmPath = "";
        static String IdaPath = "";
        static IntPtr hProcess;
        static Gee.External.Capstone.X86.CapstoneX86Disassembler disassembler = CapstoneDisassembler.CreateX86Disassembler(Gee.External.Capstone.X86.X86DisassembleMode.Bit64);
        public class DumpedClass
        {
            public IntPtr ParseOffset;
            public String Name;
            public List<ReadOp> OpList = new List<ReadOp>();
            public Boolean OnlyReadsList;
        }
        static Dictionary<UInt64, DumpedClass> Dumped = new Dictionary<UInt64, DumpedClass>();
        public class ReadOp
        {
            public UInt64 dumpedClass;
            public UInt64 structOff;
            public String Name;
            public String Rename;
            public String Op;
            public Boolean If;
            public Boolean For;
            public Boolean List;
            public Boolean ReadsList;
        }
        public static String GetReadName(UInt64 dumpedClass)
        {
            GetReadInfo(dumpedClass, out String readType, out _, out String name, out _, out bool customName);
            return readType;
        }
        public static void GetReadInfo(UInt64 dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size, out Boolean customName)
        {
            customName = false;
            readType = "err";
            readCommand = "err";
            name = "err";
            size = dumpedClass;
            if (dumpedClass == 1)
            {
                readType = "Byte";
                readCommand = "reader.ReadByte()";
                name = "b";
            }
            else if (dumpedClass == 2)
            {
                readType = "UInt16";
                readCommand = "reader.ReadUInt16()";
                name = "u16";
            }
            else if (dumpedClass == 4)
            {
                readType = "UInt32";
                readCommand = "reader.ReadUInt32()";
                name = "u32";
            }
            else if (dumpedClass == 8)
            {
                readType = "UInt64";
                readCommand = "reader.ReadUInt64()";
                name = "u64";
            }
            else if (dumpedClass == Dumped.First(d => d.Value.Name == "PackedInt").Key)
            {
                readType = "Int64";
                readCommand = "reader.ReadPackedInt()";
                name = "p64";
                size = 8;
            }
            else if (dumpedClass == Dumped.First(d => d.Value.Name == "SimpleInt").Key)
            {
                readType = "UInt64";
                readCommand = "reader.ReadSimpleInt()";
                name = "s64";
                size = 8;
            }
            else if (dumpedClass == Dumped.First(d => d.Value.Name == "String").Key)
            {
                readType = "String";
                readCommand = "reader.ReadString()";
                name = "str";
                size = 16;
            }
            else if (dumpedClass == Dumped.First(d => d.Value.Name == "Flag").Key)
            {
                readType = "UInt64";
                readCommand = "reader.ReadFlag()";
                name = "flag";
                size = 16;
            }
            else if (dumpedClass == Dumped.First(d => d.Value.Name == "PackedValues").Key)
            {
                readType = "List<Object>";
                readCommand = "reader.ReadPackedValues(1, 1, 4, 4, 4, 3, 6)";
                name = "packed";
                size = 16;
            }
            else if (dumpedClass < 0x1000)
            {
                readType = "Byte[]";
                readCommand = "reader.ReadBytes(" + dumpedClass + ")";
                name = "bytearray";
            }
            else if (dumpedClass < 0x1100)
            {
                readType = "Byte[]";
                readCommand = "reader.ReadBytes(" + (dumpedClass - 0x1000) + ")";
                name = "bytearray";
            }
            else if (Dumped[dumpedClass].OnlyReadsList)
            {
                GetReadInfo(Dumped[dumpedClass].OpList[1].dumpedClass, out String subReadType, out String subReadCommand, out String subName, out size, out customName);
                readType = "List<" + subReadType + ">";
                readCommand = "reader.ReadList<" + subReadType + ">()";
                if (subReadType == "Byte[]") readCommand = "reader.ReadList<" + subReadType + ">(" + Dumped[dumpedClass].OpList[1].dumpedClass + ")";
                if (Dumped[dumpedClass].OpList[1].dumpedClass > 0x1000)
                    name = char.ToLower(subReadType[0]) + subReadType.Substring(1) + "s";
                else name = subName + "list";
            }
            else
            {
                customName = true;
                size = 0;
                readType = Dumped[dumpedClass].Name;
                foreach (var o in Dumped[dumpedClass].OpList)
                {
                    GetReadInfo(o.dumpedClass, out _, out _, out _, out UInt64 subSize, out _);
                    size += subSize;
                }
                readCommand = "reader.Read<" + Dumped[dumpedClass].Name + ">()";
                name = char.ToLower(readType[0]) + readType.Substring(1);
            }
        }
        public static void DumpClass(DumpedClass cl, Region region, out String baseClass, out String regionClass)
        {
            var privateClass = new StringBuilder();
            privateClass.AppendLine("using System;");
            privateClass.AppendLine("using System.Collections.Generic;");
            privateClass.AppendLine("namespace LostArkLogger");
            privateClass.AppendLine("{");
            privateClass.AppendLine("    public class " + cl.Name + " : Packet");
            privateClass.AppendLine("    {");
            var classHeader = new StringBuilder();
            classHeader.AppendLine("using System;");
            classHeader.AppendLine("using System.Collections.Generic;");
            classHeader.AppendLine("namespace LostArkLogger");
            classHeader.AppendLine("{");
            classHeader.AppendLine("    public partial class " + cl.Name);
            classHeader.AppendLine("    {");
            var baseClassSb = new StringBuilder(classHeader.ToString());
            baseClassSb.AppendLine("        public " + cl.Name + "(BitReader reader)");
            baseClassSb.AppendLine("        {");
            foreach (var r in new List<String> { "Steam", "Korea" })
                //foreach (var r in new List<String> { "Steam" })
                baseClassSb.AppendLine("            if (Properties.Settings.Default.Region == Region." + r + ") " + r + "Decode(reader);");
            //baseClassSb.AppendLine("            if (Properties.Settings.Default.Region == Region." + r + ") " + "SteamDecode(reader);");
            var properties = new StringBuilder();
            var regionClassSb = new StringBuilder(classHeader.ToString());
            regionClassSb.AppendLine("        public void " + region + "Decode(BitReader reader)");
            regionClassSb.AppendLine("        {");
            //foreach(var op in cl.OpList)
            cl.OpList.Where(o => !String.IsNullOrEmpty(o.Rename)).ToList().ForEach(o => o.Name = o.Rename);
            var ordered = cl.OpList.OrderBy(o => String.IsNullOrEmpty(o.Rename)).ThenByDescending(o => o.dumpedClass).ThenBy(o => o.Name).ToList();
            //var fieldCount = 0;
            //ordered.Where(o=> String.IsNullOrEmpty(o.Rename)).ToList().ForEach(o => o.Name = "field" + fieldCount++);
            /*foreach (var group in ordered.Where(o => String.IsNullOrEmpty(o.Rename)).GroupBy(o => o.dumpedClass))
            {
                var fieldCount = 0;
                GetReadInfo(group.First().dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size);
                if (group.Count() > 1)
                    group.ToList().ForEach(o => o.Name = name + "_" + fieldCount++);
                else
                    group.First().Name = name;
            }*/

            //foreach (var group in ordered.Where(o => String.IsNullOrEmpty(o.Rename) && !GetReadType(o.dumpedClass).Contains("Byte[]")).GroupBy(o => GetReadType(o.dumpedClass)))
            foreach (var group in ordered.Where(o => String.IsNullOrEmpty(o.Rename)).GroupBy(o => GetReadName(o.dumpedClass)))
            {
                var fieldCount = 0;
                GetReadInfo(group.First().dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size, out bool customName);
                //if (group.First().dumpedClass < 0x20000 || readType.Contains("Byte[]"))
                if (!customName)
                    group.ToList().ForEach(o => o.Name = name + "_" + fieldCount++);
                else
                    group.ToList().ForEach(o => o.Name = name);
            }/*
            var bacount = 0;
            {
                var fieldCount = 0;
                var bytearrays = ordered.Where(o => String.IsNullOrEmpty(o.Rename) && GetReadType(o.dumpedClass).Contains("List<Byte[]"));
                foreach (var ba in bytearrays)
                {
                    GetReadInfo(ba.dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size);
                    ba.Name = name + "_" + fieldCount++;
                }
            }
            bacount = 0;
            {
                var fieldCount = 0;
                var bytearrays = ordered.Where(o => String.IsNullOrEmpty(o.Rename) && GetReadType(o.dumpedClass).Contains("Byte[]"));
                foreach (var ba in bytearrays)
                {
                    GetReadInfo(ba.dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size);
                    ba.Name = name + "_" + fieldCount++;
                }
            }
            /*foreach (var group in ordered.Where(o => String.IsNullOrEmpty(o.Rename)).GroupBy(o => o.Name))
            {
                var fieldCount = 0;
                if (group.Count() > 1)
                    group.ToList().ForEach(o => o.Name = o.Name + "_" + fieldCount++);
            }*/
            if (cl.OpList.Any(o => o.List)) cl.OpList.First().Name = "num";
            for (var i = 0; i < cl.OpList.Count; i++)
            {
                var op = cl.OpList[i];
                GetReadInfo(op.dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size, out bool customName);
                if (op.List)
                    regionClassSb.AppendLine("            " + (op.List ? "    " : "") + op.Name + ".Add(" + readCommand + ");");
                else
                    regionClassSb.AppendLine("            " + (op.List ? "    " : "") + op.Name + " = " + readCommand + ";");
                if (op.If) regionClassSb.AppendLine("            if (" + op.Name + " == 1)");
                if (op.If) regionClassSb.Append("    ");
                if (op.Name == "num") regionClassSb.AppendLine("            for(var i = 0; i < num; i++)");
                if (op.Name == "num") regionClassSb.AppendLine("            {");
            }
            for (var i = 0; i < ordered.Count; i++)
            {
                var op = ordered[i];
                var structoff = "//" + op.structOff;
                structoff = "";
                GetReadInfo(op.dumpedClass, out String readType, out String readCommand, out String name, out UInt64 size, out bool customName);
                if (op.List)
                    properties.AppendLine("        public List<" + readType + "> " + op.Name + " = new List<" + readType + ">();" + structoff);
                else
                    properties.AppendLine("        public " + readType + " " + op.Name + ";" + structoff);
            }
            if (cl.OpList.Any(o => o.List)) regionClassSb.AppendLine("            }");

            baseClassSb.AppendLine("        }");
            baseClassSb.Append(properties.ToString());
            baseClassSb.AppendLine("    }");
            baseClassSb.AppendLine("}");
            regionClassSb.AppendLine("        }");
            regionClassSb.AppendLine("    }");
            regionClassSb.AppendLine("}");
            baseClass = baseClassSb.ToString();
            regionClass = regionClassSb.ToString();
        }
        public static void ParseFunc(Byte[] bytes, IntPtr getPacket, String packetName)
        {
            var dumpClass = new DumpedClass { ParseOffset = getPacket, Name = packetName };
            if (Dumped.ContainsKey((UInt64)getPacket)) return;
            Dumped.Add((UInt64)getPacket, dumpClass);
            var fieldNum = 0;
            var fieldNumPerType = new Dictionary<String, int>();
            var structCounter = 1;
            //Console.WriteLine("opcode : " + opcode.ToString("X") + " : " + opcodeToName[opcode]);
            var readSize = 0u;
            var structOff = 0u;
            //var instructions = disassembler.Disassemble();
            var instructions = disassembler.Disassemble(bytes);
            var bodyParser = new StringBuilder();
            var properties = new StringBuilder();
            var list = false;
            for (var i = 0; i < instructions.Length; i++)
            //foreach (var instruction in instructions)
            {
                var instruction = instructions[i];
                //Console.WriteLine(instruction.Mnemonic + " " + instruction.Operand);
                if (instruction.Mnemonic == "mov" && instruction.Operand.StartsWith("r8d"))
                {
                    if (readSize != 0)
                        Console.WriteLine("mov failed!!!!");
                    if (instruction.Bytes.Length == 6)
                        readSize = BitConverter.ToUInt32(instruction.Bytes, 2);
                }
                if (instruction.Mnemonic == "imul" && instruction.Operand.StartsWith("r8d"))
                {
                    if (readSize != 0)
                        Console.WriteLine("imul failed!!!!");
                    if (instruction.Bytes.Length == 4)
                        readSize = instruction.Bytes[3];
                }
                if (instruction.Mnemonic == "movsx" && instruction.Operand.StartsWith("r8"))
                {
                    if (readSize != 0)
                        Console.WriteLine("movsx failed!!!!");
                    readSize = 1;
                }
                if (instruction.Mnemonic == "shl" && instruction.Operand.StartsWith("r8d"))
                {
                    if (readSize == 0)
                        Console.WriteLine("shl failed!!!!");
                    //if (instruction.Bytes.Length == 4)
                    readSize = (uint)((int)readSize << (int)instruction.Details.Operands[1].Immediate); // need to multiply still
                }
                if (instruction.Mnemonic == "lea" && instruction.Operand.StartsWith("r8d, [rbp"))
                {
                    if (readSize != 0)
                        Console.WriteLine("lea1 failed!!!!");
                    if (instruction.Bytes.Length == 4)
                        readSize = (UInt32)instruction.Details.Displacement;
                }
                if (instruction.Mnemonic == "lea" && instruction.Operand.StartsWith("r8d, [rcx"))
                {
                    if (readSize != 0)
                        Console.WriteLine("lea2 failed!!!!");
                    if (instruction.Operand.Contains("rcx + rcx*2"))
                        readSize = 3;
                    else if (instruction.Operand.Contains("rcx + rcx]"))
                        readSize = 2;
                    else readSize = 1;
                }
                if (instruction.Mnemonic == "lea" && (instruction.Operand.StartsWith("rcx") || instruction.Operand.StartsWith("rdx") || instruction.Operand.StartsWith("r9")) && !instruction.Operand.Contains("rsp"))
                {
                    if (structOff != 0) Console.WriteLine("lea failed!!!!");
                    structOff = (uint)instruction.Details.Displacement;
                }
                if (instruction.Mnemonic == "add" && instruction.Operand.StartsWith("rcx"))
                {
                    if (structOff != 0) Console.WriteLine("mov struct off failed!!!!");
                    structOff = (uint)instruction.Details.Displacement;
                }
                if (instruction.Mnemonic + " " + instruction.Operand == "add r8d, r8d")
                {
                    Console.WriteLine("werid struct");
                    readSize = 2;
                }
                if ((instruction.Mnemonic == "jmp" && instruction.Operand.StartsWith("qword"))
                    || (instruction.Mnemonic == "call" && instruction.Operand.StartsWith("qword")))
                {
                    if (readSize == 0)
                    {
                        list = true;
                        readSize += 1;
                        Console.Write("");
                    }
                    dumpClass.OpList.Add(new ReadOp { dumpedClass = readSize, Name = "field" + fieldNum++, List = list, structOff = structOff });
                    readSize = 0;
                    structOff = 0;
                }
                else if (instruction.Mnemonic == "jmp" && i == 1)
                {
                    var callAddr = (Int64)UInt64.Parse(instruction.Operand.Substring(2), System.Globalization.NumberStyles.HexNumber);
                    var getSubstruct = (IntPtr)((int)getPacket + callAddr - 0x1000);

                    if (!Dumped.ContainsKey((UInt64)getSubstruct))
                    {
                        var pktParseBytes = sigScan.m_vDumpedRegion.Skip((int)getSubstruct).Take(0x2000).ToArray();
                        ParseFunc(pktParseBytes, (IntPtr)getSubstruct, packetName + "_" + getSubstruct.ToString("X"));// "Struct" + Dumped.Count); // "Sub" + packetName);//
                        //ParseFunc(pktParseBytes, (IntPtr)getSubstruct, packetName + "_genStruct");// "Struct" + Dumped.Count); // "Sub" + packetName);//
                    }

                    dumpClass.OpList.Add(new ReadOp { dumpedClass = (UInt64)getSubstruct, Name = "field" + fieldNum++, List = list, structOff = structOff });
                    structOff = 0;
                }

                else if (instruction.Mnemonic == "call")
                {
                    var callAddr = (Int64)UInt64.Parse(instruction.Operand.Substring(2), System.Globalization.NumberStyles.HexNumber);
                    var getSubstruct = (IntPtr)((int)getPacket + callAddr - 0x1000);

                    if (!Dumped.ContainsKey((UInt64)getSubstruct))
                    {
                        var pktParseBytes = sigScan.m_vDumpedRegion.Skip((int)getSubstruct).Take(0x2000).ToArray();
                        //ParseFunc(pktParseBytes, (IntPtr)getSubstruct, packetName + "_" + structCounter++);// "Struct" + Dumped.Count); // "Sub" + packetName);//
                        ParseFunc(pktParseBytes, (IntPtr)getSubstruct, packetName + "_" + getSubstruct.ToString("X"));// "Struct" + Dumped.Count); // "Sub" + packetName);//
                        //ParseFunc(pktParseBytes, (IntPtr)getSubstruct, packetName + "_genStruct");// "Struct" + Dumped.Count); // "Sub" + packetName);//
                    }
                    dumpClass.OpList.Add(new ReadOp { dumpedClass = (UInt64)getSubstruct, Name = "field" + fieldNum++, List = list, structOff = structOff });
                    structOff = 0;
                }

                if (instruction.Mnemonic == "cmp" && instruction.Details.Operands.Length == 2 &&
                    ((instruction.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Immediate && instruction.Details.Operands[1].Immediate > 1)
                    || (instruction.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Immediate && instruction.Details.Operands[1].Immediate > 1)))
                {
                    fieldNum--;
                    list = true;
                }
                else if (instruction.Mnemonic == "cmp" && instruction.Details.Operands.Length == 2 && instruction.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Immediate && instruction.Details.Operands[1].Immediate == 1)
                {
                    fieldNum--;
                    dumpClass.OpList.Last().If = true;
                }
                else if (instruction.Mnemonic == "cmp")
                {
                    if (list == false)
                    {
                        fieldNum--;
                        list = true;
                    }
                }
                if (instruction.Mnemonic == "ret")
                    break;
                if (instruction.Mnemonic == "int3")
                    break;
            }
            if (dumpClass.OpList.Count == 2 && dumpClass.OpList[0].dumpedClass == 2 && dumpClass.OpList.Any(o => o.List == true))
                dumpClass.OnlyReadsList = true;
            //if (dumpClass.Name.Contains("genStruct")) dumpClass.Name = dumpClass.Name.Replace("genStruct", dumpClass.OpList.Max(a=>a.structOff).ToString("X"));
        }
        static Process process;
        static SigScan sigScan;
        public static Dictionary<String, Dictionary<UInt64, String>> fieldRenames = new Dictionary<string, Dictionary<ulong, string>>();
        public class PartialByte
        {
            public uint offset;
            public uint size;
            public string name;
        }
        static List<ReadOp> SplitByteArray(List<PartialByte> named, uint byteArrayOffset, uint byteArraySize)
        {
            var readOps = new List<ReadOp>();
            var ordered = named.OrderBy(n => n.offset).ToList();
            var currentOffset = byteArrayOffset;
            while (true)
            {
                //if (ordered[0].offset > currentOffset)
                {
                    readOps.Add(new ReadOp { structOff = currentOffset - byteArrayOffset, dumpedClass = 0x1000 + ordered[0].offset - currentOffset, Name = "field" + readOps.Count });
                    currentOffset = ordered[0].offset;
                }
                //else
                {
                    readOps.Add(new ReadOp { structOff = ordered[0].offset, dumpedClass = ordered[0].size, Rename = ordered[0].name });
                    currentOffset += ordered[0].size;
                    if (ordered.Count == 1)
                    {
                        // if (currentOffset < byteArraySize)
                        readOps.Add(new ReadOp { structOff = ordered[0].offset + ordered[0].size, dumpedClass = 0x1000 + byteArrayOffset + byteArraySize - currentOffset, Name = "field" + readOps.Count });
                        break;
                    }
                    ordered = ordered.Skip(1).ToList();
                }
            }
            return readOps;
        }
        public static String Dump(String savePath, String gameDir, Region region, out String blowfish, out String aes)
        {
            var nameToOpcode = new Dictionary<String, UInt32>();
            var nameToSize = new Dictionary<String, UInt32>();
            var nameToHandler = new Dictionary<String, IntPtr>();
            var nameToGetOpcode = new Dictionary<String, UInt64>();
            aes = "";
            blowfish = "";
            disassembler.EnableInstructionDetails = true;
            disassembler.DisassembleSyntax = DisassembleSyntax.Intel;
            var sb = new StringBuilder();
            sb.AppendLine("using System;");
            sb.AppendLine("namespace LostArkLogger");
            sb.AppendLine("{");
            sb.AppendLine("    public enum OpCodes_" + region + " : UInt16");
            sb.AppendLine("    {");
            //var orig = File.ReadAllBytes(@"C:\Users\Downloads\lostark\lostark.exe");
            //var process = Process.Start(@"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\Binaries\Win64\LOSTARK.exe", "-launch_from_dev_launcher -AuthKey=");
            if (region == Region.Korea) process = Process.Start(gameDir + @"Binaries\Win64\LOSTARKkr.exe", "-launch_from_dev_launcher -AuthKey=");
            else process = Process.Start(gameDir + @"Binaries\Win64\LOSTARK.exe", "-launch_from_dev_launcher -AuthKey=");
            //var process = Process.GetProcessesByName("Launch_Game")[0];
            hProcess = OpenProcess(0xFFFF, false, process.Id);
            var nops = Enumerable.Range(0, 0x50).Select(s => (byte)0x90).ToArray();

            var orig = new Byte[4];
            ReadProcessMemory(hProcess, (IntPtr)(process.MainModule.BaseAddress + 0x10000), orig, 4, out _);
            while (true) // wait for some code exec
            {
                var negOne = new Byte[4];
                ReadProcessMemory(hProcess, (IntPtr)(process.MainModule.BaseAddress + 0x10000), negOne, 4, out _);
                if (!negOne.SequenceEqual(orig)) break;
                Thread.Sleep(50);
            }
            Thread.Sleep(1500);
            NtSuspendProcess(hProcess);
            sigScan = new SigScan(process, process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            Func<IntPtr, IntPtr> GetFuncStart = new Func<IntPtr, IntPtr>((IntPtr a) => {
                for (var i = 0; i < 0x2000; i++)
                {
                    //if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0xcc && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i - 1] == 0xcc)
                    if (((sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i - 1] == 0xcc && (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i - 2] == 0xcc || sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i - 2] == 0xc3)) || sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i - 1] == 0xc3) && ((UInt64)a - (UInt64)sigScan.Address - (UInt64)i) % 0x10 == 0
                    && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] != 0xc2 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] != 0 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] != 0xff)
                    {
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0xf3) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0xfe) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x4d) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x17) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x51) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x48 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i + 1] == 0x83) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x48 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i + 1] == 0x81) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x48 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i + 1] == 0x8D) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x48 && sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i + 1] == 0xC1) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x4) continue;
                        if (sigScan.m_vDumpedRegion[(int)((UInt64)a - (UInt64)sigScan.Address) - i] == 0x48)
                        {
                            Console.WriteLine("found valid func!");
                        }
                        return (IntPtr)((UInt64)a - (UInt64)i);
                    }
                }
                return IntPtr.Zero;
            });
            Func<String, IntPtr> GetFuncFromString = new Func<String, IntPtr>((String a) =>
            {
                var stringAddr = sigScan.FindPatterns(BitConverter.ToString(Encoding.Unicode.GetBytes(a)).Replace("-", " "), process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0];
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if ((sigScan.m_vDumpedRegion[i] == 0x48 || sigScan.m_vDumpedRegion[i] == 0x4c) && sigScan.m_vDumpedRegion[i + 1] == 0x8d)
                    {
                        var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 3);
                        var addr = sigScan.Address + i + jmpTo + 7;
                        if (addr == stringAddr)
                        {
                            return GetFuncStart((IntPtr)((UInt64)i + (UInt64)sigScan.Address));
                        }
                    }
                }
                return IntPtr.Zero;
            });
            Func<IntPtr, IntPtr> GetXrefToFunc = new Func<IntPtr, IntPtr>((IntPtr a) =>
            {
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if (sigScan.m_vDumpedRegion[i] == 0xe8)
                    {
                        var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 1);
                        var addr = sigScan.Address + i + jmpTo + 5;
                        if (addr == a)
                        {
                            return (IntPtr)((UInt64)i + (UInt64)sigScan.Address);
                        }
                    }
                }
                return IntPtr.Zero;
            });
            Func<IntPtr, List<IntPtr>> GetXrefsToFunc = new Func<IntPtr, List<IntPtr>>((IntPtr a) =>
            {
                var xrefs = new List<IntPtr>();
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if (sigScan.m_vDumpedRegion[i] == 0xe8)
                    {
                        var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 1);
                        var addr = sigScan.Address + i + jmpTo + 5;
                        if (addr == a)
                        {
                            xrefs.Add((IntPtr)((UInt64)i + (UInt64)sigScan.Address));
                            //return (IntPtr)((UInt64)i + (UInt64)sigScan.Address);
                        }
                    }
                }
                //return IntPtr.Zero;
                return xrefs;
            });
            Func<String, Int32, IntPtr> GetFuncFromStringOffset = new Func<String, Int32, IntPtr>((String a, Int32 offset) =>
            {
                var stringAddrs = sigScan.FindPatterns(BitConverter.ToString(Encoding.Unicode.GetBytes(a)).Replace("-", " "), process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                if (stringAddrs.Count() == 0) return IntPtr.Zero;
                var stringAddr = stringAddrs.Count() == 1 ? stringAddrs[0] : stringAddrs.First(a => (UInt64)a % 0x10 == 0);
                //stringAddr = (IntPtr)(stringAddr+(int)offset);
                stringAddr += offset;
                if ((UInt64)stringAddr % 0x10 != 0) stringAddr += 8;
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if (sigScan.m_vDumpedRegion[i] == 0x48 && sigScan.m_vDumpedRegion[i + 1] == 0x8d)
                    {
                        var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 3);
                        var addr = sigScan.Address + i + jmpTo + 7;
                        if (addr == stringAddr)
                        {
                            return GetFuncStart((IntPtr)((UInt64)i + (UInt64)sigScan.Address));
                        }
                    }
                }
                return IntPtr.Zero;
            });
            Func<int, int> ParsePreviousCommand = new Func<int, int>((int a) =>
            {
                //var off = (UInt16)a - (UInt16)sigScan.Address;
                var off = a;
                if (sigScan.m_vDumpedRegion[off - 3] == 0x49 && sigScan.m_vDumpedRegion[off - 2] == 0x8b && sigScan.m_vDumpedRegion[off - 1] == 0xd0)
                {
                    return 3;
                }
                if (sigScan.m_vDumpedRegion[off - 5] == 0xe9 && sigScan.m_vDumpedRegion[off - 1] == 0xff)
                {
                    return 5;
                }
                if (sigScan.m_vDumpedRegion[off - 6] == 0x0f && sigScan.m_vDumpedRegion[off - 5] == 0x85 && sigScan.m_vDumpedRegion[off - 1] == 0)
                {
                    return 6;
                }
                if (sigScan.m_vDumpedRegion[off - 6] == 0x81 && sigScan.m_vDumpedRegion[off - 5] == 0xfa && sigScan.m_vDumpedRegion[off - 1] == 0)
                {
                    return 6;
                }
                if (sigScan.m_vDumpedRegion[off - 2] == 0x7f)
                {
                    return 2;
                }
                if (sigScan.m_vDumpedRegion[off - 2] == 0x74)
                {
                    return 2;
                }
                return 0;
            });
            Func<IntPtr, UInt16> GetOpcodeFromHandler = new Func<IntPtr, ushort>((IntPtr a) =>
            {
                var toIda = (UInt64)a - (UInt64)process.MainModule.BaseAddress;
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if (sigScan.m_vDumpedRegion[i] == 0xe9)
                    {
                        var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 1);
                        var addr = sigScan.Address + i + jmpTo + 5;
                        if (addr == a)
                        {
                            for (var j = i % 0x10; j < 0x1000; j += 0x10)
                            {
                                if (((sigScan.m_vDumpedRegion[i - j - 2] == 0xc3 || sigScan.m_vDumpedRegion[i - j - 2] == 0xcc) && sigScan.m_vDumpedRegion[i - j - 1] == 0xcc) || sigScan.m_vDumpedRegion[i - j - 1] == 0xc3)
                                {
                                    var jmpTable = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(i - j).Take(0x1000).ToArray());//.Reverse().SkipWhile(k => k.Address == i - j);
                                    var jmpToHandler = jmpTable.First(k => k.Address == j + 0x1000);
                                    UInt64 curValue = (UInt64)0;
                                    for (var jmps = 0; jmps < jmpTable.Length; jmps++)
                                    {
                                        if (jmpTable[jmps].Mnemonic == "cmp" && jmpTable[jmps].Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Immediate)
                                        {
                                            curValue = (UInt64)jmpTable[jmps].Details.Operands[1].Immediate;
                                            for (var jmps2 = jmps + 1; jmps2 < jmpTable.Length; jmps2++)
                                            {
                                                if (jmpTable[jmps2].Mnemonic == "jmp" || jmpTable[jmps2].Mnemonic == "je")
                                                {
                                                    if (jmpTable[jmps2].Mnemonic == "jmp")
                                                    {
                                                        if (jmpTable[jmps2].Address == j + 0x1000) return (UInt16)curValue;
                                                    }
                                                    else if (jmpTable[jmps2].Mnemonic == "je")
                                                    {
                                                        var index = jmpTable.TakeWhile(k => k.Address != jmpTable[jmps2].Details.Operands[0].Immediate).Count();
                                                        for (var jmps3 = index; jmps3 < jmpTable.Length; jmps3++)
                                                        {
                                                            if (jmpTable[jmps3].Mnemonic == "jmp")
                                                            {
                                                                if (jmpTable[jmps3].Address == j + 0x1000) return (UInt16)curValue;
                                                                //Console.WriteLine("found it " + jmps3);
                                                                break;
                                                            }
                                                        }

                                                    }
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    var reversed = jmpTable.TakeWhile(k => k.Address != j + 0x1000).Reverse().ToList();
                                    var jmpAddr = reversed[0].Address;
                                    var jmpLabel = jmpTable.FirstOrDefault(k => k.Mnemonic == "je" && k.Details.Operands[0].Immediate == jmpAddr);
                                    if (jmpLabel == null)
                                    {
                                        jmpAddr = reversed[1].Address;
                                        jmpLabel = jmpTable.FirstOrDefault(k => k.Mnemonic == "je" && k.Details.Operands[0].Immediate == jmpAddr);
                                    }
                                    if (jmpLabel == null && reversed[2].Details.Operands.Length >= 2 && reversed[2].Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Immediate)
                                    {
                                        return (UInt16)reversed[2].Details.Operands[1].Immediate;
                                    }
                                    if (jmpLabel == null)
                                    {
                                        var qq = reversed.FirstOrDefault(o => o.Mnemonic == "cmp");
                                        if (qq != null)
                                            return (UInt16)reversed.First(o => o.Mnemonic == "cmp").Details.Operands[1].Immediate;
                                    }
                                    if (jmpLabel == null) continue;
                                    var beforeCmp = jmpTable.TakeWhile(k => k.Address != jmpLabel.Address).Reverse().TakeWhile(k => k.Mnemonic != "cmp");
                                    var subVal = beforeCmp.Where(k => k.Mnemonic == "sub").Sum(a => a.Details.Operands[1].Immediate);
                                    if (subVal > 0x100) return (UInt16)subVal;
                                    var cmpBranch = jmpTable.TakeWhile(k => k.Address != jmpLabel.Address).Reverse().First(k => k.Mnemonic == "cmp");
                                    var opcode = cmpBranch.Details.Operands[1].Immediate;
                                    return (UInt16)opcode;
                                }
                            }
                            //break;
                        }
                        if (addr == a)
                        {
                            var byteDist = ParsePreviousCommand(i);
                            if (byteDist == 3)
                            {
                                var jmpDest = i - byteDist;
                                var asm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(i - byteDist).Take(2).ToArray());
                                var prev = i - byteDist;
                                while (true)
                                {
                                    var offset = ParsePreviousCommand(prev);
                                    prev = prev - offset;
                                    asm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(prev).Take(offset).ToArray());
                                    if (offset == 2)
                                    {
                                        if (prev + sigScan.m_vDumpedRegion[prev + 1] + 2 == jmpDest)
                                        {
                                            offset = ParsePreviousCommand(prev);
                                            prev = prev - offset;
                                            asm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(prev).Take(offset).ToArray());
                                            return (UInt16)asm[0].Details.Operands[1].Immediate;
                                        }
                                    }
                                    if (offset == 0) break;
                                }
                            }
                            break;
                        }
                    }
                }
                return 0;
            });
            Func<IntPtr, UInt16> GetOpcodeFromHandlerBest = new Func<IntPtr, ushort>((IntPtr a) =>
            {
                for (var i = 0; i < sigScan.Size; i++)
                {
                    if (sigScan.m_vDumpedRegion[i] == 0x48 && sigScan.m_vDumpedRegion[i + 1] == 0x8d && sigScan.m_vDumpedRegion[i + 2] == 0x0d)
                    {
                        var lea = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 3);
                        var addr = sigScan.Address + i + lea + 7;
                        if (addr == a)
                        {
                            var leaRef = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(i).Take(0x200).ToArray());
                            var opcode = leaRef.First(j => j.Mnemonic == "mov" && j.Operand.StartsWith("edx")).Details.Operands[1].Immediate;
                            return (UInt16)opcode;
                        }
                    }
                }
                return 0;
            });
            Func<IntPtr, IntPtr> GetVtableFromCtor = new Func<IntPtr, IntPtr>((IntPtr a) =>
            {
                var ctor = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)a - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                for (var i = 0; i < ctor.Length; i++)
                {
                    if (ctor[i].Mnemonic == "lea" && ctor[i].Operand.StartsWith("rax"))
                    {
                        var lea = BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)((Int64)a - (Int64)sigScan.Address + ctor[i].Address - 0x1000 + 3));
                        var vTableStart = sigScan.Address + (int)((Int64)a - (Int64)sigScan.Address + ctor[i].Address - 0x1000 + 7) + lea;
                        return vTableStart;
                    }
                }
                return IntPtr.Zero;
            });
            Func<IntPtr, String> GetAsmForFunc = new Func<IntPtr, String>((IntPtr a) =>
            {
                var sb = new StringBuilder();
                var func = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)a - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                for (var i = 0; i < func.Length; i++)
                {
                    var aa = func[i];
                    var line = "";
                    if (aa.Mnemonic.StartsWith("nop") && aa.Address == 0x1244)
                        Console.WriteLine("adfba");
                    if (func[i].Mnemonic.StartsWith("j"))
                    {
                        var fs = aa.ToString();
                        line = func[i].Mnemonic + " 0x" + (0x400000 + func[i].Details.Operands[0].Immediate).ToString("X");// + " // " + BitConverter.ToString(func[i].Bytes));
                    }
                    else if (func[i].Mnemonic.StartsWith("nop"))
                    {
                        for (var j = 0; j < func[i].Bytes.Length; j++)
                            line = "nop";//// + " : " + BitConverter.ToString(func[i].Bytes));
                    }
                    else
                        line = func[i].Mnemonic + " " + func[i].Operand.Replace("ptr ", "").Replace("xmmword ", "");// + " // " + BitConverter.ToString(func[i].Bytes));
                    // rep stosb byte [rdi], al  // remove this
                    if (line.Contains("gs:")) line = line.Replace("[", "").Replace("]", "").Replace("gs", "ptr gs");
                    if (line.Contains("movabs")) line = line.Replace("movabs", "mov");
                    sb.AppendLine(line);
                    if (func[i].Mnemonic.StartsWith("ret")) break;
                }
                return sb.ToString();
            });
            Func<IntPtr, String> GetPsuedocode = new Func<IntPtr, String>((IntPtr a) =>
            {
                var asm = GetAsmForFunc(a);
                asm = "format pe64 console\nuse64\nentry start\nsection '.text' code readable executable\nstart:\n" + asm;
                File.WriteAllText("temp.asm", asm);
                var asmGen = Process.Start(FasmPath + "FASM.EXE", "temp.asm temp.exe");
                while (!asmGen.HasExited) Thread.Sleep(15);
                var psuedoGen = Process.Start(IdaPath + "idat64.exe", "-Ohexrays:-new:-nosave:temp:start -A temp.exe");
                while (!psuedoGen.HasExited) Thread.Sleep(150);
                var psuedoCode = File.ReadAllText("temp.c");
                File.Delete("temp.c");
                File.Delete("temp.exe");
                File.Delete("temp.exe.i64");
                File.Delete("temp.asm");
                return psuedoCode;
            });
            Func<IntPtr, UInt16> GetOpcodeFromVtable = new Func<IntPtr, UInt16>((IntPtr a) =>
            {
                var addr = (int)(BitConverter.ToInt64(sigScan.m_vDumpedRegion, (int)((Int64)a - (Int64)sigScan.Address) + 8) - (Int64)sigScan.Address);
                var ops = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip(addr).Take(0x100).ToArray());
                var moveax = ops.First(o => o.Mnemonic == "mov");
                return (UInt16)moveax.Details.Operands[1].Immediate;
            });
            var versionCheckSize = sigScan.FindPatterns("48 83 C8 FF 66 83 7C 41 ? ? 48 8D 40 01 75 F4 8B 89 ? ? ? ? 83 C1 16 8D 04 41 C3", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var versionCheckSizeRef = sigScan.FindPatterns(BitConverter.ToString(BitConverter.GetBytes((UInt64)versionCheckSize[0])).Replace("-", " "), process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var pktTable = (UInt64)versionCheckSizeRef[0] - (UInt64)sigScan.Address - 16;

            var statusEffectParse = GetFuncFromStringOffset("AddBuffOverCount ID", -0xF0 + 0x50);

            var possibleDmg = sigScan.FindPatterns("E8 ? ? ? ?", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            //var possibleDmg = sigScan.FindPatterns("48 ? ? E8 ? ? ? ? FF ? 48", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var skillMove = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("sys.squarehole.announce_new_registration", 0x60 + 5 * 0x50)));
            var skillMove2 = sigScan.FindPatterns("48 8B C4 55 41 54 41 55 41 56 41 57 48 8D 68 B1 48 81 EC ? ? ? ? 48 C7 45 ? ? ? ? ? 48 89 58 08 48 89 70 10 48 89 78 18 45 0F", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var abSkillMove = sigScan.FindPatterns("40 55 56 57 41 54 41 55 41 56 41 57 48 8D AC 24 ? ? ? ? B8 ? ? ? ? E8 ? ? ? ? 48 2B E0 48 C7 44 24 ? ? ? ? ? 48 89 9C 24 ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 85 ? ? ? ? 45 0F", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            //var abSkillMove = sigScan.FindPatterns("40 55 56 57 41 54 41 55 41 56 41 57 48 8D AC 24 ? ? ? ? B8 ? ? ? ? E8 ? ? ? ? 48 2B E0 48 C7 44 24 ? ? ? ? ? 48 89 9C 24 ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 85 ? ? ? ? 45 0F B6 E1 45 8B E8 4C 8B", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            foreach (var d in possibleDmg)
            {
                //var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)((UInt64)d - (UInt64)sigScan.Address) + 4);
                var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)((UInt64)d - (UInt64)sigScan.Address) + 1);
                var addr = IntPtr.Zero + (int)((UInt64)d - (UInt64)sigScan.Address) + jmpTo + 5;
                if (addr == (IntPtr)((UInt64)skillMove - (UInt64)sigScan.Address))
                    nameToHandler["PKTSkillDamageNotify"] = GetFuncStart(d);
                if (addr == (IntPtr)((UInt64)abSkillMove[0] - (UInt64)sigScan.Address))
                    nameToHandler["PKTSkillDamageAbnormalMoveNotify"] = GetFuncStart(d);
            }
            nameToHandler["PKTCounterAttackNotify"] = GetFuncFromStringOffset("TopHudSecureURL", 0 - 0x48 - 0x50 * 5);
            nameToHandler["PKTInitEnv"] = GetFuncFromStringOffset("Logout\0", 0x10);
            /*var proj = GetFuncFromStringOffset("ProjectilePos too near", -0x50);
            if (proj == IntPtr.Zero) nameToHandler["PKTNewProjectile"] = GetFuncStart(sigScan.FindPatterns("40 57 48 83 EC 30 48 C7 44 24 ? ? ? ? ? 48 89 5C 24 ? 48 89 74 24 ? 48 8B DA 48 83 62 ? fe", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
            else nameToHandler["PKTNewProjectile"] = GetFuncStart(GetXrefToFunc(proj));*/
            var proj = GetFuncFromStringOffset("ProjectilePos too near", -0x50);
            if (proj == IntPtr.Zero) nameToHandler["PKTNewProjectile"] = nameToHandler["PKTNewProjectile"] = GetFuncStart(GetXrefsToFunc(GetFuncFromStringOffset("ProjectileManager", 0x30 + 3 * 0x50))[1]);
            else nameToHandler["PKTNewProjectile"] = GetFuncStart(GetXrefToFunc(proj));

            //nameToHandler["PKTStatusEffectAddNotify"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("AddBuffOverCount ID", -0xF0)));
            nameToHandler["PKTStatusEffectAddNotify"] = GetFuncStart(GetXrefToFunc(statusEffectParse));
            nameToHandler["PKTAuthTokenResult"] = GetFuncStart(sigScan.FindPatterns("6B C2 64 33 DB", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
            nameToHandler["PKTSkillStartNotify"] = GetFuncFromString("SkillSyncCheck,"); //  40 57 48 83 EC 60 48 C7 44 24 ? ? ? ? ? 48 89 5C 24 ? 48 8B FA 48 8B D9 48 85 D2 75 07 33 C0 E9
            nameToHandler["PKTSkillStageNotify"] = GetFuncStart(sigScan.FindPatterns("88 8D ? ? ? ? 0F B7 88 ? ? ? ? 66 89 8D ? ? ? ? 0F B6 80 ? ? ? ? 88 85 ? ? ? ? 0F B7 87 ? ? ? ? 66 89 85 ? ? ? ? 0F B6 87 ? ? ? ? 88 85 ? ? ? ? 0F B7 87", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]); //  40 57 48 83 EC 60 48 C7 44 24 ? ? ? ? ? 48 89 5C 24 ? 48 8B FA 48 8B D9 48 85 D2 75 07 33 C0 E9
            nameToHandler["PKTInitPC"] = GetFuncFromStringOffset("sys.pcselect.error_testserver_enter_condition", 0x100);
            nameToHandler["PKTStatusEffectRemoveNotify"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("AddBuffOverCount ID", 0x80 + 2 * 0x50)));

            foreach (var handler in nameToHandler) nameToOpcode[handler.Key] = GetOpcodeFromHandlerBest(handler.Value);

            nameToHandler["PKTNewNpc"] = GetFuncFromString("RECV > PKTNewNpc\0");
            nameToHandler["PKTNewNpcSummon"] = GetFuncFromString("RECV > PKTNewNpcSummon");
            //nameToHandler["PKTStatChangeOriginNotify"] = GetFuncFromStringOffset("LocalPlayer is not die but HP Change to 0", 0x60);
            //   nameToHandler["PKTStatChangeOriginNotify"] = GetFuncFromStringOffset("LocalPlayer is not die but HP Change to 0", 0xB0 + 0x50);
            //nameToHandler["PKTNewPC2"] = GetFuncStart(sigScan.FindPatterns("40 56 57 41 56 48 83 EC 50 48 C7 44 24 ? ? ? ? ? 48 89 5C 24 ? 48 89 AC 24 ? ? ? ? 48 8B DA 4C 8B F1 48 8B CA E8", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
            //nameToHandler["PKTDeathNotify"] = GetFuncStart(sigScan.FindPatterns("48 8B 46 ? 48 3B 46 ? 74 05 48 85 C0 75 32 F3 0F 10 15 ? ? ? ? F3 0F 10 45 ? F3 0F 59 C2 F3 0F 11 45", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
            nameToHandler["PKTNewPC"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("RECV > PKTNewNpc\0", -9 * 0x50)));
            nameToHandler["PKTDeathNotify"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("sys.common.localplayer_instant_revive", -5 * 0x50)));
            nameToHandler["PKTRemoveObject"] = GetFuncFromString("Inter,");
            //nameToHandler["PKTRaidResult"] = GetFuncStart(sigScan.FindPatterns("48 85 D2 75 07 33 C0 E9", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
            nameToHandler["PKTRaidResult"] = GetFuncFromStringOffset("sys.raid.result_failure_braveheart", -0x50);
            nameToHandler["PKTRaidBossKillNotify"] = GetFuncFromStringOffset("Sys.raid.abyss_vote_passed_massage", -6 * 0x50);
            nameToHandler["PKTTriggerBossBattleStatus"] = GetFuncFromStringOffset("Sys.raid.abyss_vote_passed_massage", -5 * 0x50);
            nameToHandler["PKTTriggerStartNotify"] = GetFuncFromStringOffset("(%lld)", -7 * 0x50);
            var ttdsbf = GetFuncFromStringOffset("sys.party.leave_has_pkshield_1", 0x40 + 2 * 0x50);
            var pp = GetXrefToFunc(GetFuncFromStringOffset("sys.party.leave_has_pkshield_1", 0x40 + 2 * 0x50));
            nameToHandler["PKTPartyStatusEffectAddNotify"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("sys.party.leave_has_pkshield_1", 0x40 + 2 * 0x50)));
            nameToHandler["PKTPartyStatusEffectRemoveNotify"] = GetFuncStart(GetXrefToFunc(GetFuncFromStringOffset("sys.party.leave_has_pkshield_1", 0x40 + 6 * 0x50)));
            foreach (var handler in nameToHandler) if (!nameToOpcode.ContainsKey(handler.Key)) nameToOpcode[handler.Key] = GetOpcodeFromHandler(handler.Value);
            foreach (var op in nameToOpcode)
            {
                if (op.Value == 0)
                    Console.WriteLine("failed : " + op.Key);
            }
            //nameToHandler["PKTNewNpcSummon"] = GetFuncFromString("RECV > PKTNewNpcSummon");
            //nameToOpcode["PKTNewNpcSummon"] = 0x22BE;

            var nto = nameToOpcode.OrderBy(b => b.Key);
            foreach (var ntokv in nto) sb.AppendLine("        " + ntokv.Key + " = 0x" + ntokv.Value.ToString("X") + ",");

            var pktHandlerInit2 = sigScan.FindPatterns("75 15 48 8D 54 24 ? 48 8D 4D 90 E8 ? ? ? ? 90 41 8D 5E 01 EB 32 48 C7 44 24", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var pktHandlerInit = sigScan.FindPatterns("48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC 30 48 8B F9 48 8D 0D ? ? ? ? 49 8B F0 8B DA E8", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var readPackedInt = sigScan.FindPatterns("48 89 5C 24 ? 48 89 74 24 ? 48 89 7C 24 ? 41 56 48 83 EC 20 48 8B 02 4C 8B F2 48 8D 51 08 48 8B D9 41 B8 ? ? ? ? 49 8B CE FF 50 18 44 0F B6 43", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var readFlags = sigScan.FindPatterns("48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 83 EC 20 48 8B 02 48 8B FA 48 8D 51 1F 48 8B E9 41 B8", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var readString = sigScan.FindPatterns("48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 83 EC 20 33 ED 48 8B DA 48 8B F9 66 89 29 48 8B 02 44 8D 45 02 48 8D 54 24 ? 48 8B CB 66 89 6C 24 ? FF 50 18 8B F0 0F B7 44 24 ? 66 83 F8 14 77 21 4C", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var readSimpleInt = sigScan.FindPatterns("48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC 20 48 8B 02 48 8B F2 48 8B D9 48 8B D1 41 B8 ? ? ? ? 48 8B CE FF 50 18 44 8B 0B 45 8B C1 8B F8 41 81 E0 ? ? ? ? 41 81 F8 1F 08", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            var readSomePackedValues = sigScan.FindPatterns("48 89 5C 24 ? 48 89 6C 24 ? 48 89 74 24 ? 57 48 83 EC 20 48 8B 02 48 8B FA 48 8D 51 17 48 8B E9 41 B8", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            Dumped.Add((UInt64)((Int64)readString[0] - (Int64)sigScan.Address), new DumpedClass { Name = "String" });
            Dumped.Add((UInt64)((Int64)readPackedInt[0] - (Int64)sigScan.Address), new DumpedClass { Name = "PackedInt" });
            Dumped.Add((UInt64)((Int64)readFlags[0] - (Int64)sigScan.Address), new DumpedClass { Name = "Flag" });
            Dumped.Add((UInt64)((Int64)readSimpleInt[0] - (Int64)sigScan.Address), new DumpedClass { Name = "SimpleInt" });
            foreach (var p in readSomePackedValues)
            {
                Dumped.Add((UInt64)((Int64)p - (Int64)sigScan.Address), new DumpedClass { Name = "PackedValues" });
            }

            var pktVtable0 = BitConverter.ToUInt64(sigScan.m_vDumpedRegion, (int)pktTable);
            //foreach (var pkt in dumpStructs)
            foreach (var pktkv in nameToOpcode)
            {
                if (pktkv.Key == "PKTAuthTokenResult") continue;
                if (pktkv.Key == "PKTRaidResult") continue;
                if (pktkv.Key == "PKTRaidBossKillNotify") continue;
                if (pktkv.Key == "PKTInitEnv")
                {
                }
                if (pktkv.Key == "PKTTriggerBossBattleStatus") continue;
                var possGetOpcodes = sigScan.FindPatterns("B8 " + BitConverter.ToString(BitConverter.GetBytes((UInt32)pktkv.Value)).Replace("-", " ") + " C3 CC CC", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                if (possGetOpcodes.Count() == 0)
                    Console.WriteLine("couldn't find!!");
                foreach (var getOpcodeRef in possGetOpcodes)
                {
                    var pktVtable = sigScan.FindPatterns((BitConverter.ToString(BitConverter.GetBytes(pktVtable0)) + "-" + BitConverter.ToString(BitConverter.GetBytes((UInt64)getOpcodeRef))).Replace("-", " "), process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);

                    var pktParse = BitConverter.ToUInt64(sigScan.m_vDumpedRegion, (int)((Int64)pktVtable[0] - (Int64)sigScan.Address + 24));
                    var pktParseBytes = sigScan.m_vDumpedRegion.Skip((int)((Int64)pktParse - (Int64)sigScan.Address)).Take(0x1000).ToArray();
                    Console.WriteLine(pktkv.Key + " : " + (pktParse - (UInt64)sigScan.Address).ToString("X") + " : " + pktkv.Value.ToString("X"));
                    ParseFunc(pktParseBytes, (IntPtr)(pktParse - (UInt64)sigScan.Address), pktkv.Key);
                }
                //var getOpcodeRef = nameToGetOpcode[pkt];
                //var pktStringRef = sigScan.FindPatterns(BitConverter.ToString(Encoding.Unicode.GetBytes(pkt + "\0")).Replace("-"," "), process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //avar getOpcodeRef = BitConverter.ToUInt64(sigScan.m_vDumpedRegion, (int)((Int64)pktStringRef[0] - (Int64)sigScan.Address) - 0x20);
            }
            var parsedSubStructs = 0;
            if (nameToOpcode.ContainsKey("PKTInitPC"))
            {
                //var handler = sigScan.FindPatterns("4C 8B C0 BA " + BitConverter.ToString(BitConverter.GetBytes((UInt32)nameToOpcode["PKTInitPC"])).Replace("-", " ") + " 48 8B CF", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var leaPkt = (Int64)handler[0] - (Int64)sigScan.Address - 0x22;
                //var handlerOffset = leaPkt + BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)leaPkt + 3) + 7;
                //var handlerFunc = (uint)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)handlerOffset).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse().First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdx")).Details.Displacement;
                //var myIdAddr = sigScan.FindPatterns("4C 8B A6 ? ? ? ? 48 8D 15 ? ? ? ? 48 8D 8E ? ? ? ? FF 15 ? ? ? ? 48 85 C0", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var funcStart = GetFuncStart(myIdAddr);
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTInitPC");
                //var procInitPc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)myIdAddr[0] - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                var fullInitPc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)nameToHandler["PKTInitPC"] - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                var floats = fullInitPc.Where(i => i.Mnemonic == "movss" && i.Operand.StartsWith("xmm1") && i.Operand.Contains("rsi")).ToList();
                var words = fullInitPc.Where(i => i.Mnemonic == "movzx" && i.Operand.StartsWith("eax") && i.Operand.Contains(" word")).ToList();
                //var id = (UInt32)procInitPc.First().Details.Displacement;
                var id = (UInt32)fullInitPc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r12")).Details.Displacement;
                var nameId = (UInt32)fullInitPc.First(i => i.Mnemonic == "lea" && i.Operand.StartsWith("rcx")).Details.Displacement;
                //var nameId = (UInt32)procInitPc[2].Details.Displacement;
                var gearLevel = (UInt32)floats[0].Details.Displacement;
                var classId = (UInt32)words[0].Details.Displacement;
                var level = (UInt32)words[2].Details.Displacement;
                cl.Value.OpList.First(c => c.structOff == id).Rename = "PlayerId";
                cl.Value.OpList.First(c => c.dumpedClass == Dumped.First(d => d.Value.Name == "String").Key).Rename = "Name";
                //cl.Value.OpList.First(c => c.structOff == nameId).Rename = "Name";
                cl.Value.OpList.First(c => c.structOff == gearLevel).Rename = "GearLevel";
                cl.Value.OpList.First(c => c.structOff == classId).Rename = "ClassId";


                var byteArray = cl.Value.OpList.First(o => o.dumpedClass > 100 && o.dumpedClass < 200);
                var bIndex = cl.Value.OpList.IndexOf(byteArray);
                cl.Value.OpList.InsertRange(bIndex, SplitByteArray(new List<PartialByte> { new PartialByte { name = "Level", size = 2, offset = level } }, (uint)byteArray.structOff, (uint)byteArray.dumpedClass));
                cl.Value.OpList.Remove(byteArray);
            }
            if (nameToOpcode.ContainsKey("PKTInitEnv"))
            {
                /*var handler = sigScan.FindPatterns("4C 8B C0 BA " + BitConverter.ToString(BitConverter.GetBytes((UInt32)nameToOpcode["PKTInitEnv"])).Replace("-", " ") + " 48 8B CF", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                var leaPkt = (Int64)handler[0] - (Int64)sigScan.Address - 0x22;
                var handlerOffset = leaPkt + BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)leaPkt + 3) + 7;*/
                var handlerFunc = (uint)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTInitEnv"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse().First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdx")).Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTInitEnv");
                cl.Value.OpList.First(c => c.structOff == handlerFunc).Rename = "PlayerId";
            }
            if (nameToOpcode.ContainsKey("PKTSkillDamageNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTSkillDamageNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse().ToList();//
                var skillins = handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r8d"));
                var skillOp = (uint)skillins.Details.Displacement;
                var stuff = handlerFunc.Select(s => s.Address.ToString("X") + " : " + s.Mnemonic + " " + s.Operand);
                var effectOp2 = handlerFunc[handlerFunc.IndexOf(skillins) - 3];
                //var effectOp = (uint)handlerFunc[handlerFunc.IndexOf(skillins) + 4].Details.Displacement;
                //var effectOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("ecx")).Details.Displacement;
                //var effectOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("ecx") && i.Details.Displacement > 0).Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTSkillDamageNotify");
                cl.Value.OpList.First(c => c.structOff == skillOp).Rename = "SkillId";
                //cl.Value.OpList.First(c => c.structOff == effectOp).Rename = "SkillEffectId";
                cl.Value.OpList.First(c => c.dumpedClass == 4 && String.IsNullOrEmpty(c.Rename)).Rename = "SkillEffectId";
                cl.Value.OpList.First(c => c.dumpedClass == 8).Rename = "SourceId";

                var skillDmgEvents = Dumped[cl.Value.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                var skillDmgEvent = Dumped[skillDmgEvents.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                skillDmgEvent.Name = "SkillDamageEvent";

                //var parseSkillDmg = sigScan.FindPatterns("41 83 E6 07 B9 ? ? ? ? E8 ? ? ? ? 83 F8 01 0F", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var qq = GetFuncFromString("sys.squarehole.announce_new_registration");
                // var qq = GetFuncFromStringOffset("sys.squarehole.announce_new_registration", 0x1f0);

                var dmgParge = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)GetFuncFromStringOffset("sys.squarehole.announce_new_registration", 0x1f0) - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => !i.Mnemonic.StartsWith("ret"));
                var parseStart = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)GetFuncFromStringOffset("sys.squarehole.announce_new_registration", 0x1f0) - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).SkipWhile(o => o.Mnemonic != "cmp" || !o.Operand.StartsWith("dword") || !o.Operand.EndsWith("0")).ToList();
                var mod = (uint)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)GetFuncFromStringOffset("sys.squarehole.announce_new_registration", 0x1f0) - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).SkipWhile(o => o.Mnemonic != "movzx" || !o.Operand.StartsWith("ecx")).ToList()[0].Details.Displacement;
                var dmgs = dmgParge.Where(i => i.Mnemonic.StartsWith("mov") && i.Operand.StartsWith("rax") && skillDmgEvent.OpList.Count(o => o.structOff == (UInt64)i.Details.Displacement - 8 && o.dumpedClass == (UInt64)readPackedInt[0] - (UInt64)sigScan.Address) > 0).ToList();//.GroupBy(i => i.Details.Displacement).OrderBy(i => i.Count()).First().First().Details.Displacement;

                skillDmgEvent.OpList.First(c => c.structOff == (uint)dmgs[0].Details.Displacement - 8).Rename = "MaxHp";
                skillDmgEvent.OpList.First(c => c.structOff == (uint)dmgs[1].Details.Displacement - 8).Rename = "CurHp";
                skillDmgEvent.OpList.First(c => c.structOff == (uint)dmgs[2].Details.Displacement - 8).Rename = "Damage"; /* var d2 = dmgParge.Where(i => i.Mnemonic.StartsWith("mov") && i.Mnemonic.StartsWith("rax") && skillDmgEvent.OpList.Count(o => o.structOff == (UInt64)i.Details.Displacement - 8 && o.dumpedClass == (UInt64)readPackedInt[0] - (UInt64)sigScan.Address) > 0).GroupBy(i => i.Details.Displacement).OrderBy(i => i.Count());

                 //var mod = (uint)parseStart[0].Details.Displacement;
                 var damageInfos = 0;
                 for(var i = 0; i < parseStart.Count - 3; i++)
                 {
                     if (parseStart[i].Mnemonic == "mov" && parseStart[i + 2].Mnemonic == "mov" && parseStart[i + 4].Mnemonic == "mov" && parseStart[i].Operand.StartsWith("rax") && parseStart[i + 2].Operand.StartsWith("rax") && parseStart[i + 4].Operand.StartsWith("rax"))
                     {
                         skillDmgEvent.OpList.Last(c => c.structOff == (uint)parseStart[i].Details.Displacement - 8).Rename = "MaxHp";
                         skillDmgEvent.OpList.Last(c => c.structOff == (uint)parseStart[i + 2].Details.Displacement - 8).Rename = "CurHp";
                         skillDmgEvent.OpList.Last(c => c.structOff == (uint)parseStart[i + 4].Details.Displacement - 8).Rename = "Damage";
                         break;
                     }
                 }
                 var dmgs = parseStart.Where(o => o.Mnemonic == "mov" && o.Operand.StartsWith("rax")).ToList();*/
                //skillDmgEvent.OpList.Last(c => c.structOff == (uint)dmgs[6].Details.Displacement).Rename = "TargetId";
                skillDmgEvent.OpList.Last(c => c.dumpedClass == 8).Rename = "TargetId";
                skillDmgEvent.OpList.Last(c => c.structOff == mod).Rename = "Modifier";
            }
            if (nameToOpcode.ContainsKey("PKTSkillDamageAbnormalMoveNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTSkillDamageAbnormalMoveNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse();
                var skillOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r8d")).Details.Displacement;
                var effectOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("eax") && i.Details.Displacement > 0).Details.Displacement;
                //var effectOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rcx") && i.Details.Displacement > 0).Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTSkillDamageAbnormalMoveNotify");
                cl.Value.OpList.First(c => c.structOff == skillOp).Rename = "SkillId";
                cl.Value.OpList.First(c => c.structOff == effectOp).Rename = "SkillEffectId";
                cl.Value.OpList.First(c => c.dumpedClass == 8).Rename = "SourceId";
                var skillDmgEvents = Dumped[cl.Value.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                var skillDmgMoveEvents = Dumped[skillDmgEvents.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                skillDmgMoveEvents.Name = "SkillDamageMoveEvent";
            }
            if (nameToOpcode.ContainsKey("PKTNewProjectile"))
            {
                //var handler = sigScan.FindPatterns("4C 8B C0 BA " + BitConverter.ToString(BitConverter.GetBytes((UInt32)nameToOpcode["PKTNewProjectile"])).Replace("-", " ") + " 48 8B CF", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var leaPkt = (Int64)handler[0] - (Int64)sigScan.Address - 0x22;
                //var handlerOffset = leaPkt + BitConverter.ToInt32(sigScan.m_vDumpedRegion, (int)leaPkt + 3) + 7;
                //var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)handlerOffset).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse().First(i => i.Mnemonic == "call");
                //var callAddr = (Int64)UInt64.Parse(handlerFunc.Operand.Substring(2), System.Globalization.NumberStyles.HexNumber);
                //var parseProjFunc = (IntPtr)((int)handlerOffset + callAddr - 0x1000);

                var parseProjFunc = GetFuncFromStringOffset("ProjectileManager", 0x28 + 4 * 0x50);
                if (parseProjFunc == IntPtr.Zero) parseProjFunc = GetFuncFromStringOffset("QuestIds[{0}] QuestId[{1}]", -6 * 0x50);
                if (parseProjFunc == IntPtr.Zero) parseProjFunc = GetFuncFromStringOffset("Projectile CheckInvalidTargetPos_AimPos", 0xe0 + 3 * 0x50);

                //var idaaaa = 0x7FF788B70000 + ((UInt64)parseProjFunc);
                var idaaaa = 0x7FF7C8CB0000 + ((UInt64)parseProjFunc - (UInt64)sigScan.Address);
                //var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTNewProjectile"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret").Reverse().First(i => i.Mnemonic == "call");
                //var callAddr = (Int64)UInt64.Parse(handlerFunc.Operand.Substring(2), System.Globalization.NumberStyles.HexNumber);
                //var parseProjFunc = (IntPtr)((int)((UInt64)nameToHandler["PKTNewProjectile"] - (UInt64)sigScan.Address) + callAddr - 0x1000);
                var funcAsm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)parseProjFunc - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).ToList();
                //var ops = funcAsm.Where(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r") && (i.Operand.Contains("[rdx") || i.Operand.Contains("[rdx"))).ToList();
                var ops2 = funcAsm.Where(i => i.Mnemonic == "mov" && i.Operand.StartsWith("eax")).ToList();
                //var ownerId = (UInt64)ops.First(i => i.Operand.StartsWith("rdi")).Details.Displacement; // ops[0] works too
                var ops = new List<Gee.External.Capstone.X86.X86Instruction>();
                for (var i = 0; i < funcAsm.Count - 3; i++)
                {
                    if (!(funcAsm[i].Mnemonic == "jmp" || funcAsm[i].Mnemonic == "je") && funcAsm[i + 1].Mnemonic == "mov" && (funcAsm[i + 1].Operand.StartsWith("r") || funcAsm[i + 1].Operand.StartsWith("e")) && funcAsm[i + 1].Operand.Contains("[rdx"))
                    {
                        ops.Add(funcAsm[i + 1]);
                        if (ops.Count == 3)
                            break;
                    }
                }
                var ownerId = (UInt64)ops[0].Details.Displacement;// works too
                var projId = (UInt64)ops[1].Details.Displacement;
                var skillEffect = (UInt64)ops[2].Details.Displacement;

                var skillId = 0ul;
                for (var i = 0; i < funcAsm.Count - 2; i++)
                {
                    if (funcAsm[i].Mnemonic.Contains("call") && funcAsm[i + 2].Operand.StartsWith("eax"))
                    {
                        skillId = (UInt64)funcAsm[i + 2].Details.Displacement;
                        break;
                    }
                }
                //var skillId = (UInt64)funcAsm.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("eax") && i.Operand.Contains("eax, dword ptr [rsi")).Details.Displacement;
                var extras = funcAsm.Where(i => i.Mnemonic == "movzx" && i.Operand.StartsWith("eax")).ToList();
                var skillLevel = (UInt64)extras[1].Details.Displacement;
                var tripods = (UInt64)extras[2].Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTNewProjectile");
                var projInfo = Dumped[cl.Value.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                projInfo.Name = "ProjectileInfo";
                //cl.Value.OpList.First(o => o.dumpedClass == (UInt64)projInfo.ParseOffset).Rename = "Info";
                projInfo.OpList.First(c => c.structOff == projId).Rename = "ProjectileId";
                projInfo.OpList.First(c => c.structOff == ownerId).Rename = "OwnerId";
                projInfo.OpList.First(c => c.structOff == skillLevel).Rename = "SkillLevel";
                projInfo.OpList.First(c => c.structOff == tripods).Rename = "Tripods";
                projInfo.OpList.First(c => c.structOff == skillId).Rename = "SkillId";
                projInfo.OpList.First(c => c.structOff == skillEffect).Rename = "SkillEffect";
            }
            if (nameToOpcode.ContainsKey("PKTNewNpc"))
            {
                var newNpc = Dumped.FirstOrDefault(c => c.Value.Name == "PKTNewNpc");
                var npcStruct = Dumped[newNpc.Value.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                npcStruct.Name = "NpcStruct";
                //newNpc.Value.OpList.First(o => o.dumpedClass == (UInt64)npcStruct.ParseOffset).Name = "npc";
                var PKTNewNpcId = GetFuncFromStringOffset("RECV > PKTNewNpc\0", -4 * 0x50);
                //var PKTNewNpcNetId = GetFuncFromStringOffset("RECV > PKTNewNpc\0", -5 * 0x50);
                var PKTNewNpcNetId = GetFuncFromString("RECV > PKTNewNpc\0");
                var disasm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcId - (Int64)sigScan.Address + 0x1A)).Take(0x1000).ToArray());
                var npcId = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcNetId - (Int64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => !i.Mnemonic.StartsWith("ret")).Where(i => i.Mnemonic.StartsWith("mov") && npcStruct.OpList.Count(o => o.structOff == (UInt64)i.Details.Displacement && o.dumpedClass == 4) > 0).GroupBy(i => i.Details.Displacement).OrderBy(i => i.Count()).First().First().Details.Displacement;

                //var npcId = (UInt32)disasm.TakeWhile(i => !(i.Mnemonic == "mov" && i.Operand.StartsWith("edx"))).Reverse().ToArray()[0].Details.Displacement;
                //var parseProjFunc = GetFuncFromStringOffset("QuestIds[{0}] QuestId[{1}]", -0x1e0);
                //var PKTNewNpcId = sigScan.FindPatterns("49 8B 06 45 8B CC 4C", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize); // 48 8B 07 45 8B CC 4C
                //var PKTNewNpcNetId = sigScan.FindPatterns("44 88 44 24 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 6C 24 ? 48 81 EC ? ? ? ? 48 C7 45 ? ? ? ? ? 48 89 9C 24 ? ? ? ? 49 8B F1 4C 8B F2 4C 8B E9", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var npcId = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcId[0] - (Int64)sigScan.Address + 0x1A)).Take(0x10).ToArray())[0].Details.Displacement;
                // var netId = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcNetId - (Int64)sigScan.Address)).Take(0x1000).ToArray()).First(i=> i.Mnemonic == "mov" && i.Operand.StartsWith("r1")).Details.Displacement;
                var netId = (UInt16)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcNetId - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic.StartsWith("mov") && npcStruct.OpList.Count(o => o.structOff == (UInt64)i.Details.Displacement && o.dumpedClass == 8) > 0).GroupBy(i => i.Details.Displacement).First(i => i.Key > 0).First().Details.Displacement;
                //var netIdasdf = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcNetId - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i=> i.Mnemonic.StartsWith("mov") && npcStruct.OpList.Count(o=>o.structOff == (UInt64)i.Details.Displacement && o.dumpedClass == 8) > 0).GroupBy(i=>i.Details.Displacement).Where(i=>i.Count() == 6).First().First().Details.Displacement;
                //var netId = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewNpcNetId - (Int64)sigScan.Address)).Take(0x1000).ToArray()).First(i=> i.Mnemonic.StartsWith("mov") && npcStruct.OpList.Count(o=>o.structOff == (UInt64)i.Details.Displacement && o.dumpedClass == 8)>0).Details.Displacement;
                //if (npcStruct.OpList.Count(c => c.structOff == npcId) == 0)  npcId = (UInt32)disasm.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("esi")).Details.Displacement;
                var tests = npcStruct.OpList.Where(c => c.dumpedClass == 8);
                npcStruct.OpList.First(c => c.structOff == npcId).Rename = "NpcType";
                npcStruct.OpList.First(c => c.structOff == netId).Rename = "NpcId";
            }
            if (nameToOpcode.ContainsKey("PKTNewPC"))
            {
                var newPc = Dumped.FirstOrDefault(c => c.Value.Name == "PKTNewPC");
                var pcStruct = Dumped[newPc.Value.OpList.First(c => c.dumpedClass > 0x1000 && newPc.Value.OpList.Count(c2 => c2.If && c2.Name == c.Name) == 0).dumpedClass];
                pcStruct.Name = "PCStruct";
                pcStruct.OpList.Where(c => c.dumpedClass > 0x1000 && Dumped[c.dumpedClass].OpList.Count == 3).ToList().ForEach(o => Dumped[o.dumpedClass].Name = "SkillRunes");
                //newPc.Value.OpList.First(o => o.dumpedClass == (UInt64)pcStruct.ParseOffset).Name = "playerCharacter";
                var PKTNewPCId = GetFuncFromString("OtherPetPCDeserial");
                //var PKTNewPCId = sigScan.FindPatterns("C7 80 ? ? ? ? ? ? ? ? 48 8B 86 ? ? ? ? 48 89 44 24 ? 44 8B B6 ? ? ? ? 48 8B 07 48 8B CF FF 90", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var PKTNewPCId = sigScan.FindPatterns("C7 80 ? ? ? ? ? ? ? ? 48 8B 06 ? ? ? ? ? 44 8B B6 ? ? ? ? ", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var equippedItems = sigScan.FindPatterns("48 8D 8F ? ? ? ? 48 8D", PKTNewPCId[0], 0x500);
                var pcStructParse = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewPCId - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                //var PKTNewPCName = sigScan.FindPatterns("48 8D B1 ? ? ? ? 48 8B D6", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var PKTNewPCName = sigScan.FindPatterns("48 8D B1 ? ? ? ? 48 ? ? ? ? ? ? ? ? ? E8 ? ? ? ? 48 8D 8F ? ? ? ? 48 8B D6 E8 ? ? ? ?", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var PKTNewPCName = sigScan.FindPatterns("FF 15 ? ? ? ? 48 85 C0 74 04 66 44 89 38 49 8D 95", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //if (PKTNewPCName.Count == 0) PKTNewPCName = sigScan.FindPatterns("FF 15 ? ? ? ? 48 85 C0 74 04 66 44 89 38 49 8B D5", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var PKTNewPCClass = sigScan.FindPatterns("FF 50 18 48 8B 03 0F B7 97 ? ? ? ? 48 8B CB FF 50 20 48 8D 97", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //foreach(var s in new String[2] { "FF 50 18 48 8B 03 0F B7 97 ? ? ? ? 48 8B", "FF 50 18 48 8B 03 0F B7 57" })

                var parserAddr = sigScan.FindPatterns("48 8B C4 57 41 54 41 55 41 56 41 57 48 83 EC 60 48 C7 40 ? ? ? ? ? 48 89 58 10 48 89 68 18 48 89 70 20 49 8B F8 48 8B E9 4C 8B 1A 8B 99", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                var parserPsuedo = GetPsuedocode(parserAddr[0]);
                foreach (var s in new String[] { })
                {
                    //var PKTNewPCClass = sigScan.FindPatterns("FF 50 18 48 8B 03 0F B7 97 ? ? ? ? 48 8B", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    //var PKTNewPCClass = sigScan.FindPatterns("FF 50 18 48 8B 03 0F B7 57", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);

                    //var qq = GetPsuedocode(nameToHandler["PKTInitEnv"]);
                    var PKTNewPCClass = sigScan.FindPatterns(s, process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    var found = false;
                    foreach (var pcclass in PKTNewPCClass)
                    {
                        //var playerId2 = BitConverter.ToUInt32(disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewPCId - (Int64)sigScan.Address + 10)).Take(0x10).ToArray())[0].Bytes, 3);
                        var playerIdParser = pcStructParse.SkipWhile(i => !(i.Mnemonic == "mov" && i.Operand.StartsWith("dword")));
                        var playerId = (uint)playerIdParser.ToArray()[1].Details.Displacement;
                        pcStruct.OpList.First(c => c.structOff == playerId).Rename = "PlayerId";
                        var PKTNewPCName = GetFuncFromStringOffset("OtherPetSummonChange", 0x30);
                        var nameParse = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)PKTNewPCName - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                        for (var i = 0; i < nameParse.Length; i++)
                        {
                            if (nameParse[i].Mnemonic == "lea" && nameParse[i].Operand.StartsWith("rcx") && !nameParse[i].Operand.Contains("rbp") && nameParse[i + 1].Mnemonic == "call" && pcStruct.OpList.Count(pc => pc.structOff == (ulong)nameParse[i].Details.Displacement) == 1)
                            {
                                var name = (UInt32)nameParse[i].Details.Displacement;
                                pcStruct.OpList.First(c => c.structOff == name).Rename = "Name";
                                break;
                            }
                        }
                        if (pcStruct.OpList.Count(c => c.Rename == "Name") == 0)
                        {
                            if (pcStruct.OpList.Count(c => c.dumpedClass == (UInt64)readString[0] - (UInt64)sigScan.Address) == 1)
                                pcStruct.OpList.First(c => c.dumpedClass == (UInt64)readString[0] - (UInt64)sigScan.Address).Rename = "Name";
                            else
                                throw new Exception("");
                        }
                        //pcStruct.OpList.First(c => c.dumpedClass == (UInt64)readString[0] - (UInt64)sigScan.Address && String.IsNullOrEmpty(c.Rename)).Rename = "Guild";
                        var important = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)pcclass - (Int64)sigScan.Address - 10)).Take(0x1000).ToArray());
                        var partyIdAsm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)pcclass - (Int64)sigScan.Address - 10 - 0xe)).Take(0x1000).ToArray());
                        var classId = (uint)important[0].Details.Displacement;
                        var partyId = (uint)partyIdAsm[0].Details.Displacement;
                        var level = (uint)important[4].Details.Displacement;
                        var gearLevel = (uint)important.Where(o => o.Mnemonic.StartsWith("movss") && o.Operand.StartsWith("xmm1")).ToList()[1].Details.Displacement;
                        try
                        {
                            pcStruct.OpList.First(c => c.structOff == classId).Rename = "ClassId";
                            pcStruct.OpList.First(c => c.structOff == level).Rename = "Level";
                            pcStruct.OpList.First(c => c.structOff == gearLevel).Rename = "GearLevel";
                            pcStruct.OpList.First(c => c.structOff == partyId).Rename = "PartyId";
                            found = true;
                            break;
                        }
                        catch
                        {

                        }
                    }
                    if (found) break;
                }

                /*for (var i = 0; i < pcStructParse.Length - 8; i++)
                {
                    //if (pcStructParse[i].Mnemonic == "mov" && pcStructParse[i+1].Mnemonic == "lea" && pcStructParse[i+2].Mnemonic == "mov" && pcStructParse[i+3].Mnemonic == "xor" && pcStructParse[i+4].Mnemonic == "mov" && pcStructParse[i+5].Mnemonic == "mov" && pcStructParse[i+6].Mnemonic == "call")
                    if (pcStructParse[i].Mnemonic == "mov" && pcStructParse[i+1].Mnemonic == "lea" && pcStructParse[i+2].Mnemonic == "mov" && pcStructParse[i+3].Mnemonic == "xor" && pcStructParse[i+4].Mnemonic == "mov" && pcStructParse[i+5].Mnemonic == "mov")
                    {
                        var itemInfo = (uint)pcStructParse[i + 1].Details.Displacement;
                        pcStruct.OpList.First(c => c.structOff == itemInfo).Rename = "EquippedItems";
                        var itemInfoClass = Dumped[Dumped[pcStruct.OpList.First(c => c.structOff == itemInfo).dumpedClass].OpList[1].dumpedClass];
                        itemInfoClass.Name = "ItemInfo";
                        //var itemInfoParse = sigScan.FindPatterns("48 89 5C 24 ? 48 89 7C 24 ? 0F B7 02 33 FF 4C 8B DA 66 89 01 48 8B D9 44 0F B7 D7 66 3B 3A 0F 8D ? ? ? ? 66 66 66 0F 1F 84 00 ? ? ? ? 4D 0F BF C2 49 C1 E0 06 4B 8D 04 18 4D 8D 0C 18 44 0F B7 C7", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                        //var itemInfoParse = sigScan.FindPatterns("0F B7 48 2E 66 41 89 49 ? 0F B6 48 31 41 88 49 31 84 C9 74 08 0F B6 48 30 41 88 49 30", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                        //var itemInfoParse = sigScan.FindPatterns("49 C1 E0 06 4B 8D 04 18 4D 8D 0C 18", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                        var itemInfoParse = sigScan.FindPatterns("? C1 E0 06 ? 8D 04 18 ? 8D 0C 18", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                        //var itemInfoOff = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)itemInfoParse[0] - (Int64)sigScan.Address)).Take(0x100).ToArray()).SkipWhile(i=>i.Mnemonic != "jl").TakeWhile(i=>i.Mnemonic != "ret").Last(i=>i.Mnemonic == "movzx").Details.Displacement;
                        var itemInfoOff =0x3eu;
                        //var itemInfoOff = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)itemInfoParse[0] - (Int64)sigScan.Address)).Take(0x10).ToArray())[0].Details.Displacement;
                        //var op = itemInfoClass.OpList.First(c => c.structOff == itemInfoOff - 2);
                        var op = itemInfoClass.OpList.First();
                        if (op.dumpedClass != 2) op = itemInfoClass.OpList.First(c => c.dumpedClass == 2);
                        op.Rename = "Level";
                        break;
                    }
                }*/
                {
                    var possibleStructs = pcStruct.OpList.Where(p => p.dumpedClass > 0x2000 && Dumped[p.dumpedClass].OpList.Count == 2).ToList();
                    var tt = possibleStructs.Select(l => Dumped[l.dumpedClass]).ToList();
                    var itemInfoClassAddrs = possibleStructs.Where(p => possibleStructs.Count(p2 => Dumped[p2.dumpedClass].OpList[1].dumpedClass == Dumped[p.dumpedClass].OpList[1].dumpedClass) == 2);
                    var itemInfoClassAddr = Dumped[itemInfoClassAddrs.First().dumpedClass].OpList[1].dumpedClass;
                    //var itemInfoClassAddr = pcStruct.OpList.First(p => p.dumpedClass > 0x1000 && p.dumpedClass != Dumped.First().Key && pcStruct.OpList.Count(p2 => p2.dumpedClass == p.dumpedClass) == 2).dumpedClass;
                    var itemInfoClass = Dumped[itemInfoClassAddr];
                    // var itemInfoClass = Dumped[Dumped[pcStruct.OpList.First(c => c.structOff == itemInfo).dumpedClass].OpList[1].dumpedClass];
                    itemInfoClass.Name = "ItemInfo";
                    //var itemInfoParse = sigScan.FindPatterns("48 89 5C 24 ? 48 89 7C 24 ? 0F B7 02 33 FF 4C 8B DA 66 89 01 48 8B D9 44 0F B7 D7 66 3B 3A 0F 8D ? ? ? ? 66 66 66 0F 1F 84 00 ? ? ? ? 4D 0F BF C2 49 C1 E0 06 4B 8D 04 18 4D 8D 0C 18 44 0F B7 C7", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    //var itemInfoParse = sigScan.FindPatterns("0F B7 48 2E 66 41 89 49 ? 0F B6 48 31 41 88 49 31 84 C9 74 08 0F B6 48 30 41 88 49 30", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    //var itemInfoParse = sigScan.FindPatterns("49 C1 E0 06 4B 8D 04 18 4D 8D 0C 18", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    //var itemInfoParse = sigScan.FindPatterns("? C1 E0 06 ? 8D 04 18 ? 8D 0C 18", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    //var itemInfoOff = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)itemInfoParse[0] - (Int64)sigScan.Address)).Take(0x100).ToArray()).SkipWhile(i=>i.Mnemonic != "jl").TakeWhile(i=>i.Mnemonic != "ret").Last(i=>i.Mnemonic == "movzx").Details.Displacement;
                    //var itemInfoOff = 0x3eu;
                    //var itemInfoOff = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)itemInfoParse[0] - (Int64)sigScan.Address)).Take(0x10).ToArray())[0].Details.Displacement;
                    //var op = itemInfoClass.OpList.First(c => c.structOff == itemInfoOff - 2);
                    var op = itemInfoClass.OpList.First();
                    if (op.dumpedClass != 2) op = itemInfoClass.OpList.First(c => c.dumpedClass == 2);
                    op.Rename = "Level";
                    pcStruct.OpList.First(c => c.dumpedClass == itemInfoClassAddrs.First().dumpedClass).Rename = "EquippedItems";
                }
                /*
                for (var i = 0; i < pcStructParse.Length - 8; i++)
                {
                    if (pcStructParse[i].Mnemonic == "mov" && pcStructParse[i+1].Mnemonic == "mov" && pcStructParse[i+2].Mnemonic == "xor" && pcStructParse[i+3].Mnemonic == "mov" && pcStructParse[i+4].Mnemonic == "mov" && pcStructParse[i+5].Mnemonic == "mov" && pcStructParse[i+6].Mnemonic == "call")
                    {
                        var itemInfo = (uint)pcStructParse[i + 1].Details.Displacement;
                        pcStruct.OpList.First(c => c.structOff == itemInfo).Rename = "EquippedItems";
                        
                        break;
                    }
                }*/
                //Dumped[pcStruct.OpList.First(c => c.dumpedClass > 0x1000 && Dumped[c.dumpedClass].OpList.Count == 3).dumpedClass].Name = "SkillRunes";
                //var itemInfo = Dumped[pcStruct.OpList.First(o => (o.dumpedClass != ((UInt64)readString[0] - (UInt64)sigScan.Address)) && o.dumpedClass > 0x1000 && pcStruct.OpList.Count(oo => oo.dumpedClass == o.dumpedClass) == 2).dumpedClass];
                //itemInfo.Name = "Equipment";
            }
            if (nameToOpcode.ContainsKey("PKTStatChangeOriginNotify"))
            {
                var structs = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)nameToHandler["PKTStatChangeOriginNotify"] - (Int64)sigScan.Address)).Take(0x1000).ToArray()).SkipWhile(i => i.Mnemonic != "movzx").Skip(1).SkipWhile(i => i.Mnemonic != "movzx").Where(i => i.Mnemonic == "lea" && i.Operand.StartsWith("r")).ToList();
                var id = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)nameToHandler["PKTStatChangeOriginNotify"] - (Int64)sigScan.Address)).Take(0x1000).ToArray()).SkipWhile(i => i.Mnemonic != "movzx").Skip(1).SkipWhile(i => i.Mnemonic != "movzx").Where(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdx")).ToList();

                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTStatChangeOriginNotify");
                var statPairList = cl.Value.OpList.First(c => c.structOff == (uint)structs[0].Details.Displacement);
                statPairList.Rename = "StatPairList";
                cl.Value.OpList.First(c => c.structOff != statPairList.structOff && c.dumpedClass == statPairList.dumpedClass).Rename = "StatPairChangedList";
                //cl.Value.OpList.First(c => c.structOff == (uint)structs[1].Details.Displacement).Rename = "StatPairChangedList";
                cl.Value.OpList.First(c => c.structOff == (uint)id[0].Details.Displacement).Rename = "ObjectId";
                var c = Dumped[cl.Value.OpList.First(c => c.dumpedClass > 0x1000).dumpedClass];
                c.Name = "StatPair";
                c.OpList.First(c => c.dumpedClass > 0x1000).Rename = "Value";
                c.OpList.First(c => c.dumpedClass == 1).Rename = "StatType";
            }
            if (nameToOpcode.ContainsKey("PKTStatusEffectAddNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTStatusEffectAddNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                var objectId = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.Contains("[rdx")).Details.Displacement;
                var effectOp = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("ecx")).Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTStatusEffectAddNotify");
                cl.Value.OpList.First(c => c.structOff == objectId).Rename = "ObjectId";
                cl.Value.OpList.First(c => c.dumpedClass == 1).Rename = "New";
                var buffClassField = cl.Value.OpList.First(c => c.dumpedClass > 0x1000);
                //var hasBuffField = cl.Value.OpList.First(c=>c.Name)
                var c = Dumped[buffClassField.dumpedClass];
                c.Name = "StatusEffectData";
                var buffClassFieldstructOff = buffClassField.structOff + 0;// 0x18;// 0x18; // hack
                //var buffClassFieldstructOff = buffClassField.structOff + 0x18;// 0x18; // hack
                /*var callSubParse = handlerFunc.SkipWhile(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rcx, rdi")).ToList();
                var callAddr = (Int64)UInt64.Parse(callSubParse[1].Operand.Substring(2), System.Globalization.NumberStyles.HexNumber);
                var parseProjFunc = (IntPtr)((int)handlerOffset + callAddr - 0x1000);
                var projId = (UInt64)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)parseProjFunc).Take(0x1000).ToArray()).First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r15")).Details.Displacement;*/

                var buffClass = statusEffectParse;// sigScan.FindPatterns("83 F8 01 0F 85 ? ? ? ? 48 8D 0D ? ? ? ? E8 ? ? ? ? F2 0F 5C F0", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                if (region == Region.Steam)
                {
                    var buffClasss = sigScan.FindPatterns("83 F8 01 0F 85 ? ? ? ? 48 8D 0D ? ? ? ? E8 ? ? ? ? F2 0F 5C F0", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                    var buffClass2 = buffClasss[0];
                    buffClass = buffClasss[0];
                }

                var disasm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                // steam
                var buffOffsets64 = disasm.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Size == 8 && i.Details.Operands[0].Register.Name.StartsWith("r") && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name.StartsWith("r") && !i.Details.Operands[1].Memory.Base.Name.StartsWith("rip")).ToList();
                if (region == Region.Korea) buffOffsets64 = disasm.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Size == 8 && i.Details.Operands[0].Register.Name.StartsWith("r") && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name.StartsWith("r") && i.Details.Operands[1].Memory.Base.Name.StartsWith("rsi")).ToList();

                var buffOffsets = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic == "mov" && !i.Operand.StartsWith("byte ptr") && !i.Operand.StartsWith("word ptr") && !i.Operand.StartsWith("qword ptr")).ToList();
                //var buffOffsets64 = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass[0] - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic == "mov" && i.Details.Operands[0].Size == 8 && i.Details.Displacement > 0 && !i.Operand.StartsWith("byte ptr") && !i.Operand.StartsWith("word ptr") && !i.Operand.StartsWith("qword ptr")).ToList();
                var buffOffsets32 = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic == "mov" && i.Details.Operands[0].Size == 4 && i.Details.Displacement > 0 && !i.Operand.StartsWith("byte ptr") && !i.Operand.StartsWith("word ptr") && !i.Operand.StartsWith("qword ptr") && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register).ToList();
                var buffOffsets8 = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic == "movzx" && i.Details.Displacement > 0 && !i.Operand.StartsWith("byte ptr") && !i.Operand.StartsWith("word ptr") && !i.Operand.StartsWith("qword ptr")).ToList();
                var buffOffsets2 = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)buffClass - (Int64)sigScan.Address)).Take(0x1000).ToArray()).SkipWhile(i => !i.Mnemonic.StartsWith("cmp") && !i.Operand.StartsWith("byte ptr") && !i.Operand.StartsWith("word ptr") && !i.Operand.StartsWith("qword ptr")).First();
                //c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets64[0].Details.Displacement).Rename = "InstanceId";
                //c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets64[0].Details.Displacement).Rename = "InstanceId";
                c.OpList.First(c => c.dumpedClass == 8 && (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets64.First(b => b.Details.Displacement == (uint)(buffClassFieldstructOff + c.structOff))?.Details?.Displacement).Rename = "InstanceId";
                c.OpList.First(c => c.Rename != "InstanceId" && c.dumpedClass == 8 && (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets64.First(b => b.Details.Displacement == (uint)(buffClassFieldstructOff + c.structOff))?.Details?.Displacement).Rename = "SourceId";
                //c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets64[1].Details.Displacement).Rename = "SourceId";
                var valueField = c.OpList.First(c => c.dumpedClass == 0x10);
                c.OpList.First(c => c.structOff == valueField.structOff + 16).Rename = "hasValue";
                valueField.Rename = "Value";
                //c.OpList.First(c => (uint)(buffClassField.structOff + c.structOff) == buffOffsets[2].Details.Displacement).Name = "Level";
                //c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets[3].Details.Displacement).Rename = "StartTime";
                c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets32[0].Details.Displacement).Rename = "EffectInstanceId";
                c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets32[1].Details.Displacement).Rename = "StatusEffectId";
                c.OpList.First(c => (uint)(buffClassFieldstructOff + c.structOff) == buffOffsets8[0].Details.Displacement).Rename = "SkillLevel";

                // c.OpList.First(c => c.structOff == (uint)((int)buffClassField.structOff + buffOffsets[7].Details.Displacement)).Name = "Level";
                //c.OpList.First(c => c.structOff == (uint)((int)buffClassField.structOff + buffOffsets2.Details.Displacement)).Name = "BuffId";
            }
            if (nameToOpcode.ContainsKey("PKTCounterAttackNotify"))
            {
                var idaAddr = (UInt64)nameToHandler["PKTCounterAttackNotify"] - (UInt64)sigScan.Address;
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTCounterAttackNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                var sourceTarget = handlerFunc.SkipWhile(i => !(i.Mnemonic == "mov" && i.Operand.StartsWith("rbx,"))).Take(2).ToArray();
                var objRegs = handlerFunc.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Size == 8 && i.Details.Operands[0].Register.Name.StartsWith("r") && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name.StartsWith("r") && !i.Details.Operands[1].Memory.Base.Name.StartsWith("rip")).ToList();

                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTCounterAttackNotify");
                var byteArray = cl.Value.OpList.First();

                var source = objRegs.First(o => o.Details.Operands[0].Size == 8 && (ulong)o.Details.Displacement >= byteArray.structOff && (ulong)o.Details.Displacement < (byteArray.structOff + byteArray.dumpedClass - 8)).Details.Displacement;
                var target = objRegs.First(o => o.Details.Displacement != source && o.Details.Operands[0].Size == 8 && (ulong)o.Details.Displacement >= byteArray.structOff && (ulong)o.Details.Displacement <= (byteArray.structOff + byteArray.dumpedClass - 8)).Details.Displacement;
                cl.Value.OpList = SplitByteArray(new List<PartialByte> { new PartialByte { name = "TargetId", size = 8, offset = (uint)target }, new PartialByte { name = "SourceId", size = 8, offset = (uint)source } }, (uint)byteArray.structOff, (uint)byteArray.dumpedClass);
            }
            if (nameToOpcode.ContainsKey("PKTSkillStartNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTSkillStartNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                var skillId = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("ecx, dword ptr [rbx +")).Details.Displacement;
                var source = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdi")).Details.Displacement;
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTSkillStartNotify");
                cl.Value.OpList.First(c => c.structOff == source).Rename = "SourceId";
                cl.Value.OpList.First(c => c.structOff == skillId).Rename = "SkillId";
            }
            if (nameToOpcode.ContainsKey("PKTSkillStageNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTSkillStageNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                var source = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r14")).Details.Displacement;
                var sources = handlerFunc.Where(i => i.Mnemonic == "mov" && i.Operand.StartsWith("eax")).ToList();
                var skillId = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("eax") && i.Operand.Contains("rsi")).Details.Displacement;
                var stage = (uint)handlerFunc.First(i => i.Mnemonic == "movsx" && i.Operand.StartsWith("eax") && i.Operand.Contains("rsi")).Details.Displacement;

                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTSkillStageNotify");
                var byteArray = cl.Value.OpList.First();
                cl.Value.OpList = SplitByteArray(new List<PartialByte> { new PartialByte { name = "SourceId", size = 8, offset = source }, new PartialByte { name = "SkillId", size = 4, offset = skillId }, new PartialByte { name = "Stage", size = 1, offset = stage } }, (uint)byteArray.structOff, (uint)byteArray.dumpedClass);
            }
            if (nameToOpcode.ContainsKey("PKTDeathNotify"))
            {
                var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((UInt64)nameToHandler["PKTDeathNotify"] - (UInt64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                //var handler = sigScan.FindPatterns("4C 8B C0 BA " + BitConverter.ToString(BitConverter.GetBytes((UInt32)nameToOpcode["PKTDeathNotify"])).Replace("-", " ") + " 48 8B CF", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var handler = GetFuncStart(sigScan.FindPatterns("48 8B 46 ? 48 3B 46 ? 74 05 48 85 C0 75 32 F3 0F 10 15 ? ? ? ? F3 0F 10 45 ? F3 0F 59 C2 F3 0F 11 45", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize)[0]);
                //var handlerFunc = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)handler - (Int64)sigScan.Address)).Take(0x1000).ToArray()).TakeWhile(i => i.Mnemonic != "ret");
                var target = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rbx") && i.Operand.Contains("word")).Details.Displacement;
                var source = (uint)handlerFunc.First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rax") && i.Operand.Contains("rsi")).Details.Displacement;

                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTDeathNotify");
                cl.Value.OpList.First(c => c.structOff == target).Rename = "TargetId";
                cl.Value.OpList.First(c => c.structOff == source).Rename = "SourceId";
            }
            if (nameToOpcode.ContainsKey("PKTNewNpcSummon"))
            {
                //var summonOwner = sigScan.FindPatterns("81 3D ? ? ? ? ? ? ? ? 0F 8E ? ? ? ? 48 8B 0D ? ? ? ? 48 85 C9 41 0F 94 C6 41 F7 DE 49 63 C6 48 23 C6 48 0B C1 F7 80", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                //var summonOwner = sigScan.FindPatterns("FF 15 ? ? ? ? 41 39 ? ? ? ? ? 0F 84 ? ? ? ? 49 8B", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
                var summonOwner = nameToHandler["PKTNewNpcSummon"];// GetFuncFromString("ScouterDroneNpcId");

                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTNewNpcSummon");
                var byteArray = cl.Value.OpList.First(i => i.dumpedClass > 1 && i.dumpedClass < 0x100);
                var disasm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)summonOwner - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                var objRegs = disasm.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Register.Name.StartsWith("r") && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name.StartsWith("r") && !i.Details.Operands[1].Memory.Base.Name.StartsWith("rip")).ToList();

                //var summon = (uint)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)summonOwner - (Int64)sigScan.Address)).Take(0x1000).ToArray()).First(i => i.Mnemonic == "mov" && (UInt64)i.Details.Displacement >= byteArray.structOff && (UInt64)i.Details.Displacement < byteArray.structOff + byteArray.dumpedClass).Details.Displacement;
                var summons = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)summonOwner - (Int64)sigScan.Address)).Take(0x1000).ToArray()).Where(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdx") && (Int64)i.Details.Displacement >= 0);
                //var summon = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)summonOwner - (Int64)sigScan.Address)).Take(0x1000).ToArray()).First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("rdx") && (Int64)i.Details.Displacement >= 0 && (UInt64)i.Details.Displacement < byteArray.dumpedClass).Details.Displacement;
                //var summon = (UInt32)disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)summonOwner - (Int64)sigScan.Address)).Take(0x1000).ToArray()).First(i => i.Mnemonic == "mov" && i.Operand.StartsWith("r") && (Int64)i.Details.Displacement >= (Int64)byteArray.structOff && (UInt64)i.Details.Displacement < byteArray.structOff + byteArray.dumpedClass).Details.Displacement;
                var summon = (uint)byteArray.structOff + (uint)objRegs[0].Details.Displacement;
                var newOps = cl.Value.OpList.TakeWhile(i => i != byteArray).ToList();
                newOps.AddRange(SplitByteArray(new List<PartialByte> { new PartialByte { name = "OwnerId", size = 8, offset = summon - 0x18 } }, (uint)byteArray.structOff, (uint)byteArray.dumpedClass));
                newOps.AddRange(cl.Value.OpList.SkipWhile(i => i != byteArray).Skip(1));
                cl.Value.OpList = newOps;
            }
            if (nameToOpcode.ContainsKey("PKTTriggerStartNotify"))
            {
                var handler = nameToHandler["PKTTriggerStartNotify"];
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTTriggerStartNotify");
                var disasm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)handler - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                //var objReg = disasm.FirstOrDefault(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[1].Register.Name == "rdx")?.Details.Operands[0].Register.Name;
                var objReg = disasm.FirstOrDefault(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[1].Register.Name == "rdx");//?.Details.Operands[0].Register.Name;
                var regName = objReg == null ? "rdx" : objReg.Details.Operands[0].Register.Name;
                //var objReg2 = disasm.First(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Register.Name == "ecx" && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base.Name == regName);
                var objRegs = disasm.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name == regName).ToList();

                cl.Value.OpList.First(c => c.structOff == (uint)objRegs[1].Details.Displacement).Rename = "TriggerUnitIndex"; // a9, 9d [0]
                cl.Value.OpList.First(c => c.structOff == (uint)objRegs[2].Details.Displacement).Rename = "ActorId"; // ad
                cl.Value.OpList.First(c => c.structOff == (uint)objRegs[3].Details.Displacement).Rename = "Signal"; // 13f
            }
            if (nameToOpcode.ContainsKey("PKTStatusEffectRemoveNotify"))
            {
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTStatusEffectRemoveNotify");
                cl.Value.OpList.First(c => c.dumpedClass > 0x2000).Rename = "InstanceIds";
                cl.Value.OpList.First(c => c.dumpedClass == 1).Rename = "Reason";
                cl.Value.OpList.First(c => c.dumpedClass == 8).Rename = "ObjectId";
            }
            if (nameToOpcode.ContainsKey("PKTPartyStatusEffectAddNotify"))
            {
                var handler = nameToHandler["PKTPartyStatusEffectAddNotify"];
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTPartyStatusEffectAddNotify");
                var disasm = disassembler.Disassemble(sigScan.m_vDumpedRegion.Skip((int)((Int64)handler - (Int64)sigScan.Address)).Take(0x1000).ToArray());
                var objRegs = disasm.Where(i => i.Mnemonic == "mov" && i.Details.Operands.Length == 2 && i.Details.Operands[0].Type == Gee.External.Capstone.X86.X86OperandType.Register && i.Details.Operands[0].Register.Name.StartsWith("r") && i.Details.Operands[1].Type == Gee.External.Capstone.X86.X86OperandType.Memory && i.Details.Operands[1].Memory.Base != null && i.Details.Operands[1].Memory.Base.Name.StartsWith("r") && !i.Details.Operands[1].Memory.Base.Name.StartsWith("rip")).ToList();

                cl.Value.OpList.First(c => c.dumpedClass == 8 && c.structOff == (uint)objRegs[0].Details.Displacement).Rename = "PartyId";
                cl.Value.OpList.Last(c => c.dumpedClass == 8 && String.IsNullOrEmpty(c.Rename)).Rename = "PlayerIdOnRefresh";
            }
            if (nameToOpcode.ContainsKey("PKTPartyStatusEffectRemoveNotify"))
            {
                var cl = Dumped.FirstOrDefault(c => c.Value.Name == "PKTPartyStatusEffectRemoveNotify");
                if (cl.Key > 0)
                {
                    cl.Value.OpList.First(c => c.dumpedClass == 8).Rename = "PartyId";
                    cl.Value.OpList.First(c => c.dumpedClass > 8).Rename = "StatusEffectIds";

                }
            }

            foreach (var cl in Dumped)
            {
                if ((int)cl.Value.ParseOffset > 0)
                {
                    if (cl.Value.OnlyReadsList) continue;
                    if (cl.Value.Name.Contains("_"))
                    {
                        GetReadInfo((UInt64)cl.Value.ParseOffset, out _, out _, out _, out UInt64 size, out bool customName);
                        cl.Value.Name = "sub" + cl.Value.Name.Substring(0, cl.Value.Name.IndexOf("_")) + size;
                    }
                }
            }
            foreach (var cl in Dumped)
            {
                if ((int)cl.Value.ParseOffset > 0)
                {
                    if (cl.Value.OnlyReadsList) continue;
                    DumpClass(cl.Value, region, out String baseClass, out String regionClass);
                    if (savePath.Contains("Headlost"))
                    {
                        File.WriteAllText(savePath + @"Packets\Steam\" + cl.Value.Name + ".cs", baseClass);
                    }
                    else
                    {
                        File.WriteAllText(savePath + @"Packets\Base\" + cl.Value.Name + ".cs", baseClass);
                        File.WriteAllText(savePath + @"Packets\" + region + @"\" + cl.Value.Name + ".cs", regionClass);
                    }
                }
            }

            aes = "";
            blowfish = "";


            var aesSigs = sigScan.FindPatterns("4C 8D 05 ? ? ? ? 41 8D 51 41 48 8D 0D ? ? ? ? FF 15 ? ? ? ? 48 8D 0D ? ? ? ? E8 ? ? ? ? 84 C0 74 78 45 33 D2 4C 39 15 ? ? ? ? 76 60", process.MainModule.BaseAddress, process.MainModule.ModuleMemorySize);
            foreach (var aesSig in aesSigs)
            {
                var lea = new Byte[7];
                ReadProcessMemory(hProcess, aesSig, lea, lea.Length, out _);
                var stringOffset = aesSig + BitConverter.ToInt32(lea, 3) + lea.Length;
                var stringBytes = new Byte[0x100];
                ReadProcessMemory(hProcess, stringOffset, stringBytes, stringBytes.Length, out _);
                var unicodeBytes = new UInt16[0x80];
                Buffer.BlockCopy(stringBytes, 0, unicodeBytes, 0, stringBytes.Length);
                var lookingForVictory = Encoding.UTF8.GetString(unicodeBytes.TakeWhile(b => b != 0).Select(b => (Byte)b).ToArray());
                if (lookingForVictory.Contains("VictoryCrestLearnType"))
                {
                    var cmp = new Byte[7];
                    ReadProcessMemory(hProcess, aesSig + 0x2b, cmp, cmp.Length, out _);
                    var aesOffset = aesSig + 0x2b + BitConverter.ToInt32(cmp, 3) + cmp.Length + 8;
                    var aesBytes = new Byte[0x10];
                    ReadProcessMemory(hProcess, aesOffset, aesBytes, aesBytes.Length, out _);
                    aes = BitConverter.ToString(aesBytes).Replace("-", "");
                    break;
                }

            }

            NtResumeProcess(hProcess);
            CloseHandle(hProcess);
            process.Kill();
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }
        [DllImport("kernel32")] static extern IntPtr OpenProcess(Int32 dwDesiredAccess, Boolean bInheritHandle, Int32 dwProcessId);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, UInt32 dwSize, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport("ntdll")] static extern Int32 NtCreateSection(out IntPtr sectionHandle, Int32 DesiredAccess, IntPtr objectAttributes, ref Int32 MaximumSize, UInt32 SectionPageProtection, Int32 AllocationAttributes, IntPtr fileHandle);
        [DllImport("ntdll")] static extern void NtResumeProcess(IntPtr processHandle);
        [DllImport("ntdll")] static extern void NtSuspendProcess(IntPtr processHandle);
        [DllImport("ntdll")] static extern Int32 NtUnmapViewOfSection(IntPtr processHandle, IntPtr baseAddress);
        [DllImport("ntdll")] static extern Int32 NtMapViewOfSection(IntPtr sectionHandle, IntPtr processHandle, ref IntPtr baseAddress, UIntPtr ZeroBits, Int32 commitSize, out Int32 SectionOffset, ref Int32 ViewSize, UInt32 InheritDisposition, Int32 allocationType, UInt32 win32Protect);

        [DllImport("kernel32")] static extern bool CloseHandle(IntPtr hObject);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, Int32 flAllocationType, UInt32 flProtect);
        [DllImport("kernel32")] static extern IntPtr VirtualQueryEx(IntPtr handle, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION64 lpBuffer, UInt32 dwLength);
        [DllImport("kernel32")] static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

        [DllImport("kernel32")] static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, Byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesRead);
        [DllImport("kernel32")] static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, Byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION64
        {
            public IntPtr BaseAddress;
            public ulong AllocationBase;
            public int AllocationProtect;
            public int __alignment1;
            public ulong RegionSize;
            public int State;
            public int Protect;
            public int Type;
            public int __alignment2;
        }
    }
}

```

`LoaDumper/Program.cs`:

```cs
using System.Net;
using LoaDumper;


var basePath = @"C:\Users\" + Environment.UserName + @"\Documents\GitHub\LostArkLogger\LostArkLogger\";
var steam = Region.Korea;
steam = Region.Steam;
HardCodes(steam, out String installDir, out String blowfish, out String aes);
DumpInfo(basePath, steam, installDir, blowfish, aes);

static void DumpInfo(String basePath, Region region, String installDir, String blowfish, String aes)
{
    File.WriteAllText(basePath + @"Packets\OpCodes_" + region + ".cs", PacketDumper.Dump(basePath, installDir, region, out String blowfish2, out String aes2));
    var regionPad = region == Region.Korea ? "kr" : "";
    File.WriteAllBytes(basePath + @"Resources\" + "oodle_state_" + region + ".bin", ObjectSerialize.Compress(ExtractLPK.Dump(installDir + @"EFGame\data1" + regionPad + ".lpk", blowfish, aes, "oodle_state.bin")));
    File.WriteAllBytes(basePath + @"Resources\" + "xor_" + region + ".bin", ObjectSerialize.Compress(Seed.GetXorTable(region.ToString())));
    ExtractLPK.ExtractDb(basePath, region, installDir, blowfish, aes);
}
static void HardCodes(Region region, out String installDir, out String blowfish, out String aes)
{
    installDir = blowfish = aes = "";
    if (region == Region.Steam) installDir = @"F:\Games\SteamLibrary\steamapps\common\Lost Ark\";
    if (region == Region.Steam) installDir = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\";
    if (region == Region.Korea) installDir = @"F:\Games\Games\LOSTARK\";
    if (region == Region.Korea) installDir = @"C:\Program Files (x86)\Steam\steamapps\common\Lost Ark\\";
    if (region == Region.Russia) installDir = @"F:\Games\LOSTARK\";
    //if (region == "jp") installDir = @"F:\Games\Games\LOSTARK\";
    if (region == Region.Steam) blowfish = @"83657ea6ffa1e671375c689a2e99a598";
    if (region == Region.Korea) blowfish = @"287f1d85be26e55a1d994e9e1bfd0df1";
    if (region == Region.Russia) blowfish = @"a7f33db20dfb711a16d5d3dd3d4cef4d";
    //if (region == "jp") blowfish = @"c66e7c755883b5a92227b6c1c71c1d94";
    if (region == Region.Steam) aes = @"1069d88738c5c75f82b44a1f0a382762";
    if (region == Region.Korea) aes = @"6ce3db2fbe338fba87edf2abf6453bfa";
    if (region == Region.Russia) aes = @"ee36ace0d87a9eaea565e6884a058b63";
    //if (region == "jp") aes = @"fail";
}
static void DLKorea()
{
    // post https://patchapi.onstove.com/apiv1/get_live_version
    // http://la.cdn.stovegame.net/stove/live/game/dpms_45/v542/plist.json
    // https://la.cdn.stovegame.net/stove/live/game/dpms_45/v543/3.gz // LostArk.exe
    // https://la.cdn.stovegame.net/stove/live/game/dpms_45/v543/4.gz // data.lpk
    var url = "https://patchapi.onstove.com/apiv1/get_live_version";
    var handler = new HttpClientHandler();
    handler.Proxy = new WebProxy("", 3128);
    handler.Proxy.Credentials = new NetworkCredential("", "");
    var httpClient = new HttpClient(handler);
    var request = new HttpRequestMessage(HttpMethod.Post, url);
    request.Content = new FormUrlEncodedContent(new List<KeyValuePair<string, string>> { new KeyValuePair<string, string>("service_code", "45") });// new StringContent(content);
    var response = httpClient.Send(request);
    var res = response.Content.ReadAsStringAsync().Result;
    var versionInfoUrl = res.Substring(res.IndexOf("http"));
    versionInfoUrl = versionInfoUrl.Substring(0, versionInfoUrl.IndexOf("json") + 4);

    var kr = new WebClient();
    //kr.Proxy = new WebProxy("", 80);
    kr.Proxy = handler.Proxy;

    var latestVersions = kr.DownloadString(versionInfoUrl);
    var exe = latestVersions.Substring(latestVersions.IndexOf("LOSTARK.exe"), 0x100).Split("|", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
    var data = latestVersions.Substring(latestVersions.IndexOf("/data.lpk"), 0x100).Split("|", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
    if (!File.Exists("LostArk_" + exe[1] + "_" + exe[2] + ".exe"))
        kr.DownloadFile("http://la.cdn.stovegame.net/stove/live/game/dpms_45/v" + exe[1] + "/" + exe[2] + ".gz", "LostArk_" + exe[1] + "_" + exe[2] + ".exe");
    if (!File.Exists("data_" + data[1] + "_" + data[2] + ".lpk"))
        kr.DownloadFile("http://la.cdn.stovegame.net/stove/live/game/dpms_45/v" + data[1] + "/" + data[2] + ".gz", "data_" + data[1] + "_" + data[2] + ".lpk");
    //var plist = kr.DownloadString("http://la.cdn.stovegame.net/stove/live/game/dpms_45/v542/plist.json");
}
```

`LoaDumper/Region.cs`:

```cs
namespace LoaDumper
{
    public enum Region : Byte
    {
        Steam,
        Korea,
        Russia
    }
}

```

`LoaDumper/Seed.cs`:

```cs
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;

namespace LoaDumper
{
    internal class Seed
    {
        static String rsaXml = "<RSAKeyValue><Modulus>rSVaV7qT/PmGpW9SRyWA/ulsdpxvcjgJLkeNYx0ageMBgscDGMswWk2V9DnxKYyfzT9eoQvC3xNCa1qFHRkFBSTfjqETcW40mNdcmPQmYtUBpNg1pp4uBfXF8LAtetm7wp5XI6KgYShtg+83vh0hU6yIqlBilSDpl7jAv7nru1OX0hhDIaKerhYZZv9GEXDUJmJkoN1araejriOlDS9u1uAUHKGHCSmje+zSolJG/C1Ut7kViWl5xoNtoNRUcKP8Io0MGJKKg3hxgLDktjZFjev5I7MaZDCg9VnrC4DaKKeyJ6aREFjRU3phR7RDJRcuwZLTCTdd9thuIIZPugxiuQ==</Modulus><Exponent>AQAB</Exponent><P>1v2WeN/Mq5z60F4rlwub6HRotLdIk5h12J5NXlC155UpQoecSpkzwHyAvxR36/rhDKbsWYhMlyilI4t5sAZylDa+XoMpea4tUCxhESqWX4DNRu8gmyXBVHkRFbfK/BgpWcoBnKuy2YadM0howGoS72Q6Dc02WYynRxOSloB6qwc=</P><Q>zixoZeek9SF4npPMwRPp2vQWqKZGhhNZ1azrKHCeNNeAOiTx+YHUiL07jPQYGjJkE0kLLv0WFGH0IMkyhHnAES6m4MEzL3DhuL+2AuOt2bxKMAgX4ZqAKuGd25uSwaABa+lHJqRVwa06On5VoUtUSaXhyPbl7E1kIkIN4fDSVD8=</Q><DP>Plulhn/bfLd2pHN8Dz6lxSHmsOwsl+rz25Xm+QFOEdLY+dwdwCF5uk4ihcnpEsBdAG92RG3dUUbPx2SQMjdcipLqWr2OjSWxLP0CVplUrnTMldOMUJP95IONKhB6Ru63J70JBKlkoeWCuTo6b/0Uau1WTWSFbCn45wvNS+wOKIc=</DP><DQ>lXMXUhcyOgbDOqAEokjfEbox2pp9MJ9CVWN9KtlHtSIpbvxs8uIrv9r8Gdauyf6REHG4S51lrey7XDC8D895bHsWuIETq2X2GUfOlhWYZebZGCwls4GdOnhFR3VkUjq8DQ8SZm5lQ3lgZhpB1COYu7IlEtn2HO6UkUi0a3132V0=</DQ><InverseQ>aHJdGTSXWGVxs4SXlDdtXhnNf7nonSn7nIuxovcZ0C+jQkV9EuksM9Ap1flpDYt1ynn8rIg2Xju0eREoIU9yP/lq/Ji0Uwcoq3HBD3+/uOQuxqHM0lsern4Gr53F17sF2mCbkzJAx6CbrjYv8AiumWl13lDeGtLUOFRMX5StW4Q=</InverseQ><D>mgq7X4WNF+nfktuBde613xRI/RWcSR/1ewkJjv5bkOcndvQbmzlaoVyZZpkOJ4sGuRIB3IGcM97snpoAB600vCjcBAbmR2pmvPwNU78TT6Z2OfRpdv0PsRnBqqrzK3L/CtzYZcnPqeDP3is7ipZcChdb1zqBGnAXonYqdeixAwybOFau41bm9QXhZRBvLWWWlXmgAo9iYoOBuym24IIVxo0fGgTo7PcbV/vYJH+gLPSF0JowHT74yHFBoJGqKL6NDuiT4NC24CCvfFWEP4am0lreHThRe4HKgdJPLTV/ncxmifjSjqBOJsNQpJEcqcMAduMS+WBriWQVOXZWnFA56Q==</D></RSAKeyValue>";
        public static Byte[] GetXorTable(String region)
        {
            var client = new TcpClient();
            if (region == "Steam") client.Connect(IPAddress.Parse("52.44.176.195"), 6010); // us
            if (region == "Korea") client.Connect(IPAddress.Parse("110.45.233.75"), 6010); // kr
            var stream = client.GetStream();
            using (var rsa = new RSACryptoServiceProvider(2048) { PersistKeyInCsp = false })
            {
                rsa.FromXmlString(rsaXml);
                var base64 = Convert.ToBase64String(rsa.ExportRSAPublicKey());
                var cert = "-----BEGIN RSA PUBLIC KEY-----\n";
                for (var i = 0; i < base64.Length; i += 64) cert += base64.Substring(i, Math.Min(64, base64.Length - i)) + "\n";
                cert += "-----END RSA PUBLIC KEY-----\n";

                var packet = BitConverter.GetBytes((UInt16)0).ToList(); // packet length
                packet.AddRange(BitConverter.GetBytes((UInt16)1)); // opcode
                packet.Add(0); // uncompressed
                packet.Add(0); // unencrypted
                packet.AddRange(BitConverter.GetBytes((UInt64)0)); // counter
                packet.AddRange(BitConverter.GetBytes((UInt64)0)); // rand
                packet.AddRange(BitConverter.GetBytes(cert.Length));
                packet.AddRange(Encoding.UTF8.GetBytes(cert));
                var packetBytes = packet.ToArray();
                Array.Copy(BitConverter.GetBytes(packet.Count), packetBytes, 2);
                stream.Write(packetBytes, 0, packetBytes.Length);
            }
            {
                var buf = new byte[client.ReceiveBufferSize];
                var n = stream.Read(buf, 0, buf.Length);
                if (BitConverter.ToUInt16(buf) != n) throw new Exception("bad packet length");
                if (BitConverter.ToUInt16(buf, 2) != 2) throw new Exception("bad packet opcode");
                if (buf[5] != 0) throw new Exception("bad packet encryption");
                if (buf[4] == 2) buf = IronSnappy.Snappy.Decode(buf.Take(n).Skip(6).ToArray()).Skip(16).ToArray();

                var tableSize = 0x100;
                var xorTable = Enumerable.Range(0, tableSize).Select(s => (Byte)s).ToList();
                var seedBytes = BitConverter.GetBytes(BitConverter.ToUInt32(buf, 0));
                var o = (Byte)0;
                for (var i = 0; i < tableSize; i++)
                {
                    var index = xorTable[i];
                    o = (Byte)(seedBytes[i % 4] + index + o);
                    var tempSwap = xorTable[o];
                    xorTable[o] = index;
                    xorTable[i] = tempSwap;
                }

                return xorTable.ToArray();
            }
        }
    }
}

```

`LoaDumper/SigScan.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;

//
// sigScan C# Implementation - Written by atom0s [aka Wiccaan]
// Class Version: 2.0.0
//
// [ CHANGE LOG ] -------------------------------------------------------------------------
//
//      2.0.0
//          - Updated to no longer require unsafe or fixed code.
//          - Removed unneeded methods and code.
//
//      1.0.0
//          - First version written and release.
//
// [ CREDITS ] ----------------------------------------------------------------------------
//
// sigScan is based on the FindPattern code written by
// dom1n1k and Patrick at GameDeception.net
//
// Full credit to them for the purpose of this code. I, atom0s, simply
// take credit for converting it to C#.
//
// [ USAGE ] ------------------------------------------------------------------------------
//
// Examples:
//
//      SigScan _sigScan = new SigScan();
//      _sigScan.Process = someProc;
//      _sigScan.Address = new IntPtr(0x123456);
//      _sigScan.Size = 0x1000;
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
//      SigScan _sigScan = new SigScan(someProc, new IntPtr(0x123456), 0x1000);
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
// ----------------------------------------------------------------------------------------
namespace LoaDumper
{
    public class SignatureEntity
    {
        public int StartAddress { get; set; }
        public int SearchRange { get; set; }
        public byte[] WantedBytes { get; set; }
        public String Mask { get; set; }
        public int AddressOffset { get; set; }

        public SignatureEntity(int startSAddress, int searchRange, byte[] wantedBytes, String mask, int addressOffset)
        {
            StartAddress = startSAddress;
            SearchRange = searchRange;
            WantedBytes = wantedBytes;
            Mask = mask;
            AddressOffset = addressOffset;
        }

        public IntPtr ScanSignature(Process process)
        {
            SigScan sigScan = new SigScan(process, new IntPtr(StartAddress), SearchRange);
            return sigScan.FindPattern(WantedBytes, Mask, AddressOffset);
        }
    }


    public class SigScan
    {
        /// <summary>
        /// ReadProcessMemory
        /// 
        ///     API import definition for ReadProcessMemory.
        /// </summary>
        /// <param name="hProcess">Handle to the process we want to read from.</param>
        /// <param name="lpBaseAddress">The base address to start reading from.</param>
        /// <param name="lpBuffer">The return buffer to write the read data to.</param>
        /// <param name="dwSize">The size of data we wish to read.</param>
        /// <param name="lpNumberOfBytesRead">The number of bytes successfully read.</param>
        /// <returns></returns>
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool ReadProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            [Out()] byte[] lpBuffer,
            int dwSize,
            out int lpNumberOfBytesRead
            );

        /// <summary>
        /// m_vDumpedRegion
        /// 
        ///     The memory dumped from the external process.
        /// </summary>
        public byte[] m_vDumpedRegion;

        /// <summary>
        /// m_vProcess
        /// 
        ///     The process we want to read the memory of.
        /// </summary>
        private Process m_vProcess;

        /// <summary>
        /// m_vAddress
        /// 
        ///     The starting address we want to begin reading at.
        /// </summary>
        private IntPtr m_vAddress;

        /// <summary>
        /// m_vSize
        /// 
        ///     The number of bytes we wish to read from the process.
        /// </summary>
        private Int32 m_vSize;


        #region "sigScan Class Construction"
        /// <summary>
        /// SigScan
        /// 
        ///     Main class constructor that uses no params. 
        ///     Simply initializes the class properties and 
        ///     expects the user to set them later.
        /// </summary>
        public SigScan()
        {
            this.m_vProcess = null;
            this.m_vAddress = IntPtr.Zero;
            this.m_vSize = 0;
            this.m_vDumpedRegion = null;
        }
        /// <summary>
        /// SigScan
        /// 
        ///     Overloaded class constructor that sets the class
        ///     properties during construction.
        /// </summary>
        /// <param name="proc">The process to dump the memory from.</param>
        /// <param name="addr">The started address to begin the dump.</param>
        /// <param name="size">The size of the dump.</param>
        public SigScan(Process proc, IntPtr addr, int size)
        {
            this.m_vProcess = proc;
            this.m_vAddress = addr;
            this.m_vSize = size;
        }
        #endregion

        #region "sigScan Class Private Methods"
        /// <summary>
        /// DumpMemory
        /// 
        ///     Internal memory dump function that uses the set class
        ///     properties to dump a memory region.
        /// </summary>
        /// <returns>Boolean based on RPM results and valid properties.</returns>
        private bool DumpMemory()
        {
            try
            {
                // Checks to ensure we have valid data.
                if (this.m_vProcess == null)
                    return false;
                if (this.m_vProcess.HasExited == true)
                    return false;
                if (this.m_vAddress == IntPtr.Zero)
                    return false;
                if (this.m_vSize == 0)
                    return false;

                // Create the region space to dump into.
                this.m_vDumpedRegion = new byte[this.m_vSize];

                bool bReturn = false;
                int nBytesRead = 0;

                // Dump the memory.
                bReturn = ReadProcessMemory(this.m_vProcess.Handle, this.m_vAddress, this.m_vDumpedRegion, this.m_vSize, out nBytesRead);

                // Validation checks.
                if (bReturn == false || nBytesRead != this.m_vSize)
                    return false;
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// MaskCheck
        /// 
        ///     Compares the current pattern byte to the current memory dump
        ///     byte to check for a match. Uses wildcards to skip bytes that
        ///     are deemed unneeded in the compares.
        /// </summary>
        /// <param name="nOffset">Offset in the dump to start at.</param>
        /// <param name="btPattern">Pattern to scan for.</param>
        /// <param name="strMask">Mask to compare against.</param>
        /// <returns>Boolean depending on if the pattern was found.</returns>
        private bool MaskCheck(int nOffset, byte[] btPattern, string strMask)
        {
            // Loop the pattern and compare to the mask and dump.
            for (int x = 0; x < btPattern.Length; x++)
            {
                // If the mask char is a wildcard, just continue.
                if (strMask[x] == '?')
                    continue;

                // If the mask char is not a wildcard, ensure a match is made in the pattern.
                if ((strMask[x] == 'x') && (btPattern[x] != this.m_vDumpedRegion[nOffset + x]))
                    return false;
            }

            // The loop was successful so we found the pattern.
            return true;
        }
        #endregion
        public List<IntPtr> FindPatterns(String pattern, IntPtr start, Int32 length)
        {
            //var skip = pattern.ToLower().Contains("cc") ? 0xcc : pattern.ToLower().Contains("aa") ? 0xaa : 0;
            //var sigScan = new SigScan(Process, start, length);
            var arrayOfBytes = pattern.Replace("-", " ").Split(' ').Select(b => b.Contains("?") ? (Byte)0 : (Byte)Convert.ToInt32(b, 16)).ToArray();
            var strMask = String.Join("", pattern.Split(' ').Select(b => b.Contains("?") ? '?' : 'x'));
            return FindPatterns(arrayOfBytes, strMask, 0);
        }
        #region "sigScan Class Public Methods"
        /// <summary>
        /// FindPattern
        /// 
        ///     Attempts to locate the given pattern inside the dumped memory region
        ///     compared against the given mask. If the pattern is found, the offset
        ///     is added to the located address and returned to the user.
        /// </summary>
        /// <param name="btPattern">Byte pattern to look for in the dumped region.</param>
        /// <param name="strMask">The mask string to compare against.</param>
        /// <param name="nOffset">The offset added to the result address.</param>
        /// <returns>IntPtr - zero if not found, address if found.</returns>
        public IntPtr FindPattern(byte[] btPattern, string strMask, int nOffset)
        {
            try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return IntPtr.Zero;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return IntPtr.Zero;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length - strMask.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        return IntPtr.Add(this.m_vAddress, x + nOffset);
                    }
                }

                // Pattern was not found.
                return IntPtr.Zero;
            }
            catch (Exception)
            {
                return IntPtr.Zero;
            }
        }
        public List<IntPtr> GetJmpRef(IntPtr ptr)
        {
            var ptrs = new List<IntPtr>();
            for (var x = 0u; x < this.m_vDumpedRegion.Length; x++)
            {
                if(m_vDumpedRegion[x] == 0xE9) // jmp
                {
                    var jmpAddr = BitConverter.ToUInt32(m_vDumpedRegion, (int)x + 1);
                    if (x + jmpAddr + 5 == (UInt64)ptr)
                    {
                        //ptrs.Add(IntPtr.Add(this.m_vAddress, x));

                    }
                }
            }
            return ptrs;
        }
        public List<IntPtr> FindPatterns(byte[] btPattern, string strMask, int nOffset)
        {
            var ptrs = new List<IntPtr>();
            //try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return null;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return null;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length- btPattern.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        ptrs.Add(IntPtr.Add(this.m_vAddress, x + nOffset));
                    }
                }

                // Pattern was not found.
                return ptrs;
            }
            //catch (Exception e)
            {
                return null;
            }
        }

        /// <summary>
        /// ResetRegion
        /// 
        ///     Resets the memory dump array to nothing to allow
        ///     the class to redump the memory.
        /// </summary>
        public void ResetRegion()
        {
            this.m_vDumpedRegion = null;
        }
        #endregion

        #region "sigScan Class Properties"
        public Process Process
        {
            get { return this.m_vProcess; }
            set { this.m_vProcess = value; }
        }
        public IntPtr Address
        {
            get { return this.m_vAddress; }
            set { this.m_vAddress = value; }
        }
        public Int32 Size
        {
            get { return this.m_vSize; }
            set { this.m_vSize = value; }
        }
        #endregion

    }
}
```

`README.md`:

```md
# LostArkDumper
 

```