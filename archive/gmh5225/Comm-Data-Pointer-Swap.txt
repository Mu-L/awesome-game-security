Project Path: arc_gmh5225_Comm-Data-Pointer-Swap__geb29w3

Source Tree:

```txt
arc_gmh5225_Comm-Data-Pointer-Swap__geb29w3
├── DataHook
│   ├── DataHook
│   │   ├── DataHook.vcxproj
│   │   ├── DataHook.vcxproj.filters
│   │   ├── DataHook.vcxproj.user
│   │   ├── Hook.cpp
│   │   ├── Imports.h
│   │   └── Memory.h
│   ├── DataHook.sln
│   └── Usermode
│       ├── Hook.cpp
│       ├── Memory.cpp
│       ├── Memory.h
│       ├── Usermode.vcxproj
│       ├── Usermode.vcxproj.filters
│       └── Usermode.vcxproj.user
└── README.md

```

`DataHook/DataHook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DataHook", "DataHook\DataHook.vcxproj", "{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Usermode", "Usermode\Usermode.vcxproj", "{D301DD7C-939E-4738-978C-9D3C36D1350E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM.ActiveCfg = Debug|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM.Build.0 = Debug|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM.Deploy.0 = Debug|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM64.Build.0 = Debug|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x64.ActiveCfg = Debug|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x64.Build.0 = Debug|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x64.Deploy.0 = Debug|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x86.ActiveCfg = Debug|Win32
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x86.Build.0 = Debug|Win32
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Debug|x86.Deploy.0 = Debug|Win32
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM.ActiveCfg = Release|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM.Build.0 = Release|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM.Deploy.0 = Release|ARM
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM64.ActiveCfg = Release|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM64.Build.0 = Release|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|ARM64.Deploy.0 = Release|ARM64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x64.ActiveCfg = Release|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x64.Build.0 = Release|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x64.Deploy.0 = Release|x64
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x86.ActiveCfg = Release|Win32
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x86.Build.0 = Release|Win32
		{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}.Release|x86.Deploy.0 = Release|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|ARM.ActiveCfg = Debug|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|ARM64.ActiveCfg = Debug|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|x64.ActiveCfg = Debug|x64
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|x64.Build.0 = Debug|x64
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|x86.ActiveCfg = Debug|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Debug|x86.Build.0 = Debug|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|ARM.ActiveCfg = Release|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|ARM64.ActiveCfg = Release|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|x64.ActiveCfg = Release|x64
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|x64.Build.0 = Release|x64
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|x86.ActiveCfg = Release|Win32
		{D301DD7C-939E-4738-978C-9D3C36D1350E}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6B9798EB-F339-4D21-BC18-646C7D003C2E}
	EndGlobalSection
EndGlobal

```

`DataHook/DataHook/DataHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3D1FE9D3-67ED-42E0-B813-1EC3BB5FF598}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DataHook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Imports.h" />
    <ClInclude Include="Memory.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Hook.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DataHook/DataHook/DataHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DataHook/DataHook/DataHook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`DataHook/DataHook/Hook.cpp`:

```cpp
#include "Memory.h"

__int64(__fastcall* original_function)(void*, void*, void*);
__int64 __fastcall hooked_function(void* a1, void* a2, void* a3)
{
	if (ExGetPreviousMode() != UserMode)
	{
		return original_function(a1, a2, a3);
	}

	if (!a1)
	{
		return original_function(a1, a2, a3);
	}

	WRITE_STRUCT* w = (WRITE_STRUCT*)a1;

	if (w->special != 0xDEAD)
	{
		return original_function(a1, a2, a3);
	}
	if (w->write)
	{
		if (!w->address || !w->target_pid || !w->size)
			return STATUS_INVALID_PARAMETER;

		PEPROCESS proc;
		if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)w->target_pid, &proc)))
			return STATUS_INVALID_PARAMETER_1;

		SIZE_T bytes = 0;

		NTSTATUS status = MmCopyVirtualMemory(PsGetCurrentProcess(), w->buffer, proc, w->address, w->size, KernelMode, &bytes);

		if (!NT_SUCCESS(status))
			return STATUS_UNSUCCESSFUL;

		return STATUS_SUCCESS;
	}
	else if (w->read)
	{
		if (!w->address || !w->target_pid || !w->size)
			return STATUS_INVALID_PARAMETER;

		PEPROCESS proc;
		if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)w->target_pid, &proc)))
			return STATUS_INVALID_PARAMETER_1;

		SIZE_T bytes = 0;

		NTSTATUS status = MmCopyVirtualMemory(proc, w->address, PsGetCurrentProcess(), w->buffer, w->size, KernelMode, &bytes);

		if (!NT_SUCCESS(status))
			return STATUS_UNSUCCESSFUL;

		return STATUS_SUCCESS;
	}
	else if (w->request_base)
	{
		PEPROCESS target_proc;
		PsLookupProcessByProcessId((HANDLE)w->target_pid, &target_proc);
		w->process_base = PsGetProcessSectionBaseAddress(target_proc);
		ObDereferenceObject(target_proc);
	}
	return STATUS_SUCCESS;
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT drv_obj, PUNICODE_STRING reg_pth)
{
	UNREFERENCED_PARAMETER(drv_obj);
	UNREFERENCED_PARAMETER(reg_pth);

	DbgPrintEx(0, 0, "[+] Driver Loaded");

	PVOID image_base = memory::GetSystemBaseModule("\\SystemRoot\\System32\\win32kbase.sys");
	if (!image_base)
	{
		DbgPrintEx(0, 0, "[+] Error Finding Image Base");
		return STATUS_UNSUCCESSFUL;
	}

	DbgPrintEx(0, 0, "[+] Found Image Base");

	PBYTE FunctionAddress1 = memory::FindPatternWork(image_base, "\x74\x10\x4C\x8B\xC6\x48\x8B\xD5\xFF\x15\x00\x00\x00\x00", "xxxxxxxxxx????");
	if (!FunctionAddress1)
	{
		DbgPrintEx(0, 0, "[+] Error Finding Qword Pointer 1");
		return STATUS_UNSUCCESSFUL;
	}

	DbgPrintEx(0, 0, "[+] Found Qword Pointer 1: 0x%llx", FunctionAddress1);

	UINT64 deref_pointer1 = (UINT64)(FunctionAddress1) - 0xA;
	deref_pointer1 = (UINT64)deref_pointer1 + *(PINT)((PBYTE)deref_pointer1 + 3) + 7;

	DbgPrintEx(0, 0, "[+] Derefed Pointer 1: 0x%llx", &deref_pointer1);

	if (NT_SUCCESS(memory::FindProcessByName("explorer.exe", &target)))
	{
		DbgPrintEx(0, 0, "[+] Found Explorer.exe: %p", target);

		KeAttachProcess(target);
		*(void**)&original_function = _InterlockedExchangePointer((void**)deref_pointer1, (void**)hooked_function);
		KeDetachProcess();

		DbgPrintEx(0, 0, "[+] Attached & Detached Target");
	}
	else
	{
		DbgPrintEx(0, 0, "[!] Failed To Find Explorer.exe");
		return STATUS_UNSUCCESSFUL;
	}

	DbgPrintEx(0, 0, "[+] Swapped Qword Pointer");

	return STATUS_SUCCESS;
}
```

`DataHook/DataHook/Imports.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <ntimage.h>

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _WRITE_STRUCT
{
	int special;

	bool read;
	bool write;
	bool request_base;
	bool new_base;
	int target_pid;
	void* base_address;
	void* address;
	void* buffer;
	void* output;
	void* process_base;

	size_t size;

	const char* mod_name;
}WRITE_STRUCT;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;
```

`DataHook/DataHook/Memory.h`:

```h
#pragma once
#include "Imports.h"

PEPROCESS target;
extern "C" NTKERNELAPI PPEB PsGetProcessPeb(IN PEPROCESS Process);
extern "C" __declspec(dllimport) PLIST_ENTRY NTAPI PsLoadedModuleList;
extern "C" NTKERNELAPI PVOID NTAPI RtlFindExportedRoutineByName(_In_ PVOID ImageBase, _In_ PCCH RoutineNam);
extern "C" NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
extern "C" NTSTATUS NTAPI MmCopyVirtualMemory(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

namespace memory
{
	PVOID GetSystemBaseModule(const char* module_name)
	{
		ULONG bytes = 0;
		NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

		if (!bytes) return 0;

		PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x504D5448);

		status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

		if (!NT_SUCCESS(status)) return 0;

		PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
		PVOID module_base = 0, module_size = 0;

		for (ULONG i = 0; i < modules->NumberOfModules; i++)
		{
			if (strcmp((char*)module[i].FullPathName, module_name) == 0)
			{
				DbgPrintEx(0, 0, "[+] Looping Module List");
				module_base = module[i].ImageBase;
				module_size = (PVOID)module[i].ImageSize;
				break;
			}
		}

		if (modules) ExFreePoolWithTag(modules, 0);
		if (module_base <= 0) return 0;
		return module_base;
	}

	NTSTATUS FindProcessByName(CHAR* process_name, PEPROCESS* process)
	{
		PEPROCESS sys_process = PsInitialSystemProcess;
		PEPROCESS cur_entry = sys_process;
		CHAR image_name[15];

		do
		{
			RtlCopyMemory((PVOID)(&image_name), (PVOID)((uintptr_t)cur_entry + 0x5a8), sizeof(image_name));

			if (strstr(image_name, process_name))
			{
				DWORD active_threads;
				RtlCopyMemory((PVOID)&active_threads, (PVOID)((uintptr_t)cur_entry + 0x5f0), sizeof(active_threads));
				if (active_threads)
				{
					*process = cur_entry;
					return STATUS_SUCCESS;
				}
			}

			PLIST_ENTRY list = (PLIST_ENTRY)((uintptr_t)(cur_entry) + 0x448);
			cur_entry = (PEPROCESS)((uintptr_t)list->Flink - 0x448);

		} while (cur_entry != sys_process);

		return STATUS_NOT_FOUND;
	}


	BOOLEAN data_compare(const BYTE* pData, const BYTE* bMask, const char* szMask)
	{
		for (; *szMask; ++szMask, ++pData, ++bMask)
			if (*szMask == 'x' && *pData != *bMask)
				return 0;
		return (*szMask) == 0;
	}


	PIMAGE_NT_HEADERS getHeader(PVOID module)
	{
		return (PIMAGE_NT_HEADERS)((PBYTE)module + PIMAGE_DOS_HEADER(module)->e_lfanew);
	}

	PBYTE FindPattern(PVOID module, DWORD size, LPCSTR pattern, LPCSTR mask)
	{

		auto checkMask = [](PBYTE buffer, LPCSTR pattern, LPCSTR mask) -> BOOL
		{
			for (auto x = buffer; *mask; pattern++, mask++, x++)
			{
				auto addr = *(BYTE*)(pattern);
				if (addr != *x && *mask != '?')
					return FALSE;
			}

			return TRUE;
		};

		for (auto x = 0; x < size - strlen(mask); x++) 
		{

			auto addr = (PBYTE)module + x;
			if (checkMask(addr, pattern, mask))
				return addr;
		}

		return NULL;
	}

	PBYTE FindPatternWork(PVOID base, LPCSTR pattern, LPCSTR mask)
	{

		auto header = getHeader(base);
		auto section = IMAGE_FIRST_SECTION(header);

		for (auto x = 0; x < header->FileHeader.NumberOfSections; x++, section++)
		{

			if (!memcmp(section->Name, ".text", 5) || !memcmp(section->Name, "PAGE", 4))
			{
				auto addr = FindPattern((PBYTE)base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
				if (addr) {
					//DbgPrintEx(0, 0, "[+] Found in Section -> [ %s ]", section->Name);
					return addr;
				}
			}
		}

		return NULL;
	}
}
```

`DataHook/Usermode/Hook.cpp`:

```cpp
#pragma once
#include "Memory.h"

int main()
{
	if (!setup_comm())
	{
		std::cout << "[!] Failed To Setup Communication" << std::endl;
		return 0;
	}

	std::cout << "[+] Communication Established" << std::endl;

	pid = get_pid(L"notepad.exe");

	if (!pid)
	{
		std::cout << "[!] Failed To Get PID" << std::endl;
		return 0;
	}

	std::cout << "[+] PID: " << pid << std::endl;

	std::getchar();
	return 0;

}
```

`DataHook/Usermode/Memory.cpp`:

```cpp
#include "Memory.h"

int pid;
PVOID proc_base;
void(__fastcall* FunctionPTR)(void* a1, void* a2, void* a3);

bool setup_comm()
{
	auto ntdll_base = LoadLibraryA("win32u.dll");
	if (!ntdll_base) {
		return FALSE;
	}
	std::cout << "[+] Found win32u.dll: " << ntdll_base << std::endl;

	auto function_addr = GetProcAddress(ntdll_base, "NtDCompositionSetChildRootVisual");
	if (!function_addr) {
		return FALSE;
	}

	*(void**)&FunctionPTR = function_addr;

	std::cout << "[+] Found Function Address: " << function_addr << std::endl;

	return &FunctionPTR;
}

DWORD get_pid(LPCWSTR process_name) 
{
	HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	DWORD pid = NULL;

	if (handle == INVALID_HANDLE_VALUE)
		return pid;

	PROCESSENTRY32W entry = { 0 };
	entry.dwSize = sizeof(PROCESSENTRY32W);

	if (Process32FirstW(handle, &entry)) {
		if (!_wcsicmp(process_name, entry.szExeFile)) {
			pid = entry.th32ProcessID;
		}
		else while (Process32NextW(handle, &entry)) {
			if (!_wcsicmp(process_name, entry.szExeFile)) {
				pid = entry.th32ProcessID;
			}
		}
	}

	CloseHandle(handle);
	return pid;
}

// test this out
PVOID get_base(DWORD pid)
{
	WRITE_STRUCT request = {};
	SecureZeroMemory(&request, sizeof(WRITE_STRUCT));

	request.special = 0xDEAD;
	request.write = FALSE;
	request.read = FALSE;
	request.request_base = TRUE;
	request.target_pid = pid;

	FunctionPTR(&request, 0, 0);
	return request.process_base;
}
```

`DataHook/Usermode/Memory.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <iostream>

extern int pid;
extern PVOID proc_base;

bool setup_comm();
DWORD get_pid(LPCWSTR process_name);
PVOID get_base(DWORD pid);

struct WRITE_STRUCT
{
	int special;
	bool read;
	bool write;
	bool request_base;
	int target_pid;
	void* base_address;
	void* address;
	void* buffer;
	void* output;
	void* process_base;

	size_t size;

	const char* mod_name;
};
```

`DataHook/Usermode/Usermode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d301dd7c-939e-4738-978c-9d3c36d1350e}</ProjectGuid>
    <RootNamespace>Usermode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Hook.cpp" />
    <ClCompile Include="Memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DataHook/Usermode/Usermode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DataHook/Usermode/Usermode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`README.md`:

```md
# Data-Pointer-Swap

Simple Kernel Mode Data Pointer Swap, Credits To FoxiTV On UC for Great Resources About This Topic.
This Source Was Made Back In August 2021 & Decided To Release This Now As I Never Had A Purpose To Use This At All. 
I Know There Is Alot Info Already But Why Not Add Some More Pasta To My GitHub.

Some Info About This Driver:
Status Would Be 100% Detected As Im Probaly Using A Popular Pointer & Not Doing Any Pointer Chaining. (or other methods)
I Suggest Finding A Random non-PG Protected Module And Take Advantage Of That. 

![8e97c5c1c678dd96786d5018c2500fb1-png](https://user-images.githubusercontent.com/80023326/151693652-f80dd1cb-8272-4c7a-a1ee-9098e1422b2c.jpg)

```