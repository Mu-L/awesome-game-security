Project Path: arc_gmh5225_Rootkit-2_yntadjfg

Source Tree:

```txt
arc_gmh5225_Rootkit-2_yntadjfg
├── README.md
└── detect_hide_process
    ├── CsrssWalker.cpp
    ├── CsrssWalker.h
    ├── DrvMain.cpp
    ├── global.cpp
    └── global.hpp

```

`README.md`:

```md
A way to detect hidden process that by walking csrss.
Analysis blog:https://blog.csdn.net/qq_41252520/article/details/138261078

```

`detect_hide_process/CsrssWalker.cpp`:

```cpp
#include "CsrssWalker.h"

NTSTATUS WalkCsrss()
{
	PEPROCESS* eps;
	NTSTATUS ntStatus;
	KAPC_STATE kApcState;

	ntStatus = GetProcessByName(L"csrss.exe", &eps, TRUE);
	if (!NT_SUCCESS(ntStatus)) goto cleanup;

	for (ULONG i = 0; eps[i]; i++)
	{
		KeStackAttachProcess(eps[i], &kApcState);
		ntStatus = WalkCsrssInternal(eps[i]);
		KeUnstackDetachProcess(&kApcState);

		DbgPrint("\n-------------------------------------------------------------------------\n");
	}

cleanup:
	if (eps)
	{
		for (ULONG i = 0; eps[i]; i++) ObDereferenceObject(eps[i]);

		ExFreePoolWithTag(eps, 'PeAr');
	}

	return ntStatus;
}

NTSTATUS WalkCsrssInternal(PEPROCESS Process)
{
#ifdef _AMD64_
	const UCHAR pattern[] = "\x48\x8B\x0D\xCC\xCC\xCC\xCC";
#else
	const UCHAR pattern[] = "\x8B\x0D\xB4\xCC\xCC\xCC\xCC";
#endif

	UNICODE_STRING uszCsrsrv = RTL_CONSTANT_STRING(L"csrsrv.dll");
	PVOID pfnCsrLocateServerThread = NULL;
	PVOID fdPos;
	NTSTATUS ntStatus;
	PVOID pfnCsrExecServerThread = NULL;
	PVOID pCsrsrvBase;
	PCSR_PROCESS* ppCsrProcssList;

	__try 
	{
		do 
		{
			pCsrsrvBase = BBGetUserModule(Process, &uszCsrsrv);
			if (pCsrsrvBase == NULL)
			{
				ntStatus = STATUS_NOT_FOUND;
				break;
			}

			pfnCsrExecServerThread = BBGetModuleExport(pCsrsrvBase, "CsrExecServerThread", Process);
			if (pfnCsrExecServerThread == NULL)
			{
				ntStatus = STATUS_NOT_FOUND;
				break;
			}

			ntStatus = BBSearchPattern(pattern, 0xCC, sizeof(pattern) - 1, pfnCsrExecServerThread, 0x40, &fdPos);
			if (!NT_SUCCESS(ntStatus)) break;

			ProbeForRead(fdPos, sizeof(ULONG), 1);
#ifdef _AMD64_
			ppCsrProcssList = (PCSR_PROCESS*)((PUCHAR)fdPos + *(PULONG)((PUCHAR)fdPos + 3) + sizeof(pattern) - 1);
#else
			ppCsrProcssList = *(PCSR_PROCESS**)((PUCHAR)fdPos + 2);
#endif
			ProbeForRead(ppCsrProcssList, sizeof(PCSR_PROCESS), 1);

			EnumCsrssProcessList(*ppCsrProcssList);
		} while (FALSE);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("[!] An exception occurred! Exception code = %I32x\n", GetExceptionCode());
	}
	
	return ntStatus;
}

VOID EnumCsrssProcessList(PCSR_PROCESS CsrProcessList)
{
	PEPROCESS pProcess = NULL;
	NTSTATUS ntStatus;
	PUNICODE_STRING uszProcName;
	PLIST_ENTRY pListHdr;
	PLIST_ENTRY pNext;

	__try
	{
		ProbeForRead(CsrProcessList, sizeof(CSR_PROCESS), 1);

		pListHdr = (PLIST_ENTRY)&CsrProcessList->ListLink;
		pNext = pListHdr->Blink;

		while (pListHdr != pNext)
		{
			PCSR_PROCESS pCsrProc = CONTAINING_RECORD(pNext, CSR_PROCESS, ListLink);
			ProbeForRead(pCsrProc, sizeof(CSR_PROCESS), 1);

			ntStatus = PsLookupProcessByProcessId(pCsrProc->ClientId.UniqueProcess, &pProcess);
			if (NT_SUCCESS(ntStatus))
			{
				ntStatus = SeLocateProcessImageName(pProcess, &uszProcName);
				if (NT_SUCCESS(ntStatus))
				{
					DbgPrint("Pid: %x -- %wZ\n",PsGetProcessId(pProcess) ,uszProcName);
					ExFreePool(uszProcName);
				}
				ObDereferenceObject(pProcess);
			}
			
			pNext = pNext->Blink;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("[!] An exception occurred! Exception code = %I32x\n", GetExceptionCode());
	}

}
```

`detect_hide_process/CsrssWalker.h`:

```h
#pragma once
#include "global.hpp"

typedef struct _CSR_PROCESS
{
	struct _CLIENT_ID ClientId; // 0x0
	struct _LIST_ENTRY ListLink; // 0x10
	struct _LIST_ENTRY ThreadList; // 0x20
	// ...
} CSR_PROCESS, * PCSR_PROCESS;

NTSTATUS WalkCsrss();
NTSTATUS WalkCsrssInternal(PEPROCESS Process);
VOID EnumCsrssProcessList(PCSR_PROCESS CsrProcessList);
```

`detect_hide_process/DrvMain.cpp`:

```cpp
#include "CsrssWalker.h"

extern"C"
NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DrvObj,
	_In_ PUNICODE_STRING RegPath);

VOID DriverUnload(_In_ PDRIVER_OBJECT DrvObj);

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DrvObj,
	_In_ PUNICODE_STRING RegPath)
{
	DrvObj->DriverUnload = DriverUnload;

	return WalkCsrss();
}

VOID DriverUnload(_In_ PDRIVER_OBJECT DrvObj)
{
	
}
```

`detect_hide_process/global.cpp`:

```cpp
#include "global.hpp"
#include <ntimage.h>

HANDLE GetProcessIdByName(PWCHAR Name, PHANDLE ParentId)
{
	NTSTATUS ntStatus;
	PEPROCESS pProcess = NULL;
	PUNICODE_STRING pImageFileName = NULL;

	if (Name == NULL)
	{
		return NULL;
	}

	for (ULONG i = 5; i < 100000; i++)
	{
		ntStatus = PsLookupProcessByProcessId((HANDLE)i, &pProcess);
		if (NT_SUCCESS(ntStatus))
		{
			ntStatus = SeLocateProcessImageName(pProcess, &pImageFileName);
			if (NT_SUCCESS(ntStatus))
			{
				if (pImageFileName->MaximumLength >= wcslen(Name) * 2 && wcsstr(pImageFileName->Buffer, Name))
				{
					if(ParentId) *ParentId = PsGetProcessInheritedFromUniqueProcessId(pProcess);

					ExFreePool(pImageFileName);
					ObDereferenceObject(pProcess);
					return (HANDLE)i;
				}
				ExFreePool(pImageFileName);
			}

			ObDereferenceObject(pProcess);
		}
	}

	return NULL;
}

NTSTATUS GetProcessByName(PWCHAR Name, PEPROCESS** Process, BOOLEAN FindAll)
{
	NTSTATUS ntStatus;
	PEPROCESS pProcess = NULL;
	PUNICODE_STRING pImageFileName = NULL;
	ULONG id = 0;

	if (Name == NULL)
	{
		return NULL;
	}

	PEPROCESS* result = (PEPROCESS*)ExAllocatePoolWithTag(NonPagedPool, sizeof(PEPROCESS) * 100, 'PeAr');
	if (result == NULL) return NULL;

	RtlZeroMemory(result, sizeof(PEPROCESS) * 100);

	for (ULONG i = 5; i < 100000; i++)
	{
		ntStatus = PsLookupProcessByProcessId((HANDLE)i, &pProcess);
		if (NT_SUCCESS(ntStatus))
		{
			ntStatus = SeLocateProcessImageName(pProcess, &pImageFileName);
			if (NT_SUCCESS(ntStatus))
			{
				if (pImageFileName->MaximumLength >= wcslen(Name) * 2 && wcsstr(pImageFileName->Buffer, Name))
				{
					ExFreePool(pImageFileName);
					if (FindAll)
					{
						if (id >= 100) break;

						result[id++] = pProcess;
						continue;
					}
					else
					{
						result[id++] = pProcess;
						break;
					}
				}

				ExFreePool(pImageFileName);
			}

			ObDereferenceObject(pProcess);
		}
	}
	
	if (id > 0)
	{
		*Process = result;
		return STATUS_SUCCESS;
	}
	else
	{
		ExFreePoolWithTag(result, 'PeAr');
		*Process = NULL;
		return STATUS_NOT_FOUND;
	}
	
}

PVOID BBGetUserModule(IN PEPROCESS pProcess, IN PUNICODE_STRING ModuleName)
{
	ASSERT(pProcess != NULL);
	if (pProcess == NULL)
		return NULL;

	// Protect from UserMode AV
	__try
	{
		LARGE_INTEGER time = { 0 };
		time.QuadPart = -250ll * 10 * 1000;     // 250 msec.

		PPEB pPeb = PsGetProcessPeb(pProcess);
		if (!pPeb)
		{
			DbgPrint("BlackBone: %s: No PEB present. Aborting\n", __FUNCTION__);
			return NULL;
		}

		// Wait for loader a bit
		for (INT i = 0; !pPeb->Ldr && i < 10; i++)
		{
			DbgPrint("BlackBone: %s: Loader not intialiezd, waiting\n", __FUNCTION__);
			KeDelayExecutionThread(KernelMode, TRUE, &time);
		}

		// Still no loader
		if (!pPeb->Ldr)
		{
			DbgPrint("BlackBone: %s: Loader was not intialiezd in time. Aborting\n", __FUNCTION__);
			return NULL;
		}

		// Search in InLoadOrderModuleList
		for (PLIST_ENTRY pListEntry = pPeb->Ldr->InLoadOrderModuleList.Flink;
			pListEntry != &pPeb->Ldr->InLoadOrderModuleList;
			pListEntry = pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
			if (RtlCompareUnicodeString(&pEntry->BaseDllName, ModuleName, TRUE) == 0)
				return pEntry->DllBase;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("BlackBone: %s: Exception, Code: 0x%X\n", __FUNCTION__, GetExceptionCode());
	}

	return NULL;
}

PVOID BBGetModuleExport(IN PVOID pBase, IN PCCHAR name_ord, IN PEPROCESS pProcess)
{
	PIMAGE_DOS_HEADER pDosHdr = (PIMAGE_DOS_HEADER)pBase;
	PIMAGE_NT_HEADERS32 pNtHdr32 = NULL;
	PIMAGE_NT_HEADERS64 pNtHdr64 = NULL;
	PIMAGE_EXPORT_DIRECTORY pExport = NULL;
	ULONG expSize = 0;
	ULONG_PTR pAddress = 0;

	ASSERT(pBase != NULL);
	if (pBase == NULL)
		return NULL;

	/// Not a PE file
	if (pDosHdr->e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	pNtHdr32 = (PIMAGE_NT_HEADERS32)((PUCHAR)pBase + pDosHdr->e_lfanew);
	pNtHdr64 = (PIMAGE_NT_HEADERS64)((PUCHAR)pBase + pDosHdr->e_lfanew);

	// Not a PE file
	if (pNtHdr32->Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	// 64 bit image
	if (pNtHdr32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
	{
		pExport = (PIMAGE_EXPORT_DIRECTORY)(pNtHdr64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)pBase);
		expSize = pNtHdr64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	}
	// 32 bit image
	else
	{
		pExport = (PIMAGE_EXPORT_DIRECTORY)(pNtHdr32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)pBase);
		expSize = pNtHdr32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	}

	PUSHORT pAddressOfOrds = (PUSHORT)(pExport->AddressOfNameOrdinals + (ULONG_PTR)pBase);
	PULONG  pAddressOfNames = (PULONG)(pExport->AddressOfNames + (ULONG_PTR)pBase);
	PULONG  pAddressOfFuncs = (PULONG)(pExport->AddressOfFunctions + (ULONG_PTR)pBase);

	for (ULONG i = 0; i < pExport->NumberOfFunctions; ++i)
	{
		USHORT OrdIndex = 0xFFFF;
		PCHAR  pName = NULL;

		// Find by index
		if ((ULONG_PTR)name_ord <= 0xFFFF)
		{
			OrdIndex = (USHORT)i;
		}
		// Find by name
		else if ((ULONG_PTR)name_ord > 0xFFFF && i < pExport->NumberOfNames)
		{
			pName = (PCHAR)(pAddressOfNames[i] + (ULONG_PTR)pBase);
			OrdIndex = pAddressOfOrds[i];
		}
		// Weird params
		else
			return NULL;

		if (((ULONG_PTR)name_ord <= 0xFFFF && (USHORT)((ULONG_PTR)name_ord) == OrdIndex + pExport->Base) ||
			((ULONG_PTR)name_ord > 0xFFFF && strcmp(pName, name_ord) == 0))
		{
			pAddress = pAddressOfFuncs[OrdIndex] + (ULONG_PTR)pBase;

			break;
		}
	}

	return (PVOID)pAddress;
}

NTSTATUS BBSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_INVALID_PARAMETER;

	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}
```

`detect_hide_process/global.hpp`:

```hpp
#pragma once
#include <ntifs.h>


typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

extern"C"
HANDLE
NTSYSAPI
PsGetProcessInheritedFromUniqueProcessId(PEPROCESS Process);

extern"C"
NTKERNELAPI
PPEB
NTAPI
PsGetProcessPeb(IN PEPROCESS Process);

HANDLE GetProcessIdByName(PWCHAR Name, PHANDLE ParentId);
NTSTATUS GetProcessByName(PWCHAR Name, PEPROCESS** Process,BOOLEAN FindAll = FALSE);
PVOID BBGetUserModule(IN PEPROCESS pProcess, IN PUNICODE_STRING ModuleName);
PVOID BBGetModuleExport(IN PVOID pBase, IN PCCHAR name_ord, IN PEPROCESS pProcess);
NTSTATUS BBSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound);
```