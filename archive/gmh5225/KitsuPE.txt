Project Path: arc_gmh5225_KitsuPE_19o9gqte

Source Tree:

```txt
arc_gmh5225_KitsuPE_19o9gqte
├── CMakeLists.txt
├── basic_applications
│   ├── CMakeLists.txt
│   ├── basic_c_application
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── main.h
│   ├── basic_cpp_application
│   │   ├── CMakeLists.txt
│   │   ├── main.cpp
│   │   ├── main.hpp
│   │   ├── pong.cpp
│   │   └── pong.hpp
│   ├── basic_gui_application
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── main.h
│   └── basic_library
│       ├── CMakeLists.txt
│       ├── include
│       │   └── basic_library
│       │       └── basic_library.h
│       ├── main.c
│       └── main.h
├── debug_tool
│   ├── CMakeLists.txt
│   ├── main.cpp
│   └── main.hpp
├── externals
│   └── fast-lzma2
├── foxylib
│   ├── CMakeLists.txt
│   ├── cmake-build-debug
│   │   ├── CMakeCache.txt
│   │   ├── CMakeFiles
│   │   │   ├── 3.24.2
│   │   │   │   ├── CMakeCCompiler.cmake
│   │   │   │   ├── CMakeDetermineCompilerABI_C.bin
│   │   │   │   ├── CMakeRCCompiler.cmake
│   │   │   │   ├── CMakeSystem.cmake
│   │   │   │   └── CompilerIdC
│   │   │   │       ├── CMakeCCompilerId.c
│   │   │   │       ├── CMakeCCompilerId.exe
│   │   │   │       └── CMakeCCompilerId.obj
│   │   │   ├── CMakeOutput.log
│   │   │   ├── ShowIncludes
│   │   │   │   ├── foo.h
│   │   │   │   ├── main.c
│   │   │   │   └── main.obj
│   │   │   ├── TargetDirectories.txt
│   │   │   ├── clion-Debug-log.txt
│   │   │   ├── clion-environment.txt
│   │   │   ├── cmake.check_cache
│   │   │   └── rules.ninja
│   │   ├── Testing
│   │   │   └── Temporary
│   │   │       └── LastTest.log
│   │   ├── build.ninja
│   │   └── cmake_install.cmake
│   ├── include
│   │   └── foxylib
│   │       ├── constants.h
│   │       ├── platform.h
│   │       ├── status.h
│   │       └── utils
│   │           ├── console
│   │           │   ├── commands.h
│   │           │   ├── console.h
│   │           │   └── types.h
│   │           ├── helpers.h
│   │           └── logging
│   │               ├── logging.h
│   │               ├── loglevel.h
│   │               └── types.h
│   └── utils
│       ├── console
│       │   ├── commands.c
│       │   └── console.c
│       ├── helpers.c
│       └── logging
│           └── logging.c
├── foxywinapi
│   ├── CMakeLists.txt
│   ├── foxywinapi.cpp
│   ├── foxywinapi.hpp
│   ├── lazy_importer.hpp
│   └── pe_file.hpp
├── pe_parser
│   ├── CMakeLists.txt
│   ├── main.cpp
│   └── old
│       ├── main.cpp
│       ├── main.hpp
│       └── pe
│           ├── pe_file.cpp
│           └── pe_file.hpp
├── pe_stub
│   ├── CMakeLists.txt
│   └── main.cpp
├── readme.md
├── shellcode
│   ├── CMakeLists.txt
│   ├── extract.py
│   ├── main.cpp
│   └── x64
│       ├── shellcode.bin
│       └── shellcode.bin.h
└── shellcode_test
    ├── CMakeLists.txt
    └── main.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.8)

project ("FoxyTools")

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

set(CXX_STANDARD 17)

include_directories("pe_shared")
add_compile_options(
        #"/Oi-" # de-activate intrinsic functions
        #"/O1" # disable whole-program optimizations
        #"-fno-builtin"
        "/O1"
)

# add lzma2 library (we build it here because it has no CMakeLists.txt)
set(LZMA2_DIR "externals/fast-lzma2")
add_library (lzma2 STATIC
        "${LZMA2_DIR}/dict_buffer.c" "${LZMA2_DIR}/fl2_common.c" "${LZMA2_DIR}/fl2_compress.c"
        "${LZMA2_DIR}/fl2_decompress.c" "${LZMA2_DIR}/fl2_pool.c" "${LZMA2_DIR}/fl2_threading.c"
        "${LZMA2_DIR}/lzma2_dec.c" "${LZMA2_DIR}/lzma2_enc.c" "${LZMA2_DIR}/radix_bitpack.c"
        "${LZMA2_DIR}/radix_mf.c" "${LZMA2_DIR}/radix_struct.c" "${LZMA2_DIR}/range_enc.c"
        "${LZMA2_DIR}/util.c" "${LZMA2_DIR}/xxhash.c")
target_include_directories(lzma2 PUBLIC "${LZMA2_DIR}")

add_subdirectory("pe_parser")

add_subdirectory("foxylib")
add_subdirectory("foxywinapi")
add_subdirectory("basic_applications")
add_subdirectory("debug_tool")


add_subdirectory("pe_stub")

add_subdirectory("shellcode")
add_subdirectory("shellcode_test")
```

`basic_applications/CMakeLists.txt`:

```txt
add_subdirectory("basic_c_application")
add_subdirectory("basic_cpp_application")
add_subdirectory("basic_gui_application")
add_subdirectory("basic_library")

```

`basic_applications/basic_c_application/CMakeLists.txt`:

```txt
set(PROJECT_NAME "basic_c_application")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES C)

add_executable(${PROJECT_NAME} "main.c" )
target_link_libraries(${PROJECT_NAME} foxylib)

```

`basic_applications/basic_c_application/main.c`:

```c
#include "main.h"

#define BUFFER_SIZE 2048
#define EXIT_PHRASE "go away"

//#include <foxylib/utils/console/status.h>
#include <foxylib/utils/logging/logging.h>


int main(int argc, char** argv) {
	// register SIGINT handler (CTRL+C)
	signal(SIGINT, sigint_handler);


    int ENABLED_LOG_LEVEL = FOXY_LOG_INFO | FOXY_LOG_WARNING | FOXY_LOG_DEBUG | FOXY_LOG_DEV;
    printf("LogLevel idx: %d, LogLevel naem: %s\n", ENABLED_LOG_LEVEL, FOXY_LOG_LEVEL_TAGS[ENABLED_LOG_LEVEL]);

    printf("ENABLED_LOG_LEVEL & FOXY_LOG_INFO = %d\n", ENABLED_LOG_LEVEL & FOXY_LOG_WARNING);

	printf("Henlo! I'm a smol and basic application written in C.\n");
	pong_loop();

	return 0;
}

void pong_loop() {
	// variables used
	char input_buffer[BUFFER_SIZE + 1];
	uint8_t is_running = 1;

	// start input loop
	while (is_running) {
		// clear input buffer
		memset(input_buffer, 0, BUFFER_SIZE + 1);

		// retrieve user input
		printf("\nTell me something (say \"%s\" and I'll stop): ", EXIT_PHRASE);
		fgets(input_buffer, BUFFER_SIZE, stdin);

		// remove any trailing newlines (LF, CR, CRLF and LFCR)
		input_buffer[strcspn(input_buffer, "\r\n")] = 0;

		// stop if user wants us to, otherwise repeat what he said
		if (strcmp(input_buffer, EXIT_PHRASE) == 0) {
			is_running = 0;
			printf("Oh noooo! Bai baii~ QwQ\n\n");
		} else if(strlen(input_buffer) > 0) {
			printf("That's what you said: %s\n", input_buffer);
		}
		
		sleep(10);
	}
}

void sigint_handler(int val)
{
	printf("\nOH NO OH NO HELP! WHY ARE YOU DOING THIS TO ME? :C\n");
	exit(val);
}

```

`basic_applications/basic_c_application/main.h`:

```h
#pragma once

#include <foxylib/platform.h>

#include <stdint.h>
#include <stdio.h>
#include <signal.h>


int main(int argc, char** argv);
void pong_loop();
void sigint_handler(int val);
```

`basic_applications/basic_cpp_application/CMakeLists.txt`:

```txt
set(PROJECT_NAME "basic_cpp_application")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)


add_executable(${PROJECT_NAME} "main.cpp" "pong.cpp")
target_link_libraries(${PROJECT_NAME} foxylib)

```

`basic_applications/basic_cpp_application/main.cpp`:

```cpp
#include "main.hpp"
#include "pong.hpp"





static const std::string EXIT_PHRASE = "go away";
pong app{ EXIT_PHRASE };

int main(int argc, char** argv) {
	// register SIGINT handler (CTRL+C)
	signal(SIGINT, sigint_handler);

	std::cout << "Henlo! I'm a smol and basic application written in C++.\n";

    //std::cout;
	//app.start_loop();

	return 0;
}

void sigint_handler(int val)
{
	app.stop_loop();
	std::cout << "\nOH NO OH NO HELP! WHY ARE YOU DOING THIS TO ME? :C\n";
	exit(val);
}

```

`basic_applications/basic_cpp_application/main.hpp`:

```hpp
#pragma once
#include <foxylib/platform.h>
#include <signal.h>

int main(int argc, char** argv);
void pong_loop();
void sigint_handler(int val);
```

`basic_applications/basic_cpp_application/pong.cpp`:

```cpp
#include "pong.hpp"

pong::pong(const std::string& exit_phrase) :
	m_is_running{ false },
	m_exit_phrase{ exit_phrase } {

}

pong::~pong() {

}

void pong::start_loop() {
	this->m_is_running = true;
	
	// start input loop
	while (this->m_is_running) {
		// variable used to store the user input
		std::string input_buffer{};

		// retrieve user input
		std::cout << "\nTell me something (say \"" << m_exit_phrase << "\" and I'll stop): ";
		std::getline(std::cin, input_buffer);

		// stop if user wants us to, otherwise repeat what he said
		if (input_buffer.compare(m_exit_phrase) == 0) {
			this->m_is_running = false;
			std::cout << "Oh noooo! Bai baii~ QwQ\n\n";
		} else if (input_buffer.length() > 0) {
			std::cout << "That's what you said: " << input_buffer << "\n";
		}

		sleep(10);
	}
}

void pong::stop_loop() {
	this->m_is_running = false;
}
```

`basic_applications/basic_cpp_application/pong.hpp`:

```hpp
#pragma once
#include <foxylib/platform.h>
#include <iostream>
#include <string>

class pong {
public:
	pong(const std::string& exit_phrase);
	~pong();

	void start_loop();
	void stop_loop();
private:
	bool m_is_running;
	std::string m_exit_phrase;
};
```

`basic_applications/basic_gui_application/CMakeLists.txt`:

```txt
set(PROJECT_NAME "basic_gui_application")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES C)

add_executable(${PROJECT_NAME} WIN32 "main.c" )
target_link_libraries(${PROJECT_NAME} foxylib basic_library)

```

`basic_applications/basic_gui_application/main.c`:

```c
#include "main.h"
#include <stdio.h>
#include <basic_library/basic_library.h>
#include <foxylib/utils/console/console.h>


static const char WINDOW_TEXT[] = "Henlo! UwU\nI'm an ugly Win32 API window";

#define BUTTON_ID_MSGBOX 1
#define BUTTON_ID_QUIT 2

#define BUTTON_WIDTH 150
#define BUTTON_HEIGHT 25
#define BUTTON_SPACING 10

HWND button_beep;
HWND button_quit;


int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PWSTR lpCmdLine, int nCmdShow) {

    console_init("test gui");
    console_start();


    MSG  msg;
    WNDCLASSW wc = { 0 };
    wc.lpszClassName = L"Basic Win32 API Window";
    wc.hInstance = hInstance;
    wc.hbrBackground = GetSysColorBrush(WHITE_BRUSH);
    wc.lpfnWndProc = WndProc;
    wc.hCursor = LoadCursor(0, IDC_ARROW);


    RegisterClassW(&wc);
    CreateWindowW(wc.lpszClassName, L"Basic Win32 API Forms Application",
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_VISIBLE,
        150, 150, 450, 150, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
    WPARAM wParam, LPARAM lParam) {

    PAINTSTRUCT ps;
    HDC hdc;
    RECT rect;
    RECT text_rect = { 0, 0, 0, 0 };
    RECT button_beep_rect = { 0, 0, 0, 0 }, button_quit_rect = { 0, 0, 0, 0 };

    GetClientRect(hwnd, &rect);


    switch (msg) {

    case WM_CREATE:
        button_beep = CreateWindowW(L"Button", L"Show MessageBox",
            WS_VISIBLE | WS_CHILD,
            0, 0, 0, 0, hwnd, (HMENU)BUTTON_ID_MSGBOX, NULL, NULL);

        button_quit = CreateWindowW(L"Button", L"Quit",
            WS_VISIBLE | WS_CHILD,
            0, 0, 0, 0, hwnd, (HMENU)BUTTON_ID_QUIT, NULL, NULL);



    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);

        HFONT hFont = CreateFont (16, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, ANSI_CHARSET,
                                  OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                  DEFAULT_PITCH | FF_DONTCARE, TEXT("Tahoma"));

        SelectObject(hdc, hFont);

        // text parameters
        SetTextColor(hdc, RGB(0x00, 0x00, 0x00));
        SetBkMode(hdc, TRANSPARENT);


        SendMessage(button_beep, WM_SETFONT, (WPARAM)hFont, TRUE);
        SendMessage(button_quit, WM_SETFONT, (WPARAM)hFont, TRUE);

        // calc text size + position
        DrawText(hdc, WINDOW_TEXT, -1, &text_rect, DT_CALCRECT);

        text_rect.top = (rect.bottom - text_rect.bottom - BUTTON_HEIGHT - BUTTON_SPACING) / 2;
        text_rect.left = (rect.right - text_rect.right) / 2;
        text_rect.right = text_rect.left + text_rect.right;
        text_rect.bottom = text_rect.top + text_rect.bottom;

        // calc button size + position
        button_beep_rect.left = (rect.right / 2) - BUTTON_WIDTH - BUTTON_SPACING / 2;
        button_beep_rect.top = (rect.bottom) / 2 + BUTTON_SPACING;
        button_quit_rect.left = (rect.right / 2) + BUTTON_SPACING / 2;
        button_quit_rect.top = (rect.bottom) / 2 + BUTTON_SPACING;

        // fill window background
        FillRect(hdc, &rect, (HBRUSH)GetStockObject(WHITE_BRUSH));

        // draw text
        DrawText(hdc, WINDOW_TEXT, -1, &text_rect, 0);

        // set button size + position
        SetWindowPos(button_beep, NULL, button_beep_rect.left, button_beep_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT, SWP_NOREDRAW);
        SetWindowPos(button_quit, NULL, button_quit_rect.left, button_quit_rect.top, BUTTON_WIDTH, BUTTON_HEIGHT, SWP_NOREDRAW);

        EndPaint(hwnd, &ps);
        break;
    case WM_EXITSIZEMOVE:
        InvalidateRect(hwnd, NULL, 1);
        break;
    case WM_COMMAND:

        if (LOWORD(wParam) == BUTTON_ID_MSGBOX) {

            MessageBeep(MB_OK);
            test_function_msgbox("This message box is created from a DLL");
        }

        if (LOWORD(wParam) == BUTTON_ID_QUIT) {
            MessageBox(hwnd, test_function_retval("lol lol"), "he", MB_OK);
            PostQuitMessage(0);
        }

        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
```

`basic_applications/basic_gui_application/main.h`:

```h
#pragma once

#include <foxylib/platform.h>

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow);
LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

```

`basic_applications/basic_library/CMakeLists.txt`:

```txt
set(PROJECT_NAME "basic_library")
project(${PROJECT_NAME} LANGUAGES C)

add_library(${PROJECT_NAME} SHARED "main.c")
target_include_directories(${PROJECT_NAME} PUBLIC "include")
target_link_libraries(${PROJECT_NAME} foxylib)

```

`basic_applications/basic_library/include/basic_library/basic_library.h`:

```h
__declspec(dllexport) void __cdecl test_function_msgbox(const char* text);
__declspec(dllexport) char* __cdecl test_function_retval(char* text);

```

`basic_applications/basic_library/main.c`:

```c
#include "main.h"

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        MessageBox(NULL, "Basic Library -> DllMain called! (DLL_PROCESS_ATTACH)", "Basic Library", MB_OK);
        break;

    case DLL_THREAD_ATTACH:
        //MessageBox(NULL, "Basic Library -> DllMain called! (DLL_THREAD_ATTACH)", "Basic Library", MB_OK);
        break;

    case DLL_THREAD_DETACH:
        //MessageBox(NULL, "Basic Library -> DllMain called! (DLL_THREAD_DETACH)", "Basic Library", MB_OK);
        break;

    case DLL_PROCESS_DETACH:
        MessageBox(NULL, "Basic Library -> DllMain called! (DLL_PROCESS_DETACH)", "Basic Library", MB_OK);
        break;
    }
    return TRUE;
}

void __cdecl test_function_msgbox(const char* text)
{
    MessageBox(NULL, text, "Basic Library (test_function_msgbox)", MB_OK);
}

char* __cdecl test_function_retval(char* text)
{
    char* return_value = "\0";
    sprintf(return_value, "Basic Library -> test_function_retval text parameter: %s", text);
    return return_value;
}

```

`basic_applications/basic_library/main.h`:

```h
#pragma once

#include <foxylib/platform.h>
#include "basic_library/basic_library.h"

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

```

`debug_tool/CMakeLists.txt`:

```txt
set(PROJECT_NAME "debug_tool")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} VERSION ${PROJECT_VERSION} LANGUAGES C CXX)

add_executable(${PROJECT_NAME} "main.cpp")


```

`debug_tool/main.cpp`:

```cpp
#include "main.hpp"

int main(int argc, char** argv) {
	std::cout << "FoxyTools Win32 Debug Tool says hello!\n";
	std::cin.get();

	return 0;
}
```

`debug_tool/main.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <iostream>

```

`foxylib/CMakeLists.txt`:

```txt
set(PROJECT_NAME "foxylib")

project(${PROJECT_NAME} LANGUAGES C)

add_library(${PROJECT_NAME} STATIC "utils/helpers.c" "utils/console/commands.c" "utils/console/console.c" "utils/logging/logging.c")
target_include_directories(${PROJECT_NAME} PUBLIC "include")
target_include_directories(${PROJECT_NAME} PRIVATE "include/foxylib")

```

`foxylib/cmake-build-debug/CMakeCache.txt`:

```txt
# This is the CMakeCache file.
# For build in directory: e:/Development/FoxyTools/foxylib/cmake-build-debug
# It was generated by CMake: C:/Program Files/JetBrains/CLion 2022.3.1/bin/cmake/win/bin/cmake.exe
# You can edit this file to change values found and used by cmake.
# If you do not want to change any of the values, simply exit the editor.
# If you do want to change a value, simply edit, save, and exit the editor.
# The syntax for the file is as follows:
# KEY:TYPE=VALUE
# KEY is the name of a variable in the cache.
# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.
# VALUE is the current value for the KEY.

########################
# EXTERNAL cache entries
########################

//Path to a program.
CMAKE_AR:FILEPATH=C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/lib.exe

//For backwards compatibility, what version of CMake commands and
// syntax should this version of CMake try to support.
CMAKE_BACKWARDS_COMPATIBILITY:STRING=2.4

//Choose the type of build, options are: None Debug Release RelWithDebInfo
// MinSizeRel ...
CMAKE_BUILD_TYPE:STRING=Debug

//Enable colored diagnostics throughout.
CMAKE_COLOR_DIAGNOSTICS:BOOL=ON

//C compiler
CMAKE_C_COMPILER:FILEPATH=C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/cl.exe

//Flags used by the C compiler during all build types.
CMAKE_C_FLAGS:STRING=/DWIN32 /D_WINDOWS /W3

//Flags used by the C compiler during DEBUG builds.
CMAKE_C_FLAGS_DEBUG:STRING=/MDd /Zi /Ob0 /Od /RTC1

//Flags used by the C compiler during MINSIZEREL builds.
CMAKE_C_FLAGS_MINSIZEREL:STRING=/MD /O1 /Ob1 /DNDEBUG

//Flags used by the C compiler during RELEASE builds.
CMAKE_C_FLAGS_RELEASE:STRING=/MD /O2 /Ob2 /DNDEBUG

//Flags used by the C compiler during RELWITHDEBINFO builds.
CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=/MD /Zi /O2 /Ob1 /DNDEBUG

//Libraries linked by default with all C applications.
CMAKE_C_STANDARD_LIBRARIES:STRING=kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib

//Flags used by the linker during all build types.
CMAKE_EXE_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during DEBUG builds.
CMAKE_EXE_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during MINSIZEREL builds.
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during RELEASE builds.
CMAKE_EXE_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during RELWITHDEBINFO builds.
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//Enable/Disable output of compile commands during generation.
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=

//Value Computed by CMake.
CMAKE_FIND_PACKAGE_REDIRECTS_DIR:STATIC=E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/pkgRedirects

//Install path prefix, prepended onto install directories.
CMAKE_INSTALL_PREFIX:PATH=C:/Program Files (x86)/foxylib

//Path to a program.
CMAKE_LINKER:FILEPATH=C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/link.exe

//make program
CMAKE_MAKE_PROGRAM:FILEPATH=C:/Program Files/JetBrains/CLion 2022.3.1/bin/ninja/win/ninja.exe

//Flags used by the linker during the creation of modules during
// all build types.
CMAKE_MODULE_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during the creation of modules during
// DEBUG builds.
CMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during the creation of modules during
// MINSIZEREL builds.
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of modules during
// RELEASE builds.
CMAKE_MODULE_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of modules during
// RELWITHDEBINFO builds.
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//Path to a program.
CMAKE_MT:FILEPATH=C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/mt.exe

//Value Computed by CMake
CMAKE_PROJECT_DESCRIPTION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_HOMEPAGE_URL:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_NAME:STATIC=foxylib

//RC compiler
CMAKE_RC_COMPILER:FILEPATH=C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/rc.exe

//Flags for Windows Resource Compiler during all build types.
CMAKE_RC_FLAGS:STRING=-DWIN32

//Flags for Windows Resource Compiler during DEBUG builds.
CMAKE_RC_FLAGS_DEBUG:STRING=-D_DEBUG

//Flags for Windows Resource Compiler during MINSIZEREL builds.
CMAKE_RC_FLAGS_MINSIZEREL:STRING=

//Flags for Windows Resource Compiler during RELEASE builds.
CMAKE_RC_FLAGS_RELEASE:STRING=

//Flags for Windows Resource Compiler during RELWITHDEBINFO builds.
CMAKE_RC_FLAGS_RELWITHDEBINFO:STRING=

//Flags used by the linker during the creation of shared libraries
// during all build types.
CMAKE_SHARED_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during the creation of shared libraries
// during DEBUG builds.
CMAKE_SHARED_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during the creation of shared libraries
// during MINSIZEREL builds.
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of shared libraries
// during RELEASE builds.
CMAKE_SHARED_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of shared libraries
// during RELWITHDEBINFO builds.
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//If set, runtime paths are not added when installing shared libraries,
// but are added when building.
CMAKE_SKIP_INSTALL_RPATH:BOOL=NO

//If set, runtime paths are not added when using shared libraries.
CMAKE_SKIP_RPATH:BOOL=NO

//Flags used by the linker during the creation of static libraries
// during all build types.
CMAKE_STATIC_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during the creation of static libraries
// during DEBUG builds.
CMAKE_STATIC_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of static libraries
// during MINSIZEREL builds.
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of static libraries
// during RELEASE builds.
CMAKE_STATIC_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of static libraries
// during RELWITHDEBINFO builds.
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//If this value is on, makefiles will be generated without the
// .SILENT directive, and all commands will be echoed to the console
// during the make.  This is useful for debugging only. With Visual
// Studio IDE projects all commands are done without /nologo.
CMAKE_VERBOSE_MAKEFILE:BOOL=FALSE

//Single output directory for building all executables.
EXECUTABLE_OUTPUT_PATH:PATH=

//Single output directory for building all libraries.
LIBRARY_OUTPUT_PATH:PATH=

//Value Computed by CMake
foxylib_BINARY_DIR:STATIC=E:/Development/FoxyTools/foxylib/cmake-build-debug

//Value Computed by CMake
foxylib_IS_TOP_LEVEL:STATIC=ON

//Value Computed by CMake
foxylib_SOURCE_DIR:STATIC=E:/Development/FoxyTools/foxylib


########################
# INTERNAL cache entries
########################

//ADVANCED property for variable: CMAKE_AR
CMAKE_AR-ADVANCED:INTERNAL=1
//This is the directory where this CMakeCache.txt was created
CMAKE_CACHEFILE_DIR:INTERNAL=e:/Development/FoxyTools/foxylib/cmake-build-debug
//Major version of cmake used to create the current loaded cache
CMAKE_CACHE_MAJOR_VERSION:INTERNAL=3
//Minor version of cmake used to create the current loaded cache
CMAKE_CACHE_MINOR_VERSION:INTERNAL=24
//Patch version of cmake used to create the current loaded cache
CMAKE_CACHE_PATCH_VERSION:INTERNAL=2
//Path to CMake executable.
CMAKE_COMMAND:INTERNAL=C:/Program Files/JetBrains/CLion 2022.3.1/bin/cmake/win/bin/cmake.exe
//Path to cpack program executable.
CMAKE_CPACK_COMMAND:INTERNAL=C:/Program Files/JetBrains/CLion 2022.3.1/bin/cmake/win/bin/cpack.exe
//Path to ctest program executable.
CMAKE_CTEST_COMMAND:INTERNAL=C:/Program Files/JetBrains/CLion 2022.3.1/bin/cmake/win/bin/ctest.exe
//ADVANCED property for variable: CMAKE_C_COMPILER
CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS
CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_DEBUG
CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_MINSIZEREL
CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELEASE
CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELWITHDEBINFO
CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_STANDARD_LIBRARIES
CMAKE_C_STANDARD_LIBRARIES-ADVANCED:INTERNAL=1
//Executable file format
CMAKE_EXECUTABLE_FORMAT:INTERNAL=Unknown
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG
CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE
CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXPORT_COMPILE_COMMANDS
CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
//Name of external makefile project generator.
CMAKE_EXTRA_GENERATOR:INTERNAL=
//Name of generator.
CMAKE_GENERATOR:INTERNAL=Ninja
//Generator instance identifier.
CMAKE_GENERATOR_INSTANCE:INTERNAL=
//Name of generator platform.
CMAKE_GENERATOR_PLATFORM:INTERNAL=
//Name of generator toolset.
CMAKE_GENERATOR_TOOLSET:INTERNAL=
//Source directory with the top level CMakeLists.txt file for this
// project
CMAKE_HOME_DIRECTORY:INTERNAL=E:/Development/FoxyTools/foxylib
//ADVANCED property for variable: CMAKE_LINKER
CMAKE_LINKER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG
CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE
CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MT
CMAKE_MT-ADVANCED:INTERNAL=1
//number of local generators
CMAKE_NUMBER_OF_MAKEFILES:INTERNAL=1
//Platform information initialized
CMAKE_PLATFORM_INFO_INITIALIZED:INTERNAL=1
//noop for ranlib
CMAKE_RANLIB:INTERNAL=:
//ADVANCED property for variable: CMAKE_RC_COMPILER
CMAKE_RC_COMPILER-ADVANCED:INTERNAL=1
CMAKE_RC_COMPILER_WORKS:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS
CMAKE_RC_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_DEBUG
CMAKE_RC_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_MINSIZEREL
CMAKE_RC_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_RELEASE
CMAKE_RC_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_RELWITHDEBINFO
CMAKE_RC_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//Path to CMake installation.
CMAKE_ROOT:INTERNAL=C:/Program Files/JetBrains/CLion 2022.3.1/bin/cmake/win/share/cmake-3.24
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG
CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE
CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH
CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_RPATH
CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS
CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG
CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE
CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE
CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1


```

`foxylib/cmake-build-debug/CMakeFiles/3.24.2/CMakeCCompiler.cmake`:

```cmake
set(CMAKE_C_COMPILER "C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/cl.exe")
set(CMAKE_C_COMPILER_ARG1 "")
set(CMAKE_C_COMPILER_ID "MSVC")
set(CMAKE_C_COMPILER_VERSION "19.31.31104.0")
set(CMAKE_C_COMPILER_VERSION_INTERNAL "")
set(CMAKE_C_COMPILER_WRAPPER "")
set(CMAKE_C_STANDARD_COMPUTED_DEFAULT "90")
set(CMAKE_C_EXTENSIONS_COMPUTED_DEFAULT "OFF")
set(CMAKE_C_COMPILE_FEATURES "c_std_90;c_function_prototypes;c_std_99;c_restrict;c_variadic_macros;c_std_11;c_static_assert;c_std_17")
set(CMAKE_C90_COMPILE_FEATURES "c_std_90;c_function_prototypes")
set(CMAKE_C99_COMPILE_FEATURES "c_std_99;c_restrict;c_variadic_macros")
set(CMAKE_C11_COMPILE_FEATURES "c_std_11;c_static_assert")
set(CMAKE_C17_COMPILE_FEATURES "c_std_17")
set(CMAKE_C23_COMPILE_FEATURES "")

set(CMAKE_C_PLATFORM_ID "Windows")
set(CMAKE_C_SIMULATE_ID "")
set(CMAKE_C_COMPILER_FRONTEND_VARIANT "")
set(CMAKE_C_SIMULATE_VERSION "")
set(CMAKE_C_COMPILER_ARCHITECTURE_ID x64)

set(MSVC_C_ARCHITECTURE_ID x64)

set(CMAKE_AR "C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/lib.exe")
set(CMAKE_C_COMPILER_AR "")
set(CMAKE_RANLIB ":")
set(CMAKE_C_COMPILER_RANLIB "")
set(CMAKE_LINKER "C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/link.exe")
set(CMAKE_MT "C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/mt.exe")
set(CMAKE_COMPILER_IS_GNUCC )
set(CMAKE_C_COMPILER_LOADED 1)
set(CMAKE_C_COMPILER_WORKS TRUE)
set(CMAKE_C_ABI_COMPILED TRUE)

set(CMAKE_C_COMPILER_ENV_VAR "CC")

set(CMAKE_C_COMPILER_ID_RUN 1)
set(CMAKE_C_SOURCE_FILE_EXTENSIONS c;m)
set(CMAKE_C_IGNORE_EXTENSIONS h;H;o;O;obj;OBJ;def;DEF;rc;RC)
set(CMAKE_C_LINKER_PREFERENCE 10)

# Save compiler ABI information.
set(CMAKE_C_SIZEOF_DATA_PTR "8")
set(CMAKE_C_COMPILER_ABI "")
set(CMAKE_C_BYTE_ORDER "LITTLE_ENDIAN")
set(CMAKE_C_LIBRARY_ARCHITECTURE "")

if(CMAKE_C_SIZEOF_DATA_PTR)
  set(CMAKE_SIZEOF_VOID_P "${CMAKE_C_SIZEOF_DATA_PTR}")
endif()

if(CMAKE_C_COMPILER_ABI)
  set(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_C_COMPILER_ABI}")
endif()

if(CMAKE_C_LIBRARY_ARCHITECTURE)
  set(CMAKE_LIBRARY_ARCHITECTURE "")
endif()

set(CMAKE_C_CL_SHOWINCLUDES_PREFIX "Hinweis: Einlesen der Datei: ")
if(CMAKE_C_CL_SHOWINCLUDES_PREFIX)
  set(CMAKE_CL_SHOWINCLUDES_PREFIX "${CMAKE_C_CL_SHOWINCLUDES_PREFIX}")
endif()





set(CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES "")
set(CMAKE_C_IMPLICIT_LINK_LIBRARIES "")
set(CMAKE_C_IMPLICIT_LINK_DIRECTORIES "")
set(CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES "")

```

`foxylib/cmake-build-debug/CMakeFiles/3.24.2/CMakeRCCompiler.cmake`:

```cmake
set(CMAKE_RC_COMPILER "C:/Program Files (x86)/Windows Kits/10/bin/10.0.19041.0/x64/rc.exe")
set(CMAKE_RC_COMPILER_ARG1 "")
set(CMAKE_RC_COMPILER_LOADED 1)
set(CMAKE_RC_SOURCE_FILE_EXTENSIONS rc;RC)
set(CMAKE_RC_OUTPUT_EXTENSION .res)
set(CMAKE_RC_COMPILER_ENV_VAR "RC")

```

`foxylib/cmake-build-debug/CMakeFiles/3.24.2/CMakeSystem.cmake`:

```cmake
set(CMAKE_HOST_SYSTEM "Windows-10.0.22000")
set(CMAKE_HOST_SYSTEM_NAME "Windows")
set(CMAKE_HOST_SYSTEM_VERSION "10.0.22000")
set(CMAKE_HOST_SYSTEM_PROCESSOR "AMD64")



set(CMAKE_SYSTEM "Windows-10.0.22000")
set(CMAKE_SYSTEM_NAME "Windows")
set(CMAKE_SYSTEM_VERSION "10.0.22000")
set(CMAKE_SYSTEM_PROCESSOR "AMD64")

set(CMAKE_CROSSCOMPILING "FALSE")

set(CMAKE_SYSTEM_LOADED 1)

```

`foxylib/cmake-build-debug/CMakeFiles/3.24.2/CompilerIdC/CMakeCCompilerId.c`:

```c
#ifdef __cplusplus
# error "A C++ compiler has been selected for C."
#endif

#if defined(__18CXX)
# define ID_VOID_MAIN
#endif
#if defined(__CLASSIC_C__)
/* cv-qualifiers did not exist in K&R C */
# define const
# define volatile
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_C)
# define COMPILER_ID "SunPro"
# if __SUNPRO_C >= 0x5100
   /* __SUNPRO_C = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# endif

#elif defined(__HP_cc)
# define COMPILER_ID "HP"
  /* __HP_cc = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)

#elif defined(__DECC)
# define COMPILER_ID "Compaq"
  /* __DECC_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)

#elif defined(__IBMC__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
# define COMPILER_ID "XL"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TINYC__)
# define COMPILER_ID "TinyCC"

#elif defined(__BCC__)
# define COMPILER_ID "Bruce"

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(1)
# if defined(__LCC__)
#  define COMPILER_VERSION_MINOR DEC(__LCC__- 100)
# endif
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"
# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif

#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)
# define COMPILER_ID "SDCC"
# if defined(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
# else
  /* SDCC = VRP */
#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#if !defined(__STDC__) && !defined(__clang__)
# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)
#  define C_VERSION "90"
# else
#  define C_VERSION
# endif
#elif __STDC_VERSION__ > 201710L
# define C_VERSION "23"
#elif __STDC_VERSION__ >= 201710L
# define C_VERSION "17"
#elif __STDC_VERSION__ >= 201000L
# define C_VERSION "11"
#elif __STDC_VERSION__ >= 199901L
# define C_VERSION "99"
#else
# define C_VERSION "90"
#endif
const char* info_language_standard_default =
  "INFO" ":" "standard_default[" C_VERSION "]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

#ifdef ID_VOID_MAIN
void main() {}
#else
# if defined(__CLASSIC_C__)
int main(argc, argv) int argc; char *argv[];
# else
int main(int argc, char* argv[])
# endif
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}
#endif

```

`foxylib/cmake-build-debug/CMakeFiles/CMakeOutput.log`:

```log
The system is: Windows - 10.0.22000 - AMD64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/cl.exe 
Build flags: 
Id flags:  

The output was:
0
Microsoft (R) C/C++-Optimierungscompiler Version 19.31.31104 für x64
Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.

CMakeCCompilerId.c
Microsoft (R) Incremental Linker Version 14.31.31104.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:CMakeCCompilerId.exe 
CMakeCCompilerId.obj 


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "CMakeCCompilerId.exe"

Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "CMakeCCompilerId.obj"

The C compiler identification is MSVC, found in "E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/3.24.2/CompilerIdC/CMakeCCompilerId.exe"

Detecting C compiler ABI info compiled with the following output:
Change Dir: E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/CMakeTmp

Run Build Command(s):C:/Program Files/JetBrains/CLion 2022.3.1/bin/ninja/win/ninja.exe cmTC_9a774 && [1/2] Building C object CMakeFiles\cmTC_9a774.dir\CMakeCCompilerABI.c.obj
[2/2] Linking C executable cmTC_9a774.exe




```

`foxylib/cmake-build-debug/CMakeFiles/ShowIncludes/main.c`:

```c
#include "foo.h" 
int main(){}

```

`foxylib/cmake-build-debug/CMakeFiles/TargetDirectories.txt`:

```txt
E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/foxylib.dir
E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/edit_cache.dir
E:/Development/FoxyTools/foxylib/cmake-build-debug/CMakeFiles/rebuild_cache.dir

```

`foxylib/cmake-build-debug/CMakeFiles/clion-Debug-log.txt`:

```txt
"C:\Program Files\JetBrains\CLion 2022.3.1\bin\cmake\win\bin\cmake.exe" -DCMAKE_BUILD_TYPE=Debug "-DCMAKE_MAKE_PROGRAM=C:/Program Files/JetBrains/CLion 2022.3.1/bin/ninja/win/ninja.exe" -G Ninja -S E:\Development\FoxyTools\foxylib -B E:\Development\FoxyTools\foxylib\cmake-build-debug
-- The C compiler identification is MSVC 19.31.31104.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.31.31103/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
CMake Warning (dev) in CMakeLists.txt:
  No cmake_minimum_required command is present.  A line of code such as

    cmake_minimum_required(VERSION 3.24)

  should be added at the top of the file.  The version specified may be lower
  if you wish to support older CMake versions for this project.  For more
  information run "cmake --help-policy CMP0000".
This warning is for project developers.  Use -Wno-dev to suppress it.

-- Configuring done
-- Generating done
-- Build files have been written to: E:/Development/FoxyTools/foxylib/cmake-build-debug

```

`foxylib/cmake-build-debug/CMakeFiles/clion-environment.txt`:

```txt
ToolSet: 17.0 (local)@C:\Program Files\Microsoft Visual Studio\2022\Professional
Options: msvc.arch=amd64

Options:-DCMAKE_MAKE_PROGRAM=C:/Program Files/JetBrains/CLion 2022.3.1/bin/ninja/win/ninja.exe
```

`foxylib/cmake-build-debug/CMakeFiles/cmake.check_cache`:

```check_cache
# This file is generated by cmake for dependency checking of the CMakeCache.txt file

```

`foxylib/cmake-build-debug/CMakeFiles/rules.ninja`:

```ninja
# CMAKE generated file: DO NOT EDIT!
# Generated by "Ninja" Generator, CMake Version 3.24

# This file contains all the rules used to get the outputs files
# built from the input files.
# It is included in the main 'build.ninja'.

# =============================================================================
# Project: foxylib
# Configurations: Debug
# =============================================================================
# =============================================================================

#############################################
# localized /showIncludes string

msvc_deps_prefix = Hinweis: Einlesen der Datei: 


#############################################
# Rule for compiling C files.

rule C_COMPILER__foxylib_Debug
  deps = msvc
  command = C:\PROGRA~1\MICROS~2\2022\PROFES~1\VC\Tools\MSVC\1431~1.311\bin\Hostx64\x64\cl.exe  /nologo $DEFINES $INCLUDES $FLAGS /showIncludes /Fo$out /Fd$TARGET_COMPILE_PDB /FS -c $in
  description = Building C object $out


#############################################
# Rule for linking C static library.

rule C_STATIC_LIBRARY_LINKER__foxylib_Debug
  command = cmd.exe /C "$PRE_LINK && C:\PROGRA~1\MICROS~2\2022\PROFES~1\VC\Tools\MSVC\1431~1.311\bin\Hostx64\x64\lib.exe /nologo $LINK_FLAGS /out:$TARGET_FILE $in  && $POST_BUILD"
  description = Linking C static library $TARGET_FILE
  restat = $RESTAT


#############################################
# Rule for running custom commands.

rule CUSTOM_COMMAND
  command = $COMMAND
  description = $DESC


#############################################
# Rule for re-running cmake.

rule RERUN_CMAKE
  command = "C:\Program Files\JetBrains\CLion 2022.3.1\bin\cmake\win\bin\cmake.exe" --regenerate-during-build -SE:\Development\FoxyTools\foxylib -BE:\Development\FoxyTools\foxylib\cmake-build-debug
  description = Re-running CMake...
  generator = 1


#############################################
# Rule for cleaning all built files.

rule CLEAN
  command = "C:\Program Files\JetBrains\CLion 2022.3.1\bin\ninja\win\ninja.exe" $FILE_ARG -t clean $TARGETS
  description = Cleaning all built files...


#############################################
# Rule for printing all primary targets available.

rule HELP
  command = "C:\Program Files\JetBrains\CLion 2022.3.1\bin\ninja\win\ninja.exe" -t targets
  description = All primary targets available:


```

`foxylib/cmake-build-debug/Testing/Temporary/LastTest.log`:

```log
Start testing: Jan 18 05:27 Mitteleuropäische Zeit
----------------------------------------------------------
End testing: Jan 18 05:27 Mitteleuropäische Zeit

```

`foxylib/cmake-build-debug/build.ninja`:

```ninja
# CMAKE generated file: DO NOT EDIT!
# Generated by "Ninja" Generator, CMake Version 3.24

# This file contains all the build statements describing the
# compilation DAG.

# =============================================================================
# Write statements declared in CMakeLists.txt:
# 
# Which is the root file.
# =============================================================================

# =============================================================================
# Project: foxylib
# Configurations: Debug
# =============================================================================

#############################################
# Minimal version of Ninja required by this file

ninja_required_version = 1.5


#############################################
# Set configuration variable for custom commands.

CONFIGURATION = Debug
# =============================================================================
# Include auxiliary files.


#############################################
# Include rules file.

include CMakeFiles\rules.ninja

# =============================================================================

#############################################
# Logical path to working directory; prefix for absolute paths.

cmake_ninja_workdir = E$:\Development\FoxyTools\foxylib\cmake-build-debug\
# =============================================================================
# Object build statements for STATIC_LIBRARY target foxylib


#############################################
# Order-only phony target for foxylib

build cmake_object_order_depends_target_foxylib: phony || CMakeFiles\foxylib.dir

build CMakeFiles\foxylib.dir\debug_console.obj: C_COMPILER__foxylib_Debug E$:\Development\FoxyTools\foxylib\debug_console.c || cmake_object_order_depends_target_foxylib
  FLAGS = /DWIN32 /D_WINDOWS /W3 /MDd /Zi /Ob0 /Od /RTC1
  INCLUDES = -IE:\Development\FoxyTools\foxylib\include -IE:\Development\FoxyTools\foxylib\include\foxylib
  OBJECT_DIR = CMakeFiles\foxylib.dir
  OBJECT_FILE_DIR = CMakeFiles\foxylib.dir
  TARGET_COMPILE_PDB = CMakeFiles\foxylib.dir\foxylib.pdb
  TARGET_PDB = foxylib.pdb


# =============================================================================
# Link build statements for STATIC_LIBRARY target foxylib


#############################################
# Link the static library foxylib.lib

build foxylib.lib: C_STATIC_LIBRARY_LINKER__foxylib_Debug CMakeFiles\foxylib.dir\debug_console.obj
  LANGUAGE_COMPILE_FLAGS = /DWIN32 /D_WINDOWS /W3 /MDd /Zi /Ob0 /Od /RTC1
  LINK_FLAGS = /machine:x64
  OBJECT_DIR = CMakeFiles\foxylib.dir
  POST_BUILD = cd .
  PRE_LINK = cd .
  TARGET_COMPILE_PDB = CMakeFiles\foxylib.dir\foxylib.pdb
  TARGET_FILE = foxylib.lib
  TARGET_PDB = foxylib.pdb


#############################################
# Utility command for edit_cache

build CMakeFiles\edit_cache.util: CUSTOM_COMMAND
  COMMAND = cmd.exe /C "cd /D E:\Development\FoxyTools\foxylib\cmake-build-debug && "C:\Program Files\JetBrains\CLion 2022.3.1\bin\cmake\win\bin\cmake.exe" -E echo "No interactive CMake dialog available.""
  DESC = No interactive CMake dialog available...
  restat = 1

build edit_cache: phony CMakeFiles\edit_cache.util


#############################################
# Utility command for rebuild_cache

build CMakeFiles\rebuild_cache.util: CUSTOM_COMMAND
  COMMAND = cmd.exe /C "cd /D E:\Development\FoxyTools\foxylib\cmake-build-debug && "C:\Program Files\JetBrains\CLion 2022.3.1\bin\cmake\win\bin\cmake.exe" --regenerate-during-build -SE:\Development\FoxyTools\foxylib -BE:\Development\FoxyTools\foxylib\cmake-build-debug"
  DESC = Running CMake to regenerate build system...
  pool = console
  restat = 1

build rebuild_cache: phony CMakeFiles\rebuild_cache.util

# =============================================================================
# Target aliases.

build foxylib: phony foxylib.lib

# =============================================================================
# Folder targets.

# =============================================================================

#############################################
# Folder: E:/Development/FoxyTools/foxylib/cmake-build-debug

build all: phony foxylib.lib

# =============================================================================
# Unknown Build Time Dependencies.
# Tell Ninja that they may appear as side effects of build rules
# otherwise ordered by order-only dependencies.

# =============================================================================
# Built-in targets


#############################################
# Re-run CMake if any of its inputs changed.

build build.ninja: RERUN_CMAKE | C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCCompiler.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCCompilerABI.c C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCommonLanguageInclude.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCompilerIdDetection.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompileFeatures.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompilerABI.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompilerId.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineRCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineSystem.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeFindBinUtils.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeGenericSystem.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeInitializeConfigs.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeLanguageInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseImplicitIncludeInfo.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseImplicitLinkInfo.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseLibraryArchitecture.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeRCCompiler.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeRCInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystem.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystemSpecificInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystemSpecificInitialize.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestCompilerCommon.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestRCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ADSP-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ARMCC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ARMClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\AppleClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Borland-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Bruce-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\CMakeCommonCompilerMacros.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Clang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Clang-DetermineCompilerInternal.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Compaq-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Cray-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Embarcadero-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Fujitsu-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\FujitsuClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\GHS-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\GNU-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\HP-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IAR-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IBMCPP-C-DetermineVersionInternal.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IBMClang-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Intel-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IntelLLVM-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\LCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC-C.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\NVHPC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\NVIDIA-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\OpenWatcom-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\PGI-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\PathScale-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SCO-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SDCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SunPro-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\TI-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\TinyCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\VisualAge-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Watcom-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\XL-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\XLClang-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\zOS-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Internal\FeatureTesting.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows-MSVC-C.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows-MSVC.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\WindowsPaths.cmake CMakeCache.txt CMakeFiles\3.24.2\CMakeCCompiler.cmake CMakeFiles\3.24.2\CMakeRCCompiler.cmake CMakeFiles\3.24.2\CMakeSystem.cmake E$:\Development\FoxyTools\foxylib\CMakeLists.txt
  pool = console


#############################################
# A missing CMake input file is not an error.

build C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCCompiler.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCCompilerABI.c C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCommonLanguageInclude.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeCompilerIdDetection.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompileFeatures.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompilerABI.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineCompilerId.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineRCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeDetermineSystem.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeFindBinUtils.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeGenericSystem.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeInitializeConfigs.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeLanguageInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseImplicitIncludeInfo.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseImplicitLinkInfo.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeParseLibraryArchitecture.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeRCCompiler.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeRCInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystem.cmake.in C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystemSpecificInformation.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeSystemSpecificInitialize.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestCompilerCommon.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\CMakeTestRCCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ADSP-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ARMCC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\ARMClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\AppleClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Borland-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Bruce-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\CMakeCommonCompilerMacros.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Clang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Clang-DetermineCompilerInternal.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Compaq-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Cray-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Embarcadero-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Fujitsu-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\FujitsuClang-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\GHS-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\GNU-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\HP-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IAR-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IBMCPP-C-DetermineVersionInternal.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IBMClang-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Intel-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\IntelLLVM-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\LCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC-C.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\MSVC.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\NVHPC-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\NVIDIA-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\OpenWatcom-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\PGI-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\PathScale-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SCO-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SDCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\SunPro-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\TI-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\TinyCC-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\VisualAge-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\Watcom-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\XL-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\XLClang-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Compiler\zOS-C-DetermineCompiler.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Internal\FeatureTesting.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows-MSVC-C.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows-MSVC.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\Windows.cmake C$:\Program$ Files\JetBrains\CLion$ 2022.3.1\bin\cmake\win\share\cmake-3.24\Modules\Platform\WindowsPaths.cmake CMakeCache.txt CMakeFiles\3.24.2\CMakeCCompiler.cmake CMakeFiles\3.24.2\CMakeRCCompiler.cmake CMakeFiles\3.24.2\CMakeSystem.cmake E$:\Development\FoxyTools\foxylib\CMakeLists.txt: phony


#############################################
# Clean all the built files.

build clean: CLEAN


#############################################
# Print all primary targets available.

build help: HELP


#############################################
# Make the all target the default.

default all

```

`foxylib/cmake-build-debug/cmake_install.cmake`:

```cmake
# Install script for directory: E:/Development/FoxyTools/foxylib

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "C:/Program Files (x86)/foxylib")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Debug")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()

if(CMAKE_INSTALL_COMPONENT)
  set(CMAKE_INSTALL_MANIFEST "install_manifest_${CMAKE_INSTALL_COMPONENT}.txt")
else()
  set(CMAKE_INSTALL_MANIFEST "install_manifest.txt")
endif()

string(REPLACE ";" "\n" CMAKE_INSTALL_MANIFEST_CONTENT
       "${CMAKE_INSTALL_MANIFEST_FILES}")
file(WRITE "E:/Development/FoxyTools/foxylib/cmake-build-debug/${CMAKE_INSTALL_MANIFEST}"
     "${CMAKE_INSTALL_MANIFEST_CONTENT}")

```

`foxylib/include/foxylib/constants.h`:

```h
#pragma once

#define MAX_WINDOW_TITLE 256
#define MAX_INPUT_BUFFER 4096

#define DEFAULT_FORMAT_STRING_BUFFER_SIZE 32
```

`foxylib/include/foxylib/platform.h`:

```h
#pragma once

#ifdef _WIN32
#include <windows.h>
#define sleep(x) Sleep(x)
#else
#include <unistd.h>
#endif

#ifndef __cplusplus
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#endif

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

```

`foxylib/include/foxylib/status.h`:

```h
#ifndef FOXYTOOLS_STATUS_H
#define FOXYTOOLS_STATUS_H

// status code classification type
enum FOXY_STATUS_TYPE {
    STATUS_TYPE_OK = 0,
    STATUS_TYPE_ERROR = 1
} typedef foxy_status_type_t;

// table containing all foxylib status codes
#define FOXY_STATUS_CODE_TABLE \
/* X(status code name, value, status type, description) */ \
/* general status codes */ \
X(FOXY_STATUS_SUCCESS, 0x00, STATUS_TYPE_OK, "success") \
X(FOXY_STATUS_ERROR, 0x01, STATUS_TYPE_ERROR, "error") \
X(FOXY_STATUS_ERROR_C_LIB_FUNC, 0x02, STATUS_TYPE_ERROR, "failure while executing native c function") \
/* logging status codes */ \
X(FOXY_LOGGING_FILE_CREATED, 0x50, STATUS_TYPE_OK, "created log file") \
X(FOXY_LOGGING_STARTED, 0x51, STATUS_TYPE_OK, "started logging") \
X(FOXY_LOGGING_STOPPED, 0x52, STATUS_TYPE_OK, "stopped logging") \
X(FOXY_LOGGING_ERROR_FILE_CREATION, 0x55, STATUS_TYPE_ERROR, "failed to create log file") \
X(FOXY_LOGGING_ERROR_FILE_NAME_GENERATION, 0x56, STATUS_TYPE_ERROR, "failed to generate log file name")  \
X(FOXY_LOGGING_ERROR_MODULE_ALREADY_EXISTS, 0x57, STATUS_TYPE_ERROR, "the requested log module already exists") \
X(FOXY_LOGGING_ERROR_MODULE_FAILED_TO_CREATE, 0x58, STATUS_TYPE_ERROR, "failed to create the logging module")  \
X(FOXY_LOGGING_ERROR_FILE_ALREADY_EXISTS, 0x59, STATUS_TYPE_ERROR, "failed to format log entry")  \
X(FOXY_LOGGING_ERROR_ENTRY_FORMATTING, 0x60, STATUS_TYPE_ERROR, "failed to format log entry")  \
/* console status codes */ \
X(FOXY_CONSOLE_INITIALIZED, 0x100, STATUS_TYPE_OK, "console context initialized") \
X(FOXY_CONSOLE_THREAD_STARTED, 0x101, STATUS_TYPE_OK, "console processing thread started successfully") \
X(FOXY_CONSOLE_THREAD_STOPPED, 0x102, STATUS_TYPE_OK, "console processing thread stopped") \
X(FOXY_CONSOLE_COMMAND_ADDED, 0x103, STATUS_TYPE_OK, "command added successfully") \
X(FOXY_CONSOLE_COMMAND_EXECUTED, 0x104, STATUS_TYPE_OK, "successfully executed command") \
X(FOXY_CONSOLE_UNLOADED, 0x105, STATUS_TYPE_OK, "console has been unloaded") \
X(FOXY_CONSOLE_ERROR_CMD_NOT_FOUND, 0x110, STATUS_TYPE_ERROR, "command not found") \
X(FOXY_CONSOLE_ERROR_CMD_FAILED, 0x111, STATUS_TYPE_ERROR, "command execution failed") \
X(FOXY_CONSOLE_ERROR_CMD_MISSING_ARGS, 0x112, STATUS_TYPE_ERROR, "missing command arguments") \
X(FOXY_CONSOLE_ERROR_CMD_ALREADY_EXISTS, 0x113, STATUS_TYPE_ERROR, "command already exists") \
X(FOXY_CONSOLE_ERROR_THREAD_START_FAILED, 0x114, STATUS_TYPE_ERROR, "console thread failed to start") \
X(FOXY_CONSOLE_ERROR_STDIN_OPEN_FAILED, 0x120, STATUS_TYPE_ERROR, "failed to open stdin stream") \
X(FOXY_CONSOLE_ERROR_STDOUT_OPEN_FAILED, 0x121, STATUS_TYPE_ERROR, "failed to open stdout stream") \
X(FOXY_CONSOLE_ERROR_STDERR_OPEN_FAILED, 0x122, STATUS_TYPE_ERROR, "failed to open stderr stream") \
X(FOXY_CONSOLE_ERROR_ALLOC_FAILED, 0x130, STATUS_TYPE_ERROR, "failed to allocate console") \
X(FOXY_CONSOLE_ERROR_INPUT_FAILED, 0x131, STATUS_TYPE_ERROR, "failed to process input") \
/* unknown/undefined */ \
X(FOXY_STATUS_NONE, 0x31337, STATUS_TYPE_OK, "not set")

// enum mapping status code to (hexadecimal) value
#define X(a, b, c, d) a=b,
enum FOXY_STATUS_CODE {
    FOXY_STATUS_CODE_TABLE
} typedef foxy_status_code_t;
#undef X

// array mapping status code to status type (success/failure)
#define X(a, b, c, d) [a]=c,
static foxy_status_type_t FOXY_STATUS_CODE_TYPES[] = {
    FOXY_STATUS_CODE_TABLE
};
#undef X

// array mapping status code to description text
#define X(a, b, c, d) [a]=d,
static char *FOXY_STATUS_CODE_DESCRIPTIONS[] = {
    FOXY_STATUS_CODE_TABLE
};
#undef X

#endif //STATUS
```

`foxylib/include/foxylib/utils/console/commands.h`:

```h
#ifndef FOXYTOOLS_COMMANDS_H
#define FOXYTOOLS_COMMANDS_H
#include <foxylib/utils/console/types.h>

void init_commands(console_ctx_p ctx);
int cmd_help(console_ctx_p ctx, char* command, size_t arg_count, char** arguments);
int cmd_quit(console_ctx_p ctx, char* command, size_t arg_count, char** arguments);

#endif//FOXYTOOLS_COMMANDS_H
```

`foxylib/include/foxylib/utils/console/console.h`:

```h
#ifndef FOXYTOOLS_CONSOLE_H
#define FOXYTOOLS_CONSOLE_H
#include <foxylib/utils/console/types.h>

foxy_status_code_t console_init(char* console_title);
foxy_status_code_t console_start();
foxy_status_code_t console_close();



console_ctx_p console_get_context(void);
void console_set_context(console_ctx_p context);

uint32_t __stdcall console_main_thread(void* lp_param);

#endif //FOXYTOOLS_CONSOLE_H
```

`foxylib/include/foxylib/utils/console/types.h`:

```h
#ifndef FOXYTOOLS_TYPES_H
#define FOXYTOOLS_TYPES_H
#include <foxylib/platform.h>
#include <foxylib/constants.h>
#include <foxylib/status.h>

#define CONSOLE_CMD_NAME_SIZE 16
#define CONSOLE_CMD_DESC_SIZE 256


typedef struct console_ctx_t *console_ctx_p;

// function type definition as executed by commands
typedef foxy_status_code_t (console_cmd_func_t)(console_ctx_p ctx, char* command, size_t arg_count, char** arguments);
typedef console_cmd_func_t* console_cmd_func_p;

// data structure for console command definitions
struct console_cmd_t {
    char name[CONSOLE_CMD_NAME_SIZE];
    char desc[CONSOLE_CMD_DESC_SIZE];
    console_cmd_func_p func;
} typedef console_cmd, *console_cmd_p;

// data structure for console runtime context parameters
struct console_ctx_t {
    // title of the console window
    char console_title[MAX_WINDOW_TITLE];

    // pointers to stdio streams
    FILE* stdin_ptr;
    FILE* stdout_ptr;
    FILE* stderr_ptr;

    // flag to indicate whether the console has been initialized or not
    uint8_t is_initialized;

    // flag to indicate whether the console thread is running or not
    uint8_t is_running;

    // console thread handle and id
    void* thread_handle;
    uint32_t thread_id;

    // last native error code
    int last_error;

    // last internal status code
    foxy_status_code_t last_status;

    // array of all registered console commands + command count
    size_t command_count;
    console_cmd_p command_list;
} typedef console_ctx, *console_ctx_p;



static console_ctx cmd_ctx = {
    .console_title="FoxyConsole",
    .command_list=NULL,
    .command_count=0,
    .stdin_ptr=NULL,
    .stdout_ptr=NULL,
    .stderr_ptr=NULL,
    .is_initialized=0,
    .is_running=0,
    .thread_handle=NULL,
    .thread_id=0,
    .last_error=0,
    .last_status=FOXY_STATUS_NONE
};



#endif //FOXYTOOLS_TYPES_H

```

`foxylib/include/foxylib/utils/helpers.h`:

```h
#pragma once
#include <foxylib/platform.h>

// returns a unix timestamp in seconds since epoch
size_t get_unix_timestamp(char* dest);

// creates a formatted timestamp based on the current time and a given format string
size_t get_formatted_timestamp(char* dest , const char* fmt);

// counts all occurrences of char "find" in the given string and returns the number
size_t count_char_occurrences_in_string(const char* str, const char find);

// counts all occurrences of whitespaces (including newline and tab) in a given string
size_t count_whitespaces_in_string(const char* str);

```

`foxylib/include/foxylib/utils/logging/logging.h`:

```h
#ifndef FOXYTOOLS_LOGGING_H
#define FOXYTOOLS_LOGGING_H
#include <foxylib/utils/logging/loglevel.h>
#include <foxylib/utils/logging/types.h>
#include <foxylib/utils/helpers.h>
#include <foxylib/status.h>

#define ENABLE_DEV_LOG

static logging_defaults logging_default_options = {
    .filename_ext = ".log",
    .filename_timestamp_format = "%Y%m%d_%H%M%S",
    .entry_timestamp_format = "%Y-%m-%d %H:%M:%S",
    .base_format_string = "%s %-9s %s\n",
};

static logging_ctx log_ctx = {
    .module_name="default",
    .log_levels=FOXY_LOG_ALL,
    .file_ptr=NULL,
    .file_path="",
    .is_initialized=0
};

foxy_status_code_t logging_init(char* module_name, int log_levels);
char* __logging_build_format_string(foxy_log_level_t log_level, const char* format);
void __logging_va_msg(FILE* output_stream, char* format, va_list args);

// macro to avoid unneccessary code duplication in the LOG* inline functions below
#define _LOG_VA_MSG(output_stream, log_level, format) \
    if((log_ctx.log_levels & (int)log_level) == (int)log_level) \
    { \
        char* final_fmt = __logging_build_format_string(log_level, format); \
        va_list args; \
        va_start(args, format); \
            __logging_va_msg(output_stream, final_fmt, args); \
        va_end(args); \
    }

// write a log message with a choosable prefix to stdout + log file (if set)
__inline void LOG(foxy_log_level_t log_level, char* format, ...)
{
    _LOG_VA_MSG(stdout, log_level, format);
}

// write a development log message to stdout + log file (if set) (does nothing when ENABLE_DEV_MODE is undefined)
__inline void LOG_DEV(char* format, ...)
{
#ifdef ENABLE_DEV_LOG
    _LOG_VA_MSG(stdout, FOXY_LOG_DEV, format);
#endif
}

// write a debug log message to stdout + log file (if set)
__inline void LOG_DEBUG(char* format, ...)
{
    _LOG_VA_MSG(stdout, FOXY_LOG_DEBUG, format);
}

// write an error log message to stderr + log file (if set)
__inline void LOG_ERROR(char* format, ...)
{
    _LOG_VA_MSG(stdout, FOXY_LOG_ERROR, format);
}

// write a warning log message to stdout + log file (if set)
__inline void LOG_WARN(char* format, ...)
{
    _LOG_VA_MSG(stdout, FOXY_LOG_WARNING, format);
}

// write an information log message to stdout + log file (if set)
__inline void LOG_INFO(char* format, ...)
{
    _LOG_VA_MSG(stdout, FOXY_LOG_INFO, format);
}

#endif //FOXYTOOLS_LOGGING_H
```

`foxylib/include/foxylib/utils/logging/loglevel.h`:

```h

#ifndef FOXYTOOLS_LOGLEVEL_H
#define FOXYTOOLS_LOGLEVEL_H

#define FOXY_LOG_LEVEL_TABLE \
X(FOXY_LOG_DEV, 4, "DEV") \
X(FOXY_LOG_DEBUG, 8, "DEBUG") \
X(FOXY_LOG_INFO, 16, "INFO") \
X(FOXY_LOG_WARNING, 32, "WARNING") \
X(FOXY_LOG_ERROR, 64, "ERROR") \
X(FOXY_LOG_FATAL, 128, "FATAL")


#define FOXY_LOG_ALL \
    (FOXY_LOG_DEV | FOXY_LOG_DEBUG | FOXY_LOG_INFO | \
    FOXY_LOG_WARNING | FOXY_LOG_ERROR | FOXY_LOG_FATAL)

#define X(a, b, d) a=b,
enum FOXY_LOG_LEVEL {
    FOXY_LOG_LEVEL_TABLE
} typedef foxy_log_level_t;
#undef X

#define X(a, b, d) [a]=d,
static char *FOXY_LOG_LEVEL_TAGS[] = {
    FOXY_LOG_LEVEL_TABLE
};
#undef X

#endif //FOXYTOOLS_LOGLEVEL_H

```

`foxylib/include/foxylib/utils/logging/types.h`:

```h

#ifndef FOXYTOOLS_LOGGING_TYPES_H
#define FOXYTOOLS_LOGGING_TYPES_H

#include <foxylib/platform.h>
#include <foxylib/constants.h>

struct logging_ctx_t {
    char module_name[32];
    int log_levels;
    FILE* file_ptr;
    char file_path[MAX_PATH];
    uint8_t is_initialized;
} typedef logging_ctx, *logging_ctx_p;

struct logging_defaults_t {
    char filename_ext[8];
    char filename_timestamp_format[DEFAULT_FORMAT_STRING_BUFFER_SIZE];
    char entry_timestamp_format[DEFAULT_FORMAT_STRING_BUFFER_SIZE];
    char base_format_string[DEFAULT_FORMAT_STRING_BUFFER_SIZE];
} typedef logging_defaults, *logging_defaults_p;

#endif //FOXYTOOLS_LOGGING_TYPES_H

```

`foxylib/utils/console/commands.c`:

```c
#include <foxylib/utils/console/commands.h>

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

const console_cmd default_commands[] = {
    {.name="help", .desc="Show usage and help regarding the available commands", .func=cmd_help},
    {.name="quit", .desc="Exit this application", .func=cmd_quit}
};

void init_commands(console_ctx_p ctx) {
    ctx->command_count = ARRAY_SIZE(default_commands);
    for(int i = 0; i < ctx->command_count; ++i) {
        ctx->command_list = realloc(ctx->command_list, ctx->command_count * sizeof(console_cmd));
        ctx->command_list[i] = default_commands[i];
    }
}

void add_command(console_ctx_p ctx, console_cmd cmd) {
    ctx->command_count++;
    ctx->command_list = realloc(ctx->command_list, ctx->command_count * sizeof(console_cmd));
    ctx->command_list[ctx->command_count] = cmd;
}


foxy_status_code_t cmd_help(console_ctx_p ctx, char* command, size_t arg_count, char** arguments) {
    printf("Showing help for the %zd available commands:\n", ctx->command_count);
    for(int i = 0; i < ctx->command_count; ++i) {
        console_cmd cmd_info = ctx->command_list[i];
        printf("  - \"%s\": %s\n", cmd_info.name, cmd_info.desc);
    }

    return FOXY_CONSOLE_COMMAND_EXECUTED;
}

foxy_status_code_t cmd_quit(console_ctx_p ctx, char* command, size_t arg_count, char** arguments) {
    uint8_t prompt_done = 0;

    while(prompt_done == 0) {
        printf("Do you really want to exit? (y/N): ");
        char input = getchar();

        if(toupper(input) == 'N' || isspace(input)) {
            prompt_done = 1;
        } else if(toupper(input) == 'Y') {
            _exit(0);
        } else {
            printf("Invalid input!\n");
        }
    }

    return FOXY_CONSOLE_COMMAND_EXECUTED;
}
```

`foxylib/utils/console/console.c`:

```c
#include <foxylib/utils/console/console.h>
#include <foxylib/utils/logging/logging.h>
#include <foxylib/utils/console/commands.h>

// initialize context with default values
foxy_status_code_t console_init(char* console_title) {
    if(console_title != NULL) {
        strcpy(cmd_ctx.console_title, console_title);
    }

    // allocate console window
    AllocConsole();

    // set window title
    SetConsoleTitle(cmd_ctx.console_title);

    // open stdin console input stream
    cmd_ctx.last_error =
        freopen_s(&cmd_ctx.stdin_ptr, "CONIN$", "r", stdin);
    if(cmd_ctx.last_error != 0)
    {
        printf_s("Failed to open stdin! Error code: %d", cmd_ctx.last_error);
        cmd_ctx.last_status = FOXY_CONSOLE_ERROR_STDIN_OPEN_FAILED;
        return cmd_ctx.last_status;
    }

    // open stdout console output stream
    cmd_ctx.last_error =
        freopen_s(&cmd_ctx.stdout_ptr, "CONOUT$", "w", stdout);
    if(cmd_ctx.last_error != 0)
    {
        printf_s("Failed to open stdout! Error code: %d", cmd_ctx.last_error);
        cmd_ctx.last_status = FOXY_CONSOLE_ERROR_STDOUT_OPEN_FAILED;
        return cmd_ctx.last_status;
    }

    // open stderr console error output stream
    cmd_ctx.last_error =
        freopen_s(&cmd_ctx.stderr_ptr, "CONOUT$", "w", stderr);
    if(cmd_ctx.last_error != 0)
    {
        printf_s("Failed to open stderr! Error code: %d", cmd_ctx.last_error);
        cmd_ctx.last_status = FOXY_CONSOLE_ERROR_STDERR_OPEN_FAILED;
        return cmd_ctx.last_status;
    }

    if(logging_init("console", FOXY_LOG_ALL) != FOXY_STATUS_SUCCESS) {
        printf("ERROR WHILE STARTING LOGGING\n");
        return FOXY_STATUS_ERROR;
    }


    init_commands(&cmd_ctx);
    //console_add_command("help", "Prints a help text", console_cmd_help);

    // set status to initialized, awaiting command setup and main
    // thread creation from now
    cmd_ctx.is_initialized = 1;
    cmd_ctx.last_status = FOXY_CONSOLE_INITIALIZED;
    return cmd_ctx.last_status;
}

foxy_status_code_t console_start() {
    // start main console loop to process commands etc
    cmd_ctx.is_running = 1;
    cmd_ctx.thread_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)console_main_thread, NULL, 0, (LPDWORD)&cmd_ctx.thread_id);

    // check if thread has been started
    if(cmd_ctx.thread_handle == NULL) {
        cmd_ctx.is_running = 0;
        cmd_ctx.last_status = FOXY_CONSOLE_ERROR_THREAD_START_FAILED;
    } else {
        cmd_ctx.last_status = FOXY_CONSOLE_THREAD_STARTED;
    }

    return cmd_ctx.last_status;
}

foxy_status_code_t console_close() {
    // stop main thread
    cmd_ctx.is_running = 0;

    // free command array
    free(cmd_ctx.command_list);

    // free console
    FreeConsole();

    // free input/output streams
    fflush(cmd_ctx.stdin_ptr);
    fflush(cmd_ctx.stdout_ptr);
    fflush(cmd_ctx.stderr_ptr);
    fclose(cmd_ctx.stdin_ptr);
    fclose(cmd_ctx.stdout_ptr);
    fclose(cmd_ctx.stderr_ptr);

    cmd_ctx.last_status = FOXY_CONSOLE_THREAD_STOPPED;
    return cmd_ctx.last_status;
}

uint32_t __stdcall console_main_thread(void* lp_param) {
    // variable for user input storage
    char* user_input_buf = malloc(MAX_INPUT_BUFFER);

    // main loop for processing command input etc
    while(cmd_ctx.is_running) {
        // will be set to 1 when command has been found
        uint8_t found_cmd = 0;

        // will be used to store the command arguments
        char** command_arguments = NULL;
        unsigned int argument_idx = 0;

        // reset input buffer
        memset(user_input_buf, 0, MAX_INPUT_BUFFER);

        // fetch user input line from stdin
        printf("> ");
        fgets(user_input_buf, MAX_INPUT_BUFFER, stdin);

        // remove newline(s) from input string
        user_input_buf[strcspn(user_input_buf, "\r\n")] = 0;

        // split user input into tokens separated by whitespace
        char* part = strtok(user_input_buf, " ");

        // loop until nothing is left to split
        while(part != NULL) {
            // calculate array and part sizes
            size_t calc_arguments_size, part_size;
            calc_arguments_size = sizeof(char**) * (argument_idx + 1);
            part_size = sizeof(char) * (strlen(part) + 1);

            // add argument to the array
            command_arguments = realloc(command_arguments, calc_arguments_size);
            command_arguments[argument_idx] = malloc(part_size);
            strcpy(command_arguments[argument_idx], part);
            ++argument_idx;

            // look for next part
            part = strtok(NULL, " ");
        }

        // empty command given, ignore
        if (command_arguments == NULL || command_arguments[0] == NULL) {
            continue;
        }

        // try to find the given command in the command list
        for (int i = 0; i < cmd_ctx.command_count; ++i) {
            // value holding the current command info
            const console_cmd cmd_info = cmd_ctx.command_list[i];

            // call command function if match was found
            if (_stricmp(cmd_info.name, command_arguments[0]) == 0) {
                found_cmd = 1;

                LOG_DEV("Executing command: %s", cmd_info.name);
                const foxy_status_code_t ret = cmd_info.func(&cmd_ctx, command_arguments[0], argument_idx, command_arguments);
                if(ret != FOXY_STATUS_SUCCESS && ret != FOXY_CONSOLE_COMMAND_EXECUTED)
                {
                    LOG_ERROR("Command execution failed! (status code: %d)", ret);
                }

                break;
            }
        }

        // show error message if command was not found
        if(found_cmd == 0) {
            LOG_ERROR("Command not found! Type \"help\" for a list of commands.");
        }

    }
}
```

`foxylib/utils/helpers.c`:

```c
#include <foxylib/utils/helpers.h>

size_t get_unix_timestamp(char* dest) {
    size_t result = 0;

    // if destination char pointer is not empty, we fill it with
    // a unix timestamp (seconds since epoch)
    if(dest != NULL) {
        sprintf_s(dest, 16, "%lu", (unsigned long)time(NULL));
        result = strlen(dest);
    }

    return result;
}

size_t get_formatted_timestamp(char* dest , const char* fmt) {
    // create variables
    size_t result = 0;
    time_t timestamp;
    struct tm time_info;

    // retrieve current time data
    time(&timestamp);
    localtime_s(&time_info, &timestamp);

    // build formatted timestamp string and store it in dest char pointer
    // as long as it's not NULL
    if(dest != NULL) {
        strftime(dest, strlen(fmt) * 2, fmt, &time_info);
        result = strlen(dest);
    }

    return result;
}

size_t count_char_occurrences_in_string(const char* str, const char find) {
    // get input string length
    size_t len = strlen(str);

    // iterate through the input string and count all occurences of "find"
    int nchar = 0;
    for (int i = 0; i != len; i++) {
        if(str[i] != find) {
            nchar++;
        }
    }

    // return number of found chars
    return nchar;
}


size_t count_whitespaces_in_string(const char* str) {
    // get input string length
    size_t len = strlen(str);

    // iterate through the input string and count all whitespaces
    // (including newline and tab)
    int nchar = 0;
    for (int i = 0; i != len; ++i) {
        if(isspace(str[i])) {
            nchar++;
        }
    }

    // return number of found whitespace chars
    return nchar;
}

size_t convert_to_uppercase(char* dest, const char* src) {
    // get length of input string
    size_t len = strlen(src);

    // allocate destination buffer
    dest = malloc(len);

    // iterate through the input string and write uppercase
    // string to dest buffer
    for(int i = 0; i != len; ++i) {
        dest[i] = toupper(src[i]);
    }

    // return string length
    return len;
}

size_t convert_to_lowercase(char* dest, const char* src) {
    // get length of input string
    size_t len = strlen(src);

    // allocate destination buffer
    dest = malloc(len);

    // iterate through the input string and write lowercase
    // string to dest buffer
    for(int i = 0; i != len; ++i) {
        dest[i] = tolower(src[i]);
    }

    // return string length
    return len;
}
```

`foxylib/utils/logging/logging.c`:

```c
#include <foxylib/utils/logging/logging.h>



foxy_status_code_t logging_init(char* module_name, int log_levels) {
    if(log_ctx.is_initialized == 1) {
        LOG_ERROR("logging_init(): logger is already initialized! aborting init...");
        return FOXY_LOGGING_ERROR_MODULE_ALREADY_EXISTS;
    }

    strcpy(log_ctx.module_name, module_name);
    log_ctx.log_levels = log_levels;


    // build log file name based on timestamp and log module name
    char* filename_timestamp = malloc(DEFAULT_FORMAT_STRING_BUFFER_SIZE);
    get_formatted_timestamp(filename_timestamp, logging_default_options.filename_timestamp_format);
    if (sprintf_s(log_ctx.file_path, MAX_PATH + 1, "%s_%s%s",
                  filename_timestamp, log_ctx.module_name, logging_default_options.filename_ext) < 0) {
        LOG_ERROR("logging_init(): failed to create log file name");
        return FOXY_LOGGING_ERROR_FILE_NAME_GENERATION;
    }

    free(filename_timestamp);

    int ret = fopen_s(&log_ctx.file_ptr, log_ctx.file_path, "w+");
    if(ret != 0) {
        printf("failed to open log file %s!\n", log_ctx.file_path);
        return FOXY_LOGGING_ERROR_FILE_CREATION;
    }

    log_ctx.is_initialized = 1;
    return FOXY_STATUS_SUCCESS;
}

char* __logging_build_format_string(foxy_log_level_t log_level, const char* format) {
    // log entry base format
    const size_t base_len = strlen(format) + (DEFAULT_FORMAT_STRING_BUFFER_SIZE * 3);
    char tmp_prefix[9] = "";
    sprintf(tmp_prefix, "[%s]", FOXY_LOG_LEVEL_TAGS[log_level]);

    char tmp_timestamp[DEFAULT_FORMAT_STRING_BUFFER_SIZE] = "";
    get_formatted_timestamp(tmp_timestamp, logging_default_options.entry_timestamp_format);

    // create new format string based on base format and the format given as function parameter
    char* result = malloc(base_len + 1);
    sprintf_s(result, base_len,
              logging_default_options.base_format_string,
              tmp_timestamp, tmp_prefix, format);

    return result;
}

void __logging_va_msg(FILE* output_stream, char* format, va_list args) {
    vfprintf(output_stream, format, args);

    if(log_ctx.file_ptr != NULL) {
        vfprintf(log_ctx.file_ptr, format, args);
        fflush(log_ctx.file_ptr);
    }
}
```

`foxywinapi/CMakeLists.txt`:

```txt
set(PROJECT_NAME "foxywinapi")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)

add_library(${PROJECT_NAME} STATIC "foxywinapi.cpp")
target_include_directories(${PROJECT_NAME} PUBLIC ".")
set_target_properties(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE CXX)


```

`foxywinapi/foxywinapi.cpp`:

```cpp
#include "foxywinapi.hpp"
```

`foxywinapi/foxywinapi.hpp`:

```hpp
#ifndef __FOXY_WINAPI_H__
#define __FOXY_WINAPI_H__
#include <lazy_importer.hpp>

// FoxyCRT - minimal Win32 CRT replacement
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <cstdint>

// disable warnings for failed #pragma intrinsic directives
#pragma warning(disable : 4163)

extern "C" {
int strcmp(char const *str1, char const *str2) {
    for (; *str1 == *str2; str1++, str2++) {
        if (*str1 == '\0')
            return 0;
    }

    return ((*(char *) str1 < *(char *) str2) ? -1 : +1);
}

int w_strcmp(wchar_t const *cmp, wchar_t const *other) {
    WORD *w_cmp = (WORD *) cmp;
    WORD *w_other = (WORD *) other;
    while (*w_other != 0) {
        WORD lowercase_other = ((*w_other >= 'A' && *w_other <= 'Z')
                                ? *w_other - 'A' + 'a'
                                : *w_other);
        if (*w_cmp != lowercase_other) {
            return 0;
        }
        w_cmp++;
        w_other++;
    }
    return (*w_cmp == 0);
}

void *malloc(size_t Size) {
    return LI_FN(HeapAlloc)(LI_FN(GetProcessHeap)(), HEAP_ZERO_MEMORY, Size);
}

void free(void *ptr) {
    LI_FN(HeapFree)(LI_FN(GetProcessHeap)(), 0, ptr);
}

void *realloc(void *ptr, size_t new_size) {
    uint8_t *d = nullptr;
    uint8_t *s = nullptr;
    size_t size;

    if (new_size == 0)
        return nullptr;

    if (ptr == nullptr)
        return malloc(new_size);


    size_t old_size = LI_FN(HeapSize)(LI_FN(GetProcessHeap)(), 0, ptr);

    if (old_size == new_size) {
        return ptr;
    }

    // allocating new ptr and moving data to it (from ptr)
    void *new_ptr = malloc(new_size);

    d = (uint8_t *) new_ptr;
    s = (uint8_t *) ptr;
    size = old_size;
    for (volatile int i = 0; i < size; i++) {
        ((BYTE *) d)[i] = ((BYTE *) s)[i];
    }

    // setting ptr to 0
    uint64_t *dest = (uint64_t *) ptr;
    size = old_size / sizeof(uint64_t);
    while (size > 0) {
        *((uint8_t *) dest) = 0;
        dest++;
        size--;
    }
    free(ptr);

    return new_ptr;
}

#pragma function(memset)
void *memset(void *dest, int c, size_t count)
{
    char *bytes = (char *)dest;
    while (count--)
    {
        *bytes++ = (char)c;
    }
    return dest;
}

#pragma function(memcpy)
void *memcpy(void *dest, const void *src, size_t count)
{
    char *dest8 = (char *)dest;
    const char *src8 = (const char *)src;
    while (count--)
    {
        *dest8++ = *src8++;
    }
    return dest;
}

void *memmove(void *destination, const void *source, size_t num) {
    for (volatile int i = 0; i < num; i++) {
        ((uint8_t *) destination)[i] = ((uint8_t *) source)[i];
    }
    return destination;
}

#define printf(format, ...) ({ \
    char buf[1024]; \
    int result = 0; \
    LI_FN(wsprintfA).forwarded()(buf, format, __VA_ARGS__); \
    DWORD done; \
    LI_FN(WriteFile)(LI_FN(GetStdHandle)(STD_OUTPUT_HANDLE), buf, (DWORD) LI_FN(strlen)(buf), &done, nullptr); \
    result; \
})


/*int printf(const char *format, ...) {
    char buf[1024];
    va_list argList;
    va_start(argList, format);
    int result = 0;
    LI_FN(wvsprintfA).forwarded()(buf, format, argList);
    va_end(argList);
    DWORD done;
    LI_FN(WriteFile)(LI_FN(GetStdHandle)(STD_OUTPUT_HANDLE), buf, (DWORD) LI_FN(strlen)(buf), &done, nullptr);
    return result;
}*/

int puts(const char *s) {
    return printf("%s\n", s);
}

int sprintf(char *buf, const char *format, ...) {
    va_list argList;
        va_start(argList, format);
    int result = 0;
    LI_FN(wvsprintfA).forwarded()(buf, format, argList);
        va_end(argList);
    return result;
}

}

#endif //__FOXY_WINAPI_H__
```

`foxywinapi/lazy_importer.hpp`:

```hpp
/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
// * Code doesn't compile with errors about pointer conversion:
//  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
// * Lazy importer can't find the function I want:
//   - Double check that the module in which it's located in is actually loaded
//   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
//     This will start using case insensitive comparison globally
//   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
//     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li { namespace detail {

namespace win {

struct LIST_ENTRY_T {
    const char* Flink;
    const char* Blink;
};

struct UNICODE_STRING_T {
    unsigned short Length;
    unsigned short MaximumLength;
    wchar_t*       Buffer;
};

struct PEB_LDR_DATA_T {
    unsigned long Length;
    unsigned long Initialized;
    const char*   SsHandle;
    LIST_ENTRY_T  InLoadOrderModuleList;
};

struct PEB_T {
    unsigned char   Reserved1[2];
    unsigned char   BeingDebugged;
    unsigned char   Reserved2[1];
    const char*     Reserved3[2];
    PEB_LDR_DATA_T* Ldr;
};

struct LDR_DATA_TABLE_ENTRY_T {
    LIST_ENTRY_T InLoadOrderLinks;
    LIST_ENTRY_T InMemoryOrderLinks;
    LIST_ENTRY_T InInitializationOrderLinks;
    const char*  DllBase;
    const char*  EntryPoint;
    union {
        unsigned long SizeOfImage;
        const char*   _dummy;
    };
    UNICODE_STRING_T FullDllName;
    UNICODE_STRING_T BaseDllName;

    LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
    load_order_next() const noexcept
    {
        return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
            InLoadOrderLinks.Flink);
    }
};

struct IMAGE_DOS_HEADER { // DOS .EXE header
    unsigned short e_magic; // Magic number
    unsigned short e_cblp; // Bytes on last page of file
    unsigned short e_cp; // Pages in file
    unsigned short e_crlc; // Relocations
    unsigned short e_cparhdr; // Size of header in paragraphs
    unsigned short e_minalloc; // Minimum extra paragraphs needed
    unsigned short e_maxalloc; // Maximum extra paragraphs needed
    unsigned short e_ss; // Initial (relative) SS value
    unsigned short e_sp; // Initial SP value
    unsigned short e_csum; // Checksum
    unsigned short e_ip; // Initial IP value
    unsigned short e_cs; // Initial (relative) CS value
    unsigned short e_lfarlc; // File address of relocation table
    unsigned short e_ovno; // Overlay number
    unsigned short e_res[4]; // Reserved words
    unsigned short e_oemid; // OEM identifier (for e_oeminfo)
    unsigned short e_oeminfo; // OEM information; e_oemid specific
    unsigned short e_res2[10]; // Reserved words
    long           e_lfanew; // File address of new exe header
};

struct IMAGE_FILE_HEADER {
    unsigned short Machine;
    unsigned short NumberOfSections;
    unsigned long  TimeDateStamp;
    unsigned long  PointerToSymbolTable;
    unsigned long  NumberOfSymbols;
    unsigned short SizeOfOptionalHeader;
    unsigned short Characteristics;
};

struct IMAGE_EXPORT_DIRECTORY {
    unsigned long  Characteristics;
    unsigned long  TimeDateStamp;
    unsigned short MajorVersion;
    unsigned short MinorVersion;
    unsigned long  Name;
    unsigned long  Base;
    unsigned long  NumberOfFunctions;
    unsigned long  NumberOfNames;
    unsigned long  AddressOfFunctions; // RVA from base of image
    unsigned long  AddressOfNames; // RVA from base of image
    unsigned long  AddressOfNameOrdinals; // RVA from base of image
};

struct IMAGE_DATA_DIRECTORY {
    unsigned long VirtualAddress;
    unsigned long Size;
};

struct IMAGE_OPTIONAL_HEADER64 {
    unsigned short       Magic;
    unsigned char        MajorLinkerVersion;
    unsigned char        MinorLinkerVersion;
    unsigned long        SizeOfCode;
    unsigned long        SizeOfInitializedData;
    unsigned long        SizeOfUninitializedData;
    unsigned long        AddressOfEntryPoint;
    unsigned long        BaseOfCode;
    unsigned long long   ImageBase;
    unsigned long        SectionAlignment;
    unsigned long        FileAlignment;
    unsigned short       MajorOperatingSystemVersion;
    unsigned short       MinorOperatingSystemVersion;
    unsigned short       MajorImageVersion;
    unsigned short       MinorImageVersion;
    unsigned short       MajorSubsystemVersion;
    unsigned short       MinorSubsystemVersion;
    unsigned long        Win32VersionValue;
    unsigned long        SizeOfImage;
    unsigned long        SizeOfHeaders;
    unsigned long        CheckSum;
    unsigned short       Subsystem;
    unsigned short       DllCharacteristics;
    unsigned long long   SizeOfStackReserve;
    unsigned long long   SizeOfStackCommit;
    unsigned long long   SizeOfHeapReserve;
    unsigned long long   SizeOfHeapCommit;
    unsigned long        LoaderFlags;
    unsigned long        NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct IMAGE_OPTIONAL_HEADER32 {
    unsigned short       Magic;
    unsigned char        MajorLinkerVersion;
    unsigned char        MinorLinkerVersion;
    unsigned long        SizeOfCode;
    unsigned long        SizeOfInitializedData;
    unsigned long        SizeOfUninitializedData;
    unsigned long        AddressOfEntryPoint;
    unsigned long        BaseOfCode;
    unsigned long        BaseOfData;
    unsigned long        ImageBase;
    unsigned long        SectionAlignment;
    unsigned long        FileAlignment;
    unsigned short       MajorOperatingSystemVersion;
    unsigned short       MinorOperatingSystemVersion;
    unsigned short       MajorImageVersion;
    unsigned short       MinorImageVersion;
    unsigned short       MajorSubsystemVersion;
    unsigned short       MinorSubsystemVersion;
    unsigned long        Win32VersionValue;
    unsigned long        SizeOfImage;
    unsigned long        SizeOfHeaders;
    unsigned long        CheckSum;
    unsigned short       Subsystem;
    unsigned short       DllCharacteristics;
    unsigned long        SizeOfStackReserve;
    unsigned long        SizeOfStackCommit;
    unsigned long        SizeOfHeapReserve;
    unsigned long        SizeOfHeapCommit;
    unsigned long        LoaderFlags;
    unsigned long        NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct IMAGE_NT_HEADERS {
    unsigned long     Signature;
    IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
};

} // namespace win

struct forwarded_hashes {
    unsigned module_hash;
    unsigned function_hash;
};

// 64 bit integer where 32 bits are used for the hash offset
// and remaining 32 bits are used for the hash computed using it
using offset_hash_pair = unsigned long long;

LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return ( pair & 0xFFFFFFFF ); }

LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return ( pair >> 32 ); }

template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
{
return static_cast<unsigned int>(
(value ^ ((!CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
static_cast<unsigned long long>(16777619));
}

LAZY_IMPORTER_FORCEINLINE constexpr unsigned
khash_impl(const char* str, unsigned value) noexcept
{
return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
}

LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
    const char* str, unsigned offset) noexcept
{
return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
}

template<class CharT = char>
LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
{
unsigned value = offset;

for(;;) {
char c = *str++;
if(!c)
return value;
value = hash_single(value, c);
}
}

LAZY_IMPORTER_FORCEINLINE unsigned hash(
    const win::UNICODE_STRING_T& str, unsigned offset) noexcept
{
auto       first = str.Buffer;
const auto last  = first + (str.Length / sizeof(wchar_t));
auto       value = offset;
for(; first != last; ++first)
value = hash_single(value, static_cast<char>(*first));

return value;
}

LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
    const char* str, unsigned offset) noexcept
{
forwarded_hashes res{ offset, offset };

for(; *str != '.'; ++str)
res.module_hash = hash_single<true>(res.module_hash, *str);

++str;

for(; *str; ++str)
res.function_hash = hash_single(res.function_hash, *str);

return res;
}

// some helper functions
LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
{
#if defined(_M_X64) || defined(__amd64__)
return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
}

LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
{
    return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
}

LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
    const char* base) noexcept
{
return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
    base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
}

LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
    const char* base) noexcept
{
return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
    base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
}

LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
{
return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
ldr()->InLoadOrderModuleList.Flink);
}

struct exports_directory {
    const char*                        _base;
    const win::IMAGE_EXPORT_DIRECTORY* _ied;
    unsigned long                      _ied_size;

public:
    using size_type = unsigned long;

    LAZY_IMPORTER_FORCEINLINE
    exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

    LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
    {
        return reinterpret_cast<const char*>(_ied) != _base;
    }

    LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
    {
        return _ied->NumberOfNames;
    }

    LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
    {
        return _ied;
    }

    LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
    {
        return reinterpret_cast<const char*>(
            _base + reinterpret_cast<const unsigned long*>(
                _base + _ied->AddressOfNames)[index]);
    }

    LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
    {
        const auto* const rva_table =
            reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

        const auto* const ord_table = reinterpret_cast<const unsigned short*>(
            _base + _ied->AddressOfNameOrdinals);

        return _base + rva_table[ord_table[index]];
    }

    LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
        const char* export_address) const noexcept
    {
        const auto ui_ied = reinterpret_cast<const char*>(_ied);
        return (export_address > ui_ied && export_address < ui_ied + _ied_size);
    }
};

struct safe_module_enumerator {
    using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
    value_type* value;
    value_type* head;

    LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
        : safe_module_enumerator(ldr_data_entry())
        {}

    LAZY_IMPORTER_FORCEINLINE
    safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
        : value(ldr->load_order_next()), head(value)
    {}

    LAZY_IMPORTER_FORCEINLINE void reset() noexcept
    {
        value = head->load_order_next();
    }

    LAZY_IMPORTER_FORCEINLINE bool next() noexcept
    {
        value = value->load_order_next();

        return value != head && value->DllBase;
    }
};

struct unsafe_module_enumerator {
    using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
    value_type value;

    LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
        : value(ldr_data_entry())
        {}

    LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

    LAZY_IMPORTER_FORCEINLINE bool next() noexcept
    {
        value = value->load_order_next();
        return true;
    }
};

// provides the cached functions which use Derive classes methods
template<class Derived, class DefaultType = void*>
class lazy_base {
protected:
    // This function is needed because every templated function
    // with different args has its own static buffer
    LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
    {
        static void* value = nullptr;
        return value;
    }

public:
    template<class T = DefaultType>
    LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
    {
        return Derived::template get<T, safe_module_enumerator>();
    }

    template<class T = DefaultType, class Enum = unsafe_module_enumerator>
    LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
    {
        auto& cached = _cache();
        if(!cached)
            cached = Derived::template get<void*, Enum>();

        return (T)(cached);
    }

    template<class T = DefaultType>
    LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
    {
        return cached<T, safe_module_enumerator>();
    }
};

template<offset_hash_pair OHP>
struct lazy_module : lazy_base<lazy_module<OHP>> {
    template<class T = void*, class Enum = unsafe_module_enumerator>
    LAZY_IMPORTER_FORCEINLINE static T get() noexcept
    {
        Enum e;
        do {
            if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                return (T)(e.value->DllBase);
        } while(e.next());
        return {};
    }

    template<class T = void*, class Ldr>
    LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
    {
        safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
        do {
            if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                return (T)(e.value->DllBase);
        } while(e.next());
        return {};
    }

    template<class T = void*, class Ldr>
    LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
    {
        auto& cached = lazy_base<lazy_module<OHP>>::_cache();
        if(!cached)
            cached = in(ldr);

        return (T)(cached);
    }
};

template<offset_hash_pair OHP, class T>
struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
    using base_type = lazy_base<lazy_function<OHP, T>, T>;

    template<class... Args>
    LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
    {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
        return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
        return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
    }

    template<class F = T, class Enum = unsafe_module_enumerator>
    LAZY_IMPORTER_FORCEINLINE static F get() noexcept
    {
        // for backwards compatability.
        // Before 2.0 it was only possible to resolve forwarded exports when
        // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
        return forwarded<F, Enum>();
#else

        Enum e;

        do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
            if(!e.value->DllBase || !e.value->FullDllName.Length)
                    continue;
#endif

            const exports_directory exports(e.value->DllBase);

            if(exports) {
                auto export_index = exports.size();
                while(export_index--)
                    if(hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                        return (F)(exports.address(export_index));
            }
        } while(e.next());
        return {};
#endif
    }

    template<class F = T, class Enum = unsafe_module_enumerator>
    LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
    {
        detail::win::UNICODE_STRING_T name;
        forwarded_hashes              hashes{ 0, get_hash(OHP) };

        Enum e;
        do {
            name = e.value->BaseDllName;
            name.Length -= 8; // get rid of .dll extension

            if(!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                            const auto addr = exports.address(export_index);

                            if(exports.is_forwarded(addr)) {
                                hashes = hash_forwarded(
                                    reinterpret_cast<const char*>(addr),
                                    get_offset(OHP));

                                e.reset();
                                break;
                            }
                            return (F)(addr);
                        }
                }
            }
        } while(e.next());
        return {};
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
    {
        return forwarded<F, safe_module_enumerator>();
    }

    template<class F = T, class Enum = unsafe_module_enumerator>
    LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
    {
        auto& value = base_type::_cache();
        if(!value)
            value = forwarded<void*, Enum>();
        return (F)(value);
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
    {
        return forwarded_cached<F, safe_module_enumerator>();
    }

    template<class F = T, bool IsSafe = false, class Module>
    LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
    {
        if(IsSafe && !m)
            return {};

        const exports_directory exports((const char*)(m));
        if(IsSafe && !exports)
            return {};

        for(unsigned long i{};; ++i) {
            if(IsSafe && i == exports.size())
                break;

            if(hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                return (F)(exports.address(i));
        }
        return {};
    }

    template<class F = T, class Module>
    LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
    {
        return in<F, true>(m);
    }

    template<class F = T, bool IsSafe = false, class Module>
    LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
    {
        auto& value = base_type::_cache();
        if(!value)
            value = in<void*, IsSafe>(m);
        return (F)(value);
    }

    template<class F = T, class Module>
    LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
    {
        return in_cached<F, true>(m);
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
    {
        return in<F>(ldr_data_entry()->load_order_next()->DllBase);
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
    {
        return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
    {
        return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
    }

    template<class F = T>
    LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
    {
        return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
    }
};

}} // namespace li::detail

#endif // include guard

```

`foxywinapi/pe_file.hpp`:

```hpp

#pragma once

#include <cstdint>

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef enum pe_image_machine : uint16_t {
    PE_IMAGE_MACHINE_UNKNOWN = 0,
    PE_I386 = 0x014c,  // Intel 386 or later processors and compatible processors
    PE_R3000 = 0x0162,  // MIPS little-endian, 0x160 big-endian
    PE_R4000 = 0x0166,  // MIPS little-endian
    PE_R10000 = 0x0168,  // MIPS little-endian
    PE_WCEMIPSV2 = 0x0169,  // MIPS little-endian WCE v2
    PE_ALPHA = 0x0184,  // Alpha_AXP
    PE_SH3 = 0x01a2,  // Hitachi SH3
    PE_SH3DSP = 0x01a3,  // Hitachi SH3 DSP
    PE_SH3E = 0x01a4,  // Hitachi SH3E little-endian
    PE_SH4 = 0x01a6,  // Hitachi SH4
    PE_SH5 = 0x01a8,  // Hitachi SH5
    PE_ARM = 0x01c0,  // ARM little-endian
    PE_THUMB = 0x01c2,  // Thumb
    PE_ARMNT = 0x01c4,  // Arm Thumb-2 little-endian
    PE_AM33 = 0x01d3,  // Matsushita AM33
    PE_POWERPC = 0x01f0,  // Power PC little endian
    PE_POWERPCFP = 0x01f1,  // Power PC with floating point support
    PE_IA64 = 0x0200,  // Intel Itanium processor family
    PE_MIPS16 = 0x0266,  // MIPS16
    PE_ALPHA64 = 0x0284,  // ALPHA64
    PE_MIPSFPU = 0x0366,  // MIPS with FPU
    PE_MIPSFPU16 = 0x0466,  // MIPS16 with FPU
    PE_TRICORE = 0x0520,  // Infineon
    PE_CEF = 0x0CEF,
    PE_EBC = 0x0EBC,  // EFI Byte Code
    PE_RISCV32 = 0x5032,  // RISC-V 32-bit address space
    PE_RISCV64 = 0x5064,  // RISC-V 64-bit address space
    PE_RISCV128 = 0x5128,  // RISC-V 128-bit address space
    PE_AMD64 = 0x8664,  // x64
    PE_M32R = 0x9041,  // Mitsubishi M32R little-endian
    PE_ARM64 = 0xAA64,  // ARM64 little-endian
    PE_CEE = 0xC0EE
} pe_image_machine_e;

typedef enum pe_file_characteristics {
    PE_IMAGE_FILE_RELOCS_STRIPPED = 0x0001,
    PE_IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002,
    PE_IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004,
    PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008,
    PE_IMAGE_FILE_AGGRESIVE_WS_TRIM = 0x0010,
    PE_IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020,
    PE_IMAGE_FILE_BYTES_REVERSED_LO = 0x0080,
    PE_IMAGE_FILE_32BIT_MACHINE = 0x0100,
    PE_IMAGE_FILE_DEBUG_STRIPPED = 0x0200,
    PE_IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400,
    PE_IMAGE_FILE_NET_RUN_FROM_SWAP = 0x0800,
    PE_IMAGE_FILE_SYSTEM = 0x1000,
    PE_IMAGE_FILE_DLL = 0x2000,
    PE_IMAGE_FILE_UP_SYSTEM_ONLY = 0x4000,
    PE_IMAGE_FILE_BYTES_REVERSED_HI = 0x8000
} pe_file_characteristics_e;

typedef enum pe_optional_magic : uint16_t {
    PE_PE32 = 0x10b,
    PE_PE64 = 0x20b,
    PE_ROM = 0x107
} pe_optional_magic_e;

typedef enum pe_image_subsystem : uint16_t {
    PE_IMAGE_SUBSYSTEM_UNKNOWN = 0,  // Unknown subsystem
    PE_NATIVE = 1,  // Image doesn't require a subsystem
    PE_WINDOWS_GUI = 2,  // Image runs in the Windows GUI subsystem
    PE_WINDOWS_CUI = 3,  // Image runs in the Windows character subsystem
    PE_OS2_CUI = 5,  // image runs in the OS/2 character subsystem
    PE_POSIX_CUI = 7,  // image runs in the Posix character subsystem
    PE_NATIVE_WINDOWS = 8,  // image is a native Win9x driver
    PE_WINDOWS_CE_GUI = 9,  // Image runs in the Windows CE subsystem
    PE_EFI_APPLICATION = 10,
    PE_EFI_BOOT_SERVICE_DRIVER = 11,
    PE_EFI_RUNTIME_DRIVER = 12,
    PE_EFI_ROM = 13,
    PE_XBOX = 14,
    PE_WINDOWS_BOOT_APPLICATION = 16
} pe_image_subsystem_e;

typedef enum pe_dll_characteristics : uint16_t {
    PE_IMAGE_LIBRARY_PROCESS_INIT = 0x0001, // reserved
    PE_IMAGE_LIBRARY_PROCESS_TERM = 0x0002, // reserved
    PE_IMAGE_LIBRARY_THREAD_INIT = 0x0004, // reserved
    PE_IMAGE_LIBRARY_THREAD_TERM = 0x0008, // reserved
    PE_IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = 0x0020, // image can handle a high entropy 64-bit virtual address space
    PE_IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040, // dll can be relocated at load time
    PE_IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 0x0080, // code integrity checks are enforced
    PE_IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100, // image is nx compatible
    PE_IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 0x0200, // isolation aware, but do not isolate the image
    PE_IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400, // does not use structured exception (se) handling - no se handler may be called in this image
    PE_IMAGE_DLLCHARACTERISTICS_NO_BIND = 0x0800, // do not bind the image
    PE_IMAGE_DLLCHARACTERISTICS_APPCONTAINER = 0x1000, // image must execute in an app container
    PE_IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 0x2000, // image is a wdm driver
    PE_IMAGE_DLLCHARACTERISTICS_GUARD_CF = 0x4000, // image supports control flow guard
    PE_IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000 // image is terminal server aware
} pe_dll_characteristics_e;

typedef enum pe_section_characteristics : uint32_t {
    PE_IMAGE_SCN_TYPE_DSECT = 0x00000001, // reserved
    PE_IMAGE_SCN_TYPE_NOLOAD = 0x00000002, // reserved
    PE_IMAGE_SCN_TYPE_GROUP = 0x00000004, // reserved
    PE_IMAGE_SCN_TYPE_NO_PAD = 0x00000008, // OBSOLETE: replaced by IMAGE_SCN_ALIGN_1BYTES (do not pad section to the next boundary)
    PE_IMAGE_SCN_TYPE_COPY = 0x00000010, // reserved
    PE_IMAGE_SCN_CNT_CODE = 0x00000020, // section contains executable code
    PE_IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040, // section contains initialized data
    PE_IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080, // section contains uninitialized data
    PE_IMAGE_SCN_LNK_OTHER = 0x00000100, // reserved
    PE_IMAGE_SCN_LNK_INFO = 0x00000200, // section contains comments or other information (only valid for object files)
    PE_IMAGE_SCN_TYPE_OVER = 0x00000400, // reserved
    PE_IMAGE_SCN_LNK_REMOVE = 0x00000800, // section will not become part of the image (only valid for object files)
    PE_IMAGE_SCN_LNK_COMDAT = 0x00001000, // section contains COMDAT data (only valid for object files)
    //0x00002000
    PE_IMAGE_SCN_NO_DEFER_SPEC_EXC = 0x00004000, // reset speculative exceptions handling bits in the TLB entries for this section
    PE_IMAGE_SCN_GPREL = 0x00008000, // section contains data referenced through the global pointer
    PE_IMAGE_SCN_MEM_SYSHEAP = 0x00010000, // OBSOLETE
    PE_IMAGE_SCN_MEM_PURGEABLE = 0x00020000, // reserved
    PE_IMAGE_SCN_MEM_LOCKED = 0x00040000, // reserved
    PE_IMAGE_SCN_MEM_PRELOAD = 0x00080000, // reserved
    PE_IMAGE_SCN_ALIGN_1BYTES = 0x00100000, // align data on 1-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_2BYTES = 0x00200000, // align data on 2-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_4BYTES = 0x00300000, // align data on 4-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_8BYTES = 0x00400000, // align data on 8-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_16BYTES = 0x00500000, // align data on 16-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_32BYTES = 0x00600000, // align data on 32-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_64BYTES = 0x00700000, // align data on 64-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_128BYTES = 0x00800000, // align data on 128-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_256BYTES = 0x00900000, // align data on 256-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_512BYTES = 0x00A00000, // align data on 512-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000, // align data on 1024-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000, // align data on 2048-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000, // align data on 4096-byte boundary (only valid for object files)
    PE_IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000, // align data on 8192-byte boundary (only valid for object files)
    PE_IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000, // section contains extended relocations
    PE_IMAGE_SCN_MEM_DISCARDABLE = 0x02000000, // section can be discarded as needed
    PE_IMAGE_SCN_MEM_NOT_CACHED = 0x04000000, // section cannot be cached
    PE_IMAGE_SCN_MEM_NOT_PAGED = 0x08000000, // section cannot be paged
    PE_IMAGE_SCN_MEM_SHARED = 0x10000000, // section cannot be shared in memory
    PE_IMAGE_SCN_MEM_EXECUTE = 0x20000000, // section can be executed as code
    PE_IMAGE_SCN_MEM_READ = 0x40000000, // section can be read
    PE_IMAGE_SCN_MEM_WRITE = 0x80000000, // section can be written to

} pe_section_characteristics_e;

typedef enum pe_base_relocation_type : uint16_t {
    PE_IMAGE_REL_BASED_ABSOLUTE = 0,
    PE_IMAGE_REL_BASED_HIGH,
    PE_IMAGE_REL_BASED_LOW,
    PE_IMAGE_REL_BASED_HIGHLOW,
    PE_IMAGE_REL_BASED_HIGHADJ,
    PE_IMAGE_REL_BASED_MACHINE_SPECIFIC_5,
    PE_IMAGE_REL_BASED_RESERVED,
    PE_IMAGE_REL_BASED_MACHINE_SPECIFIC_7,
    PE_IMAGE_REL_BASED_MACHINE_SPECIFIC_8,
    PE_IMAGE_REL_BASED_MACHINE_SPECIFIC_9,
    PE_IMAGE_REL_BASED_DIR64
} pe_base_relocation_type_e;

typedef enum pe_image_debug_type : uint32_t {
    PE_COFF = 1,
    PE_CODEVIEW = 2,
    PE_FPO = 3,
    PE_MISC = 4,
    PE_EXCEPTION,
    PE_FIXUP,
    PE_OMAP_TO_SRC,
    PE_OMAP_FROM_SRC,
    PE_BORLAND,
    PE_RESERVED10,
    PE_CLSID,
    PE_VC_FEATURE,
    PE_POGO,
    PE_ILTCG,
    PE_MPX,
    PE_REPRO
} pe_image_debug_type_e;

typedef enum pe_image_directory_entry {
    PE_IMAGE_DIRECTORY_ENTRY_EXPORT = 0,
    PE_IMAGE_DIRECTORY_ENTRY_IMPORT = 1,
    PE_IMAGE_DIRECTORY_ENTRY_RESOURCE = 2,
    PE_IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3,
    PE_IMAGE_DIRECTORY_ENTRY_SECURITY = 4,
    PE_IMAGE_DIRECTORY_ENTRY_BASERELOC = 5,
    PE_IMAGE_DIRECTORY_ENTRY_DEBUG = 6,
    PE_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7,
    PE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8,
    PE_IMAGE_DIRECTORY_ENTRY_TLS = 9,
    PE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10,
    PE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11,
    PE_IMAGE_DIRECTORY_ENTRY_IAT = 12,
    PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13,
    PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14
} pe_image_directory_entry_e;

typedef struct pe_dos_header {
    uint16_t magic;
    uint16_t bytes_on_last_page;
    uint16_t page_count;
    uint16_t relocation_count;
    uint16_t header_paragraphs;
    uint16_t min_extra_paragraphs;
    uint16_t max_extra_paragraphs;
    uint16_t init_relative_ss_value;
    uint16_t init_sp_value;
    uint16_t checksum;
    uint16_t init_ip_value;
    uint16_t relocation_table_address;
    uint16_t overlay_number;
    uint16_t reserved_1[4];
    uint16_t oem_id;
    uint16_t oem_info;
    uint16_t reserved_2[10];
    int32_t new_exe_header_address;
} pe_dos_header_t, *pe_dos_header_p;


typedef struct pe_image_file_header {
    pe_image_machine machine;
    uint16_t section_count;
    uint32_t timestamp;
    uint32_t symbol_table_pointer;
    uint32_t symbol_count;
    uint16_t optional_header_size;
    uint16_t characteristics;
} pe_image_file_header_t, *pe_image_file_header_p;


typedef struct pe_image_data_directory {
    uint32_t virtual_address;
    uint32_t size;
} pe_image_data_directory_t, *pe_image_data_directory_p;

typedef struct pe_image_optional_header_64 {
    pe_optional_magic magic;
    uint8_t major_linker_version;
    uint8_t minor_linker_version;
    uint32_t code_size;
    uint32_t initialized_data_size;
    uint32_t uninitialized_data_size;
    uint32_t entry_point_address;
    uint32_t code_base;
    uint64_t image_base;
    uint32_t section_alignment;
    uint32_t file_alignment;
    uint16_t major_os_version;
    uint16_t minor_os_version;
    uint16_t major_image_version;
    uint16_t minor_image_version;
    uint16_t major_subsystem_version;
    uint16_t minor_subsystem_version;
    uint32_t win32_version_value;
    uint32_t image_size;
    uint32_t headers_size;
    uint32_t checksum;
    pe_image_subsystem subsystem;
    uint16_t dll_characteristics; // pe_dll_characteristics
    uint64_t stack_reserve_size;
    uint64_t stack_commit_size;
    uint64_t heap_reserve_size;
    uint64_t heap_commit_size;
    uint32_t loader_flags;
    uint32_t data_directory_count;
    pe_image_data_directory export_directory;
    pe_image_data_directory import_directory;
    pe_image_data_directory resource_directory;
    pe_image_data_directory exception_directory;
    pe_image_data_directory security_directory;
    pe_image_data_directory base_relocation_table;
    pe_image_data_directory debug_directory;
    pe_image_data_directory architecture_directory;
    pe_image_data_directory global_pointer_directory;
    pe_image_data_directory tls_directory;
    pe_image_data_directory load_configuration_directory;
    pe_image_data_directory bound_import_directory;
    pe_image_data_directory import_address_table;
    pe_image_data_directory delay_load_import_directory;
    pe_image_data_directory com_runtime_directory;
    pe_image_data_directory reserved;
} pe_image_optional_header_64_t, *pe_image_optional_header_64_p;

typedef struct pe_nt_headers_64 {
    uint32_t signature;
    pe_image_file_header file_header;
    pe_image_optional_header_64 optional_header;

} pe_nt_headers_64_t, *pe_nt_headers_64_p;

typedef struct pe_section_header {
    uint8_t name[8];
    union {
        uint32_t physical_address;
        uint32_t virtual_size;
    } misc;
    uint32_t virtual_address;
    uint32_t raw_data_size;
    uint32_t raw_data_pointer;
    uint32_t relocations_pointer;
    uint32_t line_numbers_pointer;
    uint16_t relocations_count;
    uint16_t line_numbers_count;
    uint32_t characteristics; // pe_section_characteristics
} pe_section_header_t, *pe_section_header_p;


typedef struct pe_base_relocation_block {
    uint16_t offset;
    pe_base_relocation_type type;
} pe_base_relocation_block_t;

typedef struct pe_base_relocation {
    uint32_t virtual_address;
    uint32_t block_size;
    pe_base_relocation_type *blocks;
} pe_base_relocation_t;

typedef struct pe_image_debug_directory {
    uint32_t characteristics;
    uint32_t timestamp;
    uint16_t major_version;
    uint16_t minor_version;
    pe_image_debug_type type;
    uint32_t data_size;
    uint32_t raw_data_address;
    uint32_t raw_data_pointer;
} pe_image_debug_directory_t;

typedef struct pe_file_data {
    uint64_t* pe_address;
    size_t pe_size;

    pe_dos_header* dos_header;
    pe_nt_headers_64* nt_header;
    pe_image_data_directory* ei_data_dir;
    pe_image_data_directory* tls_data_dir;
    pe_image_data_directory* eh_data_dir;

    pe_section_header* section_header;
} pe_file_data_t;
```

`pe_parser/CMakeLists.txt`:

```txt
set(PROJECT_NAME "pe_parser")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)
set(CXX_STANDARD 17)

include_directories("../foxywinapi")

add_executable(${PROJECT_NAME} "main.cpp")
target_link_libraries(${PROJECT_NAME} kernel32.lib ucrt)
target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_17)

```

`pe_parser/main.cpp`:

```cpp
#include <cstdio>

int main(int argc, char** argv)
{
    printf("lol");
}
```

`pe_parser/old/main.cpp`:

```cpp
#include "main.hpp"
#include "pe/pe_file.hpp"
#include <lazy_importer.hpp>


int WinMain(int argc, char** argv) {
    pe_file target_pe{};
    target_pe.parse_from_file("E:/Development/FoxyTools/dist/release/bin/pe_stub.exe");
    std::cout << "raw header size: " << target_pe.get_raw_header_size() << std::endl;

    std::ifstream input_stream{"E:/basic_c_application.exe", std::ios::binary};
    input_stream.seekg(0, std::ios::end);
    std::streamsize input_size = input_stream.tellg();
    input_stream.seekg(0, std::ios::beg);

    std::vector<uint8_t> packed_pe_data(input_size);
    if(!input_stream.read(reinterpret_cast<char*>(packed_pe_data.data()), input_size)) {
        std::cout << "error while reading exe file!" << std::endl;
        return 1;
    }

    input_stream.close();

    target_pe.add_section(".packed", packed_pe_data, pe_section_characteristics::PE_IMAGE_SCN_MEM_READ | pe_section_characteristics::PE_IMAGE_SCN_CNT_INITIALIZED_DATA);
    target_pe.write_to_file("E:/basic_c_application.packed.exe");
    /*std::filesystem::path test{"E:/basic_c_application.exe"};

    pe_dos_header dos_header{0};
    pe_nt_headers_64 nt_header{0};
    std::vector<pe_section_header> section_headers{};
    std::map<std::string, uint8_t*> section_data{};

    uint64_t first_section_pointer{0};

    size_t dos_stub_size;
    char* dos_stub_buffer;

    size_t space_after_headers;
    size_t raw_header_size;
    size_t total_file_size{0};

    std::ifstream file_stream{test, std::ios::binary};
    if(!file_stream.is_open()) {
        std::cout << "failed to open file!\n";
        return 1;
    } else {
        file_stream.read(reinterpret_cast<char*>(&dos_header), sizeof(dos_header));
        dos_stub_size = dos_header.new_exe_header_address - sizeof(dos_header);
        dos_stub_buffer = reinterpret_cast<char*>(malloc(dos_stub_size));
        file_stream.read(dos_stub_buffer, dos_stub_size);
        file_stream.read(reinterpret_cast<char*>(&nt_header), sizeof(nt_header));

        for(int i = 0; i < nt_header.file_header.section_count; ++i) {
            pe_section_header tmp_header{0};
            file_stream.read(reinterpret_cast<char*>(&tmp_header), sizeof(tmp_header));
            section_headers.push_back(tmp_header);

            if(i == 0) {
                first_section_pointer = tmp_header.raw_data_pointer;
            }
        }

        raw_header_size = sizeof(dos_header) + dos_stub_size + sizeof(nt_header) + (sizeof(pe_section_header) * section_headers.size());
        space_after_headers = first_section_pointer - raw_header_size;
        file_stream.seekg(raw_header_size + space_after_headers);

        total_file_size += raw_header_size + space_after_headers;

        std::cout << "sizeof dos_header: " << sizeof(dos_header) << std::endl;
        std::cout << "dos stub size: " << dos_stub_size << std::endl;
        std::cout << "raw header size: " << raw_header_size << std::endl;
        std::cout << "first section ptr: " << first_section_pointer << std::endl;
        std::cout << "space after headers: " << space_after_headers << std::endl;

        for(auto &el: section_headers) {
            uint8_t* tmp_data = reinterpret_cast<uint8_t*>(malloc(el.raw_data_size));
            file_stream.read(reinterpret_cast<char*>(tmp_data), el.raw_data_size);
            section_data.insert(std::pair<std::string, uint8_t*>((char*)el.name, tmp_data));
            total_file_size += el.raw_data_size;

        }

        file_stream.close();
    }



    std::cout << "dos_header 1: " << std::hex << dos_header.magic << std::endl;
    for(int i = 0; i < dos_stub_size; ++i) {
        std::cout << std::hex << (uint8_t)dos_stub_buffer[i];
    }
    std::cout << std::endl;
    std::cout << "nt header 1: " << std::hex << nt_header.signature << std::endl;

    for(auto &el: section_headers) {
        std::cout << "section: " << el.name << std::endl;
    }

    pe_section_header new_section{0};

    uint8_t test_data[8192*10] = {0};

    strcpy((char*)new_section.name, ".fox");
    new_section.virtual_address = nt_header.optional_header.image_size;
    new_section.raw_data_size = roundToNearestMultiple(512, sizeof(test_data));
    new_section.raw_data_pointer = total_file_size;
    section_headers.push_back(new_section);

    nt_header.optional_header.image_size = roundToNearestMultiple(4096, new_section.raw_data_size + nt_header.optional_header.image_size);

    space_after_headers -= sizeof(new_section);


    section_data.insert(std::pair<std::string, uint8_t*>(".fox", test_data));

    nt_header.file_header.section_count += 1;

    std::ofstream outfile{"E:/out.exe", std::ios::binary};
    std::ofstream outfile_foxy{"E:/out.fox", std::ios::binary};

    outfile.write(reinterpret_cast<char*>(&dos_header), sizeof(dos_header));
    outfile.write(reinterpret_cast<char*>(dos_stub_buffer), dos_stub_size);
    outfile.write(reinterpret_cast<char*>(&nt_header), sizeof(nt_header));
    for(auto &el: section_headers) {
        std::cout << "writing section header: " << el.name << std::endl;
        outfile.write(reinterpret_cast<char*>(&el), sizeof(el));
    }

    for(int i = 0; i < space_after_headers; ++i) {
        outfile.put(0x00);
    }

    for(auto &el: section_headers) {
        std::cout << "writing section data: " << el.name << " (size: " <<  (int)el.raw_data_size << ")" << std::endl;

        outfile.write(reinterpret_cast<char*>(section_data[(char*)el.name]), el.raw_data_size);

        FOXY_PE_HEADER out_header{0};
        memcpy(out_header.section_name, el.name, sizeof(el.name));
        out_header.section_size = el.raw_data_size;
        out_header.section_data = section_data[(char*)el.name];

        outfile_foxy.write(reinterpret_cast<char*>(&out_header), sizeof(out_header));
        outfile_foxy.write(reinterpret_cast<char*>(out_header.section_data), out_header.section_size);

    }

    outfile.close();
    outfile_foxy.close();*/



    return 0;
}
```

`pe_parser/old/main.hpp`:

```hpp
#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>

//#include <windows.h>

```

`pe_parser/old/pe/pe_file.cpp`:

```cpp
#include "pe_file.hpp"

#include <utility>
#include <fstream>
#include <iostream>

pe_file::pe_file() :
    m_dos_header{0},
    m_nt_header{0},
    m_section_data{},
    m_section_headers{},
    m_input_data{} {

}

pe_file::~pe_file() = default;

void pe_file::parse_from_file(const std::string& input_file) {
    std::ifstream input_stream{input_file, std::ios::binary};

    // get size of the input file
    input_stream.seekg(0, std::ios::end);
    std::streamsize input_size = input_stream.tellg();
    input_stream.seekg(0, std::ios::beg);

    // read file into buffer
    std::vector<uint8_t> buffer(input_size);
    if(input_stream.read(reinterpret_cast<char*>(buffer.data()), input_size)) {
        parse_from_buffer(buffer);
    }

    input_stream.close();
}

void pe_file::parse_from_buffer(const std::vector<uint8_t>& buf) {
    uint32_t offset{0};

    // read dos header from buffer
    memcpy(&m_dos_header, buf.data(), sizeof(m_dos_header));
    offset += sizeof(m_dos_header);

    // read dos stub from buffer
    m_dos_stub_data = std::vector<uint8_t>(m_dos_header.new_exe_header_address - sizeof(m_dos_header));
    memcpy(m_dos_stub_data.data(), buf.data() + offset, m_dos_stub_data.size());
    offset += m_dos_stub_data.size();

    // read nt header from buffer
    memcpy(&m_nt_header, buf.data() + offset, sizeof(m_nt_header));
    offset += sizeof(m_nt_header);

    // read each section header from buffer
    for(int i = 0; i < m_nt_header.file_header.section_count; ++i) {
        pe_section_header tmp_header{0};
        memcpy(&tmp_header, buf.data() + offset, sizeof(tmp_header));
        offset += sizeof(tmp_header);

        m_section_headers.push_back(tmp_header);
    }

    // skip the padding between headers and section data
    offset += get_space_after_headers();

    // read data for each section
    for(auto &el: m_section_headers) {
        std::vector<uint8_t> tmp_data(el.raw_data_size);
        memcpy(tmp_data.data(), buf.data() + offset, el.raw_data_size);
        offset += el.raw_data_size;

        m_section_data.insert(std::pair<std::string, std::vector<uint8_t>>((char*)el.name, tmp_data));
    }
}

bool pe_file::write_to_file(const std::string& output_file) {
    // open output file
    std::ofstream file_stream{output_file, std::ios::binary};
    if(!file_stream.is_open()) {
        return false;
    }

    // build pe data and write to output file
    std::vector<uint8_t> buf{write_to_buffer()};
    if(!file_stream.write(reinterpret_cast<char*>(buf.data()), buf.size())) {
        return false;
    }

    file_stream.close();
    return true;
}

std::vector<uint8_t> pe_file::write_to_buffer() {
    // buffer to hold the pe file data
    std::vector<uint8_t> buf(get_total_file_size());
    uint32_t offset{0};

    // write dos header
    memcpy(buf.data(), reinterpret_cast<char*>(&m_dos_header), sizeof(m_dos_header));
    offset += sizeof(m_dos_header);

    // write dos stub
    memcpy(buf.data() + offset, reinterpret_cast<char*>(m_dos_stub_data.data()), m_dos_stub_data.size());
    offset += m_dos_stub_data.size();

    // write nt header
    memcpy(buf.data() + offset, reinterpret_cast<char*>(&m_nt_header), sizeof(m_nt_header));
    offset += sizeof(m_nt_header);

    // write section headers
    for(auto &el: m_section_headers) {
        std::cout << "writing section header: " << el.name << std::endl;
        memcpy(buf.data() + offset, reinterpret_cast<char*>(&el), sizeof(el));
        offset += sizeof(el);
    }

    // append padding after header data
    offset += get_space_after_headers();

    // write data for each section
    for(auto &el: m_section_headers) {
        std::cout << "writing section data: " << el.name << std::endl;
        memcpy(buf.data() + offset, reinterpret_cast<char*>(m_section_data[(char*)el.name].data()), el.raw_data_size);
        offset += el.raw_data_size;
    }

    return buf;
}

uint32_t pe_file::get_first_section_pointer() {
    // return raw data address of first section
    if(!m_section_headers.empty()) {
        return m_section_headers[0].raw_data_pointer;
    }

    return 0;
}

uint32_t pe_file::get_space_after_headers() {
    // calculate padding which will be added after the headers
    return get_first_section_pointer() - get_raw_header_size();
}

uint32_t pe_file::get_raw_header_size() {
    // calculate raw data size of the headers
    return sizeof(m_dos_header) + m_dos_stub_data.size() + sizeof(m_nt_header) + (sizeof(pe_section_header) * m_section_headers.size());
}

uint32_t pe_file::get_total_file_size() {
    // calculate size of the whole pe file including section data
    uint32_t result = get_raw_header_size() + get_space_after_headers();
    for(auto &el: m_section_data) {
        result += el.second.size();
    }

    return result;
}

void pe_file::recalculate_section_sizes() {
    // address pointing to the raw section data (first section starts right after headers + header padding)
    uint32_t current_data_address = get_raw_header_size() + get_space_after_headers();

    // image size calculation starts at the code base specified in the nt header
    m_nt_header.optional_header.image_size = m_nt_header.optional_header.code_base;

    // calculate sizes and addresses for each section
    for(auto &el: m_section_headers) {
        auto& section_data = m_section_data[(char*)el.name];

        std::cout << "=== SECTION: " << el.name << " ===" << std::endl;
        std::cout << "section_data.size(): " << section_data.size() << ", old el.raw_data_size: " << el.raw_data_size << ", new el.raw_data_size: ";

        // calculate aligned size of the raw section data
        el.raw_data_size = round_to_nearest_multiple(m_nt_header.optional_header.file_alignment, section_data.size());
        std::cout << el.raw_data_size << std::endl;

        // virtual section address based on the currently calculated image size
        el.virtual_address = m_nt_header.optional_header.image_size;

        // raw file address pointing to the section data
        el.raw_data_pointer = current_data_address;
        current_data_address += el.raw_data_size;

        // add aligned virtual section size to the total image size
        m_nt_header.optional_header.image_size += round_to_nearest_multiple(m_nt_header.optional_header.section_alignment, section_data.size());
    }

    m_nt_header.file_header.section_count = m_section_headers.size();
}

bool pe_file::add_section(const std::string &name, std::vector<uint8_t> data, uint32_t characteristics) {
    if(m_section_data.count(name)) {
        return false;
    }

    size_t real_data_size = data.size();
    data.resize(round_to_nearest_multiple(m_nt_header.optional_header.file_alignment, data.size()), 0x00);

    pe_section_header new_section{0};
    new_section.misc.virtual_size = real_data_size;
    new_section.misc.physical_address = real_data_size;
    new_section.raw_data_size = data.size();

    memcpy(new_section.name, name.c_str(), sizeof(new_section.name));
    new_section.characteristics = characteristics;

    m_section_headers.push_back(new_section);
    m_section_data.insert(std::pair<std::string, std::vector<uint8_t>>(name, data));

    recalculate_section_sizes();
    return true;
}

bool pe_file::delete_section(const std::string &name) {
    if(!m_section_data.count(name)) {
        return false;
    }

    // remove section header
    for(int i = 0; i < m_section_headers.size(); ++i) {
        if(name == (char*)m_section_headers[i].name) {
            m_section_headers.erase(m_section_headers.begin() + i);
            break;
        }
    }

    // remove section data
    m_section_data.erase(name);

    recalculate_section_sizes();

    return true;
}

bool pe_file::rename_section(const std::string &orig_name, const std::string &new_name) {
    if(!m_section_data.count(orig_name) || m_section_data.count(new_name)) {
        return false;
    }

    // remove section header
    for(auto &el: m_section_headers) {
        if(orig_name == (char*)el.name) {
            memcpy(el.name, new_name.c_str(), sizeof(el.name));
            break;
        }
    }

    // replace section data element
    m_section_data.insert(std::pair<std::string, std::vector<uint8_t>>(new_name, m_section_data[orig_name]));
    m_section_data.erase(orig_name);

    recalculate_section_sizes();

    return true;
}

bool pe_file::set_section_data(const std::string &name, std::vector<uint8_t> data) {
    if(!m_section_data.count(name)) {
        return false;
    }

    m_section_data.erase(name);
    m_section_data.insert(std::pair<std::string, std::vector<uint8_t>>(name, data));

    recalculate_section_sizes();

    return true;
}

bool pe_file::set_section_characteristics(const std::string &name, uint32_t characteristics) {
    if(!m_section_data.count(name)) {
        return false;
    }

    for(auto &el: m_section_headers) {
        if(name == (char*)el.name) {
            el.characteristics = characteristics;
            break;
        }
    }

    return true;
}

std::vector<uint8_t> pe_file::get_section_data(const std::string &name) {
    if(!m_section_data.count(name)) {
        return {};
    }

    return m_section_data[name];
}

uint32_t pe_file::get_section_characteristics(const std::string &name) {
    for(auto &el: m_section_headers) {
        if(name == (char*)el.name) {
            return el.characteristics;
        }
    }

    return 0x00;
}

```

`pe_parser/old/pe/pe_file.hpp`:

```hpp
#pragma once
#include <pe_file.hpp>
#include <vector>
#include <map>
#include <string>

class pe_file {
public:
    pe_file();
    ~pe_file();

    void parse_from_file(const std::string& input_file);
    void parse_from_buffer(const std::vector<uint8_t>& buf);
    bool write_to_file(const std::string& output_file);
    std::vector<uint8_t> write_to_buffer();

    bool add_section(const std::string& name, std::vector<uint8_t> data, uint32_t characteristics = 0x00);
    bool delete_section(const std::string& name);
    bool rename_section(const std::string& orig_name, const std::string& new_name);

    bool set_section_data(const std::string& name, std::vector<uint8_t> data);
    bool set_section_characteristics(const std::string& name, uint32_t characteristics);

    std::vector<uint8_t> get_section_data(const std::string& name);
    uint32_t get_section_characteristics(const std::string& name);

    uint32_t get_first_section_pointer();
    uint32_t get_space_after_headers();
    uint32_t get_raw_header_size();
    uint32_t get_total_file_size();

    void recalculate_section_sizes();

    static inline uint32_t round_to_nearest_multiple(uint32_t multiple, uint32_t value) {
        return ((value + (multiple - 1) &(-multiple)));
    }

private:
    pe_dos_header m_dos_header;
    pe_nt_headers_64 m_nt_header;
    std::vector<pe_section_header> m_section_headers;
    std::map<std::string, std::vector<uint8_t>> m_section_data;
    std::vector<uint8_t> m_dos_stub_data;
    std::vector<uint8_t> m_input_data;
};
```

`pe_stub/CMakeLists.txt`:

```txt
set(PROJECT_NAME "pe_stub")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)

add_executable(${PROJECT_NAME} "main.cpp")
target_link_libraries(${PROJECT_NAME} foxywinapi)


target_compile_options(${PROJECT_NAME}
        PRIVATE
        "/sdl-" # disable SDL checks
        "/GS-" # disable security checks
        "/MT" # multi-threaded runtime
        "/O1" # optimize for fast code
        "/fp:except-" # disable floating point exceptions
        "/Oy" # suppress frame pointers
#        "/GT" # optimize
)


target_link_options(${PROJECT_NAME}
        PRIVATE
        "/NODEFAULTLIB" # ignore all default libraries
        "/ENTRY:start" # set custom entry point
        "/SUBSYSTEM:WINDOWS" # link for windows subsystem
        "/MACHINE:X64" # target 64bit
        "/DYNAMICBASE:NO" # disable dynamic base address (removes reloc table)
        "/MAP" # generate mapping file
        "/NXCOMPAT:NO" # disables DEP support
        "/SAFESEH:NO" # disable safe exception handlers
        "/OPT:REF"
        "/MANIFEST:NO"
        "/DEBUG:NONE"

)







```

`pe_stub/main.cpp`:

```cpp
#pragma code_seg(".stub")
#pragma comment(linker, "/MERGE:.rdata=.stub")
#pragma comment(linker, "/MERGE:.pdata=.stub")

#include <lazy_importer.hpp>
#include <foxywinapi.hpp>


HWND open_console(const char* title)
{
    LI_FN(AllocConsole)();
    LI_FN(SetConsoleTitleA)(title);
    HANDLE in_handle, out_handle, err_handle;
    in_handle  = LI_FN(CreateFileA)("CONIN$", (GENERIC_READ | GENERIC_WRITE), 0,
        nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    out_handle = LI_FN(CreateFileA)("CONOUT$", GENERIC_WRITE, 0,
        nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    err_handle = LI_FN(CreateFileA)("CONOUT$", GENERIC_WRITE, 0,
        nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);

    LI_FN(SetStdHandle)(STD_INPUT_HANDLE, in_handle);
    LI_FN(SetStdHandle)(STD_OUTPUT_HANDLE, out_handle);
    LI_FN(SetStdHandle)(STD_ERROR_HANDLE, err_handle);

    LI_FN(SetConsoleMode)(in_handle, ENABLE_WINDOW_INPUT);

    return LI_FN(GetConsoleWindow)();
}

void close_console()
{
    LI_FN(FreeConsole)();

    LI_FN(CloseHandle)(LI_FN(GetStdHandle)(STD_INPUT_HANDLE));
    LI_FN(CloseHandle)(LI_FN(GetStdHandle)(STD_OUTPUT_HANDLE));
    LI_FN(CloseHandle)(LI_FN(GetStdHandle)(STD_ERROR_HANDLE));
}


void start()
{
    auto user32 = LI_FN(LoadLibraryA)("user32.dll");
    open_console("PE loader");

    printf("[i] PE loader stub is starting!\n");

    char test_buf[1024] = "hamlo";
    printf("[+] test_buf: %s\n", test_buf);

    while(1)  {
        LI_FN(Sleep)(10);
    };
}

```

`readme.md`:

```md
# KitsuPE
In this repository, you'll find some sort of playground I use for my PE (portable executable) file modification stuff.
The code should be compiled using LLVM for Windows because I replace/redefine some intrinsic functions (i.e. memset)
for substituting usage of the regular Win32 CRT.

## shellcode
The project `shellcode` contains shellcode which will be compiled into a .exe file. The `extract.py` script extracts the compiled code
from the .exe file into a `shellcode.bin` file, ready to be loaded as shellcode from a native Win32 application.

`shellcode_test` implements a default shellcode loader to test this one.

## foxywinapi
In these files I added some basic support headers used for Win32 API stuff and as a basic CRT replacement.

## foxylib
Contains some helper functions for logging and a debug console (including executable commands). These have no special
use yet, but I'm sure I will find a purpose for this.

## pe_stub
Stub PE file which will later be used for writing a .exe file packer (this will be the loader).

## basic_applications
Contains basic C/C++ applications which I will use to test my PE packer with.
```

`shellcode/CMakeLists.txt`:

```txt
set(PROJECT_NAME "shellcode")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)

add_executable(${PROJECT_NAME} "main.cpp")
target_link_libraries(${PROJECT_NAME} foxywinapi)

set(CMAKE_VERBOSE_MAKEFILE on)

target_compile_options(${PROJECT_NAME}
        PRIVATE
        "/sdl-" # disable SDL checks
        "/GS-" # disable security checks
        "/MT" # multi-threaded runtime
        "/fp:except-" # disable floating point exceptions
)


target_link_options(${PROJECT_NAME}
        PRIVATE
        "/NODEFAULTLIB" # ignore all default libraries
        "/ENTRY:shellcode" # set custom entry point
        "/SUBSYSTEM:WINDOWS" # link for windows subsystem
        "/MACHINE:X64" # target 64bit
        "/DYNAMICBASE:NO" # disable dynamic base address (removes reloc table)
        "/MAP" # generate mapping file
        "/NXCOMPAT:NO" # disables DEP support
        "/SAFESEH:NO" # disable safe exception handlers
        "/MANIFEST:NO"
        "/merge:.rdata=base"
        "/merge:.pdata=base"
)

add_custom_command(TARGET ${PROJECT_NAME}
    POST_BUILD
    COMMAND python "${CMAKE_CURRENT_SOURCE_DIR}/extract.py" -f "$<TARGET_FILE:${PROJECT_NAME}>" -o "${CMAKE_CURRENT_SOURCE_DIR}/x64/${PROJECT_NAME}.bin"
    COMMENT "This command extracts the shellcode binary data from the PE file"
    VERBATIM
)







```

`shellcode/extract.py`:

```py
#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import pefile
import argparse
import os

if __name__ in "__main__":
    try:
        parser = argparse.ArgumentParser(description="Extracts shellcode from a PE.")
        parser.add_argument("-f", required=True, help="Path to the source executable", type=str)
        parser.add_argument("-o", required=True, help="Path to store the output raw binary", type=str)
        option = parser.parse_args()

        pe_exe = pefile.PE(option.f)
        pe_section = pe_exe.sections[0].get_data()

        if pe_section.find(b"base"):
            section_raw = pe_section[:pe_section.find(b"base")]
            section_data = section_raw[:pe_exe.sections[0].Misc_VirtualSize]

            splitted_bin_path = os.path.split(option.o)
            filename_bin = splitted_bin_path[len(splitted_bin_path)-1].replace(".", "_")

            f = open(option.o, "wb")
            f.write(section_data)
            f.close()

            f = open(option.o + ".h", "w")
            f.write(f"#ifndef __{filename_bin.upper()}_H__\n#define __{filename_bin.upper()}_H__\n\n")
            f.write(f"const unsigned char {filename_bin}[{len(section_data)}] = ""{""\n")
            n = 0
            max_n = 16
            for i in range(len(section_data)):
                if n == 0:
                    f.write("    ")

                f.write("0x{:02X}".format(section_data[i]))

                if n <= max_n and i != len(section_data)-1:
                    f.write(", ")

                if n == max_n:
                    f.write("\n")
                    n = -1
                n += 1
            f.write("\n""}"f";\n\n#endif //__{filename_bin.upper()}_H__")
            f.close()
        else:
            print("[!] error: no ending tag")
    except Exception as e:
        print("[!] error: {}".format(e))

```

`shellcode/main.cpp`:

```cpp
#include <foxywinapi.hpp>

__attribute__((unused)) __attribute__((section("base")))
void shellcode()
{
    auto user32 = LI_FN(LoadLibraryA)("user32.dll");
    constexpr char* section_name = ".data";
    constexpr uint64_t entrypoint = 0xDEADBEEF;
    LI_FN(MessageBoxA)(nullptr, "This message box got called from our shellcode!", "Yay! :3", MB_OK);
    LI_FN(MessageBoxA)(nullptr, "Executing section!", "Yay! :3", MB_OK);


}

```

`shellcode/x64/shellcode.bin.h`:

```h
#ifndef __SHELLCODE_BIN_H__
#define __SHELLCODE_BIN_H__

const unsigned char shellcode_bin[632] = {
    0x56, 0x57, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x4C, 
    0x8B, 0x40, 0x18, 0x49, 0x83, 0xC0, 0x10, 0x4D, 0x8B, 0x00, 0x49, 0x8B, 0x40, 0x30, 0x48, 0x63, 0x48, 
    0x3C, 0x44, 0x8B, 0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC9, 0x74, 0xE8, 0x42, 0x8B, 0x54, 
    0x08, 0x18, 0x48, 0x85, 0xD2, 0x74, 0xDE, 0x46, 0x8B, 0x5C, 0x08, 0x20, 0x49, 0x01, 0xC3, 0x4C, 0x8D, 
    0x50, 0x01, 0x41, 0x8B, 0x4C, 0x93, 0xFC, 0x48, 0xFF, 0xCA, 0x8A, 0x1C, 0x08, 0x84, 0xDB, 0x74, 0x24, 
    0x4C, 0x01, 0xD1, 0xBE, 0xBC, 0xF0, 0x6F, 0x3D, 0x0F, 0xBE, 0xFB, 0x31, 0xF7, 0x69, 0xF7, 0x93, 0x01, 
    0x00, 0x01, 0x8A, 0x19, 0x48, 0xFF, 0xC1, 0x84, 0xDB, 0x75, 0xEC, 0x81, 0xFE, 0xEE, 0xBB, 0x75, 0xF1, 
    0x74, 0x07, 0x48, 0x85, 0xD2, 0x75, 0xC8, 0xEB, 0x98, 0x42, 0x8B, 0x4C, 0x08, 0x1C, 0x42, 0x8B, 0x5C, 
    0x08, 0x24, 0x48, 0x01, 0xC1, 0x48, 0x01, 0xC3, 0x89, 0xD2, 0x0F, 0xB7, 0x14, 0x53, 0x8B, 0x14, 0x91, 
    0x48, 0x01, 0xC2, 0x48, 0x8D, 0x0D, 0x71, 0x01, 0x00, 0x00, 0xFF, 0xD2, 0x65, 0x48, 0x8B, 0x04, 0x25, 
    0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x40, 0x18, 0x49, 0x83, 0xC0, 0x10, 0x4D, 0x8B, 0x00, 0x49, 0x8B, 
    0x40, 0x30, 0x48, 0x63, 0x48, 0x3C, 0x44, 0x8B, 0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC9, 
    0x74, 0xE8, 0x42, 0x8B, 0x54, 0x08, 0x18, 0x48, 0x85, 0xD2, 0x74, 0xDE, 0x46, 0x8B, 0x5C, 0x08, 0x20, 
    0x49, 0x01, 0xC3, 0x4C, 0x8D, 0x50, 0x01, 0x41, 0x8B, 0x4C, 0x93, 0xFC, 0x48, 0xFF, 0xCA, 0x8A, 0x1C, 
    0x08, 0x84, 0xDB, 0x74, 0x24, 0x4C, 0x01, 0xD1, 0xBE, 0x70, 0x61, 0x05, 0xE4, 0x0F, 0xBE, 0xFB, 0x31, 
    0xF7, 0x69, 0xF7, 0x93, 0x01, 0x00, 0x01, 0x8A, 0x19, 0x48, 0xFF, 0xC1, 0x84, 0xDB, 0x75, 0xEC, 0x81, 
    0xFE, 0xBB, 0xD1, 0x57, 0x2B, 0x74, 0x07, 0x48, 0x85, 0xD2, 0x75, 0xC8, 0xEB, 0x98, 0x42, 0x8B, 0x4C, 
    0x08, 0x1C, 0x42, 0x8B, 0x5C, 0x08, 0x24, 0x48, 0x01, 0xC1, 0x48, 0x01, 0xC3, 0x89, 0xD2, 0x0F, 0xB7, 
    0x14, 0x53, 0x8B, 0x1C, 0x91, 0x48, 0x01, 0xC3, 0x48, 0x8D, 0x15, 0xF9, 0x00, 0x00, 0x00, 0x4C, 0x8D, 
    0x05, 0xD7, 0x00, 0x00, 0x00, 0x31, 0xC9, 0x45, 0x31, 0xC9, 0xFF, 0xD3, 0x65, 0x48, 0x8B, 0x04, 0x25, 
    0x60, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x40, 0x18, 0x49, 0x83, 0xC0, 0x10, 0x4D, 0x8B, 0x00, 0x49, 0x8B, 
    0x40, 0x30, 0x48, 0x63, 0x48, 0x3C, 0x44, 0x8B, 0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC9, 
    0x74, 0xE8, 0x42, 0x8B, 0x54, 0x08, 0x18, 0x48, 0x85, 0xD2, 0x74, 0xDE, 0x46, 0x8B, 0x5C, 0x08, 0x20, 
    0x49, 0x01, 0xC3, 0x4C, 0x8D, 0x50, 0x01, 0x41, 0x8B, 0x4C, 0x93, 0xFC, 0x48, 0xFF, 0xCA, 0x8A, 0x1C, 
    0x08, 0x84, 0xDB, 0x74, 0x24, 0x4C, 0x01, 0xD1, 0xBE, 0x25, 0x89, 0xAC, 0x14, 0x0F, 0xBE, 0xFB, 0x31, 
    0xF7, 0x69, 0xF7, 0x93, 0x01, 0x00, 0x01, 0x8A, 0x19, 0x48, 0xFF, 0xC1, 0x84, 0xDB, 0x75, 0xEC, 0x81, 
    0xFE, 0x04, 0x45, 0x64, 0x0A, 0x74, 0x07, 0x48, 0x85, 0xD2, 0x75, 0xC8, 0xEB, 0x98, 0x42, 0x8B, 0x4C, 
    0x08, 0x1C, 0x42, 0x8B, 0x5C, 0x08, 0x24, 0x48, 0x01, 0xC1, 0x48, 0x01, 0xC3, 0x89, 0xD2, 0x0F, 0xB7, 
    0x14, 0x53, 0x8B, 0x1C, 0x91, 0x48, 0x01, 0xC3, 0x48, 0x8D, 0x15, 0x3C, 0x00, 0x00, 0x00, 0x4C, 0x8D, 
    0x05, 0x2D, 0x00, 0x00, 0x00, 0x31, 0xC9, 0x45, 0x31, 0xC9, 0xFF, 0xD3, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 
    0x48, 0x83, 0xC4, 0x20, 0x5B, 0x5F, 0x5E, 0x48, 0xFF, 0xE0, 0x00, 0x10, 0x00, 0x00, 0x08, 0x12, 0x00, 
    0x00, 0x6C, 0x12, 0x00, 0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x59, 
    0x61, 0x79, 0x21, 0x20, 0x3A, 0x33, 0x00, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6E, 0x67, 0x20, 
    0x73, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x21, 0x00, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x73, 
    0x73, 0x61, 0x67, 0x65, 0x20, 0x62, 0x6F, 0x78, 0x20, 0x67, 0x6F, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
    0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6F, 0x75, 0x72, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 
    0x63, 0x6F, 0x64, 0x65, 0x21, 0x00, 0xCC, 0xCC, 0x01, 0x07, 0x04, 0x00, 0x07, 0x32, 0x03, 0x30, 0x02, 
    0x70, 0x01, 0x60
};

#endif //__SHELLCODE_BIN_H__
```

`shellcode_test/CMakeLists.txt`:

```txt
set(PROJECT_NAME "shellcode_test")
set(PROJECT_VERSION "0.1")

project(${PROJECT_NAME} LANGUAGES CXX)

add_executable(${PROJECT_NAME} "main.cpp")
target_include_directories(${PROJECT_NAME} PRIVATE ../shellcode/x64/)
target_link_libraries(${PROJECT_NAME} foxywinapi)


target_compile_options(${PROJECT_NAME}
        PRIVATE
        "/sdl-" # disable SDL checks
        "/GS-" # disable security checks
        "/MT" # multi-threaded runtime
        "/O1" # optimize for fast code
        "/fp:except-" # disable floating point exceptions
        "/Oy" # suppress frame pointers
#        "/GT" # optimize
)


target_link_options(${PROJECT_NAME}
        PRIVATE
        "/SUBSYSTEM:CONSOLE" # link for windows subsystem
        "/MACHINE:X64" # target 64bit
        "/DYNAMICBASE:NO" # disable dynamic base address (removes reloc table)
        "/MAP" # generate mapping file
        "/NXCOMPAT:NO" # disables DEP support
        "/SAFESEH:NO" # disable safe exception handlers
        "/OPT:REF"
        "/MANIFEST:NO"
        "/DEBUG:NONE"

)







```

`shellcode_test/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

#include <shellcode.bin.h>

int main(int argc, char** argv)
{
    printf("[i] Trying to load shellcode...\n");

    void* exec = VirtualAlloc(nullptr, sizeof(shellcode_bin), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, shellcode_bin, sizeof(shellcode_bin));
    ((void(*)())exec)();
}

```