Project Path: arc_gmh5225_ricochet-disabler_6szf2b_2

Source Tree:

```txt
arc_gmh5225_ricochet-disabler_6szf2b_2
├── Global.h
├── Native.h
├── ObCallbacks.c
├── ObCallbacks.h
├── PsNotify.c
├── PsNotify.h
├── README.md
├── Utils.c
├── Utils.h
├── blocker_km.sln
├── blocker_km.vcxproj
├── blocker_km.vcxproj.filters
├── blocker_km.vcxproj.user
├── main.c
└── x64
    └── Release
        └── driver.sys

```

`Global.h`:

```h
#pragma once

#ifndef GLOBAL_H
#define GLOBAL_H



#define kprintf(FORMAT, ...)				DbgPrintEx(77, 0, FORMAT, __VA_ARGS__)

#define DeviceName							L"\\Device\\RTKT00"
#define DosDeviceName						L"\\DosDevices\\RTKT00"

#define CTL_GET_DRIVERINFO					CTL_CODE(FILE_DEVICE_UNKNOWN, 0x701, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define CTL_DISABLE_OB_CALLBACKS			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x702, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define CTL_RESTORE_OB_CALLBACKS			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x703, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define CTL_DISABLE_IMAGE_CALLBACK			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x704, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define CTL_DISABLE_PROCESS_CALLBACK		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x705, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define CTL_DISABLE_THREAD_CALLBACK			CTL_CODE(FILE_DEVICE_UNKNOWN, 0x706, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _Module
{
	UINT64 Base, Size;
}Module, *PModule;

typedef struct _DRIVERNAME
{
	wchar_t Name[32];
}DRIVERNAME, *PDRIVERNAME;

typedef struct _DYNDATA
{
	UINT64 CallbackListOffset;

}DYNDATA, *PDYNDATA;

extern DYNDATA g_DynData;
extern Module DriverInfo;
extern PDRIVER_OBJECT g_pDriverObject;


#endif // !GLOBAL_H
```

`Native.h`:

```h
#pragma once

#ifndef NATIVE_H
#define NATIVE_H


typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

NTSTATUS NTAPI ZwQuerySystemInformation(
	_In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Inout_   PVOID                    SystemInformation,
	_In_      ULONG                    SystemInformationLength,
	_Out_opt_ PULONG                   ReturnLength
);

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version; // 0x0
	UINT16 OperationRegistrationCount; // 0x2
	UINT32 unk1; // 0x4
	PVOID RegistrationContext; // 0x8
	UNICODE_STRING Altitude; // 0x10
} CALLBACK_ENTRY, *PCALLBACK_ENTRY;

typedef struct _OBJECT_CALLBACK_ENTRY {
	LIST_ENTRY CallbackList;
	OB_OPERATION Operations;
	ULONG Active;
	/*OB_HANDLE*/ PCALLBACK_ENTRY CallbackEntry;
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK  PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
} OBJECT_CALLBACK_ENTRY, *POBJECT_CALLBACK_ENTRY;






#endif // !NATIVE_H

```

`ObCallbacks.c`:

```c
#include <ntddk.h>
#include "Global.h"
#include "Native.h"
#include "ObCallbacks.h"

OB_CALLBACK_ADDRESSES ObAddys = { 0 };

VOID SaveOrigObCallbacks()
{
	EnumerateObCallbacks(*PsProcessType, DriverInfo.Base, DriverInfo.Size, &ObAddys.pProcPreCallback, &ObAddys.pProcPostCallback, TRUE);
	EnumerateObCallbacks(*PsThreadType, DriverInfo.Base, DriverInfo.Size, &ObAddys.pThreadPreCallback, &ObAddys.pThreadPostCallback, TRUE);

	if (ObAddys.pProcPreCallback)
		ObAddys.OrigProcPre = *ObAddys.pProcPreCallback;

	if (ObAddys.pThreadPreCallback)
		ObAddys.OrigThreadPre = *ObAddys.pThreadPreCallback;

	if (ObAddys.pProcPostCallback)
		ObAddys.OrigProcPost = *ObAddys.pProcPostCallback;

	if (ObAddys.pThreadPostCallback)
		ObAddys.OrigThreadPost = *ObAddys.pThreadPostCallback;
}

VOID DisableObCallbacks()
{
	if (ObAddys.pProcPreCallback)
		*ObAddys.pProcPreCallback = DummyObjectPreCallback;

	if (ObAddys.pThreadPreCallback)
		*ObAddys.pThreadPreCallback = DummyObjectPreCallback;

	if (ObAddys.pProcPostCallback)
		*ObAddys.pProcPostCallback = DummyObjectPostCallback;

	if (ObAddys.pThreadPostCallback)
		*ObAddys.pThreadPostCallback = DummyObjectPostCallback;
}

VOID RestoreObCallbacks()
{
	if (ObAddys.pProcPreCallback)
		*ObAddys.pProcPreCallback = ObAddys.OrigProcPre;

	if (ObAddys.pThreadPreCallback)
		*ObAddys.pThreadPreCallback = ObAddys.OrigThreadPre;

	if (ObAddys.pProcPostCallback)
		*ObAddys.pProcPostCallback = ObAddys.OrigProcPost;

	if (ObAddys.pThreadPostCallback)
		*ObAddys.pThreadPostCallback = ObAddys.OrigThreadPost;
}


/*
	Traversing the CallbackLinkedList for the correct callback entry.
*/
VOID EnumerateObCallbacks(_In_ POBJECT_TYPE ObjectType, _In_ UINT64 Base, _In_ UINT64 Size
	, _Out_ UINT64* pPreCallbackAddress, _Out_ UINT64* pPostCallbackAddress)
{
	POBJECT_TYPE pObject = ObjectType;
	__try
	{
		POBJECT_CALLBACK_ENTRY pCallbackEntry = *(POBJECT_CALLBACK_ENTRY*)((UCHAR*)pObject + g_DynData.CallbackListOffset);
		POBJECT_CALLBACK_ENTRY Head = pCallbackEntry;
		while (TRUE)
		{
			if (MmIsAddressValid(pCallbackEntry->CallbackEntry->Altitude.Buffer))
			{
				UINT64 PreOp = (UINT64)pCallbackEntry->PreOperation;
				UINT64 PostOp = (UINT64)pCallbackEntry->PostOperation;

				if (PreOp > Base && PreOp < (Base + Size))
				{
					//kprintf("%s: Found PreOperation Callback at: %p\n", &pCallbackEntry->PreOperation);
					*pPreCallbackAddress = &pCallbackEntry->PreOperation;
				}

				if (PostOp > Base && PostOp < (Base + Size))
				{
					//kprintf("%s: Found PostOperation Callback at: %p\n", &pCallbackEntry->PostOperation);
					*pPostCallbackAddress = &pCallbackEntry->PostOperation;
				}
			}
			
			pCallbackEntry = (POBJECT_CALLBACK_ENTRY)pCallbackEntry->CallbackList.Flink;
			if (Head == pCallbackEntry)
				break;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return;
	}
}


OB_PREOP_CALLBACK_STATUS DummyObjectPreCallback()
{
	return OB_PREOP_SUCCESS;
}

VOID DummyObjectPostCallback()
{
	return;
}
```

`ObCallbacks.h`:

```h
#pragma once

#ifndef OB_CALLBACKS_H
#define OB_CALLBACKS_H

/*
	Enumerate ObCallbacks of *PsThreadType or *PsProcess Type.
	Checks if Pre and Post Callbacks are within the limits specified of Base and Size.
	Saves the Pre and Post Callback pointers.
*/
VOID EnumerateObCallbacks(_In_ POBJECT_TYPE ObjectType, _In_ UINT64 Base, _In_ UINT64 Size
						, _Out_ UINT64* pPreCallbackAddress, _Out_ UINT64* pPostCallbackAddress);

/*
	Disable ObCallbacks of Thread and Process If there they exist.
*/
VOID DisableObCallbacks();

/*
	Restore ObCallbacks with pointers saved from SaveOrigObCallbacks ( Call SaveOrigObCallbacks before calling this ).
*/
VOID RestoreObCallbacks();

/*
	Save Original ObCallbacks in a global container.
*/
VOID SaveOrigObCallbacks();

/*
	Dummy Pre Callback Function to disable all functionality of the callback.
*/
OB_PREOP_CALLBACK_STATUS DummyObjectPreCallback();

/*
	Dummy Post Callback Function to disable all functionality of the callback.
*/
VOID DummyObjectPostCallback();

typedef struct _OB_CALLBACK_ADDRESSES
{
	UINT64* pProcPreCallback, *pProcPostCallback;
	UINT64* pThreadPreCallback, *pThreadPostCallback;
	UINT64 OrigProcPre, OrigProcPost;
	UINT64 OrigThreadPre, OrigThreadPost;
}OB_CALLBACK_ADDRESSES, *POB_CALLBACK_ADDRESSES;

// Global ObAddress Container.
extern OB_CALLBACK_ADDRESSES ObAddys;


#endif // !OB_CALLBACKS_H


```

`PsNotify.c`:

```c
#include <ntddk.h>
#include "PsNotify.h"
#include "Global.h"
#include "Utils.h"



UINT64 FindPspLoadImageNotifyRoutine()
{
	UNICODE_STRING usFunc = { 0 };
	RtlInitUnicodeString(&usFunc, L"PsSetLoadImageNotifyRoutine");
	UINT64 Function = (UINT64)MmGetSystemRoutineAddress(&usFunc);
	
	if (!Function)
		return 0;
	
	char Pattern[3] = { 0x48,0x8D,0x0D };
	Function = FindPattern(Function, 0xFF, Pattern, sizeof(Pattern));
	if (Function)
	{
		LONG Offset = 0;
		memcpy(&Offset, (UCHAR*)(Function + 3), 4);
		Function = Function + 7 + Offset;
	}
	
	return Function;
}

NTSTATUS DisablePsImageCallback()
{
	UINT64 PspLoadImageFunc = FindPspLoadImageNotifyRoutine(), pRoutineAddress;
	if (PspLoadImageFunc)
	{
		ListCallbacks(PspLoadImageFunc, DriverInfo.Base, DriverInfo.Size, &pRoutineAddress, TRUE);
		return pRoutineAddress ? PsRemoveLoadImageNotifyRoutine(pRoutineAddress) : STATUS_UNSUCCESSFUL;
	}
	return STATUS_UNSUCCESSFUL;
}

UINT64 FindPspCreateProcessNotifyRoutine()
{
	UNICODE_STRING usFunc = { 0 };
	RtlInitUnicodeString(&usFunc, L"PsSetCreateProcessNotifyRoutine");
	UINT64 Function = (UINT64)MmGetSystemRoutineAddress(&usFunc);

	if (!Function)
		return 0;

	char Pattern1[2] = { 0xC2,0xE9 };
	Function = FindPattern(Function, 20, Pattern1, sizeof(Pattern1));
	if (Function)
	{
		LONG Offset = 0;
		memcpy(&Offset, (UCHAR*)(Function + 2), 4);
		Function = Function + 5 + Offset + 9;
	}

	char Pattern2[3] = { 0x4C,0x8D,0x25 };
	Function = FindPattern(Function, 0xFF, Pattern2, sizeof(Pattern2));
	if (Function)
	{
		LONG Offset = 0;
		memcpy(&Offset, (UCHAR*)(Function + 3), 4);
		UINT64 Addy = Function + 7 + Offset;
		return Addy;
	}
	
	return 0;
}

NTSTATUS DisablePsProcessCallback()
{
	UINT64 PspCreateProcessFunc = FindPspLoadImageNotifyRoutine(), pRoutineAddress;
	if (PspCreateProcessFunc)
	{
		ListCallbacks(PspCreateProcessFunc, DriverInfo.Base, DriverInfo.Size, &pRoutineAddress, TRUE);
		return pRoutineAddress ? PsSetCreateProcessNotifyRoutine(pRoutineAddress, TRUE) : STATUS_UNSUCCESSFUL;
	}
	return STATUS_UNSUCCESSFUL;
}

UINT64 FindPspCreateThreadNotifyRoutine()
{
	UNICODE_STRING usFunc = { 0 };
	RtlInitUnicodeString(&usFunc, L"PsSetCreateThreadNotifyRoutine");
	UINT64 Function = (UINT64)MmGetSystemRoutineAddress(&usFunc);

	if (!Function)
		return 0;

	char Pattern1[3] = { 0x33,0xD2,0xE9 };
	Function = FindPattern(Function, 20, Pattern1, sizeof(Pattern1));
	if (Function)
	{
		LONG Offset = 0;
		memcpy(&Offset, (UCHAR*)(Function + 3), 4);
		Function = Function + 5 + Offset;
	}

	char Pattern2[3] = { 0x48,0x8D,0x0D };
	Function = FindPattern(Function, 0xFF, Pattern2, sizeof(Pattern2));
	if (Function)
	{
		LONG Offset = 0;
		memcpy(&Offset, (UCHAR*)(Function + 3), 4);
		UINT64 Addy = Function + 7 + Offset;
		return Addy;
	}

	return 0;
}

NTSTATUS DisablePsThreadCallback()
{
	UINT64 PspCreateThreadFunc = FindPspCreateThreadNotifyRoutine(), pRoutineAddress;
	if (PspCreateThreadFunc)
	{
		ListCallbacks(PspCreateThreadFunc, DriverInfo.Base, DriverInfo.Size, &pRoutineAddress, TRUE);
		return pRoutineAddress ? PsRemoveCreateThreadNotifyRoutine(pRoutineAddress) : STATUS_UNSUCCESSFUL;
	}
	return STATUS_UNSUCCESSFUL;
}

VOID ListCallbacks(
	_In_ UINT64* Psp,
	_In_ UINT64 Base, _In_ UINT64 Size,
	_Out_ UINT64* pCallbackAddress,
	_In_ BOOLEAN bSaveCallback
)
{
	if (Psp)
	{
		__try
		{
			for (int i = 0; i < 0x10; ++i)
			{
				if (!MmIsAddressValid((PVOID)Psp[i]))
					continue;

				PPS_CALLBACK_ENTRY monCallBack = (PPS_CALLBACK_ENTRY)Mask3Bits(Psp[i]);

				if (MmIsAddressValid(monCallBack->Callback))
				{
					if ((UINT64)monCallBack->Callback > Base && (UINT64)monCallBack->Callback < (Base + Size))
					{
						kprintf("%s: Found Callback Address at: %p\n", __FUNCTION__, monCallBack->Callback);
						if (bSaveCallback)
							*pCallbackAddress = (UINT64)monCallBack->Callback;
						else
							monCallBack->Callback = (PVOID*)*pCallbackAddress;
					}
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			return;
		}
	}
}


VOID DummyNotifyRoutine()
{
	return;
}
```

`PsNotify.h`:

```h
#pragma once

#ifndef PS_NOTIFY_H
#define PS_NOTIFY_H

#define Mask3Bits(addr)	 (((ULONG_PTR) (addr)) & ~7)

typedef struct _PS_CALLBACK_ENTRY
{
	PVOID* Callback;
	LARGE_INTEGER* Fillz;
} PS_CALLBACK_ENTRY, *PPS_CALLBACK_ENTRY;

UINT64 FindPspLoadImageNotifyRoutine();
UINT64 FindPspCreateProcessNotifyRoutine();
UINT64 FindPspCreateThreadNotifyRoutine();

NTSTATUS DisablePsImageCallback();
NTSTATUS DisablePsProcessCallback();
NTSTATUS DisablePsThreadCallback();

/*
	Searching for the callback address for disabling it.
	Uses the Psp as base.
*/
VOID ListCallbacks(
	_In_ UINT64* Psp,
	_In_ UINT64 Base, _In_ UINT64 Size,
	_Out_ UINT64* pCallbackAddress,
	_In_ BOOLEAN bSaveCallback
);

VOID DummyNotifyRoutine();

#endif PS_NOTIFY_H
```

`README.md`:

```md
well ig its time i release this, this was a project made by me and dear sk4ller (if you are seeing this sk4ller, this is only being released due to the fact someone else has decided to leech the project (mr anti geek to be specfic) and sold copies behind my back and i simply do not trust him)

so how does this work?

we can take a quick dip into obregistercallbacks in windows internal 

link : https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks

more links : https://www.unknowncheats.me/forum/anti-cheat-bypass/148364-obregistercallbacks-and-countermeasures.html

what we are doing here is basically just disabling the call backs without restoring them and then we can simply r/w memory safely with anything (you can use process hacker and try to dump strings to test / view memory)

Good luck pasting this, i will leave a built version of the driver that is signed in the source x64 path.

to use this just create a service using the following

if you want to update this for each ver of the anti cheat just get the name of the driver and replace it in the source (pretty stupid yep)

"sc create driver binpath="path/kernel.sys" type="kernel"

then just sign it with a leaked cert and start it, enjoy.

credits : me (seemo), sk4ller

emotional support for seemo : fizware / fizzy

```

`Utils.c`:

```c
#include <ntddk.h>
#include "Utils.h"
#include "Global.h"


BOOLEAN GetDriverInformation(
	_In_ wchar_t* DriverName,
	_In_ PDRIVER_OBJECT pDriver,
	_Out_ UINT64* ModuleBase,
	_Out_ UINT64* ModuleSize
)
{
	UINT64 pLdrDataEntry = (UINT64)pDriver->DriverSection;
	UINT64 pHead = pLdrDataEntry;
	do
	{
		if (MmIsAddressValid(pLdrDataEntry + 0x58))
		{
			PUNICODE_STRING pusName = (PUNICODE_STRING)(pLdrDataEntry + 0x58);
			kprintf("%wZ\n", pusName);

			if (MmIsAddressValid(pusName->Buffer))
			{
				if (!memcmp(pusName->Buffer, DriverName, sizeof(DriverName)))
				{
					if (MmIsAddressValid(pLdrDataEntry + 0x30))
						*ModuleBase = *(ULONGLONG*)(pLdrDataEntry + 0x30);

					if (MmIsAddressValid(pLdrDataEntry + 0x40))
						*ModuleSize = *(ULONG*)(pLdrDataEntry + 0x40);

					return TRUE;

				}
			}
		}

		pLdrDataEntry = *(UINT64*)pLdrDataEntry;
	} while (pHead != pLdrDataEntry);
	return FALSE;
}

UINT64 FindPattern(
	_In_ UINT64 Base,
	_In_ UINT64 Size,
	_In_ char* Pattern,
	_In_ size_t PatternSize
)
{
	__try
	{
		for (UINT64 i = Base; i < (Base + Size); ++i)
		{
			for (int j = 0; j < PatternSize; ++j)
			{
				if ((UCHAR)Pattern[j] == *(UCHAR*)(i + j))
				{					
					if (j == (PatternSize - 1))
						return i;
				}
				else
					break;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		kprintf("%s: Exception!\n", __FUNCTION__);
		return 0;
	}
	return 0;
}


BOOLEAN InitDynamicData()
{
	RTL_OSVERSIONINFOEXW VersionInfo = { 0 };
	BOOLEAN bStatus = TRUE;

	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	NTSTATUS status = RtlGetVersion(&VersionInfo);

	if (bStatus = NT_SUCCESS(status))
	{		
		if (VersionInfo.dwBuildNumber >= 9200)
			g_DynData.CallbackListOffset = 0xC8;

		else if (VersionInfo.dwBuildNumber >= 7600)
			g_DynData.CallbackListOffset = 0xC0;

		else
			bStatus = FALSE;
	}
	return bStatus;
}
```

`Utils.h`:

```h
#pragma once

#ifndef UTILS_H
#define UTILS_H

/*
	Traversing the DriverObjects linked list for the specified driver.
*/
BOOLEAN GetDriverInformation(
	_In_ wchar_t* DriverName,
	_In_ PDRIVER_OBJECT pDriver,
	_Out_ UINT64* ModuleBase,
	_Out_ UINT64* ModuleSize
);

UINT64 FindPattern(
	_In_ UINT64 Base,
	_In_ UINT64 Size,
	_In_ char* Pattern,
	_In_ size_t PatternSize
);

BOOLEAN InitDynamicData();

#endif // !UTILS_H

```

`blocker_km.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33529.622
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ricochet", "blocker_km.vcxproj", "{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM.ActiveCfg = Debug|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM.Build.0 = Debug|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM.Deploy.0 = Debug|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM64.Build.0 = Debug|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x64.ActiveCfg = Debug|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x64.Build.0 = Debug|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x64.Deploy.0 = Debug|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x86.ActiveCfg = Debug|Win32
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x86.Build.0 = Debug|Win32
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Debug|x86.Deploy.0 = Debug|Win32
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM.ActiveCfg = Release|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM.Build.0 = Release|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM.Deploy.0 = Release|ARM
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM64.ActiveCfg = Release|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM64.Build.0 = Release|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|ARM64.Deploy.0 = Release|ARM64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x64.ActiveCfg = Release|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x64.Build.0 = Release|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x64.Deploy.0 = Release|x64
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x86.ActiveCfg = Release|Win32
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x86.Build.0 = Release|Win32
		{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}.Release|x86.Deploy.0 = Release|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|ARM.ActiveCfg = Debug|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|ARM64.ActiveCfg = Debug|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|x64.ActiveCfg = Debug|x64
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|x64.Build.0 = Debug|x64
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|x86.ActiveCfg = Debug|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Debug|x86.Build.0 = Debug|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|ARM.ActiveCfg = Release|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|ARM64.ActiveCfg = Release|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|x64.ActiveCfg = Release|x64
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|x64.Build.0 = Release|x64
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|x86.ActiveCfg = Release|Win32
		{591BFCAD-7E6C-467F-B5C2-F1B9BE5D2895}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {25C777F8-7C9B-4759-89C8-9B77EE27F664}
	EndGlobalSection
EndGlobal

```

`blocker_km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D7898E3F-9FE9-4A57-9C2B-5FB2A6F4836E}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>CallbackRootkit</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>block</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TargetName>Call</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>C:\Program Files %28x86%29\Windows Kits\10\Lib\10.0.14393.0\km\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>fltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>
      </FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>
      </FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="ObCallbacks.c" />
    <ClCompile Include="PsNotify.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Global.h" />
    <ClInclude Include="Native.h" />
    <ClInclude Include="ObCallbacks.h" />
    <ClInclude Include="PsNotify.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`blocker_km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ObCallbacks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PsNotify.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ObCallbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Native.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PsNotify.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`blocker_km.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TestCertificate>CN="WDKTestCert Seemo,133367362529508539" | A578D408B23CCC70669A690FFE3DE8E440374D17</TestCertificate>
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TestCertificate>CN="WDKTestCert Seemo,133367362529508539" | A578D408B23CCC70669A690FFE3DE8E440374D17</TestCertificate>
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`main.c`:

```c
#include <ntddk.h>
#include "Native.h"
#include "ObCallbacks.h"
#include "PsNotify.h"
#include "Utils.h"
#include "Global.h"


Module DriverInfo = { 0 };
PDRIVER_OBJECT g_pDriverObject = 0;
DYNDATA g_DynData = { 0 };

/* 
	I/O Driver Control Function:
	CTL_GET_DRIVERINFO: 
		Retrieves Base Address and Size of the Driver Specified in SystemBuffer.

	CTL_DISABLE_OB_CALLBACKS:
		Disables ObCallbacks of the thread and process of the driver specified ( call CTL_GET_DRIVERINFO before this ).

	CTL_RESTORE_OB_CALLBACKS:
		Restores ObCallbacks of the thread and process of the driver specified ( call CTL_GET_DRIVERINFO before this ).

	CTL_DISABLE_IMAGE_CALLBACK:
		Disables ImageLoadNotifyRoutine of the specified driver ( call CTL_GET_DRIVERINFO before this ).

	CTL_DISABLE_PROCESS_CALLBACK:
		Disables ProcessNotifyRoutine of the specified driver ( call CTL_GET_DRIVERINFO before this ).

	CTL_DISABLE_THREAD_CALLBACK:
		Disables ThreadNotifyRoutine of the specified driver ( call CTL_GET_DRIVERINFO before this ).
*/
NTSTATUS IOControl(DEVICE_OBJECT* pDeviceObject, IRP* Irp)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	kprintf("Called %s!\n", __FUNCTION__);

	IO_STACK_LOCATION* pStackLoc = IoGetCurrentIrpStackLocation(Irp);

	if (pStackLoc)
	{
		switch (pStackLoc->Parameters.DeviceIoControl.IoControlCode)
		{
		case CTL_GET_DRIVERINFO:
			
			kprintf("%s: Getting Driver Info\n", __FUNCTION__);
			DRIVERNAME name = *(DRIVERNAME*)Irp->AssociatedIrp.SystemBuffer;
			GetDriverInformation(name.Name, g_pDriverObject, &DriverInfo.Base, &DriverInfo.Size);
			kprintf("Base: %p \t Size: 0x%X\n", DriverInfo.Base, DriverInfo.Size);
			break;

		case CTL_DISABLE_OB_CALLBACKS:

			kprintf("%s: Disabling ObCallbacks\n", __FUNCTION__);
			DisableObCallbacks();
			break;

		case CTL_RESTORE_OB_CALLBACKS:

			kprintf("%s: Restore ObCallbacks\n", __FUNCTION__);
			RestoreObCallbacks();
			break;

		case CTL_DISABLE_IMAGE_CALLBACK:

			kprintf("%s: Disabling Image Callback\n", __FUNCTION__);
			status = DisablePsImageCallback();
			break;

		case CTL_DISABLE_PROCESS_CALLBACK:

			kprintf("%s: Disabling Process Callback\n", __FUNCTION__);
			status = DisablePsProcessCallback();
			break;

		case CTL_DISABLE_THREAD_CALLBACK:

			kprintf("%s: Disabling Thread Callback\n", __FUNCTION__);
			status = DisablePsThreadCallback();
			break;

		default:
			status = STATUS_INVALID_PARAMETER;
			break;
		}
		Irp->IoStatus.Status = status;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}

	return status;
}

NTSTATUS MJCreateAndClose(DEVICE_OBJECT* pDeviceObject, IRP* Irp)
{
	UNREFERENCED_PARAMETER(pDeviceObject);

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/*
	Restore ObCallbacks if I/O forgot to do it to prevent BSOD.
*/
void DriverUnload(PDRIVER_OBJECT pDriver)
{
	kprintf("%s: Done!\n", __FUNCTION__);

	UNICODE_STRING usDosDeviceName;
	RtlInitUnicodeString(&usDosDeviceName, DosDeviceName);
	IoDeleteSymbolicLink(&usDosDeviceName);

	RestoreObCallbacks();

	IoDeleteDevice(pDriver->DeviceObject);
}

/*
	Check if OS is supported.
	Create Symbolic Link for I/O.
	Save Original ObCallbacks for restoring them later.
*/
NTSTATUS LoadBlocker()
{

}
typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
PVOID GetSystemRoutineAddress(LPCWSTR name)
{
	UNICODE_STRING unicodeName;
	RtlInitUnicodeString(&unicodeName, name);
	return MmGetSystemRoutineAddress(&unicodeName);
}
PVOID GetSystemModuleBase(LPCWSTR name)
{
	PLIST_ENTRY loadedModuleList = (PLIST_ENTRY)(GetSystemRoutineAddress(L"PsLoadedModuleList"));
	if (!loadedModuleList)
	{
		return NULL;
	}
	__try
	{
		for (PLIST_ENTRY link = loadedModuleList->Flink; link != loadedModuleList; link = link->Flink)
		{
			LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
			if (_wcsicmp(name, entry->BaseDllName.Buffer) == 0)
			{
				return entry->DllBase;
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return NULL;
	}
	return NULL;
}




BOOLEAN IsDriverValid(PVOID driverBase)
{

	if (driverBase == NULL) {
		return FALSE;
	}
	UCHAR* driverCode = (UCHAR*)driverBase;

	if (driverCode[0] == 'M' && driverCode[1] == 'Z') {
		return TRUE;
	}


	return FALSE;
}
VOID PerformActionsOnDriverFound()
{
	KdPrint("Found Randgrid : %s\n", L"randgrid.sys");

	DRIVERNAME gemmaDriverName = { L"randgrid.sys" };
	GetDriverInformation(gemmaDriverName.Name, g_pDriverObject, &DriverInfo.Base, &DriverInfo.Size);
	SaveOrigObCallbacks();
	DisableObCallbacks();
}

NTSTATUS searcherThreadRoutine(_In_ PVOID Context)
{

	while (TRUE)
	{
		PVOID ranggrid = GetSystemModuleBase(L"randgrid.sys");

		if (ranggrid)
		{
			DRIVERNAME gemmaDriverName = { L"randgrid.sys" };
			GetDriverInformation(gemmaDriverName.Name, g_pDriverObject, &DriverInfo.Base, &DriverInfo.Size);
			SaveOrigObCallbacks();
			DisableObCallbacks();
		}

		LARGE_INTEGER Interval;
		Interval.QuadPart = -5 * 10 * 1000 * 1000; 

		KeDelayExecutionThread(KernelMode, FALSE, &Interval);
	}

	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT kdmapperParam1, _In_ PUNICODE_STRING RegistryPath)
{

	UNREFERENCED_PARAMETER(kdmapperParam1);
	UNREFERENCED_PARAMETER(RegistryPath);


	if (!InitDynamicData())
		return STATUS_UNSUCCESSFUL;

	PDEVICE_OBJECT pDevice = NULL;
	UNICODE_STRING usDeviceName, usDosDeviceName;
	g_pDriverObject = kdmapperParam1;

	RtlInitUnicodeString(&usDeviceName, DeviceName);
	RtlInitUnicodeString(&usDosDeviceName, DosDeviceName);

	NTSTATUS status = IoCreateDevice(kdmapperParam1, 0, &usDeviceName
		, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN
		, FALSE, &pDevice);
	if (NT_SUCCESS(status))
	{
		status = IoCreateSymbolicLink(&usDosDeviceName, &usDeviceName);

		if (NT_SUCCESS(status))
		{
			kdmapperParam1->DriverUnload = DriverUnload;
			kdmapperParam1->MajorFunction[IRP_MJ_CREATE] = MJCreateAndClose;
			kdmapperParam1->MajorFunction[IRP_MJ_CLOSE] = MJCreateAndClose;
			kdmapperParam1->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOControl;

			HANDLE hThread;
			PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, searcherThreadRoutine, NULL);

				
			
		}
	}

	return status;
}



```