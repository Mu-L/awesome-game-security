Project Path: arc_gmh5225_rust-external-1_23msgfit

Source Tree:

```txt
arc_gmh5225_rust-external-1_23msgfit
├── README.md
└── src
    ├── cheats.cpp
    ├── cheats.hpp
    ├── includes.hpp
    └── main.cpp

```

`README.md`:

```md
# Rust External
A very easy-to-read base for an external Rust cheat, do realise you need your own bypassing method and you're probably better off with
an internal cheat. I wrote this over a few spare hours I had, feeling cute so I will release it (without any bypass)

## Features
- Player ESP
- TC ESP
- Aimbot (not silent)

**Does not feature a fancy gui, if thats what you're into.**

```

`src/cheats.cpp`:

```cpp
#include "cheats.hpp"

template<typename T> T RPM(SIZE_T address)
{
	T buffer;
	ReadProcessMemory(hProcess, (LPCVOID)address, &buffer, sizeof(T), NULL);
	return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer)
{
	WriteProcessMemory(hProcess, (LPVOID)address, &buffer, sizeof(buffer), NULL);
}

uint32_t get_pid(const char* procName)
{
    PROCESSpeentry32 peentry;
    
    peentry.dwSize = sizeof(PROCESSpeentry32);
    HANDLE phandle = CreateToolhelp32phandle(TH32CS_SNAPPROCESS, 0);

    if (Process32First(phandle, &peentry) == 1)
    {
        while (Process32Next(phandle, &peentry) == 1)
        {
            if (stricmp(peentry.szExeFile, procName) == 0)
            {
                uint32_t pid = (uint32_t)peentry.th32ProcessID;
                CloseHandle(phandle);
                
                return pid;
            }
        }
    }

    CloseHandle(phandle);
    return 0;
}

bool check_game_loaded()
{
    return (bool)RPM<int>(baseAddr + 0xF4);
}

void draw_esp_players(int distance)
{
    int buffer = 1;
    
    WPM(baseAddr + 0xF89B41C, buffer);
    return;
}

void draw_esp_tc(int distance)
{
    int buffer = 1;
    
    WPM(baseAddr + 0xF89A12A, buffer);
    return;
}

void move_to_nearest_head()
{
    // not implemented yet
}

```

`src/cheats.hpp`:

```hpp
#include "includes.hpp"

uint32_t get_pid(const char* procName);
bool check_game_loaded();

void draw_esp_players(int distance);
void draw_esp_tc(int distance);

void move_to_nearest_head();

```

`src/includes.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <iostream>
#include <Tlhelp32.h>

#include "cheats.hpp"

```

`src/main.cpp`:

```cpp
#include "includes.hpp"

bool cheat_ready = false; /* hang me */

void init_cheat()
{
    check_game_loaded();
    
    cheat_ready = true;
    return;
}

DWORD WINAPI cheat_thread()
{
    // cheats for gamers go here
    if(!cheat_ready)
    {
        std::cout << "Cheat not ready... Shutting down...\r\n";
        exit(-1);
    }
    
    while(1) {
        draw_esp_players(1000); // max_dist
        draw_esp_tc(350); // max_dist: higher = more lag
        
        // You must hold down RMB for this to work.
        move_to_nearest_head();
    }
}

int main()
{
    std::cout << "Checking for rust...\r\n";
    
    while(get_pid("Rust.exe") == 0)
        std::cout << "[err] launch rust\r\n";
    
    uint32_t proc_id = get_pid("Rust.exe"); //get_pid(const char* proc_name);
    init_cheat(proc_id);
    
    HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)cheat_thread, NULL, NULL, 0);
}

```