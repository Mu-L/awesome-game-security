Project Path: arc_gmh5225_Overwatch2-colorbot-Cheats__cvf9buy

Source Tree:

```txt
arc_gmh5225_Overwatch2-colorbot-Cheats__cvf9buy
├── README.md
└── colorbot
    ├── arduino-contact.ino
    ├── grabber.py
    └── main.py

```

`README.md`:

```md
# Overwatch2-colorbot-cheats
Triggerbot and aimbot made for overwatch two. Set your enemy outline to purple. Code was partially taken from Unknown cheats then greatly modified.  Uses Arduino Leonardo as mouse bypass.

```

`colorbot/arduino-contact.ino`:

```ino
#include <Mouse.h>

int dx;
int dy;
int dxn;
int dyn;
int index = 0;
int num_size = 0;


int jump = 127;

void setup()
{
    Mouse.begin();
    Serial.begin(115200);
    Serial.setTimeout(0);
    Serial.println("Start");

}

void loop()
{
    if (Serial.available())
    {

        String data = Serial.readString();
        if (data == "shoot")
        {
            Mouse.click();
        }

        else if (data.substring(0, 6) == "silent")
        {
            data.remove(0, 6);
            index = 0;
            num_size = data.indexOf(":", index);
            dx = data.substring(index, num_size).toInt();
            data.remove(0, num_size + 1);
            dy = data.toInt();
            dxn = dx * -1;
            dyn = dy * -1;

            if (dx > 0)
            {
                while (dx > 127)
                {
                    dx -= 127;
                    Mouse.move(127, 0);
                }
                Mouse.move(dx, 0);
            }
            else if (dx < 0)
            {
                while (dx < -127)
                {
                    dx += 127;
                    Mouse.move(-127, 0);
                }
                Mouse.move(dx, 0);
            }
            if (dy >= 0)
            {
                while (dy > 127)
                {
                    dy -= 127;
                    Mouse.move(0, 127);
                }
                Mouse.move(0, dy);
            }
            else if (dy <= 0)
            {
                while (dy < -127)
                {
                    dy += 127;
                    Mouse.move(0, -127);
                }
                Mouse.move(0, dy);
            }
            Mouse.click();
            if (dxn > 0)
            {
                while (dxn > 127)
                {
                    dxn -= 127;
                    Mouse.move(127, 0);
                }
                Mouse.move(dxn, 0);
            }
            else if (dxn < 0)
            {
                while (dxn < -127)
                {
                    dxn += 127;
                    Mouse.move(-127, 0);
                }
                Mouse.move(dxn, 0);
            }
            if (dyn > 0)
            {
                while (dyn > 127)
                {
                    dyn -= 127;
                    Mouse.move(0, 127);
                }
                Mouse.move(0, dyn);
            }
            else if (dyn < 0)
            {
                while (dyn < -127)
                {
                    dyn += 127;
                    Mouse.move(0, -127);
                }
                Mouse.move(0, dyn);
            }
        }

        else
        {
            index = 0;
            num_size = data.indexOf(":", index);
            dx = data.substring(index, num_size).toInt();
            data.remove(0, num_size + 1);
            dy = data.toInt();
            // Serial.println(dx+":"+dy);
            if (dx > 0)
            {
                while (dx > jump)
                {
                    dx -= jump;
                    Mouse.move(jump, 0);
                }
                Mouse.move(dx, 0);
            }
            else if (dx < 0)
            {
                while (dx < -jump)
                {
                    dx += jump;
                    Mouse.move(-jump, 0);
                }
                Mouse.move(dx, 0);
            }
            if (dy >= 0)
            {
                while (dy > jump)
                {
                    dy -= jump;
                    Mouse.move(0, jump);
                }
                Mouse.move(0, dy);
            }
            else if (dy <= 0)
            {
                while (dy < -jump)
                {
                    dy += jump;
                    Mouse.move(0, -jump);
                }
                Mouse.move(0, dy);
            }
        
        }
    }
    
}
```

`colorbot/grabber.py`:

```py
import cv2
from mss import mss
import numpy as np



class Grabber:
    def __init__(self) -> None:
        
        # self.lower = np.array([139, 96, 129], np.uint8)
        # self.upper = np.array([169, 255, 255], np.uint8)
        # self.lower = np.array([139, 95, 154], np.uint8)
        # self.upper = np.array([153, 255, 255], np.uint8)


        # self.lower = np.array([139, 96, 129], np.uint8)
        # self.upper = np.array([169, 255, 255], np.uint8)
        self.lower = np.array([139, 96, 139], np.uint8)
        self.upper = np.array([157, 255, 255], np.uint8)
    def find_dimensions(self, scale,witdh,height):
        """Calculates constants required for the bot."""
        region = (int(witdh/2-witdh/scale/2),int(height/2-height/scale/2),int(witdh/2+witdh/scale/2),int(height/2+height/scale/2))
        x,y,width,height = region
        self.box_middle_x = int((width-x)/2)
        self.box_middle_y = int((height-y)/2)
        self.dimensions = region

    def process_frame(self, frame):
        """Performs operations on a frame to improve contour detection."""
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        processed = cv2.inRange(hsv, self.lower, self.upper)
        processed = cv2.morphologyEx(processed, cv2.MORPH_CLOSE, np.ones((10, 10), np.uint8))
        dilatation_size = 2
        dilation_shape = cv2.MORPH_RECT
        element = cv2.getStructuringElement(dilation_shape, (2 * dilatation_size + 1, 2 * dilatation_size + 1),
                                    (dilatation_size, dilatation_size))
        processed = cv2.dilate(processed, element)
        # processed = cv2.blur(processed, (1, 1))
        return processed
    def detect_contours(self, frame, minimum_size):
        """Returns contours larger then a specified size in a frame."""
        contours, hierarchy = cv2.findContours(frame, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        large_contours = []
        if len(contours) != 0:
            for i in contours:
                if cv2.contourArea(i) > minimum_size:
                    large_contours.append(i)
        return large_contours
    def scale_contour(self,cnt, scale:float):
        M = cv2.moments(cnt)
        cx = int(M['m10']/M['m00'])
        cy = int(M['m01']/M['m00'])

        cnt_norm = cnt - [cx, cy]
        cnt_scaled = cnt_norm * scale
        cnt_scaled = cnt_scaled + [cx, cy]
        cnt_scaled = cnt_scaled.astype(np.int32)

        return cnt_scaled
    def on_target(self, contour):
        """Returns x- and y- coordinates of the center of the largest contour."""
        for c in contour:
            cont = self.scale_contour(c,0.85)
            test = cv2.pointPolygonTest(cont,(self.box_middle_x,self.box_middle_y),False)
            if test >= 0:
                return True
        return False
    def compute_centroid(self, contour):
        """Returns x- and y- coordinates of the center of the largest contour."""
        c = max(contour, key=cv2.contourArea)
        rectangle = np.int0(cv2.boxPoints(cv2.minAreaRect(c)))
        new_box = []
        for point in rectangle:
            point_x = point[0]
            point_y = point[1]
            new_box.append([round(point_x, -1), round(point_y, -1)])
        M = cv2.moments(np.array(new_box))
        if M['m00']:
            center_x = (M['m10'] / M['m00'])
            center_y = (M['m01'] / M['m00'])
            x = -(self.box_middle_x - center_x)
            y = -(self.box_middle_y - center_y)
            return [], x, y

```

`colorbot/main.py`:

```py

from grabber import *
import time
import dxcam
import keyboard
import serial
import threading
import time
def cooldown(cooldown_bool,wait):
    #cooldown threed for toggels or cooldowns
    time.sleep(wait)
    cooldown_bool[0] = True


MONITOR_SCALE = 3 #fov
serialcomm = serial.Serial('COM3',115200, timeout = 0)#com port for arduino
grabber = Grabber()
grabber.find_dimensions(MONITOR_SCALE,1920,1080)
aim_bot_toggle = [True]
aim_bot = False
trigger_bot_toggle = [True]
trigger_bot = False
camera = dxcam.create(device_idx=0, output_idx=0, output_color= "BGRA")
camera.start(region=grabber.dimensions,target_fps=200)
start_time = time.time()
h = 1
counter = 0
while True:

    # print(grabber.dimensions)
    og = camera.get_latest_frame()
    frame = grabber.process_frame(og)
    contours = grabber.detect_contours(frame, 100)
    counter+= 1
    if(time.time() - start_time) > h:
        fps = "fps:"+ str(int(counter/(time.time() - start_time)))
        print(fps)
        counter = 0
        start_time = time.time()
    if keyboard.is_pressed('`'):
        if aim_bot_toggle[0] == True:
            aim_bot = not aim_bot
            print(aim_bot)
            aim_bot_toggle[0] = False
            thread = threading.Thread(target=cooldown, args=(aim_bot_toggle,0.2,))
            thread.start()
    if keyboard.is_pressed('alt'):
        if trigger_bot_toggle[0] == True:
            trigger_bot = not trigger_bot
            print(trigger_bot)
            trigger_bot_toggle[0] = False
            thread = threading.Thread(target=cooldown, args=(trigger_bot_toggle,0.2,))
            thread.start()
    if contours:
        try:
            rec, x, y = grabber.compute_centroid(contours)
            if aim_bot:
                data = f"{int(x/4)}:{int(y/4)}"
                serialcomm.write(data.encode())
            if trigger_bot and grabber.on_target(contours):
                serialcomm.write("shoot".encode())
        except:
            print("",end="")



    #     cv2.drawContours(og, contours, -1, (0, 0, 0), 2)
        
    # cv2.imshow('frame', og)
    # if (cv2.waitKey(1) & 0xFF) == ord('q'):
    #     cv2.destroyAllWindows()
    #     exit()



```