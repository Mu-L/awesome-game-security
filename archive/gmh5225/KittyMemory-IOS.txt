Project Path: arc_gmh5225_KittyMemory-IOS_c77l4dss

Source Tree:

```txt
arc_gmh5225_KittyMemory-IOS_c77l4dss
├── LICENSE
├── README.md
├── jailbreak
│   ├── KittyMemory-IOS
│   │   ├── KittyMemory.cpp
│   │   ├── KittyMemory.hpp
│   │   ├── MemoryModifier.cpp
│   │   ├── MemoryModifier.hpp
│   │   └── darwin
│   │       └── mach_vm.h
│   └── test
│       └── Tweak.xm
└── jailed
    ├── KittyMemory-IOS
    │   ├── KittyMemory.cpp
    │   ├── KittyMemory.hpp
    │   ├── MemoryModifier.cpp
    │   ├── MemoryModifier.hpp
    │   └── darwin
    │       └── mach_vm.h
    └── test
        └── Tweak.xm

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 MJ

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# KittyMemory-IOS
runtime memory editor library, made specifically for IOS

```

`jailbreak/KittyMemory-IOS/KittyMemory.cpp`:

```cpp
//
//  KittyMemory.cpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#include "KittyMemory.hpp"

bool MemKitty::hasASLR() {
 // PIE applies ASLR to the binary
   return (_dyld_get_image_header(0)->flags & MH_PIE);
}


bool MemKitty::x_protect(void *addr, size_t length, int protection) {
   void     *pageStart = (void *)_START_PAGE_OF_(addr);
   uintptr_t pageSize  = _SIZE_PAGE_OF_(addr, length);

   return (
     mprotect(pageStart, pageSize, protection) != -1
 );
}

 kern_return_t MemKitty::getPageInfo(uintptr_t addr, vm_region_submap_short_info_64 *outInfo) {
   vm_address_t region  = (vm_address_t) addr;
   vm_size_t region_len = 0;
   mach_msg_type_number_t info_count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
   natural_t max_depth  = 99999;
   kern_return_t kr = vm_region_recurse_64(mach_task_self(), &region, &region_len,
                                           &max_depth,
                                           (vm_region_recurse_info_t) outInfo,
                                           &info_count);
   if(kr == KERN_SUCCESS)
      outInfo->protection &= (PROT_READ | PROT_WRITE | PROT_EXEC);

   return kr;
}


void *MemKitty::MemCopy(void* dst, const void* src, size_t size){
    uint8_t *destination = (uint8_t*) dst;
    uint8_t *source      = (uint8_t*) src;

    int step = sizeof(uint8_t);

    for(int i = 0; i < size; i++){
        *((uint8_t*)destination) = *((uint8_t*)source);
        destination += step;
        source      += step;
    }
    return dst;
}

/* refs to:
https://github.com/comex/substitute/blob/master/lib/darwin/execmem.
https://github.com/everettjf/AppleTrace/blob/master/hookzz/src/zzdeps/darwin/memory-utils-darwin.c
*/
void *MemKitty::writeWrapper(void *dst, const void *src, size_t len) {

   uintptr_t startPage  = _START_PAGE_OF_(dst);
   uintptr_t offsetPage = _OFFSET_PAGE_OF_(dst);
   uintptr_t pageSize   = _SIZE_PAGE_OF_(dst, len);

   vm_region_submap_short_info_64 info;
   if(getPageInfo(startPage, &info) != KERN_SUCCESS)
       return NULL;

  // check if write permission is already there
   if(info.protection & PROT_WRITE)
       return MemCopy(dst, src, len);

   // map new page for our changes
   void *newMap = mmap(NULL, pageSize, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
   if (newMap == NULL)
        return NULL;

   mach_port_t selfTask = mach_task_self();
   kern_return_t kr;

 // copy dst page into our new mapped page
   kr = vm_copy(selfTask, startPage, pageSize, (vm_address_t)newMap);
   if (kr != KERN_SUCCESS)
       return NULL;

   // write changes into our page
   MemCopy((void *)((uintptr_t)newMap + offsetPage), src, len);

   // change protection to match dst protection
   if(mprotect(newMap, pageSize, info.protection) == -1)
       return NULL;

  // re-map our page and overwrite dst
   mach_vm_address_t dstTarget = (mach_vm_address_t)startPage;
   vm_prot_t c, m;
   kr = mach_vm_remap(selfTask, &dstTarget, pageSize, 0, VM_FLAGS_OVERWRITE,
     selfTask, (mach_vm_address_t)newMap, /*copy*/ TRUE, &c, &m, info.inheritance);

   if (kr != KERN_SUCCESS)
       return NULL;

   // clean up
    munmap(newMap, pageSize);

    return dst;
}

// write in memory at given address (copies src into dst)
void *MemKitty::writeMemory(void *dst, const void *src, size_t len) {
  if (!src || !dst || len < 1)
      return NULL;

  void *address = (void *)_FIXED_ADDR_(dst);
  return writeWrapper(address, src, len);
}

// reads from memory at given address (copies dst bytes into the buffer)
void *MemKitty::readMemory(void *dst, void *buffer, size_t len) {
  if (!dst || len < 1)
      return NULL;

  void *address = (void *)_FIXED_ADDR_(dst);

  vm_region_submap_short_info_64 info;
  if(getPageInfo(_START_PAGE_OF_(address), &info) != KERN_SUCCESS)
     return NULL;

  // check read permission
  if(info.protection & PROT_READ)
     return MemCopy(buffer, address, len);

  if(x_protect(address, len, info.protection | PROT_READ)){
     void *ret = MemCopy(buffer, address, len);
     x_protect(address, len, info.protection);
     return ret;
  }

  return NULL;
}


// reads bytes into hex string at the given address
std::string MemKitty::read2HexStr(void *addr, size_t len) {
  char tmp[len];
  memset(tmp, 0, len);

  size_t bufferLen = len*2 + 1;
  char buffer[bufferLen];
  memset(buffer, 0, bufferLen);

  std::string ret  = "0x";

  if(readMemory(addr, tmp, len) == NULL)
    return ret;

  for(int i = 0; i < len; i++){
    sprintf(&buffer[i*2], "%02X", (unsigned char)tmp[i]);
  }

  ret += buffer;
  return ret;
}


MemKitty::mach_info MemKitty::getBaseInfo(){
 mach_info _info = {
   0,
   _dyld_get_image_header(0),
   _dyld_get_image_name(0),
   (uintptr_t)_dyld_get_image_vmaddr_slide(0)
 };
 return _info;
}



MemKitty::mach_info MemKitty::getMemoryMachInfo(const char *fileName){
  mach_info _info = {};

  int imageCount = _dyld_image_count();

   for(int i = 0; i < imageCount; i++) {
     const char *name = _dyld_get_image_name(i);
     const mach_header *header = _dyld_get_image_header(i);
       if(!strstr(name, fileName)) continue;

       mach_info new_info = {
         i, header, name, (uintptr_t)_dyld_get_image_vmaddr_slide(i)
       };

       _info = new_info;
     }
     return _info;
   }

```

`jailbreak/KittyMemory-IOS/KittyMemory.hpp`:

```hpp
//
//  KittyMemory.hpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#ifndef KittyMemory_hpp
#define KittyMemory_hpp

#include <stdio.h>
#include <string>
#include <unistd.h>
#include <sys/mman.h>
#include <mach-o/dyld.h>
#include <mach/mach.h>
#include "darwin/mach_vm.h"


#define _FIXED_ADDR_(x) ((uintptr_t)x & ~(uintptr_t)1)

#define _SYS_PAGE_SIZE_ (sysconf(_SC_PAGE_SIZE))

#define _START_PAGE_OF_(x) ((uintptr_t)x & ~(uintptr_t)(_SYS_PAGE_SIZE_ - 1))

#define _END_PAGE_OF_(x, len) (_START_PAGE_OF_((uintptr_t)x + len - 1))

#define _OFFSET_PAGE_OF_(x) ((uintptr_t)x - _START_PAGE_OF_(x));

#define _SIZE_PAGE_OF_(x, len)(_END_PAGE_OF_(x, len) - _START_PAGE_OF_(x) + _SYS_PAGE_SIZE_)


namespace MemKitty {

    typedef struct {
        int index;
        const mach_header *header;
        const char *name;
        uintptr_t address;
    } mach_info;


     bool hasASLR();
     bool x_protect(void *addr, size_t length, int protection);
     kern_return_t getPageInfo(uintptr_t addr, vm_region_submap_short_info_64 *outInfo);
     void *MemCopy(void *dst, const void *src, size_t len);
     void *writeWrapper(void *dst, const void *src, size_t len);
     void *writeMemory(void *dst, const void *src, size_t len);
     void *readMemory(void *src, void *buffer, size_t len);
     std::string read2HexStr(void *addr, size_t len);
     mach_info getBaseInfo();
     mach_info getMemoryMachInfo(const char *fileName);
};

#endif /* KittyMemory_hpp */

```

`jailbreak/KittyMemory-IOS/MemoryModifier.cpp`:

```cpp
//
//  MemoryModifier.cpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#include "MemoryModifier.hpp"


MemoryModifier::MemoryModifier(){
  _binaryName    = NULL;
  _address       = NULL;
  _size          = 0;
  _originalValue = NULL;
  _modValue      = NULL;
}

MemoryModifier::MemoryModifier(void *address, const void *modifier, size_t size){
    MemoryModifier();

    if(address && modifier && size > 0){

      _address = address;
      _size    = size;

      _originalValue = new uint8_t[size];
      _modValue      = new uint8_t[size];

    // backups
      MemKitty::readMemory(_address, _originalValue, size);
      MemKitty::readMemory((void *)modifier, _modValue, size);
    }
  }

MemoryModifier::MemoryModifier(const char *binName, void *address, const void *modifier, size_t size){
    MemoryModifier();

    if(address && modifier && size > 0){

      _binaryName = binName;

      _address = getAbsoluteAddress(address);
      _size    = size;

      _originalValue = new uint8_t[size];
      _modValue      = new uint8_t[size];

    // backups
      MemKitty::readMemory(_address, _originalValue, size);
      MemKitty::readMemory((void *)modifier, _modValue, size);
    }
  }

   MemoryModifier::~MemoryModifier(){
     // clean up
     if(_originalValue){
       delete[] _originalValue;
       _originalValue = NULL;
     }

     if(_modValue){
       delete[] _modValue;
      _modValue = NULL;
     }
   }

  bool MemoryModifier::isValid() const{
    return (_address && _size > 0 && _originalValue && _modValue);
  }

  size_t MemoryModifier::get_size() const{
    return _size;
  }

  void *MemoryModifier::get_Address() const{
    return _address;
  }

  void *MemoryModifier::getAbsoluteAddress(void *addr) const{
    if(_binaryName == NULL){
      return MemKitty::hasASLR() ? (void *)(MemKitty::getBaseInfo().address + ((uintptr_t)addr)) : addr;
    }

    return (void *)(MemKitty::getMemoryMachInfo(_binaryName).address + ((uintptr_t)addr));
  }

  bool MemoryModifier::Restore(){
    if(!isValid()) return false;
    return MemKitty::writeMemory(_address, _originalValue, _size);
  }

  bool MemoryModifier::Modify(){
    if(!isValid()) return false;
    return MemKitty::writeMemory(_address, _modValue, _size);
  }

  bool MemoryModifier::setNewModifier(const void *modifier, size_t size){
    if(!modifier || size < 1) return false;

    _size = size;

    if(_modValue){
      delete[] _modValue;
      _modValue = NULL;
    }

    _modValue = new uint8_t[size];
    return MemKitty::writeMemory(_modValue, modifier, size);
  }

  std::string MemoryModifier::ToHexString(){
    if(!isValid()) return std::string("0xInvalid");
    return MemKitty::read2HexStr(_address, _size);
  }

```

`jailbreak/KittyMemory-IOS/MemoryModifier.hpp`:

```hpp
//
//  MemoryModifier.hpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#ifndef MemoryModifier_hpp
#define MemoryModifier_hpp

#include "KittyMemory.hpp"


class MemoryModifier {
private:
  const char *_binaryName;

  void * _address;
  size_t _size;

  uint8_t *_originalValue;
  uint8_t *_modValue;

public:
  MemoryModifier();

  // expects absolute address
  MemoryModifier(void *address, const void *modifier, size_t size);

  // expects binary name and relative address, if binary name is NULL then it'll consider the base executable
  MemoryModifier(const char *binName, void *address, const void *modifier, size_t size);
  

  ~MemoryModifier();

  // validate modifier
  bool isValid() const;

  // get mod size
  size_t get_size() const;

  // returns pointer to the target address
  void *get_Address() const;

  // final address pointer
  void *getAbsoluteAddress(void *addr) const;

  // restore to original value
  bool Restore();

  // apply modifications to target address
  bool Modify();

  // reset mod value/size
  bool setNewModifier(const void *modifier, size_t size);

 // returns current target address bytes as hex string
  std::string ToHexString();
};

#endif /* MemoryModifier_hpp */

```

`jailbreak/KittyMemory-IOS/darwin/mach_vm.h`:

```h
#ifndef    _mach_vm_user_
#define    _mach_vm_user_

/* Module mach_vm */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern int mig_strncpy_zerofill(char *dest, const char *src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */

/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef    mach_vm_MSG_COUNT
#define    mach_vm_MSG_COUNT    20
#endif    /* mach_vm_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach_debug/mach_debug_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>

__BEGIN_DECLS


/* Routine mach_vm_allocate */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_allocate
        (
                vm_map_t target,
                mach_vm_address_t *address,
                mach_vm_size_t size,
                int flags
        );

/* Routine mach_vm_deallocate */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_deallocate
        (
                vm_map_t target,
                mach_vm_address_t address,
                mach_vm_size_t size
        );

/* Routine mach_vm_protect */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_protect
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                boolean_t set_maximum,
                vm_prot_t new_protection
        );

/* Routine mach_vm_inherit */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_inherit
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_inherit_t new_inheritance
        );

/* Routine mach_vm_read */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_offset_t *data,
                mach_msg_type_number_t *dataCnt
        );

/* Routine mach_vm_read_list */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read_list
        (
                vm_map_t target_task,
                mach_vm_read_entry_t data_list,
                natural_t count
        );

/* Routine mach_vm_write */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_write
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_offset_t data,
                mach_msg_type_number_t dataCnt
        );

/* Routine mach_vm_copy */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_copy
        (
                vm_map_t target_task,
                mach_vm_address_t source_address,
                mach_vm_size_t size,
                mach_vm_address_t dest_address
        );

/* Routine mach_vm_read_overwrite */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read_overwrite
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                mach_vm_address_t data,
                mach_vm_size_t *outsize
        );

/* Routine mach_vm_msync */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_msync
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_sync_t sync_flags
        );

/* Routine mach_vm_behavior_set */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_behavior_set
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_behavior_t new_behavior
        );

/* Routine mach_vm_map */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_map
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t size,
                mach_vm_offset_t mask,
                int flags,
                mem_entry_name_port_t object,
                memory_object_offset_t offset,
                boolean_t copy,
                vm_prot_t cur_protection,
                vm_prot_t max_protection,
                vm_inherit_t inheritance
        );

/* Routine mach_vm_machine_attribute */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_machine_attribute
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_machine_attribute_t attribute,
                vm_machine_attribute_val_t *value
        );

/* Routine mach_vm_remap */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_remap
        (
                vm_map_t target_task,
                mach_vm_address_t *target_address,
                mach_vm_size_t size,
                mach_vm_offset_t mask,
                int flags,
                vm_map_t src_task,
                mach_vm_address_t src_address,
                boolean_t copy,
                vm_prot_t *cur_protection,
                vm_prot_t *max_protection,
                vm_inherit_t inheritance
        );

/* Routine mach_vm_page_query */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_page_query
        (
                vm_map_t target_map,
                mach_vm_offset_t offset,
                integer_t *disposition,
                integer_t *ref_count
        );

/* Routine mach_vm_region_recurse */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_region_recurse
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t *size,
                natural_t *nesting_depth,
                vm_region_recurse_info_t info,
                mach_msg_type_number_t *infoCnt
        );

/* Routine mach_vm_region */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_region
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t *size,
                vm_region_flavor_t flavor,
                vm_region_info_t info,
                mach_msg_type_number_t *infoCnt,
                mach_port_t *object_name
        );

/* Routine _mach_make_memory_entry */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t _mach_make_memory_entry
        (
                vm_map_t target_task,
                memory_object_size_t *size,
                memory_object_offset_t offset,
                vm_prot_t permission,
                mem_entry_name_port_t *object_handle,
                mem_entry_name_port_t parent_handle
        );

/* Routine mach_vm_purgable_control */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_purgable_control
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_purgable_t control,
                int *state
        );

/* Routine mach_vm_page_info */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_page_info
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_page_info_flavor_t flavor,
                vm_page_info_t info,
                mach_msg_type_number_t *infoCnt
        );

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__mach_vm_subsystem__defined
#define __Request__mach_vm_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    int flags;
} __Request__mach_vm_allocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
} __Request__mach_vm_deallocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    boolean_t set_maximum;
    vm_prot_t new_protection;
} __Request__mach_vm_protect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_inherit_t new_inheritance;
} __Request__mach_vm_inherit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
} __Request__mach_vm_read_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_read_entry_t data_list;
    natural_t count;
} __Request__mach_vm_read_list_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_ool_descriptor_t data;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_msg_type_number_t dataCnt;
} __Request__mach_vm_write_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t source_address;
    mach_vm_size_t size;
    mach_vm_address_t dest_address;
} __Request__mach_vm_copy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_vm_address_t data;
} __Request__mach_vm_read_overwrite_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_sync_t sync_flags;
} __Request__mach_vm_msync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_behavior_t new_behavior;
} __Request__mach_vm_behavior_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_vm_offset_t mask;
    int flags;
    memory_object_offset_t offset;
    boolean_t copy;
    vm_prot_t cur_protection;
    vm_prot_t max_protection;
    vm_inherit_t inheritance;
} __Request__mach_vm_map_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_machine_attribute_t attribute;
    vm_machine_attribute_val_t value;
} __Request__mach_vm_machine_attribute_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t src_task;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t target_address;
    mach_vm_size_t size;
    mach_vm_offset_t mask;
    int flags;
    mach_vm_address_t src_address;
    boolean_t copy;
    vm_inherit_t inheritance;
} __Request__mach_vm_remap_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_offset_t offset;
} __Request__mach_vm_page_query_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    natural_t nesting_depth;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_region_recurse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_region_flavor_t flavor;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_region_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t parent_handle;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    memory_object_size_t size;
    memory_object_offset_t offset;
    vm_prot_t permission;
} __Request___mach_make_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_purgable_t control;
    int state;
} __Request__mach_vm_purgable_control_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_page_info_flavor_t flavor;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_page_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__mach_vm_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__mach_vm_subsystem__defined
#define __RequestUnion__mach_vm_subsystem__defined
union __RequestUnion__mach_vm_subsystem {
    __Request__mach_vm_allocate_t Request_mach_vm_allocate;
    __Request__mach_vm_deallocate_t Request_mach_vm_deallocate;
    __Request__mach_vm_protect_t Request_mach_vm_protect;
    __Request__mach_vm_inherit_t Request_mach_vm_inherit;
    __Request__mach_vm_read_t Request_mach_vm_read;
    __Request__mach_vm_read_list_t Request_mach_vm_read_list;
    __Request__mach_vm_write_t Request_mach_vm_write;
    __Request__mach_vm_copy_t Request_mach_vm_copy;
    __Request__mach_vm_read_overwrite_t Request_mach_vm_read_overwrite;
    __Request__mach_vm_msync_t Request_mach_vm_msync;
    __Request__mach_vm_behavior_set_t Request_mach_vm_behavior_set;
    __Request__mach_vm_map_t Request_mach_vm_map;
    __Request__mach_vm_machine_attribute_t Request_mach_vm_machine_attribute;
    __Request__mach_vm_remap_t Request_mach_vm_remap;
    __Request__mach_vm_page_query_t Request_mach_vm_page_query;
    __Request__mach_vm_region_recurse_t Request_mach_vm_region_recurse;
    __Request__mach_vm_region_t Request_mach_vm_region;
    __Request___mach_make_memory_entry_t Request__mach_make_memory_entry;
    __Request__mach_vm_purgable_control_t Request_mach_vm_purgable_control;
    __Request__mach_vm_page_info_t Request_mach_vm_page_info;
};
#endif /* !__RequestUnion__mach_vm_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__mach_vm_subsystem__defined
#define __Reply__mach_vm_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
} __Reply__mach_vm_allocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_deallocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_protect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_inherit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_ool_descriptor_t data;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_msg_type_number_t dataCnt;
} __Reply__mach_vm_read_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_read_entry_t data_list;
} __Reply__mach_vm_read_list_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_write_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_copy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_size_t outsize;
} __Reply__mach_vm_read_overwrite_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_msync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_behavior_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
} __Reply__mach_vm_map_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    vm_machine_attribute_val_t value;
} __Reply__mach_vm_machine_attribute_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t target_address;
    vm_prot_t cur_protection;
    vm_prot_t max_protection;
} __Reply__mach_vm_remap_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    integer_t disposition;
    integer_t ref_count;
} __Reply__mach_vm_page_query_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
    mach_vm_size_t size;
    natural_t nesting_depth;
    mach_msg_type_number_t infoCnt;
    int info[19];
} __Reply__mach_vm_region_recurse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object_name;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_msg_type_number_t infoCnt;
    int info[10];
} __Reply__mach_vm_region_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object_handle;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    memory_object_size_t size;
} __Reply___mach_make_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    int state;
} __Reply__mach_vm_purgable_control_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_msg_type_number_t infoCnt;
    int info[32];
} __Reply__mach_vm_page_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__mach_vm_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__mach_vm_subsystem__defined
#define __ReplyUnion__mach_vm_subsystem__defined
union __ReplyUnion__mach_vm_subsystem {
    __Reply__mach_vm_allocate_t Reply_mach_vm_allocate;
    __Reply__mach_vm_deallocate_t Reply_mach_vm_deallocate;
    __Reply__mach_vm_protect_t Reply_mach_vm_protect;
    __Reply__mach_vm_inherit_t Reply_mach_vm_inherit;
    __Reply__mach_vm_read_t Reply_mach_vm_read;
    __Reply__mach_vm_read_list_t Reply_mach_vm_read_list;
    __Reply__mach_vm_write_t Reply_mach_vm_write;
    __Reply__mach_vm_copy_t Reply_mach_vm_copy;
    __Reply__mach_vm_read_overwrite_t Reply_mach_vm_read_overwrite;
    __Reply__mach_vm_msync_t Reply_mach_vm_msync;
    __Reply__mach_vm_behavior_set_t Reply_mach_vm_behavior_set;
    __Reply__mach_vm_map_t Reply_mach_vm_map;
    __Reply__mach_vm_machine_attribute_t Reply_mach_vm_machine_attribute;
    __Reply__mach_vm_remap_t Reply_mach_vm_remap;
    __Reply__mach_vm_page_query_t Reply_mach_vm_page_query;
    __Reply__mach_vm_region_recurse_t Reply_mach_vm_region_recurse;
    __Reply__mach_vm_region_t Reply_mach_vm_region;
    __Reply___mach_make_memory_entry_t Reply__mach_make_memory_entry;
    __Reply__mach_vm_purgable_control_t Reply_mach_vm_purgable_control;
    __Reply__mach_vm_page_info_t Reply_mach_vm_page_info;
};
#endif /* !__RequestUnion__mach_vm_subsystem__defined */

#ifndef subsystem_to_name_map_mach_vm
#define subsystem_to_name_map_mach_vm \
    { "mach_vm_allocate", 4800 },\
    { "mach_vm_deallocate", 4801 },\
    { "mach_vm_protect", 4802 },\
    { "mach_vm_inherit", 4803 },\
    { "mach_vm_read", 4804 },\
    { "mach_vm_read_list", 4805 },\
    { "mach_vm_write", 4806 },\
    { "mach_vm_copy", 4807 },\
    { "mach_vm_read_overwrite", 4808 },\
    { "mach_vm_msync", 4809 },\
    { "mach_vm_behavior_set", 4810 },\
    { "mach_vm_map", 4811 },\
    { "mach_vm_machine_attribute", 4812 },\
    { "mach_vm_remap", 4813 },\
    { "mach_vm_page_query", 4814 },\
    { "mach_vm_region_recurse", 4815 },\
    { "mach_vm_region", 4816 },\
    { "_mach_make_memory_entry", 4817 },\
    { "mach_vm_purgable_control", 4818 },\
    { "mach_vm_page_info", 4819 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif /* _mach_vm_user_ */
```

`jailbreak/test/Tweak.xm`:

```xm
#import <UIKit/UIKit.h>
#import "KittyMemory-IOS/MemoryModifier.hpp"



%hook UnityAppController
-(void)applicationDidBecomeActive:(id)argument {

  NSLog(@"=========== I'M LOADED ============");

  // ==================================== 
  // Patch Code Example            

   void *someFuncReturnsBool_Address = (void *)0xFuncAddress;
   MemoryModifier FuncModifier("TargetBinayName", someFuncReturnsBool_Address,
                                                        /* MOV X0 #1
                                                           RET */"\x20\x00\x80\xD2\xC0\x03\x5F\xD6", 8);
    NSLog(@"current bytes %s", FuncModifier.ToHexString().c_str());
    if(FuncModifier.Modify()){
      NSLog(@"modified bytes %s", FuncModifier.ToHexString().c_str());
     }
    if(FuncModifier.Restore()){
       NSLog(@"restored bytes %s", FuncModifier.ToHexString().c_str());
     }
	 

   
  // ==================================== 
  // Modify Health Example       
  
   uintptr_t playerBaseAddr = MemKitty::getBaseInfo().address + 0xPlayerAddress;
   uintptr_t playerPointer;
   // read player pointer
   if(readMemory(playerBaseAddr, &playerPointer, sizeof(uintptr_t))){
       void *playerHealthPointer = (void *)(playerPointer + 0xHealthOffset);
       int hackedPlayerHealth = 1337;
       MemoryModifier playerHealthMod(playerHealthPointer, &hackedPlayerHealth, sizeof(int));
       NSLog(@"playerHealth address: %p", playerHealthMod.get_Address());
      if(playerHealthMod.Modify()){
         NSLog(@"playerHealth has been modified successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }

      int newHackedPlayerHealth = 999999;
      if(playerHealthMod.setNewModifier(&newHackedPlayerHealth, sizeof(int)) && playerHealthMod.Modify()){
         NSLog(@"playerHealth has been modified with new modifier successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }

      if(playerHealthMod.Restore()){
         NSLog(@"playerHealth has been restored successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }
   }
   
   

 // =============================================================================

 // Direct read & write, Camera Angles Example

   uintptr_t cameraBaseAddr = MemKitty::getBaseInfo().address + 0xCameraAddress;
   uintptr_t cameraPointer;
   // read camera pointer
   if(readMemory(cameraBaseAddr, &cameraPointer, sizeof(uintptr_t))){
   // read angles
      Vector2 currentCameraAngles;
   if(readMemory((void *)(cameraPointer + 0xAnglesOffset), &currentCameraAngles, sizeof(Vector2))){
       NSLog("CameraAngles(%f, %f)", currentCameraAngles.x, currentCameraAngles.y);
   }
   // write to angles
   Vector2 aimBotAngles = getAimbotAngles();
   if(writeMemory((void *)(cameraPointer + 0xAnglesOffset), &aimBotAngles, sizeof(Vector2))){
       NSLog("CameraAngles(%f, %f)", aimBotAngles.x, aimBotAngles.y);
    }
  }
%orig;

}
%end

```

`jailed/KittyMemory-IOS/KittyMemory.cpp`:

```cpp
//
//  KittyMemory.cpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#include "KittyMemory.hpp"

bool MemKitty::hasASLR() {
 // PIE applies ASLR to the binary
   return (_dyld_get_image_header(0)->flags & MH_PIE);
}


 kern_return_t MemKitty::getPageInfo(uintptr_t addr, vm_region_submap_short_info_64 *outInfo) {
   vm_address_t region  = (vm_address_t) addr;
   vm_size_t region_len = 0;
   mach_msg_type_number_t info_count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
   natural_t max_depth  = 99999;
   kern_return_t kr = vm_region_recurse_64(mach_task_self(), &region, &region_len,
                                           &max_depth,
                                           (vm_region_recurse_info_t) outInfo,
                                           &info_count);
   if(kr == KERN_SUCCESS)
      outInfo->protection &= (PROT_READ | PROT_WRITE | PROT_EXEC);

   return kr;
}


void *MemKitty::MemCopy(void* dst, const void* src, size_t size){
    uint8_t *destination = (uint8_t*) dst;
    uint8_t *source      = (uint8_t*) src;

    int step = sizeof(uint8_t);

    for(int i = 0; i < size; i++){
        *((uint8_t*)destination) = *((uint8_t*)source);
        destination += step;
        source      += step;
    }
    return dst;
}


// write in memory at given address (copies src into dst)
void *MemKitty::writeMemory(void *dst, const void *src, size_t len) {
  if (!src || !dst || len < 1)
      return NULL;

  void     *address   = (void *)_FIXED_ADDR_(dst);
  uintptr_t startPage = _START_PAGE_OF_(address);

  vm_region_submap_short_info_64 info;
  if(getPageInfo(startPage, &info) != KERN_SUCCESS)
     return NULL;

  // check write rights
   if(info.protection & PROT_WRITE)
      return MemCopy(dst, src, len);
   
  return NULL;
}

// reads from memory at given address (copies dst into the buffer)
void *MemKitty::readMemory(void *dst, void *buffer, size_t len) {
  if (!dst || len < 1)
      return NULL;

  void     *address    = (void *)_FIXED_ADDR_(dst);
  uintptr_t startPage  = _START_PAGE_OF_(address);

  vm_region_submap_short_info_64 info;
  if(getPageInfo(_START_PAGE_OF_(address), &info) != KERN_SUCCESS)
     return NULL;

  // check read rights
  if(info.protection & PROT_READ)
     return MemCopy(buffer, address, len);

  return NULL;
}


// reads bytes into hex string at the given address
std::string MemKitty::read2HexStr(void *addr, size_t len) {
  char tmp[len];
  memset(tmp, 0, len);

  size_t bufferLen = len*2 + 1;
  char buffer[bufferLen];
  memset(buffer, 0, bufferLen);

  std::string ret  = "0x";

  if(readMemory(addr, tmp, len) == NULL)
    return ret;

  for(int i = 0; i < len; i++){
    sprintf(&buffer[i*2], "%02X", (unsigned char)tmp[i]);
  }

  ret += buffer;
  return ret;
}


MemKitty::mach_info MemKitty::getBaseInfo(){
 mach_info _info = {
   0,
   _dyld_get_image_header(0),
   _dyld_get_image_name(0),
   (uintptr_t)_dyld_get_image_vmaddr_slide(0)
 };
 return _info;
}



MemKitty::mach_info MemKitty::getMemoryMachInfo(const char *fileName){
  mach_info _info = {};

  int imageCount = _dyld_image_count();

   for(int i = 0; i < imageCount; i++) {
     const char *name = _dyld_get_image_name(i);
     const mach_header *header = _dyld_get_image_header(i);
       if(!strstr(name, fileName)) continue;

       mach_info new_info = {
         i, header, name, (uintptr_t)_dyld_get_image_vmaddr_slide(i)
       };

       _info = new_info;
     }
     return _info;
   }

```

`jailed/KittyMemory-IOS/KittyMemory.hpp`:

```hpp
//
//  KittyMemory.hpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#ifndef KittyMemory_hpp
#define KittyMemory_hpp

#include <stdio.h>
#include <string>
#include <unistd.h>
#include <sys/mman.h>
#include <mach-o/dyld.h>
#include <mach/mach.h>
#include "darwin/mach_vm.h"


#define _FIXED_ADDR_(x) ((uintptr_t)x & ~(uintptr_t)1)

#define _SYS_PAGE_SIZE_ (sysconf(_SC_PAGE_SIZE))

#define _START_PAGE_OF_(x) ((uintptr_t)x & ~(uintptr_t)(_SYS_PAGE_SIZE_ - 1))

#define _END_PAGE_OF_(x, len) (_START_PAGE_OF_((uintptr_t)x + len - 1))

#define _OFFSET_PAGE_OF_(x) ((uintptr_t)x - _START_PAGE_OF_(x));

#define _SIZE_PAGE_OF_(x, len)(_END_PAGE_OF_(x, len) - _START_PAGE_OF_(x) + _SYS_PAGE_SIZE_)


namespace MemKitty {

    typedef struct {
        int index;
        const mach_header *header;
        const char *name;
        uintptr_t address;
    } mach_info;


     bool hasASLR();
     kern_return_t getPageInfo(uintptr_t addr, vm_region_submap_short_info_64 *outInfo);
     void *MemCopy(void *dst, const void *src, size_t len);
     void *writeMemory(void *dst, const void *src, size_t len);
     void *readMemory(void *src, void *buffer, size_t len);
     std::string read2HexStr(void *addr, size_t len);
     mach_info getBaseInfo();
     mach_info getMemoryMachInfo(const char *fileName);
};

#endif /* KittyMemory_hpp */

```

`jailed/KittyMemory-IOS/MemoryModifier.cpp`:

```cpp
//
//  MemoryModifier.cpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#include "MemoryModifier.hpp"


MemoryModifier::MemoryModifier(){
  _binaryName    = NULL;
  _address       = NULL;
  _size          = 0;
  _originalValue = NULL;
  _modValue      = NULL;
}

MemoryModifier::MemoryModifier(void *address, const void *modifier, size_t size){
    MemoryModifier();

    if(address && modifier && size > 0){

      _address = address;
      _size    = size;

      _originalValue = new uint8_t[size];
      _modValue      = new uint8_t[size];

    // backups
      MemKitty::readMemory(_address, _originalValue, size);
      MemKitty::readMemory((void *)modifier, _modValue, size);
    }
  }

MemoryModifier::MemoryModifier(const char *binName, void *address, const void *modifier, size_t size){
    MemoryModifier();

    if(address && modifier && size > 0){

      _binaryName = binName;

      _address = getAbsoluteAddress(address);
      _size    = size;

      _originalValue = new uint8_t[size];
      _modValue      = new uint8_t[size];

    // backups
      MemKitty::readMemory(_address, _originalValue, size);
      MemKitty::readMemory((void *)modifier, _modValue, size);
    }
  }

   MemoryModifier::~MemoryModifier(){
     // clean up
     if(_originalValue){
       delete[] _originalValue;
       _originalValue = NULL;
     }

     if(_modValue){
       delete[] _modValue;
      _modValue = NULL;
     }
   }

  bool MemoryModifier::isValid() const{
    return (_address && _size > 0 && _originalValue && _modValue);
  }

  size_t MemoryModifier::get_size() const{
    return _size;
  }

  void *MemoryModifier::get_Address() const{
    return _address;
  }

  void *MemoryModifier::getAbsoluteAddress(void *addr) const{
    if(_binaryName == NULL){
      return MemKitty::hasASLR() ? (void *)(MemKitty::getBaseInfo().address + ((uintptr_t)addr)) : addr;
    }

    return (void *)(MemKitty::getMemoryMachInfo(_binaryName).address + ((uintptr_t)addr));
  }

  bool MemoryModifier::Restore(){
    if(!isValid()) return false;
    return MemKitty::writeMemory(_address, _originalValue, _size);
  }

  bool MemoryModifier::Modify(){
    if(!isValid()) return false;
    return MemKitty::writeMemory(_address, _modValue, _size);
  }

  bool MemoryModifier::setNewModifier(const void *modifier, size_t size){
    if(!modifier || size < 1) return false;

    _size = size;

    if(_modValue){
      delete[] _modValue;
      _modValue = NULL;
    }

    _modValue = new uint8_t[size];
    return MemKitty::writeMemory(_modValue, modifier, size);
  }

  std::string MemoryModifier::ToHexString(){
    if(!isValid()) return std::string("0xInvalid");
    return MemKitty::read2HexStr(_address, _size);
  }

```

`jailed/KittyMemory-IOS/MemoryModifier.hpp`:

```hpp
//
//  MemoryModifier.hpp
//
//
//  Created by MJ (Ruit) on 1/1/19.
//
//

#ifndef MemoryModifier_hpp
#define MemoryModifier_hpp

#include "KittyMemory.hpp"


class MemoryModifier {
private:
  const char *_binaryName;

  void * _address;
  size_t _size;

  uint8_t *_originalValue;
  uint8_t *_modValue;

public:
  MemoryModifier();

  // expects absolute address
  MemoryModifier(void *address, const void *modifier, size_t size);

  // expects binary name and relative address, if binary name is NULL then it'll consider the base executable
  MemoryModifier(const char *binName, void *address, const void *modifier, size_t size);
  

  ~MemoryModifier();

  // validate modifier
  bool isValid() const;

  // get mod size
  size_t get_size() const;

  // returns pointer to the target address
  void *get_Address() const;

  // final address pointer
  void *getAbsoluteAddress(void *addr) const;

  // restore to original value
  bool Restore();

  // apply modifications to target address
  bool Modify();

  // reset mod value/size
  bool setNewModifier(const void *modifier, size_t size);

 // returns current target address bytes as hex string
  std::string ToHexString();
};

#endif /* MemoryModifier_hpp */

```

`jailed/KittyMemory-IOS/darwin/mach_vm.h`:

```h
#ifndef    _mach_vm_user_
#define    _mach_vm_user_

/* Module mach_vm */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern int mig_strncpy_zerofill(char *dest, const char *src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */

/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef    mach_vm_MSG_COUNT
#define    mach_vm_MSG_COUNT    20
#endif    /* mach_vm_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach_debug/mach_debug_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>

__BEGIN_DECLS


/* Routine mach_vm_allocate */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_allocate
        (
                vm_map_t target,
                mach_vm_address_t *address,
                mach_vm_size_t size,
                int flags
        );

/* Routine mach_vm_deallocate */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_deallocate
        (
                vm_map_t target,
                mach_vm_address_t address,
                mach_vm_size_t size
        );

/* Routine mach_vm_protect */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_protect
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                boolean_t set_maximum,
                vm_prot_t new_protection
        );

/* Routine mach_vm_inherit */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_inherit
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_inherit_t new_inheritance
        );

/* Routine mach_vm_read */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_offset_t *data,
                mach_msg_type_number_t *dataCnt
        );

/* Routine mach_vm_read_list */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read_list
        (
                vm_map_t target_task,
                mach_vm_read_entry_t data_list,
                natural_t count
        );

/* Routine mach_vm_write */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_write
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_offset_t data,
                mach_msg_type_number_t dataCnt
        );

/* Routine mach_vm_copy */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_copy
        (
                vm_map_t target_task,
                mach_vm_address_t source_address,
                mach_vm_size_t size,
                mach_vm_address_t dest_address
        );

/* Routine mach_vm_read_overwrite */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_read_overwrite
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                mach_vm_address_t data,
                mach_vm_size_t *outsize
        );

/* Routine mach_vm_msync */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_msync
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_sync_t sync_flags
        );

/* Routine mach_vm_behavior_set */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_behavior_set
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_behavior_t new_behavior
        );

/* Routine mach_vm_map */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_map
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t size,
                mach_vm_offset_t mask,
                int flags,
                mem_entry_name_port_t object,
                memory_object_offset_t offset,
                boolean_t copy,
                vm_prot_t cur_protection,
                vm_prot_t max_protection,
                vm_inherit_t inheritance
        );

/* Routine mach_vm_machine_attribute */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_machine_attribute
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                mach_vm_size_t size,
                vm_machine_attribute_t attribute,
                vm_machine_attribute_val_t *value
        );

/* Routine mach_vm_remap */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_remap
        (
                vm_map_t target_task,
                mach_vm_address_t *target_address,
                mach_vm_size_t size,
                mach_vm_offset_t mask,
                int flags,
                vm_map_t src_task,
                mach_vm_address_t src_address,
                boolean_t copy,
                vm_prot_t *cur_protection,
                vm_prot_t *max_protection,
                vm_inherit_t inheritance
        );

/* Routine mach_vm_page_query */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_page_query
        (
                vm_map_t target_map,
                mach_vm_offset_t offset,
                integer_t *disposition,
                integer_t *ref_count
        );

/* Routine mach_vm_region_recurse */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_region_recurse
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t *size,
                natural_t *nesting_depth,
                vm_region_recurse_info_t info,
                mach_msg_type_number_t *infoCnt
        );

/* Routine mach_vm_region */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_region
        (
                vm_map_t target_task,
                mach_vm_address_t *address,
                mach_vm_size_t *size,
                vm_region_flavor_t flavor,
                vm_region_info_t info,
                mach_msg_type_number_t *infoCnt,
                mach_port_t *object_name
        );

/* Routine _mach_make_memory_entry */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t _mach_make_memory_entry
        (
                vm_map_t target_task,
                memory_object_size_t *size,
                memory_object_offset_t offset,
                vm_prot_t permission,
                mem_entry_name_port_t *object_handle,
                mem_entry_name_port_t parent_handle
        );

/* Routine mach_vm_purgable_control */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_purgable_control
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_purgable_t control,
                int *state
        );

/* Routine mach_vm_page_info */
#ifdef    mig_external
mig_external
#else
extern
#endif    /* mig_external */
kern_return_t mach_vm_page_info
        (
                vm_map_t target_task,
                mach_vm_address_t address,
                vm_page_info_flavor_t flavor,
                vm_page_info_t info,
                mach_msg_type_number_t *infoCnt
        );

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__mach_vm_subsystem__defined
#define __Request__mach_vm_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    int flags;
} __Request__mach_vm_allocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
} __Request__mach_vm_deallocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    boolean_t set_maximum;
    vm_prot_t new_protection;
} __Request__mach_vm_protect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_inherit_t new_inheritance;
} __Request__mach_vm_inherit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
} __Request__mach_vm_read_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_read_entry_t data_list;
    natural_t count;
} __Request__mach_vm_read_list_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_ool_descriptor_t data;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_msg_type_number_t dataCnt;
} __Request__mach_vm_write_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t source_address;
    mach_vm_size_t size;
    mach_vm_address_t dest_address;
} __Request__mach_vm_copy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_vm_address_t data;
} __Request__mach_vm_read_overwrite_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_sync_t sync_flags;
} __Request__mach_vm_msync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_behavior_t new_behavior;
} __Request__mach_vm_behavior_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_vm_offset_t mask;
    int flags;
    memory_object_offset_t offset;
    boolean_t copy;
    vm_prot_t cur_protection;
    vm_prot_t max_protection;
    vm_inherit_t inheritance;
} __Request__mach_vm_map_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    vm_machine_attribute_t attribute;
    vm_machine_attribute_val_t value;
} __Request__mach_vm_machine_attribute_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t src_task;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t target_address;
    mach_vm_size_t size;
    mach_vm_offset_t mask;
    int flags;
    mach_vm_address_t src_address;
    boolean_t copy;
    vm_inherit_t inheritance;
} __Request__mach_vm_remap_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_offset_t offset;
} __Request__mach_vm_page_query_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    natural_t nesting_depth;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_region_recurse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_region_flavor_t flavor;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_region_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t parent_handle;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    memory_object_size_t size;
    memory_object_offset_t offset;
    vm_prot_t permission;
} __Request___mach_make_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_purgable_t control;
    int state;
} __Request__mach_vm_purgable_control_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    mach_vm_address_t address;
    vm_page_info_flavor_t flavor;
    mach_msg_type_number_t infoCnt;
} __Request__mach_vm_page_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__mach_vm_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__mach_vm_subsystem__defined
#define __RequestUnion__mach_vm_subsystem__defined
union __RequestUnion__mach_vm_subsystem {
    __Request__mach_vm_allocate_t Request_mach_vm_allocate;
    __Request__mach_vm_deallocate_t Request_mach_vm_deallocate;
    __Request__mach_vm_protect_t Request_mach_vm_protect;
    __Request__mach_vm_inherit_t Request_mach_vm_inherit;
    __Request__mach_vm_read_t Request_mach_vm_read;
    __Request__mach_vm_read_list_t Request_mach_vm_read_list;
    __Request__mach_vm_write_t Request_mach_vm_write;
    __Request__mach_vm_copy_t Request_mach_vm_copy;
    __Request__mach_vm_read_overwrite_t Request_mach_vm_read_overwrite;
    __Request__mach_vm_msync_t Request_mach_vm_msync;
    __Request__mach_vm_behavior_set_t Request_mach_vm_behavior_set;
    __Request__mach_vm_map_t Request_mach_vm_map;
    __Request__mach_vm_machine_attribute_t Request_mach_vm_machine_attribute;
    __Request__mach_vm_remap_t Request_mach_vm_remap;
    __Request__mach_vm_page_query_t Request_mach_vm_page_query;
    __Request__mach_vm_region_recurse_t Request_mach_vm_region_recurse;
    __Request__mach_vm_region_t Request_mach_vm_region;
    __Request___mach_make_memory_entry_t Request__mach_make_memory_entry;
    __Request__mach_vm_purgable_control_t Request_mach_vm_purgable_control;
    __Request__mach_vm_page_info_t Request_mach_vm_page_info;
};
#endif /* !__RequestUnion__mach_vm_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__mach_vm_subsystem__defined
#define __Reply__mach_vm_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
} __Reply__mach_vm_allocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_deallocate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_protect_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_inherit_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_ool_descriptor_t data;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_msg_type_number_t dataCnt;
} __Reply__mach_vm_read_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_read_entry_t data_list;
} __Reply__mach_vm_read_list_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_write_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_copy_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_size_t outsize;
} __Reply__mach_vm_read_overwrite_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_msync_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
} __Reply__mach_vm_behavior_set_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
} __Reply__mach_vm_map_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    vm_machine_attribute_val_t value;
} __Reply__mach_vm_machine_attribute_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t target_address;
    vm_prot_t cur_protection;
    vm_prot_t max_protection;
} __Reply__mach_vm_remap_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    integer_t disposition;
    integer_t ref_count;
} __Reply__mach_vm_page_query_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_vm_address_t address;
    mach_vm_size_t size;
    natural_t nesting_depth;
    mach_msg_type_number_t infoCnt;
    int info[19];
} __Reply__mach_vm_region_recurse_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object_name;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    mach_vm_address_t address;
    mach_vm_size_t size;
    mach_msg_type_number_t infoCnt;
    int info[10];
} __Reply__mach_vm_region_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t object_handle;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    memory_object_size_t size;
} __Reply___mach_make_memory_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    int state;
} __Reply__mach_vm_purgable_control_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    kern_return_t RetCode;
    mach_msg_type_number_t infoCnt;
    int info[32];
} __Reply__mach_vm_page_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__mach_vm_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__mach_vm_subsystem__defined
#define __ReplyUnion__mach_vm_subsystem__defined
union __ReplyUnion__mach_vm_subsystem {
    __Reply__mach_vm_allocate_t Reply_mach_vm_allocate;
    __Reply__mach_vm_deallocate_t Reply_mach_vm_deallocate;
    __Reply__mach_vm_protect_t Reply_mach_vm_protect;
    __Reply__mach_vm_inherit_t Reply_mach_vm_inherit;
    __Reply__mach_vm_read_t Reply_mach_vm_read;
    __Reply__mach_vm_read_list_t Reply_mach_vm_read_list;
    __Reply__mach_vm_write_t Reply_mach_vm_write;
    __Reply__mach_vm_copy_t Reply_mach_vm_copy;
    __Reply__mach_vm_read_overwrite_t Reply_mach_vm_read_overwrite;
    __Reply__mach_vm_msync_t Reply_mach_vm_msync;
    __Reply__mach_vm_behavior_set_t Reply_mach_vm_behavior_set;
    __Reply__mach_vm_map_t Reply_mach_vm_map;
    __Reply__mach_vm_machine_attribute_t Reply_mach_vm_machine_attribute;
    __Reply__mach_vm_remap_t Reply_mach_vm_remap;
    __Reply__mach_vm_page_query_t Reply_mach_vm_page_query;
    __Reply__mach_vm_region_recurse_t Reply_mach_vm_region_recurse;
    __Reply__mach_vm_region_t Reply_mach_vm_region;
    __Reply___mach_make_memory_entry_t Reply__mach_make_memory_entry;
    __Reply__mach_vm_purgable_control_t Reply_mach_vm_purgable_control;
    __Reply__mach_vm_page_info_t Reply_mach_vm_page_info;
};
#endif /* !__RequestUnion__mach_vm_subsystem__defined */

#ifndef subsystem_to_name_map_mach_vm
#define subsystem_to_name_map_mach_vm \
    { "mach_vm_allocate", 4800 },\
    { "mach_vm_deallocate", 4801 },\
    { "mach_vm_protect", 4802 },\
    { "mach_vm_inherit", 4803 },\
    { "mach_vm_read", 4804 },\
    { "mach_vm_read_list", 4805 },\
    { "mach_vm_write", 4806 },\
    { "mach_vm_copy", 4807 },\
    { "mach_vm_read_overwrite", 4808 },\
    { "mach_vm_msync", 4809 },\
    { "mach_vm_behavior_set", 4810 },\
    { "mach_vm_map", 4811 },\
    { "mach_vm_machine_attribute", 4812 },\
    { "mach_vm_remap", 4813 },\
    { "mach_vm_page_query", 4814 },\
    { "mach_vm_region_recurse", 4815 },\
    { "mach_vm_region", 4816 },\
    { "_mach_make_memory_entry", 4817 },\
    { "mach_vm_purgable_control", 4818 },\
    { "mach_vm_page_info", 4819 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif /* _mach_vm_user_ */
```

`jailed/test/Tweak.xm`:

```xm
#import <UIKit/UIKit.h>
#import "KittyMemory-IOS/MemoryModifier.hpp"



%hook UnityAppController
-(void)applicationDidBecomeActive:(id)argument {

  NSLog(@"=========== I'M LOADED ============");
  

  // ==================================== 
  // Modify Health Example       
  
   uintptr_t playerBaseAddr = MemKitty::getBaseInfo().address + 0xPlayerAddress;
   uintptr_t playerPointer;
   // read player pointer
   if(readMemory(playerBaseAddr, &playerPointer, sizeof(uintptr_t))){
       void *playerHealthPointer = (void *)(playerPointer + 0xHealthOffset);
       int hackedPlayerHealth = 1337;
       MemoryModifier playerHealthMod(playerHealthPointer, &hackedPlayerHealth, sizeof(int));
       NSLog(@"playerHealth address: %p", playerHealthMod.get_Address());
      if(playerHealthMod.Modify()){
         NSLog(@"playerHealth has been modified successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }

      int newHackedPlayerHealth = 999999;
      if(playerHealthMod.setNewModifier(&newHackedPlayerHealth, sizeof(int)) && playerHealthMod.Modify()){
         NSLog(@"playerHealth has been modified with new modifier successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }

      if(playerHealthMod.Restore()){
         NSLog(@"playerHealth has been restored successfully");
         NSLog(@"current playerHealth: %d", playerHealth);
      }
   }
   
   

 // =============================================================================

 // Direct read & write, Camera Angles Example

   uintptr_t cameraBaseAddr = MemKitty::getBaseInfo().address + 0xCameraAddress;
   uintptr_t cameraPointer;
   // read camera pointer
   if(readMemory(cameraBaseAddr, &cameraPointer, sizeof(uintptr_t))){
   // read angles
      Vector2 currentCameraAngles;
   if(readMemory((void *)(cameraPointer + 0xAnglesOffset), &currentCameraAngles, sizeof(Vector2))){
       NSLog("CameraAngles(%f, %f)", currentCameraAngles.x, currentCameraAngles.y);
   }
   // write to angles
   Vector2 aimBotAngles = getAimbotAngles();
   if(writeMemory((void *)(cameraPointer + 0xAnglesOffset), &aimBotAngles, sizeof(Vector2))){
       NSLog("CameraAngles(%f, %f)", aimBotAngles.x, aimBotAngles.y);
    }
  }
%orig;

}
%end

```