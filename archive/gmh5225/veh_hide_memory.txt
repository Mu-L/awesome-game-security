Project Path: arc_gmh5225_veh_hide_memory_0rjf38b3

Source Tree:

```txt
arc_gmh5225_veh_hide_memory_0rjf38b3
├── HideMemory.cpp
├── HideMemory.h
├── README.md
├── Virtualization.cpp
├── Virtualization.sln
├── Virtualization.vcxproj
├── Virtualization.vcxproj.filters
├── Virtualization.vcxproj.user
├── fun.h
├── globals.cpp
├── globals.h
├── loadLibary.cpp
└── loadLibary.h

```

`HideMemory.cpp`:

```cpp
#include "globals.h"
#include "HideMemory.h"
#include "loadLibary.h"

std::vector<PROTECTEDMEMORY>PagesOfNoAccessOfData;

//只想读写的话可以打开这个锁
std::mutex m;

PSHARE_VEH pInfo = NULL;


//DeFault Encrypt/Decrypt
void EncryptData(DWORD64 lpAddress, size_t size)
{
	for (int i = 0; i < size; i++)
	{
		((char*)lpAddress)[i] = ((char*)lpAddress)[i] ^ 'b';
	}
}

LONG NTAPI VehExceptionHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	DWORD OldProtect = 0;
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
	{
		for (auto it = PagesOfNoAccessOfData.begin(); it != PagesOfNoAccessOfData.end(); it++)
		{
			if (ExceptionInfo->ExceptionRecord->ExceptionInformation[1] <= (*it).lpAddress + (*it).dwSize &&
				ExceptionInfo->ExceptionRecord->ExceptionInformation[1] >= (*it).lpAddress)
			{
				m.lock();
				//Restore Page Protection and Decrypt
				(*it).Protected = FALSE;//Not Protected
				VirtualProtect((LPVOID)(*it).lpAddress, (*it).dwSize, PAGE_EXECUTE_READWRITE, &OldProtect);

				if ((*it).Decrypt)
					(*it).Decrypt((*it).lpAddress, (*it).dwSize);
				else
					EncryptData((*it).lpAddress, (*it).dwSize);//Decrypt

				ExceptionInfo->ContextRecord->EFlags |= 0x100;//Do a single step
				return EXCEPTION_CONTINUE_EXECUTION;	

			}
		}

	}

	if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)
	{
		for (auto it = PagesOfNoAccessOfData.begin(); it != PagesOfNoAccessOfData.end(); it++)
		{
			if ((*it).Protected == FALSE)
			{
				if ((*it).Encrypt)
					(*it).Encrypt((*it).lpAddress, (*it).dwSize);
				else
					EncryptData((*it).lpAddress, (*it).dwSize);//加密

				VirtualProtect((LPVOID)(*it).lpAddress, (*it).dwSize, PAGE_NOACCESS, &OldProtect);
				m.unlock();
				return EXCEPTION_CONTINUE_EXECUTION;
			}
		}
	}

	return EXCEPTION_CONTINUE_SEARCH;

}

BOOL Init()
{
	return AddVectoredExceptionHandler(TRUE, VehExceptionHandler) == NULL ? FALSE : TRUE;
}

DWORD64 AllocateHiddenMemory(LPVOID lpAddress, SIZE_T dwSize,ENCRYPTDATAPROC Encrypt, DECRYPTDATAPROC Decrypt)
{
	pInfo = my_loadLibrary(DLL_NAME);
	printf("DllBase: %llx\n", pInfo->DllBase);
	printf("Dll_OEP: %llx\n", pInfo->DllOfEntryPoint);
	printf("export_fun: %llx\n", pInfo->export_fun);

	dwSize = pInfo->DllImageSize;

	PVOID allocated = (PVOID)pInfo->DllBase; //VirtualAlloc(lpAddress, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (allocated != NULL)
	{


		DWORD OldProtect = 0;
		dwSize = ((dwSize-1) & 0xfffffffffffff000) + 0x1000;//size是0 就走不到这里

		PROTECTEDMEMORY protected_mem = { 0 };
		protected_mem.lpAddress = (DWORD64)allocated;
		protected_mem.dwSize = dwSize;
		protected_mem.ExecutingProtection = FALSE;
		protected_mem.Protected = TRUE;
		protected_mem.Encrypt = Encrypt;
		protected_mem.Decrypt = Decrypt;


		if(!Encrypt)
			EncryptData((DWORD64)allocated, dwSize);
		else
			Encrypt((DWORD64)allocated, dwSize);

		PagesOfNoAccessOfData.push_back(protected_mem);

		BOOL bRet  = VirtualProtect(allocated, dwSize, PAGE_NOACCESS, &OldProtect);
	}
	
	return (DWORD64)allocated;
}

BOOL FreeHiddenMemory(DWORD64 lpAddress)
{
	for (auto it = PagesOfNoAccessOfData.begin(); it != PagesOfNoAccessOfData.end(); it++)
	{
		if ((*it).lpAddress == lpAddress)
		{
			PagesOfNoAccessOfData.erase(it);
			return VirtualFree((LPVOID)lpAddress, 0, MEM_RELEASE);
		}
	}
	return FALSE;
}

```

`HideMemory.h`:

```h
#pragma once

typedef void(*ENCRYPTDATAPROC)(
	_Out_writes_bytes_all_(_Size) DWORD64 lpAddress,//内存区域起始地址
	_In_ size_t _Size//内存区域大小
	);

typedef void(*DECRYPTDATAPROC)(
	_Out_writes_bytes_all_(_Size) DWORD64 lpAddress,//内存区域起始地址
	_In_ size_t _Size//内存区域大小
	);

typedef struct _PROTECTEDMEMORY
{
	DWORD64 lpAddress;
	SIZE_T dwSize;//0x1000为单位
	BOOL Protected;//True则表示被保护
	BOOL ExecutingProtection;//TRUE表示这段代码要被运行
	ENCRYPTDATAPROC Encrypt;
	DECRYPTDATAPROC Decrypt;

}PROTECTEDMEMORY, * PPROTECTEDMEMORY;

extern std::vector<PROTECTEDMEMORY>PagesOfNoAccessOfData;

/// <summary>
/// 初始化，函数会占用VEH
/// </summary>
/// <returns></returns>
BOOL Init();

/// <summary>
/// 分配一块受保护的供读写内存
/// </summary>
/// <param name="lpAddress">分配的地址，为NULL则自动分配</param>
/// <param name="dwSize">分配的大小，向上取整到0x1000</param>
/// <param name="Encrypt">加密回调，为NULL则用默认加密</param>
/// <param name="Decrypt">解密回调，为NULL则用默认解密</param>
/// <returns>分配的地址</returns>
DWORD64 AllocateHiddenMemory(LPVOID lpAddress, SIZE_T dwSize, ENCRYPTDATAPROC Encrypt, DECRYPTDATAPROC Decrypt);

/// <summary>
/// 释放一块受保护的内存
/// </summary>
/// <param name="lpAddress">内存起始地址</param>
/// <returns></returns>
BOOL FreeHiddenMemory(DWORD64 lpAddress);


```

`README.md`:

```md
# MemoryVirtualization

利用VEH和PAGE_NOACCESS，在应用层隐藏一块内存  
x64 编译通过

```

`Virtualization.cpp`:

```cpp
#include "globals.h"
#include "HideMemory.h"
#include "fun.h"
DWORD64 hidemem;

//如果只想读写的话可以删除这个锁,并打开在VEH处理函数内的锁, 要执行的话可能会在执行时触发双重异常,所以在这里加锁
//std::mutex m;

typedef NTSTATUS (NTAPI* _NtClose)(IN HANDLE ObjectHandle);
typedef NTSTATUS (NTAPI* _NtReadVirtualMemory)(HANDLE ProcessHandle,PVOID BaseAddress,PVOID Buffer,ULONG NumberOfBytesToRead,PULONG NumberOfBytesReaded);

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)   


extern PSHARE_VEH pInfo;



typedef VOID(WINAPI *_testDemo)();
_testDemo pTestDemo = NULL;


BOOL IsMemoryHidden()
{
	MEMORY_BASIC_INFORMATION MemInfo = { 0 };
	VirtualQuery((LPVOID)hidemem, &MemInfo, sizeof(MemInfo));
	if (MemInfo.Protect != PAGE_NOACCESS)
	{		
		return FALSE;
	}
	return TRUE;
}

BOOL bOnce = FALSE;
void ReadThreadProc2()
{
	while (1)
	{

		if (!bOnce)
		{
			pTestDemo = (_testDemo)pInfo->export_fun;

			//因为是自己拉伸 必须要执行 pDllMain()
			ProcDllMain  pDllMain = ((ProcDllMain)(pInfo->DllOfEntryPoint));
			pDllMain(0, DLL_PROCESS_ATTACH, (PVOID)pInfo->DllBase);
			bOnce = TRUE;
		}
	
		/*	__try {
				pTestDemo();
			}
			__except (1)
			{

			}*/
		pTestDemo();
		printf("testDemo already run  %llx \n", pTestDemo);

		Sleep(1000);		
	}
}

void ReadThreadProc3()
{
	while (1)
	{
		ULONGLONG tick = GetTickCount64();
		//m.lock();
		printf("Thread3 ReadTime %llu ms Data:%llx\n", GetTickCount64() - tick, *(DWORD64*)hidemem);
		//m.unlock();
		Sleep(100);
	}
}


int main()
{
	WCHAR title[64];
	_snwprintf_s(title, sizeof(title), L"PID: %lx", GetCurrentProcessId());
	SetConsoleTitleW(title);
	
	Init();
	hidemem = AllocateHiddenMemory(NULL, 1, 
		[](DWORD64 lpAddress, size_t _Size) {
			for (int i = 0; i < _Size; i++)
			{
				((char*)lpAddress)[i] += (char)6;
				((char*)lpAddress)[i] = ((char*)lpAddress)[i] ^ 'a';
			}
		},
		[](DWORD64 lpAddress, size_t _Size) {
			for (int i = 0; i < _Size; i++)
			{
				((char*)lpAddress)[i] = ((char*)lpAddress)[i] ^ 'a';
				((char*)lpAddress)[i] -= (char)6;
			} 
		});	

	
	

	std::thread ReadThread1(ReadThreadProc2);
	//std::thread ReadThread2(ReadThreadProc3);

	//BOOL MessageBoxState = TRUE;

	getchar();

	//while (1)
	//{
	//	printf("Allocated %llx\n\n", hidemem);

	//	ULONGLONG tick = GetTickCount64();

	//	//R/W ==========================================================================================
	//	//m.lock();
	//	*(DWORD64*)hidemem += 1;
	//	printf("ReadWriteTime %llu ms Data:%llx\n", GetTickCount64() - tick, *(DWORD64*)hidemem);
	//	//m.unlock();
	//	//R/W ==========================================================================================

	//	//Execute =======================================================================================
	//	//tick = GetTickCount64(); 请查看当前文件头部的锁
	//	//m.lock();
	//	//if (ExecuteHiddenMemory())
	//	//	printf("ExecuteTime   %llu ms \n", GetTickCount64() - tick);
	//	//else
	//	//	printf("Execute Failed\n");
	//	//m.unlock();
	//	//Execute =======================================================================================


	//	//SEH ===========================================================================================
	//	tick = GetTickCount64();
	//	//m.lock();
	//	if(CheckSEH())
	//		printf("Support SEH   %llu ms\n", GetTickCount64() - tick);
	//	//m.unlock();
	//	//SEH ===========================================================================================

	//	Sleep(200);
	//	system("cls");
	//}

END:
	//m.lock();
	FreeHiddenMemory(hidemem);
	//m.unlock();
}


```

`Virtualization.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31702.278
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Virtualization", "Virtualization.vcxproj", "{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Debug|x64.ActiveCfg = Debug|x64
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Debug|x64.Build.0 = Debug|x64
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Debug|x86.ActiveCfg = Debug|Win32
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Debug|x86.Build.0 = Debug|Win32
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Release|x64.ActiveCfg = Release|x64
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Release|x64.Build.0 = Release|x64
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Release|x86.ActiveCfg = Release|Win32
		{A185A0BF-3D9C-4025-8FD1-B120F77A5F36}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D1B1D528-F2EC-4748-A787-9EB6B1DAB927}
	EndGlobalSection
EndGlobal

```

`Virtualization.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a185a0bf-3d9c-4025-8fd1-b120f77a5f36}</ProjectGuid>
    <RootNamespace>Virtualization</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Shlwapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>..\dependencies\zydis-3.2.1\dependencies\zycore\include;..\dependencies\zydis-3.2.1\include;..\dependencies\zydis-3.2.1\msvc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Zycore.lib;Zydis.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\dependencies\zydis-3.2.1\msvc\bin\ReleaseX64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="globals.cpp" />
    <ClCompile Include="HideMemory.cpp" />
    <ClCompile Include="loadLibary.cpp" />
    <ClCompile Include="Virtualization.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="fun.h" />
    <ClInclude Include="globals.h" />
    <ClInclude Include="HideMemory.h" />
    <ClInclude Include="loadLibary.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Virtualization.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Virtualization.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="globals.cpp">
      <Filter>资源文件</Filter>
    </ClCompile>
    <ClCompile Include="HideMemory.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="loadLibary.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="globals.h">
      <Filter>资源文件</Filter>
    </ClInclude>
    <ClInclude Include="HideMemory.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="loadLibary.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="fun.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Virtualization.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`fun.h`:

```h
#pragma once
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <psapi.h>


#define MAP_VEH L"hzw_veh"
#define TYPE 0




#define DLL_NAME L"C:\\demo64.dll"






typedef struct _SHARE_VEH_
{
	ULONG DllImageSize;
	ULONG64 DllBase;
	ULONG64 export_fun;
	ULONG64 DllOfEntryPoint;
}SHARE_VEH, *PSHARE_VEH;


void OutputDebugPrintf(const char * strOutputString, ...);
typedef BOOL(APIENTRY *ProcDllMain)(LPVOID, DWORD, LPVOID);




```

`globals.cpp`:

```cpp
#include "globals.h"

static void _split(const std::string& s, char delim,
    std::vector<std::string>& elems) {
    std::stringstream ss(s);
    std::string item;

    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
}

std::vector<std::string> split(const std::string& s, char delim) {
    std::vector<std::string> elems;
    _split(s, delim, elems);
    return elems;
}


std::string extract(std::string& values, int index, char delim = ' ') {
    if (values.length() == 0)
        return std::string("");

    std::vector<std::string> x = split(values, delim);
    try {
        return x.at(index);
    }
    catch (const std::out_of_range& e) {
        return std::string("");  // 要是访问超出范围的元素，我们就返回空串
    }
}

#pragma warning(disable:4996)

std::wstring to_wide_string(const std::string& input)
{
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    return converter.from_bytes(input);
}
// convert wstring to string 
std::string to_byte_string(const std::wstring& input)
{
    //std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    return converter.to_bytes(input);
}

/*
std::string.find：从前往后查找子串或字符出现的位置。
std::string.rfind：从后往前查找子串或字符出现的位置。
*/
```

`globals.h`:

```h
#pragma once
#include <iostream>
#include <thread>
#include <Windows.h>
#include <TlHelp32.h>
#include <cmath>
#include <vector>
#include <thread>

#include <tchar.h>
#include <sstream>
#include <algorithm>
#include <unordered_map>  
#include <map>
#include <fstream>
#include <codecvt>
#include <mutex>

std::vector<std::string> split(const std::string& s, char delim);
std::string extract(std::string& values, int index, char delim );

std::wstring to_wide_string(const std::string& input);
std::string to_byte_string(const std::wstring& input);

```

`loadLibary.cpp`:

```cpp
#include "loadLibary.h"
#include <Shlwapi.h>
//Shlwapi.lib

#define  DWORDX ULONG_PTR
static pfnRtlImageNtHeader RtlImageNtHeader_ = NULL;
static pfnImageDirectoryEntryToData RtlImageDirectoryEntryToData = NULL;
static pfnRtlFindExportedRoutineByName RtlFindExportedRoutineByName = NULL;
static pfnLdrProcessRelocationBlock LdrProcessRelocationBlock = NULL;
static RtlFreeUnicodeStringT RtlFreeUnicodeString_ = NULL;
static LdrLoadDllT LdrLoadDll_ = NULL;
static RtlAnsiStringToUnicodeStringT RtlAnsiStringToUnicodeString_ = NULL;
static RtlInitAnsiStringT RtlInitAnsiString_ = NULL;
static LdrGetProcedureAddressT LdrGetProcedureAddress_ = NULL;

BOOL initApi()
{
	HMODULE h = GetModuleHandle(L"ntdll.dll");
	RtlImageNtHeader_ = (pfnRtlImageNtHeader)GetProcAddress(h, "RtlImageNtHeader");
	RtlInitAnsiString_ = (RtlInitAnsiStringT)GetProcAddress(h, "RtlInitAnsiString");
	RtlAnsiStringToUnicodeString_ = (RtlAnsiStringToUnicodeStringT)GetProcAddress(h, "RtlAnsiStringToUnicodeString");
	LdrLoadDll_ = (LdrLoadDllT)GetProcAddress(h, "LdrLoadDll");
	RtlFreeUnicodeString_ = (RtlFreeUnicodeStringT)GetProcAddress(h, "RtlFreeUnicodeString");
	RtlImageDirectoryEntryToData = (pfnImageDirectoryEntryToData)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "RtlImageDirectoryEntryToData");
	LdrGetProcedureAddress_ = (LdrGetProcedureAddressT)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "LdrGetProcedureAddress");
	if (!RtlImageNtHeader_ || !RtlInitAnsiString_ || !RtlAnsiStringToUnicodeString_ || !LdrLoadDll_ || !RtlFreeUnicodeString_ ||
		!RtlImageDirectoryEntryToData || !LdrGetProcedureAddress_) {
		return FALSE;
	}


	return TRUE;
}


PVOID MapFileByPath(LPCWSTR szFullPath, DWORD& pImageSize)
{
	if (!PathFileExistsW(szFullPath))
	{
		return NULL;
	}

	HANDLE hFile = CreateFile(
		szFullPath,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return NULL;
	}

	DWORD dwSize = GetFileSize(hFile, NULL);
	if (dwSize == 0)
	{
		CloseHandle(hFile);
		return NULL;
	}



	PVOID pBuffer = malloc(dwSize);
	if (!pBuffer)
	{
		CloseHandle(hFile);
		return NULL;
	}

	RtlZeroMemory(pBuffer, dwSize);
	DWORD dwRet = 0;
	if (!ReadFile(hFile, pBuffer, dwSize, &dwRet, NULL))
	{
		CloseHandle(hFile);
		free(pBuffer);
		return NULL;
	}

	CloseHandle(hFile);


	PVOID ImageBase = NULL;

	if (!ImageFile((PBYTE)pBuffer, &ImageBase, pImageSize) || ImageBase == NULL)
	{
		free(pBuffer);
		return NULL;
	}

	//DebugLog(L"New ImageBase: 0x%08X", ImageBase);
	free(pBuffer);

	return ImageBase;
}


BOOL ImageFile(PVOID FileBuffer, PVOID* ImageModuleBase, DWORD& ImageSize)
{

	PIMAGE_DOS_HEADER ImageDosHeader = NULL;
	PIMAGE_NT_HEADERS ImageNtHeaders = NULL;
	PIMAGE_SECTION_HEADER ImageSectionHeader = NULL;
	DWORD FileAlignment = 0, SectionAlignment = 0, NumberOfSections = 0, SizeOfImage = 0, SizeOfHeaders = 0;
	DWORD Index = 0;
	PVOID ImageBase = NULL;
	DWORD SizeOfNtHeaders = 0;

	if (!FileBuffer || !ImageModuleBase)
	{
		return FALSE;
	}

	__try
	{
		ImageDosHeader = (PIMAGE_DOS_HEADER)FileBuffer;
		if (ImageDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		{
			return FALSE;
		}

		ImageNtHeaders = RtlImageNtHeader_(FileBuffer);


		if (ImageNtHeaders->Signature != IMAGE_NT_SIGNATURE)
		{
			return FALSE;
		}

		FileAlignment = ImageNtHeaders->OptionalHeader.FileAlignment;
		SectionAlignment = ImageNtHeaders->OptionalHeader.SectionAlignment;
		NumberOfSections = ImageNtHeaders->FileHeader.NumberOfSections;
		SizeOfImage = ImageNtHeaders->OptionalHeader.SizeOfImage;
		SizeOfHeaders = ImageNtHeaders->OptionalHeader.SizeOfHeaders;
		SizeOfImage = AlignSize(SizeOfImage, SectionAlignment);

		ImageSize = SizeOfImage;

		ImageBase = malloc(SizeOfImage);
		if (ImageBase == NULL)
		{
			return FALSE;
		}
		RtlZeroMemory(ImageBase, SizeOfImage);

		SizeOfNtHeaders = sizeof(ImageNtHeaders->FileHeader) + sizeof(ImageNtHeaders->Signature) + ImageNtHeaders->FileHeader.SizeOfOptionalHeader;
		ImageSectionHeader = IMAGE_FIRST_SECTION(ImageNtHeaders);

		for (Index = 0; Index < NumberOfSections; Index++)
		{
			ImageSectionHeader[Index].SizeOfRawData = AlignSize(ImageSectionHeader[Index].SizeOfRawData, FileAlignment);
			ImageSectionHeader[Index].Misc.VirtualSize = AlignSize(ImageSectionHeader[Index].Misc.VirtualSize, SectionAlignment);
		}

		if (ImageSectionHeader[NumberOfSections - 1].VirtualAddress + ImageSectionHeader[NumberOfSections - 1].SizeOfRawData > SizeOfImage)
		{
			ImageSectionHeader[NumberOfSections - 1].SizeOfRawData = SizeOfImage - ImageSectionHeader[NumberOfSections - 1].VirtualAddress;
		}

		RtlCopyMemory(ImageBase, FileBuffer, SizeOfHeaders);

		for (Index = 0; Index < NumberOfSections; Index++)
		{
			DWORD FileOffset = ImageSectionHeader[Index].PointerToRawData;
			DWORD Length = ImageSectionHeader[Index].SizeOfRawData;
			ULONG64 ImageOffset = ImageSectionHeader[Index].VirtualAddress;
			RtlCopyMemory(&((PBYTE)ImageBase)[ImageOffset], &((PBYTE)FileBuffer)[FileOffset], Length);
		}

		*ImageModuleBase = ImageBase;


	}
	__except (1)
	{
		if (ImageBase)
		{
			free(ImageBase);
			ImageBase = NULL;
		}

		*ImageModuleBase = NULL;
		return FALSE;
	}

	return TRUE;
}

UINT AlignSize(UINT nSize, UINT nAlign)
{
	return ((nSize + nAlign - 1) / nAlign * nAlign);
}


BOOL FixImportTable(PVOID pBuffer, ULONG_PTR dwLoadMemoryAddress)
{
	PIMAGE_NT_HEADERS pNtHeaders = NULL;
	ANSI_STRING ansiStr;
	UNICODE_STRING UnicodeString;


	pNtHeaders = RtlImageNtHeader_(pBuffer);
	if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	ULONG_PTR Offset = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)pBuffer + Offset);
	PIMAGE_IMPORT_BY_NAME pByName = NULL;

	while (pID->Characteristics != 0)
	{
		PIMAGE_THUNK_DATA pRealIAT = (PIMAGE_THUNK_DATA)((ULONG_PTR)pBuffer + pID->FirstThunk);
		PIMAGE_THUNK_DATA pOriginalIAT = (PIMAGE_THUNK_DATA)((ULONG_PTR)pBuffer + pID->OriginalFirstThunk);
		//获取dll的名字
		char* pName = (char*)((ULONG_PTR)pBuffer + pID->Name);
		HANDLE hDll = 0;


		RtlInitAnsiString_(&ansiStr, pName);


		RtlAnsiStringToUnicodeString_(&UnicodeString, &ansiStr, true);


		LdrLoadDll_(NULL, NULL, &UnicodeString, &hDll);
	

		RtlFreeUnicodeString_(&UnicodeString);

		if (hDll == NULL) {

			return FALSE;
		}

		//获取DLL中每个导出函数的地址，填入IAT
		//每个IAT结构是 ：
		// union { PBYTE ForwarderString;
		// PDWORDX Function;
		// DWORDX Ordinal;
		// PIMAGE_IMPORT_BY_NAME AddressOfData;
		// } u1;
		// 长度是一个DWORDX ，正好容纳一个地址。
		for (ULONG i = 0; ; i++)
		{
			if (pOriginalIAT[i].u1.Function == 0)break;
			FARPROC lpFunction = NULL;
			if (IMAGE_SNAP_BY_ORDINAL(pOriginalIAT[i].u1.Ordinal)) //这里的值给出的是导出序号
			{
				if (IMAGE_ORDINAL(pOriginalIAT[i].u1.Ordinal))
				{
	
					LdrGetProcedureAddress_(hDll, NULL, IMAGE_ORDINAL(pOriginalIAT[i].u1.Ordinal), &lpFunction);
				}
			}
			else//按照名字导入
			{
				//获取此IAT项所描述的函数名称
				pByName = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)pBuffer + (ULONG_PTR)(pOriginalIAT[i].u1.AddressOfData));
				if ((char *)pByName->Name)
				{
					RtlInitAnsiString_(&ansiStr, (char *)pByName->Name);

					LdrGetProcedureAddress_(hDll, &ansiStr, 0, &lpFunction);

				}

			}

			//标记***********

			if (lpFunction != NULL) //找到了！
				pRealIAT[i].u1.Function = (ULONG_PTR)lpFunction;
			else {
				return FALSE;
			}
		}

		//move to next
		pID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)pID + sizeof(IMAGE_IMPORT_DESCRIPTOR));
	}

	return FixBaseRelocTable(pBuffer, dwLoadMemoryAddress);

}







BOOL FixBaseRelocTable(PVOID pBuffer, ULONG_PTR dwLoadMemoryAddress)
{

	PIMAGE_NT_HEADERS pNTHeader = NULL;

	pNTHeader = RtlImageNtHeader_(pBuffer);
	if (pNTHeader->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	__try {

		if (pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > 0
			&& pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > 0)
		{

			DWORDX Delta = (DWORDX)dwLoadMemoryAddress - pNTHeader->OptionalHeader.ImageBase;
			DWORDX * pAddress;
			//注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址
			PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)((DWORDX)pBuffer
				+ pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			while ((pLoc->VirtualAddress + pLoc->SizeOfBlock) != 0) //开始扫描重定位表
			{
				WORD *pLocData = (WORD *)((DWORDX)pLoc + sizeof(IMAGE_BASE_RELOCATION));
				//计算本节需要修正的重定位项（地址）的数目
				int NumberOfReloc = (pLoc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				for (int i = 0; i < NumberOfReloc; i++)
				{
					if ((DWORDX)(pLocData[i] & 0xF000) == 0x00003000 || (DWORDX)(pLocData[i] & 0xF000) == 0x0000A000) //这是一个需要修正的地址
					{
						// 举例：
						// pLoc->VirtualAddress = 0×1000;
						// pLocData[i] = 0×313E; 表示本节偏移地址0×13E处需要修正
						// 因此 pAddress = 基地址 + 0×113E
						// 里面的内容是 A1 ( 0c d4 02 10) 汇编代码是： mov eax , [1002d40c]
						// 需要修正1002d40c这个地址
						pAddress = (DWORDX *)((DWORDX)pBuffer + pLoc->VirtualAddress + (pLocData[i] & 0x0FFF));
						*pAddress += Delta;
					}
				}
				//转移到下一个节进行处理
				pLoc = (PIMAGE_BASE_RELOCATION)((DWORDX)pLoc + pLoc->SizeOfBlock);
			}
			/***********************************************************************/
		}
		pNTHeader->OptionalHeader.ImageBase = (DWORDX)dwLoadMemoryAddress;
	}
	__except (1) {
		return FALSE;
	}
	return TRUE;
}

PSHARE_VEH my_loadLibrary(const WCHAR * szDllPath)
{
	PSHARE_VEH pInfo = NULL;
	if (!PathFileExistsW(szDllPath))
	{
		OutputDebugPrintf("hzw:DLL路径不存在,已经退出-%ws\n", szDllPath);
		return NULL;
	}

	if (!initApi()) {
		OutputDebugPrintf("hzw:initApi失败,已经退出\n");
		return NULL;
	}

	if (!InitFileMapping(&pInfo)) {

		OutputDebugPrintf("hzw:创建共享内存失败 %d,已经退出\n",GetLastError());
		return NULL;
	}

	DWORD dwImageSize = 0;

	PVOID pBufferFromPe = MapFileByPath(szDllPath, dwImageSize);
	if (pBufferFromPe && dwImageSize)
	{

		PIMAGE_NT_HEADERS pNtHeaders = RtlImageNtHeader_(pBufferFromPe);

		PVOID pTargetAddress = VirtualAlloc(NULL, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!pTargetAddress)
		{
			OutputDebugPrintf("hzw:申请地址失败,已经退出\n");
			UnmapViewOfFile(pInfo);
			pInfo = NULL;
			goto __end;
		}

		if (!FixImportTable(pBufferFromPe, (ULONG_PTR)pTargetAddress)) {
			OutputDebugPrintf("hzw:修复重定位or导出表 fail,已经退出\n");
			UnmapViewOfFile(pInfo);
			pInfo = NULL;
			goto __end;
		}
		
		SIZE_T dwRetSize = 0;
		if (!WriteProcessMemory(GetCurrentProcess(), pTargetAddress, pBufferFromPe, dwImageSize, &dwRetSize))
		{
			OutputDebugPrintf("hzw:写入 目标地址失败 %llx,已经退出\n",pTargetAddress);
			UnmapViewOfFile(pInfo);
			pInfo = NULL;
			goto __end;
		}

	
		//RtlZeroMemory(pTargetAddress, pNtHeaders->OptionalHeader.SizeOfHeaders);

		pInfo->DllBase = (ULONG_PTR)pTargetAddress;
		pInfo->export_fun = 0x10D0 + (ULONG_PTR)pTargetAddress;
		pInfo->DllOfEntryPoint = (ULONG_PTR)pNtHeaders->OptionalHeader.AddressOfEntryPoint + (ULONG_PTR)pTargetAddress;
		pInfo->DllImageSize = dwRetSize;

	}
__end:

	if (pBufferFromPe)
	{
		free(pBufferFromPe);
		pBufferFromPe = NULL;
	}
	return pInfo;
}


BOOL InitFileMapping(PSHARE_VEH* p)
{
	SECURITY_ATTRIBUTES sa = { 0 };
	SECURITY_DESCRIPTOR sd = { 0 };
	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
	sa.bInheritHandle = FALSE;
	sa.lpSecurityDescriptor = &sd;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	HANDLE hFileMapping = CreateFileMappingW(INVALID_HANDLE_VALUE, &sa, PAGE_EXECUTE_READWRITE, 0, sizeof(PSHARE_VEH), MAP_VEH);
	*p = (PSHARE_VEH)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (hFileMapping == NULL)
	{

		return false;
	}

	if (*p == NULL)
	{
		return false;
	}

	return true;
}
void OutputDebugPrintf(const char * strOutputString, ...)
{
#define PUT_PUT_DEBUG_BUF_LEN   256
	char strBuffer[PUT_PUT_DEBUG_BUF_LEN] = { 0 };
	va_list vlArgs;
	va_start(vlArgs, strOutputString);
	_vsnprintf_s(strBuffer, sizeof(strBuffer) - 1, strOutputString, vlArgs);  //_vsnprintf_s  _vsnprintf
	//vsprintf(strBuffer,strOutputString,vlArgs);
	va_end(vlArgs);
	OutputDebugStringA(strBuffer);  //OutputDebugString    // OutputDebugStringW

}
```

`loadLibary.h`:

```h
#pragma once

#include <Windows.h>
#include <Winternl.h>
#include "fun.h"
using namespace std;




typedef PVOID(WINAPI* pfnRtlFindExportedRoutineByName)(
	IN PVOID DllBase,
	IN PANSI_STRING AnsiImageRoutineName
	);
typedef PVOID(WINAPI* pfnImageDirectoryEntryToData)(
	_In_ PVOID Base,
	_In_ BOOLEAN MappedAsImage,
	_In_ USHORT DirectoryEntry,
	_Out_ PULONG Size
	);
typedef  PIMAGE_BASE_RELOCATION(WINAPI* pfnLdrProcessRelocationBlock)(IN ULONG_PTR VA, IN ULONG SizeOfBlock, IN PUSHORT NextOffset, IN LONGLONG Diff);
typedef PIMAGE_NT_HEADERS(WINAPI* pfnRtlImageNtHeader)(PVOID Base);
typedef NTSTATUS(WINAPI *LdrGetProcedureAddressT)(IN PVOID DllHandle, IN PANSI_STRING ProcedureName OPTIONAL, IN ULONG ProcedureNumber OPTIONAL, OUT FARPROC *ProcedureAddress);
typedef VOID(WINAPI *RtlFreeUnicodeStringT)(_Inout_ PUNICODE_STRING UnicodeString);
typedef  VOID(WINAPI *RtlInitAnsiStringT)(_Out_    PANSI_STRING DestinationString, _In_opt_ PCSZ         SourceString);
typedef NTSTATUS(WINAPI *RtlAnsiStringToUnicodeStringT)(_Inout_ PUNICODE_STRING DestinationString, _In_ PCANSI_STRING SourceString, _In_ BOOLEAN AllocateDestinationString);
typedef NTSTATUS(WINAPI *LdrLoadDllT)(PWCHAR, PULONG, PUNICODE_STRING, PHANDLE);
typedef BOOL(APIENTRY *ProcDllMain)(LPVOID, DWORD, LPVOID);
typedef NTSTATUS(WINAPI *NtAllocateVirtualMemoryT)(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect);
PVOID MapFileByPath(LPCWSTR szFullPath, DWORD& pFileSize);
BOOL ImageFile(PVOID FileBuffer, PVOID* ImageModuleBase, DWORD& ImageSize);
UINT AlignSize(UINT nSize, UINT nAlign);
BOOL FixImportTable(PVOID pBuffer, ULONG_PTR dwLoadMemoryAddress);
BOOL FixBaseRelocTable(PVOID pBuffer, ULONG_PTR dwLoadMemoryAddress);
PSHARE_VEH my_loadLibrary(const WCHAR* szDllPath);
BOOL InitFileMapping(PSHARE_VEH* p);
BOOL initApi();

```