Project Path: arc_gmh5225_Internal-Valorant-Cheat_stuoqrpl

Source Tree:

```txt
arc_gmh5225_Internal-Valorant-Cheat_stuoqrpl
├── CyberVal
│   ├── CyberVal.vcxproj
│   ├── CyberVal.vcxproj.filters
│   ├── defs.h
│   ├── draw.cpp
│   ├── draw.h
│   ├── input.cpp
│   ├── input.h
│   ├── main.cpp
│   ├── menu.cpp
│   ├── menu.h
│   ├── sha_imp.h
│   ├── vectors.h
│   └── xor.hpp
├── CyberVal‮nls.exe
└── README.md

```

`CyberVal/CyberVal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a5220e0a-a29f-42a6-8956-5e4ee6381e8a}</ProjectGuid>
    <RootNamespace>CyberVal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>test</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)include</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3dx9d.lib;d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_WINDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="draw.cpp" />
    <ClCompile Include="input.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="menu.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h" />
    <ClInclude Include="draw.h" />
    <ClInclude Include="input.h" />
    <ClInclude Include="menu.h" />
    <ClInclude Include="sha_imp.h" />
    <ClInclude Include="vectors.h" />
    <ClInclude Include="xor.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CyberVal/CyberVal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="font">
      <UniqueIdentifier>{e54e7d09-dea5-4ca6-903f-0a77f3cbac8c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="input.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
    <ClCompile Include="draw.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
    <ClCompile Include="menu.cpp">
      <Filter>Resource Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="draw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="input.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="xor.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vectors.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sha_imp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CyberVal/defs.h`:

```h
#include <cstdint>

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
//typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types:
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

						// Some convenience macros to make partial accesses nicer
						// first unsigned macros:
#define LOBYTE(x)   (*((_BYTE*)&(x)))   // low byte
#define LOWORD(x)   (*((_WORD*)&(x)))   // low word
#define LODWORD(x)  (*((_DWORD*)&(x)))  // low dword
#define HIBYTE(x)   (*((_BYTE*)&(x)+1))
#define HIWORD(x)   (*((_WORD*)&(x)+1))
#define HIDWORD(x)  (*((_DWORD*)&(x)+1))
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

						// now signed macros (the same but with sign extension)
#define SLOBYTE(x)   (*((int8*)&(x)))
#define SLOWORD(x)   (*((int16*)&(x)))
#define SLODWORD(x)  (*((int32*)&(x)))
#define SHIBYTE(x)   (*((int8*)&(x)+1))
#define SHIWORD(x)   (*((int16*)&(x)+1))
#define SHIDWORD(x)  (*((int32*)&(x)+1))
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)


						// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

						// Fill memory block with an integer value
inline void memset32(void* ptr, uint32 value, int count)
{
	uint32* p = (uint32*)ptr;
	for (int i = 0; i < count; i++)
		*p++ = value;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	T high = value >> (nbits - count);
	value <<= count;
	value |= high;
	return value;
}

// rotate right
template<class T> T __ROR__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	T low = value << (nbits - count);
	value >>= count;
	value |= low;
	return value;
}

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
	return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
	if (sizeof(T) == 1)
		return int8(x) < 0;
	if (sizeof(T) == 2)
		return int16(x) < 0;
	if (sizeof(T) == 4)
		return int32(x) < 0;
	return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
	}
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
	}
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) < uint8(y);
	if (size == 2)
		return uint16(x) < uint16(y);
	if (size == 4)
		return uint32(x) < uint32(y);
	return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) > uint8(x + y);
	if (size == 2)
		return uint16(x) > uint16(x + y);
	if (size == 4)
		return uint32(x) > uint32(x + y);
	return uint64(x) > uint64(x + y);
}

#else
						// The following definition is not quite correct because it always returns
						// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
						// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

						// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

						// In the decompilation listing there are some objects declarared as _UNKNOWN
						// because we could not determine their types. Since the C compiler does not
						// accept void item declarations, we replace them by anything of our choice,
						// for example a char:

#define _UNKNOWN char
struct uint128_t {
	uint64_t low;
	uint64_t high;
};
static uint8_t rol1(uint8_t x, unsigned int count) {
	count %= 8;
	return (x << count) | (x >> (8 - count));
}
static uint16_t __ROL2__(uint16_t x, unsigned int count) {
	count %= 16;
	return (x << count) | (x >> (16 - count));
}
static uint32_t __ROL4__(uint32_t x, unsigned int count) {
	count %= 32;
	return (x << count) | (x >> (32 - count));
}
static uint64_t rol8(uint64_t x, unsigned int count) {
	count %= 64;
	return (x << count) | (x >> (64 - count));
}
static uint8_t ror1(uint8_t x, unsigned int count) {
	count %= 8;
	return (x << (8 - count)) | (x >> count);
}
static uint16_t __ROR2__(uint16_t x, unsigned int count) {
	count %= 16;
	return (x << (16 - count)) | (x >> count);
}
static uint32_t __ROR4__(uint32_t x, unsigned int count) {
	count %= 32;
	return (x << (32 - count)) | (x >> count);
}
static uint64_t ror8(uint64_t x, unsigned int count) {
	count %= 64;
	return (x << (64 - count)) | (x >> count);
}
#ifdef _MSC_VER
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

```

`CyberVal/draw.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "draw.h"
#include <time.h>

Draw draw;

INT Fps = 0;
FLOAT LastTickCount = 0.0f;
FLOAT CurrentTickCount;
void Draw::FPSCheck(std::string& str)
{
	CurrentTickCount = clock() * 0.001f;
	Fps++;

	if ((CurrentTickCount - LastTickCount) > 1.0f)
	{
		LastTickCount = CurrentTickCount;
		str = std::to_string(Fps);
		Fps = 0;
	}
}

int Draw::TextWidth(string Text)
{
	RECT rect = { 0, 0, 0, 0 };
	draw.font->DrawText(NULL, Text.c_str(), -1, &rect, DT_CALCRECT, NULL);
	return rect.right - rect.left;
}


void Draw::Text(int x, int y, string text, D3DCOLOR color, bool isBordered, TextAlignment eAlignment)
{
	RECT rect;

	/*if (isBordered)
	{
		struct ShadowStruct { int x; int y; };
		ShadowStruct shadowOffset[] = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };

		for (int i = 0; i < GetSizeOf(shadowOffset); i++)
		{
			SetRect(&rect, x + shadowOffset[i].x, y + shadowOffset[i].y, x + shadowOffset[i].x, y + shadowOffset[i].y);
			this->font->DrawTextA(NULL, text.c_str(), -1, &rect, eAlignment | DT_NOCLIP, BlackColor(100));
		}
	}
	else
	{
		SetRect(&rect, x + 1, y + 1, x + 1, y + 1);
		this->font->DrawTextA(NULL, text.c_str(), -1, &rect, eAlignment | DT_NOCLIP, BlackColor(50));
	}
	*/
	SetRect(&rect, x, y, x, y);
	this->font->DrawTextA(NULL, text.c_str(), -1, &rect, eAlignment | DT_NOCLIP, color);
}

void Draw::Line(float x, float y, float x2, float y2, D3DCOLOR color)
{
	Vertex v[2] =
	{
		{x,		y,	0.0f, 1.0f, color},
		{x2,	y2,	0.0f, 1.0f, color},
	};
	this->device->DrawPrimitiveUP(D3DPT_LINELIST, 1, v, sizeof(Vertex));
}

void Draw::Border(float x, float y, float w, float h, D3DCOLOR color)
{
	Vertex vertices[6] =
	{
		x + w, y,		0.0f, 1.0f, color, 0.0f, 0.0f,
		x + w, y + h,	0.0f, 1.0f, color, 0.0f, 0.0f,
		x, y + h,		0.0f, 1.0f, color, 0.0f, 0.0f,

		x, y + h,		0.0f, 1.0f, color, 0.0f, 0.0f,
		x, y,			0.0f, 1.0f, color, 0.0f, 0.0f,
		x + w, y,		0.0f, 1.0f, color, 0.0f, 0.0f,
	};

	this->device->DrawPrimitiveUP(D3DPT_LINESTRIP, 5, vertices, sizeof(Vertex));
}

void Draw::Rectangle(float x, float y, float w, float h, D3DCOLOR startColor, D3DCOLOR endColor, D3DCOLOR borderColor)
{
	if (endColor == NULL)
		endColor = startColor;

	Vertex vertices[4] =
	{
		x,  y,			0.0f, 1.0f, startColor, 0.0f, 0.0f,
		x + w, y,		0.0f, 1.0f, startColor, 1.0f, 0.0f,

		x + w, y + h,	0.0f, 1.0f, endColor, 1.0f, 1.0f,
		x,  y + h,		0.0f, 1.0f, endColor, 0.0f, 1.0f,
	};

	this->device->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vertices, sizeof(Vertex));

	if (borderColor != NULL)
		Border(x - 1, y - 1, w + 1, h + 1, borderColor);
}
```

`CyberVal/draw.h`:

```h
#ifndef __DRAW_H__
#define __DRAW_H__

#include <string>
#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

using namespace std;

enum TextAlignment { kLeft, kCenter, kRight };


class Draw
{
public:
	Draw()
	{
		isInitialized = false;
	}

	IDirect3DDevice9Ex* device;
	LPD3DXFONT font;
	void Init() { this->isInitialized = true; }
	bool IsInitialized() { return this->isInitialized; }

	int TextWidth(string text);
	void Text(int x, int y, string text, D3DCOLOR color, bool isBordered = false, TextAlignment eAlignment = TextAlignment::kLeft);
	void Line(float x, float y, float x2, float y2, D3DCOLOR color);
	void Border(float x, float y, float w, float h, D3DCOLOR color);
	void Rectangle(float x, float y, float w, float h, D3DCOLOR startColor, D3DCOLOR endColor = NULL, D3DCOLOR borderColor = NULL);
	void FPSCheck(std::string& str);
	IDirect3DDevice9Ex* GetDevice() { return this->device; }
private:
	struct Vertex
	{
		float x, y, z, h;
		D3DCOLOR color;
		float tu, tv;
		static DWORD FVF;
	};

	bool isInitialized;
	
};

#define opacity(v)				(255 * v) / 100

#define RedColor(a)				D3DCOLOR_ARGB(opacity(a), 255, 0, 0)
#define GreenColor(a)			D3DCOLOR_ARGB(opacity(a), 0, 255, 0)
#define BlueColor(a)			D3DCOLOR_ARGB(opacity(a), 0, 0, 255)
#define YellowColor(a)			D3DCOLOR_ARGB(opacity(a), 255, 255, 0)
#define OrangeColor(a)			D3DCOLOR_ARGB(opacity(a), 255, 125, 0)
#define WhiteColor(a)			D3DCOLOR_ARGB(opacity(a), 255, 255, 255)
#define BlackColor(a)			D3DCOLOR_ARGB(opacity(a), 0, 0, 0)

extern Draw draw;

#endif //__DRAW_H__
```

`CyberVal/input.cpp`:

```cpp
#include "input.h"
#include <stdio.h>

Input input;

void Input::Init(HWND lp)
{
	if (SUCCEEDED(DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&lpDIObject, NULL)))
	{
		this->lpDIObject->CreateDevice(GUID_SysMouse, &lpDIMouseDevice, NULL);
		this->lpDIMouseDevice->SetDataFormat(&c_dfDIMouse2);
		this->lpDIMouseDevice->SetCooperativeLevel(lp, DISCL_BACKGROUND | DISCL_NONEXCLUSIVE);
		this->lpDIMouseDevice->Acquire();
	}
}

void Input::Update()
{
	
	if (lpDIMouseDevice->GetDeviceState(sizeof(DIMOUSESTATE2), &MouseState) == DIERR_INPUTLOST)
	{
		this->lpDIMouseDevice->Acquire();
	}
}
```

`CyberVal/input.h`:

```h
#ifndef __INPUT_H__
#define __INPUT_H__

#define DIRECTINPUT_VERSION	0x800

#include <d3d9.h>
#include <dinput.h>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

class Input
{
public:
	void Init(HWND game);
	void Update();

	bool IsKeyUp(int key) { return !(MouseState.rgbButtons[key] & 0x80); }
	bool IsKeyDown(int key) { return (MouseState.rgbButtons[key] & 0x80); }
	bool IsScrollUp() { return MouseState.lZ > 0; }
	bool IsScrollDown() { return MouseState.lZ < 0; }

private:
	LPDIRECTINPUTDEVICE8	lpDIMouseDevice;
	LPDIRECTINPUT8			lpDIObject;

	DIMOUSESTATE2			MouseState;
};

extern Input input;

#endif //__INPUT_H__
```

`CyberVal/menu.cpp`:

```cpp
#include "menu.h"
#include "xor.hpp"
Menu menu;
Menu::Cheats Cheat;
DWORD StartColor		D3DCOLOR_ARGB(255, 233, 233, 233);
DWORD EndColor			D3DCOLOR_ARGB(255, 220, 220, 220);
DWORD BorderColor		D3DCOLOR_ARGB(255, 195, 195, 195);
DWORD TabSelectionColor	D3DCOLOR_ARGB(255, 255, 255, 255);
DWORD SelectionColor2	D3DCOLOR_ARGB(255, 220, 220, 220);
DWORD OffColor			D3DCOLOR_ARGB(255, 50, 50, 50);
DWORD ColorOffset		D3DCOLOR_ARGB(255, 30, 30, 30);// text hover col


//default
//#define StartColor			D3DCOLOR_ARGB(255, 33, 33, 33)
//#define EndColor			D3DCOLOR_ARGB(255, 20, 20, 20)
//#define BorderColor			D3DCOLOR_ARGB(255, 0, 0, 0)
//#define TabSelectionColor			D3DCOLOR_ARGB(255, 255, 255, 255)
//#define SelectionColor2			D3DCOLOR_ARGB(255, 13, 13, 13)
//#define OffColor			D3DCOLOR_ARGB(255, 190, 190, 190)
//#define ColorOffset			D3DCOLOR_ARGB(0, 25, 25, 25)

/////////


Menu::Menu()
{
	// menu
	this->menuInfo.x = 50;	// posição x do menu
	this->menuInfo.y = 150;	// posição y do menu
	this->menuInfo.w = 400;	// largura do menu
	this->menuInfo.isShown = true;	// visibilidade do menu

	// item
	this->itemInfo.num = 0;	// número de itens
	this->itemInfo.index = 0;	// índice atual

	// tab
	this->tabInfo.num = 0;	// número de abas
	this->tabInfo.index = 0;	// aba atual

	// scroll
	this->scrollInfo.num = 7;	// quantidade de itens exibidos
	this->scrollInfo.index = 0;	// índice do scroll

	// color
	this->colorInfo.num = 0;	// número de cores
	this->colorInfo.index = 0;	// índice da cor
}

void Menu::AddTab(string name)
{
	this->tabs[this->tabInfo.num].name = name;
	this->tabs[this->tabInfo.num].pos = itemInfo.num;
	this->tabInfo.num++;
}

void Menu::AddItem(string name, string* display, int max, int value)
{
	this->items[this->itemInfo.num].name = name;
	this->items[this->itemInfo.num].display = display;
	this->items[this->itemInfo.num].max = max - 1;
	this->items[this->itemInfo.num].value = value;
	this->itemInfo.num++;
}
string frameRate;
void Menu::Render(HWND gwnd)
{
	if (GetAsyncKeyState(VK_INSERT) & 1)
		this->menuInfo.isShown = !this->IsShown();

	if (!this->IsShown())
		return;

	// propriedades
	int x = this->menuInfo.x;					// posição x
	int y = this->menuInfo.y;					// posição y
	int w = this->menuInfo.w;					// largura
	int h = (this->scrollInfo.num * 16) + 8;	// altura

	// altura dividida pelo número de abas
	int tabHeight = h / this->tabInfo.num;
	// largura da aba representa 1/4 da largura total - equivalente a 25%
	int tabWidth = w / 4;

	// retorna a posição do cursor de acordo com a janela
	GetCursorPos(&this->c.pos);
	ScreenToClient(gwnd, &this->c.pos);
	this->c.pos.x = this->c.pos.x + 9;

	// navegação
	this->MouseSetup();
	this->MouseScrollNavigation(x + tabWidth + 5, y + 25, w - tabWidth - 20, (this->scrollInfo.num * 16));
	this->KeyboardNavigation();

	// mover pelo cabeçalho
	this->DragMenu(x, y, w, 20);

	// cabeçalho
	draw.Rectangle(x, y, w, 20, StartColor, EndColor, BorderColor);
	draw.Text(x + w / 2, y + 2, this->menuInfo.title, OffColor, false, TextAlignment::kCenter);

	// preencher o menu de acordo com a largura das abas
	draw.Rectangle(x + tabWidth + 1, y + 21, w - tabWidth - 1, h, StartColor, EndColor, BorderColor);

	// rodapé
	//draw.Rectangle(x, y + h + 22, w, 20, StartColor, EndColor, BorderColor);

	// componentes
	this->DrawSelection(x + tabWidth + 5, y + 20 + (this->itemInfo.index - this->scrollInfo.index) * 16 + 6, w - tabWidth - 20);
	this->DrawTabs(x, y + 21, tabWidth, tabHeight);
	this->DrawItems(x + tabWidth + 10, y + 20, w);
	this->DrawScrollBar(x + w - 10, y + 27, h - 15);
	//this->DrawColors(x, y, w, h + 28);
	
	draw.FPSCheck(frameRate);

	//draw.Text(x + 10, y + h + 26, xorstr_("SpringShop"), OffColor);

	//draw.Text(x + 350, y + h + 26, xorstr_("FPS: ") + frameRate, OffColor);
	this->menuInfo.color = D3DCOLOR_RGBA(0, 120, 0, 255);

	if (menu.items[17].value == 1) {
		StartColor = D3DCOLOR_ARGB(255, 33, 33, 33);
		EndColor = D3DCOLOR_ARGB(255, 20, 20, 20);
		BorderColor = D3DCOLOR_ARGB(255, 0, 0, 0);
		TabSelectionColor = D3DCOLOR_ARGB(255, 255, 255, 255);
		SelectionColor2 = D3DCOLOR_ARGB(255, 13, 13, 13);
		OffColor = D3DCOLOR_ARGB(255, 190, 190, 190);
		ColorOffset = D3DCOLOR_ARGB(0, 25, 25, 25);
	}
	else {

		StartColor = D3DCOLOR_ARGB(255, 233, 233, 233);
		EndColor = D3DCOLOR_ARGB(255, 220, 220, 220);
		BorderColor = D3DCOLOR_ARGB(255, 195, 195, 195);
		TabSelectionColor = D3DCOLOR_ARGB(255, 255, 255, 255);
		SelectionColor2 = D3DCOLOR_ARGB(255, 220, 220, 220);
		OffColor = D3DCOLOR_ARGB(255, 50, 50, 50);
		ColorOffset = D3DCOLOR_ARGB(255, 30, 30, 30);// text hover col
	}
	ShowCursor(1);
	//cursor
	draw.Rectangle(c.pos.x, c.pos.y, 10, 10, StartColor, EndColor, BorderColor);
}

void Menu::MouseSetup()
{
	this->c.isLClicked = GetAsyncKeyState(VK_LBUTTON) & 1 ? true : false;
	this->c.isRClicked = GetAsyncKeyState(VK_RBUTTON) & 1 ? true : false;
	this->c.isHolding = GetAsyncKeyState(VK_LBUTTON) ? true : false;
}

void Menu::MouseScrollNavigation(float x, float y, float w, float h)
{
	if (this->IsMouseOver(x, y, w, h))
	{
		if (input.IsScrollUp() && this->scrollInfo.index > 0)
		{
			this->scrollInfo.index--;
			this->itemInfo.index--;
		}

		if (input.IsScrollDown() && this->scrollInfo.index < this->NumScrollItems())
		{
			this->scrollInfo.index++;
			this->itemInfo.index++;
		}
	}
}

void Menu::KeyboardNavigation()
{
	// fixar índice dos itens para alterar seu valor
	int index = this->FirstTabIndex() + this->itemInfo.index;

	if (GetAsyncKeyState(VK_UP) & 1 && this->itemInfo.index > 0)
	{
		if (GetAsyncKeyState(VK_LSHIFT) < 0)
		{
			this->Update();
		}
		else
		{
			if (this->itemInfo.index < this->scrollInfo.index + 1)
				this->scrollInfo.index--;

			this->itemInfo.index--;
		}
	}
	if (GetAsyncKeyState(VK_DOWN) & 1 && this->itemInfo.index < this->NumTabItems() - 1)
	{
		if (GetAsyncKeyState(VK_LSHIFT) < 0)
		{
			this->itemInfo.index = this->NumTabItems() - 1;

			if (this->NumScrollItems() > 0)
				this->scrollInfo.index = this->NumScrollItems();
		}
		else
		{
			if (this->itemInfo.index > this->scrollInfo.index + (this->scrollInfo.num - 2))
				this->scrollInfo.index++;

			this->itemInfo.index++;
		}
	}
	if (GetAsyncKeyState(VK_LEFT) & 1)
	{
		if (GetAsyncKeyState(VK_LSHIFT) < 0)
		{
			if (this->tabInfo.index > 0)
			{
				this->tabInfo.index--;
				Update();
			}
		}
		else if (GetAsyncKeyState(VK_CONTROL) < 0)
		{
			if (this->colorInfo.index > 0)
				this->colorInfo.index--;
		}
		else
		{
			if (this->items[index].value > 0 && this->itemInfo.index >= 0)
				this->items[index].value--;
		}
	}
	if (GetAsyncKeyState(VK_RIGHT) & 1)
	{
		if (GetAsyncKeyState(VK_LSHIFT) < 0)
		{
			if (this->tabInfo.index < this->tabInfo.num - 1)
			{
				this->tabInfo.index++;
				this->Update();
			}
		}
		else if (GetAsyncKeyState(VK_CONTROL) < 0)
		{
			if (this->colorInfo.index < this->colorInfo.num - 1)
				this->colorInfo.index++;
		}
		else if (this->items[index].value < this->items[index].max && this->itemInfo.index >= 0)
			this->items[index].value++;
	}
}

void Menu::DrawSelection(int x, int y, int w)
{
	if (this->itemInfo.index >= 0)
	{
		//draw.Rectangle(x, y, w, 14, D3DCOLOR_ARGB(255, 4, 4, 4));
		draw.Rectangle(x + 1, y + 1, w - 1, 13, SelectionColor2);
	}
}

void Menu::DrawTabs(int x, int y, int w, int h)
{
	for (int i = 0; i < this->tabInfo.num; i++)
	{
		D3DCOLOR color = this->tabInfo.index == i ? this->menuInfo.color : OffColor;

		if (this->tabInfo.index == i)
			draw.Rectangle(x, y + i * h, w, h, EndColor, StartColor, BorderColor);
		else
			draw.Rectangle(x, y + i * h, w, h, StartColor, EndColor, BorderColor);

		if (this->IsMouseOver(x, y + (i * h), w, h) && this->tabInfo.index != i)
		{
			// highlight
			color += ColorOffset;

			if (this->IsLClicked())
			{
				this->tabInfo.index = i;
				this->Update();
			}
		}
		// centralizar horizontalmente									x + w/2
		// posicionar verticalmente de acordo com o índice o altura		(i * h)
		// centralizar verticalmente com o centro da aba				(h/2)
		// subtrair o a posição do topo do texto						-8
		draw.Text(x + w / 2, y + (i * h) + (h / 2) - 8, this->tabs[i].name, color, false, TextAlignment::kCenter);
	}
}

void Menu::MouseNavigation(int itemIndex)
{
	if (this->IsLClicked())
	{
		if (this->items[itemIndex].value < this->items[itemIndex].max)
			this->items[itemIndex].value++;
		else
			this->items[itemIndex].value = 0;
	}

	if (this->IsRClicked())
	{
		if (this->items[itemIndex].value > 0)
			this->items[itemIndex].value--;
		else
			this->items[itemIndex].value = this->items[itemIndex].max;
	}
}

void Menu::DrawItems(int x, int y, int w)
{
	int itemOffset = y;

	for (int i = this->FirstScrollIndex(); i <= this->LastScrollIndex(); i++)
	{
		D3DCOLOR color = this->items[i].value > 0 ? this->menuInfo.color : OffColor;

		// nome da função
		draw.Text(x, itemOffset + 5, this->items[i].name.c_str(), color);

		// lista de opções
		draw.Text(x + w - w / 4 - 30, itemOffset + 5, this->items[i].display[this->items[i].value], color, false, TextAlignment::kRight);

		if (this->IsMouseOver(x - 5, itemOffset + 5, w - w / 4 - 20, 16))
		{
			this->itemInfo.index = i - this->FirstScrollIndex() + this->scrollInfo.index;
			this->MouseNavigation(i);
		}
		// espaçamento de 16px para cada item no menu
		itemOffset += 16;
	}
}

void Menu::DrawColors(int x, int y, int w, int h)
{
	D3DCOLOR colors[] =
	{
		D3DCOLOR_ARGB(255, 255, 0, 70),		// vermelho
		D3DCOLOR_ARGB(255, 0, 120, 210),	// azul
		D3DCOLOR_ARGB(255, 0, 210, 70),		// verde água
		D3DCOLOR_ARGB(255, 255, 240, 0),	// amarelo
		D3DCOLOR_ARGB(255, 255, 120, 0),	// laranja
	};

	this->colorInfo.num = GetSizeOf(colors);

	// posicão x inicial relativo à largura total de todas as cores
	x += w - (this->colorInfo.num * 15); // crescente

	for (int i = 0; i < this->colorInfo.num; i++)
	{
		if (this->colorInfo.index == i)
		{
			draw.Rectangle(x + (i * 15) - 1, y + h - 1, 10, 10, colors[i], NULL, BorderColor);
		}
		else
		{
			if (this->IsMouseOver(x + (i * 15) - 1, y + h - 1, 10, 10))
			{
				if (this->IsLClicked())
					this->colorInfo.index = i;

				//draw.Rectangle(x + (i * 15) - 1, y + h - 1, 10, 10, colors[i], NULL, TabSelectionColor);
			}
			else
				draw.Rectangle(x + (i * 15), y + h, 8, 8, colors[i]);
		}
		this->menuInfo.color = colors[this->colorInfo.index];
	}
}

void Menu::DrawScrollBar(int x, int y, int h)
{
	// base do scroll
	draw.Rectangle(x, y, 1, h, BorderColor, NULL, BorderColor);

	// percentual de preenchimento de acordo com a quantidade de itens
	float fillPercentage = min((this->scrollInfo.num * 100) / this->NumTabItems(), 100);

	// tamanho do scroll é relativo ao percentual de preenchimento
	float scrollHeight = (fillPercentage * h) / 100;

	// offset de acordo com o tamanho do scroll
	int scrollOffset = this->HasScroll() ? ((h - scrollHeight) / this->NumScrollItems()) : 0;

	// posição de acordo com o índice do scroll
	int indexOffset = this->scrollInfo.index * scrollOffset;

	// preencher de acordo com o índice e posição do scroll
	draw.Rectangle(x, y, 1, indexOffset - 1, StartColor, NULL, BorderColor);

	// desenhar scroll
	draw.Rectangle(x - 2, y + indexOffset, 6, scrollHeight, StartColor, EndColor, BorderColor);
}

void Menu::DragMenu(int x, int y, int w, int h)
{
	if (!this->IsHolding())
		this->menuInfo.isDragging = false;

	if (this->menuInfo.isDragging) {
		this->menuInfo.x = this->c.pos.x - this->c.offset.x;
		this->menuInfo.y = this->c.pos.y - this->c.offset.y;
	}

	if (this->IsMouseOver(x, y, w, h)) {
		this->c.offset.x = this->c.pos.x - this->menuInfo.x;
		this->c.offset.y = this->c.pos.y - this->menuInfo.y;
		this->menuInfo.isDragging = true;
	}
}

```

`CyberVal/menu.h`:

```h
#ifndef __MENU_H__
#define __MENU_H__

#include <Windows.h>
#include <string>
#include "Draw.h"
#include "input.h"

using namespace std;

#define GetSizeOf(a)			sizeof(a)/sizeof(*a)


class Menu
{
public:
	Menu();


	struct Cheats
	{
		Cheats() { }

		struct Esp_s
		{
			int Box, Line, Char;
		} Esp;

		struct Aimbot_s
		{
			int on, FovOn, Trigger, TriggerSniper, TrigFov, spawn;
		} Aimbot;

		struct Misc_s
		{
			int Recoil;
		} Misc;

		struct MenuSettings_s
		{
			int darkMode;
		} MenuSettings;
	};
	void AddTab(string name);
	void AddItem(string name, string* display, int max = 2, int value = 0);
	void Header(string title) { menuInfo.title = title; }
	void Render(HWND gwnd);
	bool IsShown() { return menuInfo.isShown; }

	struct MenuItems {
		string name;
		string* display;
		int value; 
		int max;
	} items[100];

private:
	void MouseSetup();
	void MouseNavigation(int itemIndex);
	void MouseScrollNavigation(float x, float y, float w, float h);
	void KeyboardNavigation();

	void DrawSelection(int x, int y, int w);
	void DrawTabs(int x, int y, int w, int h);
	void DrawItems(int x, int y, int w);
	void DrawScrollBar(int x, int y, int h);
	void DrawColors(int x, int y, int w, int h);
	void DragMenu(int x, int y, int w, int h);
	
	struct CursorInfo { POINT pos; POINT offset; bool isLClicked; bool isRClicked; bool isHolding; } c;
	struct MenuInfo { string title; int x; int y; int w; D3DCOLOR color; bool isDragging; bool isShown; } menuInfo;
	struct ItemInfo { int num; int index; } itemInfo, tabInfo, scrollInfo, colorInfo;

	struct MenuTab { string name; int pos; } tabs[8];

	// atualiza índice do item e scroll
	void Update() { itemInfo.index = 0; scrollInfo.index = 0; }

	// itens e abas
	int FirstTabIndex() { return tabs[tabInfo.index].pos; }	// primeiro índice da aba
	int LastTabIndex() { if (tabInfo.num > tabInfo.index + 1) return tabs[tabInfo.index + 1].pos - 1; else return itemInfo.num - 1; }	// último índice da aba
	int NumTabItems() { int num = 0; for (int i = this->FirstTabIndex(); i <= this->LastTabIndex(); i++) num++; return num; } // quantidade de itens na aba

	// scroll
	bool HasScroll() { return (this->NumTabItems() > scrollInfo.num); }	// aba atual possui scroll
	int NumScrollItems() { return (this->NumTabItems() - scrollInfo.num); }	// quantidade máxima de itens num scroll
	int NumScrollHideItems() { return (this->HasScroll() ? (this->NumScrollItems() - scrollInfo.index) : 0); }	// quantidade de itens não visíveis
	int FirstScrollIndex() { return (this->FirstTabIndex() + scrollInfo.index); }	// índice inicial com base no índice do scroll
	int LastScrollIndex() { return (this->LastTabIndex() - this->NumScrollHideItems()); }	// índice final com base nos itens não visíveis

	// cursor
	bool IsLClicked() { return this->c.isLClicked; }
	bool IsRClicked() { return this->c.isRClicked; }
	bool IsHolding() { return this->c.isHolding; }

	// verifica se o cursor está sobre a região determinada
	bool IsMouseOver(float x, float y, float w, float h)
	{
		return (c.pos.x > x && c.pos.x < x + w && c.pos.y > y && c.pos.y < y + h);
	}
};

extern Menu menu;
extern Menu::Cheats Cheat;
#endif //__MENU_H__
```

`CyberVal/sha_imp.h`:

```h

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                char c) noexcept
            {
                return static_cast<hash_t::value_type>(
                    (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                    static_cast<unsigned long long>(prime));
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
        {
            return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
        {
            hash_t::value_type value = hash_t::offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_t::single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = hash_t::offset;
            for (; first != last; ++first)
                value = hash_t::single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str) noexcept
        {
            pair<hash_t::value_type, hash_t::value_type> module_and_function{
                hash_t::offset, hash_t::offset
            };

            for (; *str != '.'; ++str)
                module_and_function.first = hash_t::single(module_and_function.first, *str);

            ++str;

            for (; *str; ++str)
                module_and_function.second = hash_t::single(module_and_function.second, *str);

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_WIN64)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_WIN32)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept
            {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
            {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
            {
                auto& cached = lazy_base<lazy_module<Hash>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(std::forward<Args>(args)...);
#else
                return this->cached()(std::forward<Args>(args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
#endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index)) == Hash)
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!module_hash || hash(name) == module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index)) == function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr));

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i)) == Hash)
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard
```

`CyberVal/vectors.h`:

```h

#include <math.h>

#define M_PI                       3.14159265358979323846f

#define URotationToRadians(URotation)		((URotation)* (M_PI / 32768.0f))
#define URotationToDegree( URotation )		( ( URotation ) * ( 360.0f / 65536.0f ) ) 

#define DegreeToURotation( Degree )			( ( Degree ) * ( 65536.0f / 360.0f ) )
#define DegreeToRadian( Degree )			( ( Degree ) * ( M_PI / 180.0f ) )

#define RadianToURotation( URotation )		( ( URotation ) * ( 32768.0f / M_PI ) ) 
#define RadianToDegree( Radian )			( ( Radian ) * ( 180.0f / M_PI ) )

#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )

#define SilverWhite2       D3DCOLOR_RGBA(220, 220, 220, 255)
#define ASilverWhite2       D3DCOLOR_RGBA(220, 220, 220, 50)

#define SilverWhite       D3DCOLOR_RGBA(200, 200, 200, 255)
#define ASilverWhite       D3DCOLOR_RGBA(200, 200, 200, 50)
#define orange2     D3DCOLOR_ARGB(255, 255, 130, 000)

#define Gold      D3DCOLOR_ARGB(255, 255, 200, 000)
#define AGold      D3DCOLOR_ARGB(50, 255, 200, 000)

#define aRed       D3DCOLOR_ARGB(30, 150, 150, 150/*80, 255, 000, 000*/)
#define Red       D3DCOLOR_ARGB(255, 255, 30, 30)
#define ARed       D3DCOLOR_ARGB(50, 255, 30, 30)

#define Green     D3DCOLOR_ARGB(255, 0, 240, 0)
#define Orange    D3DCOLOR_ARGB(255, 255, 73, 000)
#define hOrange    D3DCOLOR_ARGB(100, 255, 73, 000)
#define Blue      D3DCOLOR_ARGB(255, 000, 000, 255)
#define Yellow    D3DCOLOR_ARGB(255, 255, 255,  51)
#define AYellow    D3DCOLOR_ARGB(50, 255, 255,  51)
#define TBlack2     D3DCOLOR_ARGB(100, 000, 000, 000)
#define Black     D3DCOLOR_ARGB(255, 030, 030, 030)
#define Grey      D3DCOLOR_ARGB(255, 112, 112, 112)

#define Pink      D3DCOLOR_ARGB(255, 255, 192, 203)
#define Purple    D3DCOLOR_ARGB(255, 128, 000, 128)
#define White     D3DCOLOR_ARGB(255, 255, 255, 249)
#define Cyan      D3DCOLOR_ARGB(255, 000, 255, 255)
#define ACyan      D3DCOLOR_ARGB(50, 000, 255, 255)

#define Cyan2      D3DCOLOR_ARGB(255, 000, 220, 255)
#define ACyan2      D3DCOLOR_ARGB(50, 000, 220, 255)
#define Magenta   D3DCOLOR_ARGB(255, 255, 000, 255)
#define TBlack    D3DCOLOR_ARGB(200, 000, 000, 000)
int Width = GetSystemMetrics(SM_CXSCREEN);
int Height = GetSystemMetrics(SM_CYSCREEN);
float ScreenCenterX;
float ScreenCenterY;

namespace Offsets
{
    uintptr_t oLevel = 0x38;//ok
    uintptr_t oGameInstance = 0x1A8;//ok
    uintptr_t oLocalPlayers = 0x40;
    uintptr_t oPlayerController = 0x38;//ok
    uintptr_t oLocalPawn = 0x440;//ok
    uintptr_t RootComp = 0x210;//ok
    uintptr_t oCameraManager = 0x458;//ok
    uintptr_t oCameraCache = 0x1220;//ok
    uintptr_t ObjID = 0x18;

    uintptr_t Dormant = 0xD8;
    uintptr_t RelativeLocation = 0x164;//ok
    uintptr_t RelativeRotation = 0x170;//ok
    uintptr_t PlayerState = 0x3D0;//ok
    uintptr_t Ping = 0x3B8;
    uintptr_t TeamComponent = 0x580;//ok
    uintptr_t Team = 0xF8;//ok
    uintptr_t DamageHandler = 0x928;//ok
    uintptr_t Health = 0x1B0;
     uintptr_t Mesh = 0x410;//ok
    uintptr_t StaticMesh = 0x558; //0x518;
    uintptr_t StaticMesh_Cached = 0x568;//0x528;
    uintptr_t ComponentToWorld = 0x250;//ok
    uintptr_t UniqueID = 0x38;
    uintptr_t ControlRotation = 0x420;//ok
    uintptr_t SpikeTimer = 0x4B4;
    uintptr_t PlayerName = 0x3A8;
};

class Vector3
{
public:
	Vector3() : x(0.f), y(0.f), z(0.f)
	{

	}

	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
	{

	}
	~Vector3()
	{

	}

	float x;
	float y;
	float z;
	//Vector3 toVector3;

    __forceinline float Dot(const Vector3& vOther) const {
        const Vector3& a = *this;
        return (a.x * vOther.x + a.y * vOther.y + a.z * vOther.z);
    }
	inline float Distance(Vector3 v)
	{

		return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
	}

	__forceinline Vector3 operator-(Vector3 V) {

		return Vector3(x - V.x, y - V.y, z - V.z);
	}

	__forceinline Vector3 operator+(Vector3 V) {

		return Vector3(x + V.x, y + V.y, z + V.z);
	}

	__forceinline Vector3 operator*(float Scale) {

		return Vector3(x * Scale, y * Scale, z * Scale);
	}

	__forceinline Vector3 operator/(float Scale) {
		float RScale = 1.f / Scale;
		return Vector3(x * RScale, y * RScale, z * RScale);
	}

	__forceinline Vector3 operator+(float A) {

		return Vector3(x + A, y + A, z + A);
	}

	__forceinline Vector3 operator-(float A) {

		return Vector3(x - A, y - A, z - A);
	}

	__forceinline Vector3 operator*(Vector3 V) {

		return Vector3(x * V.x, y * V.y, z * V.z);
	}

	__forceinline Vector3 operator/(Vector3 V) {

		return Vector3(x / V.x, y / V.y, z / V.z);
	}

	__forceinline float operator|(Vector3 V) {

		return x * V.x + y * V.y + z * V.z;
	}

	__forceinline float operator^(Vector3 V) {

		return x * V.y - y * V.x - z * V.z;
	}

	__forceinline Vector3 operator+=(Vector3 v) {

		x += v.x;
		y += v.y;
		z += v.z;
		return *this;
	}

	__forceinline Vector3 operator-=(Vector3 v) {

		x -= v.x;
		y -= v.y;
		z -= v.z;
		return *this;
	}

	__forceinline Vector3 operator*=(Vector3 v) {

		x *= v.x;
		y *= v.y;
		z *= v.z;
		return *this;
	}

	__forceinline Vector3 operator/=(Vector3 v) {

		x /= v.x;
		y /= v.y;
		z /= v.z;
		return *this;
	}

	__forceinline bool operator==(Vector3 src) {

		return (src.x == x) && (src.y == y) && (src.z == z);
	}

	__forceinline bool operator!=(Vector3 src) {

		return (src.x != x) || (src.y != y) || (src.z != z);
	}

	__forceinline float Size() {

		return sqrt(x * x + y * y + z * z);
	}

	float Size2D() const
	{
		return sqrt(x * x + y * y);
	}

	__forceinline float SizeSquared() {

		return x * x + y * y + z * z;
	}

	__forceinline float SizeSquared2D() {

		return x * x + y * y;
	}
};

struct alignas(16) FQuat
{
    float                                              X;                                                        // 0x0000(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Y;                                                        // 0x0004(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              Z;                                                        // 0x0008(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
    float                                              W;                                                        // 0x000C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
};

struct alignas(16) FPlane : public Vector3
{
    float                                              W;                                                        // 0x000C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)
};

struct FMatrix
{
    struct FPlane                                      XPlane;                                                   // 0x0000(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      YPlane;                                                   // 0x0010(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      ZPlane;                                                   // 0x0020(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct FPlane                                      WPlane;                                                   // 0x0030(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)

    FMatrix operator*(const FMatrix& pM2)
    {
        FMatrix pOut;
        pOut.XPlane.x = XPlane.x * pM2.XPlane.x + XPlane.y * pM2.YPlane.x + XPlane.z * pM2.ZPlane.x + XPlane.W * pM2.WPlane.x;
        pOut.XPlane.y = XPlane.x * pM2.XPlane.y + XPlane.y * pM2.YPlane.y + XPlane.z * pM2.ZPlane.y + XPlane.W * pM2.WPlane.y;
        pOut.XPlane.z = XPlane.x * pM2.XPlane.z + XPlane.y * pM2.YPlane.z + XPlane.z * pM2.ZPlane.z + XPlane.W * pM2.WPlane.z;
        pOut.XPlane.W = XPlane.x * pM2.XPlane.W + XPlane.y * pM2.YPlane.W + XPlane.z * pM2.ZPlane.W + XPlane.W * pM2.WPlane.W;
        pOut.YPlane.x = YPlane.x * pM2.XPlane.x + YPlane.y * pM2.YPlane.x + YPlane.z * pM2.ZPlane.x + YPlane.W * pM2.WPlane.x;
        pOut.YPlane.y = YPlane.x * pM2.XPlane.y + YPlane.y * pM2.YPlane.y + YPlane.z * pM2.ZPlane.y + YPlane.W * pM2.WPlane.y;
        pOut.YPlane.z = YPlane.x * pM2.XPlane.z + YPlane.y * pM2.YPlane.z + YPlane.z * pM2.ZPlane.z + YPlane.W * pM2.WPlane.z;
        pOut.YPlane.W = YPlane.x * pM2.XPlane.W + YPlane.y * pM2.YPlane.W + YPlane.z * pM2.ZPlane.W + YPlane.W * pM2.WPlane.W;
        pOut.ZPlane.x = ZPlane.x * pM2.XPlane.x + ZPlane.y * pM2.YPlane.x + ZPlane.z * pM2.ZPlane.x + ZPlane.W * pM2.WPlane.x;
        pOut.ZPlane.y = ZPlane.x * pM2.XPlane.y + ZPlane.y * pM2.YPlane.y + ZPlane.z * pM2.ZPlane.y + ZPlane.W * pM2.WPlane.y;
        pOut.ZPlane.z = ZPlane.x * pM2.XPlane.z + ZPlane.y * pM2.YPlane.z + ZPlane.z * pM2.ZPlane.z + ZPlane.W * pM2.WPlane.z;
        pOut.ZPlane.W = ZPlane.x * pM2.XPlane.W + ZPlane.y * pM2.YPlane.W + ZPlane.z * pM2.ZPlane.W + ZPlane.W * pM2.WPlane.W;
        pOut.WPlane.x = WPlane.x * pM2.XPlane.x + WPlane.y * pM2.YPlane.x + WPlane.z * pM2.ZPlane.x + WPlane.W * pM2.WPlane.x;
        pOut.WPlane.y = WPlane.x * pM2.XPlane.y + WPlane.y * pM2.YPlane.y + WPlane.z * pM2.ZPlane.y + WPlane.W * pM2.WPlane.y;
        pOut.WPlane.z = WPlane.x * pM2.XPlane.z + WPlane.y * pM2.YPlane.z + WPlane.z * pM2.ZPlane.z + WPlane.W * pM2.WPlane.z;
        pOut.WPlane.W = WPlane.x * pM2.XPlane.W + WPlane.y * pM2.YPlane.W + WPlane.z * pM2.ZPlane.W + WPlane.W * pM2.WPlane.W;
        return pOut;
    }
};
struct alignas(16) FTransform
{
    struct FQuat                                       Rotation;                                                 // 0x0000(0x0010) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    struct Vector3                                     Translation;                                              // 0x0010(0x000C) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    unsigned char                                      UnknownData00[0x4];                                       // 0x001C(0x0004) MISSED OFFSET
    struct Vector3                                     Scale3D;                                                  // 0x0020(0x000C) (Edit, BlueprintVisible, SaveGame, IsPlainOldData)
    unsigned char                                      UnknownData01[0x4];                                       // 0x002C(0x0004) MISSED OFFSET

    FMatrix ToMatrixWithScale()
    {
        FMatrix m;
        m.WPlane.x = Translation.x;
        m.WPlane.y = Translation.y;
        m.WPlane.z = Translation.z;

        float x2 = Rotation.X + Rotation.X;
        float y2 = Rotation.Y + Rotation.Y;
        float z2 = Rotation.Z + Rotation.Z;

        float xx2 = Rotation.X * x2;
        float yy2 = Rotation.Y * y2;
        float zz2 = Rotation.Z * z2;
        m.XPlane.x = (1.0f - (yy2 + zz2)) * Scale3D.x;
        m.YPlane.y = (1.0f - (xx2 + zz2)) * Scale3D.x;
        m.ZPlane.z = (1.0f - (xx2 + yy2)) * Scale3D.z;

        float yz2 = Rotation.Y * z2;
        float wx2 = Rotation.W * x2;
        m.ZPlane.y = (yz2 - wx2) * Scale3D.z;
        m.YPlane.z = (yz2 + wx2) * Scale3D.y;

        float xy2 = Rotation.X * y2;
        float wz2 = Rotation.W * z2;
        m.YPlane.x = (xy2 - wz2) * Scale3D.y;
        m.XPlane.y = (xy2 + wz2) * Scale3D.x;

        float xz2 = Rotation.X * z2;
        float wy2 = Rotation.W * y2;
        m.ZPlane.x = (xz2 + wy2) * Scale3D.z;
        m.XPlane.z = (xz2 - wy2) * Scale3D.x;

        m.XPlane.W = 0.0f;
        m.YPlane.W = 0.0f;
        m.ZPlane.W = 0.0f;
        m.WPlane.W = 1.0f;

        return m;
    }
};

static FMatrix ToMatrix(Vector3 rot)
{
    Vector3 origin = Vector3{};
    float radPitch = (rot.x * float(M_PI) / 180.f);
    float radYaw = (rot.y * float(M_PI) / 180.f);
    float radRoll = (rot.z * float(M_PI) / 180.f);

    float SP = sinf(radPitch);
    float CP = cosf(radPitch);
    float SY = sinf(radYaw);
    float CY = cosf(radYaw);
    float SR = sinf(radRoll);
    float CR = cosf(radRoll);

    FMatrix matrix;
    matrix.XPlane.x = CP * CY;
    matrix.XPlane.y = CP * SY;
    matrix.XPlane.z = SP;
    matrix.XPlane.W = 0.f;

    matrix.YPlane.x = SR * SP * CY - CR * SY;
    matrix.YPlane.y = SR * SP * SY + CR * CY;
    matrix.YPlane.z = -SR * CP;
    matrix.YPlane.W = 0.f;

    matrix.ZPlane.x = -(CR * SP * CY + SR * SY);
    matrix.ZPlane.y = CY * SR - CR * SP * SY;
    matrix.ZPlane.z = CR * CP;
    matrix.ZPlane.W = 0.f;

    matrix.WPlane.x = origin.x;
    matrix.WPlane.y = origin.y;
    matrix.WPlane.z = origin.z;
    matrix.WPlane.W = 1.f;

    return matrix;
}

typedef struct _ValEntity
{
    uintptr_t Addr;
    uintptr_t Mesh;
    int Type;
   // int ObjectID;

}ValEntity;
vector<ValEntity> entityList;


uintptr_t ULevel;
uintptr_t GameInstance;
uintptr_t LocalPlayer;
uintptr_t AcknowledgedPawn;
uintptr_t LocalPlayerState;
uint64_t PlayerController = 0;
uint64_t CameraCache = 0;

class CameraStruct
{
public:
    Vector3 Position; //0x11B0 
    Vector3 Rotation; //0x11BC 
    float Fov; //0x11C8 
}; //Size=0x11CC
//CameraStruct GetCameraCache()
//{
//    CameraStruct Camera = read<CameraStruct>(CameraCache + Offsets::oCameraCache);
//    return Camera;
//}


template <typename T>
T read(uintptr_t address)
{
    T buffer{ };
    if(ReadProcessMemory(GetCurrentProcess(), (LPVOID)address, &buffer, sizeof(T), 0))   
        return buffer;
}

template<typename T>
bool write(uintptr_t address, T* buffer, SIZE_T sizeh)
{
    if (address > 0x7FFFFFFFFFFF || address < 1) return 0;
    WriteProcessMemory(GetCurrentProcess(), (LPVOID)address, buffer, sizeh, 0);
}

CameraStruct GetCameraCache()
{
    auto Camera = read<CameraStruct>(CameraCache + Offsets::oCameraCache);
    return Camera;
}
D3DMATRIX to_matrix(const Vector3& rotation, const Vector3& origin) {
    const auto pitch = rotation.x * float(3.14159265358979323846f) / 180.f;
    const auto yaw = rotation.y * float(3.14159265358979323846f) / 180.f;
    const auto roll = rotation.z * float(3.14159265358979323846f) / 180.f;

    const auto SP = sinf(pitch);
    const auto CP = cosf(pitch);
    const auto SY = sinf(yaw);
    const auto CY = cosf(yaw);
    const auto SR = sinf(roll);
    const auto CR = cosf(roll);

    D3DMATRIX matrix;
    matrix._11 = CP * CY;
    matrix._12 = CP * SY;
    matrix._13 = SP;
    matrix._14 = 0.f;

    matrix._21 = SR * SP * CY - CR * SY;
    matrix._22 = SR * SP * SY + CR * CY;
    matrix._23 = -SR * CP;
    matrix._24 = 0.f;

    matrix._31 = -(CR * SP * CY + SR * SY);
    matrix._32 = CY * SR - CR * SP * SY;
    matrix._33 = CR * CP;
    matrix._34 = 0.f;

    matrix._41 = origin.x;
    matrix._42 = origin.y;
    matrix._43 = origin.z;
    matrix._44 = 1.f;

    return matrix;
}



__forceinline __int64 decrypt_uworld(const uint32_t key, const uintptr_t* state)
{

    unsigned __int64 v19; // r11
    unsigned __int64 v20; // r8
    unsigned __int64 v21; // r9
    unsigned int v22; // er10
    unsigned __int64 v23; // rcx
    unsigned __int64 v24; // rdx
    unsigned __int64 v25; // rcx
    int v26; // ebx
    unsigned int v27; // ecx
    __int64 v28; // rax
    unsigned __int64 v29; // r8
    unsigned __int64 v30; // r8
    unsigned __int64 v31; // rcx
    unsigned __int64 v32; // rdx
    unsigned __int64 v33; // rcx

    v19 = 2685821657736338717i64
        * ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))
        % 7;
    v20 = state[v19];
    v21 = (2685821657736338717i64
        * ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
    v22 = (unsigned int)v19 % 7;
    if (!((unsigned int)v19 % 7))
    {
        v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20
            - (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
        v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
        v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
        v20 = rol8((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
    LABEL_26:
        v26 = 2 * v19;
        goto LABEL_27;
    }
    if (v22 != 1)
        goto LABEL_26;
    v26 = 2 * v19;
    v20 = rol8(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
LABEL_27:
    v27 = v26 + v21;
    if (v22 == 2)
        v20 = ~(v20 - v27);
    switch (v22)
    {
    case 3u:
        v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
        v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
        break;
    case 4u:
        v29 = ror8(v20, (unsigned __int8)(v27 % 0x3F) + 1);
        v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
        break;
    case 5u:
        v30 = ror8(v20, (unsigned __int8)(v27 % 0x3F) + 1);
        v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
        v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
        v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
        v20 = rol8((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
        break;
    case 6u:
        v20 = ~v20 - (unsigned int)(v21 + v19);
        break;
    }
    return v20 ^ (unsigned int)key;
}

uint64_t valBase = (uintptr_t)GetModuleHandleA(0);
uint64_t UWorld = 0;


uint64_t ReadWorld()
{
    __try
    {
       // std::printf("valBase %p \n", valBase);
        uint64_t key = read<uint64_t>(valBase + 0x86DA038);
        //std::printf("key %p \n", key);

#pragma pack(push, 1)
        struct State
        {
            uint64_t Keys[7];
        };
#pragma pack(pop)
        const auto state = read<State>(valBase + 0x86DA000);
       // std::printf("state %p \n", state.Keys);

        if (key != 0)
            return read<uint64_t>(decrypt_uworld(key, (uint64_t*)&state));
    }
    __except (1) {}
}
//
//Vector3 WorldToScreen(Vector3& world_loc) {
//    auto CamCache = GetCameraCache();
//    const auto matrix = to_matrix(CamCache.Rotation, Vector3());
//    const auto axisx = Vector3(matrix.m[0][0], matrix.m[0][1], matrix.m[0][2]);
//    const auto axisy = Vector3(matrix.m[1][0], matrix.m[1][1], matrix.m[1][2]);
//    const auto axisz = Vector3(matrix.m[2][0], matrix.m[2][1], matrix.m[2][2]);
//
//    const auto delta = world_loc - CamCache.Position;
//    auto transformed = Vector3(delta.Dot(axisy), delta.Dot(axisz), delta.Dot(axisx));
//
//    if (transformed.z < 0.001f)
//        transformed.z = 0.001f;
//
//    const auto fov_angle = CamCache.Fov;
//    const float center = Width / 2.f;
//    const float centery = Height / 2.f;
//
//    return Vector3(center + transformed.x * (center / static_cast<float>(tan(fov_angle * M_PI / 360))) / transformed.z, centery - transformed.y * (center / static_cast<float>(tan(fov_angle * M_PI / 360))) / transformed.z, 0.f);
//}


FTransform GetBoneIndex(DWORD_PTR mesh, int index)
{
    DWORD_PTR bonearray = read<DWORD_PTR>(mesh + Offsets::StaticMesh);// 5A0 / 590
    if (!bonearray || bonearray == NULL)
        bonearray = read<DWORD_PTR>(mesh + Offsets::StaticMesh_Cached);
    return read<FTransform>(bonearray + (index * 0x30));
}

Vector3 GetBoneWithRotation(DWORD_PTR mesh, int id)
{
    FTransform Bone = GetBoneIndex(mesh, id);
    FTransform ComponentToWorld = read<FTransform>(mesh + Offsets::ComponentToWorld);
    FMatrix Matrix = Bone.ToMatrixWithScale() * ComponentToWorld.ToMatrixWithScale();
    return Vector3{ Matrix.WPlane.x, Matrix.WPlane.y, Matrix.WPlane.z };
}

```

`CyberVal/xor.hpp`:

```hpp

#pragma once

template <int X> struct EnsureCompileTime {
	enum : int {
		Value = X
	};
};
#define Seed ((__TIME__[7] - '0') * 1  + (__TIME__[6] - '0') * 10  + \
	(__TIME__[4] - '0') * 60 + (__TIME__[3] - '0') * 600 + \
	(__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)

__forceinline constexpr int LinearCongruentGenerator(int Rounds) {
	return 2013904223 + 2664525 * ((Rounds > 0) ? LinearCongruentGenerator(Rounds - 1) : Seed & 0xFFFFFFFF);
}
#define Random() EnsureCompileTime<LinearCongruentGenerator(15)>::Value 
#define RandomNumber(Min, Max) (Min + (Random() % (Max - Min + 1)))
template <int... Pack> struct IndexList {};
template <typename IndexList, int Right> struct Append;
template <int... Left, int Right> struct Append<IndexList<Left...>, Right> {
	typedef IndexList<Left..., Right> Result;
};
template <int N> struct ConstructIndexList {
	typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <> struct ConstructIndexList<0> {
	typedef IndexList<> Result;
};
const char XORKEY_A = static_cast<char>(0x51);
const wchar_t XORKEY_W = static_cast<wchar_t>(0x331);
__declspec(noinline)  constexpr char EncryptCharacterA(const char Character, int Index) {
	return Character ^ (XORKEY_A + Index);
}
template <typename IndexList> class CingA;
template <int... Index> class CingA<IndexList<Index...> > {
private:
	char Value[sizeof...(Index) + 1];
public:
	__forceinline constexpr CingA(const char* const String)
		: Value{ EncryptCharacterA(String[Index], Index)... } {}

	__forceinline char* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEY_A + t);
		}
		Value[sizeof...(Index)] = '\0';
		return Value;
	}

	__forceinline char* get() {
		return Value;
	}
};
__declspec(noinline) constexpr wchar_t EncryptCharacterW(const wchar_t Character, int Index) {
	return Character ^ (XORKEY_W + Index);
}
template <typename IndexList> class CingW;
template <int... Index> class CingW<IndexList<Index...> > {
private:
	wchar_t Value[sizeof...(Index) + 1];
public:
	__forceinline constexpr CingW(const wchar_t* const String)
		: Value{ EncryptCharacterW(String[Index], Index)... } {}

	__forceinline wchar_t* decrypt() {
		for (int t = 0; t < sizeof...(Index); t++) {
			Value[t] = Value[t] ^ (XORKEY_W + t);
		}
		Value[sizeof...(Index)] = '\0\0';
		return Value;
	}

	__forceinline wchar_t* get() {
		return Value;
	}
};

#define xorstr_( String ) ( CingA<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )  
#define wxorstr_( String ) ( CingW<ConstructIndexList<sizeof( String ) - 1>::Result>( String ).decrypt() )  

```

`README.md`:

```md
# Internal-Valorant-Cheat
This is a free release of an Internal Valorant Cheat!

![image](https://user-images.githubusercontent.com/98547494/151431758-9f5cb5e1-c038-4ece-85df-30d995c0f1dd.png)

```