Project Path: arc_gmh5225_AtomPePacker_0xq35aqv

Source Tree:

```txt
arc_gmh5225_AtomPePacker_0xq35aqv
├── DllPP64Stub
│   ├── Crt.h
│   ├── Debug.h
│   ├── DllPP64Stub.vcxproj
│   ├── DllPP64Stub.vcxproj.filters
│   ├── DllPP64Stub.vcxproj.user
│   ├── General.c
│   ├── IatCamouflage.h
│   ├── Structs.h
│   ├── Syscalls.h
│   ├── Syscalls.lib
│   ├── Unpack.c
│   ├── Utils.c
│   ├── Utils.h
│   ├── common.h
│   ├── decompress.h
│   ├── easylzma.c
│   ├── easylzma.h
│   ├── easylzma_s.lib
│   └── main.c
├── Helper
│   └── Hasher
│       ├── Hasher.c
│       ├── Hasher.vcxproj
│       ├── Hasher.vcxproj.filters
│       └── Hasher.vcxproj.user
├── LICENSE
├── PP64Stub
│   ├── Crt.h
│   ├── Debug.h
│   ├── General.c
│   ├── IatCamouflage.h
│   ├── PP64Stub.vcxproj
│   ├── PP64Stub.vcxproj.filters
│   ├── PP64Stub.vcxproj.user
│   ├── Structs.h
│   ├── Syscalls.h
│   ├── Syscalls.lib
│   ├── Unpack.c
│   ├── Utils.c
│   ├── Utils.h
│   ├── common.h
│   ├── decompress.h
│   ├── easylzma.c
│   ├── easylzma.h
│   ├── easylzma_s.lib
│   └── main.c
├── PePacker64
│   ├── Header.h
│   ├── NewSection.c
│   ├── PePacker.c
│   ├── PePacker64.vcxproj
│   ├── PePacker64.vcxproj.filters
│   ├── PePacker64.vcxproj.user
│   ├── common.h
│   ├── compress.h
│   ├── decompress.h
│   ├── easylzma.c
│   ├── easylzma.h
│   └── easylzma_s.lib
├── PePacker64.sln
├── README.md
└── Test
    ├── ArgsTest
    │   ├── ArgsTest.c
    │   ├── ArgsTest.vcxproj
    │   ├── ArgsTest.vcxproj.filters
    │   └── ArgsTest.vcxproj.user
    └── TlsTest
        ├── TlsTest.c
        ├── TlsTest.vcxproj
        ├── TlsTest.vcxproj.filters
        └── TlsTest.vcxproj.user

```

`DllPP64Stub/Crt.h`:

```h
/*

    since im using easylzma library, which is using some crt functions, i had to replace them here, using custom code, so yeah ...
    thats what these are :p

    ofc some of the code is from vx-api (for the credits)
*/

#pragma once
#include <Windows.h>


PVOID _malloc(SIZE_T Size)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);
}

BOOL _free(PVOID ptr)
{
    return HeapFree(GetProcessHeap(), 0, ptr);
}


PVOID _realloc(PVOID ptr, SIZE_T new_size)
{

    byte* d = NULL; 
    byte* s = NULL;
    size_t size = NULL;

    if (new_size == NULL)
        return NULL;

    if (ptr == NULL)
        return _malloc(new_size);


    size_t old_size = HeapSize(GetProcessHeap(), 0, ptr);

    if (old_size == new_size) {
        return ptr;
    }
    
    // allocating new ptr and moving data to it (from ptr)
    void* new_ptr = _malloc(new_size);

    d = (byte*)new_ptr;
    s = (byte*)ptr;
    size = old_size;
    for (volatile int i = 0; i < size; i++) {
        ((BYTE*)d)[i] = ((BYTE*)s)[i];
    }

    // setting ptr to 0
    PULONG Dest = (PULONG)ptr;
    size = old_size / sizeof(ULONG);
    while (size > 0){
        *Dest = 0;
        Dest++;
        size--;
    }

    //freeing ptr
    _free(ptr);

    return new_ptr;
}



//       REPLACING MEMSET
extern void* __cdecl memset(void*, int, size_t);
#pragma intrinsic(memset)
#pragma function(memset)
void* __cdecl memset(void* pTarget, int value, size_t cbTarget) {
	unsigned char* p = (unsigned char*)pTarget;
	while (cbTarget-- > 0) {
		*p++ = (unsigned char)value;
	}
	return pTarget;
}

//      REPLACING MEMMOVE
extern void* __cdecl memmove(void* destination, const void* source, size_t num);
#pragma intrinsic(memmove)
#pragma function(memmove)
void* __cdecl memmove(void* destination, const void* source, size_t num) {
    for (volatile int i = 0; i < num; i++) {
        ((BYTE*)destination)[i] = ((BYTE*)source)[i];
    }
    return destination;
}

//      REPLACING FREE
extern void __cdecl free(void*);
#pragma intrinsic(free)
#pragma function(free)
void __cdecl free(void* pAddress) {
	_free(pAddress);
}

//      REPLACING MALLOC
extern void* __cdecl malloc(size_t);
#pragma intrinsic(malloc)
#pragma function(malloc)
void* __cdecl malloc(size_t Size) {
	return _malloc(Size);
}

//      REPLACING REALLOC
extern void* __cdecl realloc(void* ptr, size_t new_size);
#pragma intrinsic(realloc)
#pragma function(realloc)
void* __cdecl realloc(void* ptr, size_t new_size) {
    return _realloc(ptr, new_size);
}



//      REPLACING MEMCPY
extern void* __cdecl memcpy(void*, void const*, size_t);
#pragma intrinsic(memcpy)
#pragma function(memcpy)
void* __cdecl memcpy(void* dst, void const* src, size_t size) {
    for (volatile int i = 0; i < size; i++) {
        ((BYTE*)dst)[i] = ((BYTE*)src)[i];
    }
    return dst;
}


//      REPLACING STRNCMP
extern int __cdecl strncmp(char const*, char const*, size_t);
#pragma intrinsic(strncmp)
#pragma function(strncmp)
int __cdecl strncmp(char const* str1, char const* str2, size_t size) {

    for (; *str1 == *str2; str1++, str2++)
    {
        if (*str1 == '\0')
            return 0;
    }

    return ((*(LPCSTR)str1 < *(LPCSTR)str2) ? -1 : +1);
}


```

`DllPP64Stub/Debug.h`:

```h
#pragma once

//#define DEBUG


#ifndef DEBUG_H
#define DEBUG_H

#include <Windows.h>


#ifdef DEBUG



HANDLE GetConsole();

#define PRINT( STR, ... )                                                                   \
    if (1) {                                                                                \
        LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );         \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfW( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleW( GetConsole(), buf, len, NULL, NULL );			                    \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  


#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetConsole(), buf, len, NULL, NULL );                                \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  





#endif // DEBUG






#endif // !DEBUG_H

```

`DllPP64Stub/DllPP64Stub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ae237528-7f07-43b2-a315-c6b43448e5e6}</ProjectGuid>
    <RootNamespace>DllPP64Stub</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DLLPP64STUB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DLLPP64STUB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DLLPP64STUB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>easylzma_s.lib;Syscalls.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DLLPP64STUB_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>easylzma_s.lib;Syscalls.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="easylzma.c" />
    <ClCompile Include="General.c" />
    <ClCompile Include="Unpack.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="Crt.h" />
    <ClInclude Include="Debug.h" />
    <ClInclude Include="decompress.h" />
    <ClInclude Include="easylzma.h" />
    <ClInclude Include="IatCamouflage.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Syscalls.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DllPP64Stub/DllPP64Stub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="easylzma">
      <UniqueIdentifier>{039edeba-202d-47f9-a685-a6304147f665}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="easylzma.c">
      <Filter>easylzma</Filter>
    </ClCompile>
    <ClCompile Include="General.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Unpack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="easylzma.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="decompress.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Crt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IatCamouflage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="Debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DllPP64Stub/DllPP64Stub.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`DllPP64Stub/General.c`:

```c
/*

    contains bunch of helper functions to replace the crt version 
    (vx-api and others for the credits ...)
*/

#include <Windows.h>

#include "Structs.h"
#include "Utils.h"


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/rad9800/TamperingSyscalls/blob/master/TamperingSyscalls/entry.cpp#L329
VOID _RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source){

	if ((target->Buffer = (PWSTR)source)){

		unsigned int length = wcslen(source) * sizeof(WCHAR);
		if (length > 0xfffc)
			length = 0xfffc;

		target->Length = length;
		target->MaximumLength = target->Length + sizeof(WCHAR);
	}

	else target->Length = target->MaximumLength = 0;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L482
wchar_t* _strcatW(wchar_t* dest, const wchar_t* src){

    if ((dest == NULL) || (src == NULL))
        return dest;

    while (*dest != 0)
        dest++;

    while (*src != 0) {
        *dest = *src;
        dest++;
        src++;
    }

    *dest = 0;
    return dest;
}

char* _strcatA (char* dest, const char* src) {
    
    if ((dest == NULL) || (src == NULL))
        return dest;

    while (*dest != 0)
        dest++;

    while (*src != 0) {
        *dest = *src;
        dest++;
        src++;
    }

    *dest = 0;
    return dest;
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L461
wchar_t* _strcpyW(wchar_t* dest, const wchar_t* src){

    wchar_t* p;

    if ((dest == NULL) || (src == NULL))
        return dest;

    if (dest == src)
        return dest;

    p = dest;
    while (*src != 0) {
        *p = *src;
        p++;
        src++;
    }

    *p = 0;
    return dest;
}


char* _strcpyA(char* dest, const char* src) {

    char* p;

    if ((dest == NULL) || (src == NULL))
        return dest;

    if (dest == src)
        return dest;

    p = dest;
    while (*src != 0) {
        *p = *src;
        p++;
        src++;
    }

    *p = 0;
    return dest;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L500
PVOID _memcpy(void* dst, const void* src, SIZE_T count) {
    for (volatile int i = 0; i < count; i++) {
        ((BYTE*)dst)[i] = ((BYTE*)src)[i];
    }
    return dst;
}

// https://github.com/vxunderground/VX-API/blob/main/VX-API/ZeroMemoryEx.cpp
VOID _ZeroMemory(PVOID Destination, SIZE_T Size){

    PULONG Dest = (PULONG)Destination;
    SIZE_T Count = Size / sizeof(ULONG);

    while (Count > 0)
    {
        *Dest = 0;
        Dest++;
        Count--;
    }

    return;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


CHAR _ToUpper (CHAR c) {
    
    if (c >= 'a' && c <= 'z') {
        return c - 'a' + 'A';
    }
    
    return c;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/StringLength.cpp
SIZE_T _StrlenA(LPCSTR String){

    LPCSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

SIZE_T _StrlenW(LPCWSTR String){

    LPCWSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringRotr32.cpp
UINT32 _HashStringRotr32SubA(UINT32 Value, UINT Count)
{

    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

DWORD _HashStringRotr32A(PCHAR String)
{

    DWORD Value = 0;

    for (INT Index = 0; Index < _StrlenA(String); Index++)
        Value = String[Index] + _HashStringRotr32SubA(Value, SEED);

    return Value;
}


UINT32 _HashStringRotr32SubW(UINT32 Value, UINT Count)
{
    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

DWORD _HashStringRotr32W(PWCHAR String)
{
    DWORD Value = 0;

    for (INT Index = 0; Index < _StrlenW(String); Index++)
        Value = String[Index] + _HashStringRotr32SubW(Value, SEED);

    return Value;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/Cracked5pider/KaynLdr/blob/main/KaynLdr/src/Win32.c#L39
UINT32 _CopyDotStr(PCHAR String){

    for (UINT32 i = 0; i < _StrlenA(String); i++)
    {
        if (String[i] == '.')
            return i;
    }
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/CharStringToWCharString.cpp

SIZE_T _CharToWchar (PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed){

    INT Length = (INT)MaximumAllowed;
    
    while (--Length >= 0){
        if (!(*Destination++ = *Source++))
            return MaximumAllowed - Length - 1;
    }

    return MaximumAllowed - Length;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```

`DllPP64Stub/IatCamouflage.h`:

```h
/*
	since this stub is using api hashing & removing crt functions, the low number of imported functions is pretty much a ioc
	so i had to come up with a list of non-blacklisted api's that can change the modules & functions used (although not executed)

*/

#pragma once
#include <Windows.h>
#include <synchapi.h>



LPVOID FunctionToReturnSomething(int i, int* pi, int* px, int* py) {
	int x, y;
	x = y = i++;
	y += x * i;
	x = i + 100;
	i = i + i / 2;
	*pi = i;
	*px = x;
	*py = y;
	return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024);
}



BOOL CamouflageImports(int i) {
	int x, y;
	x = y = i++;
	y += x * i;
	x = i + 100;
	i = i + i / 2;

	LPVOID p = FunctionToReturnSomething(i, &i, &x, &y);
	

	//i : 577 || x : 485 || y : 148224
	//PRINT(L"[i] i : %d || x : %d || y : %d \n", i, x, y);

	if (i == 577) {
		x += 1;
		x -= 1;
		if (y * 2 == y + 148224) {
			if (GetLastError() == ERROR_IPSEC_IKE_SECLOADFAIL) {
				// we dont care about anything here, we just want these to be imported to our iat
				ReleaseSRWLockExclusive(NULL);
				ReleaseSRWLockShared(NULL);
				SetCriticalSectionSpinCount(NULL, NULL);
				TryAcquireSRWLockExclusive(NULL);
				WakeAllConditionVariable(NULL);
				SetUnhandledExceptionFilter(NULL);
				UnhandledExceptionFilter(NULL);
				CheckMenuItem(NULL, NULL, NULL);
				GetMenu(NULL);
				GetSystemMenu(NULL, NULL);
				GetMenuItemID(NULL, NULL);
				EnableMenuItem(NULL, NULL, NULL);
				MessageBeep(NULL);
				GetLastError();
				MessageBoxW(NULL, NULL, NULL, NULL);
				MessageBoxA(NULL, NULL, NULL, NULL);
				UpdateWindow(NULL);
				GetWindowContextHelpId(NULL);
			}
			else {
				HeapFree(GetProcessHeap(), 0, p);
			}
		}
	}


	return TRUE;

}
```

`DllPP64Stub/Structs.h`:

```h
#pragma once

#include <Windows.h>


#ifndef STRUCTS
#define STRUCTS


#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;


#define InitializeObjectAttributes( p, n, a, r, s ) {	\
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _BASE_RELOCATION_ENTRY {
	WORD Offset : 12;
	WORD Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;


typedef PVOID PACTIVATION_CONTEXT;

typedef struct _PEB_LDR_DATA {
    ULONG                   Length;
    ULONG                   Initialized;
    PVOID                   SsHandle;
    LIST_ENTRY              InLoadOrderModuleList;
    LIST_ENTRY              InMemoryOrderModuleList;
    LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;



typedef struct _CURDIR{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, * PCURDIR;

#define RTL_MAX_DRIVE_LETTERS 32

typedef struct _RTL_DRIVE_LETTER_CURDIR{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;


typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    WORD LoadCount;
    WORD TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    union
    {
        UCHAR BitField;
        struct
        {
            UCHAR ImageUsesLargePages : 1;
            UCHAR IsProtectedProcess : 1;
            UCHAR IsImageDynamicallyRelocated : 1;
            UCHAR SkipPatchingUser32Forwarders : 1;
            UCHAR IsPackagedProcess : 1;
            UCHAR IsAppContainer : 1;
            UCHAR IsProtectedProcessLight : 1;
            UCHAR IsLongPathAwareProcess : 1;
        };
    };
    UCHAR Padding0[4];
    VOID* Mutant;
    VOID* ImageBaseAddress;
    struct _PEB_LDR_DATA* Ldr;
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
    VOID* SubSystemData;
    VOID* ProcessHeap;
    struct _RTL_CRITICAL_SECTION* FastPebLock;
    union _SLIST_HEADER* volatile AtlThunkSListPtr;
    VOID* IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1;
            ULONG ReservedBits0 : 24;
        };
    };
    UCHAR Padding1[4];
    union
    {
        VOID* KernelCallbackTable;
        VOID* UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    VOID* ApiSetMap;
    ULONG TlsExpansionCounter;
    UCHAR Padding2[4];
    VOID* TlsBitmap;
    ULONG TlsBitmapBits[2];
    VOID* ReadOnlySharedMemoryBase;
    VOID* SharedData;
    VOID** ReadOnlyStaticServerData;
    VOID* AnsiCodePageData;
    VOID* OemCodePageData;
    VOID* UnicodeCaseTableData;
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;
    union _LARGE_INTEGER CriticalSectionTimeout;
    ULONGLONG HeapSegmentReserve;
    ULONGLONG HeapSegmentCommit;
    ULONGLONG HeapDeCommitTotalFreeThreshold;
    ULONGLONG HeapDeCommitFreeBlockThreshold;
    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    VOID** ProcessHeaps;
    VOID* GdiSharedHandleTable;
    VOID* ProcessStarterHelper;
    ULONG GdiDCAttributeList;
    UCHAR Padding3[4];
    struct _RTL_CRITICAL_SECTION* LoaderLock;
    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    UCHAR Padding4[4];
    ULONGLONG ActiveProcessAffinityMask;
    ULONG GdiHandleBuffer[60];
    VOID(*PostProcessInitRoutine)();
    VOID* TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];
    ULONG SessionId;
    UCHAR Padding5[4];
    union _ULARGE_INTEGER AppCompatFlags;
    union _ULARGE_INTEGER AppCompatFlagsUser;
    VOID* pShimData;
    VOID* AppCompatInfo;
    struct _UNICODE_STRING CSDVersion;
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;
    ULONGLONG MinimumStackCommit;
    struct _FLS_CALLBACK_INFO* FlsCallback;
    struct _LIST_ENTRY FlsListHead;
    VOID* FlsBitmap;
    ULONG FlsBitmapBits[4];
    ULONG FlsHighIndex;
    VOID* WerRegistrationData;
    VOID* WerShipAssertPtr;
    VOID* pUnused;
    VOID* pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    UCHAR Padding6[4];
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    ULONGLONG TppWorkerpListLock;
    struct _LIST_ENTRY TppWorkerpList;
    VOID* WaitOnAddressHashTable[128];
    VOID* TelemetryCoverageHeader;
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags;
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA* LeapSecondData;
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
} PEB, * PPEB;



#endif // !STRUCTS

```

`DllPP64Stub/Syscalls.h`:

```h
/*
	this file is from my syscallslib repo
*/

#pragma once
#include <Windows.h>



#ifndef SYSCALLS
#define SYSCALLS

#include "Structs.h"

#define EXTERN extern


typedef struct _HashStruct {
	DWORD NtAllocateVirtualMemory_Hash;
	DWORD NtProtectVirtualMemory_Hash;

	DWORD NtCreateSection_Hash;
	DWORD NtOpenSection_Hash;
	DWORD NtMapViewOfSection_Hash;
	DWORD NtUnmapViewOfSection_Hash;

	DWORD NtClose_Hash;

}HashStruct, * PHashStruct;



EXTERN BOOL
InitializeStruct(
	IN			INT			Seed,									// INPUT : Seed Of The Rotr32 Hashing algo
	IN			PHashStruct PStruct									// INPUT : pointer to a struct of type 'HashStruct' that will initialize the data 
);

EXTERN PVOID
NtAllocateVirtualMemory(
	IN  OPTIONAL  HANDLE	ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL  PVOID		BaseAddress,							// INPUT  : NULL by default  
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	IN  OPTIONAL  ULONG		AllocationType,							// INPUT  : MEM_COMMIT | MEM_RESERVE by default
	IN  OPTIONAL  ULONG		Protect,								// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

// calling the default NtAllocateVirtualMemory | u can do such thing to the others ...
EXTERN PVOID
NtAllocateVirtualMemory2(
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN ULONG
NtProtectVirtualMemory(
	IN  OPTIONAL HANDLE		ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN			 PVOID		BaseAddress,							// INPUT  : can't be NULL
	IN			 SIZE_T		NumberOfBytesToProtect,					// INPUT  : can't be NULL
	IN			 ULONG		NewAccessProtection,					// INPUT  : can't be NULL
	OUT OPTIONAL PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN HANDLE
NtCreateSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN	OPTIONAL	POBJECT_ATTRIBUTES	ObjectAttributes,			// INPUT  : NULL by default
	IN				SIZE_T				NumberOfBytes,				// INPUT  : can't be NULL
	IN	OPTIONAL	ULONG               SectionPageProtection,		// INPUT  : PAGE_READWRITE be default
	IN	OPTIONAL	ULONG               AllocationAttributes,		// INPUT  : SEC_COMMIT by default
	IN	OPTIONAL	HANDLE              FileHandle,					// INPUT  : NULL by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);



EXTERN HANDLE
NtOpenSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN				POBJECT_ATTRIBUTES  ObjectAttributes,			// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);

EXTERN PVOID
NtMapViewOfSection(
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL	PVOID				BaseAddress,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               AllocationType,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               Protect,					// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);


EXTERN VOID
NtUnmapViewOfSection(
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  			PVOID				BaseAddress,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);



EXTERN VOID
NtClose(
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);



#endif // !SYSCALLS

```

`DllPP64Stub/Unpack.c`:

```c
#include <Windows.h>


#include "Structs.h"
#include "Utils.h"
#include "Syscalls.h"
#include "Debug.h"


typedef struct _InPeConfig {

	ULONG_PTR				pPeAddress;
	SIZE_T					sPeSize;

	PIMAGE_DOS_HEADER		pDosHdr;
	PIMAGE_NT_HEADERS		pNtHdr;


	PIMAGE_DATA_DIRECTORY	pEIDataDir;		//IMAGE_DIRECTORY_ENTRY_IMPORT
	PIMAGE_DATA_DIRECTORY	pTLSDataDir;	//IMAGE_DIRECTORY_ENTRY_TLS
	PIMAGE_DATA_DIRECTORY	pEBDataDir;		//IMAGE_DIRECTORY_ENTRY_BASERELOC
	PIMAGE_DATA_DIRECTORY	pEHDataDir;		//IMAGE_DIRECTORY_ENTRY_EXCEPTION

	PIMAGE_SECTION_HEADER	pSecHdr;

} InPeConfig, * PInPeConfig;





BOOL _InitPeStruct(PInPeConfig _Pe, PVOID pPeAddress, SIZE_T sPeSize) {

	// check input
	if (pPeAddress == NULL || sPeSize == NULL) {
		return FALSE;
	}

	// filling up the struct
	_Pe->pPeAddress = pPeAddress;
	_Pe->sPeSize = sPeSize;
	_Pe->pDosHdr = (PIMAGE_DOS_HEADER)pPeAddress;
	// dos hdr check
	if (_Pe->pDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}
	_Pe->pNtHdr = (PIMAGE_NT_HEADERS)((PBYTE)pPeAddress + _Pe->pDosHdr->e_lfanew);
	// nt hdr check
	if (_Pe->pNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	_Pe->pEIDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	_Pe->pTLSDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	
	_Pe->pEBDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	_Pe->pEHDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];

	_Pe->pSecHdr = (PIMAGE_SECTION_HEADER)((SIZE_T)_Pe->pNtHdr + sizeof(IMAGE_NT_HEADERS));

	if (_Pe->pDosHdr == NULL	|| _Pe->pNtHdr == NULL		||
		_Pe->pEIDataDir == NULL || _Pe->pTLSDataDir == NULL || _Pe->pEBDataDir == NULL || _Pe->pEHDataDir  == NULL ||
		_Pe->pSecHdr == NULL	
		){
		
		return FALSE;
	}
	//done
	return TRUE;
}




BOOL _FixImportAddressTable(InPeConfig _Pe, ULONG_PTR pPeAddress) {

	PIMAGE_IMPORT_DESCRIPTOR	pImgDes = NULL;

	/*
	// this work as well, in case u want to ignore the 'InPeConfig' parameter:
	PIMAGE_DOS_HEADER			pDosHdr = (PIMAGE_DOS_HEADER)pPeAddress;
	PIMAGE_NT_HEADERS			pNtHdr = (PIMAGE_NT_HEADERS)(pPeAddress + pDosHdr->e_lfanew);
	PIMAGE_DATA_DIRECTORY		pEIDataDir = &pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];;
	*/


	// loop through the dlls
	for (SIZE_T i = 0; i < _Pe.pEIDataDir->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

		pImgDes = (IMAGE_IMPORT_DESCRIPTOR*)(_Pe.pEIDataDir->VirtualAddress + (ULONG_PTR)pPeAddress + i);

		if (pImgDes->OriginalFirstThunk == NULL && pImgDes->FirstThunk == NULL) {
			break;
		}

		LPSTR		DllName		= (LPSTR)((ULONGLONG)pPeAddress + pImgDes->Name);
		ULONG_PTR	Head		= pImgDes->FirstThunk;
		ULONG_PTR	Next		= pImgDes->OriginalFirstThunk;
		SIZE_T		HeadSize	= 0;
		SIZE_T		NextSize	= 0;
		HMODULE		hModule		= LoadLibraryH(DllName);

		if (hModule == NULL) {
			return FALSE;
		}

		if (Next == NULL) {
			Next = pImgDes->FirstThunk;
		}
		
		// loop through functions inside the dll to import
		while (TRUE) {

			PIMAGE_THUNK_DATA			_1stThunk				= (IMAGE_THUNK_DATA*)(pPeAddress + HeadSize + Head);
			PIMAGE_THUNK_DATA			Orig1stThunk			= (IMAGE_THUNK_DATA*)(pPeAddress + NextSize + Next);
			PIMAGE_IMPORT_BY_NAME		FuncName				= NULL;
			ULONG_PTR					pFunction				= NULL;

			if (_1stThunk->u1.Function == NULL) {
				break;
			}

			// by ordinal
			if (Orig1stThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
				PIMAGE_DOS_HEADER		_dos;
				PIMAGE_NT_HEADERS		_nt;
				PIMAGE_EXPORT_DIRECTORY	_ExportDir;
				PDWORD					_FuncAddArray;
				
				_dos = (PIMAGE_DOS_HEADER)hModule;
				_nt = (PIMAGE_NT_HEADERS)(((ULONG_PTR)hModule) + _dos->e_lfanew);
				_ExportDir = (PIMAGE_EXPORT_DIRECTORY)(((ULONG_PTR)hModule) + _nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
				_FuncAddArray = (PDWORD)((ULONG_PTR)hModule + _ExportDir->AddressOfFunctions);
				
				pFunction = ((ULONG_PTR)hModule + _FuncAddArray[Orig1stThunk->u1.Ordinal]);

				//this work as well:
				//pFunction = (ULONG_PTR)GetProcAddress(hModule, (char*)(Orig1stThunk->u1.Ordinal & 0xFFFF));
			}
			// by name
			else {
				FuncName = (PIMAGE_IMPORT_BY_NAME)((SIZE_T)pPeAddress + Orig1stThunk->u1.AddressOfData);
				pFunction = (ULONG_PTR)GetProcAddressH(hModule, HASH(FuncName->Name));
				//this work as well:
				//pFunction = (ULONG_PTR)GetProcAddress(hModule, FuncName->Name);

			}

			if (pFunction == NULL) {
#ifdef DEBUG
				PRINTA("[!] Could Not Import !%s.%s \n", DllName, FuncName->Name);
#endif // DEBUG
				return FALSE;
			}

			_1stThunk->u1.Function = (ULONGLONG)pFunction;

			// next function
			HeadSize += sizeof(IMAGE_THUNK_DATA);
			NextSize += sizeof(IMAGE_THUNK_DATA);
			
		}
	}
	
	return TRUE;
}


// from https://github.com/Cracked5pider/KaynLdr/blob/main/KaynLdr/src/Win32.c#L139
// && https://github.com/abhisek/Pe-Loader-Sample/blob/master/src/PeLdr.cpp#L18

BOOL _ReallocationSupport(ULONG_PTR ActualAddress, ULONG_PTR PreferableAddress, PIMAGE_BASE_RELOCATION BaseRelocDir){

	PIMAGE_BASE_RELOCATION  pImageBR = BaseRelocDir;
	ULONG_PTR				OffsetIB = ActualAddress - PreferableAddress;
	PBASE_RELOCATION_ENTRY	Reloc	 = NULL;

	while (pImageBR->VirtualAddress != 0){

		Reloc = (PBASE_RELOCATION_ENTRY)(pImageBR + 1);

		while ((PBYTE)Reloc != (PBYTE)pImageBR + pImageBR->SizeOfBlock){
			
			switch (Reloc->Type) {
				case IMAGE_REL_BASED_DIR64:
					*((ULONG_PTR*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += OffsetIB;
					break;
				case IMAGE_REL_BASED_HIGHLOW:
					*((DWORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += (DWORD)OffsetIB;
					break;

				case IMAGE_REL_BASED_HIGH:
					*((WORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += HIWORD(OffsetIB);
					break;

				case IMAGE_REL_BASED_LOW:
					*((WORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += LOWORD(OffsetIB);
					break;

				case IMAGE_REL_BASED_ABSOLUTE:
					break;

				default:
#ifdef DEBUG
					PRINT(L"[!] Unknown relocation type: 0x%08x \n", Reloc->Offset);
#endif // DEBUG
					return FALSE;
			}

			Reloc++;
		}

		pImageBR = (PIMAGE_BASE_RELOCATION)Reloc;
	}

	return TRUE;
}





VOID UnpackAndRunEp(PVOID pPeAddress, SIZE_T sPeSize, BOOL RunPe) {
	
	InPeConfig				_Pe1		= { 0 };
	ULONG_PTR				pAddress	= NULL;


	if (!_InitPeStruct(&_Pe1, pPeAddress, sPeSize)) {
#ifdef DEBUG
		PRINT(L"[!] Could Not Initialize The Pe Struct (Unpack.c:231)\n");
#endif // DEBUG
		return;
	}

	NtUnmapViewOfSection(NULL, _Pe1.pNtHdr->OptionalHeader.ImageBase, NULL);
	
	
	pAddress = (ULONG_PTR)NtAllocateVirtualMemory(NULL, _Pe1.pNtHdr->OptionalHeader.ImageBase, _Pe1.pNtHdr->OptionalHeader.SizeOfImage, NULL, NULL, NULL);
	if (pAddress == NULL) {
		pAddress = (ULONG_PTR)NtAllocateVirtualMemory2(_Pe1.pNtHdr->OptionalHeader.SizeOfImage, NULL);
		if (pAddress == NULL) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Allocate A Vaild Base Address For The Pe (Unpack.c:244)\n");
#endif // DEBUG
			return;
		}
	}

#ifdef DEBUG
	PRINT(L"[i] Preferable Address : 0x%p \n", _Pe1.pNtHdr->OptionalHeader.ImageBase);
	PRINT(L"[i] Actuall Allocated Address : 0x%p \n", pAddress);
	PRINT(L"[i] Allocation Size : %d \n", (unsigned int)_Pe1.pNtHdr->OptionalHeader.SizeOfImage);
#endif // DEBUG

	_memcpy(pAddress, pPeAddress, _Pe1.pNtHdr->OptionalHeader.SizeOfHeaders);


	for (int i = 0; i < _Pe1.pNtHdr->FileHeader.NumberOfSections; i++) {
#ifdef DEBUG
		PRINT(L"\t[%0.2d] Copying 0x%p To 0x%p Of Size : %d \n", i, (ULONG_PTR)pPeAddress + _Pe1.pSecHdr[i].VirtualAddress, pAddress + _Pe1.pSecHdr[i].PointerToRawData, _Pe1.pSecHdr[i].SizeOfRawData);
#endif // DEBUG

		_memcpy(pAddress + _Pe1.pSecHdr[i].VirtualAddress, (ULONG_PTR)pPeAddress + _Pe1.pSecHdr[i].PointerToRawData, _Pe1.pSecHdr[i].SizeOfRawData);
	}

	// fixing the iat
	if (!_FixImportAddressTable(_Pe1, pAddress)) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Fix The IAT (Unpack.c:270)\n");
#endif // DEBUG
		return;
	}

	// reallocation if needed
	if (pAddress != _Pe1.pNtHdr->OptionalHeader.ImageBase) {
#ifdef DEBUG
		PRINT(L"[i] The Allocated Mem Is Different Than The Preferable Address, Handling Reallocations ... \n");
#endif // DEBUG
		if (!_ReallocationSupport(pAddress, _Pe1.pNtHdr->OptionalHeader.ImageBase, (PIMAGE_BASE_RELOCATION)(pAddress + _Pe1.pEBDataDir->VirtualAddress))) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Fix The Re-Allocation (Unpack.c:282)\n");
#endif // DEBUG
			return;
		}
		
	}

	// registering exception handlers if needed
	if (_Pe1.pEHDataDir->Size){
#ifdef DEBUG
		PRINT(L"[i] Handling The Packed Pe's Exception Handlers ... \n");
#endif // DEBUG
		PIMAGE_RUNTIME_FUNCTION_ENTRY pImgRunFuncEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(pAddress + _Pe1.pEHDataDir->VirtualAddress);

		fnRtlAddFunctionTable pRtlAddFunctionTable = (fnRtlAddFunctionTable)GetProcAddressH(GetModuleHandleH(KERNEL32DLL), RtlAddFunctionTable_StrHashed);
		if (pRtlAddFunctionTable == NULL || (pRtlAddFunctionTable != NULL && !pRtlAddFunctionTable(pImgRunFuncEntry, (_Pe1.pEHDataDir->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1, pAddress))) {
#ifdef DEBUG
			PRINT(L"[!] RtlAddFunctionTable Failed (Unpack.c:298) [ %d ]\n", GetLastError());
#endif // DEBUG
			// return;	// altho its prob okk in case of this failed
		}
	}


	if (!RefreshNtdll()) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Refresh Ntdll's Text Section From Hooks [ Unpack.c:308 ]\n");
#endif // DEBUG
			// return;	// altho its prob okk in case of this failed
	}
	

	// fixing the permissions (needed before the tls callbacks handling)
	for (DWORD i = 0; i < _Pe1.pNtHdr->FileHeader.NumberOfSections; i++) {

		DWORD Protection = 0;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
			Protection = PAGE_WRITECOPY;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
			Protection = PAGE_READONLY;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_READWRITE;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
			Protection = PAGE_EXECUTE;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
			Protection = PAGE_EXECUTE_WRITECOPY;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READ;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READWRITE;
		
#ifdef DEBUG
		PRINT(L"\t[%0.2d] Setting Mem Permissions To 0x%0.4X on [ 0x%p ]\n", i, Protection, (PVOID)(pAddress + _Pe1.pSecHdr[i].VirtualAddress));
#endif // DEBUG

		NtProtectVirtualMemory(NULL, (PVOID)(pAddress + _Pe1.pSecHdr[i].VirtualAddress), (SIZE_T)(_Pe1.pSecHdr[i].SizeOfRawData), Protection, NULL);
	}


	// tls callback handling if needed
	if (_Pe1.pTLSDataDir->Size) {
#ifdef DEBUG
		PRINT(L"[i] Found Tls Callbacks, Setting Up For Execution ... \n");
#endif // DEBUG

		PIMAGE_TLS_DIRECTORY pImgTlsDir = (PIMAGE_TLS_DIRECTORY)(pAddress + _Pe1.pTLSDataDir->VirtualAddress);
		PIMAGE_TLS_CALLBACK* ppCallback = (PIMAGE_TLS_CALLBACK*)(pImgTlsDir->AddressOfCallBacks);
		for (; *ppCallback; ppCallback++) {
			(*ppCallback)((LPVOID)pAddress, DLL_PROCESS_ATTACH, NULL);
		}
	}


	PVOID EP = (PVOID)(pAddress + _Pe1.pNtHdr->OptionalHeader.AddressOfEntryPoint);

	// clean everything before .txt section ( ~ 4096 bytes )
	_ZeroMemory(pAddress, (SIZE_T)_Pe1.pSecHdr[0].VirtualAddress);

#ifdef DEBUG
	PRINT(L"[i] Running The Packed Pe's Entry Point ... \n\n\n");
#endif // DEBUG
	((VOID(*)())EP)();

}



```

`DllPP64Stub/Utils.c`:

```c
#include <Windows.h>

#include "Structs.h"
#include "Utils.h"
#include "Syscalls.h"
#include "Debug.h"

//==============================================================================================================================================================================



BOOL InitializeDirectNtCalls() {
	HashStruct SyscallHashStruct = {

		.NtAllocateVirtualMemory_Hash	= NtAllocateVirtualMemory_StrHashed,
		.NtProtectVirtualMemory_Hash	= NtProtectVirtualMemory_StrHashed,
		.NtCreateSection_Hash			= NtCreateSection_StrHashed,
		.NtOpenSection_Hash				= NtOpenSection_StrHashed,
		.NtMapViewOfSection_Hash		= NtMapViewOfSection_StrHashed,
		.NtUnmapViewOfSection_Hash		= NtUnmapViewOfSection_StrHashed,
		.NtClose_Hash					= NtClose_StrHashed,

	};


	return InitializeStruct(SEED, &SyscallHashStruct);
}


//==============================================================================================================================================================================



//==============================================================================================================================================================================



LPVOID GetDllFromKnownDlls(PWSTR DllName) {

	PVOID pModule = NULL;
	HANDLE hSection = INVALID_HANDLE_VALUE;
	UNICODE_STRING UniStr;
	OBJECT_ATTRIBUTES ObjAtr;
	NTSTATUS STATUS;

	WCHAR FullName[MAX_PATH];
	WCHAR Buf[MAX_PATH] = { L'\\', L'K', L'n', L'o', L'w', L'n', L'D', L'l', L'l', L's', L'\\' };

	_strcpy(FullName, Buf);
	_strcat(FullName, DllName);
	_RtlInitUnicodeString(&UniStr, FullName);


	InitializeObjectAttributes(
		&ObjAtr,
		&UniStr,
		0x40L,
		NULL,
		NULL
	);


	hSection = NtOpenSection(SECTION_MAP_READ | SECTION_MAP_EXECUTE, &ObjAtr, &STATUS);
	if (!NT_SUCCESS(STATUS) || hSection == INVALID_HANDLE_VALUE) {
#ifdef DEBUG
		PRINT(L"[!] %s : NtOpenSection Failed : 0x%0.8X (Utils.c:63)\n", FullName, STATUS);
#endif // DEBUG
		return NULL;
	}


	pModule = NtMapViewOfSection(hSection, NULL, NULL, NULL, PAGE_READONLY, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] %s : NtMapViewOfSection Failed : 0x%0.8X (Utils.c:72)\n", FullName, STATUS);
#endif // DEBUG
		return NULL;
	}

#ifdef DEBUG
	PRINT(L"[+] The module \"%s\" is successfully mapped to 0x%p \n", FullName, pModule);
#endif // DEBUG

	return pModule;
}




BOOL RefreshNtdll() {
	
	NTSTATUS	STATUS			= NULL;
	DWORD		OldProtection	= NULL;
	PVOID		pLocalAddress	= NULL, pRemoteAddress	= NULL;
	SIZE_T		sLocalSize		= NULL;

	LPVOID		KnownDllNtdllModule		= GetDllFromKnownDlls((PWSTR)NTDLLDLLW);
	LPVOID		CurrentNtdllModule		= GetModuleHandleH(NTDLLDLLA);

	if (KnownDllNtdllModule == NULL || CurrentNtdllModule == NULL) {
		return FALSE;
	}
	PIMAGE_DOS_HEADER		CurrentNtdllDosHdr = (PIMAGE_DOS_HEADER)CurrentNtdllModule;
	if (CurrentNtdllDosHdr->e_magic != IMAGE_DOS_SIGNATURE){
		return FALSE;
	}
	PIMAGE_NT_HEADERS		CurrentNtdllNtHdr = (PIMAGE_NT_HEADERS)((ULONG_PTR)CurrentNtdllModule + CurrentNtdllDosHdr->e_lfanew);
	if (CurrentNtdllNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}
	
	
	for (int i = 0; i < CurrentNtdllNtHdr->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER pImgSec = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(CurrentNtdllNtHdr) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
		if ((*(ULONG*)pImgSec->Name | 0x20202020) == 'xet.') {
			sLocalSize = pImgSec->Misc.VirtualSize;
			pLocalAddress = (PVOID)((ULONG_PTR)CurrentNtdllModule + pImgSec->VirtualAddress);
			pRemoteAddress = (PVOID)((ULONG_PTR)KnownDllNtdllModule + pImgSec->VirtualAddress);
		}
	}

	if (sLocalSize == NULL || pLocalAddress == NULL || pRemoteAddress == NULL) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Get Details Of The Txt Section Of The Module To Replace (Utils.c:122)\n");
#endif // DEBUG
		return FALSE;
	}

	// change protection to start patching
	OldProtection = NtProtectVirtualMemory(NULL, pLocalAddress, sLocalSize, PAGE_EXECUTE_WRITECOPY, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtProtectVirtualMemory [1] Failed : 0x%0.8X (Utils.c:130)\n", STATUS);
#endif
		return FALSE;
	}

#ifdef DEBUG
	PRINT(L"[i] Replacing 0x%p with 0x%p of size  %d \n", pLocalAddress, pRemoteAddress, sLocalSize);
#endif
	// replacing
	_memcpy(pLocalAddress, pRemoteAddress, sLocalSize);


	// re-fix the memory permissions to what it was
	NtProtectVirtualMemory(NULL, pLocalAddress, sLocalSize, OldProtection, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtProtectVirtualMemory [2] Failed : 0x%0.8X (Utils.c:146)\n", STATUS);
#endif
		return FALSE;
	}

	NtUnmapViewOfSection(NULL, KnownDllNtdllModule, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtUnmapViewOfSection  Failed : 0x%0.8X (Utils.c:154)\n", STATUS);
#endif
		return FALSE;
	}
	
	return TRUE;
}

//==============================================================================================================================================================================






//==============================================================================================================================================================================


HMODULE GetModuleHandleH(LPSTR ModuleName) {
	if (ModuleName == NULL)
		return NULL;
	
	PPEB pPeb = (PPEB)__readgsqword(0x60);
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);
	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);
	
	while (pDte) {
		if (pDte->FullDllName.Buffer != NULL) {
			if (pDte->FullDllName.Length < MAX_PATH - 1) {
				CHAR DllName[MAX_PATH] = { 0 };
				DWORD i = 0;
				while (pDte->FullDllName.Buffer[i] && i < sizeof(DllName) - 1) {
					DllName[i] = _ToUpper((char)pDte->FullDllName.Buffer[i]);
					i++;
				}
				DllName[i] = '\0';
				if (HASH(DllName) == HASH(ModuleName)) {
					return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
				}
			}
		}
		else {
			break;
		}

		pDte = (PLDR_DATA_TABLE_ENTRY)DEREF_64(pDte);
	}
	return NULL;
}



HMODULE LoadLibraryH(LPSTR DllName) {

	NTSTATUS		STATUS				= NULL;
	UNICODE_STRING	Ustr				= { 0 };
	WCHAR			wDllName[MAX_PATH]	= { 0 };
	HMODULE			hModule				= NULL;

	_CharToWchar(wDllName, DllName, _StrlenA(DllName));

	USHORT DestSize = _StrlenW(wDllName) * sizeof(WCHAR);
	Ustr.Length = DestSize;
	Ustr.MaximumLength = DestSize + sizeof(WCHAR);
	Ustr.Buffer = wDllName;


	fnLdrLoadDll pLdrLoadDll = (fnLdrLoadDll)GetProcAddressH(GetModuleHandleH(NTDLLDLLA), LdrLoadDll_StrHashed);
	if(pLdrLoadDll != NULL && NT_SUCCESS((STATUS = pLdrLoadDll(NULL, 0, &Ustr, &hModule)))){
		return hModule;
	}
#ifdef DEBUG
	PRINT(L"[!] LdrLoadDll Faild To Load \"%s\" 0x%0.8X (Utils.c:224)\n", wDllName, STATUS);
#endif // DEBUG

	return NULL;
}



FARPROC GetProcAddressH (HMODULE hModule, DWORD Hash) {

	if (hModule == NULL || Hash == NULL)
		return NULL;

	HMODULE hModule2 = NULL;
	UINT64	DllBaseAddress = (UINT64)hModule;

	PIMAGE_NT_HEADERS NtHdr = (PIMAGE_NT_HEADERS)(DllBaseAddress + ((PIMAGE_DOS_HEADER)DllBaseAddress)->e_lfanew);
	PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)&NtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	PIMAGE_EXPORT_DIRECTORY ExportTable = (PIMAGE_EXPORT_DIRECTORY)(DllBaseAddress + pDataDir->VirtualAddress);

	UINT64 FunctionNameAddressArray = (DllBaseAddress + ExportTable->AddressOfNames);
	UINT64 FunctionAddressArray = (DllBaseAddress + ExportTable->AddressOfFunctions);
	UINT64 FunctionOrdinalAddressArray = (DllBaseAddress + ExportTable->AddressOfNameOrdinals);
	UINT64 pFunctionAddress = NULL;

	DWORD	dwCounter = ExportTable->NumberOfNames;

	while (dwCounter--) {
		char* FunctionName = (char*)(DllBaseAddress + DEREF_32(FunctionNameAddressArray));

		if (HASH(FunctionName) == Hash) {
			FunctionAddressArray += (DEREF_16(FunctionOrdinalAddressArray) * sizeof(DWORD));
			pFunctionAddress = (UINT64)(DllBaseAddress + DEREF_32(FunctionAddressArray));

			if (pDataDir->VirtualAddress <= DEREF_32(FunctionAddressArray) && (pDataDir->VirtualAddress + pDataDir->Size) >= DEREF_32(FunctionAddressArray)) {
				CHAR Library[MAX_PATH] = { 0 };
				CHAR Function[MAX_PATH] = { 0 };
				UINT32 Index = _CopyDotStr((PCHAR)pFunctionAddress);
				if (Index == 0) {
					return NULL;
				}
				_memcpy((PVOID)Library, (PVOID)pFunctionAddress, Index);
				_memcpy((PVOID)Function, (PVOID)((ULONG_PTR)pFunctionAddress + Index + 1), _StrlenA((LPCSTR)((ULONG_PTR)pFunctionAddress + Index + 1)));
				if ((hModule2 = LoadLibraryH(Library)) != NULL) {
					pFunctionAddress = (UINT64)GetProcAddressH(hModule2, HASH(Function));
				}
			}
			break;
		}
		FunctionNameAddressArray += sizeof(DWORD);
		FunctionOrdinalAddressArray += sizeof(WORD);
	}
	return (FARPROC)pFunctionAddress;
}





//==============================================================================================================================================================================






```

`DllPP64Stub/Utils.h`:

```h
/*
	this file contains the common functions called, as well other stuff (macros, typedefs ...)
*/

#pragma once

#include <Windows.h>

#ifndef COMMON
#define COMMON

#include "Structs.h"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// macros:


#define SEED 0x07

#define DEREF( name )		*(	UINT_PTR	*)	(name)
#define DEREF_64( name )	*(	DWORD64		*)	(name)
#define DEREF_32( name )	*(	DWORD		*)	(name)
#define DEREF_16( name )	*(	WORD		*)	(name)
#define DEREF_8( name )		*(	BYTE		*)	(name)

#define HASH(API)		(_HashStringRotr32A((PCHAR) API))
#define HASHW(API)		(_HashStringRotr32W((PWCHAR) API))


#define NTDLLDLLA								"NTDLL.DLL"
#define NTDLLDLLW								L"NTDLL.DLL"
#define KERNEL32DLL								"KERNEL32.DLL"


#define ATOM_StrHashed							0x9F520B2D

#define NtAllocateVirtualMemory_StrHashed       0x014044AE
#define NtProtectVirtualMemory_StrHashed        0xE67C7320
#define NtCreateSection_StrHashed				0xAC2EDA02
#define NtOpenSection_StrHashed					0xD443EC8C
#define NtMapViewOfSection_StrHashed			0x92DD00B3
#define NtUnmapViewOfSection_StrHashed			0x12D71086
#define NtClose_StrHashed						0x7B3F64A4

#define LdrLoadDll_StrHashed					0xCC4C8B22
#define RtlAddFunctionTable_StrHashed			0x9219585C


#define GetModuleHandleExA_StrHashed			0xBADBD3CD
#define Atom_StrHashed							0xDFD2086D

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// typedefs:


typedef NTSTATUS(NTAPI* fnLdrLoadDll)(
	PWCHAR             PathToFile,
	ULONG              Flags,
	PUNICODE_STRING    ModuleFileName,
	PHANDLE            ModuleHandle
	);

typedef BOOLEAN(WINAPI* fnRtlAddFunctionTable)(
	PRUNTIME_FUNCTION FunctionTable,
	DWORD             EntryCount,
	DWORD64           BaseAddress
	);


typedef BOOL(WINAPI* fnGetModuleHandleExA)(
	DWORD		dwFlags,
	LPCSTR		lpModuleName,
	HMODULE*	phModule
);

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Unpack.c (255):

VOID UnpackAndRunEp(PVOID pPeAddress, SIZE_T sPeSize, BOOL RunPe);



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Utils.c:


// fill up the direct syscalls struct (using a function from my Syscallslib library)
BOOL InitializeDirectNtCalls();
// overwrite the .txt section of ntdll.dll (copied from \knowndll\) to unhook ...
BOOL RefreshNtdll();

// custom getmodulehandlea
HMODULE GetModuleHandleH(LPSTR ModuleName);
// custom loadlibrarya (using LdrLoadDll)
HMODULE LoadLibraryH(LPSTR DllName);
// custom getprocaddress (via hashing)
FARPROC GetProcAddressH(HMODULE hModule, DWORD Hash);


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// General.c

/*
	these are helper functions, used to avoid crt functions, i think the names already explain the usage ...
*/

VOID		_RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source);
SIZE_T		_CharToWchar(PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed);

wchar_t*	_strcatW(wchar_t* dest, const wchar_t* src);
wchar_t*	_strcpyW(wchar_t* dest, const wchar_t* src);
char*		_strcatA(char* dest, const char* src);
char*		_strcpyA(char* dest, const char* src);

SIZE_T		_StrlenA(LPCSTR String);
SIZE_T		_StrlenW(LPCWSTR String);

DWORD		_HashStringRotr32A(PCHAR String);
DWORD		_HashStringRotr32W(PWCHAR String);
VOID		_ZeroMemory(PVOID Destination, SIZE_T Size);
PVOID		_memcpy(void* dst, const void* src, SIZE_T count);
CHAR		_ToUpper(CHAR c);
UINT32		_CopyDotStr(PCHAR String);

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------



#endif // !COMMON

```

`DllPP64Stub/common.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/common.h - definitions common to both compression and
 *                     decompression
 */

#ifndef __EASYLZMACOMMON_H__ 
#define __EASYLZMACOMMON_H__ 

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/* msft dll export gunk.  To build a DLL on windows, you
 * must define WIN32, EASYLZMA_SHARED, and EASYLZMA_BUILD.  To use a 
 * DLL, you must define EASYLZMA_SHARED and WIN32 */
#if defined(WIN32) && defined(EASYLZMA_SHARED)
#  ifdef EASYLZMA_BUILD
#    define EASYLZMA_API __declspec(dllexport)
#  else
#    define EASYLZMA_API __declspec(dllimport)
#  endif
#else
#  define EASYLZMA_API
#endif 

/** error codes */

/** no error */
#define ELZMA_E_OK                               0
/** bad parameters passed to an ELZMA function */
#define ELZMA_E_BAD_PARAMS                      10
/** could not initialize the encode with configured parameters. */
#define ELZMA_E_ENCODING_PROPERTIES_ERROR       11
/** an error occured during compression (XXX: be more specific) */
#define ELZMA_E_COMPRESS_ERROR                  12
/** currently unsupported lzma file format was specified*/
#define ELZMA_E_UNSUPPORTED_FORMAT              13
/** an error occured when reading input */
#define ELZMA_E_INPUT_ERROR                     14
/** an error occured when writing output */
#define ELZMA_E_OUTPUT_ERROR                    15
/** LZMA header couldn't be parsed */
#define ELZMA_E_CORRUPT_HEADER                  16
/** an error occured during decompression (XXX: be more specific) */
#define ELZMA_E_DECOMPRESS_ERROR                17
/** the input stream returns EOF before the decompression could complete */
#define ELZMA_E_INSUFFICIENT_INPUT              18
/** for formats which have an emebedded crc, this error would indicated that
 *  what came out was not what went in, i.e. data corruption */
#define ELZMA_E_CRC32_MISMATCH                  19
/** for formats which have an emebedded uncompressed content length,
 *  this error indicates that the amount we read was not what we expected */
#define ELZMA_E_SIZE_MISMATCH                   20


/** Supported file formats */
typedef enum {
    ELZMA_lzip, /**< the lzip format which includes a magic number and
                 *   CRC check */
    ELZMA_lzma  /**< the LZMA-Alone format, originally designed by
                 *   Igor Pavlov and in widespread use due to lzmautils,
                 *   lacking both aforementioned features of lzip */
/* XXX: future, potentially   ,
    ELZMA_xz 
*/
} elzma_file_format;

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process has generated [de]compressed output.
 *
 * the size parameter indicates how much data is in buf to be written.
 * it is required that the write callback consume all data, and a return
 * value not equal to input size indicates and error.
 */
typedef size_t (*elzma_write_callback)(void *ctx, const void *buf,
                                       size_t size);

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process requires more [un]compressed input.
 *
 * the size parameter is an in/out argument.  on input it indicates
 * the buffer size.  on output it indicates the amount of data read into
 * buf.  when *size is zero on output it indicates EOF.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef int (*elzma_read_callback)(void *ctx, void *buf,
                                   size_t *size);

/**
 * A callback invoked during elzma_[de]compress_run to report progress
 * on the [de]compression.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef void (*elzma_progress_callback)(void *ctx, size_t complete,
                                        size_t total);


/** pointer to a malloc function, supporting client overriding memory
 *  allocation routines */
typedef void * (*elzma_malloc)(void *ctx, unsigned int sz);

/** pointer to a free function, supporting client overriding memory
 *  allocation routines */
typedef void (*elzma_free)(void *ctx, void * ptr);

#ifdef __cplusplus
};
#endif    

#endif

```

`DllPP64Stub/decompress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/decompress.h - The API for LZMA decompression using easylzma
 */

#ifndef __EASYLZMADECOMPRESS_H__ 
#define __EASYLZMADECOMPRESS_H__ 

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif    

/** an opaque handle to an lzma decompressor */
typedef struct _elzma_decompress_handle * elzma_decompress_handle;

/**
 * Allocate a handle to an LZMA decompressor object.
 */ 
elzma_decompress_handle EASYLZMA_API elzma_decompress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_decompress_set_allocation_callbacks(
    elzma_decompress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA decompressor object.
 */ 
void EASYLZMA_API elzma_decompress_free(elzma_decompress_handle * hand);

/**
 * Perform decompression
 *
 * XXX: should the library automatically detect format by reading stream?
 *      currently it's based on data external to stream (such as extension
 *      or convention)
 */ 
int EASYLZMA_API elzma_decompress_run(
    elzma_decompress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_file_format format);


#ifdef __cplusplus
};
#endif    

#endif

```

`DllPP64Stub/easylzma.c`:

```c
#include <string.h>
#include <assert.h>
#include "easylzma.h"
#include "Crt.h"

struct dataStream
{
    const unsigned char* inData;
    size_t inLen;

    unsigned char* outData;
    size_t outLen;
};

static int
inputCallback(void* ctx, void* buf, size_t* size)
{
    size_t rd = 0;
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    rd = (ds->inLen < *size) ? ds->inLen : *size;

    if (rd > 0) {
        // memcpy replacement
        memcpy(buf, (void*)ds->inData, rd);
        ds->inData += rd;
        ds->inLen -= rd;
    }

    *size = rd;

    return 0;
}

static size_t
outputCallback(void* ctx, const void* buf, size_t size)
{
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    if (size > 0) {
        // realloc replacement 
        ds->outData = realloc((PVOID)ds->outData, (SIZE_T) ds->outLen + size);
        // memcpy replacement
        memcpy((void*)(ds->outData + ds->outLen), buf, size);
        ds->outLen += size;
    }

    return size;
}


int
simpleDecompress(elzma_file_format format, const unsigned char* inData,
    size_t inLen, unsigned char** outData,
    size_t* outLen)
{
    int rc;
    elzma_decompress_handle hand;

    hand = elzma_decompress_alloc();

    /* now run the compression */
    {
        struct dataStream ds;
        ds.inData = inData;
        ds.inLen = inLen;
        ds.outData = NULL;
        ds.outLen = 0;

        rc = elzma_decompress_run(hand, inputCallback, (void*)&ds,
            outputCallback, (void*)&ds, format);

        if (rc != ELZMA_E_OK) {
            // free replacment
            if (ds.outData != NULL) free(ds.outData);
            elzma_decompress_free(&hand);
            return rc;
        }

        elzma_decompress_free(&hand);
        *outData = ds.outData;
        *outLen = ds.outLen;
    }

    return rc;
}

```

`DllPP64Stub/easylzma.h`:

```h
#pragma once


#ifndef _EASYLZMA_H
#define _EASYLZMA_H

#include "decompress.h"


/* decompress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
int simpleDecompress(elzma_file_format format,
    const unsigned char* inData,
    size_t inLen,
    unsigned char** outData,
    size_t* outLen);


#endif // !_EASYLZMA_H

```

`DllPP64Stub/main.c`:

```c
#include <Windows.h>
//#include <strsafe.h>
//#include <stdio.h>

#include "Utils.h"
#include "IatCamouflage.h"
#include "easylzma.h"
#include "Debug.h"

#pragma comment (lib, "easylzma_s.lib")
#pragma comment (lib, "Syscalls.lib")


#pragma comment(linker,"/ENTRY:DllMain")
#pragma warning( disable : 4996)


//function proto-type:
BOOL ActualMain();

//_DllMainCRTStartup
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved){
    
    switch (dwReason){

        case DLL_PROCESS_ATTACH: {
#ifdef DEBUG
            if (GetConsole() == NULL) {
                MessageBoxA(NULL, "Failed To Create A Console To Write Debug Events To", ":(", MB_OK);
            }
#endif
            BOOL    _Atom = FALSE;
            int     _argc = 0;
            LPWSTR* _argv = CommandLineToArgvW(GetCommandLineW(), &_argc);
            for (int i = 0; i < _argc; i++){
                // hash this here
                if (HASHW(_argv[i]) == Atom_StrHashed){
                    _Atom = TRUE;
                }
            }


            if(!_Atom){
#ifdef DEBUG
                PRINT(L"[i] Calling ActualMain from - DllMain \n");
#endif // DEBUG
                CreateThread(NULL, NULL, ActualMain, NULL, NULL, NULL);
            }
            
        }

        case DLL_PROCESS_DETACH: {

            break;
        }
    }

    return TRUE;
}


__declspec(dllexport) VOID Atom () {
#ifdef DEBUG
    PRINT(L"[i] Calling ActualMain from - Atom \n");
#endif // DEBUG

    if(!ActualMain()){
#ifdef DEBUG
        MessageBoxA(NULL, " ActualMain - Atom ", "FAILED ", MB_OK);
#endif // DEBUG
        return;
    }

    WaitForSingleObject(CreateEvent(0, 0, 0, 0), INFINITE);
}




BOOL ActualMain() {

    HMODULE hModule = NULL;
    fnGetModuleHandleExA pGetModuleHandleExA = (fnGetModuleHandleExA)GetProcAddressH(GetModuleHandleH(KERNEL32DLL), GetModuleHandleExA_StrHashed);
    if (pGetModuleHandleExA == NULL){
        return FALSE;
    }
    if (!pGetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCSTR)&ActualMain, &hModule) || hModule == NULL) {
        return FALSE;
    }

    CamouflageImports(0xFF);

    unsigned int	iError = ELZMA_E_OK;
    unsigned char* _OutputUnpackedData = NULL;
    size_t          _OutputUnpackedSize = NULL;

    CHAR* pBaseAddress = (CHAR*)hModule;
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBaseAddress;
    PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBaseAddress + pImgDosHdr->e_lfanew);
    PIMAGE_SECTION_HEADER pImgSectionHdr = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdr) + sizeof(IMAGE_NT_HEADERS));
    PVOID  pData = NULL;
    SIZE_T sSize = NULL;
    for (size_t i = 0; i <= pImgNtHdr->FileHeader.NumberOfSections; i++) {
        if (ATOM_StrHashed == HASH(pImgSectionHdr->Name)) {
            pData = (PVOID)((ULONG_PTR)pBaseAddress + pImgSectionHdr->VirtualAddress);
            sSize = pImgSectionHdr->SizeOfRawData;
            break;
        }
        pImgSectionHdr = (PIMAGE_SECTION_HEADER)((PBYTE)pImgSectionHdr + (DWORD)sizeof(IMAGE_SECTION_HEADER));
    }

    if (pData == NULL || sSize == NULL) {
#ifdef DEBUG
        PRINT(L"[!] NO .Atom Section Found - Build it Plz (main.c:)\n");
#endif // DEBUG
        return FALSE;
    }


    if (!InitializeDirectNtCalls()) {
#ifdef DEBUG
        PRINT(L"[!] Failed To Initialize The Direct Syscalls Struct (main.c:)\n");
#endif // DEBUG
        return FALSE;
    }

    if ((iError = simpleDecompress(ELZMA_lzma, pData, sSize, &_OutputUnpackedData, &_OutputUnpackedSize)) != ELZMA_E_OK) {
#ifdef DEBUG
        PRINT(L"[!] Failed To Decompress The Stub (main.c:)\n");
#endif // DEBUG
        return FALSE;
    }

    UnpackAndRunEp(_OutputUnpackedData, _OutputUnpackedSize, TRUE);

    return TRUE;
}




#ifdef DEBUG

HANDLE hConsole = NULL;

HANDLE GetConsole() {

    if (hConsole != NULL) {
        return hConsole;
    }

    if (!FreeConsole()) {
        return NULL;
    }

    if (!AllocConsole()) {
        return NULL;
    }

    if ((hConsole = GetStdHandle(STD_OUTPUT_HANDLE)) == NULL) {
        return NULL;
    }

    return hConsole;
}

#endif // DEBUG
```

`Helper/Hasher/Hasher.c`:

```c
#include <Windows.h>
#include <stdio.h>

#define SEED 0x07
#define NAME "_StrHashed"


SIZE_T _StrlenA(LPCSTR String) {

    LPCSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

SIZE_T _StrlenW(LPCWSTR String) {

    LPCWSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}


UINT32 _HashStringRotr32SubA(UINT32 Value, UINT Count) {

    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

DWORD HashStringRotr32A(PCHAR String) {

    DWORD Value = 0;

    for (INT Index = 0; Index < _StrlenA(String); Index++)
        Value = String[Index] + _HashStringRotr32SubA(Value, SEED);

    return Value;
}


UINT32 _HashStringRotr32SubW(UINT32 Value, UINT Count)
{
    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

DWORD HashStringRotr32W(PWCHAR String)
{
    DWORD Value = 0;

    for (INT Index = 0; Index < _StrlenW(String); Index++)
        Value = String[Index] + _HashStringRotr32SubW(Value, SEED);

    return Value;
}




int main() {


  
  /*
    printf("#define %s%s \t0x%0.8X \n", "NtAllocateVirtualMemory", NAME, HashStringRotr32A("NtAllocateVirtualMemory"));
    printf("#define %s%s \t0x%0.8X \n", "NtProtectVirtualMemory", NAME, HashStringRotr32A("NtProtectVirtualMemory"));

    printf("#define %s%s \t0x%0.8X \n", "NtCreateSection", NAME, HashStringRotr32A("NtCreateSection"));
    printf("#define %s%s \t0x%0.8X \n", "NtOpenSection", NAME, HashStringRotr32A("NtOpenSection"));
    printf("#define %s%s \t0x%0.8X \n", "NtMapViewOfSection", NAME, HashStringRotr32A("NtMapViewOfSection"));

    printf("#define %s%s \t0x%0.8X \n", "NtUnmapViewOfSection", NAME, HashStringRotr32A("NtUnmapViewOfSection"));
    printf("#define %s%s \t0x%0.8X \n", "NtClose", NAME, HashStringRotr32A("NtClose"));
 
    printf("#define %s%s \t0x%0.8X \n", "RtlAddFunctionTable", NAME, HashStringRotr32A("RtlAddFunctionTable"));

    printf("#define %s%s \t0x%0.8X \n", "ATOM", NAME, HashStringRotr32A(".ATOM"));

  */

    printf("#define %s%s \t0x%0.8X \n", "GetModuleHandleExA", NAME, HashStringRotr32A("GetModuleHandleExA"));


    printf("#define %s%s \t0x%0.8X \n", "Atom", NAME, HashStringRotr32W(L"Atom"));


    //printf("#define %s%s \t0x%0.8X \n", "", NAME, HashStringRotr32A(""));
    //printf("#define %s%s \t0x%0.8X \n", "", NAME, HashStringRotr32W(""));

    return 0;

}


```

`Helper/Hasher/Hasher.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1bf8a1ac-560f-439c-b4fb-2cb8ddb9e9e9}</ProjectGuid>
    <RootNamespace>Hasher</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Hasher.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Helper/Hasher/Hasher.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Hasher.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Helper/Hasher/Hasher.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`PP64Stub/Crt.h`:

```h
/*

    since im using easylzma library, which is using some crt functions, i had to replace them here, using custom code, so yeah ...
    thats what these are :p

    ofc some of the code is from vx-api (for the credits)
*/

#pragma once
#include <Windows.h>


PVOID _malloc(SIZE_T Size)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);
}

BOOL _free(PVOID ptr)
{
    return HeapFree(GetProcessHeap(), 0, ptr);
}


PVOID _realloc(PVOID ptr, SIZE_T new_size)
{

    byte* d = NULL; 
    byte* s = NULL;
    size_t size = NULL;

    if (new_size == NULL)
        return NULL;

    if (ptr == NULL)
        return _malloc(new_size);


    size_t old_size = HeapSize(GetProcessHeap(), 0, ptr);

    if (old_size == new_size) {
        return ptr;
    }
    
    // allocating new ptr and moving data to it (from ptr)
    void* new_ptr = _malloc(new_size);

    d = (byte*)new_ptr;
    s = (byte*)ptr;
    size = old_size;
    for (volatile int i = 0; i < size; i++) {
        ((BYTE*)d)[i] = ((BYTE*)s)[i];
    }

    // setting ptr to 0
    PULONG Dest = (PULONG)ptr;
    size = old_size / sizeof(ULONG);
    while (size > 0){
        *Dest = 0;
        Dest++;
        size--;
    }

    //freeing ptr
    _free(ptr);

    return new_ptr;
}



//       REPLACING MEMSET
extern void* __cdecl memset(void*, int, size_t);
#pragma intrinsic(memset)
#pragma function(memset)
void* __cdecl memset(void* pTarget, int value, size_t cbTarget) {
	unsigned char* p = (unsigned char*)pTarget;
	while (cbTarget-- > 0) {
		*p++ = (unsigned char)value;
	}
	return pTarget;
}

//      REPLACING MEMMOVE
extern void* __cdecl memmove(void* destination, const void* source, size_t num);
#pragma intrinsic(memmove)
#pragma function(memmove)
void* __cdecl memmove(void* destination, const void* source, size_t num) {
    for (volatile int i = 0; i < num; i++) {
        ((BYTE*)destination)[i] = ((BYTE*)source)[i];
    }
    return destination;
}

//      REPLACING FREE
extern void __cdecl free(void*);
#pragma intrinsic(free)
#pragma function(free)
void __cdecl free(void* pAddress) {
	_free(pAddress);
}

//      REPLACING MALLOC
extern void* __cdecl malloc(size_t);
#pragma intrinsic(malloc)
#pragma function(malloc)
void* __cdecl malloc(size_t Size) {
	return _malloc(Size);
}

//      REPLACING REALLOC
extern void* __cdecl realloc(void* ptr, size_t new_size);
#pragma intrinsic(realloc)
#pragma function(realloc)
void* __cdecl realloc(void* ptr, size_t new_size) {
    return _realloc(ptr, new_size);
}



//      REPLACING MEMCPY
extern void* __cdecl memcpy(void*, void const*, size_t);
#pragma intrinsic(memcpy)
#pragma function(memcpy)
void* __cdecl memcpy(void* dst, void const* src, size_t size) {
    for (volatile int i = 0; i < size; i++) {
        ((BYTE*)dst)[i] = ((BYTE*)src)[i];
    }
    return dst;
}


//      REPLACING STRNCMP
extern int __cdecl strncmp(char const*, char const*, size_t);
#pragma intrinsic(strncmp)
#pragma function(strncmp)
int __cdecl strncmp(char const* str1, char const* str2, size_t size) {

    for (; *str1 == *str2; str1++, str2++)
    {
        if (*str1 == '\0')
            return 0;
    }

    return ((*(LPCSTR)str1 < *(LPCSTR)str2) ? -1 : +1);
}


```

`PP64Stub/Debug.h`:

```h
#include <Windows.h>


// #define DEBUG

#ifdef DEBUG

#define PRINT( STR, ... )                                                                   \
    if (1) {                                                                                \
        LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );         \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfW( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  



#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  


#endif // DEBUG

```

`PP64Stub/General.c`:

```c
/*

    contains bunch of helper functions to replace the crt version 
    (vx-api and others for the credits ...)
*/

#include <Windows.h>

#include "Structs.h"
#include "Utils.h"


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/rad9800/TamperingSyscalls/blob/master/TamperingSyscalls/entry.cpp#L329
VOID _RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source){

	if ((target->Buffer = (PWSTR)source)){

		unsigned int length = wcslen(source) * sizeof(WCHAR);
		if (length > 0xfffc)
			length = 0xfffc;

		target->Length = length;
		target->MaximumLength = target->Length + sizeof(WCHAR);
	}

	else target->Length = target->MaximumLength = 0;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L482
wchar_t* _strcatW(wchar_t* dest, const wchar_t* src){

    if ((dest == NULL) || (src == NULL))
        return dest;

    while (*dest != 0)
        dest++;

    while (*src != 0) {
        *dest = *src;
        dest++;
        src++;
    }

    *dest = 0;
    return dest;
}

char* _strcatA (char* dest, const char* src) {
    
    if ((dest == NULL) || (src == NULL))
        return dest;

    while (*dest != 0)
        dest++;

    while (*src != 0) {
        *dest = *src;
        dest++;
        src++;
    }

    *dest = 0;
    return dest;
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L461
wchar_t* _strcpyW(wchar_t* dest, const wchar_t* src){

    wchar_t* p;

    if ((dest == NULL) || (src == NULL))
        return dest;

    if (dest == src)
        return dest;

    p = dest;
    while (*src != 0) {
        *p = *src;
        p++;
        src++;
    }

    *p = 0;
    return dest;
}


char* _strcpyA(char* dest, const char* src) {

    char* p;

    if ((dest == NULL) || (src == NULL))
        return dest;

    if (dest == src)
        return dest;

    p = dest;
    while (*src != 0) {
        *p = *src;
        p++;
        src++;
    }

    *p = 0;
    return dest;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/rad9800/WTSRM/blob/master/WTSRM/entry.cpp#L500
PVOID _memcpy(void* dst, const void* src, SIZE_T count) {
    for (volatile int i = 0; i < count; i++) {
        ((BYTE*)dst)[i] = ((BYTE*)src)[i];
    }
    return dst;
}

// https://github.com/vxunderground/VX-API/blob/main/VX-API/ZeroMemoryEx.cpp
VOID _ZeroMemory(PVOID Destination, SIZE_T Size){

    PULONG Dest = (PULONG)Destination;
    SIZE_T Count = Size / sizeof(ULONG);

    while (Count > 0)
    {
        *Dest = 0;
        Dest++;
        Count--;
    }

    return;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------


CHAR _ToUpper (CHAR c) {
    
    if (c >= 'a' && c <= 'z') {
        return c - 'a' + 'A';
    }
    
    return c;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/StringLength.cpp
SIZE_T _StrlenA(LPCSTR String){

    LPCSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

SIZE_T _StrlenW(LPCWSTR String){

    LPCWSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringRotr32.cpp
UINT32 _HashStringRotr32SubA(UINT32 Value, UINT Count){

    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

DWORD _HashStringRotr32A(PCHAR String){

    DWORD Value = 0;

    for (INT Index = 0; Index < _StrlenA(String); Index++)
        Value = String[Index] + _HashStringRotr32SubA(Value, SEED);

    return Value;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/Cracked5pider/KaynLdr/blob/main/KaynLdr/src/Win32.c#L39
UINT32 _CopyDotStr(PCHAR String){

    for (UINT32 i = 0; i < _StrlenA(String); i++)
    {
        if (String[i] == '.')
            return i;
    }
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://github.com/vxunderground/VX-API/blob/main/VX-API/CharStringToWCharString.cpp

SIZE_T _CharToWchar (PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed){

    INT Length = (INT)MaximumAllowed;
    
    while (--Length >= 0){
        if (!(*Destination++ = *Source++))
            return MaximumAllowed - Length - 1;
    }

    return MaximumAllowed - Length;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```

`PP64Stub/IatCamouflage.h`:

```h
/*
	since this stub is using api hashing & removing crt functions, the low number of imported functions is pretty much an ioc itself
	so i had to come up with a list of non-blacklisted api's that can change the modules & functions used (although not executed)

*/

#pragma once
#include <Windows.h>
#include <synchapi.h>



LPVOID FunctionToReturnSomething(int i, int* pi, int* px, int* py) {
	int x, y;
	x = y = i++;
	y += x * i;
	x = i + 100;
	i = i + i / 2;
	*pi = i;
	*px = x;
	*py = y;
	return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024);
}



BOOL CamouflageImports(int i) {
	int x, y;
	x = y = i++;
	y += x * i;
	x = i + 100;
	i = i + i / 2;

	LPVOID p = FunctionToReturnSomething(i, &i, &x, &y);
	

	//i : 577 || x : 485 || y : 148224
	//PRINT(L"[i] i : %d || x : %d || y : %d \n", i, x, y);

	if (i == 577) {
		x += 1;
		x -= 1;
		if (y * 2 == y + 148224) {
			if (GetLastError() == ERROR_IPSEC_IKE_SECLOADFAIL) {
				// we dont care about anything here, we just want these to be imported by our packer
				ReleaseSRWLockExclusive(NULL);
				ReleaseSRWLockShared(NULL);
				SetCriticalSectionSpinCount(NULL, NULL);
				TryAcquireSRWLockExclusive(NULL);
				WakeAllConditionVariable(NULL);
				SetUnhandledExceptionFilter(NULL);
				UnhandledExceptionFilter(NULL);
				CheckMenuItem(NULL, NULL, NULL);
				GetMenu(NULL);
				GetSystemMenu(NULL, NULL);
				GetMenuItemID(NULL, NULL);
				EnableMenuItem(NULL, NULL, NULL);
				MessageBeep(NULL);
				GetLastError();
				MessageBoxW(NULL, NULL, NULL, NULL);
				MessageBoxA(NULL, NULL, NULL, NULL);
				UpdateWindow(NULL);
				GetWindowContextHelpId(NULL);
			}
			else {
				HeapFree(GetProcessHeap(), 0, p);
			}
		}
	}


	return TRUE;

}
```

`PP64Stub/PP64Stub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ad3a3406-be90-4dbb-abed-c411d9d6309d}</ProjectGuid>
    <RootNamespace>PP64Stub</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>easylzma_s.lib;Syscalls.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>easylzma_s.lib;Syscalls.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="easylzma.c" />
    <ClCompile Include="General.c" />
    <ClCompile Include="Utils.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="Unpack.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="Crt.h" />
    <ClInclude Include="decompress.h" />
    <ClInclude Include="easylzma.h" />
    <ClInclude Include="IatCamouflage.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="Debug.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Syscalls.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PP64Stub/PP64Stub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="easylzma">
      <UniqueIdentifier>{420c77c2-b1bf-476f-8d6d-ba6736069dcb}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Unpack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="General.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="easylzma.c">
      <Filter>easylzma</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="decompress.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="easylzma.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="Crt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IatCamouflage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PP64Stub/PP64Stub.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`PP64Stub/Structs.h`:

```h
#pragma once

#include <Windows.h>


#ifndef STRUCTS
#define STRUCTS


#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;


#define InitializeObjectAttributes( p, n, a, r, s ) {	\
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _BASE_RELOCATION_ENTRY {
	WORD Offset : 12;
	WORD Type : 4;
} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;


typedef PVOID PACTIVATION_CONTEXT;

typedef struct _PEB_LDR_DATA {
    ULONG                   Length;
    ULONG                   Initialized;
    PVOID                   SsHandle;
    LIST_ENTRY              InLoadOrderModuleList;
    LIST_ENTRY              InMemoryOrderModuleList;
    LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;



typedef struct _CURDIR{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, * PCURDIR;

#define RTL_MAX_DRIVE_LETTERS 32

typedef struct _RTL_DRIVE_LETTER_CURDIR{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;


typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    WORD LoadCount;
    WORD TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PACTIVATION_CONTEXT EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    union
    {
        UCHAR BitField;
        struct
        {
            UCHAR ImageUsesLargePages : 1;
            UCHAR IsProtectedProcess : 1;
            UCHAR IsImageDynamicallyRelocated : 1;
            UCHAR SkipPatchingUser32Forwarders : 1;
            UCHAR IsPackagedProcess : 1;
            UCHAR IsAppContainer : 1;
            UCHAR IsProtectedProcessLight : 1;
            UCHAR IsLongPathAwareProcess : 1;
        };
    };
    UCHAR Padding0[4];
    VOID* Mutant;
    VOID* ImageBaseAddress;
    struct _PEB_LDR_DATA* Ldr;
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
    VOID* SubSystemData;
    VOID* ProcessHeap;
    struct _RTL_CRITICAL_SECTION* FastPebLock;
    union _SLIST_HEADER* volatile AtlThunkSListPtr;
    VOID* IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1;
            ULONG ReservedBits0 : 24;
        };
    };
    UCHAR Padding1[4];
    union
    {
        VOID* KernelCallbackTable;
        VOID* UserSharedInfoPtr;
    };
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    VOID* ApiSetMap;
    ULONG TlsExpansionCounter;
    UCHAR Padding2[4];
    VOID* TlsBitmap;
    ULONG TlsBitmapBits[2];
    VOID* ReadOnlySharedMemoryBase;
    VOID* SharedData;
    VOID** ReadOnlyStaticServerData;
    VOID* AnsiCodePageData;
    VOID* OemCodePageData;
    VOID* UnicodeCaseTableData;
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;
    union _LARGE_INTEGER CriticalSectionTimeout;
    ULONGLONG HeapSegmentReserve;
    ULONGLONG HeapSegmentCommit;
    ULONGLONG HeapDeCommitTotalFreeThreshold;
    ULONGLONG HeapDeCommitFreeBlockThreshold;
    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    VOID** ProcessHeaps;
    VOID* GdiSharedHandleTable;
    VOID* ProcessStarterHelper;
    ULONG GdiDCAttributeList;
    UCHAR Padding3[4];
    struct _RTL_CRITICAL_SECTION* LoaderLock;
    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    UCHAR Padding4[4];
    ULONGLONG ActiveProcessAffinityMask;
    ULONG GdiHandleBuffer[60];
    VOID(*PostProcessInitRoutine)();
    VOID* TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];
    ULONG SessionId;
    UCHAR Padding5[4];
    union _ULARGE_INTEGER AppCompatFlags;
    union _ULARGE_INTEGER AppCompatFlagsUser;
    VOID* pShimData;
    VOID* AppCompatInfo;
    struct _UNICODE_STRING CSDVersion;
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;
    ULONGLONG MinimumStackCommit;
    struct _FLS_CALLBACK_INFO* FlsCallback;
    struct _LIST_ENTRY FlsListHead;
    VOID* FlsBitmap;
    ULONG FlsBitmapBits[4];
    ULONG FlsHighIndex;
    VOID* WerRegistrationData;
    VOID* WerShipAssertPtr;
    VOID* pUnused;
    VOID* pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    UCHAR Padding6[4];
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    ULONGLONG TppWorkerpListLock;
    struct _LIST_ENTRY TppWorkerpList;
    VOID* WaitOnAddressHashTable[128];
    VOID* TelemetryCoverageHeader;
    ULONG CloudFileFlags;
    ULONG CloudFileDiagFlags;
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderCompatibilityModeReserved[7];
    struct _LEAP_SECOND_DATA* LeapSecondData;
    union
    {
        ULONG LeapSecondFlags;
        struct
        {
            ULONG SixtySecondEnabled : 1;
            ULONG Reserved : 31;
        };
    };
    ULONG NtGlobalFlag2;
} PEB, * PPEB;



#endif // !STRUCTS

```

`PP64Stub/Syscalls.h`:

```h
/*
	this file is from my syscallslib repo
*/

#pragma once
#include <Windows.h>



#ifndef SYSCALLS
#define SYSCALLS

#include "Structs.h"

#define EXTERN extern


typedef struct _HashStruct {
	DWORD NtAllocateVirtualMemory_Hash;
	DWORD NtProtectVirtualMemory_Hash;

	DWORD NtCreateSection_Hash;
	DWORD NtOpenSection_Hash;
	DWORD NtMapViewOfSection_Hash;
	DWORD NtUnmapViewOfSection_Hash;

	DWORD NtClose_Hash;

}HashStruct, * PHashStruct;



EXTERN BOOL
InitializeStruct(
	IN			INT			Seed,									// INPUT : Seed Of The Rotr32 Hashing algo
	IN			PHashStruct PStruct									// INPUT : pointer to a struct of type 'HashStruct' that will initialize the data 
);

EXTERN PVOID
NtAllocateVirtualMemory(
	IN  OPTIONAL  HANDLE	ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL  PVOID		BaseAddress,							// INPUT  : NULL by default  
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	IN  OPTIONAL  ULONG		AllocationType,							// INPUT  : MEM_COMMIT | MEM_RESERVE by default
	IN  OPTIONAL  ULONG		Protect,								// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

// calling the default NtAllocateVirtualMemory | u can do such thing to the others ...
EXTERN PVOID
NtAllocateVirtualMemory2(
	IN			  SIZE_T	RegionSize,								// INPUT  : can't be NULL
	OUT OPTIONAL  PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN ULONG
NtProtectVirtualMemory(
	IN  OPTIONAL HANDLE		ProcessHandle,							// INPUT  : in case of null, the function will run localy
	IN			 PVOID		BaseAddress,							// INPUT  : can't be NULL
	IN			 SIZE_T		NumberOfBytesToProtect,					// INPUT  : can't be NULL
	IN			 ULONG		NewAccessProtection,					// INPUT  : can't be NULL
	OUT OPTIONAL PNTSTATUS	STATUS									// OUTPUT : the return from the syscall
);

EXTERN HANDLE
NtCreateSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN	OPTIONAL	POBJECT_ATTRIBUTES	ObjectAttributes,			// INPUT  : NULL by default
	IN				SIZE_T				NumberOfBytes,				// INPUT  : can't be NULL
	IN	OPTIONAL	ULONG               SectionPageProtection,		// INPUT  : PAGE_READWRITE be default
	IN	OPTIONAL	ULONG               AllocationAttributes,		// INPUT  : SEC_COMMIT by default
	IN	OPTIONAL	HANDLE              FileHandle,					// INPUT  : NULL by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);



EXTERN HANDLE
NtOpenSection(
	IN	OPTIONAL	ACCESS_MASK			DesiredAccess,				// INPUT  : SECTION_ALL_ACCESS by default
	IN				POBJECT_ATTRIBUTES  ObjectAttributes,			// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);

EXTERN PVOID
NtMapViewOfSection(
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  OPTIONAL	PVOID				BaseAddress,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               AllocationType,				// INPUT  : NULL by default
	IN  OPTIONAL	ULONG               Protect,					// INPUT  : PAGE_READWRITE by default
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall

);


EXTERN VOID
NtUnmapViewOfSection(
	IN  OPTIONAL	HANDLE              ProcessHandle,				// INPUT  : in case of null, the function will run localy
	IN  			PVOID				BaseAddress,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);



EXTERN VOID
NtClose(
	IN				HANDLE              SectionHandle,				// INPUT  : can't be NULL
	OUT OPTIONAL	PNTSTATUS			STATUS						// OUTPUT : the return from the syscall
);



#endif // !SYSCALLS

```

`PP64Stub/Unpack.c`:

```c
#include <Windows.h>


#include "Debug.h"
#include "Structs.h"
#include "Utils.h"
#include "Syscalls.h"


typedef struct _InPeConfig {

	ULONG_PTR				pPeAddress;
	SIZE_T					sPeSize;

	PIMAGE_DOS_HEADER		pDosHdr;
	PIMAGE_NT_HEADERS		pNtHdr;


	PIMAGE_DATA_DIRECTORY	pEIDataDir;		//IMAGE_DIRECTORY_ENTRY_IMPORT
	PIMAGE_DATA_DIRECTORY	pTLSDataDir;	//IMAGE_DIRECTORY_ENTRY_TLS
	PIMAGE_DATA_DIRECTORY	pEBDataDir;		//IMAGE_DIRECTORY_ENTRY_BASERELOC
	PIMAGE_DATA_DIRECTORY	pEHDataDir;		//IMAGE_DIRECTORY_ENTRY_EXCEPTION

	PIMAGE_SECTION_HEADER	pSecHdr;

} InPeConfig, * PInPeConfig;





BOOL _InitPeStruct(PInPeConfig _Pe, PVOID pPeAddress, SIZE_T sPeSize) {

	// check input
	if (pPeAddress == NULL || sPeSize == NULL) {
		return FALSE;
	}

	// filling up the struct
	_Pe->pPeAddress = pPeAddress;
	_Pe->sPeSize = sPeSize;

	// filling up the struct with the headers

	
	_Pe->pDosHdr = (PIMAGE_DOS_HEADER)pPeAddress;
	// dos hdr check
	if (_Pe->pDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}
	
	_Pe->pNtHdr = (PIMAGE_NT_HEADERS)((PBYTE)pPeAddress + _Pe->pDosHdr->e_lfanew);
	// nt hdr check
	if (_Pe->pNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}
	
	// sections 
	_Pe->pEIDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	_Pe->pTLSDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	
	_Pe->pEBDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	_Pe->pEHDataDir = &_Pe->pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];

	_Pe->pSecHdr = (PIMAGE_SECTION_HEADER)((SIZE_T)_Pe->pNtHdr + sizeof(IMAGE_NT_HEADERS));
	
	//check
	if (_Pe->pDosHdr == NULL	|| _Pe->pNtHdr == NULL		||
		_Pe->pEIDataDir == NULL || _Pe->pTLSDataDir == NULL || _Pe->pEBDataDir == NULL || _Pe->pEHDataDir  == NULL ||
		_Pe->pSecHdr == NULL	
		){
		
		return FALSE;
	}
	//done
	return TRUE;
}




BOOL _FixImportAddressTable(InPeConfig _Pe, ULONG_PTR pPeAddress) {

	PIMAGE_IMPORT_DESCRIPTOR	pImgDes = NULL;

	/*
	// this work as well, in case u want to ignore the 'InPeConfig' parameter:
	PIMAGE_DOS_HEADER			pDosHdr = (PIMAGE_DOS_HEADER)pPeAddress;
	PIMAGE_NT_HEADERS			pNtHdr = (PIMAGE_NT_HEADERS)(pPeAddress + pDosHdr->e_lfanew);
	PIMAGE_DATA_DIRECTORY		pEIDataDir = &pNtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];;
	*/

	// loop through the dlls
	for (SIZE_T i = 0; i < _Pe.pEIDataDir->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

		pImgDes = (IMAGE_IMPORT_DESCRIPTOR*)(_Pe.pEIDataDir->VirtualAddress + (ULONG_PTR)pPeAddress + i);

		if (pImgDes->OriginalFirstThunk == NULL && pImgDes->FirstThunk == NULL) {
			break;
		}

		LPSTR		DllName		= (LPSTR)((ULONGLONG)pPeAddress + pImgDes->Name);
		ULONG_PTR	Head		= pImgDes->FirstThunk;
		ULONG_PTR	Next		= pImgDes->OriginalFirstThunk;
		SIZE_T		HeadSize	= 0;
		SIZE_T		NextSize	= 0;
		HMODULE		hModule		= LoadLibraryH(DllName);

		if (hModule == NULL) {
			return FALSE;
		}

		if (Next == NULL) {
			Next = pImgDes->FirstThunk;
		}
		
		// loop through functions inside the dll to import
		while (TRUE) {

			PIMAGE_THUNK_DATA			_1stThunk				= (IMAGE_THUNK_DATA*)(pPeAddress + HeadSize + Head);
			PIMAGE_THUNK_DATA			Orig1stThunk			= (IMAGE_THUNK_DATA*)(pPeAddress + NextSize + Next);
			PIMAGE_IMPORT_BY_NAME		FuncName				= NULL;
			ULONG_PTR					pFunction				= NULL;

			if (_1stThunk->u1.Function == NULL) {
				break;
			}

			// by ordinal
			if (Orig1stThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
				PIMAGE_DOS_HEADER		_dos;
				PIMAGE_NT_HEADERS		_nt;
				PIMAGE_EXPORT_DIRECTORY	_ExportDir;
				PDWORD					_FuncAddArray;
				
				_dos = (PIMAGE_DOS_HEADER)hModule;
				_nt = (PIMAGE_NT_HEADERS)(((ULONG_PTR)hModule) + _dos->e_lfanew);
				_ExportDir = (PIMAGE_EXPORT_DIRECTORY)(((ULONG_PTR)hModule) + _nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
				_FuncAddArray = (PDWORD)((ULONG_PTR)hModule + _ExportDir->AddressOfFunctions);
				
				pFunction = ((ULONG_PTR)hModule + _FuncAddArray[Orig1stThunk->u1.Ordinal]);

				//this work as well:
				//pFunction = (ULONG_PTR)GetProcAddress(hModule, (char*)(Orig1stThunk->u1.Ordinal & 0xFFFF));
			}
			// by name
			else {
				FuncName = (PIMAGE_IMPORT_BY_NAME)((SIZE_T)pPeAddress + Orig1stThunk->u1.AddressOfData);
				pFunction = (ULONG_PTR)GetProcAddressH(hModule, HASH(FuncName->Name));
				//this work as well:
				//pFunction = (ULONG_PTR)GetProcAddress(hModule, FuncName->Name);

			}

			if (pFunction == NULL) {
#ifdef DEBUG
				PRINTA("[!] Could Not Import !%s.%s \n", DllName, FuncName->Name);
#endif // DEBUG
				return FALSE;
			}

			_1stThunk->u1.Function = (ULONGLONG)pFunction;

			// next function
			HeadSize += sizeof(IMAGE_THUNK_DATA);
			NextSize += sizeof(IMAGE_THUNK_DATA);
			
		}
	}
	
	return TRUE;
}


// from https://github.com/Cracked5pider/KaynLdr/blob/main/KaynLdr/src/Win32.c#L139 && https://github.com/abhisek/Pe-Loader-Sample/blob/master/src/PeLdr.cpp#L18

BOOL _ReallocationSupport(ULONG_PTR ActualAddress, ULONG_PTR PreferableAddress, PIMAGE_BASE_RELOCATION BaseRelocDir){

	PIMAGE_BASE_RELOCATION  pImageBR = BaseRelocDir;
	ULONG_PTR				OffsetIB = ActualAddress - PreferableAddress;
	PBASE_RELOCATION_ENTRY	Reloc	 = NULL;

	while (pImageBR->VirtualAddress != 0){

		Reloc = (PBASE_RELOCATION_ENTRY)(pImageBR + 1);

		while ((PBYTE)Reloc != (PBYTE)pImageBR + pImageBR->SizeOfBlock){
			
			switch (Reloc->Type) {
				case IMAGE_REL_BASED_DIR64:
					*((ULONG_PTR*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += OffsetIB;
					break;
				case IMAGE_REL_BASED_HIGHLOW:
					*((DWORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += (DWORD)OffsetIB;
					break;

				case IMAGE_REL_BASED_HIGH:
					*((WORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += HIWORD(OffsetIB);
					break;

				case IMAGE_REL_BASED_LOW:
					*((WORD*)(ActualAddress + pImageBR->VirtualAddress + Reloc->Offset)) += LOWORD(OffsetIB);
					break;

				case IMAGE_REL_BASED_ABSOLUTE:
					break;

				default:
#ifdef DEBUG
					PRINT(L"[!] Unknown relocation type: 0x%08x \n", Reloc->Offset);
#endif // DEBUG
					return FALSE;
			}

			Reloc++;
		}

		pImageBR = (PIMAGE_BASE_RELOCATION)Reloc;
	}

	return TRUE;
}



VOID UnpackAndRunEp(PVOID pPeAddress, SIZE_T sPeSize, BOOL RunPe) {
	
	InPeConfig				_Pe1		= { 0 };
	ULONG_PTR				pAddress	= NULL;


	if (!_InitPeStruct(&_Pe1, pPeAddress, sPeSize)) {
#ifdef DEBUG
		PRINT(L"[!] Could Not Initialize The Pe Struct (Unpack.c:234)\n");
#endif // DEBUG
		return;
	}

	NtUnmapViewOfSection(NULL, _Pe1.pNtHdr->OptionalHeader.ImageBase, NULL);
	
	
	pAddress = (ULONG_PTR)NtAllocateVirtualMemory(NULL, _Pe1.pNtHdr->OptionalHeader.ImageBase, _Pe1.pNtHdr->OptionalHeader.SizeOfImage, NULL, NULL, NULL);
	if (pAddress == NULL) {
		pAddress = (ULONG_PTR)NtAllocateVirtualMemory2(_Pe1.pNtHdr->OptionalHeader.SizeOfImage, NULL);
		if (pAddress == NULL) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Allocate A Vaild Base Address For The Pe (Unpack.c:244)\n");
#endif // DEBUG
			return;
		}
	}

#ifdef DEBUG
	PRINT(L"[i] Preferable Address : 0x%p \n", _Pe1.pNtHdr->OptionalHeader.ImageBase);
	PRINT(L"[i] Actuall Allocated Address : 0x%p \n", pAddress);
	PRINT(L"[i] Allocation Size : %d \n", (unsigned int)_Pe1.pNtHdr->OptionalHeader.SizeOfImage);
#endif // DEBUG

	_memcpy(pAddress, pPeAddress, _Pe1.pNtHdr->OptionalHeader.SizeOfHeaders);


	for (int i = 0; i < _Pe1.pNtHdr->FileHeader.NumberOfSections; i++) {
#ifdef DEBUG
		PRINT(L"\t[%0.2d] Copying 0x%p To 0x%p Of Size : %d \n", i, (ULONG_PTR)pPeAddress + _Pe1.pSecHdr[i].VirtualAddress, pAddress + _Pe1.pSecHdr[i].PointerToRawData, _Pe1.pSecHdr[i].SizeOfRawData);
#endif // DEBUG

		_memcpy(pAddress + _Pe1.pSecHdr[i].VirtualAddress, (ULONG_PTR)pPeAddress + _Pe1.pSecHdr[i].PointerToRawData, _Pe1.pSecHdr[i].SizeOfRawData);
	}

	// fixing the iat
	if (!_FixImportAddressTable(_Pe1, pAddress)) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Fix The IAT (Unpack.c:273)\n");
#endif // DEBUG
		return;
	}

	// reallocation if needed
	if (pAddress != _Pe1.pNtHdr->OptionalHeader.ImageBase) {
#ifdef DEBUG
		PRINT(L"[i] The Allocated Mem Is Different Than The Preferable Address, Handling Reallocations ... \n");
#endif // DEBUG
		if (!_ReallocationSupport(pAddress, _Pe1.pNtHdr->OptionalHeader.ImageBase, (PIMAGE_BASE_RELOCATION)(pAddress + _Pe1.pEBDataDir->VirtualAddress))) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Fix The Re-Allocation (Unpack.c:285)\n");
#endif // DEBUG
			return;
		}
		
	}

	// registering exception handlers if needed
	if (_Pe1.pEHDataDir->Size){
#ifdef DEBUG
		PRINT(L"[i] Handling The Packed Pe's Exception Handlers ... \n");
#endif // DEBUG
		PIMAGE_RUNTIME_FUNCTION_ENTRY pImgRunFuncEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(pAddress + _Pe1.pEHDataDir->VirtualAddress);

		fnRtlAddFunctionTable pRtlAddFunctionTable = (fnRtlAddFunctionTable)GetProcAddressH(GetModuleHandleH(KERNEL32DLL), RtlAddFunctionTable_StrHashed);
		if (pRtlAddFunctionTable == NULL || (pRtlAddFunctionTable != NULL && !pRtlAddFunctionTable(pImgRunFuncEntry, (_Pe1.pEHDataDir->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1, pAddress))) {
#ifdef DEBUG
			PRINT(L"[!] RtlAddFunctionTable Failed (Unpack.c:302) [ %d ]\n", GetLastError());
#endif // DEBUG
		return;	// altho its prob okk in case of this failed
		}
	}


	if (!RefreshNtdll()) {
#ifdef DEBUG
			PRINT(L"[!] Failed To Refresh Ntdll's Text Section From Hooks [ Unpack.c:311 ]\n");
#endif // DEBUG
		 return;	// altho its prob okk in case of this failed
	}
	

	// fixing the permissions (needed before the tls callbacks handling)
	for (DWORD i = 0; i < _Pe1.pNtHdr->FileHeader.NumberOfSections; i++) {

		DWORD Protection = 0;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE)
			Protection = PAGE_WRITECOPY;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ)
			Protection = PAGE_READONLY;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_READWRITE;

		if (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
			Protection = PAGE_EXECUTE;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE))
			Protection = PAGE_EXECUTE_WRITECOPY;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READ;

		if ((_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (_Pe1.pSecHdr[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READWRITE;
		
#ifdef DEBUG
		PRINT(L"\t[%0.2d] Setting Mem Permissions To 0x%0.4X on [ 0x%p ]\n", i, Protection, (PVOID)(pAddress + _Pe1.pSecHdr[i].VirtualAddress));
#endif // DEBUG

		NtProtectVirtualMemory(NULL, (PVOID)(pAddress + _Pe1.pSecHdr[i].VirtualAddress), (SIZE_T)(_Pe1.pSecHdr[i].SizeOfRawData), Protection, NULL);
	}


	// tls callback handling if needed
	if (_Pe1.pTLSDataDir->Size) {
#ifdef DEBUG
		PRINT(L"[i] Found Tls Callbacks, Setting Up For Execution ... \n");
#endif // DEBUG

		PIMAGE_TLS_DIRECTORY pImgTlsDir = (PIMAGE_TLS_DIRECTORY)(pAddress + _Pe1.pTLSDataDir->VirtualAddress);
		PIMAGE_TLS_CALLBACK* ppCallback = (PIMAGE_TLS_CALLBACK*)(pImgTlsDir->AddressOfCallBacks);
		for (; *ppCallback; ppCallback++) {
			(*ppCallback)((LPVOID)pAddress, DLL_PROCESS_ATTACH, NULL);
		}
	}


	PVOID EP = (PVOID)(pAddress + _Pe1.pNtHdr->OptionalHeader.AddressOfEntryPoint);

	// clean everything before .txt section ( ~ 4096 bytes )
	_ZeroMemory(pAddress, (SIZE_T)_Pe1.pSecHdr[0].VirtualAddress);

#ifdef DEBUG
	PRINT(L"[i] Running The Packed Pe's Entry Point ... \n\n\n");
#endif // DEBUG
	
	// you can do it with other ways
	((VOID(*)())EP)();
}



```

`PP64Stub/Utils.c`:

```c
#include <Windows.h>

#include "Debug.h"
#include "Structs.h"
#include "Utils.h"
#include "Syscalls.h"

//==============================================================================================================================================================================



BOOL InitializeDirectNtCalls() {
	HashStruct SyscallHashStruct = {

		.NtAllocateVirtualMemory_Hash	= NtAllocateVirtualMemory_StrHashed,
		.NtProtectVirtualMemory_Hash	= NtProtectVirtualMemory_StrHashed,
		.NtCreateSection_Hash			= NtCreateSection_StrHashed,
		.NtOpenSection_Hash				= NtOpenSection_StrHashed,
		.NtMapViewOfSection_Hash		= NtMapViewOfSection_StrHashed,
		.NtUnmapViewOfSection_Hash		= NtUnmapViewOfSection_StrHashed,
		.NtClose_Hash					= NtClose_StrHashed,

	};


	return InitializeStruct(SEED, &SyscallHashStruct);
}


//==============================================================================================================================================================================



//==============================================================================================================================================================================



LPVOID GetDllFromKnownDlls(PWSTR DllName) {

	PVOID pModule = NULL;
	HANDLE hSection = INVALID_HANDLE_VALUE;
	UNICODE_STRING UniStr;
	OBJECT_ATTRIBUTES ObjAtr;
	NTSTATUS STATUS;

	WCHAR FullName[MAX_PATH];
	WCHAR Buf[MAX_PATH] = { L'\\', L'K', L'n', L'o', L'w', L'n', L'D', L'l', L'l', L's', L'\\' };

	_strcpy(FullName, Buf);
	_strcat(FullName, DllName);
	_RtlInitUnicodeString(&UniStr, FullName);


	InitializeObjectAttributes(
		&ObjAtr,
		&UniStr,
		0x40L,
		NULL,
		NULL
	);


	hSection = NtOpenSection(SECTION_MAP_READ | SECTION_MAP_EXECUTE, &ObjAtr, &STATUS);
	if (!NT_SUCCESS(STATUS) || hSection == INVALID_HANDLE_VALUE) {
#ifdef DEBUG
		PRINT(L"[!] %s : NtOpenSection Failed : 0x%0.8X (Utils.c:63)\n", FullName, STATUS);	
#endif // DEBUG
		return NULL;
	}


	pModule = NtMapViewOfSection(hSection, NULL, NULL, NULL, PAGE_READONLY, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] %s : NtMapViewOfSection Failed : 0x%0.8X (Utils.c:72)\n", FullName, STATUS);
#endif // DEBUG
		return NULL;
	}

#ifdef DEBUG
	PRINT(L"[+] The module \"%s\" is successfully mapped to 0x%p \n", FullName, pModule);
#endif // DEBUG

	return pModule;
}




BOOL RefreshNtdll() {
	
	NTSTATUS	STATUS			= NULL;
	DWORD		OldProtection	= NULL;
	PVOID		pLocalAddress	= NULL, pRemoteAddress	= NULL;
	SIZE_T		sLocalSize		= NULL;

	LPVOID		KnownDllNtdllModule		= GetDllFromKnownDlls((PWSTR)NTDLLDLLW);
	LPVOID		CurrentNtdllModule		= GetModuleHandleH(NTDLLDLLA);

	if (KnownDllNtdllModule == NULL || CurrentNtdllModule == NULL) {
		return FALSE;
	}
	PIMAGE_DOS_HEADER		CurrentNtdllDosHdr = (PIMAGE_DOS_HEADER)CurrentNtdllModule;
	if (CurrentNtdllDosHdr->e_magic != IMAGE_DOS_SIGNATURE){
		return FALSE;
	}
	PIMAGE_NT_HEADERS		CurrentNtdllNtHdr = (PIMAGE_NT_HEADERS)((ULONG_PTR)CurrentNtdllModule + CurrentNtdllDosHdr->e_lfanew);
	if (CurrentNtdllNtHdr->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}
	
	
	for (int i = 0; i < CurrentNtdllNtHdr->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER pImgSec = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(CurrentNtdllNtHdr) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
		if ((*(ULONG*)pImgSec->Name | 0x20202020) == 'xet.') {
			sLocalSize = pImgSec->Misc.VirtualSize;
			pLocalAddress = (PVOID)((ULONG_PTR)CurrentNtdllModule + pImgSec->VirtualAddress);
			pRemoteAddress = (PVOID)((ULONG_PTR)KnownDllNtdllModule + pImgSec->VirtualAddress);
		}
	}

	if (sLocalSize == NULL || pLocalAddress == NULL || pRemoteAddress == NULL) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Get Details Of The Txt Section Of The Module To Replace (Utils.c:122)\n");
#endif // DEBUG
		return FALSE;
	}

	// change protection to start patching
	OldProtection = NtProtectVirtualMemory(NULL, pLocalAddress, sLocalSize, PAGE_EXECUTE_WRITECOPY, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtProtectVirtualMemory [1] Failed : 0x%0.8X (Utils.c:130)\n", STATUS);
#endif
		return FALSE;
	}

#ifdef DEBUG
	PRINT(L"[i] Replacing 0x%p with 0x%p of size  %d \n", pLocalAddress, pRemoteAddress, sLocalSize);
#endif
	// replacing
	_memcpy(pLocalAddress, pRemoteAddress, sLocalSize);


	// re-fix the memory permissions to what it was
	NtProtectVirtualMemory(NULL, pLocalAddress, sLocalSize, OldProtection, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtProtectVirtualMemory [2] Failed : 0x%0.8X (Utils.c:146)\n", STATUS);
#endif
		return FALSE;
	}

	NtUnmapViewOfSection(NULL, KnownDllNtdllModule, &STATUS);
	if (!NT_SUCCESS(STATUS)) {
#ifdef DEBUG
		PRINT(L"[!] NtUnmapViewOfSection  Failed : 0x%0.8X (Utils.c:154)\n", STATUS);
#endif
		return FALSE;
	}
	
	return TRUE;
}

//==============================================================================================================================================================================






//==============================================================================================================================================================================


HMODULE GetModuleHandleH(LPSTR ModuleName) {
	if (ModuleName == NULL)
		return NULL;
	
	PPEB pPeb = (PPEB)__readgsqword(0x60);
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);
	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);
	
	while (pDte) {
		if (pDte->FullDllName.Buffer != NULL) {
			if (pDte->FullDllName.Length < MAX_PATH - 1) {
				CHAR DllName[MAX_PATH] = { 0 };
				DWORD i = 0;
				while (pDte->FullDllName.Buffer[i] && i < sizeof(DllName) - 1) {
					DllName[i] = _ToUpper((char)pDte->FullDllName.Buffer[i]);
					i++;
				}
				DllName[i] = '\0';
				if (HASH(DllName) == HASH(ModuleName)) {
					return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
				}
			}
		}
		else {
			break;
		}

		pDte = (PLDR_DATA_TABLE_ENTRY)DEREF_64(pDte);
	}
	return NULL;
}



HMODULE LoadLibraryH(LPSTR DllName) {

	NTSTATUS		STATUS				= NULL;
	UNICODE_STRING	Ustr				= { 0 };
	WCHAR			wDllName[MAX_PATH]	= { 0 };
	HMODULE			hModule				= NULL;

	_CharToWchar(wDllName, DllName, _StrlenA(DllName));

	USHORT DestSize = _StrlenW(wDllName) * sizeof(WCHAR);
	Ustr.Length = DestSize;
	Ustr.MaximumLength = DestSize + sizeof(WCHAR);
	Ustr.Buffer = wDllName;


	fnLdrLoadDll pLdrLoadDll = (fnLdrLoadDll)GetProcAddressH(GetModuleHandleH(NTDLLDLLA), LdrLoadDll_StrHashed);
	if(pLdrLoadDll != NULL && NT_SUCCESS((STATUS = pLdrLoadDll(NULL, 0, &Ustr, &hModule)))){
		return hModule;
	}
#ifdef DEBUG
	PRINT(L"[!] LdrLoadDll Faild To Load \"%s\" 0x%0.8X (Utils.c:224)\n", wDllName, STATUS);
#endif // DEBUG

	return NULL;
}



FARPROC GetProcAddressH (HMODULE hModule, DWORD Hash) {

	if (hModule == NULL || Hash == NULL)
		return NULL;

	HMODULE hModule2 = NULL;
	UINT64	DllBaseAddress = (UINT64)hModule;

	PIMAGE_NT_HEADERS NtHdr = (PIMAGE_NT_HEADERS)(DllBaseAddress + ((PIMAGE_DOS_HEADER)DllBaseAddress)->e_lfanew);
	PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)&NtHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	PIMAGE_EXPORT_DIRECTORY ExportTable = (PIMAGE_EXPORT_DIRECTORY)(DllBaseAddress + pDataDir->VirtualAddress);

	UINT64 FunctionNameAddressArray = (DllBaseAddress + ExportTable->AddressOfNames);
	UINT64 FunctionAddressArray = (DllBaseAddress + ExportTable->AddressOfFunctions);
	UINT64 FunctionOrdinalAddressArray = (DllBaseAddress + ExportTable->AddressOfNameOrdinals);
	UINT64 pFunctionAddress = NULL;

	DWORD	dwCounter = ExportTable->NumberOfNames;

	while (dwCounter--) {
		char* FunctionName = (char*)(DllBaseAddress + DEREF_32(FunctionNameAddressArray));

		if (HASH(FunctionName) == Hash) {
			FunctionAddressArray += (DEREF_16(FunctionOrdinalAddressArray) * sizeof(DWORD));
			pFunctionAddress = (UINT64)(DllBaseAddress + DEREF_32(FunctionAddressArray));

			if (pDataDir->VirtualAddress <= DEREF_32(FunctionAddressArray) && (pDataDir->VirtualAddress + pDataDir->Size) >= DEREF_32(FunctionAddressArray)) {
				CHAR Library[MAX_PATH] = { 0 };
				CHAR Function[MAX_PATH] = { 0 };
				UINT32 Index = _CopyDotStr((PCHAR)pFunctionAddress);
				if (Index == 0) {
					return NULL;
				}
				_memcpy((PVOID)Library, (PVOID)pFunctionAddress, Index);
				_memcpy((PVOID)Function, (PVOID)((ULONG_PTR)pFunctionAddress + Index + 1), _StrlenA((LPCSTR)((ULONG_PTR)pFunctionAddress + Index + 1)));
				if ((hModule2 = LoadLibraryH(Library)) != NULL) {
					pFunctionAddress = (UINT64)GetProcAddressH(hModule2, HASH(Function));
				}
			}
			break;
		}
		FunctionNameAddressArray += sizeof(DWORD);
		FunctionOrdinalAddressArray += sizeof(WORD);
	}
	return (FARPROC)pFunctionAddress;
}





//==============================================================================================================================================================================






```

`PP64Stub/Utils.h`:

```h
/*
	this file contains the common functions called, as well other stuff (macros, typedefs ...)
*/

#pragma once

#include <Windows.h>

#ifndef COMMON
#define COMMON

#include "Structs.h"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// macros:


#define SEED 0x07

#define DEREF( name )		*(	UINT_PTR	*)	(name)
#define DEREF_64( name )	*(	DWORD64		*)	(name)
#define DEREF_32( name )	*(	DWORD		*)	(name)
#define DEREF_16( name )	*(	WORD		*)	(name)
#define DEREF_8( name )		*(	BYTE		*)	(name)

#define HASH(API)		(_HashStringRotr32A((PCHAR) API))


#define NTDLLDLLA								"NTDLL.DLL"
#define NTDLLDLLW								L"NTDLL.DLL"
#define KERNEL32DLL								"KERNEL32.DLL"


#define ATOM_StrHashed							0x9F520B2D

#define NtAllocateVirtualMemory_StrHashed       0x014044AE
#define NtProtectVirtualMemory_StrHashed        0xE67C7320
#define NtCreateSection_StrHashed				0xAC2EDA02
#define NtOpenSection_StrHashed					0xD443EC8C
#define NtMapViewOfSection_StrHashed			0x92DD00B3
#define NtUnmapViewOfSection_StrHashed			0x12D71086
#define NtClose_StrHashed						0x7B3F64A4

#define LdrLoadDll_StrHashed					0xCC4C8B22
#define RtlAddFunctionTable_StrHashed			0x9219585C


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// typedefs:


typedef NTSTATUS(NTAPI* fnLdrLoadDll)(
	PWCHAR             PathToFile,
	ULONG              Flags,
	PUNICODE_STRING    ModuleFileName,
	PHANDLE            ModuleHandle
	);

typedef BOOLEAN(WINAPI* fnRtlAddFunctionTable)(
	PRUNTIME_FUNCTION FunctionTable,
	DWORD             EntryCount,
	DWORD64           BaseAddress
	);


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Unpack.c (255):

VOID UnpackAndRunEp(PVOID pPeAddress, SIZE_T sPeSize, BOOL RunPe);



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Utils.c:


// fill up the direct syscalls struct (using a function from my Syscallslib library)
BOOL InitializeDirectNtCalls();
// overwrite the .txt section of ntdll.dll (copied from \knowndll\) to unhook ...
BOOL RefreshNtdll();

// custom getmodulehandlea
HMODULE GetModuleHandleH(LPSTR ModuleName);
// custom loadlibrarya (using LdrLoadDll)
HMODULE LoadLibraryH(LPSTR DllName);
// custom getprocaddress (via hashing)
FARPROC GetProcAddressH(HMODULE hModule, DWORD Hash);


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// General.c

/*
	these are helper functions, used to avoid crt functions  ...
*/

VOID		_RtlInitUnicodeString(PUNICODE_STRING target, PCWSTR source);
SIZE_T		_CharToWchar(PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed);

wchar_t*	_strcatW(wchar_t* dest, const wchar_t* src);
wchar_t*	_strcpyW(wchar_t* dest, const wchar_t* src);
char*		_strcatA(char* dest, const char* src);
char*		_strcpyA(char* dest, const char* src);

SIZE_T		_StrlenA(LPCSTR String);
SIZE_T		_StrlenW(LPCWSTR String);

DWORD		_HashStringRotr32A(PCHAR String);
VOID		_ZeroMemory(PVOID Destination, SIZE_T Size);
PVOID		_memcpy(void* dst, const void* src, SIZE_T count);
CHAR		_ToUpper(CHAR c);
UINT32		_CopyDotStr(PCHAR String);

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------



#endif // !COMMON

```

`PP64Stub/common.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/common.h - definitions common to both compression and
 *                     decompression
 */

#ifndef __EASYLZMACOMMON_H__ 
#define __EASYLZMACOMMON_H__ 

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/* msft dll export gunk.  To build a DLL on windows, you
 * must define WIN32, EASYLZMA_SHARED, and EASYLZMA_BUILD.  To use a 
 * DLL, you must define EASYLZMA_SHARED and WIN32 */
#if defined(WIN32) && defined(EASYLZMA_SHARED)
#  ifdef EASYLZMA_BUILD
#    define EASYLZMA_API __declspec(dllexport)
#  else
#    define EASYLZMA_API __declspec(dllimport)
#  endif
#else
#  define EASYLZMA_API
#endif 

/** error codes */

/** no error */
#define ELZMA_E_OK                               0
/** bad parameters passed to an ELZMA function */
#define ELZMA_E_BAD_PARAMS                      10
/** could not initialize the encode with configured parameters. */
#define ELZMA_E_ENCODING_PROPERTIES_ERROR       11
/** an error occured during compression (XXX: be more specific) */
#define ELZMA_E_COMPRESS_ERROR                  12
/** currently unsupported lzma file format was specified*/
#define ELZMA_E_UNSUPPORTED_FORMAT              13
/** an error occured when reading input */
#define ELZMA_E_INPUT_ERROR                     14
/** an error occured when writing output */
#define ELZMA_E_OUTPUT_ERROR                    15
/** LZMA header couldn't be parsed */
#define ELZMA_E_CORRUPT_HEADER                  16
/** an error occured during decompression (XXX: be more specific) */
#define ELZMA_E_DECOMPRESS_ERROR                17
/** the input stream returns EOF before the decompression could complete */
#define ELZMA_E_INSUFFICIENT_INPUT              18
/** for formats which have an emebedded crc, this error would indicated that
 *  what came out was not what went in, i.e. data corruption */
#define ELZMA_E_CRC32_MISMATCH                  19
/** for formats which have an emebedded uncompressed content length,
 *  this error indicates that the amount we read was not what we expected */
#define ELZMA_E_SIZE_MISMATCH                   20


/** Supported file formats */
typedef enum {
    ELZMA_lzip, /**< the lzip format which includes a magic number and
                 *   CRC check */
    ELZMA_lzma  /**< the LZMA-Alone format, originally designed by
                 *   Igor Pavlov and in widespread use due to lzmautils,
                 *   lacking both aforementioned features of lzip */
/* XXX: future, potentially   ,
    ELZMA_xz 
*/
} elzma_file_format;

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process has generated [de]compressed output.
 *
 * the size parameter indicates how much data is in buf to be written.
 * it is required that the write callback consume all data, and a return
 * value not equal to input size indicates and error.
 */
typedef size_t (*elzma_write_callback)(void *ctx, const void *buf,
                                       size_t size);

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process requires more [un]compressed input.
 *
 * the size parameter is an in/out argument.  on input it indicates
 * the buffer size.  on output it indicates the amount of data read into
 * buf.  when *size is zero on output it indicates EOF.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef int (*elzma_read_callback)(void *ctx, void *buf,
                                   size_t *size);

/**
 * A callback invoked during elzma_[de]compress_run to report progress
 * on the [de]compression.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef void (*elzma_progress_callback)(void *ctx, size_t complete,
                                        size_t total);


/** pointer to a malloc function, supporting client overriding memory
 *  allocation routines */
typedef void * (*elzma_malloc)(void *ctx, unsigned int sz);

/** pointer to a free function, supporting client overriding memory
 *  allocation routines */
typedef void (*elzma_free)(void *ctx, void * ptr);

#ifdef __cplusplus
};
#endif    

#endif

```

`PP64Stub/decompress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/decompress.h - The API for LZMA decompression using easylzma
 */

#ifndef __EASYLZMADECOMPRESS_H__ 
#define __EASYLZMADECOMPRESS_H__ 

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif    

/** an opaque handle to an lzma decompressor */
typedef struct _elzma_decompress_handle * elzma_decompress_handle;

/**
 * Allocate a handle to an LZMA decompressor object.
 */ 
elzma_decompress_handle EASYLZMA_API elzma_decompress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_decompress_set_allocation_callbacks(
    elzma_decompress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA decompressor object.
 */ 
void EASYLZMA_API elzma_decompress_free(elzma_decompress_handle * hand);

/**
 * Perform decompression
 *
 * XXX: should the library automatically detect format by reading stream?
 *      currently it's based on data external to stream (such as extension
 *      or convention)
 */ 
int EASYLZMA_API elzma_decompress_run(
    elzma_decompress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_file_format format);


#ifdef __cplusplus
};
#endif    

#endif

```

`PP64Stub/easylzma.c`:

```c
#include <string.h>
#include <assert.h>
#include "easylzma.h"
#include "Crt.h"

struct dataStream
{
    const unsigned char* inData;
    size_t inLen;

    unsigned char* outData;
    size_t outLen;
};

static int
inputCallback(void* ctx, void* buf, size_t* size)
{
    size_t rd = 0;
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    rd = (ds->inLen < *size) ? ds->inLen : *size;

    if (rd > 0) {
        // memcpy replacement
        memcpy(buf, (void*)ds->inData, rd);
        ds->inData += rd;
        ds->inLen -= rd;
    }

    *size = rd;

    return 0;
}

static size_t
outputCallback(void* ctx, const void* buf, size_t size)
{
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    if (size > 0) {
        // realloc replacement 
        ds->outData = realloc((PVOID)ds->outData, (SIZE_T) ds->outLen + size);
        // memcpy replacement
        memcpy((void*)(ds->outData + ds->outLen), buf, size);
        ds->outLen += size;
    }

    return size;
}


int
simpleDecompress(elzma_file_format format, const unsigned char* inData,
    size_t inLen, unsigned char** outData,
    size_t* outLen)
{
    int rc;
    elzma_decompress_handle hand;

    hand = elzma_decompress_alloc();

    /* now run the compression */
    {
        struct dataStream ds;
        ds.inData = inData;
        ds.inLen = inLen;
        ds.outData = NULL;
        ds.outLen = 0;

        rc = elzma_decompress_run(hand, inputCallback, (void*)&ds,
            outputCallback, (void*)&ds, format);

        if (rc != ELZMA_E_OK) {
            // free replacment
            if (ds.outData != NULL) free(ds.outData);
            elzma_decompress_free(&hand);
            return rc;
        }

        elzma_decompress_free(&hand);
        *outData = ds.outData;
        *outLen = ds.outLen;
    }

    return rc;
}

```

`PP64Stub/easylzma.h`:

```h
#pragma once


#ifndef _EASYLZMA_H
#define _EASYLZMA_H

#include "decompress.h"


/* decompress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
int simpleDecompress(elzma_file_format format,
    const unsigned char* inData,
    size_t inLen,
    unsigned char** outData,
    size_t* outLen);


#endif // !_EASYLZMA_H

```

`PP64Stub/main.c`:

```c
/*
	ORCA (@ORCx41) : The Program's EP 
*/

#include <Windows.h>

#include "Debug.h"
#include "Utils.h"
#include "IatCamouflage.h"
#include "easylzma.h"

#pragma comment (lib, "easylzma_s.lib")
#pragma comment (lib, "Syscalls.lib")

#pragma comment(linker,"/ENTRY:main")
#pragma warning( disable : 4996)




int main() {

#if _WIN64								
	PPEB pPeb = (PPEB)__readgsqword(0x60);
#elif _WIN32							
	PPEB pPeb = (PPEB)(__readfsdword(0x30));
#else									
	PPEB pPeb = NULL;
#endif

	CamouflageImports(0xFF);

	if (pPeb == NULL || (pPeb != NULL && pPeb->OSMajorVersion != 0xA)) {
		return -1;
	}
	
	unsigned int	iError = ELZMA_E_OK;
	unsigned char*	_OutputUnpackedData = NULL;
	size_t			_OutputUnpackedSize = NULL;

	CHAR* pBaseAddress = (CHAR*)pPeb->ImageBaseAddress;
	PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBaseAddress;
	PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBaseAddress + pImgDosHdr->e_lfanew);
	PIMAGE_SECTION_HEADER pImgSectionHdr = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdr) + sizeof(IMAGE_NT_HEADERS));
	PVOID  pData = NULL;
	SIZE_T sSize = NULL;
	for (size_t i = 0; i <= pImgNtHdr->FileHeader.NumberOfSections; i++) {
		if (ATOM_StrHashed == HASH(pImgSectionHdr->Name)) {
			pData = (PVOID)((ULONG_PTR)pBaseAddress + pImgSectionHdr->VirtualAddress);
			sSize = pImgSectionHdr->SizeOfRawData;
			break;
		}
		pImgSectionHdr = (PIMAGE_SECTION_HEADER)((PBYTE)pImgSectionHdr + (DWORD)sizeof(IMAGE_SECTION_HEADER));
	}

	if (pData == NULL || sSize == NULL) {
#ifdef DEBUG
		PRINT(L"[!] Could Not Find .ATOM Section ! (main:56)\n");
#endif // DEBUG
		return -1;
	}

#ifdef DEBUG
	PRINT(L"[i] .ATOM Section Data : 0x%p\n", pData);
	PRINT(L"[i] .ATOM Section Size : %d \n",   sSize);
#endif // DEBUG


	if (!InitializeDirectNtCalls()) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Initialize Direct Syscalls Struct (main.c:69)\n");
#endif // DEBUG
		return -1;
	}
	

	if ((iError = simpleDecompress(ELZMA_lzma, pData, sSize, &_OutputUnpackedData, &_OutputUnpackedSize)) != ELZMA_E_OK) {
#ifdef DEBUG
		PRINT(L"[!] Failed To Decompress Data (main:77) %d \n", iError);
#endif // DEBUG
		return -1;
	}


#ifdef DEBUG
	PRINT(L"[+] Decompressed Data Output : 0x%p \n", _OutputUnpackedData);
	PRINT(L"[+] Decompressed Size Output : %d \n",  _OutputUnpackedSize);
#endif // DEBUG


	UnpackAndRunEp(_OutputUnpackedData, _OutputUnpackedSize, TRUE);

	return 0;
}


```

`PePacker64.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32421.90
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PePacker", "PePacker64\PePacker64.vcxproj", "{D0738EA1-814C-4D92-B15C-233EF61D6A8E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PP64Stub", "PP64Stub\PP64Stub.vcxproj", "{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ArgsTest", "Test\ArgsTest\ArgsTest.vcxproj", "{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TlsTest", "Test\TlsTest\TlsTest.vcxproj", "{D7230508-506A-4D1C-A840-28E38057BC0F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Hasher", "Helper\Hasher\Hasher.vcxproj", "{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllPP64Stub", "DllPP64Stub\DllPP64Stub.vcxproj", "{AE237528-7F07-43B2-A315-C6B43448E5E6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Debug|x64.ActiveCfg = Debug|x64
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Debug|x64.Build.0 = Debug|x64
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Debug|x86.ActiveCfg = Debug|Win32
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Debug|x86.Build.0 = Debug|Win32
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Release|x64.ActiveCfg = Release|x64
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Release|x64.Build.0 = Release|x64
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Release|x86.ActiveCfg = Release|Win32
		{D0738EA1-814C-4D92-B15C-233EF61D6A8E}.Release|x86.Build.0 = Release|Win32
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Debug|x64.ActiveCfg = Debug|x64
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Debug|x64.Build.0 = Debug|x64
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Debug|x86.ActiveCfg = Debug|Win32
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Debug|x86.Build.0 = Debug|Win32
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Release|x64.ActiveCfg = Release|x64
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Release|x64.Build.0 = Release|x64
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Release|x86.ActiveCfg = Release|Win32
		{AD3A3406-BE90-4DBB-ABED-C411D9D6309D}.Release|x86.Build.0 = Release|Win32
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Debug|x64.ActiveCfg = Debug|x64
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Debug|x64.Build.0 = Debug|x64
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Debug|x86.ActiveCfg = Debug|Win32
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Debug|x86.Build.0 = Debug|Win32
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Release|x64.ActiveCfg = Release|x64
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Release|x64.Build.0 = Release|x64
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Release|x86.ActiveCfg = Release|Win32
		{2451FB29-F1A4-4AC1-ADF9-5A68C6458B07}.Release|x86.Build.0 = Release|Win32
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Debug|x64.ActiveCfg = Debug|x64
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Debug|x64.Build.0 = Debug|x64
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Debug|x86.ActiveCfg = Debug|Win32
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Debug|x86.Build.0 = Debug|Win32
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Release|x64.ActiveCfg = Release|x64
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Release|x64.Build.0 = Release|x64
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Release|x86.ActiveCfg = Release|Win32
		{D7230508-506A-4D1C-A840-28E38057BC0F}.Release|x86.Build.0 = Release|Win32
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Debug|x64.ActiveCfg = Debug|x64
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Debug|x64.Build.0 = Debug|x64
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Debug|x86.ActiveCfg = Debug|Win32
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Debug|x86.Build.0 = Debug|Win32
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Release|x64.ActiveCfg = Release|x64
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Release|x64.Build.0 = Release|x64
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Release|x86.ActiveCfg = Release|Win32
		{1BF8A1AC-560F-439C-B4FB-2CB8DDB9E9E9}.Release|x86.Build.0 = Release|Win32
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Debug|x64.ActiveCfg = Debug|x64
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Debug|x64.Build.0 = Debug|x64
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Debug|x86.ActiveCfg = Debug|Win32
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Debug|x86.Build.0 = Debug|Win32
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Release|x64.ActiveCfg = Release|x64
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Release|x64.Build.0 = Release|x64
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Release|x86.ActiveCfg = Release|Win32
		{AE237528-7F07-43B2-A315-C6B43448E5E6}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {71274344-8593-4799-8D88-124EFB997158}
	EndGlobalSection
EndGlobal

```

`PePacker64/Header.h`:

```h
#pragma once

BOOL CreateNewSection(HANDLE hFile, DWORD dwSectionSize, PBYTE pSectionData);
```

`PePacker64/NewSection.c`:

```c
#include <windows.h>
#include <stdio.h>

#include "Header.h"

//https://github.com/hMihaiDavid/addscn/blob/master/addscn/addscn.cpp

#define P2ALIGNDOWN(x, align) ((x) & -(align))
#define P2ALIGNUP(x, align) (-(-(x) & -(align)))

#ifdef _WIN64
#define MACHINE IMAGE_FILE_MACHINE_AMD64
#else
#define MACHINE IMAGE_FILE_MACHINE_I386
#endif

typedef struct MyStruct
{
	HANDLE hFile;
	HANDLE hFileMapping;
	PBYTE  pView;
};


struct MyStruct NewSection = { 0 };


PBYTE MapFileReadOnly() {

	NewSection.hFileMapping = CreateFileMapping(NewSection.hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	if (NewSection.hFileMapping == INVALID_HANDLE_VALUE) {
		// error
	}

	NewSection.pView = (PBYTE)MapViewOfFile(NewSection.hFileMapping, FILE_MAP_READ, 0, 0, 0);
	if (NewSection.pView == NULL){
		// error
	}

	if (NewSection.hFileMapping == INVALID_HANDLE_VALUE) {
		CloseHandle(NewSection.hFile);
	}

	return NewSection.pView;

}



PBYTE MapFileRWNewSize(DWORD newSize) {

	NewSection.hFileMapping = CreateFileMapping(NewSection.hFile, NULL, PAGE_READWRITE, 0, newSize, NULL);

	if (NewSection.hFileMapping == INVALID_HANDLE_VALUE) {
		// error
	}

	NewSection.pView = (PBYTE)MapViewOfFile(NewSection.hFileMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	if (NewSection.pView == NULL) {
		// error
	}

	if (NewSection.hFileMapping == INVALID_HANDLE_VALUE) {
		CloseHandle(NewSection.hFile);
	}

	return NewSection.pView;

}

BOOL Unmap() {
	return (UnmapViewOfFile((PVOID)NewSection.pView) && CloseHandle(NewSection.hFileMapping));
}


BOOL AppendNewSectionHeader(DWORD dwFileSizeLow, PSTR name, DWORD VirtualSize, DWORD Characteristics, PBYTE pSectionData) {
	
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)NewSection.pView;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((UINT_PTR)NewSection.pView + dosHeader->e_lfanew);
	WORD sizeOfOptionalHeader = ntHeaders->FileHeader.SizeOfOptionalHeader;
	PIMAGE_FILE_HEADER fileHeader = &(ntHeaders->FileHeader);
	PIMAGE_SECTION_HEADER firstSectionHeader = (PIMAGE_SECTION_HEADER)(((UINT_PTR)fileHeader) + sizeof(IMAGE_FILE_HEADER) + sizeOfOptionalHeader);
	
	WORD numberOfSections = ntHeaders->FileHeader.NumberOfSections;
	DWORD sectionAlignment = ntHeaders->OptionalHeader.SectionAlignment;
	DWORD fileAlignment = ntHeaders->OptionalHeader.FileAlignment;

	PIMAGE_SECTION_HEADER newSectionHeader = &firstSectionHeader[numberOfSections];
	PIMAGE_SECTION_HEADER lastSectionHeader = &firstSectionHeader[numberOfSections - 1];


	memset(newSectionHeader, 0, sizeof(IMAGE_SECTION_HEADER));
	memcpy(&newSectionHeader->Name, name, min(strlen(name), 8));
	newSectionHeader->Misc.VirtualSize = VirtualSize;
	newSectionHeader->VirtualAddress = P2ALIGNUP(lastSectionHeader->VirtualAddress + lastSectionHeader->Misc.VirtualSize, sectionAlignment);
	newSectionHeader->SizeOfRawData = P2ALIGNUP(VirtualSize, fileAlignment);
	newSectionHeader->PointerToRawData = dwFileSizeLow;
	newSectionHeader->Characteristics = Characteristics;
	numberOfSections++;
	ntHeaders->FileHeader.NumberOfSections = numberOfSections;
	ntHeaders->OptionalHeader.SizeOfImage = P2ALIGNUP(newSectionHeader->VirtualAddress + newSectionHeader->Misc.VirtualSize, sectionAlignment);


	//memset((PVOID)((UINT_PTR)NewSection.pView + newSectionHeader->PointerToRawData), 0, newSectionHeader->SizeOfRawData);

	memcpy((PVOID)((UINT_PTR)NewSection.pView + newSectionHeader->PointerToRawData), pSectionData, newSectionHeader->SizeOfRawData);
}




BOOL CreateNewSection(HANDLE hFile, DWORD dwSectionSize, PBYTE pSectionData) {

	DWORD dwFileSizeLow, dwFileSizeHigh;
	PBYTE pView			= NULL;
	NewSection.hFile	= hFile;
	
	CHAR str_section_name[9] = ".ATOM";

	if (NewSection.hFile == NULL) {
		return FALSE;
	}

	dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
	if (dwFileSizeHigh != NULL) {
		// error
		CloseHandle(hFile);
		return FALSE;
	}

	if ((pView = MapFileReadOnly()) == NULL) {
		CloseHandle(hFile);
		return FALSE;
	}

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)pView;
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
		// error
	}
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((UINT_PTR)pView + dosHeader->e_lfanew);
	if (ntHeaders->Signature != IMAGE_NT_SIGNATURE || ntHeaders->FileHeader.Machine != MACHINE) {
		//error
	}


	WORD numberOfSections = ntHeaders->FileHeader.NumberOfSections;
	DWORD sectionAlignment = ntHeaders->OptionalHeader.SectionAlignment;
	DWORD fileAlignment = ntHeaders->OptionalHeader.FileAlignment;


	PIMAGE_FILE_HEADER fileHeader = &(ntHeaders->FileHeader);

	WORD sizeOfOptionalHeader = ntHeaders->FileHeader.SizeOfOptionalHeader;
	PIMAGE_SECTION_HEADER firstSectionHeader = (PIMAGE_SECTION_HEADER)(((UINT_PTR)fileHeader) + sizeof(IMAGE_FILE_HEADER) + sizeOfOptionalHeader);
	PIMAGE_SECTION_HEADER newSectionHeader = &firstSectionHeader[numberOfSections];
	PBYTE firstByteOfSectionData = (PBYTE)(((DWORD)firstSectionHeader->PointerToRawData) + (UINT_PTR)pView);

	SIZE_T available_space = ((UINT_PTR)firstByteOfSectionData) - ((UINT_PTR)newSectionHeader);
	if (available_space < sizeof(IMAGE_SECTION_HEADER)) {
		//error
	}

	if (!Unmap()) {
		//error
	}

	DWORD newSize = P2ALIGNUP(dwFileSizeLow + dwSectionSize, fileAlignment);
	if ((pView = MapFileRWNewSize(newSize)) == NULL) {
		CloseHandle(hFile);
		return FALSE;
	}

	if (!AppendNewSectionHeader(dwFileSizeLow, str_section_name, dwSectionSize, IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ, pSectionData)) {
		// error
	}

	if (!Unmap()) {
		//error
	}

	return CloseHandle(hFile);
}
```

`PePacker64/PePacker.c`:

```c
#include <Windows.h>
#include <stdio.h>

#include "Header.h"
#include "easylzma.h"
#pragma comment (lib, "easylzma_s.lib")

#define _64PE	0x064
#define _32PE	0x032
#define DllPE	0xD11
#define NotPE	0x000

#define _STORE		"Modules\\"
#define _x64DllStub	"DllPP64Stub.dll"
#define _x32DllStub	"DllPP32Stub.dll"	// working on it :)
#define _x64STUB	"PP64Stub.exe"
#define _x32STUB	"PP32Stub.exe"		// working on it :)

#define _x64STUB_H	"H_PP64Stub.exe"

BOOL ReportError(const char* ApiName) {
	printf("[!] \"%s\" [ FAILED ] \t%d \n", ApiName, GetLastError());
	return FALSE;
}


BOOL ReadPayloadFile(const char* FileInput, PDWORD sPayloadSize, unsigned char** pPayloadAddress) {

	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD FileSize = NULL;
	DWORD lpNumberOfBytesRead = NULL;

	hFile = CreateFileA(FileInput, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return ReportError("CreateFileA");
	}

	FileSize = GetFileSize(hFile, NULL);

	unsigned char* Payload = (unsigned char*)malloc(FileSize);

	ZeroMemory(Payload, FileSize);

	if (!ReadFile(hFile, Payload, FileSize, &lpNumberOfBytesRead, NULL)) {
		return ReportError("ReadFile");
	}

	*pPayloadAddress = Payload;
	*sPayloadSize = lpNumberOfBytesRead;

	CloseHandle(hFile);

	if (*pPayloadAddress != NULL && *sPayloadSize != NULL)
		return TRUE;

	return FALSE;
}




INT CheckPeArch(PBYTE pPe) {

	PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)pPe;
	PIMAGE_NT_HEADERS nth = (PIMAGE_NT_HEADERS)(pPe + dos->e_lfanew);


	if (nth->FileHeader.Characteristics & IMAGE_FILE_DLL) {
		printf("[!] We Do Not Support Dll Files !");
		return DllPE;
	}
	if (nth->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE && nth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		return _64PE;
	}
	if (nth->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE && nth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		printf("[!] We Do Not Support x32 Exe Files, Yet !");
		return _32PE;
	}

	printf("[!] Please Input A Valid x64 Pe File !\n");
	return NotPE;
}



BOOL MoveExeStubToDir() {
	char Module[MAX_PATH];
	sprintf(Module, "%s%s", _STORE, _x64STUB);
	return CopyFileA(Module, ".\\"_x64STUB, FALSE);
}

BOOL MoveDllStubToDir() {
	char Module[MAX_PATH];
	sprintf(Module, "%s%s", _STORE, _x64DllStub);
	return CopyFileA(Module, ".\\"_x64DllStub, FALSE);
}

BOOL MoveHExeStubToDir() {
	char Module[MAX_PATH];
	sprintf(Module, "%s%s", _STORE, _x64STUB_H);
	return CopyFileA(Module, ".\\"_x64STUB_H, FALSE);
}



INT main(INT argc, CHAR* argv[]) {

	BOOL IsDll = FALSE, IsExe = TRUE;
	BOOL NoConsole = FALSE;

	char* whoami;
	(whoami = strrchr(argv[0], '\\')) ? ++whoami : (whoami = argv[0]);

	if (argc < 2) {
		printf("[#] Usage : %s <Input x64 exe> <*Output*> <*Optional Features*>\n", whoami);
		printf("[#] Output : \n");
		printf("\t\t\b\b-d : Output The Packed Pe As A x64 Dll File \n");
		printf("\t\t\b\b-e : Output The Packed Pe As A x64 Exe File (Default) \n");
		printf("[#] Features : \n");
		printf("\t\t\b\b-h : Hide The Console - /SUBSYSTEM:WINDOWS \n");

		printf("\n");
		return -1;
	}

	if (argc > 2){
		if (strcmp(argv[2], "-e") == 0) {
			IsDll = FALSE;
			IsExe = TRUE;
		}
		else if (strcmp(argv[2], "-d") == 0){
			IsDll = TRUE;
			IsExe = FALSE;
		}
		else {
			printf("[i] \"%s\" Is Invalid Input, Defaulting To Outputting Exe File ... \n");
		}
	}

	if (argc > 3) {
		if (strcmp(argv[3], "-h") == 0) {
			NoConsole = TRUE;
		}
	
	}


	unsigned char*	PeFile;
	DWORD			dwSize;
	char			LoaderStub[MAX_PATH];
	
	printf("[i] Reading \" %s \" ... \n", argv[1]);

	if (!ReadPayloadFile(argv[1], &dwSize, &PeFile)) {
		return -1;
	}

	if (CheckPeArch(PeFile) != _64PE) {
		return -1;
	}

	switch (CheckPeArch(PeFile)){
		case _64PE: {
			printf("[i] 64-PE Input Detected ... [ SUPPORTED ]\n");
			
			if (IsDll){
				printf("[i] Generating Dll Output ... \n");
				strcpy(LoaderStub, _x64DllStub);
				if (!MoveDllStubToDir()) {
					return ReportError("CopyFileA");
				}
			}
			else if (IsExe && !NoConsole) {
				printf("[i] Generating Exe Output ... \n");
				strcpy(LoaderStub, _x64STUB);
				if (!MoveExeStubToDir()) {
					return ReportError("CopyFileA");
				}
			}
			
			else if (IsExe && NoConsole) {
				printf("[i] Generating No Console Exe Output ... \n");
				strcpy(LoaderStub, _x64STUB_H);
				if (!MoveHExeStubToDir()) {
					return ReportError("CopyFileA");
				}
			}

			break;
		}

		case _32PE: {
			// not supported yet ...
			printf("[i] 32-PE Input Detected ... [ NOT-SUPPORTED ]\n");
			strcpy(LoaderStub, _x32STUB);
			return -1;
		}

		default:
			return -1;
	}

	

	printf("[i] Reading The Loader \"%s\" ...", LoaderStub);
	HANDLE hFile = CreateFileA(LoaderStub, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		//error
		return -1;
	}
	printf(" [ DONE ] \n");

	// compression:
	printf("[i] Packing ... ");
	unsigned int	iError = ELZMA_E_OK;
	unsigned char*	OutputCompressedData = NULL;
	size_t			OutputCompressedSize = NULL;
	if ((iError = simpleCompress(ELZMA_lzma, PeFile, dwSize, &OutputCompressedData, &OutputCompressedSize)) != ELZMA_E_OK) {
		printf("[!]  Compression Failed With Error : %d \n", iError);
		return FALSE;
	}

	printf(" [ DONE ] \n");
	printf("[+] Compressed Ratio : %d%% \n", (OutputCompressedSize * 100) / dwSize);
	printf("[+] Final Pe Size : %d \n", OutputCompressedSize);

	if (!CreateNewSection(hFile, OutputCompressedSize, OutputCompressedData)) {
		printf("[!] Failed To Create A New Section \n");
		return -1;
	}

	printf("[+] Section .ATOM is Created Containing The Input Packed Pe \n");


	return 0;
}

```

`PePacker64/PePacker64.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d0738ea1-814c-4d92-b15c-233ef61d6a8e}</ProjectGuid>
    <RootNamespace>PePacker64</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>PePacker</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DisableSpecificWarnings>4146; 4996</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DisableSpecificWarnings>4146; 4996</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="easylzma.c" />
    <ClCompile Include="NewSection.c" />
    <ClCompile Include="PePacker.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="compress.h" />
    <ClInclude Include="decompress.h" />
    <ClInclude Include="easylzma.h" />
    <ClInclude Include="Header.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PePacker64/PePacker64.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="easylzma">
      <UniqueIdentifier>{e8b35a14-a022-41d0-abf8-1e14002210f8}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PePacker.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NewSection.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="easylzma.c">
      <Filter>easylzma</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="compress.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="decompress.h">
      <Filter>easylzma</Filter>
    </ClInclude>
    <ClInclude Include="easylzma.h">
      <Filter>easylzma</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PePacker64/PePacker64.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`PePacker64/common.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/common.h - definitions common to both compression and
 *                     decompression
 */

#ifndef __EASYLZMACOMMON_H__ 
#define __EASYLZMACOMMON_H__ 

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/* msft dll export gunk.  To build a DLL on windows, you
 * must define WIN32, EASYLZMA_SHARED, and EASYLZMA_BUILD.  To use a 
 * DLL, you must define EASYLZMA_SHARED and WIN32 */
#if defined(WIN32) && defined(EASYLZMA_SHARED)
#  ifdef EASYLZMA_BUILD
#    define EASYLZMA_API __declspec(dllexport)
#  else
#    define EASYLZMA_API __declspec(dllimport)
#  endif
#else
#  define EASYLZMA_API
#endif 

/** error codes */

/** no error */
#define ELZMA_E_OK                               0
/** bad parameters passed to an ELZMA function */
#define ELZMA_E_BAD_PARAMS                      10
/** could not initialize the encode with configured parameters. */
#define ELZMA_E_ENCODING_PROPERTIES_ERROR       11
/** an error occured during compression (XXX: be more specific) */
#define ELZMA_E_COMPRESS_ERROR                  12
/** currently unsupported lzma file format was specified*/
#define ELZMA_E_UNSUPPORTED_FORMAT              13
/** an error occured when reading input */
#define ELZMA_E_INPUT_ERROR                     14
/** an error occured when writing output */
#define ELZMA_E_OUTPUT_ERROR                    15
/** LZMA header couldn't be parsed */
#define ELZMA_E_CORRUPT_HEADER                  16
/** an error occured during decompression (XXX: be more specific) */
#define ELZMA_E_DECOMPRESS_ERROR                17
/** the input stream returns EOF before the decompression could complete */
#define ELZMA_E_INSUFFICIENT_INPUT              18
/** for formats which have an emebedded crc, this error would indicated that
 *  what came out was not what went in, i.e. data corruption */
#define ELZMA_E_CRC32_MISMATCH                  19
/** for formats which have an emebedded uncompressed content length,
 *  this error indicates that the amount we read was not what we expected */
#define ELZMA_E_SIZE_MISMATCH                   20


/** Supported file formats */
typedef enum {
    ELZMA_lzip, /**< the lzip format which includes a magic number and
                 *   CRC check */
    ELZMA_lzma  /**< the LZMA-Alone format, originally designed by
                 *   Igor Pavlov and in widespread use due to lzmautils,
                 *   lacking both aforementioned features of lzip */
/* XXX: future, potentially   ,
    ELZMA_xz 
*/
} elzma_file_format;

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process has generated [de]compressed output.
 *
 * the size parameter indicates how much data is in buf to be written.
 * it is required that the write callback consume all data, and a return
 * value not equal to input size indicates and error.
 */
typedef size_t (*elzma_write_callback)(void *ctx, const void *buf,
                                       size_t size);

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process requires more [un]compressed input.
 *
 * the size parameter is an in/out argument.  on input it indicates
 * the buffer size.  on output it indicates the amount of data read into
 * buf.  when *size is zero on output it indicates EOF.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef int (*elzma_read_callback)(void *ctx, void *buf,
                                   size_t *size);

/**
 * A callback invoked during elzma_[de]compress_run to report progress
 * on the [de]compression.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef void (*elzma_progress_callback)(void *ctx, size_t complete,
                                        size_t total);


/** pointer to a malloc function, supporting client overriding memory
 *  allocation routines */
typedef void * (*elzma_malloc)(void *ctx, unsigned int sz);

/** pointer to a free function, supporting client overriding memory
 *  allocation routines */
typedef void (*elzma_free)(void *ctx, void * ptr);

#ifdef __cplusplus
};
#endif    

#endif

```

`PePacker64/compress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/compress.h - the API for LZMA compression using easylzma
 */

#ifndef __EASYLZMACOMPRESS_H__ 
#define __EASYLZMACOMPRESS_H__ 

#include "common.h"
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/** suggested default values */
#define ELZMA_LC_DEFAULT 3
#define ELZMA_LP_DEFAULT 0
#define ELZMA_PB_DEFAULT 2
#define ELZMA_DICT_SIZE_DEFAULT_MAX (1 << 26)

/** an opaque handle to an lzma compressor */
typedef struct _elzma_compress_handle * elzma_compress_handle;

/**
 * Allocate a handle to an LZMA compressor object.
 */ 
elzma_compress_handle EASYLZMA_API elzma_compress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_compress_set_allocation_callbacks(
    elzma_compress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA compressor object.
 */ 
void EASYLZMA_API elzma_compress_free(elzma_compress_handle * hand);

/**
 * Set configuration paramters for a compression run.  If not called,
 * reasonable defaults will be used.
 */ 
int EASYLZMA_API elzma_compress_config(elzma_compress_handle hand,
                                       unsigned char lc,
                                       unsigned char lp,
                                       unsigned char pb,
                                       unsigned char level,
                                       unsigned int dictionarySize,
                                       elzma_file_format format,
                                       unsigned long long uncompressedSize);

/**
 * Run compression
 */ 
int EASYLZMA_API elzma_compress_run(
    elzma_compress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_progress_callback progressCallback, void * progressContext);


/**
 * a heuristic utility routine to guess a dictionary size that gets near
 * optimal compression while reducing memory usage.
 * accepts a size in bytes, returns a proposed dictionary size
 */
unsigned int EASYLZMA_API elzma_get_dict_size(unsigned long long size);

#ifdef __cplusplus
};
#endif    

#endif

```

`PePacker64/decompress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/decompress.h - The API for LZMA decompression using easylzma
 */

#ifndef __EASYLZMADECOMPRESS_H__ 
#define __EASYLZMADECOMPRESS_H__ 

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif    

/** an opaque handle to an lzma decompressor */
typedef struct _elzma_decompress_handle * elzma_decompress_handle;

/**
 * Allocate a handle to an LZMA decompressor object.
 */ 
elzma_decompress_handle EASYLZMA_API elzma_decompress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_decompress_set_allocation_callbacks(
    elzma_decompress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA decompressor object.
 */ 
void EASYLZMA_API elzma_decompress_free(elzma_decompress_handle * hand);

/**
 * Perform decompression
 *
 * XXX: should the library automatically detect format by reading stream?
 *      currently it's based on data external to stream (such as extension
 *      or convention)
 */ 
int EASYLZMA_API elzma_decompress_run(
    elzma_decompress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_file_format format);


#ifdef __cplusplus
};
#endif    

#endif

```

`PePacker64/easylzma.c`:

```c
#include <string.h>
#include <assert.h>
#include "easylzma.h"



struct dataStream
{
    const unsigned char* inData;
    size_t inLen;

    unsigned char* outData;
    size_t outLen;
};

static int
inputCallback(void* ctx, void* buf, size_t* size)
{
    size_t rd = 0;
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    rd = (ds->inLen < *size) ? ds->inLen : *size;

    if (rd > 0) {
        memcpy(buf, (void*)ds->inData, rd);
        ds->inData += rd;
        ds->inLen -= rd;
    }

    *size = rd;

    return 0;
}

static size_t
outputCallback(void* ctx, const void* buf, size_t size)
{
    struct dataStream* ds = (struct dataStream*)ctx;
    assert(ds != NULL);

    if (size > 0) {
        ds->outData = realloc(ds->outData, ds->outLen + size);
        memcpy((void*)(ds->outData + ds->outLen), buf, size);
        ds->outLen += size;
    }

    return size;
}

int
simpleCompress(elzma_file_format format, const unsigned char* inData,
    size_t inLen, unsigned char** outData,
    size_t* outLen)
{
    int rc;
    elzma_compress_handle hand;

    /* allocate compression handle */
    hand = elzma_compress_alloc();
    assert(hand != NULL);

    rc = elzma_compress_config(hand, ELZMA_LC_DEFAULT,
        ELZMA_LP_DEFAULT, ELZMA_PB_DEFAULT,
        5, (1 << 20) /* 1mb */,
        format, inLen);

    if (rc != ELZMA_E_OK) {
        elzma_compress_free(&hand);
        return rc;
    }

    /* now run the compression */
    {
        struct dataStream ds;
        ds.inData = inData;
        ds.inLen = inLen;
        ds.outData = NULL;
        ds.outLen = 0;

        rc = elzma_compress_run(hand, inputCallback, (void*)&ds,
            outputCallback, (void*)&ds,
            NULL, NULL);

        if (rc != ELZMA_E_OK) {
            if (ds.outData != NULL) free(ds.outData);
            elzma_compress_free(&hand);
            return rc;
        }

        elzma_compress_free(&hand);
        *outData = ds.outData;
        *outLen = ds.outLen;
    }

    return rc;
}

int
simpleDecompress(elzma_file_format format, const unsigned char* inData,
    size_t inLen, unsigned char** outData,
    size_t* outLen)
{
    int rc;
    elzma_decompress_handle hand;

    hand = elzma_decompress_alloc();

    /* now run the compression */
    {
        struct dataStream ds;
        ds.inData = inData;
        ds.inLen = inLen;
        ds.outData = NULL;
        ds.outLen = 0;

        rc = elzma_decompress_run(hand, inputCallback, (void*)&ds,
            outputCallback, (void*)&ds, format);

        if (rc != ELZMA_E_OK) {
            if (ds.outData != NULL) free(ds.outData);
            elzma_decompress_free(&hand);
            return rc;
        }

        elzma_decompress_free(&hand);
        *outData = ds.outData;
        *outLen = ds.outLen;
    }

    return rc;
}

```

`PePacker64/easylzma.h`:

```h
#pragma once


#ifndef _EASYLZMA_H
#define _EASYLZMA_H

#include "compress.h"
#include "decompress.h"


/* compress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
int simpleCompress(elzma_file_format format,
    const unsigned char* inData,
    size_t inLen,
    unsigned char** outData,
    size_t* outLen);

/* decompress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
int simpleDecompress(elzma_file_format format,
    const unsigned char* inData,
    size_t inLen,
    unsigned char** outData,
    size_t* outLen);


#endif // !_EASYLZMA_H

```

`README.md`:

```md
### AtomPePacker : A Highly Capable Pe Packer
<br>

### Features :
- the packer only support x64 exe's (altho planning to make x32 version but idk when it'll be done)
- no crt imports
- api hashing library ( custom getmodulehandle and getprocaddress )
- direct syscalls ( for the part that i do the ntdll unhooking )
- ntdll unhooking from \KnownDlls\
- support tls callbacks
- support reallocation in case of needed ( the image is mapped to the preferable address first )
- no rwx section allocation 
- support exception handling
- uses elzma compression algorithm to do the compression (reducing the final file size)
- its local run pe, so it support arguments 
- fake imported functions to add more friendly look to the iat 



<br>


### Builder :
- you can download from [here](https://github.com/ORCx41/AtomPePacker/releases/tag/1) or compile the code manually
- supports only 1 input: `x64 native exe files.`
- supports 3 outputs:
  - dll :
    - `Example "rundll32.exe DllPP64.dll Atom" (Using "Atom" is a must to run your payload - this is the name if the exported function in the dll)` 
    - `can be hijacked / injected into other process`
  - exe :
    - `this output is the default (with console - for binaries like mimikatz)`
  - no console exe
    - `for binaries like a c2 agent`


<br>

### Usage :
```

[#] Usage  : PePacker.exe <Input x64 exe> <*Output*> <*Optional Features*>
[#] Output :
              -d : Output The Packed Pe As A x64 Dll File
              -e : Output The Packed Pe As A x64 Exe File (Default)
[#] Features :
              -h : Hide The Console - /SUBSYSTEM:WINDOWS



Example:


PePacker.exe mimikatz.exe			: generate exe packed file
PePacker.exe mimikatz.exe -e			: generate exe packed file
PePacker.exe mimikatz.exe -e	-h		: generate hidden exe packed file
PePacker.exe mimikatz.exe -d			: generate dll output

```




<br>

### Demo - Builder :
![Screenshot 2022-10-12 073947](https://user-images.githubusercontent.com/111295429/195252422-8e950ea8-be59-406d-ab6e-42bf273ae314.png)
![Screenshot 2022-10-12 074128](https://user-images.githubusercontent.com/111295429/195252144-1c32c279-2e22-4ccd-8b06-6b2aac901324.png)



<br>
<br>

### Demo - Profit :
![photo_2022-10-12_07-08-33](https://user-images.githubusercontent.com/111295429/195249176-9c021c71-5c1c-42f7-b1fa-7937259e6e39.png)
![photo_2022-10-12_07-08-38](https://user-images.githubusercontent.com/111295429/195249100-1fe2a944-c67f-4495-b20f-8062afe6a429.jpg)

<br>
<br>


### Thanks for :
- https://github.com/lloyd/easylzma
- https://github.com/vxunderground/VX-API


### TODO :
  - x32 support
  - reduce the entropy






```

`Test/ArgsTest/ArgsTest.c`:

```c
#include <Windows.h>
#include <stdio.h>



int main(int argc, char* argv[]) {

	printf("\n\t#########################################[ARGS TEST]#########################################\n\n");

	if (argc > 1) {
		for (size_t i = 1; i < argc; i++) {
			printf("[i] argv[%d] : %s \n", i, argv[i]);
		}
	}
	else {
		printf("[-] No Arguments Where Passed In \n");
	}
	
	printf("\n\t#########################################[ARGS TEST]#########################################\n\n");

	MessageBoxA(NULL, "DONE !", "DONE !", MB_OK);

	return 0;
}

```

`Test/ArgsTest/ArgsTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2451fb29-f1a4-4ac1-adf9-5a68c6458b07}</ProjectGuid>
    <RootNamespace>ArgsTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
    <VcpkgManifestInstall>true</VcpkgManifestInstall>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ArgsTest.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Test/ArgsTest/ArgsTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ArgsTest.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Test/ArgsTest/ArgsTest.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Test/TlsTest/TlsTest.c`:

```c
#include <Windows.h>
#include <stdio.h>

// https://github.com/kevinalmansa/TLS_Examples/tree/master/TLS_Examples/TLS_Static


#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:tls_callback_func")

void	tls_callback1(PVOID hModule, DWORD dwReason, PVOID pContext);
void	tls_callback2(PVOID hModule, DWORD dwReason, PVOID pContext);


#ifdef _WIN64
#pragma const_seg(".CRT$XLB")
EXTERN_C const
#else
#pragma data_seg(".CRT$XLB")
EXTERN_C
#endif

PIMAGE_TLS_CALLBACK tls_callback_func = (PIMAGE_TLS_CALLBACK)tls_callback1;

#ifdef _WIN64
#pragma const_seg()
#else
#pragma data_seg()
#endif //_WIN64



#ifdef _WIN64
#pragma const_seg(".CRT$XLC")
EXTERN_C const
#else
#pragma data_seg(".CRT$XLC")
EXTERN_C
#endif

PIMAGE_TLS_CALLBACK tls_callback_func2 = (PIMAGE_TLS_CALLBACK)tls_callback2;

#ifdef _WIN64
#pragma const_seg()
#else
#pragma code_seg()
#endif //_WIN64




/*****************************************************************************
First TLS Callback
Set above to segment CRT$XLB
******************************************************************************/
void	tls_callback1(PVOID hModule, DWORD dwReason, PVOID pContext)
{
	if (dwReason == DLL_THREAD_ATTACH) {
		// This will be loaded in each DLL thread attach
		MessageBox(0, TEXT("TLS Callback 1: Thread Attach Triggered"), TEXT("TLS"), 0);
	}

	if (dwReason == DLL_PROCESS_ATTACH) {
		MessageBox(0, TEXT("TLS Callback: Process Attach Triggered"), TEXT("TLS"), 0);
		// DEBUG - Help understand how this is being stored in memory.
		printf("TLS Callback Addresses:\n    Function Address: %p\n    CRT Callback Address: %p\n",
			tls_callback1, &tls_callback_func);
	}
}


/*****************************************************************************
Second TLS Callback
Set above to segment CRT$XLC
******************************************************************************/
void	tls_callback2(PVOID hModule, DWORD dwReason, PVOID pContext)
{
	if (dwReason == DLL_THREAD_ATTACH) {
		// This will be loaded in each DLL thread attach
		MessageBox(0, TEXT("TLS Callback 2: Thread Attach Triggered"), TEXT("TLS_Thread"), 0);
	}

	if (dwReason == DLL_PROCESS_ATTACH) {
		MessageBox(0, TEXT("TLS Callback 1: Process Attach Triggered"), TEXT("TLS_Process"), 0);
		// DEBUG - Help understand how this is being stored in memory.
		printf("TLS Callback Addresses:\n    Function Address: %p\n    CRT Callback Address: %p\n",
			tls_callback2, &tls_callback_func2);
	}
}


/*****************************************************************************
The actual main()
Code in the TLS Callbacks set above will execute BEFORE the main.
Setting a breakpoint here will not stop the callbacks from executing first.
******************************************************************************/
int main()
{
	printf("Main():\n    Hello World\n");
	system("pause");
	return 0;
}

```

`Test/TlsTest/TlsTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d7230508-506a-4d1c-a840-28e38057bc0f}</ProjectGuid>
    <RootNamespace>TlsTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="TlsTest.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Test/TlsTest/TlsTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="TlsTest.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Test/TlsTest/TlsTest.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```