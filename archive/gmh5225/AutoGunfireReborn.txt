Project Path: arc_gmh5225_AutoGunfireReborn_o3c9_6vx

Source Tree:

```txt
arc_gmh5225_AutoGunfireReborn_o3c9_6vx
├── AutoGunfireReborn.sln
├── GunfireRebornDumper
│   ├── App.config
│   ├── GunfireRebornDumper.csproj
│   ├── Minifier.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── lib
│   │   └── mscorlib.dll
│   └── packages.config
├── GunfireRebornMods
│   ├── Common
│   │   ├── ModBase.cs
│   │   └── ModManager.cs
│   ├── FodyWeavers.xml
│   ├── FodyWeavers.xsd
│   ├── GunfireRebornMods.csproj
│   ├── Mods
│   │   ├── Aimbot.cs
│   │   ├── AutoAim.cs
│   │   ├── ExtraSensoryPerception.cs
│   │   ├── FreeCam.cs
│   │   ├── GameSpeed.cs
│   │   ├── JumpHeight.cs
│   │   ├── MovementSpeed.cs
│   │   ├── SceneDebugger.cs
│   │   ├── UnlimitedAmmo.cs
│   │   └── WeaponMod.cs
│   ├── NativeNetSharp.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   └── packages.config
├── Il2CppAssemblyUnhollower
├── Il2CppDumper
├── LICENSE
└── README.md

```

`AutoGunfireReborn.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30011.22
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssemblyUnhollower", "Il2CppAssemblyUnhollower\AssemblyUnhollower\AssemblyUnhollower.csproj", "{B6EB4C86-9B1A-4719-8707-D84B234F7676}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnhollowerBaseLib", "Il2CppAssemblyUnhollower\UnhollowerBaseLib\UnhollowerBaseLib.csproj", "{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnhollowerRuntimeLib", "Il2CppAssemblyUnhollower\UnhollowerRuntimeLib\UnhollowerRuntimeLib.csproj", "{A969803F-C2AF-4E42-B772-A48C18116CBC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Il2CppDumper", "Il2CppDumper\Il2CppDumper\Il2CppDumper.csproj", "{8975D064-7ECE-49EE-A68D-F52D22B4D98F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GunfireRebornDumper", "GunfireRebornDumper\GunfireRebornDumper.csproj", "{385C11FF-EF0F-4FD5-B207-B76820ADE367}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GunfireRebornMods", "GunfireRebornMods\GunfireRebornMods.csproj", "{786E2464-E23C-4392-A81A-870456D7FD63}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|x64.Build.0 = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Debug|x86.Build.0 = Debug|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|Any CPU.Build.0 = Release|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|x64.ActiveCfg = Release|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|x64.Build.0 = Release|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|x86.ActiveCfg = Release|Any CPU
		{B6EB4C86-9B1A-4719-8707-D84B234F7676}.Release|x86.Build.0 = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|x64.Build.0 = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Debug|x86.Build.0 = Debug|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|Any CPU.Build.0 = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|x64.ActiveCfg = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|x64.Build.0 = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|x86.ActiveCfg = Release|Any CPU
		{B7C01AE9-0FC8-4751-B56D-F2ECFC72F269}.Release|x86.Build.0 = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|x64.Build.0 = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Debug|x86.Build.0 = Debug|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|Any CPU.Build.0 = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|x64.ActiveCfg = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|x64.Build.0 = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|x86.ActiveCfg = Release|Any CPU
		{A969803F-C2AF-4E42-B772-A48C18116CBC}.Release|x86.Build.0 = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|x64.ActiveCfg = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|x64.Build.0 = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|x86.ActiveCfg = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Debug|x86.Build.0 = Debug|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|Any CPU.Build.0 = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|x64.ActiveCfg = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|x64.Build.0 = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|x86.ActiveCfg = Release|Any CPU
		{8975D064-7ECE-49EE-A68D-F52D22B4D98F}.Release|x86.Build.0 = Release|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|x64.ActiveCfg = Debug|x64
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|x64.Build.0 = Debug|x64
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|x86.ActiveCfg = Debug|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Debug|x86.Build.0 = Debug|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|Any CPU.Build.0 = Release|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|x64.ActiveCfg = Release|x64
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|x64.Build.0 = Release|x64
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|x86.ActiveCfg = Release|Any CPU
		{385C11FF-EF0F-4FD5-B207-B76820ADE367}.Release|x86.Build.0 = Release|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|x64.ActiveCfg = Debug|x64
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|x64.Build.0 = Debug|x64
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|x86.ActiveCfg = Debug|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Debug|x86.Build.0 = Debug|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|Any CPU.Build.0 = Release|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|x64.ActiveCfg = Release|x64
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|x64.Build.0 = Release|x64
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|x86.ActiveCfg = Release|Any CPU
		{786E2464-E23C-4392-A81A-870456D7FD63}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {91033C52-D2C7-446E-98EC-025450DFD9FA}
	EndGlobalSection
EndGlobal

```

`GunfireRebornDumper/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`GunfireRebornDumper/GunfireRebornDumper.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{385C11FF-EF0F-4FD5-B207-B76820ADE367}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>GunfireRebornDumper</RootNamespace>
    <AssemblyName>GunfireRebornDumper</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Mono.Cecil, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Mdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Mdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Pdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Pdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Rocks, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Rocks.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Minifier.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Il2CppAssemblyUnhollower\AssemblyUnhollower\AssemblyUnhollower.csproj">
      <Project>{b6eb4c86-9b1a-4719-8707-d84b234f7676}</Project>
      <Name>AssemblyUnhollower</Name>
    </ProjectReference>
    <ProjectReference Include="..\Il2CppAssemblyUnhollower\UnhollowerBaseLib\UnhollowerBaseLib.csproj">
      <Project>{b7c01ae9-0fc8-4751-b56d-f2ecfc72f269}</Project>
      <Name>UnhollowerBaseLib</Name>
    </ProjectReference>
    <ProjectReference Include="..\Il2CppAssemblyUnhollower\UnhollowerRuntimeLib\UnhollowerRuntimeLib.csproj">
      <Project>{a969803f-c2af-4e42-b772-a48c18116cbc}</Project>
      <Name>UnhollowerRuntimeLib</Name>
    </ProjectReference>
    <ProjectReference Include="..\Il2CppDumper\Il2CppDumper\Il2CppDumper.csproj">
      <Project>{8975d064-7ece-49ee-a68d-f52d22b4d98f}</Project>
      <Name>Il2CppDumper</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Content Include="lib\mscorlib.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`GunfireRebornDumper/Minifier.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

namespace GunfireRebornDumper
{
    public static class Minifier
    {
        static List<String> neededTypes = new List<String>();
        static List<String> neededMethods = new List<String>();
        static List<String> neededFields = new List<String>();
        static List<String> neededProperties = new List<String>();
        static List<String> blacklistTypes = new List<String> { "Enum", "ValueType" };
        static List<String> blacklistedAssemblies = new List<String> { "mscorlib", "System", "System.Core", "UnhollowerBaseLib", "UnhollowerRuntimeLib", "Iced", "Mono.Cecil", "Costura" };
        //static List<String> blacklistedAssemblies = new List<String> { "System", "System.Core", "UnhollowerBaseLib", "UnhollowerRuntimeLib", "Iced", "Mono.Cecil", "Costura" };
        static void AddNeededType(TypeReference type)
        {
            if (type.ContainsGenericParameter) return;
            if (blacklistedAssemblies.Contains(type.Scope.Name)) return;
            if (type.FullName.Contains("<") && type.FullName.StartsWith("Il2"))
            {
                if (!neededTypes.Contains(type.FullName.Substring(0, type.FullName.IndexOf("<")))) neededTypes.Add((type.FullName.Substring(0, type.FullName.IndexOf("<"))));

            }
            if (!neededTypes.Contains(type.FullName)) neededTypes.Add(type.FullName);
            if (blacklistTypes.Contains(type.Name)) return;
            var res = type.Resolve();
            var baseType = type.Resolve().BaseType;
            if (baseType != null) AddNeededType(baseType);
        }
        static List<String> Arrays = new List<String> { "Il2CppArrayBase`1", "Il2CppStructArray`1", "Il2CppReferenceArray`1" };
        static String GetCorrectMethodName(MethodDefinition method)
        {
            var returnType = method.ReturnType.FullName;
            if (Arrays.Contains(method.ReturnType.Name))
            {
                returnType = ((GenericInstanceType)method.ReturnType).GenericArguments[0].FullName + "[]";
            }
            var argTypes = new List<String>();
            foreach (var arg in method.Parameters)
            {
                var argType = arg.ParameterType.FullName;
                if (Arrays.Contains(arg.ParameterType.Name))
                {
                    argType = ((GenericInstanceType)arg.ParameterType).GenericArguments[0].FullName + "[]";
                }
                argTypes.Add(argType);
            }
            var argString = String.Join(",", argTypes);
            return returnType + " " + method.DeclaringType.FullName + "::" + method.Name + "(" + argString + ")";
        }
        public static Boolean CleanType(TypeDefinition type)
        {
            //type.BaseType = null;
            //type.Interfaces.Clear();
            var deleteNestedTypes = new List<TypeDefinition>();
            foreach (var nestedType in type.NestedTypes)
            {
                var deleteNestedType = CleanType(nestedType);
                if (deleteNestedType) deleteNestedTypes.Add(nestedType);
            }
            if (type.FullName.Contains("ServerDefine"))
                Console.WriteLine("");
            deleteNestedTypes.ForEach(t => type.NestedTypes.Remove(t));
            if (!neededTypes.Contains(type.FullName))
            {
                return type.NestedTypes.Count == 0;
            }
            if (type.IsEnum) return false;
            var deleteMethods = new List<MethodDefinition>();
            foreach (var method in type.Methods)
            {
                var gen = false;
                if (!(neededMethods.Contains(method.FullName)))
                {
                    deleteMethods.Add(method);
                }
            }
            deleteMethods.ForEach(t => type.Methods.Remove(t.Resolve()));
            var deleteProperties = new List<PropertyDefinition>();
            foreach (var field in type.Properties)
            {
                if (!(neededProperties.Contains(field.FullName)))
                {
                    deleteProperties.Add(field);
                }
            }
            deleteProperties.ForEach(t => type.Properties.Remove(t.Resolve()));
            var deleteFields = new List<FieldDefinition>();
            foreach (var field in type.Fields)
            {
                if (!(neededFields.Contains(field.FullName) || type.IsValueType))
                {
                    deleteFields.Add(field);
                }
            }
            deleteFields.ForEach(t => type.Fields.Remove(t.Resolve()));
            return false;
        }
        static List<IMetadataScope> neededDlls = new List<IMetadataScope>();
        public static void Minify(String exe)
        {
            var assembly = AssemblyDefinition.ReadAssembly(exe);
            var dlls = Directory.GetFiles("DummyDll", "*.dll");

            foreach (EmbeddedResource resource in assembly.MainModule.Resources)
            {
                if (!resource.Name.EndsWith("dll.compressed")) continue;
                //if (blacklistedAssemblies.Count(a => "costura." + a.ToLower() + ".dll.compressed" == resource.Name) > 0) continue;
                if (resource.Name.Contains("mono.cecil")) continue;
                using (var compressedStream = resource.GetResourceStream())
                {
                    using (var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
                    {
                        using (var outputStream = new MemoryStream())
                        {
                            deflateStream.CopyTo(outputStream);
                            outputStream.Position = 0;
                            var embeddedAssembly = AssemblyDefinition.ReadAssembly(outputStream);
                            File.WriteAllBytes(embeddedAssembly.MainModule.Name, outputStream.ToArray());
                        }
                    }
                }
            }

            foreach (var module in assembly.Modules)
            {
                foreach (var type in module.Types)
                {
                    foreach (var m in type.Methods)
                    {
                        if (!m.HasBody) continue;
                        var methodReferences = m.Body.Instructions.ToList().FindAll(il => /*il.OpCode == Mono.Cecil.Cil.OpCodes.Call &&*/ il.Operand as MethodReference != null).Select(il => il.Operand as MethodReference);
                        foreach (var reference in methodReferences)
                        {
                            if (!blacklistedAssemblies.Contains(reference.DeclaringType.Scope.Name) && reference.DeclaringType.Scope != type.Scope)
                            {
                                var property = reference.DeclaringType.Resolve().Properties.FirstOrDefault(p => p.SetMethod == reference.Resolve() || p.GetMethod == reference.Resolve());
                                if (property != null)
                                {
                                    if (!neededProperties.Contains(property.FullName.Replace("Il2Cpp", "")))
                                    {
                                        neededProperties.Add(property.FullName.Replace("Il2Cpp", ""));
                                    }
                                    if (!neededFields.Contains(property.FullName.Replace("Il2Cpp", "").Replace("()", "")))
                                    {
                                        neededFields.Add(property.FullName.Replace("Il2Cpp", "").Replace("()", ""));
                                    }
                                }
                                if (!neededDlls.Contains(reference.DeclaringType.Scope))
                                {
                                    neededDlls.Add(reference.DeclaringType.Scope);
                                }
                                AddNeededType(reference.DeclaringType);
                                if (reference.IsGenericInstance)
                                {
                                    var genReference = (GenericInstanceMethod)reference;
                                    foreach (var gp in genReference.GenericParameters)
                                    {
                                        AddNeededType(gp);
                                    }
                                }
                                AddNeededType(reference.ReturnType);
                                foreach (var p in reference.Parameters)
                                {
                                    AddNeededType(p.ParameterType);
                                }
                                foreach (var p in reference.DeclaringType.Resolve().Interfaces)
                                {
                                    AddNeededType(p.InterfaceType);
                                }
                                var methodName = reference.FullName;
                                var method = reference.Resolve();
                                methodName = GetCorrectMethodName(method).Replace("Il2Cpp", "");
                                if (!neededMethods.Contains(methodName))
                                {
                                    neededMethods.Add(methodName);
                                }
                                if (reference.IsGenericInstance)
                                {
                                    if (!neededMethods.Contains(reference.Name))
                                    {
                                        //neededMethods.Add(reference.Name);
                                    }
                                }
                            }
                        }
                        var fieldReferences = m.Body.Instructions.ToList().FindAll(il => il.Operand as FieldReference != null).Select(il => il.Operand as FieldReference);
                        foreach (var reference in fieldReferences)
                        {
                            if (!blacklistedAssemblies.Contains(reference.DeclaringType.Scope.Name) && reference.DeclaringType.Scope != type.Scope)
                            {
                                if (!neededDlls.Contains(reference.DeclaringType.Scope))
                                {
                                    neededDlls.Add(reference.DeclaringType.Scope);
                                }
                                AddNeededType(reference.DeclaringType);
                                AddNeededType(reference.FieldType);
                                if (!neededFields.Contains(reference.FullName))
                                {
                                    neededFields.Add(reference.FullName);
                                }
                            }
                        }
                    }
                }
            }
            foreach (var dll in dlls)
            {
                if (neededDlls.Count(d => d.Name == Path.GetFileNameWithoutExtension(dll)) == 0)
                {
                    continue;
                }
                assembly = AssemblyDefinition.ReadAssembly(dll);
                var module = assembly.MainModule;

                var deleteTypes = new List<TypeDefinition>();
                foreach (var type in module.Types)
                {
                    var needRemove = CleanType(type);
                    if (needRemove) deleteTypes.Add(type);
                }
                deleteTypes.ForEach(t => module.Types.Remove(t.Resolve()));

                assembly.Write(dll.Replace("DummyDll", "StrippedDll"));
            }
            Console.WriteLine("");
        }
    }
}

```

`GunfireRebornDumper/Program.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;

namespace GunfireRebornDumper
{
    class Program
    {
        static Int32 appId = 1217060; // could also pull from reading all appmanifests
        static String gameName = "Gunfire Reborn";
        static String steamPath = Path.Combine(Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Valve\Steam").GetValue("SteamPath").ToString(), "steamapps");
        static String gamePath
        {
            get
            {
                if (File.Exists(Path.Combine(steamPath, $"appmanifest_{appId}.acf")))
                    return Path.Combine(steamPath, "common", gameName) + "\\";
                var lib = File.ReadAllLines(Path.Combine(steamPath, "libraryfolders.vdf"));
                foreach (var line in lib)
                {
                    if (line.Contains(@"\\"))
                    {
                        var path = line.Replace("\t", "").Replace("\\\\", "\\").Split(new char[1] { '"' }, StringSplitOptions.RemoveEmptyEntries)[1];
                        if (File.Exists(Path.Combine(path, $"steamapps\\appmanifest_{appId}.acf")))
                            return Path.Combine(path, "steamapps\\common", gameName) + "\\";
                    }
                }
                throw new Exception("Can't find game");
            }
        }
        static void Main(string[] args)
        {
            if (false)
            {
                var config = File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + @"config.json");
                config = config.Replace("\"RequireAnyKey\": true,", "\"RequireAnyKey\": false,");
                File.WriteAllText(AppDomain.CurrentDomain.BaseDirectory + @"config.json", config);
                var Il2CppDumperProgram = Type.GetType("Il2CppDumper.Program, Il2CppDumper");
                var Il2CppDumperMain = Il2CppDumperProgram.GetMethods(BindingFlags.NonPublic | BindingFlags.Static).FirstOrDefault(m => m.Name == "Main");
                Il2CppDumperMain.Invoke(null, new object[1] { (new string[2] { gamePath + gameName + @"_Data\il2cpp_data\Metadata\global-metadata.dat", gamePath + @"GameAssembly.dll" }) });
            }
            if (false)
            {
                var options = new AssemblyUnhollower.UnhollowerOptions();
                options.AdditionalAssembliesBlacklist.Add("Mono.Security"); // always blacklist this one
                options.AdditionalAssembliesBlacklist.Add("Newtonsoft.Json"); // always blacklist this one
                options.UnityBaseLibsDir = AppDomain.CurrentDomain.BaseDirectory + "DummyDll";
                options.SourceDir = AppDomain.CurrentDomain.BaseDirectory + "DummyDll";
                options.OutputDir = AppDomain.CurrentDomain.BaseDirectory + "ProxyDll";
                options.MscorlibPath = @"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorlib.dll";// AppDomain.CurrentDomain.BaseDirectory + @"lib\mscorlib.dll";
                var AssemblyUnhollowerProgram = Type.GetType("AssemblyUnhollower.Program, AssemblyUnhollower");
                var AssemblyUnhollowerMain = AssemblyUnhollowerProgram.GetMethods(BindingFlags.Public | BindingFlags.Static).FirstOrDefault(m => m.Name == "Main" && m.GetParameters()[0].ParameterType == typeof(AssemblyUnhollower.UnhollowerOptions));
                AssemblyUnhollowerMain.Invoke(null, new object[1] { options });
            }
            if (true)
            {
                Minifier.Minify(@"..\..\..\..\GunfireRebornMods\bin\x64\Debug\GunfireRebornMods.exe");
                var options = new AssemblyUnhollower.UnhollowerOptions();
                options.AdditionalAssembliesBlacklist.Add("Mono.Security"); // always blacklist this one
                options.AdditionalAssembliesBlacklist.Add("Newtonsoft.Json"); // always blacklist this one
                options.UnityBaseLibsDir = AppDomain.CurrentDomain.BaseDirectory + "StrippedDll";
                options.SourceDir = AppDomain.CurrentDomain.BaseDirectory + "StrippedDll";
                options.OutputDir = AppDomain.CurrentDomain.BaseDirectory + "FinalDll";
                options.MscorlibPath = @"C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorlib.dll";// AppDomain.CurrentDomain.BaseDirectory + @"lib\mscorlib.dll";
                var AssemblyUnhollowerProgram = Type.GetType("AssemblyUnhollower.Program, AssemblyUnhollower");
                var AssemblyUnhollowerMain = AssemblyUnhollowerProgram.GetMethods(BindingFlags.Public | BindingFlags.Static).FirstOrDefault(m => m.Name == "Main" && m.GetParameters()[0].ParameterType == typeof(AssemblyUnhollower.UnhollowerOptions));
                AssemblyUnhollowerMain.Invoke(null, new object[1] { options });
            }
        }
    }
}

```

`GunfireRebornDumper/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GunfireRebornDumper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("GunfireRebornDumper")]
[assembly: AssemblyCopyright("Copyright ©  2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("385c11ff-ef0f-4fd5-b207-b76820ade367")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`GunfireRebornDumper/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Mono.Cecil" version="0.11.4" targetFramework="net472" />
</packages>
```

`GunfireRebornMods/Common/ModBase.cs`:

```cs
using System;

namespace GunfireRebornMods
{
    public class ModBase
    {
        public String ModName { get; set; } = "Mod Name";
        public virtual Boolean HasConfig { get; set; } = false;
        public virtual Single SliderVal { get; set; } = 5;
        public virtual Single SliderMin { get; set; } = 0;
        public virtual Single SliderMax { get; set; } = 10;
        public Boolean Enabled { get; set; } = false;
        public virtual void Start() { }
        public virtual void Update() { }
        public virtual void OnGUI() { }
        public virtual void OnDisable() { }
        public virtual void OnEnable() { }
    }
}
```

`GunfireRebornMods/Common/ModManager.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace GunfireRebornMods
{
    public class ModManager : MonoBehaviour
    {
        public ModManager(IntPtr intPtr) : base(intPtr) { }
        public List<ModBase> Mods = new List<ModBase>();
        public GUILayoutOption[] GUILayoutOption = new GUILayoutOption[0];
        unsafe void OnGUI()
        {
            foreach (var mod in Mods) if (mod.Enabled) mod.OnGUI();
            if (Cursor.lockState == CursorLockMode.Locked) return;
            var area = new Rect(25, 25, 150, 250);
            GUI.Box(area, "shalzuth's mods");
            GUILayout.BeginArea(area);
            GUILayout.Space(20);
            foreach (var mod in Mods)
            {
                var val = GUILayout.Toggle(mod.Enabled, mod.GetType().Name, GUILayoutOption);
                if (val != mod.Enabled)
                {
                    if (val) mod.OnEnable();
                    else mod.OnDisable();
                    mod.Enabled = val;
                }
                if (mod.Enabled && mod.HasConfig) mod.SliderVal = GUILayout.DoHorizontalSlider(mod.SliderVal, mod.SliderMin, mod.SliderMax, new GUIStyle(GUI.skin.horizontalSlider), new GUIStyle(GUI.skin.horizontalSliderThumb), GUILayoutOption);
                if (mod.Enabled) mod.OnGUI();
            }
            GUILayout.EndArea();
        }

        void Update()
        {
            foreach (var mod in Mods) if (mod.Enabled) mod.Update();
        }
        void OnDisable()
        {
            foreach (var mod in Mods) if (mod.Enabled) mod.OnDisable();
        }
    }
}
```

`GunfireRebornMods/FodyWeavers.xml`:

```xml
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers>
```

`GunfireRebornMods/FodyWeavers.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Costura" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:all>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeRuntimeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged32Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged64Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="PreloadOrder" type="xs:string">
                <xs:annotation>
                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:all>
            <xs:attribute name="CreateTemporaryAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeDebugSymbols" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeReferences" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if runtime assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="UseRuntimeReferencePaths" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls whether the runtime assemblies are embedded with their full path or only with their assembly name.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCompression" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCleanup" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="LoadAtModuleInit" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IgnoreSatelliteAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeRuntimeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of runtime assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged32Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged64Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreloadOrder" type="xs:string">
              <xs:annotation>
                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

`GunfireRebornMods/GunfireRebornMods.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{786E2464-E23C-4392-A81A-870456D7FD63}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>GunfireRebornMods</RootNamespace>
    <AssemblyName>GunfireRebornMods</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>GunfireRebornMods.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Costura, Version=5.3.0.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\Costura.Fody.5.3.0\lib\netstandard1.0\Costura.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Win32.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Win32.Primitives.4.3.0\lib\net46\Microsoft.Win32.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="Mono.Cecil, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Mdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Mdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Pdb, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Pdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Rocks, Version=0.11.4.0, Culture=neutral, PublicKeyToken=50cebf1cceb9d05e, processorArchitecture=MSIL">
      <HintPath>..\packages\Mono.Cecil.0.11.4\lib\net40\Mono.Cecil.Rocks.dll</HintPath>
    </Reference>
    <Reference Include="System">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\DummyDll\System.dll</HintPath>
    </Reference>
    <Reference Include="System.AppContext, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.AppContext.4.3.0\lib\net463\System.AppContext.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.Console, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Console.4.3.0\lib\net46\System.Console.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Core" />
    <Reference Include="System.Diagnostics.Tracing, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.Tracing.4.3.0\lib\net462\System.Diagnostics.Tracing.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Globalization.Calendars, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Globalization.Calendars.4.3.0\lib\net46\System.Globalization.Calendars.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.4.3.0\lib\net46\System.IO.Compression.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.IO.Compression.ZipFile, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.ZipFile.4.3.0\lib\net46\System.IO.Compression.ZipFile.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.4.3.0\lib\net46\System.IO.FileSystem.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.Primitives.4.3.0\lib\net46\System.IO.FileSystem.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.4.3.0\lib\net463\System.Linq.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq.Expressions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.Expressions.4.3.0\lib\net463\System.Linq.Expressions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Http, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Http.4.3.0\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Sockets.4.3.0\lib\net46\System.Net.Sockets.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Reflection, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.4.3.0\lib\net462\System.Reflection.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.4.3.0\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.Extensions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.Extensions.4.3.0\lib\net462\System.Runtime.Extensions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.4.3.0\lib\net463\System.Runtime.InteropServices.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.RuntimeInformation.4.3.0\lib\net45\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Algorithms.4.3.0\lib\net463\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.X509Certificates.4.3.0\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.RegularExpressions, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Text.RegularExpressions.4.3.0\lib\net463\System.Text.RegularExpressions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Xml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Xml.ReaderWriter, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Xml.ReaderWriter.4.3.0\lib\net46\System.Xml.ReaderWriter.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Common\ModManager.cs" />
    <Compile Include="Common\ModBase.cs" />
    <Compile Include="Mods\Aimbot.cs" />
    <Compile Include="Mods\AutoAim.cs" />
    <Compile Include="Mods\SceneDebugger.cs" />
    <Compile Include="Mods\WeaponMod.cs" />
    <Compile Include="Mods\ExtraSensoryPerception.cs" />
    <Compile Include="Mods\FreeCam.cs" />
    <Compile Include="Mods\UnlimitedAmmo.cs" />
    <Compile Include="Mods\GameSpeed.cs" />
    <Compile Include="Mods\JumpHeight.cs" />
    <Compile Include="Mods\MovementSpeed.cs" />
    <Compile Include="NativeNetSharp.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup Condition=" '$(Configuration)' == 'Debug' ">
    <Reference Include="Assembly-CSharp">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\Assembly-CSharp.dll</HintPath>
    </Reference>
    <Reference Include="csharpdata">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\csharpdata.dll</HintPath>
    </Reference>
    <Reference Include="Il2Cppmscorlib">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\Il2Cppmscorlib.dll</HintPath>
    </Reference>
    <Reference Include="Il2CppSystem">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\Il2CppSystem.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\UnityEngine.IMGUIModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\UnityEngine.PhysicsModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.UIElementsModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\ProxyDll\UnityEngine.UIElementsModule.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup Condition=" '$(Configuration)' == 'Release' ">
    <Reference Include="Assembly-CSharp">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\Assembly-CSharp.dll</HintPath>
    </Reference>
    <Reference Include="csharpdata">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\csharpdata.dll</HintPath>
    </Reference>
    <Reference Include="Il2Cppmscorlib">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\Il2Cppmscorlib.dll</HintPath>
    </Reference>
    <Reference Include="Il2CppSystem">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\Il2CppSystem.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\UnityEngine.IMGUIModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\UnityEngine.PhysicsModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.UIElementsModule">
      <HintPath>..\GunfireRebornDumper\bin\x64\Debug\FinalDll\UnityEngine.UIElementsModule.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Il2CppAssemblyUnhollower\UnhollowerBaseLib\UnhollowerBaseLib.csproj">
      <Project>{b7c01ae9-0fc8-4751-b56d-f2ecfc72f269}</Project>
      <Name>UnhollowerBaseLib</Name>
      <Aliases>global</Aliases>
    </ProjectReference>
    <ProjectReference Include="..\Il2CppAssemblyUnhollower\UnhollowerRuntimeLib\UnhollowerRuntimeLib.csproj">
      <Project>{a969803f-c2af-4e42-b772-a48c18116cbc}</Project>
      <Name>UnhollowerRuntimeLib</Name>
      <Aliases>global</Aliases>
      <EmbedInteropTypes>False</EmbedInteropTypes>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\Fody.6.5.1\build\Fody.targets" Condition="Exists('..\packages\Fody.6.5.1\build\Fody.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Fody.6.5.1\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Fody.6.5.1\build\Fody.targets'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets'))" />
  </Target>
  <Import Project="..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets" Condition="Exists('..\packages\Costura.Fody.5.3.0\build\Costura.Fody.targets')" />
</Project>
```

`GunfireRebornMods/Mods/Aimbot.cs`:

```cs
using UnityEngine;
using System.Runtime.InteropServices;
namespace GunfireRebornMods
{
    public class Aimbot : ModBase
    {
        [DllImport("user32.dll")] static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);
        bool Toggled = false;
        // thx https://github.com/pentium1131/GunfireReborn-aimbot
        public override void Update()
        {
            if (Input.GetKeyDown(KeyCode.X)) Toggled = !Toggled;
            if (Toggled) return;
            var monsters = NewPlayerManager.GetMonsters();
            if (monsters != null)
            {
                Transform closestMonster = null;
                var closestMonsterDist = 99999f;
                foreach (var monster in monsters)
                {
                    if (monster == null) continue;
                    var bodyPartCom = monster.BodyPartCom;
                    if (bodyPartCom == null) continue;
                    var monsterTransform = bodyPartCom.GetWeakTrans(true);
                    if (monsterTransform == null) continue;
                    var vec = CameraManager.MainCameraCom.WorldToViewportPoint(monsterTransform.position);
                    if (true)
                    {
                        if (vec.z <= 0) continue;
                        vec.y = 0;
                        vec.x = 0.5f - vec.x;
                        vec.x = Screen.width * vec.x;
                        vec.z = 0f;
                        if (vec.magnitude > 150f) continue;
                    }
                    vec = monsterTransform.position - CameraManager.MainCamera.position;
                    var ray = new Ray(CameraManager.MainCamera.position, vec);
                    var hits = Physics.RaycastAll(ray, vec.magnitude);
                    var visible = true;
                    foreach (var hit in hits)
                    {
                        if (hit.collider.gameObject.layer == 0 || hit.collider.gameObject.layer == 30 || hit.collider.gameObject.layer == 31) //&& hit.collider.name.Contains("_")
                        {
                            visible = false;
                            break;
                        }
                    }
                    if (visible)
                    {
                        if (vec.magnitude < closestMonsterDist)
                        {
                            closestMonsterDist = vec.magnitude;
                            closestMonster = monsterTransform;
                        }
                    }
                }
                if (closestMonster != null)
                {
                    var offset = closestMonster.position;
                    offset += new Vector3(0, 0.2f);
                    var screenAim = CameraManager.MainCameraCom.WorldToScreenPoint(offset);
                    var aimTarget = new Vector2(screenAim.x, Screen.height - screenAim.y);
                    if (aimTarget != Vector2.zero)
                    {
                        var x = aimTarget.x - Screen.width / 2.0f;
                        var y = aimTarget.y - Screen.height / 2.0f;
                        x /= 2.5f;
                        y /= 2.5f;
                        mouse_event(0x0001, (int)x, (int)y, 0, 0);
                    }
                }
            }
        }
    }
}

```

`GunfireRebornMods/Mods/AutoAim.cs`:

```cs
using UnityEngine;
namespace GunfireRebornMods
{
    public class AutoAim : ModBase
    {
        public override void OnEnable()
        {
            GameObject.FindObjectOfType<PCControllerAutoShoot_Logic>().speed = 100;            
        }
        public override void Update()
        {
            AutoAimat.AimAtTarget(100f);
            DetectionClass.aimAssist = true;
        }
        public override void OnDisable()
        {
            GameObject.FindObjectOfType<PCControllerAutoShoot_Logic>().speed = 0;
        }
    }
}

```

`GunfireRebornMods/Mods/ExtraSensoryPerception.cs`:

```cs
using DataHelper;
using UnityEngine;

namespace GunfireRebornMods
{
    public class ExtraSensoryPerception : ModBase
    {
        public bool ShowObject(NewPlayerObject obj)
        {
            if (obj.FightType == ServerDefine.FightType.NWARRIOR_DROP_EQUIP) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_DROP_RELIC) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_SMITH) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_SHOP) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_GSCASHSHOP) return true;
            else if (obj.FightType == ServerDefine.FightType.WARRIOR_OBSTACLE_NORMAL && (obj.Shape == 4406 || obj.Shape == 4419 || obj.Shape == 4427)) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_EVENT) return true;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_ITEMBOX) return true;
            return false;

        }
        public string FightTypeToString(NewPlayerObject obj)
        {
            if (obj.FightType == ServerDefine.FightType.NWARRIOR_DROP_EQUIP) return DataMgr.GetWeaponData(obj.Shape).Name + " +" + obj.DropOPCom.WeaponInfo.SIProp.Grade.ToString();
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_DROP_RELIC) return DataMgr.GetRelicData(obj.DropOPCom.RelicSid).Name;
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_SMITH) return "Smith";
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_SHOP) return "Kermit";
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_GSCASHSHOP) return "GhostKermit";
            else if (obj.FightType == ServerDefine.FightType.WARRIOR_OBSTACLE_NORMAL && (obj.Shape == 4406 || obj.Shape == 4419 || obj.Shape == 4427)) return "Vault";
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_EVENT) return "Chest";
            else if (obj.FightType == ServerDefine.FightType.NWARRIOR_NPC_ITEMBOX) return "Chest";
            return "unk";
        }
        public override void OnEnable()
        {
            foreach (var monster in NewPlayerManager.MonsterLst)
            {
                System.Console.WriteLine("MonsterLst : " + monster.FightType);
            }
            foreach (var monster in NewPlayerManager.PlayerDict)
            {
                var val = monster.Value;
                System.Console.WriteLine("PlayerDict : " + monster.Value.FightType);
            }
            foreach (var monster in NewPlayerManager.NpcLst)
            {
                System.Console.WriteLine("NpcLst : " + monster.FightType);
            }
        }
        public override void Update()
        {
            var mon = NewPlayerManager.GetMonsters();
            foreach (var m in mon) if (m.BloodBarCom != null) m.BloodBarCom.ShowBloodBar();
            //foreach (var m in NewPlayerManager.MonsterLst) if (m.BloodBarCom != null) m.BloodBarCom.ShowBloodBar();
        }
        public override void OnGUI()
        {
            foreach (var p in NewPlayerManager.PlayerDict)
            {
                var val = p.Value;
                if (val.centerPointTrans == null) continue;
                if (!ShowObject(val)) continue;
                var screenPos = CameraManager.MainCameraCom.WorldToScreenPoint(val.centerPointTrans.transform.position);
                if (screenPos.z > 0)
                {
                    var dist = Vector3.Distance(HeroMoveManager.HeroObj.centerPointTrans.position, val.centerPointTrans.position).ToString("0.0");
                    GUI.Label(new Rect(screenPos.x, Screen.height - screenPos.y, 800, 50), FightTypeToString(val) + "(" + dist + "m)");
                    //GUI.Label(new Rect(screenPos.x, Screen.height - screenPos.y, 800, 50), monster.Value.SID + " : " + monster.Value.Shape + " : " + monster.Value.FightType);
                }
            }
        }
    }
}

```

`GunfireRebornMods/Mods/FreeCam.cs`:

```cs
using UnityEngine;
namespace GunfireRebornMods
{
    public class FreeCam : ModBase
    {
        Vector3 LastPos;
        Vector3 LastAngle;
        public override void Update()
        {
            var x = Input.GetAxis("Mouse X");
            var y = Input.GetAxis("Mouse Y");
            var lastMouse = new Vector3(x, y);
            if (Input.GetKey(KeyCode.LeftAlt))
            {
                Cursor.lockState = CursorLockMode.None;
                Cursor.visible = true;
                return;
            }
            else
            {
                Cursor.lockState = CursorLockMode.Locked;
                Cursor.visible = false;
            }
            var f = 0.0f;
            var p = GetBaseInput();
            p = p * mainSpeed;
            p = p * Time.deltaTime;
            var cameraTransform = CameraManager.MainCameraCom.transform;
            LastPos = cameraTransform.position;
            cameraTransform.position = LastPos;
            cameraTransform.Translate(p);
            LastPos = cameraTransform.position;

            LastAngle = cameraTransform.eulerAngles;
            lastMouse = new Vector3(-lastMouse.y * camSens, lastMouse.x * camSens, 0);
            lastMouse = new Vector3(LastAngle.x + lastMouse.x, LastAngle.y + lastMouse.y, 0);
            cameraTransform.eulerAngles = lastMouse;
            LastAngle = cameraTransform.eulerAngles;
        }
        float mainSpeed = 10f;
        float camSens = 5f;
        Vector3 GetBaseInput()
        {
            var dir = Vector3.zero;
            if (Input.GetKey(KeyCode.W))
                dir += new Vector3(0, 0, 1);
            if (Input.GetKey(KeyCode.S))
                dir += new Vector3(0, 0, -1);
            if (Input.GetKey(KeyCode.A))
                dir += new Vector3(-1, 0, 0);
            if (Input.GetKey(KeyCode.D))
                dir += new Vector3(1, 0, 0);
            if (Input.GetKey(KeyCode.Space))
                dir += new Vector3(0, 1, 0);
            if (Input.GetKey(KeyCode.C))
                dir += new Vector3(0, -1, 0);
            return dir;
        }
    }
}

```

`GunfireRebornMods/Mods/GameSpeed.cs`:

```cs
namespace GunfireRebornMods
{
    public class GameSpeed : ModBase
    {
        public override bool HasConfig { get; set; } =  true;
        public override void Update()
        {
            UnityEngine.Time.timeScale = SliderVal;
        }
        public override void OnDisable()
        {
            UnityEngine.Time.timeScale = 1.0f;
        }
    }
}

```

`GunfireRebornMods/Mods/JumpHeight.cs`:

```cs
namespace GunfireRebornMods
{
    public class JumpHeight : ModBase
    {
        public override bool HasConfig { get; set; } = true;
        public override float SliderMin { get; set; } = 0;
        public override float SliderVal { get; set; } = 8f;
        public override float SliderMax { get; set; } = 30f;
        float orig = 0;
        public override void Update()
        {
            if (orig == 0) orig = HeroMoveManager.HMMJS.jumping.baseHeight; //HeroMoveManager.HMMJS.jumping.StoredDefaultHeight;// HeroMoveManager.HMMJS.jumping.baseHeight;
            HeroMoveManager.HMMJS.jumping.baseHeight = (SliderVal * SliderVal) / (HeroMoveManager.HMMJS.movement.gravity * 2);

            //HeroMoveManager.HMMJS?.SetJumperHeight(SliderVal);
            //HeroMoveManager.HMMJS.jumping.StoredDefaultHeight = HeroMoveManager.HMMJS.jumping.baseHeight;
        }
        public override void OnDisable()
        {
            HeroMoveManager.HMMJS.jumping.baseHeight = orig;
        }
    }
}

```

`GunfireRebornMods/Mods/MovementSpeed.cs`:

```cs
namespace GunfireRebornMods
{
    public class MovementSpeed : ModBase
    {
        public override bool HasConfig { get; set; } = true;
        public override float SliderMin { get; set; } = 0;
        public override float SliderVal { get; set; } = 10f;
        public override float SliderMax { get; set; } = 30f;
        float orig = 0;
        public override void Update()
        {
            if (orig == 0) orig = HeroMoveManager.HMMJS.maxForwardSpeed;
            //HeroMoveManager.HMMJS.SetSpeed(12);
            HeroMoveManager.HMMJS.maxForwardSpeed = HeroMoveManager.HMMJS.maxBackwardsSpeed = HeroMoveManager.HMMJS.maxSidewaysSpeed = SliderVal;
        }
        public override void OnDisable()
        {
            HeroMoveManager.HMMJS.maxForwardSpeed = HeroMoveManager.HMMJS.maxBackwardsSpeed = HeroMoveManager.HMMJS.maxSidewaysSpeed = orig;
        }
    }
}

```

`GunfireRebornMods/Mods/SceneDebugger.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace GunfireRebornMods
{
    public class SceneDebugger : ModBase
    {
        Rect HierarchyWindow;
        Vector2 HierarchyScrollPos;
        String SearchText = "";
        Vector2 PropertiesScrollPos;
        Transform SelectedGameObject;
        List<String> ExpandedObjs = new List<String>();

        Rect ProjectWindow;
        Vector2 ProjectScrollPos;
        ConcurrentDictionary<object, Boolean> ExpandedObjects = new ConcurrentDictionary<object, Boolean>();

        public override void OnEnable()
        {
            ModName = "Scene Debugger";
            HasConfig = false;

            RootObjects = new List<GameObject>();
        }
        public override void OnGUI()
        {
            var area = new Rect(525, 25, 250, 800);
            GUI.Box(area, "scene debugger");
            GUILayout.BeginArea(area);
            GUILayout.Space(12);
            HierarchyWindowMethod(0);
            GUILayout.EndArea();
           // HierarchyWindow = GUILayout.Window(HierarchyWindowId, HierarchyWindow, (GUI.WindowFunction)HierarchyWindowMethod, "Hierarchy", new GUILayoutOption[0]);
            //ProjectWindow = GUILayout.Window(ProjectWindowId, ProjectWindow, (GUI.WindowFunction)ProjectWindowMethod, "Project", new GUILayoutOption[0]);
        }
        #region Hierarchy GUI
        void DisplayGameObject(GameObject gameObj, Int32 level)
        {
            GUILayout.BeginHorizontal(new GUILayoutOption[0]);
            {
                GUILayout.Space(level * 20);
                var color = GUI.color;
                if (SelectedGameObject == gameObj.transform)
                    GUI.color = Color.green;
                if (!gameObj.activeSelf && gameObj.transform.childCount == 0)
                    GUI.color = Color.magenta;
                else if (gameObj.transform.childCount == 0)
                    GUI.color = Color.yellow;
                else if (!gameObj.activeSelf)
                    GUI.color = Color.red;
                if (GUILayout.Toggle(ExpandedObjs.Contains(gameObj.name), gameObj.name, new GUILayoutOption[1] { GUILayout.ExpandWidth(false) }))
                {
                    if (!ExpandedObjs.Contains(gameObj.name))
                    {
                        ExpandedObjs.Add(gameObj.name);
                        SelectedGameObject = gameObj.transform;
                    }
                }
                else
                {
                    if (ExpandedObjs.Contains(gameObj.name))
                    {
                        ExpandedObjs.Remove(gameObj.name);
                        SelectedGameObject = gameObj.transform;
                    }
                }
                GUI.color = color;
            }
            GUILayout.EndHorizontal();
            if (ExpandedObjs.Contains(gameObj.name))
                for (var i = 0; i < gameObj.transform.childCount; ++i)
                    DisplayGameObject(gameObj.transform.GetChild(i).gameObject, level + 1);
        }
        List<GameObject> RootObjects = new List<GameObject>();
        void HierarchyWindowMethod(Int32 id)
        {
            GUILayout.BeginVertical(GUIContent.none, GUI.skin.box, new GUILayoutOption[0]);// { GUI.skin.box });
            {
                GUILayout.BeginHorizontal(new GUILayoutOption[0]);
                {
                    SearchText = GUILayout.TextField(SearchText, 100, new GUILayoutOption[1] { GUILayout.ExpandWidth(true) });
                    if (GUILayout.Button("Search", new GUILayoutOption[1] { GUILayout.ExpandWidth(false) }))
                    { }
                }
                GUILayout.EndHorizontal();
                if (RootObjects.Count == 0)
                {
                    foreach (Transform xform in GameObject.FindObjectsOfType<Transform>())
                        if (xform.parent == null && !xform.name.Contains("(Clone)"))
                            RootObjects.Add(xform.gameObject);
                }
                //var rootObjects = UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects();
                if (SelectedGameObject == null)
                    SelectedGameObject = RootObjects.First().transform;
                HierarchyScrollPos = GUILayout.BeginScrollView(HierarchyScrollPos, new GUILayoutOption[2] { GUILayout.Height(HierarchyWindow.height / 3), GUILayout.ExpandWidth(true) });
                {
                    foreach (var rootObject in RootObjects)
                        DisplayGameObject(rootObject, 0);
                }
                GUILayout.EndScrollView();
            }
            GUILayout.EndVertical();
            GUILayout.BeginVertical(GUIContent.none, GUI.skin.box, new GUILayoutOption[0]);//GUI.skin.box);
            {
                PropertiesScrollPos = GUILayout.BeginScrollView(PropertiesScrollPos, new GUILayoutOption[0]);// GUI.skin.box);
                {
                    var fullName = SelectedGameObject.name;
                    var parentTransform = SelectedGameObject.parent;
                    while (parentTransform != null)
                    {
                        fullName = parentTransform.name + "/" + fullName;
                        parentTransform = parentTransform.parent;
                    }
                    GUILayout.Label(fullName, new GUILayoutOption[0]);
                    GUILayout.BeginHorizontal(new GUILayoutOption[0]);
                    {
                        GUILayout.Label(SelectedGameObject.gameObject.layer + " : " + LayerMask.LayerToName(SelectedGameObject.gameObject.layer), new GUILayoutOption[0]);
                        GUILayout.FlexibleSpace();
                        SelectedGameObject.gameObject.SetActive(GUILayout.Toggle(SelectedGameObject.gameObject.activeSelf, "Active", new GUILayoutOption[1] { GUILayout.ExpandWidth(false) }));
                        if (GUILayout.Button("?", new GUILayoutOption[0]))
                            Console.WriteLine("?");
                        if (GUILayout.Button("X", new GUILayoutOption[0]))
                            GameObject.Destroy(SelectedGameObject.gameObject);
                    }
                    GUILayout.EndHorizontal();
                    foreach (var component in SelectedGameObject.GetComponents<Component>())
                    {
                        GUILayout.BeginHorizontal(GUIContent.none, GUI.skin.box, new GUILayoutOption[0]);// GUI.skin.box);
                        {

                            if (component is Behaviour)
                                (component as Behaviour).enabled = GUILayout.Toggle((component as Behaviour).enabled, "", new GUILayoutOption[1] { GUILayout.ExpandWidth(false) });

                            GUILayout.Label(component.GetIl2CppType().Name + " : " + component.GetIl2CppType().Namespace, new GUILayoutOption[0]);
                            GUILayout.FlexibleSpace();
                            if (GUILayout.Button("?", new GUILayoutOption[0]))
                                Console.WriteLine("?");
                            if (!(component is Transform))
                                if (GUILayout.Button("X", new GUILayoutOption[0]))
                                    GameObject.Destroy(component);
                        }
                        GUILayout.EndHorizontal();
                    }
                }
                GUILayout.EndScrollView();
            }
            GUILayout.EndVertical();
            //GUI.DragWindow();
        }
        #endregion
        #region Project GUI
        void ProjectWindowMethod(Int32 id)
        {
            GUILayout.BeginVertical(GUIContent.none, GUI.skin.box, new GUILayoutOption[0]);// GUI.skin.box);
            {
                ProjectScrollPos = GUILayout.BeginScrollView(ProjectScrollPos, new GUILayoutOption[2] { GUILayout.Height(ProjectWindow.height / 3), GUILayout.ExpandWidth(true) });
                {
                    var assemblies = AppDomain.CurrentDomain.GetAssemblies();
                    foreach (var assembly in assemblies)
                    {
                        ExpandedObjects[assembly] = GUILayout.Toggle(ExpandedObjects.ContainsKey(assembly) ? ExpandedObjects[assembly] : false, assembly.GetName().Name, new GUILayoutOption[1] { GUILayout.ExpandWidth(false) });
                        if (ExpandedObjects[assembly])
                        {
                            var types = assembly.GetTypes().Where(t => t.IsClass && !t.IsAbstract && !t.ContainsGenericParameters).ToList();
                            foreach (var type in types)
                            {
                                var staticfields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.FlattenHierarchy).Count(f => f.Name != "OffsetOfInstanceIDInCPlusPlusObject");
                                if (staticfields == 0)
                                    continue;
                                GUILayout.BeginHorizontal(new GUILayoutOption[0]);
                                {
                                    var color = GUI.color;
                                    GUILayout.Space(20);
                                    ExpandedObjects[type] = GUILayout.Toggle(ExpandedObjects.ContainsKey(type) ? ExpandedObjects[type] : false, type.Name, new GUILayoutOption[1] { GUILayout.ExpandWidth(false) });
                                    GUI.color = color;
                                }
                                GUILayout.EndHorizontal();
                                if (ExpandedObjects[type])
                                {
                                    var fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.FlattenHierarchy);
                                    foreach (var field in fields)
                                    {
                                        if (field.Name == "OffsetOfInstanceIDInCPlusPlusObject") continue;
                                        //var val = field.GetValue(null);
                                        GUILayout.BeginHorizontal(new GUILayoutOption[0]);
                                        {
                                            GUILayout.Space(40);
                                            ExpandedObjects[field] = GUILayout.Toggle(ExpandedObjects.ContainsKey(field) ? ExpandedObjects[field] : false, field.Name + " : " + field.FieldType, new GUILayoutOption[1] { GUILayout.ExpandWidth(false) });
                                        }
                                        GUILayout.EndHorizontal();
                                    }
                                }
                            }
                        }
                    }
                }
                GUILayout.EndScrollView();
            }
            GUILayout.EndVertical();
            //GUI.DragWindow();
        }
        #endregion
    }
}
```

`GunfireRebornMods/Mods/UnlimitedAmmo.cs`:

```cs
namespace GunfireRebornMods
{
    public class Ammo : ModBase
    {
        public override void Update()
        {
            var ws = HeroMoveManager.HeroObj?.BulletPreFormCom?.weapondict;
            foreach (var w in ws) w.value?.ReloadBulletImmediately();
            foreach (var w in ws) w.value?.ModifyBulletInMagzine(1, 100);
            // or Hook ConsumeBulletFromMag
        }
    }
}

```

`GunfireRebornMods/Mods/WeaponMod.cs`:

```cs
using UnityEngine;
namespace GunfireRebornMods
{
    public class WeaponMod : ModBase
    {
        Vector2 ScrollPos = Vector2.zero;
        public override void Update()
        {
            var ws = HeroMoveManager.HeroObj?.BulletPreFormCom?.weapondict;
            foreach (var w in ws)
            {
                if (w.value.WeaponAttr.Radius != 500f)  w.value.WeaponAttr.Radius = 500f;
                //if (w.value.WeaponAttr.Accuracy != 10000) w.value.WeaponAttr.Accuracy = 10000;
                if (w.value.WeaponAttr.AttDis != 500f) w.value.WeaponAttr.AttDis = 500f;
                // if (w.value.WeaponAttr.Pierce != 99) w.value.WeaponAttr.Pierce = 99; 
                if (w.value.WeaponAttr.BulletSpeed >= 50f && w.value.WeaponAttr.BulletSpeed != 55f && w.value.WeaponAttr.BulletSpeed != 500f || w.value.WeaponAttr.BulletSpeed == 30f) w.value.WeaponAttr.BulletSpeed = 500f;
                //if (w.value.WeaponAttr.Stability != 10000) w.value.WeaponAttr.Stability = 10000;
                if (w.value.WeaponAttr.Radius > 0f && w.value.WeaponAttr.Radius < 9f) w.value.WeaponAttr.Radius = 9f;
            }
        }
    }
}

```

`GunfireRebornMods/NativeNetSharp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

using System.IO;
using Microsoft.Win32.SafeHandles;

namespace GunfireRebornMods
{
    public unsafe static class NativeNetSharp
    {
        public delegate dynamic DynamicDelegate(params dynamic[] args);
        static ModuleBuilder moduleBuilder;
        public static IntPtr GetFunctionPointerForNativeCode(Action a)
        {
            var methodInfo = a.Method;
            if (moduleBuilder == null) moduleBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("JitDelegateTypes"), AssemblyBuilderAccess.Run).DefineDynamicModule("JitDelegateTypes");
            var parameters = methodInfo.GetParameters().Select(x => x.ParameterType).ToArray();
            var builder = moduleBuilder.DefineType(methodInfo.Name + "Delegate", TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass, typeof(MulticastDelegate));
            builder.DefineConstructor(MethodAttributes.RTSpecialName | MethodAttributes.HideBySig | MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(Object), typeof(IntPtr) }).SetImplementationFlags(MethodImplAttributes.Runtime | MethodImplAttributes.Managed);
            builder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual, methodInfo.ReturnType, parameters).SetImplementationFlags(MethodImplAttributes.Runtime | MethodImplAttributes.Managed);
            var delegateType = builder.CreateTypeInfo();
            var dlg = Delegate.CreateDelegate(delegateType, null, methodInfo);
            return Marshal.GetFunctionPointerForDelegate<Delegate>(dlg);
        }
        public static T FastCallDelegate<T>(IntPtr functionPtr)
        {
            var wrapper = new List<Byte>();
            wrapper.Add(0x58);          // pop eax  - store the return address
            wrapper.Add(0x59);          // pop ecx  - move the 1st argument to ecx
            wrapper.Add(0x5A);          // pop edx  - move the 2nd argument to edx
            wrapper.Add(0x50);          // push eax - restore the return address
            wrapper.Add(0x68);                                                  // push ...
            wrapper.AddRange(BitConverter.GetBytes(functionPtr.ToInt32()));     // the function address to call
            wrapper.Add(0xC3);                                                  // ret - and jump to
            var wrapperPtr = Marshal.AllocHGlobal(wrapper.Count);
            Marshal.Copy(wrapper.ToArray(), 0, wrapperPtr, wrapper.Count);
            return Marshal.GetDelegateForFunctionPointer<T>(wrapperPtr);
        }
        public static void JmpPatch(IntPtr originalPtr, IntPtr replacement)
        {
            // todo fix
            throw new Exception("JmpPatch not supported");
            var origCodeLoc = Marshal.ReadIntPtr(originalPtr);
            var jmpToNew = new List<Byte>();
            if (Environment.Is64BitProcess)
            {
                jmpToNew.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
                jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt64()));
                jmpToNew.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            }
            else
            {
                jmpToNew.Add(0xB8); // mov eax
                jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt32()));
                jmpToNew.AddRange(new Byte[] { 0xFF, 0xE0 }); // jmp eax
            }
            var origCode = new byte[0x12];
            Marshal.Copy(origCodeLoc, origCode, 0, origCode.Length);
            var jmpToOrig = new List<Byte>();
            jmpToOrig.AddRange(origCode);
            if (Environment.Is64BitProcess)
            {
                jmpToOrig.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
                jmpToOrig.AddRange(BitConverter.GetBytes((origCodeLoc + origCode.Length).ToInt64()));
                jmpToOrig.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            }
            else
            {

            }
            var newFuncLocation = VirtualAllocEx(GetCurrentProcess(), IntPtr.Zero, 0x100, 0x3000, 0x40);
            Marshal.Copy(jmpToOrig.ToArray(), 0, newFuncLocation, jmpToOrig.ToArray().Length);

            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, (UInt32)0x40, out UInt32 old);
            Marshal.Copy(jmpToNew.ToArray(), 0, origCodeLoc, jmpToNew.ToArray().Length);
            FlushInstructionCache(GetCurrentProcess(), origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length);
            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, old, out UInt32 _);

            Marshal.WriteIntPtr(originalPtr, newFuncLocation);
        }
        public static IntPtr baseAddress;
        public static IntPtr procHandle;
        public static Boolean target32Bit = false;
        public static void Inject(String procName, Byte[] exeBytes)
        {
            var CLSID_CLRMetaHost = new Guid("9280188D-0E8E-4867-B30C-7FA83884E8DE").ToByteArray();
            var IID_ICLRMetaHost = new Guid("D332DB9E-B9B3-4125-8207-A14884F53216").ToByteArray();
            var IID_ICLRRuntimeInfo = new Guid("BD39D1D2-BA2F-486A-89B0-B4B0CB466891").ToByteArray();
            var CLSID_CorRuntimeHost = new Guid("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E").ToByteArray();
            var IID_ICorRuntimeHost = new Guid("CB2F6722-AB3A-11D2-9C40-00C04FA30A3E").ToByteArray();
            var _AppDomain = new Guid("05F696DC-2B29-3663-AD8B-C4389CF2A713").ToByteArray();
            var CLSID_CLRRuntimeHost = new Guid("90F1A06E-7712-4762-86B5-7A5EBA6BDB02").ToByteArray();
            var IID_ICLRRuntimeHost = new Guid("90F1A06C-7712-4762-86B5-7A5EBA6BDB02").ToByteArray();

            var targetProcess = Process.GetProcessesByName(procName)[0];
            procHandle = OpenProcess(0x43a, false, targetProcess.Id);
            if (procHandle == IntPtr.Zero) throw new Exception("can't open target process. try run as admin");
            baseAddress = GetBaseAddress();
            if (!IsWow64Process(procHandle, out target32Bit)) target32Bit = IntPtr.Size == 4;
            RemoteLoadLibrary("mscoree.dll");
            var ptrSize = target32Bit ? 4 : 8;

            var CLRCreateInstance = GetProcAddress("mscoree.dll", "CLRCreateInstance");
            var safeArray = CreateSafeArray(exeBytes.ToList());
            var metaHost = ExecFunc(CLRCreateInstance, CLSID_CLRMetaHost, IID_ICLRMetaHost, new Byte[0]);
            var runtime = ExecVTable(metaHost, 3 * ptrSize, Encoding.Unicode.GetBytes("v4.0.30319"), IID_ICLRRuntimeInfo, new Byte[0]);
            var runtimeHost = ExecVTable(runtime, 9 * ptrSize, CLSID_CorRuntimeHost, IID_ICorRuntimeHost, new Byte[0]);
            var started = ExecVTable(runtimeHost, 0xA * ptrSize);
            var domain = ExecVTable(runtimeHost, 0xD * ptrSize, new Byte[0]);
            var appDomain = ExecVTable(domain, 0, _AppDomain, new Byte[0]);
            var assembly = ExecVTable(appDomain, 0x2D * ptrSize, BitConverter.GetBytes((UInt64)safeArray), new Byte[0]);
            var method = ExecVTable(assembly, 0x10 * ptrSize, new Byte[0]);
            var variant = new Byte[0x18]; variant[0] = 1;
            var mainReturnVal = new Byte[0x18];
            var methodResult = ExecVTable(method, 0x25 * ptrSize, variant, new Byte[8], new Byte[8], new Byte[8], new Byte[8], mainReturnVal); // todo fix parameters... x86 has more?
            var val = BitConverter.ToUInt64(mainReturnVal, 8);
            //var released = ExecVTable(method, 2 * ptrSize); // not sure how this works if the app is still running.
            //VirtualFreeEx(procHandle, safeArray - 0x10, 0, 0x8000);
            //var stopped = ExecVTable(runtimeHost, 0xB * ptrSize); // not sure how this works if the app is still running.
        }
        [DllImport("kernel32")] static extern IntPtr GetCurrentProcess();
        [DllImport("kernel32")] static extern IntPtr OpenProcess(Int32 dwDesiredAccess, Boolean bInheritHandle, Int32 dwProcessId);
        [DllImport("kernel32")] static extern IntPtr GetModuleHandle(String lpModuleName);
        //[DllImport("kernel32")] static extern IntPtr GetProcAddress(IntPtr hModule, String procName);
        [DllImport("kernel32")] static extern Boolean FlushInstructionCache(IntPtr hProcess, IntPtr lpBaseAddress, UIntPtr dwSize);
        [DllImport("kernel32")] public static extern Boolean VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, UInt32 flAllocationType, UInt32 flProtect);
        [DllImport("kernel32")] static extern Int32 ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [In, Out] Byte[] buffer, Int32 size, out Int32 lpNumberOfBytesRead);
        [DllImport("kernel32")] static extern Boolean WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, Byte[] lpBuffer, Int32 nSize, out Int32 lpNumberOfBytesWritten);
        [DllImport("kernel32")] static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32")] static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        [DllImport("kernel32")] static extern Int32 CloseHandle(IntPtr hObject);
        [DllImport("kernel32")] static extern Boolean VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);
        [DllImport("kernel32")] static extern Boolean VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 dwFreeType);
        [DllImport("kernel32")] static extern Boolean IsWow64Process(IntPtr processHandle, out Boolean wow64Process);
        [DllImport("psapi")] static extern bool GetModuleInformation(IntPtr hProcess, IntPtr hModule, out MODULEINFO lpmodinfo, UInt32 cb);
        [DllImport("psapi")] static extern bool EnumProcessModulesEx(IntPtr hProcess, IntPtr[] lphModule, UInt32 cb, out UInt32 lpcbNeeded, UInt32 dwFilterFlag);
        [DllImport("psapi")] static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, [Out] StringBuilder lpBaseName, UInt32 nSize);
        [DllImport("kernel32")] public static extern IntPtr GetStdHandle(Int32 nStdHandle);
        [DllImport("kernel32")] public static extern int AllocConsole();
        [DllImport("kernel32")] public static extern int FreeConsole();
        [StructLayout(LayoutKind.Sequential)]
        public struct MODULEINFO
        {
            public IntPtr lpBaseOfDll;
            public UInt32 SizeOfImage;
            public IntPtr EntryPoint;
        }
        public static IntPtr CreateSafeArray(List<Byte> bytes)
        {
            var safeArray = VirtualAllocEx(procHandle, IntPtr.Zero, bytes.Count + 0x30, 0x1000, 4);
            var safeArrayBytes = new List<Byte>();
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ??
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0x11)); // arrayType... weird
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt16)1)); // cDims
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt16)0x80)); // fFeatures
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)1)); // cbElements
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // cLocks
            if (!target32Bit) safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // ???
            safeArrayBytes.AddRange(target32Bit ? BitConverter.GetBytes((Int32)safeArray + 0x28) : BitConverter.GetBytes((UInt64)safeArray + 0x30)); // pvData
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)bytes.Count)); // rgsabound numElements
            safeArrayBytes.AddRange(BitConverter.GetBytes((UInt32)0)); // rgsabound min
            safeArrayBytes.AddRange(bytes);
            WriteProcessMemory(procHandle, safeArray, safeArrayBytes.ToArray(), safeArrayBytes.Count, out _);
            return safeArray + 0x10;
        }
        public static IntPtr ExecVTable(IntPtr obj, Int32 offset, params Byte[][] args)
        {
            var methodAddr = ReadIntPtr(ReadIntPtr(obj) + offset);
            args = args.Prepend(BitConverter.GetBytes((UInt64)obj)).ToArray();
            return ExecFunc(methodAddr, args);
        }
        public static IntPtr ExecFunc(IntPtr funcAddr, params Byte[][] args)
        {
            var newArgs = new List<IntPtr>();
            foreach (var arg in args)
            {
                if (arg.Length == 8) newArgs.Add((IntPtr)(target32Bit ? BitConverter.ToInt32(arg, 0) : BitConverter.ToInt64(arg, 0))); // todo fix hack for direct args
                else
                {
                    var argLength = arg.Length == 0 ? 0x8 : arg.Length;
                    var argVal = arg;
                    if (arg.Length == 0)
                    {
                        argLength = target32Bit ? 4 : 8;
                        argVal = new byte[argLength];
                    }
                    var temp = VirtualAllocEx(procHandle, IntPtr.Zero, argLength, 0x3000, 0x40);
                    WriteProcessMemory(procHandle, temp, argVal, argLength, out _);
                    newArgs.Add(temp);
                }
            }
            var retVal = ExecFunc(funcAddr, newArgs.ToArray());
            for (var i = 0; i < args.Length; i++)
            {
                var arg = args[i];
                var argLength = arg.Length == 0 ? (target32Bit ? 4 : 8) : arg.Length;
                var buf = new Byte[argLength];
                if (args[i].Length == 8u) { }
                else
                {
                    ReadProcessMemory(procHandle, newArgs[i], buf, buf.Length, out _);
                    if (args[i].Length != argLength) Array.Resize(ref args[i], argLength);
                    Array.Copy(buf, args[i], argLength);
                    VirtualFreeEx(procHandle, newArgs[i], 0, 0x8000);
                }
            }
            if (retVal == IntPtr.Zero && args.ToList().Last().Length == (target32Bit ? 4u : 8u)) return (IntPtr)(target32Bit ? BitConverter.ToInt32(args.ToList().Last(), 0) : BitConverter.ToInt64(args.ToList().Last(), 0)); // todo fix hack for arg refs
            else return retVal;
        }
        public static IntPtr ExecFunc(IntPtr funcAddr, params IntPtr[] args)
        {
            var asm = new List<Byte>();
            var retVal = VirtualAllocEx(procHandle, IntPtr.Zero, 8, 0x3000, 4);
            WriteProcessMemory(procHandle, retVal, BitConverter.GetBytes(0xdeadbeefcafef00d), 8, out _);
            if (target32Bit)
            {
                for (var i = args.Length - 1; i >= 0; i--)
                {
                    asm.Add(0x68); // push
                    asm.AddRange(BitConverter.GetBytes((UInt32)args[i]));
                }
                asm.Add(0xB8); // mov eax
                asm.AddRange(BitConverter.GetBytes((UInt32)funcAddr));
                asm.AddRange(new Byte[] { 0xFF, 0xD0 }); // call eax
                // todo fix this?
                //asm.AddRange(new Byte[] { 0x83, 0xC4 }); // add esp
                //asm.Add((Byte)(args.Length * 4));
                asm.Add(0xA3); // mov eax to
                asm.AddRange(BitConverter.GetBytes((UInt32)retVal));
            }
            else
            {
                asm.AddRange(new Byte[] { 0x48, 0x83, 0xEC, 0x38 }); // sub rsp 0x38
                for (var i = 0; i < args.Length && i < 4; i++)
                {
                    if (i == 0) asm.AddRange(new Byte[] { 0x48, 0xB9 }); // mov rcx
                    if (i == 1) asm.AddRange(new Byte[] { 0x48, 0xBA }); // mov rdx
                    if (i == 2) asm.AddRange(new Byte[] { 0x49, 0xB8 }); // mov r8
                    if (i == 3) asm.AddRange(new Byte[] { 0x49, 0xB9 }); // mov r9
                    asm.AddRange(BitConverter.GetBytes((UInt64)args[i]));
                }
                for (var i = 4; i < args.Length; i++) // broke need to fix
                {
                    /*asm.Add(0x68);
                    asm.AddRange(BitConverter.GetBytes((UInt32)(UInt64)args[i]));
                    asm.Add(0x68);
                    asm.AddRange(BitConverter.GetBytes(((UInt64)args[i]) >> 32));*/
                }
                asm.AddRange(new Byte[] { 0x48, 0xB8 }); // mov rax
                asm.AddRange(BitConverter.GetBytes((UInt64)funcAddr));

                asm.AddRange(new Byte[] { 0xFF, 0xD0 }); // call rax
                asm.AddRange(new Byte[] { 0x48, 0x83, 0xC4, 0x38 }); // add rsp 0x38

                asm.AddRange(new Byte[] { 0x48, 0xA3 }); // mov rax to retval
                asm.AddRange(BitConverter.GetBytes((UInt64)retVal));
            }
            asm.AddRange(Enumerable.Range(0, 0x20).Select(a => (byte)0x90));
            asm.Add(0xC3); // ret
            var codePtr = VirtualAllocEx(procHandle, IntPtr.Zero, asm.Count, 0x3000, 0x40);
            WriteProcessMemory(procHandle, codePtr, asm.ToArray(), asm.Count, out _);
            var qq = BitConverter.ToString(asm.ToArray()).Replace("-", " ");
            var thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, codePtr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(thread, 10000);
            var buf = new Byte[target32Bit ? 4u : 8u];
            ReadProcessMemory(procHandle, retVal, buf, buf.Length, out _);
            VirtualFreeEx(procHandle, retVal, 0, 0x8000);
            VirtualFreeEx(procHandle, codePtr, 0, 0x8000);
            CloseHandle(thread);
            return (IntPtr)(target32Bit ? BitConverter.ToInt32(buf, 0) : BitConverter.ToInt64(buf, 0));
        }
        public static IntPtr ReadIntPtr(IntPtr addr)
        {
            var buf = new Byte[8];
            ReadProcessMemory(procHandle, addr, buf, buf.Length, out _);
            return (IntPtr)(target32Bit ? BitConverter.ToInt32(buf, 0) : BitConverter.ToInt64(buf, 0));
        }
        public static Int32 ReadInt32(IntPtr addr)
        {
            var temp = new Byte[4];
            ReadProcessMemory(procHandle, addr, temp, temp.Length, out _);
            return BitConverter.ToInt32(temp, 0);
        }
        public static IntPtr LoadLibraryA = IntPtr.Zero;
        public static void RemoteLoadLibrary(String dllName)
        {
            if (LoadLibraryA == IntPtr.Zero) LoadLibraryA = GetProcAddress("kernel32.dll", "LoadLibraryA");
            var allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, ((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), 0x3000, 4);
            WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), ((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out _);
            var thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, LoadLibraryA, allocMemAddress, 0, IntPtr.Zero); WaitForSingleObject(thread, 10000);
            VirtualFreeEx(procHandle, allocMemAddress, 0, 0x8000);
        }
        public static IntPtr GetBaseAddress()
        {
            var ptrs = new IntPtr[1];
            EnumProcessModulesEx(procHandle, ptrs, target32Bit ? 4u : 8u, out _, 3);
            return ptrs[0];
        }
        public static IntPtr GetProcAddress(String dll, String procName)
        {
            var ptrs = new IntPtr[0];
            EnumProcessModulesEx(procHandle, ptrs, 0, out UInt32 bytesNeeded, 3);
            var size = target32Bit ? 4 : 8;
            var moduleCount = bytesNeeded / size;
            ptrs = new IntPtr[moduleCount];
            EnumProcessModulesEx(procHandle, ptrs, bytesNeeded, out _, 3);
            for (var i = 0; i < moduleCount; i++)
            {
                var path = new StringBuilder(260);
                GetModuleFileNameEx(procHandle, ptrs[i], path, 260);

                if (path.ToString().ToLower().Contains(dll.ToLower()))
                {
                    GetModuleInformation(procHandle, ptrs[i], out MODULEINFO info, (uint)(size * ptrs.Length));
                    var e_lfanew = ReadInt32(info.lpBaseOfDll + 0x3C);
                    var ntHeaders = info.lpBaseOfDll + e_lfanew;
                    var optionalHeader = ntHeaders + 0x18;
                    var dataDirectory = optionalHeader + (target32Bit ? 0x60 : 0x70);
                    var exportDirectory = info.lpBaseOfDll + ReadInt32(dataDirectory);
                    var names = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x20);
                    var ordinals = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x24);
                    var functions = info.lpBaseOfDll + ReadInt32(exportDirectory + 0x1C);
                    var numFuncs = ReadInt32(exportDirectory + 0x18);

                    for (var j = 0; j < numFuncs; j++)
                    {
                        var offset = ReadInt32(names + j * 4);
                        var buffer = new Byte[32];
                        ReadProcessMemory(procHandle, info.lpBaseOfDll + offset, buffer, 32, out _);
                        var name = Encoding.UTF8.GetString(buffer);
                        if (name.Contains("\0")) name = name.Substring(0, name.IndexOf("\0"));
                        var ordinal = ReadInt32(ordinals + j * 2) & 0xFFFF;
                        var address = info.lpBaseOfDll + ReadInt32(functions + ordinal * 4);
                        if (name == procName) return address;
                    }
                }
            }
            return IntPtr.Zero;
        }
    }
}
```

`GunfireRebornMods/Program.cs`:

```cs
using System.Text;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using UnhollowerBaseLib;
using UnhollowerRuntimeLib;
using UnityEngine;
using Microsoft.Win32.SafeHandles;
using Mono.Cecil;

namespace GunfireRebornMods
{
    static class Program
    {
        static unsafe void Main()
        {
            if (Process.GetCurrentProcess().ProcessName == typeof(Program).Namespace)
            {
                var dll = AssemblyDefinition.ReadAssembly(Assembly.GetEntryAssembly().Location);
                var rand = Guid.NewGuid().ToString().Replace("-", "");
                dll.Name.Name += rand;
                dll.MainModule.Name += rand;
                dll.MainModule.Types.ToList().ForEach(t => t.Namespace += rand);
                var dllBytes = new Byte[0];
                using (var newDll = new MemoryStream())
                {
                    dll.Write(newDll);
                    dllBytes = newDll.ToArray();
                }
                NativeNetSharp.Inject("Gunfire Reborn", dllBytes);
            }
            else
            {
                try
                {
                    NativeNetSharp.AllocConsole();
                    var standardOutput = new StreamWriter(new FileStream(new SafeFileHandle(NativeNetSharp.GetStdHandle(-11), true), FileAccess.Write), Encoding.GetEncoding(437)) { AutoFlush = true };
                    Console.SetOut(standardOutput);
                    LogSupport_TraceHandler("C# DLL loaded");
                    Setup();
                }
                catch (Exception e)
                {
                    LogSupport_TraceHandler(e.Message.ToString());
                }
            }
        }

        public static GameObject BaseObject;
        public static void Setup()
        {
            IL2CPP.il2cpp_thread_attach(IL2CPP.il2cpp_domain_get());
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            Console.WriteLine(Environment.Version);
            Console.WriteLine(Application.unityVersion);
            Console.WriteLine(Directory.GetCurrentDirectory());
            UnhollowerBaseLib.Runtime.UnityVersionHandler.Initialize(2018, 4, 20);
            LogSupport.RemoveAllHandlers();
            LogSupport.TraceHandler += LogSupport_TraceHandler;
            LogSupport.ErrorHandler += LogSupport_TraceHandler;
            LogSupport.InfoHandler += LogSupport_TraceHandler;
            LogSupport.WarningHandler += LogSupport_TraceHandler;

            ClassInjector.Detour = new DoHookDetour();
            //ClassInjector.DoHook?.GetInvocationList().ToList().ForEach(d => ClassInjector.DoHook -= (Action<IntPtr, IntPtr>)d);
            //ClassInjector.DoHook += JmpPatch;
            ClassInjector.RegisterTypeInIl2Cpp<ModManager>();
            while (BaseObject = GameObject.Find("ModManager")) GameObject.DestroyImmediate(BaseObject);
            BaseObject = new GameObject("ModManager");
            GameObject.DontDestroyOnLoad(BaseObject);
            var modMgr = BaseObject.AddComponent<ModManager>();
            var types = Assembly.GetExecutingAssembly().GetTypes().ToList().Where(t => t.BaseType == typeof(ModBase) && !t.IsNested);
            foreach (var type in types) modMgr.Mods.Add((ModBase)Activator.CreateInstance(type));
        }

        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            LogSupport.Info(e.ToString());
        }
        unsafe class DoHookDetour : IManagedDetour
        {
           private static readonly List<object> PinnedDelegates = new List<object>();
           public T Detour<T>(IntPtr @from, T to) where T : Delegate
           {
               IntPtr* targetVarPointer = &from;
               PinnedDelegates.Add(to);
               JmpPatch((IntPtr)targetVarPointer, Marshal.GetFunctionPointerForDelegate(to));
               return Marshal.GetDelegateForFunctionPointer<T>(from);
           }
        }

        private static void LogSupport_TraceHandler(string obj)
        {
            File.AppendAllText(@"log.txt", obj + "\n");
            Console.WriteLine(obj);
        }
        [DllImport("kernel32")] static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);
        [DllImport("kernel32")] static extern bool FlushInstructionCache(IntPtr hProcess, IntPtr lpBaseAddress, UIntPtr dwSize);
        [DllImport("kernel32")] static extern IntPtr GetCurrentProcess();
        [DllImport("kernel32")] static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 flAllocationType, Int32 flProtect);
        [DllImport("kernel32")] static extern IntPtr GetModuleHandle(string lpModuleName);
        public static void JmpPatch(IntPtr originalPtr, IntPtr replacement)
        {
            var origCodeLoc = Marshal.ReadIntPtr(originalPtr);
            var jmpToNew = new List<Byte>();
            jmpToNew.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
            jmpToNew.AddRange(BitConverter.GetBytes(replacement.ToInt64()));
            jmpToNew.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            var origCode = new byte[0x12];
            Marshal.Copy(origCodeLoc, origCode, 0, origCode.Length);
            var jmpToOrig = new List<Byte>();
            jmpToOrig.AddRange(origCode);
            jmpToOrig.AddRange(new Byte[] { 0x49, 0xBB }); // mov r11, replacement
            jmpToOrig.AddRange(BitConverter.GetBytes((origCodeLoc + origCode.Length).ToInt64()));
            jmpToOrig.AddRange(new Byte[] { 0x41, 0xFF, 0xE3 }); // jmp r11
            var newFuncLocation = VirtualAllocEx(GetCurrentProcess(), IntPtr.Zero, 0x100, 0x3000, 0x40); // Marshal.Alloc doesn't work here?
            Marshal.Copy(jmpToOrig.ToArray(), 0, newFuncLocation, jmpToOrig.ToArray().Length);

            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, (UInt32)0x40, out UInt32 old);
            Marshal.Copy(jmpToNew.ToArray(), 0, origCodeLoc, jmpToNew.ToArray().Length);
            FlushInstructionCache(GetCurrentProcess(), origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length);
            VirtualProtect(origCodeLoc, (UIntPtr)jmpToNew.ToArray().Length, old, out UInt32 _);

            Marshal.WriteIntPtr(originalPtr, newFuncLocation);
        }
        public static void JmpUnPatch(IntPtr originalPtr, IntPtr replacement)
        {
            // todo
        }
        unsafe public static void Hook(IntPtr original, IntPtr target)
        {
            IntPtr originalPtr = original;
            IntPtr* targetVarPointer = &originalPtr;
            JmpPatch((IntPtr)targetVarPointer, target);
        }
    }
}

```

`GunfireRebornMods/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GunfireRebornMods")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("GunfireRebornMods")]
[assembly: AssemblyCopyright("Copyright ©  2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("786e2464-e23c-4392-a81a-870456d7fd63")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`GunfireRebornMods/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Costura.Fody" version="5.3.0" targetFramework="net472" developmentDependency="true" />
  <package id="Fody" version="6.5.1" targetFramework="net472" developmentDependency="true" />
  <package id="Microsoft.NETCore.Platforms" version="1.1.0" targetFramework="net472" />
  <package id="Microsoft.Win32.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="Mono.Cecil" version="0.11.4" targetFramework="net472" />
  <package id="NETStandard.Library" version="1.6.1" targetFramework="net472" />
  <package id="System.AppContext" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections" version="4.3.0" targetFramework="net472" />
  <package id="System.Collections.Concurrent" version="4.3.0" targetFramework="net472" />
  <package id="System.Console" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.DiagnosticSource" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tools" version="4.3.0" targetFramework="net472" />
  <package id="System.Diagnostics.Tracing" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net472" />
  <package id="System.Globalization.Calendars" version="4.3.0" targetFramework="net472" />
  <package id="System.IO" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.Compression.ZipFile" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem" version="4.3.0" targetFramework="net472" />
  <package id="System.IO.FileSystem.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq" version="4.3.0" targetFramework="net472" />
  <package id="System.Linq.Expressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Http" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Net.Sockets" version="4.3.0" targetFramework="net472" />
  <package id="System.ObjectModel" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Reflection.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Handles" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net472" />
  <package id="System.Runtime.Numerics" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net472" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.Encoding.Extensions" version="4.3.0" targetFramework="net472" />
  <package id="System.Text.RegularExpressions" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Tasks" version="4.3.0" targetFramework="net472" />
  <package id="System.Threading.Timer" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.ReaderWriter" version="4.3.0" targetFramework="net472" />
  <package id="System.Xml.XDocument" version="4.3.0" targetFramework="net472" />
</packages>
```

`LICENSE`:

```
MIT License

Copyright (c) 2020 shalzuth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# AutoGunfireReborn
A tool that adds easy mode to Gunfire Reborn.

This project shows how to inject Unity modules during runtime into il2cpp Unity games.

## Features
 - AutoAim - adds the auto-aim functionality from controller usage when playing with keyboard & mouse
 - ExtraSensoryPerception - shows where portals, chests, vendors, and enemies are located (through walls)
 - FreeCam - not functional yet. Goal is to add a free camera to wander the world.
 - GameSpeed - speeds up the game
 - JumpHeight - changes the jump height of your character, making all puzzles trivial.
 - MovementSpeed - lets you run as fast as the Flash.
 - UnlimitedAmmo - no need to reload or find ammo anymore.
 - UnlockAll - not functional yet. Goal is to unlock all weapons/scrolls/etc., but this is server-sided for the most part.
 - WeaponMod - not functional. Currently only adds map-wide AOE range to explosive weapons.
 
## Todo / current issues
 - Occasionally crashes on injection
 - Deployment / packaging requries lots of DLL's, would be nice to have a single exe. Fody doesn't work as is.
 - Dumper needs to be manually run on game update
 - Most of the logic of Gunfire Reborn is done outside of Unity in a native dll / python.
 - App that does the injection is just a simple winform - need to clean this up.

## Credits
https://github.com/Perfare/Il2CppDumper - dumps out dummy DLLs from Unity il2cpp game

https://github.com/knah/Il2CppAssemblyUnhollower - converts dummy DLLs from Il2CppDumper into native calls. knah also helped me debug along the way

https://github.com/warbler/SharpMonoInjector - calls mono functions after mono is loaded


https://github.com/HerpDerpinstine/MelonLoader - not used in this project directly, but I leveraged the workflow to inject mono into the target app
```