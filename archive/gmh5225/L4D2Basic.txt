Project Path: arc_gmh5225_L4D2Basic_0ik6zdtg

Source Tree:

```txt
arc_gmh5225_L4D2Basic_0ik6zdtg
├── Extra.h
├── Includes.h
├── L4D2Basic.sln
├── L4D2Basic.vcxproj
├── L4D2Basic.vcxproj.filters
├── Methods.h
├── MyTemplate.vstemplate
├── Player.h
├── UTILITIES
│   ├── HookTemplate.h
│   ├── MemEditAdvnc.h
│   ├── SigFunctor.h
│   └── Vector.h
├── __TemplateIcon.jpg
├── bspflags.h
├── dllMain.cpp
├── drawLogic.cpp
├── drawLogic.h
└── dxStuff.h

```

`Extra.h`:

```h
#ifndef EXTRA_H
#define EXTRA_H

namespace extra 
{

	struct Choices
	{
		bool showMenu{ false };
		//xbool showTeamMates{ false };
		bool snapLines{ false };
		bool box2D{ false };
		//xbool status2D{ false };
		bool statusText{ false };
		bool statusTextTeam{ false };
		bool box3D{ false };
		bool headLineEsp{ false };
		bool rcsCrossHair{ false };
		bool statusTextEntity{ false };
		bool velocityEsp{ false };
	};
	//!inline variable with multiple file includes to be included anywhere
	inline Choices g_choices{}; 

	//One button for each of above menu items to enable disable
	//! we are initializing each memu-button identifier with  particular key_state so it can be used elsewher in code
	struct Buttons
	{
		DWORD showMenuBtn{ VK_INSERT };
		//xbool showTeamMates{ false };
		DWORD snapLinesBtn{ VK_F1 };
		DWORD box2DBtn{ VK_F2 };
		//xbool status2D{ false };
		DWORD statusTextBtn{VK_F3 };
		DWORD statusTextTeamBtn{ VK_F4 };
		DWORD box3DBtn{ VK_F5};
		DWORD headLineEspBtn{VK_F6 };
		DWORD rcsCrossHairBtn{ VK_F7 };
		DWORD statusTextEntityBtn{ VK_F8 };
		DWORD velocityEspBtn{ VK_F9};
	};
	//Another inline variable to be copied 
	inline Buttons g_Buttons{};
}



#endif // !CHOICES_H


```

`Includes.h`:

```h
#pragma once
#include<iostream>
#include<Windows.h>
#include<d3d9.h>
#include<d3dx9.h>
#include <cstdint>
#include<Psapi.h>
#include <iostream>
#include <string>
#include"utilities/HookTemplate.h"
#include"utilities/SigFunctor.h"
#include"utilities/MemEditAdvnc.h"
#include"utilities/Vector.h"
//x#include"Player.h"
//x#include"Methods.h"
//x#include"dxStuff.h"
//x#include"drawLogic.h"
#pragma comment(lib,"d3d9.lib")
#pragma comment(lib,"d3dx9.lib")
#include<directxmath.h>
#include<D3dx9math.h>
```

`L4D2Basic.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "L4D2Basic", "L4D2Basic.vcxproj", "{53C3323C-7E2F-4907-9AF4-B9609A69C540}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Debug|x64.ActiveCfg = Debug|x64
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Debug|x64.Build.0 = Debug|x64
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Debug|x86.ActiveCfg = Debug|Win32
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Debug|x86.Build.0 = Debug|Win32
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Release|x64.ActiveCfg = Release|x64
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Release|x64.Build.0 = Release|x64
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Release|x86.ActiveCfg = Release|Win32
		{53C3323C-7E2F-4907-9AF4-B9609A69C540}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CEA0FA9F-2BC0-424F-9292-3D30ACBA3A38}
	EndGlobalSection
EndGlobal

```

`L4D2Basic.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{53C3323C-7E2F-4907-9AF4-B9609A69C540}</ProjectGuid>
    <RootNamespace>$safeprojectname$</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);$(DXSDK_DIR)Lib\x86</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86)$(DXSDK_DIR)Lib\x86</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AssemblyDebug>true</AssemblyDebug>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AssemblyDebug>true</AssemblyDebug>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Extra.h" />
    <ClInclude Include="drawLogic.h" />
    <ClInclude Include="dxStuff.h" />
    <ClInclude Include="Methods.h" />
    <ClInclude Include="Player.h" />
    <ClInclude Include="utilities\HookTemplate.h" />
    <ClInclude Include="Includes.h" />
    <ClInclude Include="utilities\MemEditAdvnc.h" />
    <ClInclude Include="UTILITIES\SigFunctor.h" />
    <ClInclude Include="utilities\Vector.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllMain.cpp" />
    <ClCompile Include="drawLogic.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`L4D2Basic.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="utilities">
      <UniqueIdentifier>{4bb447da-357e-45cc-8910-3c8f296c0f7c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utilities\HookTemplate.h">
      <Filter>utilities</Filter>
    </ClInclude>
    <ClInclude Include="utilities\MemEditAdvnc.h">
      <Filter>utilities</Filter>
    </ClInclude>
    <ClInclude Include="utilities\Vector.h">
      <Filter>utilities</Filter>
    </ClInclude>
    <ClInclude Include="Player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Methods.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="drawLogic.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UTILITIES\SigFunctor.h">
      <Filter>utilities</Filter>
    </ClInclude>
    <ClInclude Include="dxStuff.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Extra.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="drawLogic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Methods.h`:

```h
#ifndef METHODS_H
#define METHODS_H
#include "directxmath.h"
#include<array>
#include "Includes.h"
#include"Player.h"
//#include"bspflags.h"

/*==========================================================================================================================================================*/
struct cplane_t
{
	Vector3 normal;
	float dist;
	uint8_t type;   // for fast side tests
	uint8_t signbits;  // signx + (signy<<1) + (signz<<1)
	uint8_t pad[2];
};

struct surface_t
{
	char* name; //0x0000
	int16_t surface_prop; //0x0004
	uint16_t flags; //0x0006
};
struct Ray_t
{
	VectorAligned  m_Start;  // starting point, centered within the extents
	VectorAligned  m_Delta;  // direction + length of the ray
	VectorAligned  m_StartOffset; // Add this to m_Start to Get the actual ray start
	VectorAligned  m_Extents;     // Describes an axis aligned box extruded along a ray
	const void* m_pWorldAxisTransform;
	bool m_IsRay;  // are the extents zero?
	bool m_IsSwept;     // is delta != 0?

	Ray_t() : m_pWorldAxisTransform( NULL )
	{
	}

	void Init( Vector3 const& start, Vector3 const& end )
	{
		m_Delta = end - start;

		m_IsSwept = (m_Delta.LengthSqr() != 0);

		m_Extents.Init();

		m_pWorldAxisTransform = NULL;
		m_IsRay = true;

		// Offset m_Start to be in the center of the box...
		m_StartOffset.Init();
		m_Start = start;
	}

	void Init( Vector3 const& start, Vector3 const& end, Vector3 const& mins, Vector3 const& maxs )
	{
		m_Delta = end - start;

		m_pWorldAxisTransform = NULL;
		m_IsSwept = (m_Delta.LengthSqr() != 0);

		m_Extents = maxs - mins;
		m_Extents *= 0.5f;
		m_IsRay = (m_Extents.LengthSqr() < 1e-6);

		// Offset m_Start to be in the center of the box...
		m_StartOffset = maxs + mins;
		m_StartOffset *= 0.5f;
		m_Start = start + m_StartOffset;
		m_StartOffset *= -1.0f;
	}

	Vector3 InvDelta() const
	{
		Vector3 vecInvDelta;
		for (int iAxis = 0; iAxis < 3; ++iAxis)
		{
			if (m_Delta[iAxis] != 0.0f)
			{
				vecInvDelta[iAxis] = 1.0f / m_Delta[iAxis];
			}
			else
			{
				vecInvDelta[iAxis] = FLT_MAX;
			}
		}
		return vecInvDelta;
	}
};
enum  TraceType
{
	TRACE_EVERYTHING = 0,
	TRACE_WORLD_ONLY,
	TRACE_ENTITIES_ONLY,
	TRACE_EVERYTHING_FILTER_PROPS,
};

class ITraceFilter
{
public:
	virtual bool ShouldHitEntity( void* pEntity, int contentsMask ) = 0;
	virtual TraceType GetTraceType() const = 0;
};


// This is the one most normal traces will inherit from
class CTraceFilter : public ITraceFilter
{
public:
	bool ShouldHitEntity( void* pEntityHandle, int /*contentsMask*/ )
	{
		return !(pEntityHandle == pSkip);
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}
	void* pSkip;
};

#define	CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define	CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define CONTENTS_MOVEABLE		0x4000
#define	CONTENTS_MONSTER		0x2000000
#define	CONTENTS_MONSTERCLIP	0x20000
#define	CONTENTS_DEBRIS			0x4000000
#define CONTENTS_HITBOX			0x40000000

#define MASK_NPCWORLDSTATIC	    ( CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE )
#define STANDARD_TRACE_MASK     ( MASK_NPCWORLDSTATIC | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX )
#define   MASK_SHOT                     (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)

#define   DISPSURF_FLAG_SURFACE           (1<<0)
#define   DISPSURF_FLAG_WALKABLE          (1<<1)
#define   DISPSURF_FLAG_BUILDABLE         (1<<2)
#define   DISPSURF_FLAG_SURFPROP1         (1<<3)
#define   DISPSURF_FLAG_SURFPROP2         (1<<4)

class CBaseTrace
{
public:
	bool IsDispSurface( void )
	{
		return ((dispFlags & DISPSURF_FLAG_SURFACE) != 0);
	}
	bool IsDispSurfaceWalkable( void )
	{
		return ((dispFlags & DISPSURF_FLAG_WALKABLE) != 0);
	}
	bool IsDispSurfaceBuildable( void )
	{
		return ((dispFlags & DISPSURF_FLAG_BUILDABLE) != 0);
	}
	bool IsDispSurfaceProp1( void )
	{
		return ((dispFlags & DISPSURF_FLAG_SURFPROP1) != 0);
	}
	bool IsDispSurfaceProp2( void )
	{
		return ((dispFlags & DISPSURF_FLAG_SURFPROP2) != 0);
	}

public:

	// these members are aligned!!
	Vector3         startpos;            // start position
	Vector3         endpos;              // final position
	cplane_t       plane;               // surface normal at impact

	float          fraction;            // time completed, 1.0 = didn't hit anything

	int            contents;            // contents on other side of surface hit
	unsigned short dispFlags;           // displacement flags for marking surfaces with data

	bool           allsolid;            // if true, plane is not valid
	bool           startsolid;          // if true, the initial point was in a solid area

	CBaseTrace()
	{
	}

};

class CGameTrace : public CBaseTrace
{
public:
	bool DidHitWorld() const;
	bool DidHitNonWorldEntity() const;
	int GetEntityIndex() const;
	bool DidHit() const;
	bool IsVisible() const;

public:

	float               fractionleftsolid;  // time we left a solid, only valid if we started in solid
	surface_t          surface;            // surface hit (impact surface)
	int                 hitgroup;           // 0 == generic, non-zero is specific body part
	short               physicsbone;        // physics bone hit by trace in studio
	unsigned short      worldSurfaceIndex;  // Index of the msurface2_t, if applicable
	//IClientEntity* hit_entity;
	void* hit_entity;
	int                 hitbox;                       // box hit by trace in studio

	CGameTrace()
	{
	}

private:
	// No copy constructors allowed
	CGameTrace( const CGameTrace& other ) :
		fractionleftsolid( other.fractionleftsolid ),
		surface( other.surface ),
		hitgroup( other.hitgroup ),
		physicsbone( other.physicsbone ),
		worldSurfaceIndex( other.worldSurfaceIndex ),
		hit_entity( other.hit_entity ),
		hitbox( other.hitbox )
	{
		startpos = other.startpos;
		endpos = other.endpos;
		plane = other.plane;
		fraction = other.fraction;
		contents = other.contents;
		dispFlags = other.dispFlags;
		allsolid = other.allsolid;
		startsolid = other.startsolid;
	}

	CGameTrace& operator=( const CGameTrace& other )
	{
		startpos = other.startpos;
		endpos = other.endpos;
		plane = other.plane;
		fraction = other.fraction;
		contents = other.contents;
		dispFlags = other.dispFlags;
		allsolid = other.allsolid;
		startsolid = other.startsolid;
		fractionleftsolid = other.fractionleftsolid;
		surface = other.surface;
		hitgroup = other.hitgroup;
		physicsbone = other.physicsbone;
		worldSurfaceIndex = other.worldSurfaceIndex;
		hit_entity = other.hit_entity;
		hitbox = other.hitbox;
		return *this;
	}
};

inline bool CGameTrace::DidHit() const
{
	return fraction < 1 || allsolid || startsolid;
}

inline bool CGameTrace::IsVisible() const
{
	return fraction > 0.97f;
}


typedef CGameTrace trace_t;


class CEngineTraceClient
{
private:

	CEngineTraceClient() = default;

public:
	//using traceRayAlias = void( __fastcall* )(void* pECX, void* unused_pEDX, Ray_t& ray, unsigned int fMask, CTraceFilter* pTraceFilter, trace_t* pTrace);// earlier defined as thiscall and was causing 
	using traceRayAlias = void( __thiscall* )(void* pECX, Ray_t& ray, unsigned int fMask, CTraceFilter* pTraceFilter, trace_t* pTrace);
	static inline traceRayAlias traceRayPtr{};
	static inline ptrdiff_t lpOrigTraceRayAddress{ SigFunctor{}("engine.dll", "\x53\x8B\xDC\x83\xEC\x08\x83\xE4\xF0\x83\xC4\x04\x55\x8B\x6B\x04\x89\x6C\x24\x04\x8B\xEC\xB8\xF8\x11\x00\x00\xE8\xCC\xCC\xCC\xCC\xA1\xCC\xCC\xCC\xCC\x33\xC5\x89\x45\xFC\x8B\x43\x10", "xxxxxxxxxxxxxxxxxxxxxxxxxxxx????x????xxxxxxxx").GetAddress() };
	static CEngineTraceClient* instance()
	{
		static CEngineTraceClient ceTraceClient;
		static ptrdiff_t pceTraceClient_base = SigFunctor{}("client.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\x01\x8B\x00\x6A\x00\x6A", "xx????xxxxx?x").GetOffsetAddress32( 2 );
		static CEngineTraceClient* ceTraceClient_base{ g_memEdit.get_THIS_frm_ptr2ObjBaseAdrs< CEngineTraceClient>( pceTraceClient_base ) };
		traceRayPtr = (traceRayAlias) lpOrigTraceRayAddress;
		return ceTraceClient_base;
	}

	void traceRayHook()
	{
		//EntityListInstance* entityListAddress = EntityListInstance::getEntityListInstancePtr();
		//LocalPlayer* localPLayerBaseAddress = LocalPlayer::getLocalPlayerPtr();

		Vector3 entityPoshead3D{};
		Vector3 localPlayerEyePos{ LocalPlayer::getLocalPlayerPtr()->vecOrigin + LocalPlayer::getLocalPlayerPtr()->m_vecViewOffset };

		Ray_t ray{};
		unsigned int fMask{};
		CTraceFilter TraceFilter{};
		trace_t Trace{};
		CEngineTraceClient* pECX = instance();
		for (int id{ 0 }; id < 900; ++id)
		{
			LocalPlayer* entity = EntityListInstance::getEntityListInstancePtr()->GetOtherEntity( id );

			if ((!entity) || (id==0)||(id==1) || (entity->iTeamNum != 3) || (entity->isDormant))
				continue;

			entityPoshead3D = LocalPlayer::getLocalPlayerPtr()->GetBonePosition( entity, 14 );
			if (entityPoshead3D.m_x != 0.0 && entityPoshead3D.m_y != 0.0f && entityPoshead3D.m_z != 0.0f)
			{
				TraceFilter.pSkip = (void*) LocalPlayer::getLocalPlayerPtr();
				ray.Init( localPlayerEyePos, entityPoshead3D );
				traceRayPtr( pECX,  ray, MASK_SHOT | CONTENTS_GRATE, &TraceFilter, &Trace );
				//?traceRayPtr( pECX, NULL, ray, MASK_NPCWORLDSTATIC | CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_HITBOX, &TraceFilter, &Trace );
				if (entity == Trace.hit_entity)
				{
					//xstd::cout << "Entity position: 0x" << std::hex << (ptrdiff_t) entity << '\n';
					LocalPlayer::getLocalPlayerPtr()->aimAt( LocalPlayer::getLocalPlayerPtr()->GetBonePosition(entity,14 ));
					
				}

			}

		}
	
	}


};

#endif
```

`MyTemplate.vstemplate`:

```vstemplate
<VSTemplate Version="3.0.0" xmlns="http://schemas.microsoft.com/developer/vstemplate/2005" Type="Project">
  <TemplateData>
    <Name>L4D2BasicSDK</Name>
    <Description>&lt;No description available&gt;</Description>
    <ProjectType>VC</ProjectType>
    <ProjectSubType>
    </ProjectSubType>
    <SortOrder>1000</SortOrder>
    <CreateNewFolder>true</CreateNewFolder>
    <DefaultName>L4D2BasicSDK</DefaultName>
    <ProvideDefaultName>true</ProvideDefaultName>
    <LocationField>Enabled</LocationField>
    <EnableLocationBrowseButton>true</EnableLocationBrowseButton>
    <Icon>__TemplateIcon.jpg</Icon>
  </TemplateData>
  <TemplateContent>
    <Project TargetFileName="L4D2Basic.vcxproj" File="L4D2Basic.vcxproj" ReplaceParameters="true">
      <ProjectItem ReplaceParameters="false" TargetFileName="$projectname$.vcxproj.filters">L4D2Basic.vcxproj.filters</ProjectItem>
      <ProjectItem ReplaceParameters="false" TargetFileName="dllMain.cpp">dllMain.cpp</ProjectItem>
      <ProjectItem ReplaceParameters="false" TargetFileName="Includes.h">Includes.h</ProjectItem>
      <ProjectItem ReplaceParameters="false" TargetFileName="Player.h">Player.h</ProjectItem>
      <Folder Name="utilities" TargetFolderName="utilities">
        <ProjectItem ReplaceParameters="false" TargetFileName="HookTemplate.h">UTILITIES\HookTemplate.h</ProjectItem>
        <ProjectItem ReplaceParameters="false" TargetFileName="MemEditAdvnc.h">UTILITIES\MemEditAdvnc.h</ProjectItem>
        <ProjectItem ReplaceParameters="false" TargetFileName="SigScan_RIP.h">UTILITIES\SigScan_RIP.h</ProjectItem>
        <ProjectItem ReplaceParameters="false" TargetFileName="Vector.h">UTILITIES\Vector.h</ProjectItem>
      </Folder>
    </Project>
  </TemplateContent>
</VSTemplate>
```

`Player.h`:

```h

#pragma once
#include<vector>
#include"Includes.h"
#include"Extra.h"

#pragma region Address
#define clientBase  (ptrdiff_t)GetModuleHandleA("client.dll")
#define engineBase  (ptrdiff_t)GetModuleHandleA("engine.dll")

#define pCClinetState_ViewAngles  (ptrdiff_t)0x4aa4 // at this offset of clientstate class get writable view angles
#define pCCSInput   (ptrdiff_t)0x6c5d7c
#pragma endregion

#define angleRad(x)  ((x)*M_PI/180)
#define W2S(x,y)  LocalPlayer::getLocalPlayerPtr()->worldToScreen(x,y)

// extern declaration for global variable g_windowSize 
//from  "dxstuff.h" to be used in "Player.h"
extern Vector2 g_windowSize;

//!New global variable made for viewProjMatrix[16] as inside player class it was overriding other offsets
//!This was causing weird bug og boomer sticker appearing
extern float g_viewProjMatrix[16];

class CRender
{
public:
	static CRender* getCRenderBaseAddress()
	{
		static ptrdiff_t pCrenderBaseAddress{ SigFunctor{}("engine.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\x01\x8B\x50\x00\xFF\xE2\xCC\xCC\xCC\x8B\x0D\x00\x00\x00\x00\x8B\x01\x8B\x50\x00\xFF\xE2\xCC\xCC\xCC\x55\x8B\xEC\x8B\x45\x00\x50", "xx????xxxx?xxxxxxx????xxxx?xxxxxxxxxx?x").GetOffsetAddress32( 2 ) };
		//Base afddress of object is pointer to object in code or a THIS POINTER
		static CRender* cRenderPtr{ g_memEdit.get_THIS_frm_ptr2ObjBaseAdrs<CRender>( pCrenderBaseAddress ) };

		return cRenderPtr;

	}

	char pad_0000[156]; //0x0000
	Matrix4x4 wvpMatrix; //0x009C
	char pad_00DC[4]; //0x00DC


}; //Size: 0x00E0

class BoneArray2
{
public:
	Matrix3x4 boneMatrixStruct; //0x0000
}; //Size: 0x0030


class N00002FF8
{
public:
	class BoneArray2 bonaArray2[85]; //0x0000
	char pad_0FF0[64]; //0x0FF0
}; //Size: 0x1030

class BoneArray1
{
public:
	float boneMatrixArray[12]; //0x0000
}; //Size: 0x0030
static_assert(sizeof( BoneArray1 ) == 0x30);

class N000030A1
{
public:
	class BoneArray1 boneArray1[85]; //0x0000
	char pad_0FF0[64]; //0x0FF0
}; //Size: 0x1030
static_assert(sizeof( N000030A1 ) == 0x1030);



class CCSInput
{
public:
	char pad_0000[177]; //0x0000
	bool m_fCameraInThirdPerson; //0x00B1
	char pad_00B2[2]; //0x00B2
	Vector3 SetCameraOffsetAngles; //0x00B4
	char pad_00C0[60]; //0x00C0
}; //Size: 0x00FC

//static_assert(sizeof( CCSInput ) == 0x150);

class LocalPlayer
{
public:
	LocalPlayer() = default;
	char pad_0000[16]; //0x0000
	char* str_infection_state; //0x0010
	char pad_0014[68]; //0x0014
	int32_t entity_id_index; //0x0058
	char pad_005C[129]; //0x005C
	bool isDormant; //0x00DD
	char pad_00DE[6]; //0x00DE
	int32_t iTeamNum; //0x00E4
	char pad_00E8[4]; //0x00E8
	int32_t health; //0x00EC
	char pad_00F0[4]; //0x00F0
	Vector3 m_vecViewOffset; //0x00F4
	Vector3 mVecVelocity; //0x100
	char pad_010C[24]; //0x0100
	Vector3 vecOrigin; //0x0124
	char pad_0130[1424]; //0x0130
	class N000030A1* boneMatrixPtr1; //0x06C0
	char pad_06C4[580]; //0x06C4
	class N00002FF8* boneMatrixPtr2; //0x0908
	char pad_090C[2680]; //0x090C
	Vector3 viewAngles; //0x1384
	char pad_1390[2300]; //0x1390
	int survivor_name_index;//0x1c8c
	int infected_name_index; //0x1c90

	//!if the viewProjMatrix[16] variable is placed directly after infected_name_index
	//! it causes wierd bug of boomer sticker
	//! some padding has to be introduced so that it does not overwrite some actual value in C_TerrorPlayer class while updating viewMatrix
	//todo Or this whole updateMatrixButtons() function alongwith variable can be shifted somewhere else
	//!Easiest way is to make a global variable and remove it from inside the class
	//xfloat viewProjMatrix[16]{};


	static LocalPlayer* getLocalPlayerPtr() // to get a this pointer of object or maybe call base-address of object
	{
		static ptrdiff_t pC_TerrorPlayer_base{ SigFunctor{}("client.dll","\xB8\xCC\xCC\xCC\xCC\x39\x10\x74\x10\x83\xC0\x04\x3D\xCC\xCC\xCC\xCC\x7C\xF2\x32\xC0\x5D\xC2\x04\x00","x????xxxxxxxx????xxxxxxxx").GetOffsetAddress32( 1 ) };
		static LocalPlayer* localPlayerptr{ g_memEdit.get_THIS_frm_ptr2ObjBaseAdrs<LocalPlayer>( pC_TerrorPlayer_base ) };
		return localPlayerptr;
	}

	Vector3* getViewAnglesPtr()
	{
		static ptrdiff_t pCClientState_minus_8{ SigFunctor{}("engine.dll","\x8B\x0D\xCC\xCC\xCC\xCC\x8B\x49\x18\x8B\x11\x50\x8B\x82\x24\x01\x00\x00\xFF\xD0\x8B\x4E\x18","xx????xxxxxxxxxxxxxxxxx").GetOffsetAddress32( 2 ) };
		static ptrdiff_t CClientState_minus_8{ g_memEdit.readPtr<ptrdiff_t>( pCClientState_minus_8,1337 ) };
		ptrdiff_t CClientState_base{ CClientState_minus_8 + 0x8 };
		ptrdiff_t viewAngleAddrs = { CClientState_base + pCClinetState_ViewAngles };
		static Vector3* viewAnglesPtr = g_memEdit.makePtr<Vector3>( viewAngleAddrs );
		return viewAnglesPtr;
	}

	void aimAt( const Vector3& target )
	{
		static Vector3* viewAngles = getViewAnglesPtr();
		Vector3 originPos = vecOrigin;
		Vector3 viewOffset = m_vecViewOffset;
		Vector3 myFinalVec = originPos + viewOffset; // vector of LocalPlayer eyePosition
		Vector3 deltaVector = target - myFinalVec; // difference Vector3 between LocalPlayer and other entity
		float deltaVectorLength = deltaVector.Length(); // Length of difference vector
		float pitch = (float) -asin( deltaVector.m_z / deltaVectorLength ) * (180 / M_PI);
		float yaw = (float) atan2( deltaVector.m_y, deltaVector.m_x ) * (180 / M_PI);

		if (pitch >= -89 && pitch <= 89 && yaw >= -180 && yaw <= 180) // clamping angles to maximumdefined angles in game
		{
			viewAngles->m_x = pitch; // set the view angles by dereference operator
			viewAngles->m_y = yaw;
			//*(float*) ((ptrdiff_t) viewAngles) = pitch;  same as above
			//*(float*) ((ptrdiff_t) viewAngles + 0x04) = yaw;
		}

	}


	Vector3 GetBonePosition( LocalPlayer* entity, int boneID )
	{
		Vector3 bonePos{};
		if (!entity || !(entity->boneMatrixPtr1))
			return { 0.0f,0.0f,0.0f };
		auto boneArrayAccess = entity->boneMatrixPtr1->boneArray1[boneID].boneMatrixArray;
		
		//x*auto boneAccessShared = std::make_shared<float[]>(12);
		//xRtlMoveMemory( &boneAccessShared, &boneArrayAccess, 48 );
		//xauto boneAccessWeak = std::weak_ptr{ boneAccessShared };
		//xauto boneCheckFail = boneAccessWeak.expired(); */
		//todo this has to be fixed up IsBadReadPtr() is deperecated


		BOOL boneCheckFail = IsBadReadPtr( boneArrayAccess, 48 ); // Function returns Zero if calling process has read access to memory block
		if (!boneCheckFail)
		{
			//auto boneArrayAccess = this->boneMatrixPtr1->boneArray1[boneID].boneMatrixArray; // This accesses boneMatrixstruct as per boneId
			bonePos.m_x = boneArrayAccess[3];
			bonePos.m_y = boneArrayAccess[7];
			bonePos.m_z = boneArrayAccess[11];
			return bonePos;
		}
		return { 0.0f,0.0f,0.0f };
	}

	void checkButtons()
	{
		//!Activation-Deactivation of menu items through key-binds to various button name

		if (GetAsyncKeyState( extra::g_Buttons.showMenuBtn ) & 1)
			extra::g_choices.showMenu = !extra::g_choices.showMenu; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.box2DBtn ) & 1)
			extra::g_choices.box2D = !extra::g_choices.box2D; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.box3DBtn ) & 1)
			extra::g_choices.box3D = !extra::g_choices.box3D; //!changes the ealier held setting on key press
		
		if (GetAsyncKeyState( extra::g_Buttons.headLineEspBtn ) & 1)
			extra::g_choices.headLineEsp = !extra::g_choices.headLineEsp; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.rcsCrossHairBtn ) & 1)
			extra::g_choices.rcsCrossHair = !extra::g_choices.rcsCrossHair; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.snapLinesBtn ) & 1)
			extra::g_choices.snapLines = !extra::g_choices.snapLines; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.statusTextBtn ) & 1)
			extra::g_choices.statusText = !extra::g_choices.statusText; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.statusTextEntityBtn ) & 1)
			extra::g_choices.statusTextEntity = !extra::g_choices.statusTextEntity; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.statusTextTeamBtn) & 1)
			extra::g_choices.statusTextTeam = !extra::g_choices.statusTextTeam; //!changes the ealier held setting on key press

		if (GetAsyncKeyState( extra::g_Buttons.velocityEspBtn ) & 1)
			extra::g_choices.velocityEsp = !extra::g_choices.velocityEsp; //!changes the ealier held setting on key press

	}

	void updateMatrixButtons()
	{
		memcpy( &g_viewProjMatrix, (BYTE*) &(CRender::getCRenderBaseAddress()->wvpMatrix.matrix4x4), sizeof( g_viewProjMatrix ) );
		checkButtons();
	}

	bool worldToScreen( Vector3 pos, Vector2& screen )
	{
		Vector4 clipCoords;
		clipCoords.m_x = pos.m_x * g_viewProjMatrix[0] + pos.m_y * g_viewProjMatrix[1] + pos.m_z * g_viewProjMatrix[2] + g_viewProjMatrix[3];
		clipCoords.m_y = pos.m_x * g_viewProjMatrix[4] + pos.m_y * g_viewProjMatrix[5] + pos.m_z * g_viewProjMatrix[6] + g_viewProjMatrix[7];
		clipCoords.m_z = pos.m_x * g_viewProjMatrix[8] + pos.m_y * g_viewProjMatrix[9] + pos.m_z * g_viewProjMatrix[10] + g_viewProjMatrix[11];
		clipCoords.m_w = pos.m_x * g_viewProjMatrix[12] + pos.m_y * g_viewProjMatrix[13] + pos.m_z * g_viewProjMatrix[14] + g_viewProjMatrix[15];
		if (clipCoords.m_w < 0.1f)
			return false;
		Vector3 NDC;  // for projection on screen 4th column homogeneous point is not [0,0,0,1]
		NDC.m_x = clipCoords.m_x / clipCoords.m_w;
		NDC.m_y = clipCoords.m_y / clipCoords.m_w;
		NDC.m_z = clipCoords.m_z / clipCoords.m_w;
		Vector2 windowSize{ g_windowSize };  // To get the window-size
		screen.m_x = ((windowSize.m_x / 2) * (NDC.m_x)) + (NDC.m_x) + windowSize.m_x / 2;
		screen.m_y = -((windowSize.m_y / 2) * (NDC.m_y)) + (NDC.m_y) + windowSize.m_y / 2;
		return true;
	}
	// function to transformvector at any given angle rotation
	Vector3 TransFormVector( Vector3 source, Vector3 angle, float dis )
	{
		Vector3 newPosition{};
		newPosition.m_x = source.m_x + (cosf( angleRad( angle.m_y ) ) * dis);
		newPosition.m_y = source.m_y + (sinf( angleRad( angle.m_y ) ) * dis);
		newPosition.m_z = source.m_z + (tanf( angleRad( angle.m_x ) ) * dis);
		return newPosition;
	}

	char* get_entity_name( LocalPlayer* entity )
	{
		using entityNameFuncAlias = char* (__thiscall*)(void* pECX);
		static entityNameFuncAlias entityNameFuncPtr = (entityNameFuncAlias) (SigFunctor{}("client.dll", "\x56\x8B\xF1\x8B\x06\x8B\x90\x00\x00\x00\x00\xFF\xD2\x50\xE8\x00\x00\x00\x00\x83\xC4\x00\x84\xC0\x74\x00\x8B\xB6", "xxxxxxx????xxxx????xx?xxx?xx").GetAddress());
		return entityNameFuncPtr( entity );

	}

};

class EntityListInstance :public LocalPlayer // inheritance used as all entities use structure similar to player
{
public:

	//std::vector < LocalPlayer*> array_EntityPtr{};


public:
	EntityListInstance() = default;

	static EntityListInstance* getEntityListInstancePtr()
	{
		static ptrdiff_t pCClientEntitylist_base = { SigFunctor{}("client.dll","\x8B\x15\x00\x00\x00\x00\x8B\xC8\x81\xE1\x00\x00\x00\x00\x03\xC9\x8D\x4C\x00\x00\x85\xC9\x74\x00\xC1\xE8\x00\x39\x41\x00\x75\x00\x8B\x01\xC3\x33\xC0\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x55\x8B\xEC\xF6\x45\x08","xx????xxxx????xxxx??xxx?xx?xx?x?xxxxxxxxxxxxxxxxxxxxxxxxxxx").GetOffsetAddress32( 2 ) };
		static EntityListInstance* entityListPtr{ g_memEdit.get_THIS_frm_ptr2ObjBaseAdrs<EntityListInstance>( pCClientEntitylist_base ) };
		return    entityListPtr;
	}

	LocalPlayer* GetOtherEntity( int index )
	{
		ptrdiff_t entityPtr = (ptrdiff_t) getEntityListInstancePtr() + 0x04 + index * 0x10;
		//ptrdiff_t otherEntityBaseAddress = g_memEdit.readPtr<ptrdiff_t>( entityPtr, 1337 );
		return { g_memEdit.get_THIS_frm_ptr2ObjBaseAdrs<LocalPlayer>( entityPtr ) };
	}

	bool checkValidEnt( LocalPlayer* entity )
	{

		if (!entity)  // to check if entity even exists or is valid
			return false;
		if (entity == getLocalPlayerPtr())
			return false;
		if (entity->iTeamNum != 3)
			return false;
		if (entity->isDormant)
			return false;
	}
	//todo this function has to be updated to include trace-ray check inside and to skip entity if not visible
	LocalPlayer* GetClosestEnemy() // Get closest enemy to player
	{
		float closestDistance = 1000000;

		int closestDistanceIndex = -1;

		LocalPlayer* localPlayer = getLocalPlayerPtr();

		for (int i{ 0 }; i < 900; ++i)
		{
			LocalPlayer* entity = GetOtherEntity( i );
			if ((!entity) || (entity == localPlayer) || (entity->iTeamNum != 3) || (entity->isDormant))
				continue;

			Vector3 LocalPlayerPos = (localPlayer->vecOrigin) + (localPlayer->m_vecViewOffset);


			Vector3 otherPlayerPos{ GetOtherEntity( i )->GetBonePosition( entity, 14 ) }; // Gets the position of other player head-position

			float distanceDiff = LocalPlayerPos.DistanceTo( otherPlayerPos );
			if (distanceDiff < closestDistance)
			{
				closestDistance = distanceDiff;
				closestDistanceIndex = i;
			}

		}
		if (closestDistanceIndex == -1)
		{
			return nullptr;
		}

		return { GetOtherEntity( closestDistanceIndex ) };
	}
	/*
		Vector3 targetEntityVec()
		{
			// Use 14 for head bone-id
			// Return a temporary Vector3 object
			LocalPlayer* targetEntity = GetClosestEnemy();

			if (!IsBadReadPtr( targetEntity->boneMatrixPtr1->boneArray1->boneMatrixArray, 48 ))
				return { targetEntity->GetBonePosition( 14 ) };
			else
				return { 0.0f,0.0f,0.0f };
		}  */

};
```

`UTILITIES/HookTemplate.h`:

```h
#ifndef HOOKTEMPLATE_H
#define HOOKTEMPLATE_H
#include<Windows.h>
#include<functional>
// patch bytes function
class HooknPatch
{
private:
	// This gatway variable stores the original bytes of function
	char* m_gateWay {nullptr};

public:
	HooknPatch() = default;
	~HooknPatch()
	{
		if (m_gateWay)
		VirtualFree( m_gateWay, 0, MEM_RELEASE );
		m_gateWay = nullptr;
		//delete[] m_gateWay;
	}

	//Specially declared (deleted) copy constructor tp prevent resource leak/mismanagement as per rule of three(3/5/0)
	//Prevents shallow copying of class resources without deep copying
	HooknPatch( const HooknPatch& other ) = delete;

	//Specially declared (deleted) copy constructor tp prevent resource leak/mismanagement as per rule of three(3/5/0)
	//Prevents shallow copying copy of class resources without deep copying
	HooknPatch& operator= ( const HooknPatch& other ) = delete;

	/*
	//Custom copy constructor with deep copy 
	HooknPatch( const HooknPatch& other )
	{
		m_gateWay = new char[sizeof(other.m_gateWay)]; // allocate a new resource of m_gateway ptr
		RtlMoveMemory( m_gateWay, other.m_gateWay, sizeof( other.m_gateWay ) ); // deep copy the resource from the original address
	}
	// custom assignement operator with deep copy
	HooknPatch& operator=( const HooknPatch& other )
	{
		// Self assignement check for avoiding self-assignement
		if (&other == this)
			return *this;
		//Release any previous resource we are holding
		delete m_gateWay;
		// copy the the original resource to a new alloacted memory by deep copying
		m_gateWay = new char[sizeof( other.m_gateWay )];
		RtlMoveMemory( m_gateWay, other.m_gateWay, sizeof( other.m_gateWay ) );

		return *this;

	}  */

	template<int LENGTH> // length is expresion parameter here
	void saveOrigBytes( char* lpOriginalFuncAddrs )
	{
		// Do not redefine m_gateWay here otherwise variable shadowing will occur 
		//Only assign so this way the variable m_gateWay can be reused to patch back original bytes later
		char* gateWay = (char*) VirtualAlloc( 0, LENGTH + 5, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );

		RtlMoveMemory( gateWay, lpOriginalFuncAddrs, LENGTH );
		// pointer of new allocated memory copied to m_gateway
		//So now m_gateWay which is member variable points to newly allocated memory
		
		m_gateWay = gateWay; // SHALLOW copy here only so m_gateway now pointe to (address) pointed of   by gateway
		gateWay = nullptr;
		//The new gatway variable created here dies/get destroyed when move out of local scope,
		// Resource deallocation is not done as m_gateway points to newly allocated/copied resource
	}

	//template non-type parameters used for template functions
	// mid-function Detour and Hook
	// usage: hP.midDetour<LENGTH>(lpOriginalFuncAddrs,lpFinalHookaddrs)
	template<int LENGTH>
	bool midDetour( char* lpOriginalFuncAddrs, char* lpFinalHookaddrs )
	{
		if (LENGTH < 5)
			return false;
		DWORD oProc;
		VirtualProtect( lpOriginalFuncAddrs, LENGTH, PAGE_EXECUTE_READWRITE, &oProc );
		RtlFillMemory( lpOriginalFuncAddrs, LENGTH, 0x90 );
		uintptr_t relAddy = (uintptr_t) (lpFinalHookaddrs - lpOriginalFuncAddrs - 5);
		*lpOriginalFuncAddrs = (char) 0xE9;
		*(uintptr_t*) (lpOriginalFuncAddrs + 1) = (uintptr_t) relAddy;
		VirtualProtect( lpOriginalFuncAddrs, LENGTH, oProc, &oProc );
		return true;
	}

	// trampoline hook function for saving register state
	// usage:hP.trampHook<LENGTH>(lpOriginalFuncAddrs,lpFinalHookaddrs)
	//(tEndScene)(hP.trampHook<7>((char*)d3d9Device[42], (char*)hkEndScene));

	template <int LENGTH>
	char* trampHook( char* lpOriginalFuncAddrs, char* lpFinalHookaddrs )
	{
		if (LENGTH < 5)
			return nullptr;
		saveOrigBytes<LENGTH>( lpOriginalFuncAddrs ); // Do not put this is in midDetour function otherwise order of execution will mess up

		uintptr_t jumpAddress = (uintptr_t) (lpOriginalFuncAddrs - m_gateWay - 5);
		*(m_gateWay + LENGTH) = (char) 0xE9;
		*(uintptr_t*) (m_gateWay + LENGTH + 1) = jumpAddress;
		if (midDetour<LENGTH>( lpOriginalFuncAddrs, lpFinalHookaddrs )) // midDeotour another templated member function called here
		{
			return m_gateWay;
		}
		else return nullptr;
	}

	//	Use of Patch or writememory Function: To patch Back original Bytes for Unhook
	// Create class HooknPatch hP ;
	//use hP.patchByte<LENGTH>((char*)lpOriginalFuncAddrs)
	//hP.patchByte<7>((BYTE*)d3d9Device[42], );

	template<int LENGTH>
	void patchByte( char* lpOriginalFuncAddrs )
	{
		DWORD oldProc {};
		VirtualProtect( lpOriginalFuncAddrs, LENGTH, PAGE_EXECUTE_READWRITE, &oldProc );
		RtlMoveMemory( lpOriginalFuncAddrs, m_gateWay, LENGTH );
		VirtualProtect( lpOriginalFuncAddrs, LENGTH, oldProc, &oldProc );
	}
	/*
	template<int LENGTH>
	void unhook( char* lpOriginalFuncAddress )
	{

		patchByte<LENGTH>( lpOriginalFuncAddress );

		if (m_gateWay)
			VirtualFree( m_gateWay, 0, MEM_RELEASE );
		m_gateWay = nullptr;
	}*/

	//!  Assign a Lambda Type for unhook Function to be used with std::thread Library
	//! Note tHat auto cannot be used for Lambda type inside Class scope
	//? So we are using std::function<return_type(arg1,arg2..argn)> for use a type of Lambda. Even c++23 std does not allow

	std::function<void(char*,int)> unHook = [&](char* lpOriginalFuncAddrs,int LENGTH)
	{
		//todo To understand why patchByte with fixed template parameter can't be used inside lambda
	    //xpatchByte<LENGTH>(lpOriginalFuncAddrs);
		DWORD oldProc{};
		VirtualProtect(lpOriginalFuncAddrs, LENGTH, PAGE_EXECUTE_READWRITE, &oldProc);
		RtlMoveMemory(lpOriginalFuncAddrs, m_gateWay, LENGTH);
		VirtualProtect(lpOriginalFuncAddrs, LENGTH, oldProc, &oldProc);
		if(m_gateWay)
			VirtualFree(m_gateWay, 0, MEM_RELEASE);
		m_gateWay = nullptr;

	};

};

inline HooknPatch g_HnP{}; // Inline global object instance to use with all files
#endif
```

`UTILITIES/MemEditAdvnc.h`:

```h
#ifndef MEMEDIT_H
#define MEMEDIT_H
#include"Windows.h"
#include<cstdint> 

// Little memory editing class 



class MemEdit
{
public:
	MemEdit() = default;

	//filter function should go inside class otherwise ODR rule is violated
	int filter( unsigned int code, LPEXCEPTION_POINTERS ep ) // correct parameter name for pointer to struct _EXCEPTION_POINTERS(EXCEPTION_POINTERS*)
	{
		//handle only Access Violation
		// If access violation it will execute the code in handler or else execute the Execption search
		return code == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;

	}

	template<typename T>
	//READ a value of type "T" from its pointer
	T readPtr( ptrdiff_t Address, const T& def_val = T() ) // Give a default value To check if readPtr fails e.g. like 5126
	{
		__try
		{
			return *(T*) (Address);
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			puts( "Wrong value derefrenced" );
			return def_val;
		}
	}

	template<typename T>
	bool  writePtr( ptrdiff_t Address, T Value )
	{
		__try
		{
			*(T*) (Address) = Value;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return false;
		}
		return true;
	}

	template<typename T>
	bool add( ptrdiff_t Address, T Value )
	{
		__try
		{
			*(T*) Address += Value;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return false;
		}
		return true;
	}

	template <typename T>
	bool sub( ptrdiff_t Address, T Value )
	{
		__try
		{
			*(T*) Address -= Value;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return false;
		}
		return true;
	}

	template <typename T>
	bool multiply( ptrdiff_t Address, T Value )
	{
		__try
		{
			*(T*) Address *= Value;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return false;
		}
		return true;
	}

	template <class T>
	bool divide( ptrdiff_t Address, T Value )
	{
		__try
		{
			*(T*) Address /= Value;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return false;
		}
		return true;
	}

	template <typename T>
	T* makePtr( ptrdiff_t addrs ) // getting  a cast to object of type T or make pointer of some address
	{
		__try
		{
			return (T*) addrs;
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return nullptr;
		}
	}

	//NOTE: FUNCTION OUTPUTS THIS POINTER OR BASE-ADDRESS OF OBJECT
	template <typename T>
	// T* is static/global-pointer to dynamic object structure(dT);  
	// static-address value "pointer2ObjBaseAdrress" is POINTER to  Base-addres of Object/ <" POINTER to THIR ptr">  or <pointer2ObjBaseAdrress>
	//(found from CE) pObjectBaseAddress NOTE: not THIS pointer or Baseaddress of object
	//The output is this pointer or object instance base address as T*
	T* get_THIS_frm_ptr2ObjBaseAdrs( ptrdiff_t pointer2ObjBaseAdrress )
	{
		__try
		{
			return (*(T**) pointer2ObjBaseAdrress);
		}
		__except (filter( GetExceptionCode(), GetExceptionInformation() ))
		{
			return nullptr;
		}
	}	
};
 /* Very Imporatnt  to instantiate class as Global Inline variable below class definition    */
inline MemEdit g_memEdit{}; // inline definition of Global class objects to be used/inluded in multiple file location




// inline MemEdit g_memEdit{};
//readPtring memmory:
//int hue= memedit.readPtr<int>(0x1337,1);
//where "0x1337" is the address and "1" is the default value
//Writing memory:
//memedit.writePtr<float>( 0x1337, 0.1f );
//memedit.add<int>( 0x1337, 2 );
//Setting a pointer to a game-object from  :
//memedit.pObjectThis<T>(addrs).
//Casting a pointer of type T from hexadecimal address
// memedit.makePtr<T>(addrs)
#endif
```

`UTILITIES/SigFunctor.h`:

```h
#ifndef SIGFUNCTOR_H
#define SIGFUNCTOR_H
#include <Windows.h>
#include<Psapi.h>
#include <iostream>
#include <string>

class SigFunctor
{
private:
	HMODULE hModule {};
	ptrdiff_t baseAddress {};
	ptrdiff_t moduleLength {};
	ptrdiff_t m_address_found {};

public:
	SigFunctor() = default;

	
	void setMemoryInfo( const char* moduleName)
	{

		// Get the handle to the target process's module
		hModule = ::GetModuleHandleA( moduleName );
		if (hModule == NULL)
		{
			std::cout << "Could not retrieve the handle to the target process's module." << std::endl;
			return;
		}

		// Get information about the target process's module
		MODULEINFO moduleInfo;
		GetModuleInformation( GetCurrentProcess(), hModule, &moduleInfo, sizeof( moduleInfo ) );

		// Get the base m_address_found and size of the target process's module
		baseAddress = (ptrdiff_t) moduleInfo.lpBaseOfDll;
		moduleLength = moduleInfo.SizeOfImage;

		// Check the searchable reason of the target process's memory
		MEMORY_BASIC_INFORMATION mbi;
		VirtualQuery( (LPCVOID) baseAddress, &mbi, sizeof( mbi ) );
		if (mbi.State != MEM_COMMIT)
		{
			std::cout << "Could not retrieve the base_address of the target process's memory." << std::endl;
		}
	
	}


	SigFunctor& FindPattern(const char* aobPattern, const char* szMask )
	{
		DWORD patternLength = (DWORD) strlen( szMask );
		for (DWORD i = 0; i < moduleLength - patternLength; ++i)
		{

			bool found = true;
			for (DWORD j = 0; j < patternLength; ++j)
			{
				found &= (szMask[j] == '?') || (aobPattern[j] == *(char*) (baseAddress + i + j));
			}
			//found = true, our entire pattern was found
			// return the memory address so we acn write it
			if (found)
			{
				m_address_found = baseAddress + i;
				break; // break out of the main outer loop if pattern is found VIMP
			}
			else
			{
				//address cant be found , pattern may be wrong
				m_address_found = 0xBADF00D;// else print 
				
			}
		}
	
		return *this;
	}

	SigFunctor& operator() ( const char* moduleName, const char* aobPattern, const char* szMask )
	{
		setMemoryInfo( moduleName );
		return  { FindPattern( aobPattern, szMask ) }; // return SigFunctor{} class as a anonymous object
		
	}


	SigFunctor& add( ptrdiff_t offset )
	{
		m_address_found += offset;
		return *this;
	}
	SigFunctor& sub( ptrdiff_t offset )
	{
		m_address_found -= offset;
		return *this;
	}

	// Patching byttes with user provided payload
	//At the desired address found write user provided payload
	//Provide address, payload and payload length to the function. get payload length using sizeof(paLoad)
	void patchByte( ptrdiff_t address, const char* payLoad )
	{
		std::size_t payLoadLen =  strlen( payLoad );
		DWORD oldProtect {};
		VirtualProtect( (LPVOID) address, payLoadLen, PAGE_EXECUTE_READWRITE, &oldProtect );
		RtlMoveMemory( (byte*) address, payLoad, payLoadLen );
		VirtualProtect( (LPVOID) address, payLoadLen, oldProtect, &oldProtect );
	}
	         
	ptrdiff_t GetAddress() // This gives the address of the first opcode byte from where pattern was copied
	{
		return m_address_found;
	}   
	//Get address of dword_offset found at a certain differnce from signature found by dereferencing at that point
	ptrdiff_t GetOffsetAddress32( int diff_firstInstByt_firstAddrByt )
	{
		ptrdiff_t offset_address= *(INT32*) (m_address_found + diff_firstInstByt_firstAddrByt);
		return offset_address;
	}



	ptrdiff_t GetAbsoluteAddress64( int whole_inst_size, int diff_firstInstByt_firstAddrByt )
	{
		ptrdiff_t  rip_address = m_address_found + whole_inst_size; // this gives address of RIP which is address of next instruction start
		//This instruction adds the offset no. of bytes between between the first byte of instruction and first byte of address to the address found
		// Then it is derefernced to read value of SIGNED INTEGER 32 bit to get the value of relative offset in __int32 hence *(INT32*)
		//This is then added to rip_address(ADDRESS NEXT INSTTUCTION) calculated above to get the concerned absolute address value contained in form of [rel_int32].
		//note use of *(INT32*) signed relative offset to go up/down from curent position
		ptrdiff_t absolute_address = rip_address + *(INT32*) (m_address_found + diff_firstInstByt_firstAddrByt);

		return absolute_address;
	}

};
/*
int main()
{
	opertaor() overloading to create a functor for Signature-Scanner class "SigFunctor{}";

	// Search for a pattern of bytes in the target process's memory
	char aobPattern[] =  "\x55\x8B\xEC\x8B\"
	char szMask[] = "xxxx";
	//search for pattern address like:
	ptrdiff_t addressFound = SigFunctor{}(moduleName,aobPattern,szMask).GetAddress()
	// Add an offset to the found m_address_found
	ptrdiff_t addressFound1 = SigFunctor{}(moduleName,aobPattern,szMask).add(offset)

	// Patch new bytes to the desired location in memory
	char bWrite[] = "\x11\x22\x33\x44\";
	SigFunctor{}(moduleName,aobPattern,szMask).patchByte(address,payLoad);

	return 0;
}  */

#endif
```

`UTILITIES/Vector.h`:

```h
#pragma once
#include<cassert>
#include<cmath>
#include <corecrt_math_defines.h> // For PI cosnstant

#include <cmath>

#define DECL_ALIGN(x) __declspec(align(x))
#define ALIGN16 DECL_ALIGN(16)
#define ALIGN16_POST DECL_ALIGN(16)
#define CHECK_VALID( _v)	0
struct Matrix3x4
{
	float matrixArray[12]; // Changed to matrix array as using a matrix3x4 in reclass was giving wrong values
};
struct Matrix4x4
{
	float matrix4x4[16]{};
};

class Vector2
{
public:
	float m_x {};
	float m_y {};

	Vector2() = default;
	Vector2( float x, float y )
		:m_x { x }, m_y { y }
	{
	}
	Vector2& operator=( const Vector2& vec )
	{
		m_x = vec.m_x;
		m_y = vec.m_y;
		return *this;
	}

	Vector2& operator+=( const Vector2& vec )
	{
		m_x += vec.m_x;
		m_y += vec.m_y;
		return *this;
	}
	Vector2& operator-=( const Vector2& vec )
	{
		m_x -= vec.m_x;
		m_y -= vec.m_y;
		return *this;
	}
	Vector2& operator*=( const Vector2& vec )
	{
		m_x *= vec.m_x;
		m_y *= vec.m_y;
		return *this;
	}
	Vector2& operator/=( const Vector2& vec )
	{
		m_x /= vec.m_x;
		m_y /= vec.m_y;
		return *this;
	}
	Vector2& operator*( const float f )
	{
		m_x *= f;
		m_y *= f;
		return *this;
	}

	Vector2& operator*=( const float f )
	{
		m_x *= f;
		m_y *= f;
		return *this;
	}
	Vector2& operator/=( const float f )
	{
		m_x /= f;
		m_y /= f;

		return *this;
	}

	friend Vector2 operator+( const Vector2& vec1, const Vector2& vec2 )
	{
		return { vec1.m_x + vec2.m_x , vec1.m_y + vec2.m_y };
	}
	friend Vector2 operator-( const Vector2& vec1, const Vector2& vec2 )
	{
		return{ vec1.m_x - vec2.m_x,vec1.m_y - vec2.m_y };
	}

	float Length() const
	{
		return sqrt( (m_x * m_x) + (m_y * m_y) );
	}

	Vector2& Normalize()
	{
		return { (*this) *= (1 / Length()) };
	}
	float DistanceTo( const Vector2& vec )
	{
		return(*this - vec).Length();
	}
	float Dot( const Vector2& vec )
	{
		return { (m_x * vec.m_x) + (m_y * vec.m_y) };
	}

	friend Vector2 RotatePoint( Vector2 pointToRotate, Vector2 centrePoint, float angle, bool angleInRadians = false )
	{
		if (!angleInRadians)
			angle = (float) (angle * M_PI / 180.0f);
		float cosTheta = (float) cos( angle );
		float sineTheta = (float) sin( angle );
		Vector2 returnVec = {
			cosTheta * (pointToRotate.m_x - centrePoint.m_x) - sineTheta * (pointToRotate.m_y - centrePoint.m_y),
			sineTheta * (pointToRotate.m_x - centrePoint.m_x) + cosTheta * (pointToRotate.m_y - centrePoint.m_y) };
		returnVec += centrePoint;
		return returnVec;
	}

};

class Vector3
{
	
public:
	float m_x {};
	float m_y {};
	float m_z {};
	
	Vector3( float x, float y, float z )
		:m_x { x }, m_y { y }, m_z { z }
	{
	}
	Vector3( void )
	{
		Invalidate();
	}

	Vector3( const float* clr )
	{
		m_x = clr[0];
		m_y = clr[1];
		m_z = clr[2];
	}

	void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f )
	{
		m_x = ix; m_y = iy; m_z = iz;
	}
	bool IsValid() const
	{
		return std::isfinite( m_x ) && std::isfinite( m_y ) && std::isfinite( m_z );
	}
	void Invalidate()
	{
		m_x = m_y = m_z = std::numeric_limits<float>::infinity();
	}


	void Zero()
	{
		m_x = m_y = m_z = 0.0f;
	}

	bool operator==( const Vector3& src ) const
	{
		return (src.m_x == m_x) && (src.m_y == m_y) && (src.m_z == m_z);
	}
	bool operator!=( const Vector3& src ) const
	{
		return (src.m_x != m_x) || (src.m_y != m_y) || (src.m_z !=m_z);
	}

	Vector3& operator=( const Vector3& vec )
	{
		m_x = vec.m_x;
		m_y = vec.m_y;
		m_z = vec.m_z;
		return *this;
	}

	Vector3& operator+=( const Vector3& vec )
	{
		m_x += vec.m_x;
		m_y += vec.m_y;
		m_z +=vec.m_z;
		return *this;
	}
	Vector3& operator-=( const Vector3& vec )
	{
		m_x -= vec.m_x;
		m_y -= vec.m_y;
		m_z -= vec.m_z;
		return *this;
	}
	Vector3& operator*=( const Vector3& vec )
	{
		m_x *= vec.m_x;
		m_y *= vec.m_y;
		m_z *= vec.m_z;
		return *this;
	}
	Vector3& operator/=( const Vector3& vec )
	{
		m_x /= vec.m_x;
		m_y /= vec.m_y;
		m_z /= vec.m_z;
		return *this;
	}
	Vector3& operator*( const float f )
	{
		m_x *= f;
		m_y *= f;
		m_z *= f;
		return *this;
	}

	Vector3& operator*=( const float f )
	{
		m_x *= f;
		m_y *= f;
		m_z *= f;
		return *this;
	}
	Vector3& operator/=( const float f )
	{
		m_x /= f;
		m_y /= f;
		m_z /= f;
		return *this;
	}
	float& operator[]( int i )
	{
		assert( (i >= 0) && (i < 3) );
		return ((float*) this)[i];
	}

	float operator[]( int i ) const
	{
		assert( (i >= 0) && (i < 3) );
		return ((float*) this)[i];
	}
	friend Vector3 operator+( const Vector3& vec1, const Vector3& vec2 )
	{
		return{ vec1.m_x + vec2.m_x,vec1.m_y + vec2.m_y,vec1.m_z + vec2.m_z };
	}
	friend Vector3 operator-( const Vector3& vec1, const Vector3& vec2 )
	{
		return{ vec1.m_x - vec2.m_x,vec1.m_y - vec2.m_y,vec1.m_z - vec2.m_z };
	}
	friend void VectorAdd( const Vector3& a, const Vector3& b, Vector3& c )
	{
		
		c.m_x = a.m_x + b.m_x;
		c.m_y = a.m_y + b.m_y;
		c.m_z = a.m_z + b.m_z;
	}
	friend void VectorSubtract( const Vector3& a, const Vector3& b, Vector3& c )
	{
	
		c.m_x = a.m_x - b.m_x;
		c.m_y = a.m_y - b.m_y;
		c.m_z = a.m_z - b.m_z;
	}
	friend void VectorCopy( const Vector3& src, Vector3& dst )
	{

		dst.m_x = src.m_x;
		dst.m_y = src.m_y;
		dst.m_z = src.m_z;
	}
	friend void VectorClear( Vector3& a )
	{
		a.m_x = a.m_y = a.m_z = 0.0f;
	}

	float Length() const
	{
		return sqrt( (m_x*m_x) + (m_y*m_y) + (m_z*m_z) );
	}
	float LengthSqr() const
	{
		return ( (m_x * m_x) + (m_y * m_y) + (m_z * m_z) );
	}
	Vector3& Normalize()
	{
		return { (*this) *= (1 / Length()) };
	}
	float DistanceTo( const Vector3& vec )
	{
		return(*this - vec).Length();
	}
	float Dot( const Vector3& vec )
	{
		return { (m_x * vec.m_x) + (m_y * vec.m_y) + (m_z * vec.m_z) };
	}
	Vector3 Cross( const Vector3& vec ) const
	{
		return { ((m_y * vec.m_z) - (m_z * vec.m_y)), ((m_z * vec.m_x) - (m_x * vec.m_z)), ((m_x * vec.m_y) - (m_y * vec.m_x)) };
	}
};

class Vector4 :public Vector3
{
public:
	float m_x{};
	float m_y{};
	float m_z{};
	float m_w{};

};

class ALIGN16 VectorAligned : public Vector3
{
public:
	inline VectorAligned( void )
	{
	};

	inline VectorAligned(Vector3 X, Vector3 Y, Vector3 Z )
	{
		//Init(X, Y, Z);
	}

	explicit VectorAligned( const Vector3& vOther )
	{
		Init( vOther.m_x, vOther.m_y, vOther.m_z );
	}

	VectorAligned& operator=( const Vector3& vOther )
	{
		Init( vOther.m_x, vOther.m_y, vOther.m_z );
		return *this;
	}

	float w;	// this space is used anyway
} ALIGN16_POST;
```

`bspflags.h`:

```h
//========= Copyright Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $Workfile:     $
// $Date:         $
// $NoKeywords: $
//=============================================================================//

#ifndef BSPFLAGS_H
#define BSPFLAGS_H

#ifdef _WIN32
#pragma once
#endif

// contents flags are seperate bits
// a given brush can contribute multiple content bits
// multiple brushes can be in a single leaf

// these definitions also need to be in q_shared.h!

// lower bits are stronger, and will eat weaker brushes completely
#define	CONTENTS_EMPTY			0		// No contents

#define	CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define	CONTENTS_AUX			0x4
#define	CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define	CONTENTS_SLIME			0x10
#define	CONTENTS_WATER			0x20
#define	CONTENTS_BLOCKLOS		0x40	// block AI line of sight
#define CONTENTS_OPAQUE			0x80	// things that cannot be seen through (may be non-solid though)
#define	LAST_VISIBLE_CONTENTS	0x80

#define ALL_VISIBLE_CONTENTS (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED			0x200	

// unused 
// NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS
// if not visible, then grab from the bottom.
#define CONTENTS_UNUSED6		0x400

#define CONTENTS_TEAM1			0x800	// per team contents used to differentiate collisions 
#define CONTENTS_TEAM2			0x1000	// between players and objects on different teams

// ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
#define CONTENTS_MOVEABLE		0x4000

// remaining contents are non-visible, and don't eat brushes
#define	CONTENTS_AREAPORTAL		0x8000

#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000

// currents can be added to any other contents, and may be mixed
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000

#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace


// NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
#define	SURF_LIGHT		0x0001		// value will hold the light strength
#define	SURF_SKY2D		0x0002		// don't draw, indicates we should skylight + draw 2d sky but not draw the 3D skybox
#define	SURF_SKY		0x0004		// don't draw, but add to skybox
#define	SURF_WARP		0x0008		// turbulent water warp
#define	SURF_TRANS		0x0010
#define SURF_NOPORTAL	0x0020	// the surface can not have a portal placed on it
#define	SURF_TRIGGER	0x0040	// FIXME: This is an xbox hack to work around elimination of trigger surfaces, which breaks occluders
#define	SURF_NODRAW		0x0080	// don't bother referencing the texture

#define	SURF_HINT		0x0100	// make a primary bsp splitter

#define	SURF_SKIP		0x0200	// completely ignore, allowing non-closed brushes
#define SURF_NOLIGHT	0x0400	// Don't calculate light
#define SURF_BUMPLIGHT	0x0800	// calculate three lightmaps for the surface for bumpmapping
#define SURF_NOSHADOWS	0x1000	// Don't receive shadows
#define SURF_NODECALS	0x2000	// Don't receive decals
#define SURF_NOCHOP		0x4000	// Don't subdivide patches on this surface 
#define SURF_HITBOX		0x8000	// surface is part of a hitbox



// -----------------------------------------------------
// spatial content masks - used for spatial queries (traceline,etc.)
// -----------------------------------------------------
#define	MASK_ALL					(0xFFFFFFFF)
// everything that is normally solid
#define	MASK_SOLID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// everything that blocks player movement
#define	MASK_PLAYERSOLID			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// blocks npc movement
#define	MASK_NPCSOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// water physics in these contents
#define	MASK_WATER					(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
// everything that blocks lighting
#define	MASK_OPAQUE					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
// everything that blocks lighting, but with monsters added.
#define MASK_OPAQUE_AND_NPCS		(MASK_OPAQUE|CONTENTS_MONSTER)
// everything that blocks line of sight for AI
#define MASK_BLOCKLOS				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
// everything that blocks line of sight for AI plus NPCs
#define MASK_BLOCKLOS_AND_NPCS		(MASK_BLOCKLOS|CONTENTS_MONSTER)
// everything that blocks line of sight for players
#define	MASK_VISIBLE					(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
// everything that blocks line of sight for players, but with monsters added.
#define MASK_VISIBLE_AND_NPCS		(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
// bullets see these as solid
#define	MASK_SHOT					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
// non-raycasted weapons see this as solid (includes grates)
#define MASK_SHOT_HULL				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
// hits solids (not grates) and passes through everything else
#define MASK_SHOT_PORTAL			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
// everything normally solid, except monsters (world+brush only)
#define MASK_SOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
// everything normally solid for player movement, except monsters (world+brush only)
#define MASK_PLAYERSOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
// everything normally solid for npc movement, except monsters (world+brush only)
#define MASK_NPCSOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// just the world, used for route rebuilding
#define MASK_NPCWORLDSTATIC			(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// These are things that can split areaportals
#define MASK_SPLITAREAPORTAL		(CONTENTS_WATER|CONTENTS_SLIME)

// UNDONE: This is untested, any moving water
#define MASK_CURRENT				(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)

// everything that blocks corpse movement
// UNDONE: Not used yet / may be deleted
#define	MASK_DEADSOLID				(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)

#endif // BSPFLAGS_H

```

`dllMain.cpp`:

```cpp
#include"Includes.h"
#include"dxStuff.h"
#include"drawLogic.h"
#include"Methods.h"
#include<thread> //! Include to create a thread function from Lambda for which we willw ait upon till completion

//!New global variable made for viewProjMatrix[16] as inside player class it was overriding other offsets
//!This was causing weird bug of boomer sticker appearing
float g_viewProjMatrix[16]{};

DWORD WINAPI myThreadProc(HMODULE hInstDLL)
{
	AllocConsole(); // To allocate console for logging
	FILE* f;
	freopen_s(&f, "CONOUT$", "w", stdout);

	LocalPlayer* localPlayerBaseAddress = LocalPlayer::getLocalPlayerPtr();
	EntityListInstance* entityListBaseAddress = EntityListInstance::getEntityListInstancePtr();

	std::cout << "LocalPlayer Base-Address:\t" << std::hex << (ptrdiff_t)localPlayerBaseAddress << '\n';
	std::cout << "EntityList Base-Address:\t" << std::hex << (ptrdiff_t)entityListBaseAddress << '\n';
	std::cout << "Closest enemy address is:\t" << std::hex << (ptrdiff_t)entityListBaseAddress->GetClosestEnemy() << '\n';
	std::cout << "The view angles pointer editable is: " << localPlayerBaseAddress->getViewAnglesPtr() << '\n';


	std::cout << " CEngineTraceClient base address: " << std::hex << (ptrdiff_t)CEngineTraceClient::instance();
	std::cout << " Trace-ray game function: " << std::hex << CEngineTraceClient::lpOrigTraceRayAddress;

	//!To Hook endScene() function of Direct3d9 where various loops execute
	DirectXStuff::dxstfInstance()->getEndSceneHooked();

	while (!GetAsyncKeyState(VK_END) & 1)
	{

		localPlayerBaseAddress->updateMatrixButtons(); // This has to causing the bug
		/*
		if (GetAsyncKeyState( VK_F1 ) & 1)
		{
			for (int i{ 0 }; i < 16; ++i)
			{
				if (i % 4 == 0)
					std::cout << '\n';
				std::cout <<g_viewProjMatrix[i] << '\t';
			}
			std::cout << '\n' << '\n';
		}*/

		Sleep(1);
	}

	//unload of Dll and reource deallocation code.
	//xg_HnP.unhook<7>((char*)DirectXStuff::dxstfInstance()->lpOriginalFuncAddress);

	//unload of Dll and reource deallocation code.
	//! std::thread include to convert unHook code as a thread function
	//! We will wait upon this thread function till it finishes . so that The Game does not crash when Dll is uninjected
	std::thread myWaitThreadFunction { g_HnP.unHook,(char*)DirectXStuff::dxstfInstance()->lpOriginalFuncAddress,7 };

	//! Std::thread ::join() to brute force wait upon execution of thread unHook function
	myWaitThreadFunction.join();

	Sleep(2000);

	if (f)
		fclose( f );
	FreeConsole();
	FreeLibraryAndExitThread( hInstDLL, 0 );//to call DLL_PROCESS_DETACH and resource deallocation
	//xSleep(3000);
	return 0;
}

BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:

		::DisableThreadLibraryCalls( hinstDLL );
		CreateThread( nullptr, 0, LPTHREAD_START_ROUTINE( myThreadProc ), hinstDLL, 0, nullptr );
		break;

		case DLL_PROCESS_DETACH:
		//perform any necesary clean-up
		break;

	}
	return TRUE; //Succesful DLL_PROCESS_ATTACH

}
```

`drawLogic.cpp`:

```cpp
#include"drawLogic.h"
#include"Player.h"
// Drawing lines here by Calling ID3DXLine interface
// and D3DXCreateLine function to get address of interface

ID3DXLine* g_pLine{}; //Crteating a global variable here and stop creating/releasing it every frame Prevented the LAG

ID3DXFont* g_pFont{}; // craete a global font variable here and not inside loop


void DrawLine( IDirect3DDevice9* pDevice, float x1, float y1, float x2, float y2, float width, bool antialias, D3DCOLOR color )
{
 // Interface implements line drawing using textured triangles
	if(!g_pLine) // Only create a g_pLine variable if none is there
	D3DXCreateLine( pDevice, &g_pLine );
	D3DXVECTOR2 line[] = { D3DXVECTOR2( x1,y1 ),D3DXVECTOR2( x2,y2 ) };
	g_pLine->SetWidth( width );
	if (antialias)
		g_pLine->SetAntialias( 1 );
	//pLine->Begin(); // exception is being thrown here when game is crashing on unhook
	g_pLine->Draw( line, 2, color );
	//pLine->End();
	//pLine->Release();
}


//drawing filled rectangle function to be called in hookedEndscene
void DrawFillRect( IDirect3DDevice9* pDevice, int x, int y, int w, int h, unsigned char r, unsigned char g, unsigned char b )
{
	D3DCOLOR rectColor = D3DCOLOR_XRGB( r, g, b );	//No point in using alpha because clear & alpha dont work!
	D3DRECT BarRect = { x, y, x + w, y + h };

	pDevice->Clear( 1, &BarRect, D3DCLEAR_TARGET | D3DCLEAR_TARGET, rectColor, 0, 0 );
}
// a Drawline function wrapper to take Vector2 objects as parameters
void DrawLine( IDirect3DDevice9* pDevice, Vector2 src, Vector2 dst, float width, bool antialias, D3DCOLOR color )
{

	DrawLine( pDevice, src.m_x, src.m_y, dst.m_x, dst.m_y, width, antialias, color );

}
//Draw line using draw prmitive method
void Line3D( IDirect3DDevice9* pDevice, float X, float Y, float Z, float X2, float Y2, float Z2, D3DCOLOR Color )
{
	struct stD3DVertex
	{
		float x, y, z, rhw;
		unsigned long color;
	};
	stD3DVertex objData[2];

	objData[0].x = X;
	objData[0].y = Y;
	objData[0].z = Z;
	objData[0].rhw = 0.0f;
	objData[0].color = Color;

	objData[1].x = X2;
	objData[1].y = Y2;
	objData[1].z = Z2;
	objData[1].rhw = 0.0f;
	objData[1].color = Color;

	LPDIRECT3DVERTEXBUFFER9 g_VertexBuffer = NULL;


    #define D3DFVF_VERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
	pDevice->CreateVertexBuffer( sizeof( objData ), 0, D3DFVF_VERTEX, D3DPOOL_DEFAULT, &g_VertexBuffer, NULL );

	void* ptr;

	g_VertexBuffer->Lock( 0, sizeof( objData ), (void**) &ptr, 0 );

	memcpy( ptr, objData, sizeof( objData ) );

	g_VertexBuffer->Unlock();

	//pDevice->BeginScene();


	pDevice->SetStreamSource( 0, g_VertexBuffer, 0, sizeof( stD3DVertex ) );

	pDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
	pDevice->SetFVF( D3DFVF_VERTEX );
	//pDevice->SetFVF(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1);
	pDevice->DrawPrimitive( D3DPT_LINELIST, 0, 1 );


	//pDevice->EndScene();
	//OrigPresent(pDevice, 0, 0, 0, 0);
}



void Line3D( IDirect3DDevice9* pDevice, Vector2 src, Vector2 dst, D3DCOLOR Color )
{

	Line3D( pDevice, src.m_x, src.m_y, 1.0f, dst.m_x, dst.m_y, 1.0f, Color );



}
void DrawTextEsp ( IDirect3DDevice9* pDevice,const char* text, float x, float y, D3DCOLOR color )
{
	RECT rect{};
	//! if ID3DXFont* Interface font object is  not created then only use D3DXCreateFontA to create it
	
	if (!g_pFont) 
	//D3DXCreateFontA version has to be used,D3DXCreateFont default to D3DXCreateFontW which requires LPCWSTR type 2nd last parameter
	D3DXCreateFontA( pDevice, 14, 0, FW_NORMAL, 1, false, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial", &g_pFont );

	SetRect( &rect, x + 1, y + 1, x + 1, y + 1 );

	g_pFont->DrawTextA( NULL, text, -1, &rect, DT_CENTER | DT_NOCLIP, D3DCOLOR_ARGB( 255, 0, 0, 0 ) );

	SetRect( &rect, x , y , x , y  );
	g_pFont->DrawTextA( NULL, text, -1, &rect, DT_CENTER | DT_NOCLIP, color );

}

//Drwaing 3d boxes around entities

void DrawEspBox3D( IDirect3DDevice9* pDevice, Vector3 entityTop, Vector3 entityOrigin, Vector3 viewAngle, int width, int thickness, D3DCOLOR color )
{

	float height3D = abs(entityTop.m_z- entityOrigin.m_z );
	Vector3 o1, o2, o3, o4, t1, t2, t3, t4;
	o1.m_z = o2.m_z = o3.m_z = o4.m_z = entityOrigin.m_z;

	o1.m_x = entityOrigin.m_x + (cosf( angleRad( viewAngle.m_y + 45 ) ) * width);
	o1.m_y = entityOrigin.m_y+ (sinf( angleRad( viewAngle.m_y + 45 ) ) * width);

	o2.m_x = entityOrigin.m_x + (cosf( angleRad( viewAngle.m_y + 135 ) ) * width);
	o2.m_y = entityOrigin.m_y + (sinf( angleRad( viewAngle.m_y + 135 ) ) * width);

	o3.m_x = entityOrigin.m_x + (cosf( angleRad( viewAngle.m_y + 225 ) ) * width);
	o3.m_y = entityOrigin.m_y + (sinf( angleRad( viewAngle.m_y + 225 ) ) * width);

	o4.m_x = entityOrigin.m_x + (cosf( angleRad( viewAngle.m_y + 315 ) ) * width);
	o4.m_y = entityOrigin.m_y + (sinf( angleRad( viewAngle.m_y + 315 ) ) * width);

	t1.m_x = o1.m_x;
	t1.m_y = o1.m_y;
	t1.m_z = o1.m_z + height3D;

	t2.m_x = o2.m_x;
	t2.m_y = o2.m_y;
	t2.m_z = o2.m_z + height3D;

	t3.m_x = o3.m_x;
	t3.m_y = o3.m_y;
	t3.m_z = o3.m_z + height3D;

	t4.m_x = o4.m_x;
	t4.m_y = o4.m_y;
	t4.m_z = o4.m_z + height3D;

	Vector2 o1two, o2two, o3two, o4two, t1two, t2two, t3two, t4two;

	if (W2S( o1, o1two ) && W2S( o2, o2two ) && W2S( o3, o3two ) && W2S( o4, o4two ) && W2S( t1, t1two ) && W2S( t2, t2two ) && W2S( t3, t3two ) && W2S( t4, t4two ))
	{
		//Draw lines for columns
		DrawLine( pDevice,t1two, o1two, thickness, false, color );
		DrawLine( pDevice, t2two, o2two, thickness, false, color );
		DrawLine( pDevice, t3two, o3two, thickness, false, color );
		DrawLine( pDevice, t4two, o4two, thickness, false, color );
		//DrawLines for Top bases
		DrawLine( pDevice, t1two, t2two, thickness, false, color );
		DrawLine( pDevice, t2two, t3two, thickness, false, color );
		DrawLine( pDevice, t3two, t4two, thickness, false, color );
		DrawLine( pDevice, t4two, t1two, thickness, false, color );
		//DrawLines for bottom bases
		DrawLine( pDevice, o1two, o2two, thickness, false, color );
		DrawLine( pDevice, o2two, o3two, thickness, false, color );
		DrawLine( pDevice, o3two, o4two, thickness, false, color );
		DrawLine( pDevice, o4two, o1two, thickness, false, color );


	}


}
// drawing 2d boxes around the entities 
void DrawEspBox2D( IDirect3DDevice9* pDevice, Vector2 top, Vector2 bottom, int thickness, bool antialias, D3DCOLOR color )
//void DrawEspBox2D( IDirect3DDevice9* pDevice, Vector2 top, Vector2 bottom,  D3DCOLOR color )
{
	int height = std::abs( top.m_y - bottom.m_y );

	Vector2 topLeft{};
	topLeft.m_x = top.m_x - height / 4;
	topLeft.m_y = top.m_y;
	Vector2 topRight{};
	topRight.m_x = top.m_x + height / 4;
	topRight.m_y = top.m_y;
	Vector2 bottomLeft{};
	bottomLeft.m_x = bottom.m_x - height / 4;
	bottomLeft.m_y = bottom.m_y;
	Vector2 bottomRight{};
	bottomRight.m_x = bottom.m_x + height / 4;
	bottomRight.m_y = bottom.m_y;
	
	DrawLine( pDevice, topLeft, topRight, thickness, false, color );
	DrawLine( pDevice, bottomLeft, bottomRight, thickness, false, color );
	DrawLine( pDevice, topLeft, bottomLeft, thickness, false, color );
	DrawLine( pDevice, topRight, bottomRight, thickness, false, color );  
	/*
	Line3D( pDevice, topLeft, topRight,  color );
	Line3D( pDevice, bottomLeft, bottomRight, color );
	Line3D( pDevice, topLeft, bottomLeft, color );
	Line3D( pDevice, topRight, bottomRight,  color );  */

}

```

`drawLogic.h`:

```h
#pragma once
#include "Includes.h"

//drawing filled rectangle function to be called in hookedEndscene

extern ID3DXLine* g_pLine; // declaration of global variable(inherent external linkage) to put it in scope of current translation unit.


extern ID3DXFont* g_pFont; // declaration of global font variable

void DrawFillRect( IDirect3DDevice9* pDevice, int x, int y, int w, int h, unsigned char r, unsigned char g, unsigned char b );

// Drawing lines here by Calling ID3DXLine interface
// and D3DXCreateLine function to get address of interface
void DrawLine( IDirect3DDevice9* pDevice, float x1, float y1, float x2, float y2, float width, bool antialias, D3DCOLOR color );

// a DrawLine wrapper function using Vector2 object instead of floats, overload resolution to select function
void DrawLine( IDirect3DDevice9* pDevice, Vector2 src, Vector2 dst, float width, bool antialias, D3DCOLOR color );

void DrawEspBox2D( IDirect3DDevice9* pDevice, Vector2 top, Vector2 bottom, int thickness, bool antialias, D3DCOLOR color );

//void DrawEspBox2D( IDirect3DDevice9* pDevice, Vector2 top, Vector2 bottom,  D3DCOLOR color );


void Line3D( IDirect3DDevice9* pDevice, float X, float Y, float Z, float X2, float Y2, float Z2, D3DCOLOR Color );

void Line3D( IDirect3DDevice9* pDevice, Vector2 src, Vector2 dst, D3DCOLOR Color );

void DrawEspBox3D( IDirect3DDevice9* pDevice,Vector3 entityTop,Vector3 entityOrigin, Vector3 viewAngle, int width, int thickness, D3DCOLOR color );

void DrawTextEsp( IDirect3DDevice9* pDevice, const char* text, float x, float y, D3DCOLOR color ); // for drawing text on screen
```

`dxStuff.h`:

```h
#pragma once
#include"Windows.h"
#include"drawLogic.h"
#include"UTILITIES/HookTemplate.h"
#include"Player.h"
#include"Methods.h"
#include"Extra.h"
#include<string>
#include<sstream>

class DirectXStuff
{
private:
	DirectXStuff() = default;
public:

	using aliasEndScene = HRESULT( __stdcall* )(IDirect3DDevice9*);
	static inline aliasEndScene EndScenePtr{  };

	using entityNameFuncAlias = char* (__thiscall*)(void* pECX);
	static inline entityNameFuncAlias entityNameFuncPtr = (entityNameFuncAlias) (SigFunctor{}("client.dll", "\x56\x8B\xF1\x8B\x06\x8B\x90\x00\x00\x00\x00\xFF\xD2\x50\xE8\x00\x00\x00\x00\x83\xC4\x00\x84\xC0\x74\x00\x8B\xB6", "xxxxxxx????xxxx????xx?xxx?xx").GetAddress());

	ptrdiff_t lpOriginalFuncAddress{};
	// interface pointer to IDirect3DDevice9
	IDirect3DDevice9* pDevice{};

	static DirectXStuff* dxstfInstance()
	{
		static DirectXStuff dxstuff;
		return &dxstuff;
	}

	// get the size of GameWindow
	static  Vector2 getWindowSize()
	{
		//get HWND of Game window
		HWND gameWindow = FindWindowA( NULL, "Left 4 Dead 2 - Direct3D 9" );
		float gameWindowWidth{};
		float gameWindowHeight{};
		RECT rect{};
		if (GetWindowRect( gameWindow, &rect ))
		{
			gameWindowWidth = rect.right - rect.left;
			gameWindowHeight = rect.bottom - rect.top;
			//adjustment
			gameWindowWidth -= 5;
			gameWindowHeight -= 29;
		}
		return { gameWindowWidth,gameWindowHeight };

	}
	// A separate variable for window-size created
	// apart from global variable to be used inside class
	static inline Vector2 windowSize{ getWindowSize() };


	// Create our hook function having prototype as Endscene
	// FIX THIS LATER== TOO MUCH STATIC
	//hookEndScene member function has to be made static for being called by hook inside its own class
	static HRESULT __stdcall hookEndScene( IDirect3DDevice9* pDevice )
	{
		//?Trace-Ray called here to have same Thread Local storage as game thread calling trace-ray function
		CEngineTraceClient::instance()->traceRayHook();

		//drawing text stuff
		//xThis has to be fixed : Not working OK
		if (extra::g_choices.statusText)
		{
			DrawTextEsp( pDevice, "First copied Esp by ReVirus. More original stuff to follow!", windowSize.m_x / 2, windowSize.m_y - 20, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
		}

		//drawing menu with controls

		int menuOffsetX = windowSize.m_x / 2;
		int menuOffsetY = 50;
		D3DCOLOR enabled = D3DCOLOR_ARGB( 255, 0, 255, 0 );
		D3DCOLOR disabled = D3DCOLOR_ARGB( 255, 255, 0, 0 );

		if (!extra::g_choices.showMenu) //if menu key is disabled only this will show
		{
			DrawTextEsp( pDevice,"Show Menu (INS)", menuOffsetX, menuOffsetY, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
		}
		else
		{
			//Menu items to show when menu key is enabled
			DrawTextEsp( pDevice, "Show Menu (INS)", menuOffsetX, menuOffsetY + 0 * 12, extra::g_choices.showMenu ? enabled : disabled );
			DrawTextEsp( pDevice, "Show snapLines (F1)", menuOffsetX, menuOffsetY +1 * 12, extra::g_choices.snapLines ? enabled : disabled );
			DrawTextEsp( pDevice, "Show box2D (F2)", menuOffsetX, menuOffsetY + 2 * 12, extra::g_choices.box2D ? enabled : disabled );
			DrawTextEsp( pDevice, "Show statusText (F3)", menuOffsetX, menuOffsetY + 3 * 12, extra::g_choices.statusText ? enabled : disabled );
			DrawTextEsp( pDevice, "Show statusTextTeam (F4)", menuOffsetX, menuOffsetY + 4 * 12, extra::g_choices.statusTextTeam ? enabled : disabled );
			DrawTextEsp( pDevice, "Show box3D (F5)", menuOffsetX, menuOffsetY + 5 * 12, extra::g_choices.box3D ? enabled : disabled );
			DrawTextEsp( pDevice, "Show headlineEsp (F6)", menuOffsetX, menuOffsetY + 6 * 12, extra::g_choices.headLineEsp ? enabled : disabled );
			DrawTextEsp( pDevice, "Show rcsCrossHair (F7)", menuOffsetX, menuOffsetY + 7 * 12, extra::g_choices.rcsCrossHair ? enabled : disabled );
			DrawTextEsp( pDevice, "Show statusTextEntity(F8)", menuOffsetX, menuOffsetY + 8 * 12, extra::g_choices.statusTextEntity ? enabled : disabled );
			DrawTextEsp( pDevice, "Show velocityEsp(F9)", menuOffsetX, menuOffsetY + 9 * 12, extra::g_choices.velocityEsp ? enabled : disabled );
			DrawTextEsp( pDevice, "Hide Menu (INS)", menuOffsetX, menuOffsetY + 10 * 12, D3DCOLOR_ARGB(255,255,255,255 ));
		}



		if (extra::g_choices.rcsCrossHair)
		{
			//DrawLine( pDevice, src, dst,  width,  antialias, D3DCOLOR color );
			// all drawing stuff goes here
			// Drawing custom Crosshair for check

			Vector2 crossHair2d{};
			crossHair2d.m_x = g_windowSize.m_x / 2;
			crossHair2d.m_y = g_windowSize.m_y / 2;

			Vector2 l{};
			Vector2 r{};
			Vector2 t{};
			Vector2 b{};

			l = r = t = b = crossHair2d; // point to representing crosshair
			l.m_x -= 4;
			r.m_x += 4;
			b.m_y += 4;
			t.m_y -= 4;

			DrawLine( pDevice, l, r, 2, false, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
			DrawLine( pDevice, t, b, 2, false, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
			//Line3D( pDevice, l, r, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
			//Line3D( pDevice, t, b, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
		}

		//Drawing snapLines to various entities

		//EntityListInstance* entityListAddress = EntityListInstance::getEntityListInstancePtr();
		//LocalPlayer* localPLayerBaseAddress = LocalPlayer::getLocalPlayerPtr();
		//Vector2 entityPoshead2D{};
		//Vector3 entityPoshead3D{};
		//Vector2 entityBottomPos2D{};
		//Vector3 entityBottomPos3D{};

		for (int id{ 0 }; id < 900; ++id)
		{
			LocalPlayer* entity = EntityListInstance::getEntityListInstancePtr()->GetOtherEntity( id );
			if (extra::g_choices.statusTextTeam)
			{
				if (id == 2 || id == 3 || id == 4)
				{
					Vector3 entityLeg3D = entity->vecOrigin;
					Vector2 entityLeg2D{};
					if (W2S( entityLeg3D, entityLeg2D ))
					{
						std::stringstream str1{};
						std::stringstream str2{};
						str1 << entity->health; //! setting stringstream buffer object using insertion(<<) operator
						std::string t1 = "Hp: " + str1.str(); // using .str() function to retrieve the results of stringstream buffer and appending to existing string object
						//!calling get_entity name vtable function for any entity to read name.
						std::string charName2string{ LocalPlayer::getLocalPlayerPtr()->get_entity_name( entity ) }; // creating/converting the returned char* back to string for further opeartion with sstream class
						str2 << charName2string;
						std::string t2 = " Name: " + str2.str();
						char* healthValue = (char*) t1.c_str();
						char* nameType = (char*) t2.c_str();

						DrawTextEsp( pDevice, nameType, entityLeg2D.m_x, entityLeg2D.m_y, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
						DrawTextEsp( pDevice, healthValue, entityLeg2D.m_x, entityLeg2D.m_y + 12, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
					}
				}
			}

			if ((!entity) || (id == 0) || (id == 1) || (entity->iTeamNum != 3) || (entity->isDormant))
				continue;

			Vector3 entityPoshead3D = entity->vecOrigin + entity->m_vecViewOffset;


			if (entityPoshead3D.m_x != 0.0 && entityPoshead3D.m_y != 0.0f && entityPoshead3D.m_z != 0.0f)

			{

				Vector2 dest{ g_windowSize.m_x / 2, g_windowSize.m_y };

				Vector3 entityBottomPos3D = entity->vecOrigin;
				Vector2 entityPoshead2D{};
				if (LocalPlayer::getLocalPlayerPtr()->worldToScreen( entityPoshead3D, entityPoshead2D ))
				{
					//? Line3D( pDevice, entityPoshead2D.m_x, entityPoshead2D.m_y, 1.0f, dest.m_x, dest.m_y, 1.0f, D3DCOLOR_ARGB( 255, 255, 0, 0 ) ); // if use z as 0.0f model become black(not working well)
					

					if (extra::g_choices.snapLines)
					{
						DrawLine( pDevice, entityPoshead2D, dest, 2, false, D3DCOLOR_ARGB( 255, 255, 0, 0 ) );
					}
					Vector2 entityBottomPos2D{};
					if (LocalPlayer::getLocalPlayerPtr()->worldToScreen( entityBottomPos3D, entityBottomPos2D ))
					{

						//Drawing a velocity vector of entity
						if (extra::g_choices.velocityEsp)
						{
							Vector3 velocityVec3D = entityBottomPos3D + (entity->mVecVelocity)*0.25f;
							Vector2 velocityVec2D{};
							if (W2S( velocityVec3D, velocityVec2D ))
							{
								DrawLine( pDevice, entityBottomPos2D, velocityVec2D, 2, false, D3DCOLOR_ARGB( 255, 255, 0, 0 ));
								
								//todoDrawFillRect(pDevice, velocityVec2D.m_x-2, velocityVec2D.m_y-2,)
							}
						}




						//If world2screen valid for entity bottom position or vecOrigin draw 2d and 3d esp boxes
						if (extra::g_choices.box2D)
						{
							DrawEspBox2D( pDevice, entityBottomPos2D, entityPoshead2D, 2, false, D3DCOLOR_ARGB( 255, 255, 0, 0 ) );
							//DrawEspBox2D( pDevice, entityBottomPos2D, entityPoshead2D, D3DCOLOR_ARGB( 255, 255, 0, 0 ) );
						}

						//DrwaEspBox3d placed here as w2s shold br true for entityBottomPos3D
						if (extra::g_choices.box3D)
						{
							DrawEspBox3D( pDevice, entityPoshead3D, entityBottomPos3D, entity->viewAngles, 25, 2, D3DCOLOR_ARGB( 255, 255, 0, 0 ) );


						}
						if (extra::g_choices.headLineEsp)
						{
							Vector3 entityAngles{ entity->viewAngles };
							Vector3 endPoint3D{ entity->TransFormVector        ( entityPoshead3D,entityAngles,60 ) };// 60 is distance to which velocity vector has to be drwan
							Vector2 endPoint2D{};
							 W2S( entityPoshead3D, entityPoshead2D );
							if (W2S( endPoint3D, endPoint2D ))
							{
								DrawLine( pDevice, entityPoshead2D, endPoint2D, 2, false, D3DCOLOR_ARGB( 255, 255, 0, 0 ) );
							}
						}
						if (extra::g_choices.statusTextEntity)
						{

							std::stringstream str1{};
							std::stringstream str2{};

							//! setting stringstream buffer object using insertion(<<) operator
							str1 << entity->infected_name_index; 

							//!using .str() function to retrieve the results of stringstream buffer and appending to existing string object
							std::string t1 = "Index: " + str1.str(); 

							//!calling get_entity name vtable function for any entity to read name.
							//!  creating/converting the returned char* back to string for further opeartion with sstream class
							std::string charName2string{ LocalPlayer::getLocalPlayerPtr()->get_entity_name( entity ) }; 

							//! setting stringstream buffer object using insertion(<<) operator
							str2 << charName2string;
							std::string t2 = " Name: " + str2.str();

						//!Converting the string object back to C-style char string using c_str()
						//! before using in DrawTextEsp function to draw 
							char* someValue = (char*) t1.c_str();
							char* nameType = (char*) t2.c_str();

							DrawTextEsp( pDevice, nameType, entityBottomPos2D.m_x, entityBottomPos2D.m_y, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );
							DrawTextEsp( pDevice, someValue, entityBottomPos2D.m_x, entityBottomPos2D.m_y + 12, D3DCOLOR_ARGB( 255, 255, 255, 255 ) );

						}


					}

				}
			}

		}
		return dxstfInstance()->EndScenePtr( pDevice );
	}

	void* FindEndScene()
	
	{
		//get HWND of Game window
		HWND gameWindow = FindWindowA( NULL, "Left 4 Dead 2 - Direct3D 9" );
		if (!gameWindow)
		{
			std::cout << "Game window HWND find failed. Error: " << GetLastError() << '\n';
		}
		//index for endscene func in VTABLe
		constexpr int endsceneIndex{ 42 };
		//index for Present function in Vtable. same for all D3D9.dll
		constexpr int presentIndex{ 17 };
		// function to create a pointer to IDirect3D9 interface 
		//methods of IDirect3D9 interface is used to create MS Direct3d objects and set-up environ
		//This interface includes method for enumerating and retrieving capabilities of device
		//IDirect3D9 interface allows creation of IDirect3DDevice9 objects
		IDirect3D9* pD3D{ nullptr };
		pD3D = { Direct3DCreate9( D3D_SDK_VERSION ) };

		if (!pD3D)
		{
			std::cout << " IDirect3d9 interface pointer not returned.\n";

		}
		/*else
			std::cout << " IDirect3D9* pD3D-->\t" << std::hex << pD3D << '\n';*/

		if (pD3D)
		{
			//Now initialize value for D3DPRESENT_PARAMETRS structure that is used to create Direct3D device
			D3DPRESENT_PARAMETERS d3dpp{};
			d3dpp.BackBufferFormat = D3DFMT_R5G6B5;
			d3dpp.BackBufferCount = 1;
			d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
			d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
			d3dpp.hDeviceWindow = gameWindow;
			d3dpp.Windowed = TRUE;
			d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
			d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

			//now use IDirect3D9* interface with createdevice() function
			//this will return address of IDirect3Device9* interface in form of pDevice pointer
			//Various implementation methods can be used from IDirect3DDevice9* interface
			//returns fully working device interface, set to the required display mode
			// and allocated with appropriate back-buffers
			IDirect3DDevice9* pDevice{};
			pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, gameWindow, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &pDevice );
			if (pDevice)
			{
				// These two lines get the address of vTable functions present in IDirect3DDevice9 interface
				// first read value of VTable from class pointer pDevice (interface class pointer)
			   // Then add the desired index to read the desired function pointer
				// Then read the value of function address from that found in step(3)
				// cast it to void*
				void* presentAddress = (void*) *(std::intptr_t*) (*(std::intptr_t*) pDevice + presentIndex * sizeof( std::intptr_t ));
				void* endSceneAddress = (void*) *(std::intptr_t*) (*(std::intptr_t*) pDevice + endsceneIndex * sizeof( std::intptr_t ));

				std::cout << " IDirect3DDevice9* pDevice --->\t" << std::hex << pDevice << '\n';
				std::cout << " Present() addrs --->\t" << std::hex << presentAddress << '\n';
				std::cout << " EndScene() addrs --->\t" << std::hex << endSceneAddress << '\n';

				//pDevice->Release(); // release the IDirect3DDevice9* interface pDevice created to prevent memory leaks
				return endSceneAddress;

			}
			//pD3D->Release(); // release the IDirect3D9* interface object pD3D created to prevent memory leaks
		}
		return nullptr;
	}

	void getEndSceneHooked()
	{
		HWND gameWindow = FindWindowA( NULL, "Left 4 Dead 2 - Direct3D 9" );
		if (!gameWindow)
		{
			std::cout << "Game window HWND find failed. Error: " << GetLastError() << '\n';
		}
		else
		{
			//If game-window is found we will find the EndScene address
			//getWindowSize( gameWindow );

			//type-cast it to a EndScene func pointer type-alias to EndScenePtr variable
			EndScenePtr = (aliasEndScene) FindEndScene();

		}
		//This will assign the real-endscene function address to EndSceneptr functionptr variable
		//Now we will use the EndSceneptr holding value of real endscene function 
		// to create a Trampoline-Hook to our hookEndScene

		//src original EndScene function address saved here in a member variable
		lpOriginalFuncAddress = (ptrdiff_t) EndScenePtr;
		ptrdiff_t lpFinalHookaddrs = (ptrdiff_t) &DirectXStuff::hookEndScene;
		//7 is the length of stolen bytes
		if (EndScenePtr) //NULL-POINTER CHECK TO AVOID HOOK TO NULLPTR
			EndScenePtr = (aliasEndScene) g_HnP.trampHook<7>( (char*) lpOriginalFuncAddress, (char*) lpFinalHookaddrs );
	}

};
// Make a separate global variable at last to deal with transfer of value to player.h
//Cannot inlude "dxstuff.h" in "player.h" as it will lead to cyclic redundancy includes
//So a global variable defined here to transfer window-size value
//In "Player.h" extern declaration given 
Vector2 g_windowSize{ DirectXStuff::dxstfInstance()->getWindowSize() };

//inline Vector2 g_windowSize{ DirectXStuff::dxstfInstance()->getWindowSize() };

//USage is in dllmain like call DirectXStuff::dxstfInstance()->getEndSceneHooked()
```