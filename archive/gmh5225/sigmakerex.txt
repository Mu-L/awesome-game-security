Project Path: arc_gmh5225_sigmakerex_s6257a17

Source Tree:

```txt
arc_gmh5225_sigmakerex_s6257a17
├── Byte frequency
│   ├── 32bit.txt
│   ├── 64bit.txt
│   ├── byte_frequency_tabulate.py
│   └── ida_get_byte_frequency.py
├── LICENSE.txt
├── Main.cpp
├── README.md
├── Search.cpp
├── Settings.h
├── SigMaker.h
├── SigMakerEx.sln
├── SigMakerEx.vcxproj
├── SigMakerEx.vcxproj.filters
├── SigMakerEx.vcxproj.user
├── Signature.cpp
├── StdAfx.h
├── Utility.cpp
├── Utility.h
├── WaitBoxEx
│   ├── WaitBoxEx.LiB
│   ├── WaitBoxEx.h
│   ├── WaitBoxEx.pdb
│   ├── WaitBoxEx64.LiB
│   ├── WaitBoxEx64.pdb
│   ├── WaitBoxExD.LiB
│   ├── WaitBoxExD.pdb
│   ├── WaitBoxExD64.LiB
│   ├── WaitBoxExD64.pdb
│   └── ida-waitboxex.url
└── images
    ├── main.png
    ├── minimal_func_example.png
    └── options.png

```

`Byte frequency/32bit.txt`:

```txt

Largest byte count: 4,278,311

Byte - Percent - Count
92: 0.475  20,325
A2: 0.483  20,675
AE: 0.499  21,336
AD: 0.501  21,440
9A: 0.525  22,466
B2: 0.567  24,243
D5: 0.569  24,359
A6: 0.571  24,449
67: 0.586  25,086
A9: 0.626  26,765
A7: 0.635  27,163
BB: 0.638  27,314
A5: 0.64  27,393
B3: 0.644  27,534
B1: 0.655  28,013
91: 0.661  28,263
93: 0.684  29,269
99: 0.685  29,327
B5: 0.691  29,546
27: 0.695  29,738
E7: 0.698  29,865
D7: 0.703  30,095
37: 0.719  30,776
63: 0.722  30,910
9B: 0.726  31,048
AA: 0.726  31,081
6D: 0.727  31,111
26: 0.73  31,236
8F: 0.731  31,264
AF: 0.731  31,286
6E: 0.736  31,468
69: 0.739  31,608
BA: 0.74  31,658
62: 0.754  32,242
6F: 0.755  32,315
97: 0.755  32,316
3A: 0.767  32,832
2D: 0.776  33,183
36: 0.789  33,774
DA: 0.792  33,897
E3: 0.794  33,973
22: 0.815  34,889
6B: 0.823  35,208
3E: 0.825  35,275
9F: 0.827  35,380
2E: 0.837  35,792
7B: 0.837  35,819
7A: 0.839  35,910
9D: 0.845  36,131
E6: 0.846  36,215
ED: 0.85  36,375
96: 0.856  36,616
BD: 0.859  36,770
2A: 0.862  36,894
65: 0.869  37,187
2F: 0.877  37,532
BF: 0.888  37,976
5A: 0.904  38,669
31: 0.922  39,443
71: 0.934  39,977
9E: 0.938  40,126
1B: 0.962  41,156
EF: 0.973  41,637
21: 0.977  41,815
1A: 0.991  42,408
35: 0.996  42,602
CD: 1.0  42,763
19: 1.01  43,337
17: 1.03  44,080
1E: 1.04  44,298
AB: 1.04  44,419
3D: 1.04  44,691
87: 1.05  44,951
82: 1.05  44,958
1D: 1.06  45,318
EA: 1.06  45,358
23: 1.06  45,525
D3: 1.08  46,241
BE: 1.08  46,296
79: 1.09  46,421
DE: 1.09  46,718
E2: 1.12  47,855
DF: 1.15  49,353
3F: 1.15  49,365
8E: 1.17  50,018
13: 1.19  51,009
25: 1.19  51,112
EE: 1.21  51,943
D6: 1.22  52,020
9C: 1.23  52,490
98: 1.23  52,572
1F: 1.23  52,628
E1: 1.24  53,155
BC: 1.26  53,987
B4: 1.26  53,988
AC: 1.27  54,151
32: 1.31  55,835
DD: 1.31  55,945
12: 1.32  56,399
16: 1.32  56,436
A0: 1.33  57,029
4B: 1.34  57,360
7F: 1.36  58,029
77: 1.36  58,106
C5: 1.36  58,143
FA: 1.41  60,231
D1: 1.42  60,745
6C: 1.44  61,593
76: 1.44  61,615
29: 1.44  61,619
B7: 1.44  61,632
F2: 1.45  62,181
60: 1.46  62,257
CA: 1.47  62,864
94: 1.5  64,258
A3: 1.51  64,695
F5: 1.53  65,573
61: 1.57  67,332
4F: 1.58  67,537
8C: 1.59  67,898
DB: 1.62  69,282
43: 1.64  70,303
FB: 1.65  70,491
86: 1.66  71,045
95: 1.68  71,715
CB: 1.68  71,731
A4: 1.7  72,641
CF: 1.7  72,704
70: 1.72  73,503
3C: 1.74  74,314
D4: 1.74  74,454
0E: 1.75  74,688
73: 1.77  75,665
34: 1.77  75,681
F7: 1.84  78,791
49: 1.87  80,040
DC: 1.89  80,797
39: 1.89  80,939
B0: 1.93  82,681
FD: 1.93  82,722
4A: 1.96  83,822
A8: 1.96  83,964
B9: 1.97  84,370
78: 1.98  84,725
2C: 1.99  85,010
72: 2.04  87,323
F9: 2.07  88,431
0B: 2.08  89,031
38: 2.1  89,690
A1: 2.1  89,995
0A: 2.14  91,468
2B: 2.15  91,911
E4: 2.22  94,965
F1: 2.28  97,371
8A: 2.29  97,866
15: 2.38  101,801
7C: 2.46  105,287
09: 2.47  105,508
D2: 2.49  106,572
81: 2.64  112,974
CE: 2.67  114,440
4E: 2.79  119,437
47: 2.8  119,785
7E: 2.84  121,331
B6: 2.85  121,888
5B: 2.97  126,861
5C: 2.98  127,562
58: 3.0  128,223
30: 3.04  129,885
07: 3.06  130,914
42: 3.18  135,905
88: 3.2  136,842
F6: 3.22  137,585
11: 3.29  140,552
59: 3.31  141,560
4C: 3.36  143,873
66: 3.38  144,548
E0: 3.42  146,354
0D: 3.48  148,690
20: 3.48  148,923
1C: 3.54  151,633
C9: 3.6  154,032
53: 3.61  154,285
54: 3.63  155,118
7D: 3.63  155,400
B8: 3.76  161,066
D0: 3.83  163,780
48: 3.86  165,315
5F: 3.88  165,786
06: 3.91  167,093
90: 3.96  169,354
84: 3.99  170,758
80: 4.06  173,708
D8: 4.06  173,880
41: 4.18  179,039
52: 4.21  180,055
E5: 4.27  182,475
05: 4.39  187,708
18: 4.57  195,498
57: 4.76  203,601
40: 4.77  203,986
FE: 4.78  204,384
F4: 4.78  204,510
28: 4.89  209,122
64: 4.98  213,210
F3: 5.24  224,115
C8: 5.26  224,953
44: 5.44  232,647
C6: 5.47  234,028
46: 5.51  235,856
3B: 5.6  239,587
F0: 5.66  242,290
EB: 5.87  251,141
03: 6.09  260,465
14: 6.14  262,656
33: 6.16  263,457
5E: 6.23  266,513
68: 6.29  268,982
C2: 7.06  302,003
F8: 7.19  307,625
6A: 7.23  309,334
56: 7.25  310,074
D9: 7.5  320,944
C1: 7.59  324,833
51: 7.89  337,415
02: 8.63  369,018
C3: 8.63  369,273
C4: 8.72  373,235
75: 9.63  411,852
E9: 10.5  448,747
C0: 10.8  461,664
5D: 11.2  477,353
85: 11.3  481,442
C7: 11.3  483,738
EC: 11.6  495,916
10: 12.1  516,535
74: 12.1  517,451
FC: 12.3  525,462
55: 13.0  556,974
0C: 13.1  560,789
50: 13.2  564,154
24: 16.7  714,384
4D: 17.0  727,035
8D: 18.7  798,872
83: 20.5  876,370
04: 20.7  887,105
89: 22.0  942,295
08: 22.2  951,362
45: 22.3  951,999
0F: 22.5  962,164
E8: 26.9  1,149,816
01: 27.4  1,173,520
FF: 55.1  2,359,115
CC: 73.3  3,137,643
8B: 76.3  3,265,159
00: 1e+02  4,278,311

```

`Byte frequency/64bit.txt`:

```txt

Largest byte count: 15,464,905

Byte - Percent - Count
A6: 0.386  59,704
9A: 0.391  60,501
A2: 0.392  60,641
9B: 0.4  61,903
AE: 0.425  65,747
A3: 0.427  66,033
6A: 0.429  66,326
B2: 0.44  68,077
96: 0.447  69,100
62: 0.449  69,423
9E: 0.456  70,592
A1: 0.457  70,708
AD: 0.467  72,262
A9: 0.472  72,924
61: 0.475  73,523
A5: 0.482  74,525
99: 0.492  76,142
92: 0.517  79,982
AB: 0.529  81,771
93: 0.551  85,212
E5: 0.553  85,574
3A: 0.556  85,935
71: 0.558  86,335
7A: 0.561  86,787
36: 0.562  86,902
A4: 0.567  87,680
B5: 0.57  88,161
91: 0.572  88,496
B3: 0.572  88,517
9D: 0.578  89,338
26: 0.586  90,693
31: 0.602  93,116
37: 0.613  94,819
EE: 0.614  94,918
DD: 0.617  95,407
B1: 0.618  95,499
69: 0.623  96,331
9F: 0.626  96,887
2D: 0.627  96,950
A7: 0.634  98,005
F5: 0.642  99,285
67: 0.659  101,891
AC: 0.659  101,955
3E: 0.671  103,845
6D: 0.673  104,041
2E: 0.681  105,253
DC: 0.683  105,582
21: 0.687  106,202
E6: 0.696  107,571
6E: 0.701  108,457
52: 0.706  109,257
BD: 0.708  109,503
22: 0.719  111,214
35: 0.722  111,717
1A: 0.726  112,317
5A: 0.732  113,250
BB: 0.735  113,721
F4: 0.743  114,976
8E: 0.744  114,988
DE: 0.751  116,196
97: 0.752  116,322
27: 0.76  117,536
1E: 0.765  118,255
2A: 0.766  118,475
E7: 0.77  119,042
D5: 0.789  121,960
BE: 0.799  123,512
AF: 0.805  124,438
82: 0.806  124,691
94: 0.807  124,763
BC: 0.808  124,912
16: 0.814  125,950
B4: 0.819  126,604
E2: 0.825  127,541
D4: 0.825  127,583
AA: 0.834  129,013
E4: 0.839  129,813
ED: 0.859  132,843
79: 0.861  133,184
32: 0.887  137,248
EA: 0.892  137,956
8A: 0.894  138,251
86: 0.896  138,613
EF: 0.92  142,266
76: 0.94  145,306
2F: 0.943  145,899
12: 0.949  146,799
2C: 0.955  147,738
E3: 0.956  147,824
51: 0.958  148,154
64: 0.962  148,803
19: 0.968  149,706
BF: 0.97  150,069
6B: 0.971  150,135
CD: 0.979  151,429
1D: 0.983  151,977
34: 0.994  153,664
65: 0.997  154,151
13: 1.01  155,535
8F: 1.03  158,833
25: 1.05  163,087
F1: 1.06  163,204
DF: 1.06  163,400
6F: 1.06  164,472
17: 1.08  166,548
23: 1.08  167,707
3F: 1.09  169,081
4A: 1.09  169,122
95: 1.1  169,913
DA: 1.13  175,141
3C: 1.14  176,332
1B: 1.14  177,047
E1: 1.15  178,015
9C: 1.16  179,263
3D: 1.16  179,827
77: 1.16  180,002
C5: 1.18  183,220
B7: 1.21  187,104
7E: 1.22  188,831
D6: 1.25  193,600
7B: 1.26  194,447
98: 1.28  197,804
87: 1.31  202,135
0E: 1.31  202,819
A8: 1.33  206,213
1C: 1.34  207,711
D9: 1.38  214,093
8C: 1.4  216,024
FB: 1.43  221,349
4E: 1.45  224,615
CA: 1.47  227,566
D1: 1.53  237,376
09: 1.54  238,845
73: 1.57  242,678
A0: 1.61  248,509
63: 1.64  252,873
D3: 1.65  254,586
DB: 1.66  255,963
F7: 1.67  258,714
7D: 1.68  259,437
4F: 1.68  260,087
D7: 1.71  265,130
FC: 1.74  269,210
72: 1.75  270,535
FA: 1.75  270,585
14: 1.77  273,109
0A: 1.79  276,904
F9: 1.8  277,813
53: 1.8  278,009
56: 1.81  280,002
F2: 1.83  283,093
29: 1.86  286,897
5E: 1.86  288,239
0B: 1.89  291,748
FD: 1.9  294,226
5B: 1.91  294,784
B6: 1.95  301,794
BA: 2.02  312,980
B9: 2.03  313,672
6C: 2.05  317,527
46: 2.1  324,404
42: 2.11  325,877
5D: 2.13  329,947
F6: 2.16  333,586
B0: 2.16  334,515
7F: 2.18  336,381
2B: 2.18  337,235
39: 2.21  341,618
CE: 2.24  346,847
68: 2.28  353,083
78: 2.31  356,665
D2: 2.35  363,279
CF: 2.5  386,567
7C: 2.51  388,546
C2: 2.57  397,005
1F: 2.65  409,822
47: 2.67  412,928
4B: 2.69  416,404
70: 2.7  418,264
E0: 2.71  418,841
07: 2.72  419,966
D8: 2.76  426,355
06: 2.83  438,131
0C: 2.85  441,108
59: 2.93  452,630
81: 2.96  457,481
54: 2.99  462,497
CB: 3.03  468,289
5F: 3.08  476,707
EC: 3.11  481,363
15: 3.13  484,301
B8: 3.14  486,170
88: 3.18  492,315
55: 3.22  497,856
60: 3.32  513,385
F0: 3.43  529,948
EB: 3.46  534,995
57: 3.58  553,922
D0: 3.61  557,810
E9: 3.79  586,091
FE: 3.82  590,153
0D: 3.99  617,323
C9: 4.08  631,687
C6: 4.12  637,097
11: 4.14  639,973
80: 4.24  655,556
58: 4.25  657,483
C4: 4.3  665,571
3B: 4.33  669,964
F8: 4.34  671,067
66: 4.5  696,228
18: 4.74  732,378
C8: 4.77  737,063
38: 4.91  758,774
90: 5.21  805,303
5C: 5.26  813,574
84: 5.33  823,839
33: 5.34  825,857
43: 5.64  872,960
C1: 6.08  940,658
75: 6.09  941,661
50: 6.28  970,445
C3: 6.46  999,274
4D: 6.47  1,000,960
30: 6.5  1,005,124
F3: 6.85  1,058,650
04: 7.08  1,095,163
C7: 7.55  1,167,534
02: 8.06  1,246,660
28: 8.17  1,264,030
05: 8.43  1,304,210
03: 8.54  1,320,763
40: 8.86  1,370,603
85: 9.73  1,504,206
45: 10.3  1,585,285
20: 10.6  1,632,210
C0: 10.7  1,661,628
74: 11.2  1,737,576
08: 11.8  1,821,748
10: 13.0  2,003,234
44: 13.4  2,069,068
49: 13.8  2,127,233
83: 14.3  2,205,932
41: 15.8  2,443,053
E8: 17.1  2,643,922
01: 18.5  2,855,602
4C: 18.8  2,910,679
FF: 24.2  3,750,053
8D: 24.8  3,842,065
89: 26.3  4,074,751
24: 27.4  4,230,122
0F: 32.6  5,042,621
CC: 34.5  5,336,078
8B: 56.7  8,767,032
00: 93.7  14,489,657
48: 1e+02  15,464,905

```

`Byte frequency/byte_frequency_tabulate.py`:

```py

"""
Tabulate JSON byte frequency files previously generated using 'ida_get_byte_frequency.py' within IDA Pro

Args:
    One or more .json input files.
"""
import sys
import json
from pprint import pprint

assert len(sys.argv) >= 2, "Expected at least one byte frequency .json file input"

# Combine the byte frequency dictionaries into one
tabulated = {}
for i in range(1, len(sys.argv)):
    path = sys.argv[i]
    print(f'Appending: {path}')
    with open(path) as fp:
        tmp = json.load(fp)
        #pprint(tmp)
        for byte, count in tmp.items():
            tabulated[byte] = tabulated.get(byte, 0) + count
#pprint(tabulated)

# Convert dictionary to a sorted list gathering the max count in the process: [byte, count]
largest = 0
byte_list = []
for byte, count in tabulated.items():
    byte_list.append([int(byte), count])
    if count > largest:
        largest = count
print(f'\nLargest byte count: {largest:,}')
byte_list = sorted(byte_list, key=lambda e: e[1])
#pprint(byte_list)

# Dump the values
print('Byte - Percent - Count')
for e in byte_list:
    print(f'{e[0]:02X}: {((e[1] / largest) * 100.0):0.4}  {e[1]:,}')


# Show byte frequency bar graph
"""
import matplotlib.pyplot as plt

byte_list = sorted(byte_list, key=lambda e: e[0])
#x = [x[0] for x in byte_list]
x = [f'{x[0]:02X}' for x in byte_list]
y = [x[1] / largest for x in byte_list]

fig, axs = plt.subplots(1, 1, figsize=(34, 13), tight_layout=True)
axs.bar(x, y)

plt.title('Code byte frequency', fontsize=20)
plt.xlabel('Code Byte', fontsize=18)
plt.ylabel('Count Ratio', fontsize=18)
plt.grid(axis='y', alpha=0.5)
plt.xticks(fontsize=6.5)
plt.xlim(axs.patches[0].get_x()-1, axs.patches[-1].get_x()+1)
#plt.savefig('byte_frequency.png')
plt.show()
"""
```

`Byte frequency/ida_get_byte_frequency.py`:

```py

"""
IDA Pro script to gather byte frequency table for code sections in the loaded IDB
saving the data to a JSON file.
"""
import json
import ctypes
from pprint import pprint
from idaapi import *
import ida_kernwin as kernwin

# Import: void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlag = AllEvents)
# https://doc.qt.io/qt-5/qcoreapplication.html#processEvents
processEventsPtr = None
if kernwin.is_idaq():
    # If IDA Windows
    if os.name == 'nt':
        qtcore = ctypes.CDLL('Qt5Core')
        if qtcore:
            processEventsPtr = qtcore['?processEvents@QCoreApplication@QT@@SAXV?$QFlags@W4ProcessEventsFlag@QEventLoop@QT@@@2@@Z']

# Call QT processEvents() to trigger the IDA output window to update immediately
def refresh():
    if processEventsPtr:
        processEventsPtr(ctypes.c_uint(0))


# Ask user for save file name
save_path = ask_file(True, "*.json", "Script: Select the byte frequency JSON save file:")
if save_path:
    frequency = {}

    # Walk all code segments..
    for n in range(get_segm_qty()):
        seg = getnseg(n)
        if seg.type == SEG_CODE:
            print(f'Script: Walking: "{get_segm_name(seg)}" {seg.start_ea:014X} - {seg.end_ea:014X}')
            refresh()

            # Add all code bytes..
            ea = seg.start_ea
            while ea < seg.end_ea:
                # For bytes that don't exist in the IDB for a given address this get_db_byte() return 0xFF
                byte = get_db_byte(ea)
                frequency[byte] = frequency.get(byte, 0) + 1
                ea += 1

    #pprint(frequency)

    # Save the byte frequency table
    print(f'Script: Saving to "{save_path}"..')
    refresh()
    with open(save_path, "w") as fp:
        json.dump(frequency, fp, indent=2)
    print("Script: Done.")
else:
    print("Script: Aborted.")
refresh()

```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) 2022 Kevin Weatherman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Main.cpp`:

```cpp

// Plugin main
#include "SigMaker.h"

// UI "actions"
enum SIG_ACTION
{
	CREATE_FUNCTION_SIG,
	CREATE_ADDRESS_SIG,
	CREATE_RANGE_SIG
};

// Global settings instance
SETTINGS settings;

static void idaapi OnRepoLink(int button_code, form_actions_t& fa) { open_url("https://github.com/kweatherman/sigmakerex"); }
static void idaapi OnOptionButton(int button_code, form_actions_t& fa)
{
    try
    {
        const char optionsDialog[] =
        {
		    "SigMakerEx Options\n\n"

		    // Output format dropdown
		    "<#Signature output style.#Output format:b:0:100:>\n"
            // Mask byte for the inline wildcard style
            "<#Mask/wildcard byte for the \"inline\" BYTE output format.#Mask byte (0xAE default):N:0:4:>\n"

		    // Function criteria dropdown
		    "<#Function signature generation criteria option.#Function sigs:b:0:100:>\n"

		    // Output level dropdown
            "<#IDA output message level.#Message level:b:0:100:>\n"

            "<#Maximum function refs to scan when a function is not unique.#Max function scan refs (0 for unlimited):D:0:4:>\n"
            "<#Maximum function entry point signature bytes. When this limit is hit, will attempt to find a cross-ref signature instead.#Max function entry point signature bytes (0 for unlimited):D:0:4:>\n"
            " \n"
        };

        settings.Validate();

	    qstrvec_t outputFormatArray;
        outputFormatArray.push_back("IDA (Default)");
        outputFormatArray.push_back("Code style");
        outputFormatArray.push_back("Inline byte");

	    qstrvec_t funcCriteriaArray;
        funcCriteriaArray.push_back("Entry Point (Default)");
        funcCriteriaArray.push_back("Minimal byte size");
        funcCriteriaArray.push_back("Full function body");

	    qstrvec_t outputLevelArray;
	    outputLevelArray.push_back("Terse (Default)");
	    outputLevelArray.push_back("Verbose");

        UINT64 maxRefCount64 = (UINT64) settings.maxScanRefCount;
        UINT64 maxEntryPointBytes64 = (UINT64) settings.maxEntryPointBytes;
        ea_t maskByteEa = (ea_t) settings.maskByte;

	    int result = ask_form(optionsDialog, &outputFormatArray,&settings.outputFormat, &maskByteEa, &funcCriteriaArray,&settings.funcCriteria, &outputLevelArray,&settings.outputLevel, &maxRefCount64, &maxEntryPointBytes64);
	    if (result > 0)
	    {
            settings.maxScanRefCount = (UINT32) min(maxRefCount64, UINT_MAX);
            settings.maxEntryPointBytes = (UINT32) min(maxEntryPointBytes64, UINT_MAX);
            settings.maskByte = (BYTE) min(maskByteEa, 0xFF);
		    settings.Save();
	    }
    }
	catch (std::exception &ex)
	{
		msg(MSG_TAG "** C++ exception: OnOptionButton(): \"%s\" ***\n", ex.what());
	}
	catch (...)
	{
		msg(MSG_TAG "** Gerneral C exception: OnOptionButton() ***\n");
	}
}

static bool idaapi run(size_t arg)
{
    // To facilitate passing action options via "plugins.cfg" hotkeys
    WORD action = (WORD) arg;
    try
    {
        if (action == 0)
        {
            const char mainDialog[] =
            {                
                "STARTITEM 1\n"
                "BUTTON YES* Continue\n"

                // ---------------- Help ----------------
                "HELP\n"
                "SigMakerEx Plugin:\n"
                "IDA Pro signature creation tool.\n"
                "Copyright\xC2\xA9 2022 Kevin Weatherman. Released under the MIT License.\n"

                "\n"
                "Create signature operations:\n"
                "1. \"Function\": Used to create a unique function entry point, a minimal function signature w/offset, or a whole-body signature depending on the \"Options\" config (see below).\n"
                "First select any address inside the target function.\n"
                "If the selected function is not unique (for the entry point, or the minimal option) then a signature for a unique function cross reference scan will be attempted.\n"
                "Typical use cases: Signatures to locate functions at run time in target memory, to locate functions in IDA after executable updates, or to help locate known libraries by signature, etc.\n\n"

                "2) \"At address\": Attempts to find a unique signature at the selected address.\n"
                "Typical use case: For locating a particular offset at runtime to hook, or making Cheat Engine script signatures for this purpose, etc.\n\n"

                "3. \"From address range\": Generates a signature from the selected address range, not checking for uniqueness.\n"
                "Special use case for when one of the other actions won't work.\n\n"

                "Signature results are pushed to the Windows clipboard for easy CTRL+V pasting into source code, etc.\n"

                "\n"
                "Options: (via the \"Options\" button)\n"
                "Output format:\n"
                "\"IDA\": The default hex binary search format that IDA and some other tools support, using spaced hex bytes and \"??\" wildcards.\n"
                "Example: \"C1 6C E8 ?? ?? ?? ?? 8B 50 08\"\n"
                "\"Code style\": Escape coded hex string and a separate mask string where 'x' are keeper bytes, and '?' are wildcard bytes.\n"
                "Example: \"\\xC1\\x6C\\xE8\\xCC\\xCC\\xCC\\xCC\\x8B\\x50\\x08\", \"xxx????xxx\"\n"
                "\"Inline byte\": A minimalist C style array of bytes with wildcard bytes included format.\n"
                "Example: \"{0xC1,0x6C,0xE8,0xAE,0xAE,0xAE,0xAE,0x8B,0x50,0x08};\"\n"
                "Use the \"mask byte\" edit box to change the default \"Inline byte\" mask byte.\n\n"

                "Function sigs:\n"
                "The criteria for \"Function\" signature generation.\n"
                "\"Entry point\": Will attempt to generate a minimal byte sized function entry point signature when possible.\n"
                "\"Minimal byte size\": Will attempt to generate a minimal, with least wildcards count, byte sized (five are greater) instruction boundary aligned signature inside of the selected function body.\n"
                "\"Full function body\": Will attempt to generate a unique full function body signature.\n\n"

                "For any of these three options, if the function is not unique, an attempt will be made to locate the smallest unique cross reference signature instead.\n"
                "If you wish to make a full or partial function signature for a non-unique function then use the \"From address range\" option instead.\n\n"

                "\"Message level\": Set to \"Verbose\" for internal signature generation message output to the IDA log window.\n\n"

                "\"Max function scan refs\": Limit how many function cross references to search when a direct \"Function\" action signature can't be found.\n"
                "Normally this should be '0' for unlimited search, but for problem cases where there are so many references that causes a slowdown, this can be set to some reasonable limit like 16 or 100.\n\n"

				"\"Max function entry point signature bytes\": When using the \"Function\" option, and the \"Entry point\" criteria is configured, optionally limit the maximum entry point signature byte size. The default is '0', for unlimited (which can be up to the entire selected function body byte size).\n"
                "If this limit is exceeded, an xref signature will be looked for instead.\n\n"
				
                "For the relatively rare case of functions that have their chunks spread over multiple address ranges, the tool will attempt to use just the first chunk.\n"
                "If wishing to make a signature in one of the disjointed chunks, try using the \"At address\" method. If all else fails, try a \"From address range\" sig (might take some manual searching for uniqueness).\n"

                "\n"
               "Credits:\n"
                "Thanks to the creator of the original SigMaker tool back from the gamedeception.net days up to the current C/C++ and Python iteration authors.\n"
                "P4TR!CK, bobbysing, xero|hawk, ajkhoury, and zoomgod et al.\n"
                "Thanks to Wojciech Mula for his SIMD programming resources.\n\n"

                "See the SigMakerEx READ.ME for more help and details.\n"
                "ENDHELP\n"
                // --------------------------------------

                // Dialog title
                "SigMakerEx\n\n"

                // Message text
                "SigMakerEx %q \t\n"

                "<#Click to open SigMakerEx repo page.#SigmakerEx Github:k::>\n\n"

                "Create signature:\n"
                "<#Attempt to create a unique function signature for selected address at or inside the function.#Function:R>\n"
                "<#Attempt to create a unique signature at selected address.#At address:R>\n"
                "<#Create a raw signiture for selected adress range, unique or not.#From address range           \t:R>>\n\n"

                "<#Options:B::>\n"
                " \n"
            };

            static WORD lastAction = CREATE_FUNCTION_SIG;
            qstring version, tmp;
            version.sprnt("v%s, built %s.", GetVersionString(MY_VERSION, tmp).c_str(), __DATE__);

            int result = ask_form(mainDialog, &version, OnRepoLink, &lastAction, OnOptionButton);
            if (result <= 0)
                return true;
            else
                action = lastAction;
        }
        else
            action -= 1;

        switch ((SIG_ACTION)action)
        {
            // Attempt to create an ideal function signature
            case CREATE_FUNCTION_SIG:
            CreateFunctionSig();
            break;

            // Attempt to create a signature for a selected address
            case CREATE_ADDRESS_SIG:
            CreateAddressSig();
            break;

            // Create a raw signature for a selected address range, unique or not
            case CREATE_RANGE_SIG:
            CreateAddressRangeSig();
            break;
        };
    }
	catch (std::exception &ex)
	{
		msg(MSG_TAG "** C++ exception: run(): \"%s\" ***\n", ex.what());
	}
	catch (...)
	{
		// Note: Need to set the /EHa to catch SEH exceptions too
		msg(MSG_TAG "** Gerneral C exception: run() ***\n");
	}
    return true;
}

static plugmod_t* idaapi init()
{
    settings.Load();
    return PLUGIN_OK;
}

void idaapi term()
{
    SearchCleanup();
}

__declspec(dllexport) plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    PLUGIN_PROC,
    init,
    term,
    run,
    "Signature creation tool.",
    "SigMakerEx plugin",
    "SigMakerEx",
    "Ctrl-Alt-S"
};

```

`README.md`:

```md
## SigMakerEx

Enhanced IDA Pro signature generator plugin.

### Installation

Copy `IDA_SigMaker32.dLL` and `IDA_SigMaker64.dLL` to your IDA `plugins` directory.

The default IDA hot key is "Ctrl-Alt-S", but can be set to another using key your IDA "plugins.cfg".
Since "Ctrl-Alt-S" now combo conflicts with an IDA default, to avoid getting warning messages, edit your "idagui.cfg" and make the "StackTrace" entry like: `"StackTrace" = 0 // "Ctrl-Alt-S" // open stack trace window` (the '0' disables the key). 

Requires IDA Pro version 7.6'ish.

### Using
Invoke the plugin via its hotkey or via the IDA Edit/Plugin menu.

![main](/images/main.png)

There are three signature generation operations:
 1. **Function**: Used to create a unique function entry point, a minimal function signature w/offset, or a whole-body signature depending on the *Options* config (see below).

    First select any address inside the target function.
    If the selected function is not unique (for the entry point, or the minimal option) then a signature for a unique function cross-reference scan will be attempted.

    Typical use cases: Signatures to locate functions at run time in target memory, to locate functions in IDA after executable updates, or to help locate known libraries by signature, etc.


2) **At address**: Attempts to find a unique signature at the selected address.
Typical use case: For locating a particular offset at runtime to hook, or making [Cheat Engine](https://www.cheatengine.org/) script signatures for this purpose, etc.

3. **From address range**: Generates a signature from the selected address range, not checking for uniqueness.
    Special use case for when one of the other actions won't work. Like wanting to ignore the uniqueness of a signature, etc.  

Example signature output:
![minimal_func_example](/images/minimal_func_example.png)

Signature results are pushed to the Windows clipboard for easy CTRL+V pasting into source code, etc.

##### Options

![options](/images/options.png)

**Output format:**
**IDA**: The default hex binary search format that IDA and some other tools support, using spaced hex bytes and "??" wildcards.
Example: `C1 6C E8 ?? ?? ?? ?? 8B 50 08`
**Code style**: Escape coded hex string and a separate mask string where 'x' are keeper bytes, and '?' are wildcard bytes.
Example: `"\xC1\x6C\xE8\xCC\xCC\xCC\xCC\x8B\x50\x08", "xxx????xxx"`
**Inline byte**: A minimalist C style array of bytes with wildcard bytes included format.
Example: `{0xC1,0x6C,0xE8,0xAE,0xAE,0xAE,0xAE,0x8B,0x50,0x08};`
Use the "mask byte" edit box to change the default "Inline byte" mask byte.
The default mask byte is `0xAE`, one of the least used code bytes (see "Ideal mask byte" below).

##### Function sigs: 

The criteria for "Function" signature generation.
**Entry point**: Will attempt to generate a minimal byte sized function entry point signature when possible.
**Minimal byte size**: Will attempt to generate a minimal, with least wildcards count, byte sized (five are greater) instruction boundary aligned signature inside of the selected function body.
**Full function body**: Will attempt to generate a unique full function body signature.

For any of these three options, if the function is not unique, an attempt will be made to locate the smallest unique cross-reference signature instead. If you wish to make a full or partial function signature for a non-unique function then use the "From address range" option instead.

**Message level**: Set to "Verbose" for internal signature generation message output to the IDA log window.

**Max function scan refs**: Limit how many function cross-references to search when a direct "Function" action signature can't be found. Normally this should be '0' for unlimited search, but for problem cases where there are so many references that it causes a slowdown, this can be set to some reasonable limit like 16 or 100 to increase the scanning speed.

For the relatively rare case of functions that have their chunks spread over multiple address ranges, the tool will attempt to use just the first chunk. If wishing to make a signature in one of the disjointed chunks, try using the "At address" method. If all else fails, try a "From address range" sig (which might take some manual searching for uniqueness).

**Max function entry point signature bytes**: When using the "Function" option, and the "Entry point" criteria is configured, optionally limit the maximum entry point signature byte size. The default is '0', for unlimited (which can be up to the entire selected function body byte size) .
If this limit is exceeded, a cross-reference signature will be looked for instead.

Set to a practical limit like '16' or '32', for preferred typically smaller xref signatures vs potentially very large entry point signatures.

### Original SigMaker vs SigMakerEx 

1) SigMakerEx ("EX") overall generates smaller and tighter function signatures by using better instruction analysis.
   Example: SigMaker ("SM") wildcards the operand bytes of instruction `sub esp, 90h` (as `"81 EC ?? ?? ?? ??`), throwing out the last four bytes unnecessarily. While EX sees it as an immediate value and keeps the whole `81 EC 90 00 00 00` byte sequence.
2) EX is better focused on normative function body signature use cases.
   For SM there is only one controllable option. It will attempt to make a unique signature at wherever address you select in the function. If it can't find one there, it will look for a unique cross-reference sig instead only.
   For EX, since the identified typical use case is to locate function entry points, the smallest entry point signature will be generated when the "Entry point" criteria option is configured.
   For when the "Minimal byte size" option is selected, it will look for the smallest and least wildcard count unique signature (of minimum five bytes) within the whole function body.
3) SM has more output criteria control over byte vs wildcard count, etc., in it's options dialog. EX assumes you want the best of both (least wildcards and smallest byte size).
4) EX omits the "conversion" and the individual "search" functionality that SM has over a preference for a simpler and less cluttered UI.
   
   For searching, since EX always emits IDA format output in addition to the selected output format signatures, use the IDA binary search "Hex" option with the IDA sig string.
4) EX is generally faster, when even doing more extensive searches, due to a technique of cloning the IDB into RAM and using an AVX2 optimized pattern scanner vs relying on the slow IDA find function for scanning.                                                                                                                                                                                                             

### Ideal mask byte

In my own projects for finding patterns dynamically, I prefer the "Inline byte" (for lack of a better name) format.
It's the simplest, most compact, and it doesn't require a runtime transformation from an ASCII hex string.
I've used this format for many projects and have yet to run into any signature collision or redundant match problems.

To minimize potential redundancy issues, it's prudent to use one of the least used code byte values for the wildcard/mask byte. To find the ideal candidates, I gathered the code byte frequency from three each large 32bit and 64bit code segments, then tabulated and sorted the results. The "ida_get_byte_frequency.py" IDA script is used the gather a byte frequency dictionary and save it to a JSON DB. The "byte_frequency_tabulate.py" script tabulates and sorts in ascending order a set of these saved JSON DBs.
It's apparent the byte frequency for 32bit isn't the same as the 64bit one and tabulated independently. See "32bit.txt" and "64bit.txt".
In a visual correlation of the two, 0xA2 is actually the least common denominator, then followed by 0xAE. 
0xAE was chosen over 0xA2 as the default mask byte since its subjectively easier to pick out in hex visually.

### Building

Built using Visual Studio 2019, on Windows 10, with the only dependency being the official IDA Pro C/C++ SDK.
Setup in the project file, it looks for an environment variable `_IDADIR` from which it expects to find a "idasdk/include" and a "idasdk/lib" folder where the IDA SDK is located. Not using `IDADIR` since IDA looks for it itself and can cause a conflict if you try to use more than one installed IDA version.

Python 3.7'ish or better to run the "byte_frequency_tabulate.py" script.

### Credits

Thanks to the creator of the original SigMaker tool back from the gamedeception.net days up to the current C/C++ and Python iteration authors:  P4TR!CK, bobbysing, xero|hawk, ajkhoury, and zoomgod et al.
Thanks to Wojciech Mula for his SIMD programming resources.

### License

Released under MIT © 2022 By Kevin Weatherman
```

`Search.cpp`:

```cpp

// Search for binary signature pattern support
#include "SigMaker.h"

// Local search data container
struct SearchData
{
	// Clone IDB byte database to RAM for fast pattern scanning
	PBYTE buffer;
	size_t size;

	BOOL CloneIdb()
	{
		if (!buffer)
		{
			LOG_VERBOSE(__FUNCTION__ ": min_ea: 0x%llX, max_ea: 0x%llX, size: 0x%llX\n\n", (UINT64) inf.omin_ea, (UINT64) inf.omax_ea, (UINT64) (inf.omax_ea - inf.omin_ea));

			// Allocate page buffer to encompass the whole the IDB region
			size = (UINT64) (inf.omax_ea - inf.omin_ea);
			buffer = (PBYTE) VirtualAlloc(NULL, size + 32, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
			if (buffer)
			{
				// Copy the IDB bytes to the buffer
				// Simple loop much faster than: get_qword(), get_bytes(), etc.
				// Note: For bytes that don't exist in the PE file, get_db_byte() will return 0xFF.
				ea_t  currentEa = inf.omin_ea;
				PBYTE ptr = buffer;
				size_t count = size;

				do
				{
					*ptr = (BYTE) get_db_byte(currentEa);
					++currentEa, ++ptr, --count;

				} while (count);
			}
			else
				msg(MSG_TAG "** Failed to allocate the clone RAM buffer of size: 0x%llX ! **\n", size);
		}

		return buffer != NULL;
	}

	void Cleanup()
	{
		if (buffer)
		{
			VirtualFree(buffer, 0, MEM_RELEASE);
			buffer = NULL;
		}
	}

	// Most post 2013 Intel and 2015 AMD CPUs have "Advanced Vector Extensions 2" (AVX2) support
	// 2022 86.65% https://store.steampowered.com/hwsurvey/
	// https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#CPUs_with_AVX2
	BOOL TestAVX2Support()
	{
		enum { EAX, EBX, ECX, EDX };
		int regs[4];

		// Highest Function Parameter
		__cpuid(regs, 0);
		if (regs[EAX] >= 7)
		{
			// Extended Features
			__cpuid(regs, 7);
			return (regs[EBX] & /*AVX2*/ (1 << 5)) != 0;
		}
		return FALSE;
	}

	BOOL hasAVX2;
	SearchData() : buffer(NULL), size(0)
	{
		hasAVX2 = TestAVX2Support();
	}
	~SearchData()
	{
		Cleanup();
	}

} static searchData;

void SearchCleanup()
{
	searchData.Cleanup();
}

//-------------------------------------------------------------------------------------------------
/*
AVX2 pattern scanner based on Wojciech Mula's avx2_strstr_anysize()
  http://0x80.pl/articles/simd-strfind.html#generic-sse-avx2

Rules:
1) Expects input data to be at least align 32
2) SIG must be at least 3 byte in length
3) SIG must be trimmed (the first and last of the pattern can't be a wildcard/mask)
*/

static inline UINT32 get_first_bit_set(UINT32 x)
{
	// Generates a single BSF instruction
	unsigned long ret;
	_BitScanForward(&ret, x);
	return (UINT32) ret;
}

static inline UINT32 clear_leftmost_set(UINT32 value)
{
	// Generates a single BLSR instruction
	return value & (value - 1);
}

// Like memcmp() but takes a 3rd 'mask' argument
// Note: Tried optimizing, has little effect on cumulative scan speed
int memcmp_mask(const BYTE *buffer1, const BYTE *buffer2, const BYTE *mask2, size_t count)
{
	while (count--)
	{
		if (*mask2)
		{
			if (*buffer1 != *buffer2)
				return -1;
		}

		buffer1++, buffer2++, mask2++;
	};
	return 0;
}

// Find signiture pattern in memory
PBYTE FindSignatureAVX2(PBYTE data, size_t size, const SIG &sig, BOOL hasWildcards)
{
	const BYTE *pat = sig.bytes.data();
	size_t patLen = sig.bytes.size();
	size_t patLen1 = (patLen - 1);
	size_t patLen2 = (patLen - 2);

	// Fill 'first' and 'last' with the first and last pattern byte respectively
	const __m256i first = _mm256_set1_epi8(pat[0]);
	const __m256i last = _mm256_set1_epi8(pat[patLen1]);

	if(!hasWildcards)
	{
		// A little faster without wildcards

		// Scan 32 bytes at the time..
		for (size_t i = 0; i < size; i += 32)
		{
			// Load in the next 32 bytes of input first and last
			// Can use align 32 bit read for first since the input is page aligned
			const __m256i block_first = _mm256_load_si256((const __m256i*) (data + i));
			const __m256i block_last = _mm256_loadu_si256((const __m256i*) (data + i + patLen1));

			// Compare first and last data to get 32byte masks
			const __m256i eq_first = _mm256_cmpeq_epi8(first, block_first);
			const __m256i eq_last = _mm256_cmpeq_epi8(last, block_last);

			// AND the equality masks and into a 32 bit mask
			UINT32 mask = _mm256_movemask_epi8(_mm256_and_si256(eq_first, eq_last));

			// Do pattern compare between first and last position if we got our first and last at this data position
			while (mask != 0)
			{
				UINT32 bitpos = get_first_bit_set(mask);
				if (memcmp(data + i + bitpos + 1, pat + 1, patLen2) == 0)
				{
					return data + i + bitpos;
				}
				mask = clear_leftmost_set(mask);
			};
		}
	}
	else
	{
		// Pattern scan with wildcards mask
		const BYTE *msk = sig.mask.data();

		for (size_t i = 0; i < size; i += 32)
		{
			const __m256i block_first = _mm256_load_si256((const __m256i*) (data + i));
			const __m256i block_last = _mm256_loadu_si256((const __m256i*) (data + i + patLen1));

			const __m256i eq_first = _mm256_cmpeq_epi8(first, block_first);
			const __m256i eq_last = _mm256_cmpeq_epi8(last, block_last);

			UINT32 mask = _mm256_movemask_epi8(_mm256_and_si256(eq_first, eq_last));

			// Do a byte pattern w/mask compare between first and last position if we got our first and last
			while (mask != 0)
			{
				UINT32 bitpos = get_first_bit_set(mask);
				if (memcmp_mask(data + i + bitpos + 1, pat + 1, msk + 1, patLen2) == 0)
				{
					return data + i + bitpos;
				}
				mask = clear_leftmost_set(mask);
			};
		}
	}

	return NULL;
}


// ------------------------------------------------------------------------------------------------

// Find signiture pattern in memory
// Base memory search reference, about 10x slower than the AVX2 version
PBYTE FindSignature(PBYTE input, size_t inputLen, const SIG &sig, BOOL hasWildcards)
{
	if (!hasWildcards)
	{
		// If no wildcards, faster to use a memcmp() type
		const BYTE *pat = sig.bytes.data();
		const BYTE *end = (input + inputLen);
		const BYTE first = *pat;
		size_t sigLen = sig.bytes.size();

		// Setup last in the pattern length byte quick for rejection test
		size_t lastIdx = (sigLen - 1);
		BYTE last = pat[lastIdx];

		for (PBYTE ptr = input; ptr < end; ++ptr)
		{
			if ((ptr[0] == first) && (ptr[lastIdx] == last))
			{
				if (memcmp(ptr+1, pat+1, sigLen-2) == 0)
					return ptr;
			}
		}
	}
	else
	{
		const BYTE *pat = sig.bytes.data();
		const BYTE *msk = sig.mask.data();
		const BYTE *end = (input + inputLen);
		const BYTE first = *pat;
		size_t sigLen = sig.bytes.size();
		size_t lastIdx = (sigLen - 1);
		BYTE last = pat[lastIdx];

		for (PBYTE ptr = input; ptr < end; ++ptr)
		{
			if ((ptr[0] == first) && (ptr[lastIdx] == last))
			{
				const BYTE *patPtr = pat+1;
				const BYTE *mskPtr = msk+1;
				const BYTE *memPtr = ptr+1;
				BOOL found = TRUE;

				for (int i = 0; (i < sigLen-2) && (memPtr < end); ++mskPtr, ++patPtr, ++memPtr, i++)
				{
					if (!*mskPtr)
						continue;

					if (*memPtr != *patPtr)
					{
						found = FALSE;
						break;
					}
				}

				if (found)
					return ptr;
			}
		}
	}

	return NULL;
}

// ------------------------------------------------------------------------------------------------

// Reference version search
static SSTATUS SearchSignature(PBYTE input, size_t inputLen, const SIG &sig)
{
	size_t sigSize = sig.bytes.size();
	size_t len = inputLen;
	size_t count = 0;
	BOOL hasWildcards = sig.hasMask();

	inputLen -= sigSize;

	// Search for signature match..
    PBYTE match = FindSignature(input, len, sig, hasWildcards);
	while (match)
	{
		// Stop now if we've hit two matches
		if (++count >= 2)
			break;

		++match;
		len = (inputLen - (int) (match - input));
		if (len < sigSize)
			break;

		// Next search
        match = FindSignature(match, len, sig, hasWildcards);
	};

	SSTATUS status;
	switch (count)
	{
		case 0: status = SSTATUS::NOT_FOUND; break;
		case 1: status = SSTATUS::UNIQUE; break;
		default: status = SSTATUS::NOT_UNIQUE; break;
	};

	// Only happens when there is an error in the search algorithm during development/testing
	if (status == SSTATUS::NOT_FOUND)
	{
		msg("\n** " __FUNCTION__ ": Sig not found! **\n");
		qstring tmp;
		sig.ToIdaString(tmp);
		msg("(%u) \"%s\"\n\n", (UINT32) sig.bytes.size(), tmp.c_str());
	}

	return status;
}

// Fast AVX2 based search
static SSTATUS SearchSignatureAVX2(PBYTE input, size_t inputLen, const SIG &sig)
{
	size_t sigSize = sig.bytes.size();
	size_t len = inputLen;
	size_t count = 0;
	BOOL hasWildcards = sig.hasMask();

	inputLen -= sigSize;

	PBYTE match = FindSignatureAVX2(input, len, sig, hasWildcards);
	while (match)
	{
		if (++count >= 2)
			break;

		++match;
		len = (inputLen - (int) (match - input));
		if (len < sigSize)
			break;

		match = FindSignatureAVX2(match, len, sig, hasWildcards);
	};

	SSTATUS status;
	switch (count)
	{
		case 0: status = SSTATUS::NOT_FOUND; break;
		case 1: status = SSTATUS::UNIQUE; break;
		default: status = SSTATUS::NOT_UNIQUE; break;
	};

	// Only happens when there is an error in the search algorithm during development/testing
	if (status == SSTATUS::NOT_FOUND)
	{
		msg("\n** " __FUNCTION__ ": Sig not found! **\n");
		qstring tmp;
		sig.ToIdaString(tmp);
		msg("(%u) \"%s\"\n\n", (UINT32) sig.bytes.size(), tmp.c_str());
	}
	return status;
}

// Search for signiture pattern, returning a status result
SSTATUS SearchSignature(const SIG &sig)
{
	// Setup IDB RAM clone on first scan
	if (!searchData.CloneIdb())
		return SSTATUS::NOT_FOUND;

	if (searchData.hasAVX2)
		return SearchSignatureAVX2(searchData.buffer, searchData.size, sig);
	else
	{
		static BOOL warnOnce = TRUE;
		if ((settings.outputLevel >= SETTINGS::LL_VERBOSE) && warnOnce)
		{
			warnOnce = FALSE;
			msg(__FUNCTION__ ": * Using non-AVX2 reference search *\n");
		}

		return SearchSignature(searchData.buffer, searchData.size, sig);
	}
}

```

`Settings.h`:

```h

#pragma once

// Settings container
struct SETTINGS
{
	#define SETTINGS_FILENAME "SigMakerEx.cfg"

	UINT32 version;	// Plugin version

	// Function signature creation criteria
	enum FUNC_CRITERIA: int
	{
		FUNC_ENTRY_POINT,	// Function entry point
		FUNC_MIN_SIZE,		// By minimal byte size
		FUNC_FULL,			// Sig of all function instructions (just first section, if has multiple)
	};
	FUNC_CRITERIA funcCriteria;

	enum OUTPUT_FORMAT: int
	{
		OF_IDA,		// IDA and others "AB 78 E8 ?? ?? ?? ?? CC" style spaced bytes with wildcards
		OF_CODE,	// Escape encoded binary with ASCII mask "code" style in two strings.
					// E.g. "\x33\x9A\xFA\x00\x00\x00\x00\x45\x68", "xxxxxxx????xx"
		OF_INLINE,	// Like "code" style, but byte string with inlined bytes w/wildcard
					// E.g. "{0x33,0x9A,0xFA,0xAE,0xAE,0xAE,0xAE,0x45,0x68}", where 0xAE is the wildcard bytes.
	};
	OUTPUT_FORMAT outputFormat;

	// IDA message output log level
	enum OUTPUTLEVEL: int
	{
		LL_TERSE,    // Minimal/normal output
		LL_VERBOSE   // Verbose for monitoring and troubleshooting
	};
	OUTPUTLEVEL outputLevel;

	// Maximum code reference search candidates
	// 0 = unlimited
	UINT32 maxScanRefCount;

	// Optional maximum function entry point signature bytes
	// 0 = unlimited
	UINT32 maxEntryPointBytes;

	// Byte mask/wildcard byte for the "inline" output format
	BYTE maskByte;

	SETTINGS() { Default();	};

	void Default()
	{
		version = MY_VERSION;
		funcCriteria = SETTINGS::FUNC_ENTRY_POINT;
		outputFormat = SETTINGS::OF_IDA;
		outputLevel  = SETTINGS::LL_TERSE;
		maxScanRefCount = 0;
		maxEntryPointBytes = 0;
		maskByte = 0xAE; // Default, one of the least common code byte frequency values
	}

	void Validate()
	{
		CLAMP(funcCriteria, SETTINGS::FUNC_ENTRY_POINT, SETTINGS::FUNC_FULL);
		CLAMP(outputFormat, SETTINGS::OF_IDA, SETTINGS::OF_INLINE);
		CLAMP(outputLevel, SETTINGS::LL_TERSE, SETTINGS::LL_VERBOSE);
	}

	void Save()
	{
		char path[MAXSTR];
		qsnprintf(path, MAXSTR - 1, "%s\\%s", get_user_idadir(), SETTINGS_FILENAME);
		FILE *fp = qfopen(path, "wb");
		if (fp)
		{
			Validate();
			qfwrite(fp, this, sizeof(SETTINGS));
			qfclose(fp);
		}
	}

	void Load()
	{
		__try
		{
			char path[MAXSTR];
			qsnprintf(path, MAXSTR - 1, "%s\\%s", get_user_idadir(), SETTINGS_FILENAME);
			FILE *fp = qfopen(path, "rb");
			if (fp)
			{
				qfread(fp, this, sizeof(SETTINGS));
				qfclose(fp);

				// If version is different other than just just the patch version, reset to the new version defaults
				if ((GET_VERSION_MAJOR(version) != GET_VERSION_MAJOR(MY_VERSION)) || (GET_VERSION_MINOR(version) != GET_VERSION_MINOR(MY_VERSION)))
				{
					Default();
					Save();
				}
				else
					Validate();
			}
		}
		__except (ReportException(__FUNCTION__, GetExceptionInformation()))
		{
			Default();
		}
	}
};

// Global instance
extern SETTINGS settings;

#define LOG_TERSE(...) { if (settings.outputLevel >= SETTINGS::LL_TERSE) msg(__VA_ARGS__); }
#define LOG_VERBOSE(...) { if (settings.outputLevel >= SETTINGS::LL_VERBOSE){ msg(__VA_ARGS__); WaitBox::processIdaEvents(); } }

```

`SigMaker.h`:

```h

// Common and shared
#pragma once

#include "StdAfx.h"
#include <vector>

#include "Settings.h"

// Minimal signature byte length
static const UINT32 MIN_SIG_SIZE = 5;

// Signature container
struct SIG
{
    std::vector<BYTE> bytes;
    std::vector<BYTE> mask;	// 0xFF = keep, 0 = wildcard/skip

    // ------------------------------------------------------------------------

	// Append one or more bytes at address to the signature
	void AddBytes(ea_t ea, UINT32 size)
	{
		size_t len = bytes.size();
		bytes.resize(len + size);
		mask.resize(len + size);

		PBYTE bytesPtr = &bytes[len];
		PBYTE maskPtr  = &mask[len];

        // get_db_byte() loop faster than get_bytes(), etc.
		while (size--)
		{
			*bytesPtr = get_db_byte(ea);
			*maskPtr = 0xFF;
			ea++, bytesPtr++, maskPtr++;
		};
	}

	// Append one or more wildcards to a signature
	void AddWildcards(UINT32 size)
	{
		size_t len = bytes.size();
		bytes.resize(len + size);
		mask.resize(len + size);

		PBYTE bytesPtr = &bytes[len];
		PBYTE maskPtr = &mask[len];

		while (size--)
		{
			*bytesPtr++ = 0xCC;
			*maskPtr++ = 0;
		};
	}

    // ------------------------------------------------------------------------

    // Output the sig as a "F8 66 4B ?? ?? ?? 88" format string
    void ToIdaString(__out qstring &string) const
    {
        size_t count = bytes.size();
        if (count > 0)
        {
			string.reserve(count * SIZESTR("?? "));
            for (size_t i = 0; i < count; i++)
            {
                if (mask[i])
                    string.cat_sprnt("%02X ", bytes[i]);
                else
                    string.cat_sprnt("?? ");
            }

			// Remove the final ' ' space
            string.remove_last();
        }
    }

    // Convert mask to a "code" style mask string; "xxxxxxx????xxx"
    void ToMaskString(__out qstring &maskStr) const
    {
		int count = (int) mask.size();
        maskStr.resize(count + 1);
		for (int i = 0; i < count; i++)
		{
			if (mask[i])
                maskStr[i] = 'x';
			else
                maskStr[i] = '?';
		}
    }

    // Convert byte pattern to '\x' "code" style encoding; "\x45\xAA\xCC\xCC\xCC\x9A\xFA"
	void ToCodeString(__out qstring &string) const
	{
		size_t count = bytes.size();
		if (count > 0)
		{
			string.reserve(count * SIZESTR("\\xCC"));
			for (size_t i = 0; i < count; i++)
			{
                if (mask[i])
                    string.cat_sprnt("\\x%02X", bytes[i]);
                else
					string += "\\xCC";
			}
		}
	}

	// Convert signature to a "inline" byte style C string. E.g. "{0x33,0x9A,0xFA,0xAE,0xAE,0xAE,0xAE,0x45,0x68}"
	void ToInlineString(__out qstring &string) const
	{
		size_t count = bytes.size();
		if (count > 0)
		{
			string = "const BYTE name_me[]={";
			for (size_t i = 0; i < count; i++)
			{
				if (mask[i])
					string.cat_sprnt("0x%02X,", bytes[i]);
				else
					string.cat_sprnt("0x%02X,", settings.maskByte);
			}
			string.remove_last();
			string += "};";
		}
	}

	// Right trim wildcards from signiture if they exist
	void trim()
	{
		size_t len = 0;
		for (size_t i = (bytes.size() - 1); i > 0; i--)
		{
			if (!mask[i])
				len++;
			else
				break;
		}

		if (len)
		{
			size_t newSize = (bytes.size() - len);
			bytes.resize(newSize);
			mask.resize(newSize);
		}
	}

	// Return wildcard/mask count
	size_t wildcards() const
	{
		size_t count = 0;

		// TODO: Vectorize this functions for speed?
		size_t size = bytes.size();
		for (size_t i = 0; i < size; ++i)
		{
			if (!mask[i])
				count++;
		}

		return count;
	}

    // Return TRUE is there is one or more wildcard/mask bytes
    __inline BOOL hasMask() const
    {
		return memchr(mask.data(), 0, bytes.size()) != NULL;
    }

    // ------------------------------------------------------------------------

    SIG& operator+=(const SIG &rhs)
    {
        // Append another sig to me
        bytes.insert(bytes.end(), rhs.bytes.begin(), rhs.bytes.end());
        mask.insert(mask.end(), rhs.mask.begin(), rhs.mask.end());
        return *this;
    }
};

// Search.cpp
enum SSTATUS
{
	NOT_FOUND,	// Signature not found error
	UNIQUE,		// Unique, single instance found
	NOT_UNIQUE	// Not unique, more than one instance found
};
SSTATUS SearchSignature(const SIG &sig);
void SearchCleanup();

// Signature.cpp
void CreateFunctionSig();
void CreateAddressSig();
void CreateAddressRangeSig();
void OutputSignature(const SIG &sig, ea_t address, UINT32 offset);

```

`SigMakerEx.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27130.2026
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SigMakerEx", "SigMakerEx.vcxproj", "{11111111-AAAA-BBBB-CCCC-777777777777}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug64|x64 = Debug64|x64
		Release|x64 = Release|x64
		Release64|x64 = Release64|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{11111111-AAAA-BBBB-CCCC-777777777777}.Debug|x64.ActiveCfg = Debug|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Debug|x64.Build.0 = Debug|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Debug64|x64.ActiveCfg = Debug64|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Debug64|x64.Build.0 = Debug64|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Release|x64.ActiveCfg = Release|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Release|x64.Build.0 = Release|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Release64|x64.ActiveCfg = Release64|x64
		{11111111-AAAA-BBBB-CCCC-777777777777}.Release64|x64.Build.0 = Release64|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {802A9F2E-7038-472F-B090-4154959F470D}
	EndGlobalSection
EndGlobal

```

`SigMakerEx.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug64|x64">
      <Configuration>Debug64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release64|x64">
      <Configuration>Release64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>SigMakerEx</ProjectName>
    <ProjectGuid>{11111111-AAAA-BBBB-CCCC-777777777777}</ProjectGuid>
    <RootNamespace>plugin</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>12.0.21005.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>IDA_SigMaker</TargetName>
    <TargetExt>.dLL</TargetExt>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\imd\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>IDA_SigMaker64</TargetName>
    <TargetExt>.dLL</TargetExt>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\imd\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>IDA_SigMaker</TargetName>
    <TargetExt>.dLL</TargetExt>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\imd\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>IDA_SigMaker64</TargetName>
    <TargetExt>.dLL</TargetExt>
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\imd\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>$(_IDADIR)\idasdk\include;WaitBoxEx</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__X64__;_DEBUG;_WINDOWS;_USRDLL;__NT__;__IDP__;__VC__;QT_NAMESPACE=QT;QT_NO_UNICODE_LITERAL;_CRT_SECURE_NO_WARNINGS;TARGET_NAME="$(TargetFileName)";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>Async</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <FloatingPointModel>Fast</FloatingPointModel>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ida.lib;User32.lib;Ole32.lib</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetFileName)</OutputFile>
      <AdditionalLibraryDirectories>$(_IDADIR)\idasdk\lib\x64_win_vc_32;$(_IDADIR)\idasdk\lib\x64_win_qt;WaitBoxEx;WaitBoxEx</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TurnOffAssemblyGeneration>true</TurnOffAssemblyGeneration>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(OutDir)$(TargetFileName)" "$(_IDADIR)\plugins"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>$(_IDADIR)\idasdk\include;WaitBoxEx</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__EA64__;__X64__;_DEBUG;_WINDOWS;_USRDLL;__NT__;__IDP__;__VC__;QT_NO_DEBUG;QT_NAMESPACE=QT;QT_NO_UNICODE_LITERAL;_CRT_SECURE_NO_WARNINGS;TARGET_NAME="$(TargetFileName)";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>Async</ExceptionHandling>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <FloatingPointModel>Fast</FloatingPointModel>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ida.lib;User32.lib;Ole32.lib</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetFileName)</OutputFile>
      <AdditionalLibraryDirectories>$(_IDADIR)\idasdk\lib\x64_win_vc_64;$(_IDADIR)\idasdk\lib\x64_win_qt;WaitBoxEx;WaitBoxEx</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TurnOffAssemblyGeneration>true</TurnOffAssemblyGeneration>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(OutDir)$(TargetFileName)" "$(_IDADIR)\plugins"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(_IDADIR)\idasdk\include;WaitBoxEx</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__X64__;NDEBUG;_WINDOWS;_USRDLL;__NT__;__IDP__;__VC__;QT_NO_DEBUG;QT_NAMESPACE=QT;QT_NO_UNICODE_LITERAL;_CRT_SECURE_NO_WARNINGS;TARGET_NAME="$(TargetFileName)";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>Async</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <FloatingPointModel>Fast</FloatingPointModel>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ida.lib;User32.lib;Ole32.lib</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetFileName)</OutputFile>
      <AdditionalLibraryDirectories>$(_IDADIR)\idasdk\lib\x64_win_vc_32;$(_IDADIR)\idasdk\lib\x64_win_qt;WaitBoxEx;WaitBoxEx</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>
      </FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TurnOffAssemblyGeneration>true</TurnOffAssemblyGeneration>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>C:\Tools\peupdate\peupdate.exe -s -r -q "$(OutDir)$(TargetFileName)"
copy "$(OutDir)$(TargetFileName)" "$(_IDADIR)\plugins"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(_IDADIR)\idasdk\include;WaitBoxEx</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__X64__;__EA64__;NDEBUG;_WINDOWS;_USRDLL;__NT__;__IDP__;__VC__;QT_NO_DEBUG;QT_NAMESPACE=QT;QT_NO_UNICODE_LITERAL;_CRT_SECURE_NO_WARNINGS;TARGET_NAME="$(TargetFileName)";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>Async</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <FloatingPointModel>Fast</FloatingPointModel>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ida.lib;User32.lib;Ole32.lib</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetFileName)</OutputFile>
      <AdditionalLibraryDirectories>$(_IDADIR)\idasdk\lib\x64_win_vc_64;$(_IDADIR)\idasdk\lib\x64_win_qt;WaitBoxEx;WaitBoxEx</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>
      </FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TurnOffAssemblyGeneration>true</TurnOffAssemblyGeneration>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>C:\Tools\peupdate\peupdate.exe -s -r -q "$(OutDir)$(TargetFileName)"
copy "$(OutDir)$(TargetFileName)" "$(_IDADIR)\plugins"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="SigMaker.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="StdAfx.h" />
    <ClInclude Include="Utility.h" />
    <ClInclude Include="WaitBoxEx\WaitBoxEx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Signature.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Search.cpp" />
    <ClCompile Include="Utility.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SigMakerEx.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Signature.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Search.cpp" />
    <ClCompile Include="Utility.cpp">
      <Filter>Support</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StdAfx.h" />
    <ClInclude Include="Utility.h">
      <Filter>Support</Filter>
    </ClInclude>
    <ClInclude Include="SigMaker.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="WaitBoxEx\WaitBoxEx.h">
      <Filter>Support</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Support">
      <UniqueIdentifier>{42b24ecd-c647-4e57-b467-384b3c0e7c71}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`SigMakerEx.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommand>$(_IDADIR)\ida.exe</LocalDebuggerCommand>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'">
    <LocalDebuggerCommand>$(_IDADIR)\ida64.exe</LocalDebuggerCommand>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommand>$(_IDADIR)\ida.exe</LocalDebuggerCommand>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <LocalDebuggerCommand>$(_IDADIR)\ida64.exe</LocalDebuggerCommand>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Signature.cpp`:

```cpp

// Main signature generation code
#include "SigMaker.h"
#include <algorithm>
#include <list>

#define WAIT_BOX_UPDATE() { if (WaitBox::isUpdateTime()) WaitBox::updateAndCancelCheck(); }

// Unique signature match container
struct SIGMATCH
{
	SIG sig;
	ea_t ea;
	UINT32 size;
    UINT32 wildcards;

	SIGMATCH(SIG &_sig, ea_t match_ea)
	{
        _sig.trim();
		sig = _sig;
		ea = match_ea;
		size = (UINT32) _sig.bytes.size();
        wildcards = (UINT32) _sig.wildcards();
	}

	bool operator <(const SIGMATCH &b) const
	{
		//return size < b.size;
        return std::pair(size, wildcards) < std::pair(b.size, b.wildcards);
	}
};
typedef std::list<SIGMATCH> UNIQUELIST;

// Container for instruction signature "siglets"
typedef std::vector<SIG> SIGLETS;


// Output signature to the IDA log pane
void OutputSignature(const SIG &sig, ea_t address, UINT32 offset)
{
	if (offset == 0)
		msg("SIG: 0x" EAFORMAT ", %u bytes %u, wildcards.\n", address, (UINT32) sig.bytes.size(), (UINT32) sig.wildcards());
	else
		msg("SIG: 0x" EAFORMAT ", @ Offset: 0x%X, %u bytes, %u wildcards\n", address, offset, (UINT32) sig.bytes.size(), (UINT32) sig.wildcards());

	// Always output IDA format
	qstring tmp;
	sig.ToIdaString(tmp);
	msg("IDA: \"%s\"\n", tmp.c_str());

	switch (settings.outputFormat)
	{
		// Escape encoded binary with ASCII mask "code" style in two strings.
		// E.g. "\x33\x9A\xFA\x00\x00\x00\x00\x45\x68", "xxxxxxx????xx"
		case SETTINGS::OF_CODE:
		{
			qstring code;
			sig.ToCodeString(code);
			qstring mask;
			sig.ToMaskString(mask);
			tmp.sprnt("\"%s\", \"%s\"", code.c_str(), mask.c_str());
			msg("%s\n", tmp.c_str());
		}
		break;

		// Like "code" style, but byte string with inlined wildcard bytes
		// E.g. "\x33\x9A\xFA\xAD\xAD\xAD\xAD\x45\x68", where 0xAD is the wildcard bytes
		case SETTINGS::OF_INLINE:
		{
			qstring bytes;
			sig.ToInlineString(bytes);
			msg("\"%s\"\n", bytes.c_str());
			qstring comment;
			comment.sprnt("// \"%s\"\n", tmp.c_str());
			tmp.sprnt("%s%s\n", comment.c_str(), bytes.c_str());
			if (offset)
			{
				qstring offstr;
				offstr.sprnt("const UINT32 name_me_offset = 0x%X;", offset);
				msg("\"%s\"\n", offstr.c_str());
				tmp += offstr;
			}
			msg("\"const BYTE MASK_BYTE = 0x%X;\"\n", settings.maskByte);
		}
		break;
	};
	WaitBox::processIdaEvents();

	SetClipboard(tmp.c_str());
}

// ------------------------------------------------------------------------------------------------
// Instruction analysis

static inline BOOL isJmpCntl(UINT32 type) { return((type >= NN_ja) && (type <= NN_jz)); }             // Return TRUE if a conditional jump instruction
static inline BOOL isJmpNotCntl(UINT32 type) { return((type >= NN_jmp) && (type <= NN_jmpshort)); }   // Return TRUE if a non-conditional jump instruction
static inline BOOL isCall(UINT32 type) { return((type >= NN_call) && (type <= NN_callni)); }          // Return TRUE if is a call instruction
static inline BOOL IsIdbAddress(ea_t address) { return((address >= inf.omin_ea) && (address < inf.omax_ea)); }  // Returns TRUE if address is inside this IDB

// Return the instruction operand offset if it has one
static UINT32 OperandOffset(__in insn_t &cmd)
{
    // For x86/AMD64 this will only a few max
    for (UINT32 i = 0; i < UA_MAXOP; i++)
    {
        // Hit end of opcode entries?
		optype_t type = cmd.ops[i].type;
		if ((type == o_void) || (type == (o_idpspec5 + 1)))
            return 0;
        else
        // Has an operand value
        if (cmd.ops[i].offb != 0)
            return cmd.ops[i].offb;
    }
    return 0;
}

// Get largest value of the instruction operands be it a displacement or immediate value, etc., and considering the MSB/sign bit
static ea_t LargestOperandValue(insn_t &cmd, ea_t test_ea)
{
	// IDA conveniently returns absolute addresses (not relative ones)

	// TODO: For the sign assumptions here, could check for AWE aware flag (PE header flag IMAGE_FILE_LARGE_ADDRESS_AWARE) for 32bit targets
    // Rare PE header flag for 32bit but a possibility still.
    #ifndef __EA64__
    static const ea_t HIGH_BIT = 0x80000000;
    #else
    static const ea_t HIGH_BIT = 0x8000000000000000;
    #endif

    ea_t result = 0;

    for (UINT32 i = 0; i < UA_MAXOP; i++)
    {
        optype_t type = cmd.ops[i].type;
        if ((type == o_void) || (type == (o_idpspec5 + 1)))
            break;
        else
        {
            ea_t value = (ea_t) cmd.ops[i].value;
            //if ((value & HIGH_BIT) && (type == o_imm))
            //    msg(EAFORMAT " v: " EAFORMAT "\n", test_ea, value);

            // Ignore signed immediate value, assume it's a flag value that can be ignored
            if (!((value & HIGH_BIT) && (type == o_imm)))
                if (value > result)
                    result = value;

            // Ignore signed displacements and memory references
            ea_t adress = cmd.ops[i].addr;
            if (!((adress & HIGH_BIT) && ((type == o_displ) || (type == o_mem))))
                if (adress > result)
                    result = adress;

            //if (result & HIGH_BIT)
            //    msg(EAFORMAT " " EAFORMAT " " EAFORMAT " t: %d\n", test_ea, value, adress, type);
        }
    }

    return result;
}

// Decode an instruction into a sig container
static void AddInst(__in_opt func_t *pfn, __in insn_t &cmd, __inout SIG &sig)
{
    UINT32 offb = OperandOffset(cmd);
    if (offb != 0)
    {
        // Filter out all call targets
        BOOL filter = FALSE;
        if (isCall(cmd.itype))
            filter = TRUE;
        else
        // Check jump targets
        if (isJmpCntl(cmd.itype) || isJmpNotCntl(cmd.itype))
        {
			// If we have function bounds, test for membership
			if (pfn)
			{
				// Filter if jump target is outside of our function
				ea_t target_ea = LargestOperandValue(cmd, cmd.ea);
				filter = !func_contains(pfn, target_ea);
			}
			else
			// Else, keep short jumps and filter the rest
			{
				if (cmd.size != 2)
					filter = TRUE;
			}
        }
        else
        {
            // Filter intermediate values that are probably an address
            if (ea_t value = LargestOperandValue(cmd, cmd.ea))
                filter = IsIdbAddress(value);
        }

        if (filter)
        {
            // Save the leading instruction bytes and wildcard the rest
            sig.AddBytes(cmd.ea, offb);
            sig.AddWildcards(cmd.size - offb);
        }
        else
            sig.AddBytes(cmd.ea, cmd.size);
    }
    else
		// No operand value
		sig.AddBytes(cmd.ea, cmd.size);
}


// ------------------------------------------------------------------------------------------------

// Dump a function's siglets for development
static void DumpFuncSiglets(__in func_t *pfn, __in SIGLETS &siglets)
{
	qstring name;
	get_func_name(&name, pfn->start_ea);
	msg("--------------------- " EAFORMAT " '%s' ---------------------\n", pfn->start_ea, name.c_str());

	ea_t current_ea = pfn->start_ea;
	size_t count = siglets.size();
	for (size_t i = 0; i < count; i++)
	{
		SIG &siglet = siglets[i];
		UINT32 size = (UINT32) siglet.bytes.size();

		msg("[%04u] " EAFORMAT ": ", i, current_ea);
		qstring str;
		siglet.ToIdaString(str);
		msg("(%u) \"%s\"", size, str.c_str());
		qstring disasm;
		GetDisasmText(current_ea, disasm);
		msg("  '%s'\n", disasm.c_str());
		current_ea += size;
	}

	msg("--------------------- " EAFORMAT " '%s' ---------------------\n", pfn->end_ea, name.c_str());
}

// Decode instruction into a siglet
// Returns instruction/alignment section on return, else <= 0 on error
static int InstToSig(__in_opt func_t *pfn, ea_t current_ea, __out SIG &siglet)
{
	// Decode instruction at this address
	insn_t cmd;
	int decodeSize = decode_insn(&cmd, current_ea);
	int itemSize = (int) get_item_size(current_ea);
	if (decodeSize <= 0)
	{
		// Decode failure
		// TODO: Fix bad instruction cases if/when encountered
		msg(MSG_TAG "** " __FUNCTION__ ": Decode failure @ 0x" EAFORMAT "! decodeSize: %d, itemSize: %d **\n", current_ea, decodeSize, itemSize);
		return -1;
	}

	if (decodeSize != itemSize)
	{
		// 99% of the time these are just "align" blocks
		flags_t flags = get_flags_ex(current_ea, 0);
		if (is_align(flags))
		{
			// Wildcard the itemSize count of bytes
			siglet.AddWildcards(itemSize);
		}
		else
		{
			// TODO: Fix more anomalous instruction cases as they encountered..
			msg(MSG_TAG "* " __FUNCTION__ ": Decode anomaly @ 0x" EAFORMAT "! decodeSize: %d, itemSize: %d *\n", current_ea, decodeSize, itemSize);
			qstring outbuf;
			IdaFlags2String(flags, outbuf);
			msg(" F: %08X, \"%s\"\n", flags, outbuf.c_str());
			qstring disasm;
			GetDisasmText(current_ea, disasm);
			msg(" '%s'\n\n", disasm.c_str());
			return -1;
		}
	}
	else
	{
		// Add instruction to signature
		AddInst(pfn, cmd, siglet);
	}

	return itemSize;
}

// Convert function instructions into an array of "siglets"
// For disjointed chunk functions, only processes the first/entry chunk
static BOOL FuncToSiglets(__in func_t *pfn, __out SIGLETS &siglets)
{
	// Iterate function instructions
	func_item_iterator_t fIt;
	if (!fIt.set(pfn))
	{
		msg(MSG_TAG "** Failed to init function iterator **\n");
		return FALSE;
	}

	ea_t expected_ea = BADADDR;
	do
	{
		// Decode next instruction
		ea_t current_ea = fIt.current();

		// Detect if we walked into some other function body
		// Will happen for the functions that have chunks spread out over different address ranges.
		// Also for the occasional broken function definition too.
		if ((current_ea != expected_ea) && (expected_ea != BADADDR))
		{
			// We'll stop here, keep what we have, and return
			msg(MSG_TAG "* Into non-contiguous chunk @ 0x" EAFORMAT ", expected " EAFORMAT ". Signature truncated. * \n", current_ea, expected_ea);
			break;
		}

		// Add next instruction siglet
		SIG siglet;
		int itemSize = InstToSig(pfn, current_ea, siglet);
		if (itemSize >= 1)
			siglets.push_back(siglet);
		else
			return FALSE;

		expected_ea = (current_ea + itemSize);

	} while (fIt.next_not_tail());

	return TRUE;
}

// Build a full function signature combined from a siglets array
static void BuildFuncSig(__in const SIGLETS &siglets, __out SIG &sig)
{
	for (const SIG &siglet: siglets)
		sig += siglet;
}

// Look for a unique sig at given function siglet boundary position
static ea_t FindSigAtFuncAddress(ea_t current_ea, ea_t end_ea, size_t sigIndex, const SIGLETS &siglets, __out SIG &outsig)
{
	/*
	TODO: Currently sig candidates are generated from instruction boundary lengths.
	Walking by sub-instruction lengths could result in more smallish sig canidates.
	But already relativity slow from all the uniqueness queries, this would increase the amount of searches (thus the time) even more.
	Although typically using instruction lengths as it is returns plenty of canidates in the 5'ish byte length anyhow.
	*/

	// Expand our sig until we either find a unique one or we hit the end address
    SIG sig;
	size_t sigByteSize = 0;
    size_t sigletCount = siglets.size();

	for (size_t i = sigIndex; i < sigletCount; i++)
	{
		const SIG &siglet = siglets[i];
		sig += siglet;
		size_t byteSize = siglet.bytes.size();
		sigByteSize += byteSize;

		// If sig byte size is MIN_SIG_SIZE or larger check if the sig is unique
		if (sigByteSize >= MIN_SIG_SIZE)
		{
			// Skip the cases like "E8 ?? ?? ?? ??"
			size_t nonMaskSize = (sigByteSize - sig.wildcards());
			if (nonMaskSize > 1)
			{
				// Make a trimmed temp copy for further testing and faster scan speed
				SIG tmp = sig;
				tmp.trim();

				// Skip cases like "E8 ?? ?? ?? ??"
				if (tmp.bytes.size() >= MIN_SIG_SIZE)
				{
					// Unique sig now?
					SSTATUS status = SearchSignature(tmp);
					if (status == SSTATUS::UNIQUE)
					{
						// Yes, return it
						outsig = tmp;
						return current_ea;
					}
					else
					// To cover a case that can only happen during development
					if (status == SSTATUS::NOT_FOUND)
						return BADADDR;

					WAIT_BOX_UPDATE();
				}
			}
		}

		current_ea += (ea_t) byteSize;
		if (current_ea >= end_ea)
			break;
	}

    return BADADDR;
}


// Find minimal at instruction boundary, inside a function (already known to be unique), signature.
static ea_t FindMinimalFuncSig(ea_t start_ea, ea_t end_ea, __in const SIGLETS &siglets, __out SIG &outsig)
{
	// Walk through each siglet from the top down at instruction boundaries
	UNIQUELIST canidates;
	ea_t current_ea = start_ea;
	size_t count = siglets.size();

	for (size_t i = 0; i < count; i++)
	{
		// Try to find a unique sig at this address for siglet position
		const SIG &siglet = siglets[i];
		SIG sig;
		ea_t result_ea = FindSigAtFuncAddress(current_ea, end_ea, i, siglets, sig);
		if (result_ea != BADADDR)
		{
			// Save candidate
			SIGMATCH canidate(sig, current_ea);
			canidates.push_back(canidate);

			// If at MIN_SIG_SIZE or less and no wildcards stop with this one
			if ((canidate.size <= MIN_SIG_SIZE) && (canidate.wildcards == 0))
			{
				LOG_VERBOSE(__FUNCTION__ ": Found ideal canidate: %u, %u.\n", canidate.size, canidate.wildcards);
				break;
			}
		}

		current_ea += (ea_t) siglet.bytes.size();
	}

	// Sport unique sig canidates by ascending primarily size, secondarily by 2nd wildcard count
	canidates.sort();

	if (settings.outputLevel >= SETTINGS::LL_VERBOSE)
	{
		msg("\nUnique sig canidates: %u\n", (UINT32)canidates.size());
		for (SIGMATCH &c: canidates)
		{
			qstring str;
			c.sig.ToIdaString(str);
			msg(EAFORMAT ": (%02u, %02u) '%s'\n", c.ea, c.size, c.wildcards, str.c_str());
		}
		WaitBox::processIdaEvents();
	}

	// Return the topmost/best
	outsig = canidates.front().sig;
	return canidates.front().ea;
}

// Find unique sig at function (already known to be unique) entry point downward
// The size will be anywhere from MIN_SIG_SIZE to the entire function body size
static ea_t FindFuncEntryPointSig(ea_t start_ea, __in SIG &funcSig, __out SIG &outsig)
{
    // Walk function sig down a byte at the time until we build a unique sig
    funcSig.trim();
	size_t sigSize = funcSig.bytes.size();
    size_t sigByteSize = 0;
    outsig.bytes.reserve(sigSize);
    outsig.mask.reserve(sigSize);

	for (size_t i = 0; i < sigSize; i++)
	{
		// Append next byte from function sig
        outsig.bytes.push_back(funcSig.bytes[i]);
        outsig.mask.push_back(funcSig.mask[i]);
        sigByteSize += 1;

		// If sig byte size is MIN_SIG_SIZE or greater check if the sig is unique
        if (sigByteSize >= MIN_SIG_SIZE)
        {
			// Make a trimmed temp copy for further testing and faster scan speed
			SIG tmp = outsig;
			tmp.trim();

			// Skip cases like "E8 ?? ?? ?? ??"
			if (tmp.bytes.size() >= MIN_SIG_SIZE)
			{
				// Unique now?
				SSTATUS status = SearchSignature(tmp);
				if (status == SSTATUS::UNIQUE)
				{
					// Yes, return it
					outsig = tmp;
					return start_ea;
				}
				else
				// To cover a case that can only happen during development
				if (status == SSTATUS::NOT_FOUND)
					return BADADDR;

				WAIT_BOX_UPDATE();
			}
        }
	}

    return BADADDR;
}

// Find the optimal function (already known to be unique) signature based on user criteria setting
ea_t FindFuncSig(__in const func_t *pfn, __in const SIGLETS &siglets, __in SIG &funcSig, __out SIG &outsig, UINT32 &offset)
{
    switch (settings.funcCriteria)
    {
		// Sig from function entry point downward
        case SETTINGS::FUNC_ENTRY_POINT:
		{
			ea_t result_ea = FindFuncEntryPointSig(pfn->start_ea, funcSig, outsig);
			offset = 0;
			return result_ea;
		}
        break;

		// Minimal optimal function sig
		case SETTINGS::FUNC_MIN_SIZE:
		{
			ea_t result_ea = FindMinimalFuncSig(pfn->start_ea, pfn->end_ea, siglets, outsig);
			offset = (UINT32) (result_ea - pfn->start_ea);
			return result_ea;
		}
		break;

		// Full function sig
		case SETTINGS::FUNC_FULL:
		{
			funcSig.trim();
            outsig = funcSig;
			offset = 0;
            return pfn->start_ea;
		}
		break;
    };

    return BADADDR;
}


// ------------------------------------------------------------------------------------------------

// Look for a unique function sig at given address
// Returns base address of sig, or BADADDR on failure
static ea_t FindSigAtFuncAddress(ea_t current_ea, __in func_t *pfn, __out SIG &outsig)
{
	// Expand our sig until we either find a unique one or we hit the end address..
	SIG sig;
	size_t sigByteSize = 0;
	ea_t end_ea = pfn->end_ea;

	while ((current_ea != BADADDR) && (current_ea < end_ea))
	{
		SIG siglet;
		int itemSize = InstToSig(pfn, current_ea, siglet);
		if (itemSize >= 1)
			sig += siglet;
		else
			return BADADDR;
		sigByteSize += (size_t) itemSize;

		// If sig byte size is MIN_SIG_SIZE or larger check if the sig is unique
		if (sigByteSize >= MIN_SIG_SIZE)
		{
			// Make a trimmed temp copy for further testing and faster scan speed
			SIG tmp = sig;
			tmp.trim();

			// Skip cases like "E8 ?? ?? ?? ??"
			if (tmp.bytes.size() >= MIN_SIG_SIZE)
			{
				// Unique sig now?
				SSTATUS status = SearchSignature(tmp);
				if (status == SSTATUS::UNIQUE)
				{
					// Yes, return it
					outsig = tmp;
					return current_ea;
				}
				else
				// To cover a case that can only happen during development
				if (status == SSTATUS::NOT_FOUND)
					return BADADDR;

				WAIT_BOX_UPDATE();
			}
		}

		current_ea += (ea_t) itemSize;
		if (current_ea >= end_ea)
			break;
	}

	return BADADDR;
}

// Look for a unique sig at given address; same as above sans function requirement
// Returns base address of sig, or BADADDR on failure
static ea_t FindSigAtAddress(ea_t current_ea, __out SIG &outsig)
{
	// Expand our sig until we either find a unique one, we run into a function, or we hit a non-address
	SIG sig;
	size_t sigByteSize = 0;

	while (TRUE)
	{
		// Bail if we are no longer inside of a valid code space
		flags_t flags = get_flags_ex(current_ea, 0);
		if (!is_code(flags))
		{
			LOG_VERBOSE(__FUNCTION__ ": 0x" EAFORMAT " no longer in a valid code space.\n", current_ea);
			break;
		}

		// Check if we walked into a function now
		// The assumption is the user wants a sig for some place non inside of a function and now we
		// walked into one at or past the entry point.
		//if(get_func(current_ea))
		if (is_func(flags))
		{
			LOG_VERBOSE(__FUNCTION__ ": 0x" EAFORMAT " walked into a function.\n", current_ea);
			break;
		}

		SIG siglet;
		int itemSize = InstToSig(NULL, current_ea, siglet);
		if (itemSize >= 1)
			sig += siglet;
		else
			return BADADDR;
		sigByteSize += (size_t)itemSize;

		// If sig byte size is MIN_SIG_SIZE or larger check if the sig is unique
		if (sigByteSize >= MIN_SIG_SIZE)
		{
			// Make a trimmed temp copy for further testing and faster scan speed
			SIG tmp = sig;
			tmp.trim();

			// Skip cases like "E8 ?? ?? ?? ??"
			if (tmp.bytes.size() >= MIN_SIG_SIZE)
			{
				// Unique sig now?
				SSTATUS status = SearchSignature(tmp);
				if (status == SSTATUS::UNIQUE)
				{
					// Yes, return it
					outsig = tmp;
					return current_ea;
				}
				else
				// To cover a case that can only happen during development
				if (status == SSTATUS::NOT_FOUND)
					return BADADDR;

				WAIT_BOX_UPDATE();
			}
		}

		current_ea += (ea_t) itemSize;
	}

	return BADADDR;
}

// Attempt to find a function entry code reference sig and output it
BOOL FindFuncXrefSig(ea_t func_ea)
{
	// Get first cref to the function if there is one
	ea_t ref_ea = get_first_cref_to(func_ea);
	if (ref_ea == BADADDR)
	{
		LOG_VERBOSE("No crefs available.\n");
	}
	else
	{
		// Gather target function references best sig canidates..
		UNIQUELIST canidates;

		// Override maximum ref limit search if setting exists, else use unlimited
		// TODO: Could be situations where we look at 100's, if not thousands of refs, trying a sig at each taking seconds if not minutes.
		// Might need a default max limit and/or iteration time limit.
		UINT32 refLimit = ((settings.maxScanRefCount > 0) ? settings.maxScanRefCount : UINT_MAX);
		UINT32 sigCount = 0;

		while ((ref_ea != BADADDR) && (sigCount < refLimit))
		{
			func_t *pfn = get_func(ref_ea);
			if (pfn)
			{
				LOG_VERBOSE("[%u] Function ref @ 0x" EAFORMAT ", Func: 0x" EAFORMAT "\n", sigCount, ref_ea, pfn->start_ea);

				// Look for a unique sig from reference branch down
				SIG sig;
				ea_t sig_ea = FindSigAtFuncAddress(ref_ea, pfn, sig);
				if (sig_ea != BADADDR)
				{
					// Save candidate
					SIGMATCH canidate(sig, sig_ea);
					canidates.push_back(canidate);

					// The ref sigs are going to start with the reference branch instruction.
					// So we are looking at least a 5 byte sig with wildcards to begin with.
					// Bail out now if we got a good minimal sig.
					static const UINT32 BRANCH_INSTRUCTION_SIZE = 5; // E.g. "E8 ?? ?? ?? ??"
					if ((canidate.size <= (BRANCH_INSTRUCTION_SIZE + MIN_SIG_SIZE)) && (canidate.wildcards <= (BRANCH_INSTRUCTION_SIZE - 1)))
					{
						LOG_VERBOSE(__FUNCTION__ ": Found good minimal canidate: %u, %u.\n", canidate.size, canidate.wildcards);
						break;
					}
				}
				else
					LOG_VERBOSE(" Ref not unique or error occured, skipped.\n");
			}

			sigCount++;
			ref_ea = get_next_cref_to(func_ea, ref_ea);
		};

		if (!canidates.empty())
		{
			// Sort sig canidates by ascending primarily size, secondarily by 2nd wildcard count
			canidates.sort();

			if (settings.outputLevel >= SETTINGS::LL_VERBOSE)
			{
				msg("\nXfef sig canidates: %u\n", (UINT32) canidates.size());
				for (SIGMATCH &c: canidates)
				{
					qstring str;
					c.sig.ToIdaString(str);
					msg(EAFORMAT ": (%02u, %02u) '%s'\n", c.ea, c.size, c.wildcards, str.c_str());
				}
				msg("\n");
				WaitBox::processIdaEvents();
			}

			// Output the topmost/best canidate
			msg("Function reference ");
			OutputSignature(canidates.front().sig, canidates.front().ea, 0);
			return TRUE;
		}
	}

	// If we made it here, we didn't find a xref sig
	return FALSE;
}

// ------------------------------------------------------------------------------------------------

// Attempt to create unique function signature at selected address
void CreateFunctionSig()
{
    // User selected address
    ea_t ea_selection = get_screen_ea();
    if (ea_selection == BADADDR)
    {
        msg(MSG_TAG "* Select a function address first *\n");
        return;
    }

    // Address must be at or inside a function
    func_t *pfn = get_func(ea_selection);
	if (!pfn)
	{
		msg(MSG_TAG "* Select an address inside a code function *\n");
		return;
	}

    // Convert function into a instruction "siglets" for analysis
	msg("\n");
    msg(MSG_TAG "Finding function signature.\n");
	TIMESTAMP procStart = GetTimestamp();
    SIGLETS siglets;
    if (FuncToSiglets(pfn, siglets))
    {
		if (settings.outputLevel >= SETTINGS::LL_VERBOSE)
		{
			msg("\nFunction siglets:\n");
			DumpFuncSiglets(pfn, siglets);
		}
    }

    // Build a full function signature from the siglets
    SIG funcSig;
    BuildFuncSig(siglets, funcSig);
    if (settings.outputLevel >= SETTINGS::LL_VERBOSE)
    {
        qstring sigStr;
        funcSig.ToIdaString(sigStr);
        msg("\nFull sig: \"%s\"\n\n", sigStr.c_str());
    }
	WaitBox::processIdaEvents();
	WaitBox::show("SigMakerEx", "Working..");
	WaitBox::updateAndCancelCheck(-1);

    // Check if the function is unique first. If it's not, we won't find a unique sig within it
    if (SearchSignature(funcSig) == SSTATUS::UNIQUE)
    {
        LOG_VERBOSE("Function is unqiue, finding optimal settings sig.\n");

        // Find an optimal sig for the unique function
        SIG outsig;
		UINT32 offset = 0;
        ea_t sig_ea = FindFuncSig(pfn, siglets, funcSig, outsig, offset);
		if (sig_ea != BADADDR)
		{
			// If entry point criteria is active, check optional max byte size
			if (settings.funcCriteria == SETTINGS::FUNC_ENTRY_POINT)
			{
				if ((settings.maxEntryPointBytes != 0) && ((UINT32) outsig.bytes.size() > settings.maxEntryPointBytes))
				{
					LOG_VERBOSE("\nEntry point signature byte count exceeds configured max, looking for a reference function sig instead.\n");
					if (!FindFuncXrefSig(pfn->start_ea))
						msg(MSG_TAG "* Failed to find a base or reference signature for selected function. *\n");
					goto exit;
				}
			}

			msg("Function ");
			OutputSignature(outsig, sig_ea, offset);

		}
    }
	else
    // Not unique, look for a function reference signature instead
    {
        LOG_VERBOSE("\nFunction is not unqiue, looking for a reference function sig.\n");
		if (!FindFuncXrefSig(pfn->start_ea))
			msg(MSG_TAG "* Failed to find a base or reference signature for selected function. *\n");
    }

	exit:;
	WaitBox::hide();
    LOG_VERBOSE("Took %.3f seconds.\n", (GetTimestamp() - procStart));
	WaitBox::processIdaEvents();
}


// ------------------------------------------------------------------------------------------------

// Attempt to create unique signature at selected address (inside a function or not)
void CreateAddressSig()
{
	// User selected address
	ea_t ea_selection = get_screen_ea();
	if (ea_selection == BADADDR)
	{
		msg(MSG_TAG "* Select a function address first *\n");
		return;
	}

	msg("\n");
	msg(MSG_TAG "Finding signature for " EAFORMAT ".\n", ea_selection);
	WaitBox::show("SigMakerEx", "Working..");
	WaitBox::updateAndCancelCheck(-1);
	WaitBox::processIdaEvents();
	TIMESTAMP procStart = GetTimestamp();

	// Ideally the address will be inside a function for better instruction analysis. Will typically
	// be the case, but not a requirement here.
	func_t *pfn = get_func(ea_selection);
	if (pfn)
	{
		LOG_VERBOSE("Selected address 0x" EAFORMAT " is inside function 0x" EAFORMAT "\n", ea_selection, pfn->start_ea);

		// Look for a minimal unique sig from address selection down
		SIG sig;
		ea_t sig_ea = FindSigAtFuncAddress(ea_selection, pfn, sig);
		if (sig_ea != BADADDR)
		{
			msg("Address ");
			OutputSignature(sig, ea_selection, 0);
		}
		else
			msg(MSG_TAG "* Failed to find unique signiture at address. *\n");
	}
	else
	{
		// The not inside a function version
		LOG_VERBOSE("Selected address 0x" EAFORMAT " is NOT inside a function.", ea_selection);

		SIG sig;
		ea_t sig_ea = FindSigAtAddress(ea_selection, sig);
		if (sig_ea != BADADDR)
		{
			msg("Address ");
			OutputSignature(sig, ea_selection, 0);
		}
		else
			msg(MSG_TAG "* Failed to find unique signiture at address. *\n");
	}

	WaitBox::hide();
	LOG_VERBOSE("Took %.3f seconds.\n", (GetTimestamp() - procStart));
	WaitBox::processIdaEvents();
}

// ------------------------------------------------------------------------------------------------

void CreateAddressRangeSig()
{
	// Generate signature from user selected address range, unique or not
	ea_t start_ea, end_ea;
	if (read_range_selection(get_current_viewer(), &start_ea, &end_ea))
	{
		if ((end_ea - start_ea) < MIN_SIG_SIZE)
		{
			msg(MSG_TAG "Code selection too small, needs to be at least %u bytes long. *\n", MIN_SIG_SIZE);
			return;
		}

		msg("\n");
		msg(MSG_TAG "Creating signiture from " EAFORMAT " to " EAFORMAT ".\n", start_ea, end_ea);
		WaitBox::processIdaEvents();
		TIMESTAMP procStart = GetTimestamp();

        // Iterate instructions over range.
		SIG sig;
		func_item_iterator_t fIt;
		bool isWithinRange = fIt.set_range(start_ea, end_ea);

        do
        {
            // Add next instruction to signature
            ea_t current_ea = fIt.current();
			SIG siglet;
			int itemSize = InstToSig(get_func(current_ea), current_ea, siglet);
			if (itemSize >= 1)
				sig += siglet;
			else
			{
				// Bail on decode failure, already reported in InstToSig()
				return;
			}

        } while (fIt.next_not_tail());

		if (!sig.bytes.empty())
		{
			sig.trim();
			msg("Range ");
			OutputSignature(sig, start_ea, 0);
		}

		LOG_VERBOSE("Took %.3f seconds.\n", (GetTimestamp() - procStart));
	}
	else
	{
		msg(MSG_TAG "* No code range selected *\n");
	}
	WaitBox::processIdaEvents();
}

```

`StdAfx.h`:

```h

// Common header
#pragma once

#define WIN32_LEAN_AND_MEAN
#define WINVER		 0x0A00 // _WIN32_WINNT_WIN10
#define _WIN32_WINNT 0x0A00
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <intrin.h>
#pragma intrinsic(memset, memcpy, memcmp, strcat, strcmp, strcpy, strlen)

// IDA SDK
#define USE_DANGEROUS_FUNCTIONS
#define USE_STANDARD_FILE_FUNCTIONS
//#define NO_OBSOLETE_FUNCS
#pragma warning(push)
#pragma warning(disable:4244) // "conversion from 'ssize_t' to 'int', possible loss of data"
#pragma warning(disable:4267) // "conversion from 'size_t' to 'uint32', possible loss of data"
#include <ida.hpp>
#include <bytes.hpp>
#include <allins.hpp>
#include <diskio.hpp>
#include <loader.hpp>
#include <search.hpp>
#include <typeinf.hpp>
#pragma warning(pop)

#define MSG_TAG "SigMakerEx: "
#include "Utility.h"

#include "WaitBoxEx.h"

#define MY_VERSION MAKE_SEMANTIC_VERSION(VERSION_RELEASE, 1, 1, 1)

```

`Utility.cpp`:

```cpp

// IDA plugin utility support
#include "StdAfx.h"
#include <tchar.h>
#include <winnt.h>

static ALIGN(16) TIMESTAMP performanceFrequency = 0;
struct OnUtilityInit
{
	OnUtilityInit()
	{
		LARGE_INTEGER large;
		QueryPerformanceFrequency(&large);
		performanceFrequency = (TIMESTAMP) large.QuadPart;
	}
} static _utilityInit;

qstring &GetVersionString(UINT32 version, qstring &version_string)
{
	version_string.sprnt("%u.%u.%u", GET_VERSION_MAJOR(MY_VERSION), GET_VERSION_MINOR(MY_VERSION), GET_VERSION_PATCH(MY_VERSION));
	VERSION_STAGE stage = GET_VERSION_STAGE(version);
	switch (GET_VERSION_STAGE(version))
	{
		case VERSION_ALPHA:	version_string += "-alpha";	break;
		case VERSION_BETA: version_string += "-beta"; break;
	};
	return version_string;
}

// Return high resolution floating elapsed seconds
TIMESTAMP GetTimestamp()
{
	LARGE_INTEGER large;
	QueryPerformanceCounter(&large);
	return ((TIMESTAMP) large.QuadPart / performanceFrequency);
}


LPCSTR TimestampString(TIMESTAMP time, __out_bcount_z(64) LPSTR buffer)
{
	if(time >= HOUR)
		sprintf_s(buffer, 64, "%.2f hours", (time / (TIMESTAMP) HOUR));
	else
	if(time >= MINUTE)
		sprintf_s(buffer, 64, "%.2f minutes", (time / (TIMESTAMP) MINUTE));
	else
	if(time < (TIMESTAMP) 0.01)
		sprintf_s(buffer, 64, "%.2f ms", (time * (TIMESTAMP) 1000.0));
	else
		sprintf_s(buffer, 64, "%.2f seconds", time);
	return buffer;
}

LPSTR NumberCommaString(UINT64 n, __out_bcount_z(32) LPSTR buffer)
{
	int i = 0, c = 0;
	do
	{
		buffer[i] = ('0' + (n % 10)); i++;

		n /= 10;
		if ((c += (3 && n)) >= 3)
		{
			buffer[i] = ','; i++;
			c = 0;
		}

	} while (n);
	buffer[i] = 0;
	return _strrev(buffer);
}

// Send text to the Windows clipboard for pasting
BOOL SetClipboard(LPCSTR text)
{
	BOOL result = false;

	if (OpenClipboard(NULL))
	{
		if (EmptyClipboard())
		{
			size_t dataSize = (strlen(text) + 1);
			if (dataSize > 1)
			{
				HGLOBAL memHandle = GlobalAlloc(GMEM_MOVEABLE, dataSize);
				if (memHandle)
				{
					LPSTR textMem = (LPSTR) GlobalLock(memHandle);
					if (textMem)
					{
						memcpy(textMem, text, dataSize);
						GlobalUnlock(memHandle);
						result = (SetClipboardData(CF_TEXT, memHandle) != NULL);
					}
				}
			}
		}

		CloseClipboard();
	}

	return result;
}

// Get line of disassembled code text sans color tags
void GetDisasmText(ea_t ea, __out qstring &s)
{
	s.clear();
	generate_disasm_line(&s, ea, (GENDSM_FORCE_CODE | GENDSM_REMOVE_TAGS | GENDSM_MULTI_LINE));
}


// ================================================================================================
// IDA flag dumping utility

// Duplicated from IDA SDK "bytes.hpp" since using these directly makes the code possible or just simpler
// * Type
#define FF_CODE 0x00000600LU	// Code
#define FF_DATA 0x00000400LU    // Data
#define FF_TAIL 0x00000200LU    // Tail; second, third (tail) byte of instruction or data
#define FF_UNK  0x00000000LU    // Unexplored

// * Data F0000000
#define DT_TYPE		0xF0000000	// Data type mask
#define FF_BYTE     0x00000000	// byte
#define FF_WORD     0x10000000	// word
#define FF_DWORD    0x20000000  // double word
#define FF_QWORD    0x30000000  // quad word
#define FF_TBYTE    0x40000000  // triple byte
#define FF_STRLIT   0x50000000  // string literal
#define FF_STRUCT   0x60000000  // struct variable
#define FF_OWORD    0x70000000  // octal word/XMM word (16 bytes/128 bits)
#define FF_FLOAT    0x80000000  // float
#define FF_DOUBLE   0x90000000  // double
#define FF_PACKREAL 0xA0000000  // packed decimal real
#define FF_ALIGN    0xB0000000  // alignment directive
//                  0xC0000000  // reserved
#define FF_CUSTOM   0xD0000000  // custom data type
#define FF_YWORD    0xE0000000  // YMM word (32 bytes/256 bits)
#define FF_ZWORD    0xF0000000  // ZMM word (64 bytes/512 bits)

// * Code F0000000
#define MS_CODE 0xF0000000LU	// Code type mask
#define FF_FUNC 0x10000000LU	// Function start
//              0x20000000LU    // Reserved
#define FF_IMMD 0x40000000LU    // Has Immediate value
#define FF_JUMP 0x80000000LU    // Has jump table or switch_info

// * Instruction/Data operands 0F000000
#define MS_1TYPE 0x0F000000LU   // Mask for the type of other operands
#define FF_1VOID 0x00000000LU   // Void (unknown)
#define FF_1NUMH 0x01000000LU   // Hexadecimal number
#define FF_1NUMD 0x02000000LU   // Decimal number
#define FF_1CHAR 0x03000000LU   // Char ('x')
#define FF_1SEG  0x04000000LU   // Segment
#define FF_1OFF  0x05000000LU   // Offset
#define FF_1NUMB 0x06000000LU   // Binary number
#define FF_1NUMO 0x07000000LU   // Octal number
#define FF_1ENUM 0x08000000LU   // Enumeration
#define FF_1FOP  0x09000000LU   // Forced operand
#define FF_1STRO 0x0A000000LU   // Struct offset
#define FF_1STK  0x0B000000LU   // Stack variable
#define FF_1FLT  0x0C000000LU   // Floating point number
#define FF_1CUST 0x0D000000LU   // Custom representation

#define MS_0TYPE 0x00F00000LU	// Mask for 1st arg typing
#define FF_0VOID 0x00000000LU   // Void (unknown)
#define FF_0NUMH 0x00100000LU   // Hexadecimal number
#define FF_0NUMD 0x00200000LU   // Decimal number
#define FF_0CHAR 0x00300000LU   // Char ('x')
#define FF_0SEG  0x00400000LU   // Segment
#define FF_0OFF  0x00500000LU   // Offset
#define FF_0NUMB 0x00600000LU   // Binary number
#define FF_0NUMO 0x00700000LU   // Octal number
#define FF_0ENUM 0x00800000LU   // Enumeration
#define FF_0FOP  0x00900000LU   // Forced operand
#define FF_0STRO 0x00A00000LU   // Struct offset
#define FF_0STK  0x00B00000LU   // Stack variable
#define FF_0FLT  0x00C00000LU   // Floating point number
#define FF_0CUST 0x00D00000LU   // Custom representation

// * State information 000FF800
#define MS_COMM   0x000FF800    // Mask of common bits
#define FF_FLOW   0x00010000    // Exec flow from prev instruction
#define FF_SIGN   0x00020000    // Inverted sign of operands
#define FF_BNOT   0x00040000    // Bitwise negation of operands
#define FF_UNUSED 0x00080000    // unused bit (was used for variable bytes)
#define FF_COMM   0x00000800    // Has comment
#define FF_REF    0x00001000    // has references
#define FF_LINE   0x00002000    // Has next or prev lines
#define FF_NAME   0x00004000    // Has name
#define FF_LABL   0x00008000    // Has dummy name
// 000001FF
#define FF_IVL  0x00000100LU	// Has byte value in 000000FF

// Decode IDA address flags value into a readable string
void IdaFlags2String(flags_t f, __out qstring &s, BOOL withValue)
{
	s.clear();
    #define FTEST(_f) if(f & _f){ if(!first) s += ", "; s += #_f; first = FALSE; }

	// F0000000
	BOOL first = TRUE;
	if(is_data(f))
	{
		switch(f & DT_TYPE)
		{
			case FF_BYTE    : s += "FF_BYTE";     break;
			case FF_WORD    : s += "FF_WORD";     break;
			case FF_DWORD	: s += "FF_DWORD";    break;
			case FF_QWORD	: s += "FF_QWORD";    break;
			case FF_TBYTE	: s += "FF_TBYTE";    break;
			case FF_STRLIT	: s += "FF_STRLIT";   break;
			case FF_STRUCT  : s += "FF_STRUCT";   break;
			case FF_OWORD	: s += "FF_OWORD";    break;
			case FF_FLOAT   : s += "FF_FLOAT";	  break;
			case FF_DOUBLE  : s += "FF_DOUBLE";   break;
			case FF_PACKREAL: s += "FF_PACKREAL"; break;
			case FF_ALIGN   : s += "FF_ALIGN";    break;

			case FF_CUSTOM	: s += "FF_CUSTOM";   break;
			case FF_YWORD	: s += "FF_YWORD";    break;
			case FF_ZWORD	: s += "FF_ZWORD";    break;

		};
		first = FALSE;
	}
	else
	if(is_code(f))
	{
		if(f & MS_CODE)
		{
			FTEST(FF_FUNC);
			FTEST(FF_IMMD);
			FTEST(FF_JUMP);
		}
	}

	// 0F000000
	if(f & MS_1TYPE)
	{
		if(!first) s += ", ";
		switch(f & MS_1TYPE)
		{
			//default: s += ",FF_1VOID"; break;
			case FF_1NUMH: s += "FF_1NUMH"; break;
			case FF_1NUMD: s += "FF_1NUMD"; break;
			case FF_1CHAR: s += "FF_1CHAR"; break;
			case FF_1SEG:  s += "FF_1SEG";  break;
			case FF_1OFF:  s += "FF_1OFF";  break;
			case FF_1NUMB: s += "FF_1NUMB"; break;
			case FF_1NUMO: s += "FF_1NUMO"; break;
			case FF_1ENUM: s += "FF_1ENUM"; break;
			case FF_1FOP:  s += "FF_1FOP";  break;
			case FF_1STRO: s += "FF_1STRO"; break;
			case FF_1STK:  s += "FF_1STK";  break;
			case FF_1FLT:  s += "FF_1FLT";  break;
			case FF_1CUST: s += "FF_1CUST"; break;
		};
		first = FALSE;
	}

	// 00F00000
	if(f & MS_0TYPE)
	{
		if(!first) s += ", ";
		switch(f & MS_0TYPE)
		{
			//default: s += ",FF_0VOID"; break;
			case FF_0NUMH: s += "FF_0NUMH"; break;
			case FF_0NUMD: s += "FF_0NUMD"; break;
			case FF_0CHAR: s += "FF_0CHAR"; break;
			case FF_0SEG : s += "FF_0SEG";  break;
			case FF_0OFF : s += "FF_0OFF";  break;
			case FF_0NUMB: s += "FF_0NUMB"; break;
			case FF_0NUMO: s += "FF_0NUMO"; break;
			case FF_0ENUM: s += "FF_0ENUM"; break;
			case FF_0FOP : s += "FF_0FOP";  break;
			case FF_0STRO: s += "FF_0STRO"; break;
			case FF_0STK : s += "FF_0STK";  break;
			case FF_0FLT : s += "FF_0FLT";  break;
			case FF_0CUST: s += "FF_0CUST"; break;
		};
		first = FALSE;
	}

	// 000F0000
	if(f & 0xF0000)
	{
		FTEST(FF_FLOW);
		FTEST(FF_SIGN);
		FTEST(FF_BNOT);
		FTEST(FF_UNUSED);
	}

	// 0000F000
	if(f & 0xF000)
	{
		FTEST(FF_REF);
		FTEST(FF_LINE);
		FTEST(FF_NAME);
		FTEST(FF_LABL);
	}

	// 00000F00
	if(!first) s += ", ";
	switch(f & (FF_CODE | FF_DATA | FF_TAIL))
	{
		case FF_CODE: s += "FF_CODE"; break;
		case FF_DATA: s += "FF_DATA"; break;
		case FF_TAIL: s += "FF_TAIL"; break;
		default: s += "FF_UNK";	   break;
	};
	first = FALSE;
	if(f & FF_COMM) s += ", FF_COMM";
	if(f & FF_IVL)  s += ", FF_IVL";

	// 000000FF optional value dump
    if (withValue && (f & FF_IVL))
	{
        char buffer[16];
        sprintf_s(buffer, sizeof(buffer), ", value: %02X", (f & 0xFF));
		s += buffer;
	}

	#undef FTEST
}

// Dump flags at address w/optional byte value dump
void DumpFlags(ea_t ea, BOOL withValue)
{
    qstring s;
    IdaFlags2String(get_flags(ea), s, withValue);
    msg(EAFORMAT " Flags: %s\n", ea, s.c_str());
}


// ------------------------------------------------------------------------------------------------

// Print C SEH information
int ReportException(LPCSTR name, LPEXCEPTION_POINTERS nfo)
{
	msg(MSG_TAG "** Exception: 0x%08X @ 0x%llX, in %s()! **\n", nfo->ExceptionRecord->ExceptionCode, nfo->ExceptionRecord->ExceptionAddress, name);
	return EXCEPTION_EXECUTE_HANDLER;
}

```

`Utility.h`:

```h

// IDA plugin utility support
#pragma once

// ------------------------------------------------------------------------------------------------

#ifndef __EA64__
#define EAFORMAT "%08X"
#else
#define EAFORMAT "%014llX"
#endif

// Size of string sans terminator
#define SIZESTR(x) (_countof(x) - 1)

#define ALIGN(_x_) __declspec(align(_x_))

#define STACKALIGN(type, name) \
	BYTE space_##name[sizeof(type) + (16-1)]; \
	type &name = *reinterpret_cast<type *>((UINT_PTR) (space_##name + (16-1)) & ~(16-1))

// Now you can use the #pragma message to add the location of the message:
// Examples:
// #pragma message(__LOC__ "important part to be changed")
// #pragma message(__LOC2__ "error C9901: wish that error would exist")
#define __STR2__(x) #x
#define __STR1__(x) __STR2__(x)
#define __LOC__ __FILE__ "("__STR1__(__LINE__)") : Warning MSG: "
#define __LOC2__ __FILE__ "("__STR1__(__LINE__)") : "

template <class T> void CLAMP(T &x, T min, T max) { if (x < min) x = min; else if (x > max) x = max; }

// Semantic versioning for storage 32bit UINT32, using 10 bits (0 to 1023) for major, minor, and patch numbers
// Then 2 bits to (for up to 4 states) to indicate alpha, beta, etc.
// https://semver.org/
enum VERSION_STAGE
{
	VERSION_RELEASE,
	VERSION_ALPHA,
	VERSION_BETA
};
#define MAKE_SEMANTIC_VERSION(_stage, _major, _minor, _patch) ((((UINT32)(_stage) & 3) << 30) | (((UINT32)(_major) & 0x3FF) << 20) | (((UINT32)(_minor) & 0x3FF) << 10) | ((UINT32)(_patch) & 0x3FF))
#define GET_VERSION_STAGE(_version) ((VERSION_STAGE)(((UINT32) (_version)) >> 30))
#define GET_VERSION_MAJOR(_version) ((((UINT32) (_version)) >> 20) & 0x3FF)
#define GET_VERSION_MINOR(_version) ((((UINT32) (_version)) >> 10) & 0x3FF)
#define GET_VERSION_PATCH(_version) (((UINT32) (_version)) & 0x3FF)

qstring &GetVersionString(UINT32 version, qstring& version_string);

// ------------------------------------------------------------------------------------------------

typedef double TIMESTAMP;
#define SECOND 1
#define MINUTE (60 * SECOND)
#define HOUR   (60 * MINUTE)

TIMESTAMP GetTimestamp();

// ------------------------------------------------------------------------------------------------

LPCSTR TimestampString(TIMESTAMP time, __out_bcount_z(64) LPSTR buffer);
LPSTR NumberCommaString(UINT64 n, __out_bcount_z(32) LPSTR buffer);
BOOL SetClipboard(LPCSTR text);
void GetDisasmText(ea_t ea, __out qstring &s);

void IdaFlags2String(flags_t f, __out qstring& s, BOOL withValue = FALSE);
void DumpFlags(ea_t ea, BOOL withValue = FALSE);

// ------------------------------------------------------------------------------------------------

int ReportException(LPCSTR name, LPEXCEPTION_POINTERS nfo);
#define EXCEPT() __except(ReportException(__FUNCTION__, GetExceptionInformation())){}
#define CATCH() catch (...) { msg(MSG_TAG "** Exception in %s()! ***\n", __FUNCTION__); }

```

`WaitBoxEx/WaitBoxEx.h`:

```h

// WaitBoxEx: Custom IDA Pro wait box
// By Sirmabus
// Version 1.6
// http://www.macromonkey.com
// License: Qt LGPL
#pragma once

// Define MATERIAL_DESIGN_STYLE for a "material design" inspired style
#ifndef _LIB
	#ifndef MATERIAL_DESIGN_STYLE
		#ifndef __EA64__
			#ifndef _DEBUG
			#pragma comment(lib, "WaitBoxEx.LiB")
			#else
			#pragma comment(lib, "WaitBoxExD.LiB")
			#endif
		#else
			#ifndef _DEBUG
			#pragma comment(lib, "WaitBoxEx64.LiB")
			#else
			#pragma comment(lib, "WaitBoxExD64.LiB")
			#endif
		#endif
	#else
		#ifndef __EA64__
			#ifndef _DEBUG
			#pragma comment(lib, "WaitBoxExMd.LiB")
			#else
			#pragma comment(lib, "WaitBoxExMdD.LiB")
			#endif
		#else
			#ifndef _DEBUG
			#pragma comment(lib, "WaitBoxExMd64.LiB")
			#else
			#pragma comment(lib, "WaitBoxExMdD64.LiB")
			#endif
		#endif
	#endif // MATERIAL_DESIGN_STYLE
#endif // _LIB

namespace WaitBox
{
    // Show the modal wait box dialog
    void show(LPCSTR titleText = "Progress", LPCSTR labelText = "Please wait..", LPCSTR styleSheet = NULL, LPCSTR icon = NULL);

    // Stop the wait box
    void hide();

    // Check if user canceled and optionally the update progress too w/built-in timed update limiter.
    // Progress range: 0 to 100, or -1 to switch to indeterminate mode.
    BOOL updateAndCancelCheck(int progress = 0);


    // Returns TRUE if ready for internal update
    BOOL isUpdateTime();

    // Returns TRUE if wait box up
    BOOL isShowing();

    // Change the label text
    void setLabelText(LPCSTR labelText);

    // Convenience wrapper of Qt function "QApplication::processEvents();" to tick IDA's Qt event queue
    void processIdaEvents();
};



```

`WaitBoxEx/ida-waitboxex.url`:

```url
[{000214A0-0000-0000-C000-000000000046}]
Prop3=19,11
[InternetShortcut]
IDList=
URL=https://sourceforge.net/projects/ida-waitboxex/

```