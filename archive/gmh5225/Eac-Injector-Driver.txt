Project Path: arc_gmh5225_Eac-Injector-Driver__1v18n42

Source Tree:

```txt
arc_gmh5225_Eac-Injector-Driver__1v18n42
├── Client
│   ├── pclient
│   │   ├── pclient.cpp
│   │   ├── pclient.vcxproj
│   │   ├── pclient.vcxproj.filters
│   │   ├── pclient.vcxproj.user
│   │   ├── skStr.h
│   │   └── x64
│   │       └── Release
│   │           ├── pclient.exe.recipe
│   │           ├── pclient.iobj
│   │           ├── pclient.ipdb
│   │           ├── pclient.log
│   │           ├── pclient.obj
│   │           ├── pclient.tlog
│   │           │   ├── CL.command.1.tlog
│   │           │   ├── CL.read.1.tlog
│   │           │   ├── CL.write.1.tlog
│   │           │   ├── link.command.1.tlog
│   │           │   ├── link.read.1.tlog
│   │           │   ├── link.write.1.tlog
│   │           │   └── pclient.lastbuildstate
│   │           └── vc143.pdb
│   └── pclient.sln
└── driver
    ├── pdrv
    │   ├── Callbacks.c
    │   ├── Callbacks.h
    │   ├── Driver.c
    │   ├── Funcs.c
    │   ├── Funcs.h
    │   ├── Imports.h
    │   ├── Log.h
    │   ├── Private.c
    │   ├── Private.h
    │   ├── Shared.h
    │   ├── Structs.h
    │   ├── Utils.c
    │   ├── Utils.h
    │   ├── pdrv.vcxproj
    │   ├── pdrv.vcxproj.filters
    │   ├── pdrv.vcxproj.user
    │   └── x64
    │       ├── Debug
    │       │   └── pdrv.log
    │       └── Release
    │           ├── pdrv.log
    │           ├── pdrv.tlog
    │           │   ├── CL.command.1.tlog
    │           │   ├── pdrv.lastbuildstate
    │           │   └── unsuccessfulbuild
    │           └── vc143.pdb
    └── pdrv.sln

```

`Client/pclient.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.87
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pclient", "pclient\pclient.vcxproj", "{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Debug|x64.ActiveCfg = Debug|x64
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Debug|x64.Build.0 = Debug|x64
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Debug|x86.ActiveCfg = Debug|Win32
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Debug|x86.Build.0 = Debug|Win32
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Release|x64.ActiveCfg = Release|x64
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Release|x64.Build.0 = Release|x64
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Release|x86.ActiveCfg = Release|Win32
		{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {07334F45-CDDF-40ED-B848-FA69D56B688B}
	EndGlobalSection
EndGlobal

```

`Client/pclient/pclient.cpp`:

```cpp


// TODO: Use blank space instead of allocating memory
// TODO: Load driver automatically (add kdmapper)

#include <Windows.h>
#include <TlHelp32.h>
#include <iostream>
#include <string>
#include "skStr.h"



//#define TARGET_DLL_ADDRESS L""
#define TARGET_DLL_ADDRESS L"" //dllpath 
//#define TARGET_PROCESS L"RustClient.exe" 
#define TARGET_PROCESS L"FortniteClient-Win64-Shipping.exe" 
#define TARGET_THREAD 3

#define CODE_DISABLE 0x1601
#define CODE_RESTORE 0x1602

typedef HMODULE(WINAPI* pLoadLibraryA)(LPCSTR);
typedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);

typedef BOOL(WINAPI* PDLL_MAIN)(HMODULE, DWORD, PVOID);

typedef struct _MANUAL_INJECT
{
	PVOID ImageBase;
	PIMAGE_NT_HEADERS NtHeaders;
	PIMAGE_BASE_RELOCATION BaseRelocation;
	PIMAGE_IMPORT_DESCRIPTOR ImportDirectory;
	pLoadLibraryA fnLoadLibraryA;
	pGetProcAddress fnGetProcAddress;
}MANUAL_INJECT, * PMANUAL_INJECT;

DWORD WINAPI LoadDll(PVOID p)
{
	PMANUAL_INJECT ManualInject;

	HMODULE hModule;
	DWORD64 i, Function, count, delta;

	DWORD64* ptr;
	PWORD list;

	PIMAGE_BASE_RELOCATION pIBR;
	PIMAGE_IMPORT_DESCRIPTOR pIID;
	PIMAGE_IMPORT_BY_NAME pIBN;
	PIMAGE_THUNK_DATA FirstThunk, OrigFirstThunk;

	PDLL_MAIN EntryPoint;

	ManualInject = (PMANUAL_INJECT)p;

	pIBR = ManualInject->BaseRelocation;
	delta = (DWORD64)((LPBYTE)ManualInject->ImageBase - ManualInject->NtHeaders->OptionalHeader.ImageBase); // Calculate the delta

	while (pIBR->VirtualAddress)
	{
		if (pIBR->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
		{
			count = (pIBR->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			list = (PWORD)(pIBR + 1);

			for (i = 0; i < count; i++)
			{
				if (list[i])
				{
					ptr = (DWORD64*)((LPBYTE)ManualInject->ImageBase + (pIBR->VirtualAddress + (list[i] & 0xFFF)));
					*ptr += delta;
				}
			}
		}

		pIBR = (PIMAGE_BASE_RELOCATION)((LPBYTE)pIBR + pIBR->SizeOfBlock);
	}

	pIID = ManualInject->ImportDirectory;

	// Resolve DLL imports

	while (pIID->Characteristics)
	{
		OrigFirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->OriginalFirstThunk);
		FirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->FirstThunk);

		hModule = ManualInject->fnLoadLibraryA((LPCSTR)ManualInject->ImageBase + pIID->Name);

		if (!hModule)
		{
			return FALSE;
		}

		while (OrigFirstThunk->u1.AddressOfData)
		{
			if (OrigFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				// Import by ordinal

				Function = (DWORD64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)(OrigFirstThunk->u1.Ordinal & 0xFFFF));

				if (!Function)
				{
					return FALSE;
				}

				FirstThunk->u1.Function = Function; 
			}

			else
			{
				// Import by name

				pIBN = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)ManualInject->ImageBase + OrigFirstThunk->u1.AddressOfData);
				Function = (DWORD64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)pIBN->Name);

				if (!Function)
				{
					return FALSE;
				}

				FirstThunk->u1.Function = Function;
			}

			OrigFirstThunk++;
			FirstThunk++;
		}

		pIID++;
	}

	if (ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint)
	{
		EntryPoint = (PDLL_MAIN)((LPBYTE)ManualInject->ImageBase + ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint);
		return EntryPoint((HMODULE)ManualInject->ImageBase, DLL_PROCESS_ATTACH, NULL); // Call the entry point
	}

	return TRUE;
}

DWORD WINAPI LoadDllEnd()
{
	return 0;
}

#pragma comment(lib, "ntdll.lib")

extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);

UCHAR code[] = {
  0x48, 0xB8, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // mov -16 to rax
  0x48, 0x21, 0xC4,                                             // and rsp, rax
  0x48, 0x83, 0xEC, 0x20,                                       // subtract 32 from rsp
  0x48, 0x8b, 0xEC,                                             // mov rbp, rsp
  0x90, 0x90,                                                   // nop nop
  0x48, 0xB9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,   // mov rcx,CCCCCCCCCCCCCCCC
  0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,   // mov rax,AAAAAAAAAAAAAAAA
  0xFF, 0xD0,                                                   // call rax
  0x90,                                                         // nop
  0x90,                                                         // nop
  0xEB, 0xFC                                                    // JMP to nop
};

void CallbackSwitch(bool restore) 
{
	FARPROC fnNtQueryIntervalProfile = GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtQueryIntervalProfile");
	typedef HRESULT(__stdcall* tNtQueryIntervalProfile)(ULONG64 ProfileSource, PULONG Interval);

	tNtQueryIntervalProfile NtQueryIntervalProfile = reinterpret_cast<tNtQueryIntervalProfile>(fnNtQueryIntervalProfile);

	ULONG a2 = 0;
	if (restore) 
	{
		NtQueryIntervalProfile(CODE_RESTORE, &a2);
	}
	else 
	{
		NtQueryIntervalProfile(CODE_DISABLE, &a2);
	}

}

DWORD GetPID() 
{
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(snapshot, &entry) == TRUE)
	{
		while (Process32Next(snapshot, &entry) == TRUE)
		{
			if (wcscmp(entry.szExeFile, TARGET_PROCESS) == 0)
			{
				return entry.th32ProcessID;
			}
		}
	}

	CloseHandle(snapshot);
	return 0;
}

void End() 
{
	Beep(300, 300);
	printf(skCrypt("\[+] Successfully injected!\n"));
	getchar();
	while (true) 
	{
		exit(0);
	}
}

int main()
{

	LPBYTE ptr;
	HANDLE hProcess, hThread, hSnap, hFile;
	PVOID mem, mem1;
	DWORD ProcessId, FileSize, read, i;
	PVOID buffer, image;
	BOOLEAN bl;
	PIMAGE_DOS_HEADER pIDH;
	PIMAGE_NT_HEADERS pINH;
	PIMAGE_SECTION_HEADER pISH;

	THREADENTRY32 te32;
	CONTEXT ctx;

	MANUAL_INJECT ManualInject;

	te32.dwSize = sizeof(te32);
	ctx.ContextFlags = CONTEXT_FULL;

	system("cls");
	printf(skCrypt("[+] Initialized\n"));

	printf(skCrypt("[>] Disabling anticheat callbacks...\n"));
	CallbackSwitch(false);
	printf(skCrypt("[+] Callbacks disabled\n"));
	Sleep(100);
	system("cls");
	
	printf(skCrypt("[>] Getting game PID...\n"));
	DWORD PID = GetPID();
	if (PID == 0) 
	{
		system("cls");
		printf(skCrypt("[-] Game is not running\n"));
		Sleep(1000);
		exit(0);
		End();
	}
	system("cls");
	printf(skCrypt("[+] Found on PID %u\n"), PID);
	system("cls");
	printf(skCrypt("[>] Injecting...\n"));
	//std::vector<std::uint8_t> bytes = KeyAuthApp.download("	858860");
	//if (!KeyAuthApp.data.success) // check whether file downloaded correctly
	//{
	//	system("cls");
	//	std::cout << skCrypt("\n\nStatus: ") << KeyAuthApp.data.message;
	//	Sleep(1500);
	//	exit(0);
	//}
	//std::ofstream file("file.dll", std::ios_base::out | std::ios_base::binary);
	//file.write((char*)bytes.data(), bytes.size());
	//file.close();

	hFile = CreateFile(TARGET_DLL_ADDRESS, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); // Open the DLL

	if (hFile == INVALID_HANDLE_VALUE)
	{
		system("cls");
		printf(skCrypt("[-] Unable to open the DLL (%d)\n"), GetLastError());
		Sleep(100);
		system("cls");
		End();
	}

	FileSize = GetFileSize(hFile, NULL);
	buffer = VirtualAlloc(NULL, FileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!buffer)
	{
		system("cls");
		printf(skCrypt("[-] Unable to allocate memory for DLL data (%d)\n"), GetLastError());

		CloseHandle(hFile);
		Sleep(100);
		system("cls");
		End();
	}

	// Read the DLL

	if (!ReadFile(hFile, buffer, FileSize, &read, NULL))
	{
		system("cls");
		printf(skCrypt("[-] Unable to read the DLL (%d)\n"), GetLastError());

		VirtualFree(buffer, 0, MEM_RELEASE);
		CloseHandle(hFile);
		Sleep(100);
		system("cls");
		End();
	}

	CloseHandle(hFile);

	pIDH = (PIMAGE_DOS_HEADER)buffer;

	if (pIDH->e_magic != IMAGE_DOS_SIGNATURE)
	{
		system("cls");
		printf(skCrypt("[-] Invalid executable image\n"));

		VirtualFree(buffer, 0, MEM_RELEASE);
		Sleep(100);
		system("cls");
		End();
	}

	pINH = (PIMAGE_NT_HEADERS)((LPBYTE)buffer + pIDH->e_lfanew);

	if (pINH->Signature != IMAGE_NT_SIGNATURE)
	{
		system("cls");
		printf(skCrypt("[-] Invalid PE header\n"));

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	if (!(pINH->FileHeader.Characteristics & IMAGE_FILE_DLL))
	{
		system("cls");
		printf(skCrypt("[-] The image is not DLL\n"));

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	RtlAdjustPrivilege(20, TRUE, FALSE, &bl);

	ProcessId = PID;
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);

	if (!hProcess)
	{
		system("cls");
		printf(skCrypt("[-] Unable to open target process handle (%d)\n"), GetLastError());
		End();
	}

	image = VirtualAllocEx(hProcess, NULL, pINH->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the DLL

	if (!image)
	{
		system("cls");
		printf(skCrypt("[-] Unable to allocate memory for the DLL (%d)\n"), GetLastError());

		VirtualFree(buffer, 0, MEM_RELEASE);
		CloseHandle(hProcess);

		End();
	}

	// Copy the header to target process

	if (!WriteProcessMemory(hProcess, image, buffer, pINH->OptionalHeader.SizeOfHeaders, NULL))
	{
		system("cls");
		printf(skCrypt("[-] Unable to copy headers to target process (%d)\n"), GetLastError());

		VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);
		CloseHandle(hProcess);

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	pISH = (PIMAGE_SECTION_HEADER)(pINH + 1);

	// Copy the DLL to target process

	for (i = 0; i < pINH->FileHeader.NumberOfSections; i++)
	{
		WriteProcessMemory(hProcess, (PVOID)((LPBYTE)image + pISH[i].VirtualAddress), (PVOID)((LPBYTE)buffer + pISH[i].PointerToRawData), pISH[i].SizeOfRawData, NULL);
	}

	mem1 = VirtualAllocEx(hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the loader code

	if (!mem1)
	{
		system("cls");
		printf(skCrypt("[-] Unable to allocate memory for the loader code (%d)\n"), GetLastError());

		VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);
		CloseHandle(hProcess);

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	printf(skCrypt("[+] Loader code allocated at %#x\n"), mem1);
	memset(&ManualInject, 0, sizeof(MANUAL_INJECT));

	ManualInject.ImageBase = image;
	ManualInject.NtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)image + pIDH->e_lfanew);
	ManualInject.BaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	ManualInject.ImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
	ManualInject.fnLoadLibraryA = LoadLibraryA;
	ManualInject.fnGetProcAddress = GetProcAddress;


	if (!WriteProcessMemory(hProcess, mem1, &ManualInject, sizeof(MANUAL_INJECT), NULL))
		system("cls");
		printf(skCrypt("[-] Memory write error (%d)\n"), GetLastError());
	//std::cout << "LoadDllSize " << std::dec << (DWORD64)LoadDllEnd - (DWORD64)LoadDll << std::endl;

	// FIXED by removing optimiations : some fat fucking error here.. writing LoadDll directly appears to write a bunch of JMP instructions to undefined memory and the sizes are messed
	if (!WriteProcessMemory(hProcess, (PVOID)((PMANUAL_INJECT)mem1 + 1), LoadDll, 4096 - sizeof(MANUAL_INJECT), NULL))
		system("cls");
		printf(skCrypt("[-] Memory write error (%d)\n"), GetLastError());
	//std::cout << "LoadDllAddress " << std::hex << (PVOID)((PMANUAL_INJECT)mem1 + 1) << std::endl;

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	Thread32First(hSnap, &te32);

	int number = 0;
	while (Thread32Next(hSnap, &te32))
	{
		if (te32.th32OwnerProcessID == ProcessId)
		{
			if (number == TARGET_THREAD)
			{
				break;
			}
			number++;
		}
	}
	system("cls");
	printf(skCrypt("[+] Thread found on ID: %d\n"), te32.th32ThreadID);

	CloseHandle(hSnap);

	mem = VirtualAllocEx(hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!mem)
	{
		system("cls");
		printf(skCrypt("[-] Unable to allocate memory in target process (%d)\n"), GetLastError());

		CloseHandle(hProcess);
		End();
	}
	system("cls");
	printf(skCrypt("[+] Memory allocated at %#x\n"), mem);

	hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);

	if (!hThread)
	{
		system("cls");
		printf(skCrypt("[-] Unable to open target thread handle (%d)\n"), GetLastError());

		VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
		CloseHandle(hProcess);
		End();
	}

	SuspendThread(hThread);
	GetThreadContext(hThread, &ctx);

	buffer = VirtualAlloc(NULL, 65536, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	ptr = (LPBYTE)buffer;
	ZeroMemory(buffer, 65536);
	memcpy(buffer, code, sizeof(code));

	for (BYTE* ptr = (LPBYTE)buffer; ptr < ((LPBYTE)buffer + 300); ptr++)
	{
		DWORD64 address = *(DWORD64*)ptr;
		if (address == 0xCCCCCCCCCCCCCCCC)
		{
			system("cls");
			printf(skCrypt("[>] Writing param 1 (rcx)...\n"));
			*(DWORD64*)ptr = (DWORD64)mem1;
		}

		if (address == 0xAAAAAAAAAAAAAAAA)
		{
			system("cls");
			printf(skCrypt("[>] Writing function address (rax)...\n"));
			*(DWORD64*)ptr = (DWORD64)((PMANUAL_INJECT)mem1 + 1);
		}
	}

	if (!WriteProcessMemory(hProcess, mem, buffer, sizeof(code), NULL)) // + 0x4 because a DWORD is 0x4 big
	{
		system("cls");
		printf(skCrypt("[-] Unable to write shellcode into target process (%d)\n"), GetLastError());

		VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
		ResumeThread(hThread);

		CloseHandle(hThread);
		CloseHandle(hProcess);

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	ctx.Rip = (DWORD64)mem;

	if (!SetThreadContext(hThread, &ctx))
	{
		system("cls");
		printf("[-] Unable to hijack target thread (%d)\n"), GetLastError();

		VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
		ResumeThread(hThread);

		CloseHandle(hThread);
		CloseHandle(hProcess);

		VirtualFree(buffer, 0, MEM_RELEASE);
		End();
	}

	ResumeThread(hThread);

	CloseHandle(hThread);
	CloseHandle(hProcess);

	VirtualFree(buffer, 0, MEM_RELEASE);

	system("cls");
	printf(skCrypt("[+] Injected successfully\n"));

	/*printf(xorstr_("[>] Waiting... "));
	for (int i = 1; i <= 10; i++) 
	{
		printf(xorstr_(" %i "), i);
		Sleep(1000);
	}
	printf(xorstr_("\n[+] Wait complete\n"));*/

	system("cls");
	printf(skCrypt("[>] Restoring anticheat callbacks...\n"));
	CallbackSwitch(true);
	system("cls");
	printf(skCrypt("[+] Callbacks restored\n"));

	End();
}

```

`Client/pclient/pclient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{E70B6BC2-EC48-4BDB-925B-C2D9102FC88D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>pclient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <SupportJustMyCode>false</SupportJustMyCode>
      <ControlFlowGuard>false</ControlFlowGuard>
      <RemoveUnreferencedCodeData>false</RemoveUnreferencedCodeData>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
      <DebugInformationFormat>None</DebugInformationFormat>
      <OmitFramePointers>false</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>"C:\Users\Samuel Tulach\Desktop\pdrv\pclient\pclient\ntdll.lib";%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <EnableCOMDATFolding>false</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pclient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="auth.hpp" />
    <ClInclude Include="skStr.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="libcurl.lib" />
    <Library Include="library_x64.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Client/pclient/pclient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="pclient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Auth">
      <UniqueIdentifier>{f3a5e199-8393-4b0b-b176-96ac58a2f05f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="auth.hpp">
      <Filter>Auth</Filter>
    </ClInclude>
    <ClInclude Include="skStr.h">
      <Filter>Auth</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="libcurl.lib" />
    <Library Include="library_x64.lib" />
  </ItemGroup>
</Project>
```

`Client/pclient/pclient.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Client/pclient/skStr.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`Client/pclient/x64/Release/pclient.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Users\kcxac\Documents\Eac inje\Client\x64\Release\pclient.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`Client/pclient/x64/Release/pclient.log`:

```log
  pclient.cpp
C:\Users\kcxac\Documents\Eac inje\Client\pclient\pclient.cpp(221,9): warning C4129: '[': unrecognized character escape sequence
C:\Users\kcxac\Documents\Eac inje\Client\pclient\pclient.cpp(544,10): warning C4473: 'printf' : not enough arguments passed for format string
C:\Users\kcxac\Documents\Eac inje\Client\pclient\pclient.cpp(544,10): message : placeholders and their parameters expect 1 variadic arguments, but 0 were provided
C:\Users\kcxac\Documents\Eac inje\Client\pclient\pclient.cpp(544,10): message : the missing variadic argument 1 is required by format string '%d'
  Generating code
  133 of 251 functions (53.0%) were compiled, the rest were copied from previous compilation.
    96 functions were new in current compilation
    0 functions had inline decision re-evaluated but remain unchanged
  Finished generating code
library_x64.lib(auth.obj) : warning LNK4099: PDB '' was not found with 'library_x64.lib(auth.obj)' or at ''; linking object as if no debug info
library_x64.lib(utils.obj) : warning LNK4099: PDB '' was not found with 'library_x64.lib(utils.obj)' or at ''; linking object as if no debug info
library_x64.lib(hmac_sha256.obj) : warning LNK4099: PDB '' was not found with 'library_x64.lib(hmac_sha256.obj)' or at ''; linking object as if no debug info
library_x64.lib(sha256.obj) : warning LNK4099: PDB '' was not found with 'library_x64.lib(sha256.obj)' or at ''; linking object as if no debug info
  pclient.vcxproj -> C:\Users\kcxac\Documents\Eac inje\Client\x64\Release\pclient.exe

```

`Client/pclient/x64/Release/pclient.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\PCLIENT.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\PCLIENT.CPP

```

`Client/pclient/x64/Release/pclient.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\PCLIENT.CPP
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\1033\CLUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UM\TLHELP32.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ISTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\OSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCNUM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CLIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CMATH
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CRTDBG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTR1COMMON
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INTRIN0.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ITERATOR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOSFWD
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XUTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_ITER_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\UTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDINT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDINT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STREAMBUF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\SHARE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CERRNO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDEXCEPT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\MALLOC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XMEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\LIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\FLOAT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ISA_AVAILABILITY.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\NEW
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XATOMIC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XERRC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ATOMIC
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTHREADS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTIMEC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\TIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCALE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\MEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\TYPEINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XFACET
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_XLOCINFO_TYPES.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CCTYPE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22621.0\UCRT\LOCALE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STRING
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\AUTH.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VECTOR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\FSTREAM
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\SKSTR.H

```

`Client/pclient/x64/Release/pclient.tlog/CL.write.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\PCLIENT.CPP
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\VC143.PDB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.OBJ

```

`Client/pclient/x64/Release/pclient.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBCURL.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBRARY_X64.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.OBJ
/OUT:"C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\X64\RELEASE\PCLIENT.EXE" /INCREMENTAL:NO /NOLOGO KERNEL32.LIB USER32.LIB GDI32.LIB WINSPOOL.LIB COMDLG32.LIB ADVAPI32.LIB SHELL32.LIB OLE32.LIB OLEAUT32.LIB UUID.LIB ODBC32.LIB ODBCCP32.LIB /MANIFEST /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" /manifest:embed /DEBUG /PDB:"C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\X64\RELEASE\PCLIENT.PDB" /SUBSYSTEM:CONSOLE /OPT:REF /OPT:ICF /LTCG:incremental /LTCGOUT:"X64\RELEASE\PCLIENT.IOBJ" /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\X64\RELEASE\PCLIENT.LIB" /MACHINE:X64 X64\RELEASE\PCLIENT.OBJ
LIBCURL.LIB
LIBRARY_X64.LIB

```

`Client/pclient/x64/Release/pclient.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBCURL.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBRARY_X64.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\KERNEL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\USER32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\GDI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\WINSPOOL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\COMDLG32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\ADVAPI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\SHELL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\OLE32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\OLEAUT32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\UUID.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\ODBC32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\ODBCCP32.LIB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.OBJ
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBCURL.LIB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBRARY_X64.LIB
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\C2.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\MSVCPRT.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\NTDLL.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\MSVCRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\OLDNAMES.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\NORMALIZ.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\WLDAP32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\CRYPT32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\WS2_32.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\ATLMFC\LIB\X64\ATLS.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\SHLWAPI.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\RPCRT4.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\HTTPAPI.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\PSAPI.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UM\X64\USERENV.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\VCRUNTIME.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22621.0\UCRT\X64\UCRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\1033\LINKUI.DLL
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.IPDB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.IOBJ
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\CVTRES.EXE
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\ATLMFC\LIB\X64\ATLS.AMD64.PDB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\VC143.PDB

```

`Client/pclient/x64/Release/pclient.tlog/link.write.1.tlog`:

```tlog
^C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBCURL.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\LIBRARY_X64.LIB|C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.OBJ
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\X64\RELEASE\PCLIENT.EXE
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.IPDB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\X64\RELEASE\PCLIENT.PDB
C:\USERS\KCXAC\DOCUMENTS\EAC INJE\CLIENT\PCLIENT\X64\RELEASE\PCLIENT.IOBJ

```

`Client/pclient/x64/Release/pclient.tlog/pclient.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v143:VCToolArchitecture=Native64Bit:VCToolsVersion=14.34.31933:TargetPlatformVersion=10.0.22621.0:
Release|x64|C:\Users\kcxac\Documents\Eac inje\Client\|

```

`driver/pdrv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.87
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pdrv", "pdrv\pdrv.vcxproj", "{58BA8DEC-BB05-4607-94DF-242B498AE5BC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM.ActiveCfg = Debug|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM.Build.0 = Debug|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM.Deploy.0 = Debug|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM64.Build.0 = Debug|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x64.ActiveCfg = Debug|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x64.Build.0 = Debug|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x64.Deploy.0 = Debug|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x86.ActiveCfg = Debug|Win32
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x86.Build.0 = Debug|Win32
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Debug|x86.Deploy.0 = Debug|Win32
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM.ActiveCfg = Release|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM.Build.0 = Release|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM.Deploy.0 = Release|ARM
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM64.ActiveCfg = Release|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM64.Build.0 = Release|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|ARM64.Deploy.0 = Release|ARM64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x64.ActiveCfg = Release|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x64.Build.0 = Release|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x64.Deploy.0 = Release|x64
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x86.ActiveCfg = Release|Win32
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x86.Build.0 = Release|Win32
		{58BA8DEC-BB05-4607-94DF-242B498AE5BC}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {52D18CE6-C821-41B3-8F39-16BB1017D6F8}
	EndGlobalSection
EndGlobal

```

`driver/pdrv/Callbacks.c`:

```c
#include <ntifs.h>
#include <ntstrsafe.h>
#include "Log.h"
#include "Callbacks.h"

/*
  Sorry for inconsistent types and naming. This code was ported from
  one driver to another and I have lost a track of it (little bit).
*/

// https://www.unknowncheats.me/forum/arma-2-a/175227-driver-disable-process-thread-object-callbacks.html

// https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes
#define DRIVER_ALT "327530"

/// <summary>
/// Dummy precallback
/// </summary>
/// <returns>Dummy status</returns>
OB_PREOP_CALLBACK_STATUS DummyObjectPreCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation) 
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	UNREFERENCED_PARAMETER(OperationInformation);
	return(OB_PREOP_SUCCESS);
}

/// <summary>
/// Dummy postcallback
/// </summary>
/// <returns>Dummy status</returns>
VOID DummyObjectPostCallback(PVOID RegistrationContext, POB_POST_OPERATION_INFORMATION OperationInformation) 
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	UNREFERENCED_PARAMETER(OperationInformation);
	return;
}

/// <summary>
/// Bruteforces offset
/// </summary>
/// <returns>Callback offset</returns>
QWORD GetCallbackListOffset() 
{
	POBJECT_TYPE procType = *PsProcessType;

	__try {
		if (procType && MmIsAddressValid((void*)procType)) {
			for (int i = 0xF8; i > 0; i -= 8) {
				QWORD first = *(QWORD*)((QWORD)procType + i), second = *(QWORD*)((QWORD)procType + (i + 8));
				if (first && MmIsAddressValid((void*)first) && second && MmIsAddressValid((void*)second)) {
					QWORD test1First = *(QWORD*)(first + 0x0), test1Second = *(QWORD*)(first + 0x8);
					if (test1First && MmIsAddressValid((void*)test1First) && test1Second && MmIsAddressValid((void*)test1Second)) {
						QWORD testObjectType = *(QWORD*)(first + 0x20);
						if (testObjectType == (QWORD)procType)
							return((QWORD)i);
					}
				}
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		Log("There was fatal error in %s", __FUNCTION__);
		return(0);
	}

	return 0;
}

/// <summary>
/// Disables all anticheat callsback to allow access from usermode
/// </summary>
/// <param name="oldCallbacks">Pointer to callback object to we can restore them later</param>
/// <returns>Callback offset</returns>
void Disable(POLD_CALLBACKS oldCallbacks) {
	POBJECT_TYPE procType = *PsProcessType;
	if (procType && MmIsAddressValid((void*)procType)) {
		__try {
			QWORD callbackListOffset = GetCallbackListOffset();
			if (callbackListOffset && MmIsAddressValid((void*)((QWORD)procType + callbackListOffset))) {
				LIST_ENTRY* callbackList = (LIST_ENTRY*)((QWORD)procType + callbackListOffset);
				if (callbackList->Flink && MmIsAddressValid((void*)callbackList->Flink)) {
					CALLBACK_ENTRY_ITEM* firstCallback = (CALLBACK_ENTRY_ITEM*)callbackList->Flink;
					CALLBACK_ENTRY_ITEM* curCallback = firstCallback;

					do {
						// Make sure the callback is valid.
						if (curCallback && MmIsAddressValid((void*)curCallback) && MmIsAddressValid((void*)curCallback->CallbackEntry)) {
							ANSI_STRING altitudeAnsi = { 0 };
							UNICODE_STRING altitudeUni = curCallback->CallbackEntry->Altitude;
							RtlUnicodeStringToAnsiString(&altitudeAnsi, &altitudeUni, 1);

							if (!strcmp(altitudeAnsi.Buffer, DRIVER_ALT)) {
								if (curCallback->PreOperation) {
									oldCallbacks->PreOperationProc = (QWORD)curCallback->PreOperation;
									curCallback->PreOperation = DummyObjectPreCallback;
								}
								if (curCallback->PostOperation) {
									oldCallbacks->PostOperationProc = (QWORD)curCallback->PostOperation;
									curCallback->PostOperation = DummyObjectPostCallback;
								}
								RtlFreeAnsiString(&altitudeAnsi);
								break;
							}

							RtlFreeAnsiString(&altitudeAnsi);
						}

						// Get the next callback.
						curCallback = (CALLBACK_ENTRY_ITEM*)(curCallback->CallbackList.Flink);
					} while (curCallback != firstCallback);
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			Log("There was fatal error in %s", __FUNCTION__);
			return;
		}
	}

	POBJECT_TYPE threadType = *PsThreadType;
	if (threadType && MmIsAddressValid((void*)threadType)) {
		__try {
			QWORD callbackListOffset = GetCallbackListOffset();
			if (callbackListOffset && MmIsAddressValid((void*)((QWORD)threadType + callbackListOffset))) {
				LIST_ENTRY* callbackList = (LIST_ENTRY*)((QWORD)threadType + callbackListOffset);
				if (callbackList->Flink && MmIsAddressValid((void*)callbackList->Flink)) {
					CALLBACK_ENTRY_ITEM* firstCallback = (CALLBACK_ENTRY_ITEM*)callbackList->Flink;
					CALLBACK_ENTRY_ITEM* curCallback = firstCallback;

					do {
						// Make sure the callback is valid.
						if (curCallback && MmIsAddressValid((void*)curCallback) && MmIsAddressValid((void*)curCallback->CallbackEntry)) {
							ANSI_STRING altitudeAnsi = { 0 };
							UNICODE_STRING altitudeUni = curCallback->CallbackEntry->Altitude;
							RtlUnicodeStringToAnsiString(&altitudeAnsi, &altitudeUni, 1);

							if (!strcmp(altitudeAnsi.Buffer, DRIVER_ALT)) {
								if (curCallback->PreOperation) {
									oldCallbacks->PreOperationThread = (QWORD)curCallback->PreOperation;
									curCallback->PreOperation = DummyObjectPreCallback;
								}
								if (curCallback->PostOperation) {
									oldCallbacks->PostOperationThread = (QWORD)curCallback->PostOperation;
									curCallback->PostOperation = DummyObjectPostCallback;
								}
								RtlFreeAnsiString(&altitudeAnsi);
								break;
							}

							RtlFreeAnsiString(&altitudeAnsi);
						}

						// Get the next callback.
						curCallback = (CALLBACK_ENTRY_ITEM*)(curCallback->CallbackList.Flink);
					} while (curCallback != firstCallback);
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			Log("There was fatal error in %s", __FUNCTION__);
			return;
		}
	}
}

/// <summary>
/// Restores anticheat callbacks
/// </summary>
/// <param name="oldCallbacks">Pointer to callback object</param>
/// <returns>Callback offset</returns>
void Restore(POLD_CALLBACKS oldCallbacks) {
	POBJECT_TYPE procType = *PsProcessType;
	if (procType && MmIsAddressValid((void*)procType)) {
		__try {
			QWORD callbackListOffset = GetCallbackListOffset();
			if (callbackListOffset && MmIsAddressValid((void*)((QWORD)procType + callbackListOffset))) {
				LIST_ENTRY* callbackList = (LIST_ENTRY*)((QWORD)procType + callbackListOffset);
				if (callbackList->Flink && MmIsAddressValid((void*)callbackList->Flink)) {
					CALLBACK_ENTRY_ITEM* firstCallback = (CALLBACK_ENTRY_ITEM*)callbackList->Flink;
					CALLBACK_ENTRY_ITEM* curCallback = firstCallback;

					do {
						// Make sure the callback is valid.
						if (curCallback && MmIsAddressValid((void*)curCallback) && MmIsAddressValid((void*)curCallback->CallbackEntry)) {
							ANSI_STRING altitudeAnsi = { 0 };
							UNICODE_STRING altitudeUni = curCallback->CallbackEntry->Altitude;
							RtlUnicodeStringToAnsiString(&altitudeAnsi, &altitudeUni, 1);

							if (!strcmp(altitudeAnsi.Buffer, DRIVER_ALT)) {
								if (curCallback->PreOperation && oldCallbacks->PreOperationProc)
									curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)oldCallbacks->PreOperationProc;
								if (curCallback->PostOperation && oldCallbacks->PostOperationProc)
									curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)oldCallbacks->PostOperationProc;
								RtlFreeAnsiString(&altitudeAnsi);
								break;
							}

							RtlFreeAnsiString(&altitudeAnsi);
						}

						// Get the next callback.
						curCallback = (CALLBACK_ENTRY_ITEM*)(curCallback->CallbackList.Flink);
					} while (curCallback != firstCallback);
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			Log("There was fatal error in %s", __FUNCTION__);
			return;
		}
	}

	POBJECT_TYPE threadType = *PsThreadType;
	if (threadType && MmIsAddressValid((void*)threadType)) {
		__try {
			QWORD callbackListOffset = GetCallbackListOffset();
			if (callbackListOffset && MmIsAddressValid((void*)((QWORD)threadType + callbackListOffset))) {
				LIST_ENTRY* callbackList = (LIST_ENTRY*)((QWORD)threadType + callbackListOffset);
				if (callbackList->Flink && MmIsAddressValid((void*)callbackList->Flink)) {
					CALLBACK_ENTRY_ITEM* firstCallback = (CALLBACK_ENTRY_ITEM*)callbackList->Flink;
					CALLBACK_ENTRY_ITEM* curCallback = firstCallback;

					do {
						// Make sure the callback is valid.
						if (curCallback && MmIsAddressValid((void*)curCallback) && MmIsAddressValid((void*)curCallback->CallbackEntry)) {
							ANSI_STRING altitudeAnsi = { 0 };
							UNICODE_STRING altitudeUni = curCallback->CallbackEntry->Altitude;
							RtlUnicodeStringToAnsiString(&altitudeAnsi, &altitudeUni, 1);

							if (!strcmp(altitudeAnsi.Buffer, DRIVER_ALT)) {
								if (curCallback->PreOperation && oldCallbacks->PreOperationThread)
									curCallback->PreOperation = (POB_PRE_OPERATION_CALLBACK)oldCallbacks->PreOperationThread;
								if (curCallback->PostOperation && oldCallbacks->PostOperationThread)
									curCallback->PostOperation = (POB_POST_OPERATION_CALLBACK)oldCallbacks->PostOperationThread;
								RtlFreeAnsiString(&altitudeAnsi);
								break;
							}

							RtlFreeAnsiString(&altitudeAnsi);
						}

						// Get the next callback.
						curCallback = (CALLBACK_ENTRY_ITEM*)(curCallback->CallbackList.Flink);
					} while (curCallback != firstCallback);
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			Log("There was fatal error in %s", __FUNCTION__);
			return;
		}
	}
}
```

`driver/pdrv/Callbacks.h`:

```h
#pragma once

#define WORD USHORT
#define QWORD UINT64

// OLD_CALLBACKS
typedef struct _OLD_CALLBACKS {
	QWORD PreOperationProc;
	QWORD PostOperationProc;
	QWORD PreOperationThread;
	QWORD PostOperationThread;
} OLD_CALLBACKS, * POLD_CALLBACKS;

// CALLBACK_ENTRY
typedef struct _CALLBACK_ENTRY {
	WORD Version; // 0x0
	WORD OperationRegistrationCount; // 0x2
	DWORD unk1; // 0x4
	PVOID RegistrationContext; // 0x8
	UNICODE_STRING Altitude; // 0x10
} CALLBACK_ENTRY, * PCALLBACK_ENTRY; // header size: 0x20 (0x6C if you count the array afterwards - this is only the header. The array of CALLBACK_ENTRY_ITEMs is useless.)

// CALLBACK_ENTRY_ITEM
typedef struct _CALLBACK_ENTRY_ITEM {
	LIST_ENTRY CallbackList; // 0x0
	OB_OPERATION Operations; // 0x10
	DWORD Active; // 0x14
	CALLBACK_ENTRY* CallbackEntry; // 0x18
	PVOID ObjectType; // 0x20
	POB_PRE_OPERATION_CALLBACK PreOperation; // 0x28
	POB_POST_OPERATION_CALLBACK PostOperation; // 0x30
	QWORD unk1; // 0x38
} CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM; // size: 0x40

void Disable(POLD_CALLBACKS oldCallbacks);
void Restore(POLD_CALLBACKS oldCallbacks);
```

`driver/pdrv/Driver.c`:

```c
/*
		   _
  _ __  __| |_ ___ __
 | '_ \/ _` | '_\ V /
 | .__/\__,_|_|  \_/
 |_|

 Copyright (c) 2019 Samuel Tulach - All rights reserved
 
 Used sources:
  - BlackBone Driver
    - (c) 2015 DarthTon
    - MIT
    - https://github.com/DarthTon/Blackbone

 Tested on Windows 10 x64 1909 18363.476
*/

#include "ntifs.h"
#include "ntstrsafe.h"
#include "Log.h"
#include "Structs.h"
#include "Private.h"
#include "Funcs.h"
#include "Imports.h"
#include "Callbacks.h"
#include "Utils.h"
#include "Callbacks.h"
#include "Shared.h"

#pragma warning( disable : 4152 )

static ULONG64 ArrTID[0x256] = { 0 };
static ULONG ThreadNumber = 0;
static OLD_CALLBACKS OldCallbacks = { 0 };
static HANDLE Threads[0x256] = { 0 };

/// <summary>
/// Function executed when our hooked func is called
/// </summary>
/// <param name="DontUse1">Dummy arg</param>
/// <param name="DontUse2">Dummy arg</param>
/// <param name="Code">Argument used to indentify request</param>
/// <returns>Status</returns>
NTSTATUS HookHandler(UINT_PTR DontUse1, UINT_PTR DontUse2, PULONG32 Code)
{
	UNREFERENCED_PARAMETER(DontUse1);
	UNREFERENCED_PARAMETER(DontUse2);

	Log("[+] Hook call with code %x", *Code);
	
	if (!(*Code == CODE_DISABLE || *Code == CODE_RESTORE))
	{
		Log("[-] Invalid code");
		return STATUS_CANCELLED;
	}

	SwitchMode(FALSE);

	if (*Code == CODE_DISABLE) 
	{
		// Get anticheat threads to manupulate them
		Log("[>] Gettting anticheat threads...");
		NTSTATUS status = GetDriverThreads("EasyAntiCheat.sys", &ThreadNumber, ArrTID);
		if (!NT_SUCCESS(status) || ThreadNumber == 0)
		{
			Log("[-] Failed to get anticheat threads");
		}
		Log("[+] Found %u threads", ThreadNumber);

		// Suspend threads
		Log("[>] Suspending threads...");
		for (ULONG i = 0; i < ThreadNumber; i++)
		{
			Threads[i] = OpenThread(THREAD_ALL_ACCESS, FALSE, (DWORD)ArrTID[i]);
			status = SuspendThread(Threads[i]);
			Log("[+] Thread with HANDLE %p suspended (%x)", Threads[i], status);
		}

		// Unregister callbacks
		Log("[>] Disabling anticheat callbacks...");
		Disable(&OldCallbacks);
		Log("[+] Callbacks disabled");
	}

	if (*Code == CODE_RESTORE) 
	{
		// TODO: Check if CODE_DISABLE was called first
		
		// Resume threads
		Log("[>] Resuming threads...");
		for (ULONG i = 0; i < ThreadNumber; i++)
		{
			Threads[i] = OpenThread(THREAD_ALL_ACCESS, FALSE, (DWORD)ArrTID[i]);
			ResumeThread(Threads[i]);
			Log("[+] Thread with HANDLE %p resumed", Threads[i]);
		}

		// Restore old callbacks
		Log("[>] Restoring anticheat callbacks...");
		Restore(&OldCallbacks);
		Log("[+] Callbacks restored");
	}
	
	SwitchMode(TRUE);

	return STATUS_SUCCESS;
}

/// <summary>
/// Driver main entry point
/// </summary>
/// <param name="DriverObject">DriverObject pointer</param>
/// <returns>Status</returns>
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath) 
{
	// Both are undefined when we manual map the driver
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);
	
	// Print some copyright because that's what matters the most
	Log("\n\npdrv\n");

	// Hook NtQueryIntervalProfile
	Log("[>] Hooking functions...");
	
	PVOID ntosbase = GetKernelBase(NULL);
	if (!ntosbase) 
	{
		Log("[-] Failed to get kernel base");
		return STATUS_CANCELLED;
	}
	Log("[+] Kernel base: %p", ntosbase);

	PVOID* dsptbl = (PVOID*)(RtlFindExportedRoutineByName(ntosbase, "HalDispatchTable"));
	if (!dsptbl)
	{
		Log("[-] Failed to get HalDispatchTable");
		return STATUS_CANCELLED;
	}
	Log("[+] HalDispatchTable: %p", dsptbl);

	dsptbl[1] = &HookHandler;

	Log("[+] Functions hoooked");
	
	// Return dummy status
	return STATUS_SUCCESS;
}

```

`driver/pdrv/Funcs.c`:

```c
#include <ntifs.h>
#include <ntstrsafe.h>
#include "Log.h"
#include "Structs.h"
#include "Private.h"
#include "Imports.h"
#include "Utils.h"
#include "Funcs.h"

#define SSDT_NTSUSPENDTHRED		438
#define SSDT_RESUMETHREAD		82
#define SSDT_TERMINATETHREAD	83

static NTSTATUS
(__fastcall* NtSuspendThread)(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
	);

static NTSTATUS
(__fastcall* NtTerminateThread)(
	__in HANDLE ThreadHandle,
	DWORD  dwExitCode
	);


static NTSTATUS
(__fastcall* NtResumeThread)(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
	);

/// <summary>
/// Open HANDLE to the thread
/// </summary>
/// <param name="dwDesiredAccess">Desired access</param>
/// <param name="bInheritHandle">Inherit handle</param>
/// <param name="dwThreadId">Thread ID</param>
/// <returns>HANDLE for thread</returns>
HANDLE OpenThread(DWORD dwDesiredAccess, BOOLEAN bInheritHandle, DWORD dwThreadId)
{
	OBJECT_ATTRIBUTES      ObjectAttributes = { 0, };
	CLIENT_ID              ClientId = { 0, };
	HANDLE                 hThread = NULL;
	NTSTATUS               Status;

	InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);

	if (bInheritHandle) {
		ObjectAttributes.Attributes = OBJ_INHERIT;
	}

	ClientId.UniqueProcess = NULL;
	ClientId.UniqueThread = (HANDLE)dwThreadId;

	Status = ZwOpenThread(&hThread,
		dwDesiredAccess,
		&ObjectAttributes,
		&ClientId);
	return hThread;
}

/// <summary>
/// Suspend (pause) thread
/// </summary>
/// <param name="ThreadHandle">HANDLE to desired thread</param>
/// <returns>Status</returns>
NTSTATUS SuspendThread(__in HANDLE ThreadHandle)
{
	NTSTATUS Status;
	fnNtSuspendThread suspth = (fnNtSuspendThread)(ULONG_PTR)GetSSDTEntry(SSDT_NTSUSPENDTHRED); // Warning! Latest Windows has changed this!
	Status = suspth(ThreadHandle, 0);
	return Status;
}

/// <summary>
/// Terminate thread
/// </summary>
/// <param name="ThreadHandle">HANDLE to desired thread</param>
/// <returns>Status</returns>
NTSTATUS TerminateThread(__in HANDLE ThreadHandle)
{
	NTSTATUS Status;
	fnNtTerminateThread termth = (fnNtTerminateThread)(ULONG_PTR)GetSSDTEntry(SSDT_TERMINATETHREAD);
	Status = termth(ThreadHandle, 0);
	return Status;
}

/// <summary>
/// Resume (unpause) thread
/// </summary>
/// <param name="ThreadHandle">HANDLE to desired thread</param>
/// <returns>Status</returns>
NTSTATUS ResumeThread(__in HANDLE ThreadHandle)
{
	NTSTATUS               Status;
	NtResumeThread = (NTSTATUS(__cdecl*)(HANDLE, PULONG))GetSSDTEntry(SSDT_RESUMETHREAD);
	Status = NtResumeThread(ThreadHandle, NULL);
	return Status;
}

/// <summary>
/// Get base address of system module
/// </summary>
/// <param name="ModuleName">Name of module</param>
/// <returns>Found address, 0 if not found</returns>
PVOID GetModuleBase(IN char* ModuleName, OUT ULONG64* BaseAddr, OUT ULONG* DriverSize)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;
	UNICODE_STRING routineName;

	RtlUnicodeStringInit(&routineName, L"NtOpenFile");

	// Protect from UserMode AV
	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		//DPRINT("BlackBone: %s: Invalid SystemModuleInformation size\n", __FUNCTION__);
		Log("[-] Invalid SystemModuleInformation size");
		return NULL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOL_TAG);
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

	if (NT_SUCCESS(status))
	{
		for (ULONG i = 0; i < pMods->NumberOfModules; i++)
		{
			// System routine is inside module
			if ((PVOID)pMods->Modules[i].ImageBase > (PVOID)0x8000000000000000)
			{
				char* pDrvName = (char*)(pMods->Modules[i].FullPathName) + pMods->Modules[i].OffsetToFileName;
				if (_stricmp(pDrvName, ModuleName) == 0) {
					*BaseAddr = (ULONG64)(pMods->Modules[i].ImageBase);
					*DriverSize = (ULONG64)(pMods->Modules[i].ImageSize);
					return (PVOID)(pMods->Modules[i].ImageBase);
				}
			}
		}
	}

	if (pMods)
		ExFreePoolWithTag(pMods, POOL_TAG);

	return 0;
}

// TODO: Comment
/// <summary>
/// ApcpQuerySystemProcessInformation
/// </summary>
/// <returns>Status</returns>
NTSTATUS ApcpQuerySystemProcessInformation(PSYSTEM_PROCESS_INFORMATION* SystemInfo)
{
	PSYSTEM_PROCESS_INFORMATION pBuffer = NULL;
	ULONG BufferSize = 0;
	ULONG RequiredSize = 0;

	NTSTATUS status = STATUS_SUCCESS;
	while ((status = ZwQuerySystemInformation(
		SystemProcessInformation,
		pBuffer,
		BufferSize,
		&RequiredSize//retn Length
	)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		BufferSize = RequiredSize;
		pBuffer = (PSYSTEM_PROCESS_INFORMATION)ExAllocatePool(PagedPool, BufferSize);
	}

	if (!NT_SUCCESS(status))
	{
		if (pBuffer != NULL)
		{
			ExFreePool(pBuffer);
		}

		return status;
	}
	*SystemInfo = pBuffer;
	return status;
}

// TODO: Comment
/// <summary>
/// Gets information about thread
/// </summary>
/// <returns>Status</returns>
NTSTATUS GetProcessThreadInfo(IN ULONG Pid, OUT ULONG* ThreadNuber, OUT PULONG64 Tid, OUT PULONG64 StartAddr)
{
	PEPROCESS pEProcess;
	PSYSTEM_PROCESS_INFORMATION OriginalSystemProcessInfo = NULL;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)Pid, &pEProcess);
	if (!NT_SUCCESS(status))
	{
		return status;
	}
	if (MmIsAddressValid(ThreadNuber) == 0)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	if (MmIsAddressValid(StartAddr) == 0)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	if (MmIsAddressValid(Tid) == 0)
	{
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	status = ApcpQuerySystemProcessInformation(&OriginalSystemProcessInfo);
	if (!NT_SUCCESS(status))
	{
		ObDereferenceObject(pEProcess);
		return status;
	}
	PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = OriginalSystemProcessInfo;
	status = STATUS_NOT_FOUND;
	do
	{
		if (SystemProcessInfo->UniqueProcessId == PsGetProcessId(pEProcess))
		{
			status = STATUS_SUCCESS;
			break;
		}

		SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)SystemProcessInfo + SystemProcessInfo->NextEntryOffset);
	} while (SystemProcessInfo->NextEntryOffset != 0);

	if (!NT_SUCCESS(status))
	{
		ObDereferenceObject(pEProcess);
		ExFreePool(OriginalSystemProcessInfo);
		return status;
	}
	*ThreadNuber = SystemProcessInfo->NumberOfThreads;

	for (ULONG Index = 0; Index < SystemProcessInfo->NumberOfThreads; ++Index)
	{
		HANDLE UniqueThreadId = SystemProcessInfo->Threads[Index].ClientId.UniqueThread;
		Tid[Index] = (ULONG64)UniqueThreadId;
		StartAddr[Index] = (ULONG64)SystemProcessInfo->Threads[Index].StartAddress;
	}

	ObDereferenceObject(pEProcess);
	return status;
}

/// <summary>
/// Gets driver threads
/// </summary>
/// <param name="DriverName">Name of module</param>
/// <param name="ThreadNuber">Number of threads</param>
/// <param name="Tid">Threads IDs (array)</param>
/// <returns>Found address, 0 if not found</returns>
NTSTATUS GetDriverThreads(char* DriverName, OUT ULONG* ThreadNuber, OUT PULONG64 Tid)
{
	ULONG64				DriverBaseAddr = 0;
	ULONG    			DriverSize = 0;
	ULONG				Number = 0;
	ULONG64              __Tid[0x256] = { 0 };
	ULONG64              __ThreadStartAddr[0x256] = { 0 };
	NTSTATUS            Status = STATUS_UNSUCCESSFUL;
	ULONG               Count = 0;
	GetModuleBase(DriverName, &DriverBaseAddr, &DriverSize);

	if (DriverBaseAddr == 0 || DriverSize == 0) {
		Log("[-] Driver base is 0");
		return Status;
	}
	Status = GetProcessThreadInfo(4, &Number, __Tid, __ThreadStartAddr);
	if (!NT_SUCCESS(Status)) {
		Log("[-] Failed to get thread info");
		return Status;
	}
	for (ULONG i = 0; i < Number; i++)
	{
		if (__ThreadStartAddr[i] >= DriverBaseAddr)
		{
			if (__ThreadStartAddr[i] <= DriverBaseAddr + DriverSize)
			{
				Tid[Count] = __Tid[i];
				Count++;
			}
		}
	}
	*ThreadNuber = Count;
	return STATUS_SUCCESS;
}
```

`driver/pdrv/Funcs.h`:

```h
#pragma once

typedef NTSTATUS(NTAPI* fnNtTerminateThread)(IN HANDLE ThreadHandle, IN NTSTATUS ExitStatus);
typedef NTSTATUS(NTAPI* fnNtSuspendThread)(IN HANDLE ThreadHandle, OUT PULONG PreviousSuspendCount);

HANDLE OpenThread(DWORD dwDesiredAccess, BOOLEAN bInheritHandle, DWORD dwThreadId);
NTSTATUS SuspendThread(__in HANDLE ThreadHandle);
NTSTATUS TerminateThread(__in HANDLE ThreadHandle);
NTSTATUS ResumeThread(HANDLE hThread);
PVOID GetModuleBase(IN char* ModuleName, OUT ULONG64* BaseAddr, OUT ULONG* DriverSize);
NTSTATUS ApcpQuerySystemProcessInformation(PSYSTEM_PROCESS_INFORMATION* SystemInfo);
NTSTATUS GetProcessThreadInfo(IN ULONG Pid, OUT ULONG* ThreadNuber, OUT PULONG64 Tid, OUT PULONG64 StartAddr);
NTSTATUS GetDriverThreads(char* DriverName, OUT ULONG* ThreadNuber, OUT PULONG64 Tid);
```

`driver/pdrv/Imports.h`:

```h
#pragma once

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);

NTSTATUS
NTAPI
ZwOpenThread(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PCLIENT_ID ClientId
);

NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
	_In_ PVOID ImageBase,
	_In_ PCCH RoutineNam
);

CHAR* PsGetProcessImageFileName(
	_In_ PEPROCESS Process
);
```

`driver/pdrv/Log.h`:

```h
#pragma once

#define Log(x, ...) DbgPrintEx(0, 0, x, __VA_ARGS__)
```

`driver/pdrv/Private.c`:

```c
#include <ntifs.h>
#include <ntstrsafe.h>
#include "Log.h"
#include "Structs.h"
#include "Imports.h"
#include "Utils.h"

PVOID g_KernelBase = NULL;
ULONG g_KernelSize = 0;
PSYSTEM_SERVICE_DESCRIPTOR_TABLE g_SSDT = NULL;

/// <summary>
/// Get ntoskrnl base address
/// </summary>
/// <param name="pSize">Size of module</param>
/// <returns>Found address, NULL if not found</returns>
PVOID GetKernelBase(OUT PULONG pSize)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;
	PVOID checkPtr = NULL;
	UNICODE_STRING routineName;

	// Already found
	if (g_KernelBase != NULL)
	{
		if (pSize)
			*pSize = g_KernelSize;
		return g_KernelBase;
	}

	RtlUnicodeStringInit(&routineName, L"NtOpenFile");

	checkPtr = MmGetSystemRoutineAddress(&routineName);
	if (checkPtr == NULL)
		return NULL;

	// Protect from UserMode AV
	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		//DPRINT("BlackBone: %s: Invalid SystemModuleInformation size\n", __FUNCTION__);
		Log("[-] Invalid SystemModuleInformation size");
		return NULL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOL_TAG);
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

	if (NT_SUCCESS(status))
	{
		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

		for (ULONG i = 0; i < pMods->NumberOfModules; i++)
		{
			// System routine is inside module
			if (checkPtr >= pMod[i].ImageBase &&
				checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
			{
				g_KernelBase = pMod[i].ImageBase;
				g_KernelSize = pMod[i].ImageSize;
				if (pSize)
					*pSize = g_KernelSize;
				break;
			}
		}
	}

	if (pMods)
		ExFreePoolWithTag(pMods, POOL_TAG);

	return g_KernelBase;
}

/// <summary>
/// Gets SSDT base - KiServiceTable
/// </summary>
/// <returns>SSDT base, NULL if not found</returns>
PSYSTEM_SERVICE_DESCRIPTOR_TABLE GetSSDTBase()
{
	PUCHAR ntosBase = GetKernelBase(NULL);

	// Already found
	if (g_SSDT != NULL)
		return g_SSDT;

	if (!ntosBase)
		return NULL;

	PIMAGE_NT_HEADERS pHdr = RtlImageNtHeader(ntosBase);
	PIMAGE_SECTION_HEADER pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + 1);
	for (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec < pFirstSec + pHdr->FileHeader.NumberOfSections; pSec++)
	{
		// Non-paged, non-discardable, readable sections
		// Probably still not fool-proof enough...
		if (pSec->Characteristics & IMAGE_SCN_MEM_NOT_PAGED &&
			pSec->Characteristics & IMAGE_SCN_MEM_EXECUTE &&
			!(pSec->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) &&
			(*(PULONG)pSec->Name != 'TINI') &&
			(*(PULONG)pSec->Name != 'EGAP'))
		{
			PVOID pFound = NULL;

			// KiSystemServiceRepeat pattern
			UCHAR pattern[] = "\x4c\x8d\x15\xcc\xcc\xcc\xcc\x4c\x8d\x1d\xcc\xcc\xcc\xcc\xf7";
			NTSTATUS status = SearchPattern(pattern, 0xCC, sizeof(pattern) - 1, ntosBase + pSec->VirtualAddress, pSec->Misc.VirtualSize, &pFound);
			if (NT_SUCCESS(status))
			{
				g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + 3) + 7);
				//DPRINT( "BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\n", __FUNCTION__, g_SSDT );
				return g_SSDT;
			}
		}
	}

	return NULL;
}

/// <summary>
/// Gets the SSDT entry address by index.
/// </summary>
/// <param name="index">Service index</param>
/// <returns>Found service address, NULL if not found</returns>
PVOID GetSSDTEntry(IN ULONG index)
{
	ULONG size = 0;
	PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = GetSSDTBase();
	PVOID pBase = GetKernelBase(&size);

	if (pSSDT && pBase)
	{
		// Index range check
		if (index > pSSDT->NumberOfServices)
			return NULL;

		return (PUCHAR)pSSDT->ServiceTableBase + (((PLONG)pSSDT->ServiceTableBase)[index] >> 4);
	}

	return NULL;
}
```

`driver/pdrv/Private.h`:

```h
#pragma once

PVOID GetKernelBase(OUT PULONG pSize);
PSYSTEM_SERVICE_DESCRIPTOR_TABLE GetSSDTBase();
PVOID GetSSDTEntry(IN ULONG index);
```

`driver/pdrv/Shared.h`:

```h
#pragma once

#define CODE_DISABLE 0x1601
#define CODE_RESTORE 0x1602

#define PROC_NAME "r5apex.exe"
#define DRV_NAME "EasyAntiCheat.sys"
```

`driver/pdrv/Structs.h`:

```h
#pragma once

#define POOL_TAG 'anoB'

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.
#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP
#define IMAGE_SCN_MEM_FARDATA                0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_MEM_LOCKED                 0x00040000
#define IMAGE_SCN_MEM_PRELOAD                0x00080000

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //
#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //
#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //
#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //
#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //
#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //
#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //
// Unused                                    0x00F00000
#define IMAGE_SCN_ALIGN_MASK                 0x00F00000

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

typedef struct _IMAGE_FILE_HEADER // Size=20
{
	USHORT Machine;
	USHORT NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	USHORT SizeOfOptionalHeader;
	USHORT Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
	USHORT Magic;
	UCHAR MajorLinkerVersion;
	UCHAR MinorLinkerVersion;
	ULONG SizeOfCode;
	ULONG SizeOfInitializedData;
	ULONG SizeOfUninitializedData;
	ULONG AddressOfEntryPoint;
	ULONG BaseOfCode;
	ULONGLONG ImageBase;
	ULONG SectionAlignment;
	ULONG FileAlignment;
	USHORT MajorOperatingSystemVersion;
	USHORT MinorOperatingSystemVersion;
	USHORT MajorImageVersion;
	USHORT MinorImageVersion;
	USHORT MajorSubsystemVersion;
	USHORT MinorSubsystemVersion;
	ULONG Win32VersionValue;
	ULONG SizeOfImage;
	ULONG SizeOfHeaders;
	ULONG CheckSum;
	USHORT Subsystem;
	USHORT DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	ULONG LoaderFlags;
	ULONG NumberOfRvaAndSizes;
	struct _IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
	ULONG Signature;
	struct _IMAGE_FILE_HEADER FileHeader;
	struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER
{
	UCHAR  Name[8];
	union
	{
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	USHORT  NumberOfRelocations;
	USHORT  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _SYSTEM_SERVICE_DESCRIPTOR_TABLE
{
	PULONG_PTR ServiceTableBase;
	PULONG ServiceCounterTableBase;
	ULONG_PTR NumberOfServices;
	PUCHAR ParamTableBase;
} SYSTEM_SERVICE_DESCRIPTOR_TABLE, * PSYSTEM_SERVICE_DESCRIPTOR_TABLE;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _TEB* PTEB;

// private
typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
	SYSTEM_THREAD_INFORMATION ThreadInfo;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID Win32StartAddress;
	PTEB TebBase; // since VISTA
	ULONG_PTR Reserved2;
	ULONG_PTR Reserved3;
	ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, * PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
	ULONG HardFaultCount; // since WIN7
	ULONG NumberOfThreadsHighWatermark; // since WIN7
	ULONGLONG CycleTime; // since WIN7
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;
```

`driver/pdrv/Utils.c`:

```c
#include <ntifs.h>
#include "Structs.h"
#include "Imports.h"
#include "Log.h"

/// <summary>
/// Search for pattern
/// </summary>
/// <param name="pattern">Pattern to search for</param>
/// <param name="wildcard">Used wildcard</param>
/// <param name="len">Pattern length</param>
/// <param name="base">Base address for searching</param>
/// <param name="size">Address range to search in</param>
/// <param name="ppFound">Found location</param>
/// <returns>Status code</returns>
NTSTATUS SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_INVALID_PARAMETER;

	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

/// <summary>
/// Gets name of process main module
/// </summary>
/// <param name="pid">PID of process</param>
/// <returns>Pointer to name</returns>
char* GetName(IN HANDLE pid)
{
	PEPROCESS Process;
	if (PsLookupProcessByProcessId(pid, &Process) == STATUS_INVALID_PARAMETER)
	{
		return "invalid";
	}
	return (CHAR*)PsGetProcessImageFileName(Process);
}

/// <summary>
/// Unsecure! Compares two char pointer and if one is part of another it returns true
/// </summary>
/// <param name="w1">First char pointer</param>
/// <param name="w2">Second char pointer</param>
/// <returns>Boolean</returns>
BOOLEAN IsPartOf(IN char* w1, IN char* w2)
{
	int i = 0;
	int j = 0;

	while (w1[i] != '\0') {
		if (w1[i] == w2[j])
		{
			while (w1[i] == w2[j] && w2[j] != '\0')
			{
				j++;
				i++;
			}
			if (w2[j] == '\0') {
				return TRUE;
			}
			j = 0;
		}
		i++;
	}
	return FALSE;
}

/// <summary>
/// Switch current thread mode
/// </summary>
/// <param name="Mode">Usermode if true</param>
/// <returns>Boolean</returns>
void SwitchMode(IN BOOLEAN Mode) 
{
	Log("[>] Switching mode...");
	PUCHAR pprevmode = (PUCHAR)PsGetCurrentThread() + 0x232; // PrevMode from blackbone
	UCHAR prevmode = *pprevmode;
	if (Mode) 
	{
		*pprevmode = UserMode;
	}
	else 
	{
		*pprevmode = KernelMode;
	}
	Log("[+] Switched mode (from %u, to %u)", prevmode, *pprevmode);
}
```

`driver/pdrv/Utils.h`:

```h
#pragma once

NTSTATUS SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound);
char* GetName(IN HANDLE pid);
BOOLEAN IsPartOf(IN char* w1, IN char* w2);
void SwitchMode(IN BOOLEAN Restore);
```

`driver/pdrv/pdrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{58BA8DEC-BB05-4607-94DF-242B498AE5BC}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>pdrv</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Callbacks.c" />
    <ClCompile Include="Driver.c" />
    <ClCompile Include="Funcs.c" />
    <ClCompile Include="Private.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Callbacks.h" />
    <ClInclude Include="Funcs.h" />
    <ClInclude Include="Imports.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="ntddk.h" />
    <ClInclude Include="ntifs.h" />
    <ClInclude Include="ntnls.h" />
    <ClInclude Include="ntstrsafe.h" />
    <ClInclude Include="Private.h" />
    <ClInclude Include="Shared.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driver/pdrv/pdrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Callbacks.c" />
    <ClCompile Include="Driver.c" />
    <ClCompile Include="Funcs.c" />
    <ClCompile Include="Private.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Callbacks.h" />
    <ClInclude Include="Funcs.h" />
    <ClInclude Include="Imports.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="Private.h" />
    <ClInclude Include="Shared.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="ntifs.h">
      <Filter>wdsk</Filter>
    </ClInclude>
    <ClInclude Include="ntnls.h">
      <Filter>wdsk</Filter>
    </ClInclude>
    <ClInclude Include="ntstrsafe.h">
      <Filter>wdsk</Filter>
    </ClInclude>
    <ClInclude Include="ntddk.h">
      <Filter>wdsk</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="wdsk">
      <UniqueIdentifier>{04920e27-6fcd-4cd7-b2c2-df1faddfe6f7}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`driver/pdrv/pdrv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`driver/pdrv/x64/Debug/pdrv.log`:

```log
C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Microsoft\VC\v170\Microsoft.CppBuild.targets(490,5): error MSB8040: Spectre-mitigated libraries are required for this project. Install them from the Visual Studio installer (Individual components tab) for any toolsets and architectures being used. Learn more: https://aka.ms/Ofhn4c

```

`driver/pdrv/x64/Release/pdrv.log`:

```log
  Callbacks.c
C:\Users\kcxac\Documents\Eac inje\pdrv\pdrv\Callbacks.c(1,10): fatal  error C1083: Cannot open include file: 'ntifs.h': No such file or directory
  Driver.c
C:\Users\kcxac\Documents\Eac inje\pdrv\pdrv\Driver.c(19,10): fatal  error C1083: Cannot open include file: 'ntifs.h': No such file or directory
  Funcs.c
C:\Users\kcxac\Documents\Eac inje\pdrv\pdrv\Funcs.c(1,10): fatal  error C1083: Cannot open include file: 'ntifs.h': No such file or directory
  Private.c
C:\Users\kcxac\Documents\Eac inje\pdrv\pdrv\Private.c(1,10): fatal  error C1083: Cannot open include file: 'ntifs.h': No such file or directory
  Utils.c
C:\Users\kcxac\Documents\Eac inje\pdrv\pdrv\Utils.c(1,10): fatal  error C1083: Cannot open include file: 'ntifs.h': No such file or directory
  Generating Code...

```

`driver/pdrv/x64/Release/pdrv.tlog/pdrv.lastbuildstate`:

```lastbuildstate
PlatformToolSet=WindowsKernelModeDriver10.0:VCToolArchitecture=Native64Bit:VCToolsVersion=14.34.31933:TargetPlatformVersion=10.0.22621.0:
Release|x64|C:\Users\kcxac\Documents\Eac inje\pdrv\|

```