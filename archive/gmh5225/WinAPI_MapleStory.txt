Project Path: arc_gmh5225_WinAPI_MapleStory_ugaljbu9

Source Tree:

```txt
arc_gmh5225_WinAPI_MapleStory_ugaljbu9
├── GameClient
│   ├── GameClient.h
│   ├── GameClient.ico
│   ├── GameClient.rc
│   ├── GameClient.vcxproj
│   ├── GameClient.vcxproj.filters
│   ├── Resource.h
│   ├── Unity
│   │   ├── unity_5A0O4K845Z5PJ068.cpp
│   │   ├── unity_7H55SN0SWYCZX1GR.cpp
│   │   ├── unity_82JTMKED0AVROIH4.cpp
│   │   ├── unity_EE1VTZPILABOSQLZ.cpp
│   │   ├── unity_EZQWBK0BCO39R0YP.cpp
│   │   ├── unity_FESXYYTMV2H6VOY7.cpp
│   │   ├── unity_HWAN4XAD0O5AR76X.cpp
│   │   ├── unity_I4PPU87D95RZPHFA.cpp
│   │   ├── unity_NMEJAB13KAC13461.cpp
│   │   ├── unity_OG212SEFP9QWTROH.cpp
│   │   ├── unity_OM7CFU7WRN9LERH9.cpp
│   │   ├── unity_RO1UJTUPUYEOM3ZU.cpp
│   │   ├── unity_RV4LWHYO8CTRFWH2.cpp
│   │   └── unity_VCG54Q6CEIJO9PA1.cpp
│   ├── define.h
│   ├── enum.h
│   ├── framework.h
│   ├── func.cpp
│   ├── func.h
│   ├── main.cpp
│   ├── pch.cpp
│   ├── pch.h
│   ├── qAnimation.cpp
│   ├── qAnimation.h
│   ├── qAnimator.cpp
│   ├── qAnimator.h
│   ├── qAsset.cpp
│   ├── qAsset.h
│   ├── qAssetMgr.cpp
│   ├── qAssetMgr.h
│   ├── qBackground_boss1.cpp
│   ├── qBackground_boss1.h
│   ├── qBackground_boss2.cpp
│   ├── qBackground_boss2.h
│   ├── qBackground_stage1.cpp
│   ├── qBackground_stage1.h
│   ├── qBackground_stage2.cpp
│   ├── qBackground_stage2.h
│   ├── qBackground_start.cpp
│   ├── qBackground_start.h
│   ├── qBlueDeadState.cpp
│   ├── qBlueDeadState.h
│   ├── qBlueIdleState.cpp
│   ├── qBlueIdleState.h
│   ├── qBlueMoveState.cpp
│   ├── qBlueMoveState.h
│   ├── qBoss.cpp
│   ├── qBoss.h
│   ├── qBossBallState.cpp
│   ├── qBossBallState.h
│   ├── qBossDeadState.cpp
│   ├── qBossDeadState.h
│   ├── qBossEffect_ball.cpp
│   ├── qBossEffect_ball.h
│   ├── qBossEffect_firebird.cpp
│   ├── qBossEffect_firebird.h
│   ├── qBossEffect_genesis.cpp
│   ├── qBossEffect_genesis.h
│   ├── qBossEffect_tornado.cpp
│   ├── qBossEffect_tornado.h
│   ├── qBossFirebirdState.cpp
│   ├── qBossFirebirdState.h
│   ├── qBossGenesisState.cpp
│   ├── qBossGenesisState.h
│   ├── qBossHP.cpp
│   ├── qBossHP.h
│   ├── qBossHUD.cpp
│   ├── qBossHUD.h
│   ├── qBossIdleState.cpp
│   ├── qBossIdleState.h
│   ├── qBossSkill_ball_left.cpp
│   ├── qBossSkill_ball_left.h
│   ├── qBossSkill_ball_right.cpp
│   ├── qBossSkill_ball_right.h
│   ├── qBossSkill_firebird.cpp
│   ├── qBossSkill_firebird.h
│   ├── qBossSkill_genesis.cpp
│   ├── qBossSkill_genesis.h
│   ├── qBossSkill_tornado.cpp
│   ├── qBossSkill_tornado.h
│   ├── qBossTornadoState.cpp
│   ├── qBossTornadoState.h
│   ├── qButton.cpp
│   ├── qButton.h
│   ├── qCamera.cpp
│   ├── qCamera.h
│   ├── qCollider.cpp
│   ├── qCollider.h
│   ├── qCollisionMgr.cpp
│   ├── qCollisionMgr.h
│   ├── qComponent.cpp
│   ├── qComponent.h
│   ├── qDamage_attack.cpp
│   ├── qDamage_attack.h
│   ├── qDamage_magic.cpp
│   ├── qDamage_magic.h
│   ├── qDamage_miss.cpp
│   ├── qDamage_miss.h
│   ├── qDamage_missile.cpp
│   ├── qDamage_missile.h
│   ├── qDamage_physical.cpp
│   ├── qDamage_physical.h
│   ├── qDamage_slash.cpp
│   ├── qDamage_slash.h
│   ├── qDamage_special.cpp
│   ├── qDamage_special.h
│   ├── qDbgRender.cpp
│   ├── qDbgRender.h
│   ├── qDummy_blue.cpp
│   ├── qDummy_blue.h
│   ├── qDummy_red.cpp
│   ├── qDummy_red.h
│   ├── qEffect_attack.cpp
│   ├── qEffect_attack.h
│   ├── qEffect_missile.cpp
│   ├── qEffect_missile.h
│   ├── qEffect_slash.cpp
│   ├── qEffect_slash.h
│   ├── qEffect_special.cpp
│   ├── qEffect_special.h
│   ├── qEngine.cpp
│   ├── qEngine.h
│   ├── qEntity.cpp
│   ├── qEntity.h
│   ├── qExp.cpp
│   ├── qExp.h
│   ├── qFSM.cpp
│   ├── qFSM.h
│   ├── qForce.cpp
│   ├── qForce.h
│   ├── qGuideMissile.cpp
│   ├── qGuideMissile.h
│   ├── qKeyMgr.cpp
│   ├── qKeyMgr.h
│   ├── qLevel.cpp
│   ├── qLevel.h
│   ├── qLevelMgr.cpp
│   ├── qLevelMgr.h
│   ├── qLevel_Editor.cpp
│   ├── qLevel_Editor.h
│   ├── qLevel_Logo.cpp
│   ├── qLevel_Logo.h
│   ├── qLevel_Start.cpp
│   ├── qLevel_Start.h
│   ├── qLevel_boss1.cpp
│   ├── qLevel_boss1.h
│   ├── qLevel_boss2.cpp
│   ├── qLevel_boss2.h
│   ├── qLevel_stage1.cpp
│   ├── qLevel_stage1.h
│   ├── qLevel_stage2.cpp
│   ├── qLevel_stage2.h
│   ├── qLogo.cpp
│   ├── qLogo.h
│   ├── qMenu.cpp
│   ├── qMenu.h
│   ├── qMinimap_boss1.cpp
│   ├── qMinimap_boss1.h
│   ├── qMinimap_boss2.cpp
│   ├── qMinimap_boss2.h
│   ├── qMinimap_stage1.cpp
│   ├── qMinimap_stage1.h
│   ├── qMinimap_stage2.cpp
│   ├── qMinimap_stage2.h
│   ├── qMissile.cpp
│   ├── qMissile.h
│   ├── qMonster_blue.cpp
│   ├── qMonster_blue.h
│   ├── qMonster_red.cpp
│   ├── qMonster_red.h
│   ├── qObj.cpp
│   ├── qObj.h
│   ├── qPathMgr.cpp
│   ├── qPathMgr.h
│   ├── qPlatform.cpp
│   ├── qPlatform.h
│   ├── qPlayer.cpp
│   ├── qPlayer.h
│   ├── qPlayerHP.cpp
│   ├── qPlayerHP.h
│   ├── qPortal.cpp
│   ├── qPortal.h
│   ├── qRedDeadState.cpp
│   ├── qRedDeadState.h
│   ├── qRedIdleState.cpp
│   ├── qRedIdleState.h
│   ├── qRedMoveState.cpp
│   ├── qRedMoveState.h
│   ├── qRespawnMgr.cpp
│   ├── qRespawnMgr.h
│   ├── qRigidbody.cpp
│   ├── qRigidbody.h
│   ├── qRope.cpp
│   ├── qRope.h
│   ├── qSelectObj.cpp
│   ├── qSelectObj.h
│   ├── qSkill_attack_left.cpp
│   ├── qSkill_attack_left.h
│   ├── qSkill_attack_right.cpp
│   ├── qSkill_attack_right.h
│   ├── qSkill_buff.cpp
│   ├── qSkill_buff.h
│   ├── qSkill_doublejump_left.cpp
│   ├── qSkill_doublejump_left.h
│   ├── qSkill_doublejump_right.cpp
│   ├── qSkill_doublejump_right.h
│   ├── qSkill_highjump.cpp
│   ├── qSkill_highjump.h
│   ├── qSkill_missile_ball_left.cpp
│   ├── qSkill_missile_ball_left.h
│   ├── qSkill_missile_ball_right.cpp
│   ├── qSkill_missile_ball_right.h
│   ├── qSkill_missile_left.cpp
│   ├── qSkill_missile_left.h
│   ├── qSkill_missile_right.cpp
│   ├── qSkill_missile_right.h
│   ├── qSkill_slash_left.cpp
│   ├── qSkill_slash_left.h
│   ├── qSkill_slash_right.cpp
│   ├── qSkill_slash_right.h
│   ├── qSkill_special_left.cpp
│   ├── qSkill_special_left.h
│   ├── qSkill_special_right.cpp
│   ├── qSkill_special_right.h
│   ├── qSound.cpp
│   ├── qSound.h
│   ├── qSoundMgr.cpp
│   ├── qSoundMgr.h
│   ├── qSpawner_blue1.cpp
│   ├── qSpawner_blue1.h
│   ├── qSpawner_blue2.cpp
│   ├── qSpawner_blue2.h
│   ├── qSpawner_blue3.cpp
│   ├── qSpawner_blue3.h
│   ├── qSpawner_red1.cpp
│   ├── qSpawner_red1.h
│   ├── qSpawner_red2.cpp
│   ├── qSpawner_red2.h
│   ├── qState.cpp
│   ├── qState.h
│   ├── qTaskMgr.cpp
│   ├── qTaskMgr.h
│   ├── qTexture.cpp
│   ├── qTexture.h
│   ├── qTile.cpp
│   ├── qTile.h
│   ├── qTileMap.cpp
│   ├── qTileMap.h
│   ├── qTimeMgr.cpp
│   ├── qTimeMgr.h
│   ├── qUI.cpp
│   ├── qUI.h
│   ├── qUIMgr.cpp
│   ├── qUIMgr.h
│   ├── small.ico
│   ├── struct.h
│   └── targetver.h
├── OutputFile
│   └── content
│       ├── animation
│       │   ├── boss
│       │   │   ├── ball
│       │   │   │   ├── BossBallLeft.anim
│       │   │   │   └── BossBallRight.anim
│       │   │   ├── dead
│       │   │   │   ├── BossDeadLeft.anim
│       │   │   │   └── BossDeadRight.anim
│       │   │   ├── firebird
│       │   │   │   ├── BossFirebirdLeft.anim
│       │   │   │   └── BossFirebirdRight.anim
│       │   │   ├── genesis
│       │   │   │   ├── BossGenesisLeft.anim
│       │   │   │   └── BossGenesisRight.anim
│       │   │   ├── idle
│       │   │   │   ├── BossIdleLeft.anim
│       │   │   │   └── BossIdleRight.anim
│       │   │   └── tornado
│       │   │       ├── BossTornadoLeft.anim
│       │   │       └── BossTornadoRight.anim
│       │   ├── boss_damage
│       │   │   ├── magic
│       │   │   │   └── DamageMagic.anim
│       │   │   └── physical
│       │   │       └── DamagePhysical.anim
│       │   ├── boss_effect
│       │   │   ├── ball
│       │   │   │   └── BallEffect.anim
│       │   │   ├── firebird
│       │   │   │   └── FirebirdEffect.anim
│       │   │   ├── genesis
│       │   │   │   └── GenesisEffect.anim
│       │   │   └── tornado
│       │   │       └── TornadoEffect.anim
│       │   ├── boss_skill
│       │   │   ├── ball
│       │   │   │   ├── BossBallLeft.anim
│       │   │   │   ├── BossSkillBallLeft.anim
│       │   │   │   └── BossSkillBallRight.anim
│       │   │   ├── firebird
│       │   │   │   └── BossSkillFirebird.anim
│       │   │   ├── genesis
│       │   │   │   └── BossSkillGenesis.anim
│       │   │   └── tornado
│       │   │       └── BossSkillTornado.anim
│       │   ├── bossenter
│       │   │   └── BossEnter.anim
│       │   ├── damage
│       │   │   ├── attack
│       │   │   │   └── DamageAttack.anim
│       │   │   ├── miss
│       │   │   │   └── DamageMiss.anim
│       │   │   ├── missile
│       │   │   │   └── DamageMissile.anim
│       │   │   ├── slash
│       │   │   │   └── DamageSlash.anim
│       │   │   └── special
│       │   │       └── DamageSpecial.anim
│       │   ├── effect
│       │   │   ├── attack
│       │   │   │   └── AttackEffect.anim
│       │   │   ├── missile
│       │   │   │   └── MissileEffect.anim
│       │   │   ├── slash
│       │   │   │   └── SlashEffect.anim
│       │   │   └── special
│       │   │       └── SpecialEffect.anim
│       │   ├── logo
│       │   │   └── Logo.anim
│       │   ├── monster
│       │   │   ├── blue
│       │   │   │   ├── dead
│       │   │   │   │   ├── BlueDeadLeft.anim
│       │   │   │   │   └── BlueDeadRight.anim
│       │   │   │   ├── idle
│       │   │   │   │   ├── BlueIdleLeft.anim
│       │   │   │   │   └── BlueIdleRight.anim
│       │   │   │   └── move
│       │   │   │       ├── BlueMoveLeft.anim
│       │   │   │       └── BlueMoveRight.anim
│       │   │   └── red
│       │   │       ├── dead
│       │   │       │   ├── RedDeadLeft.anim
│       │   │       │   └── RedDeadRight.anim
│       │   │       ├── idle
│       │   │       │   ├── RedIdleLeft.anim
│       │   │       │   └── RedIdleRight.anim
│       │   │       └── move
│       │   │           ├── RedMoveLeft.anim
│       │   │           └── RedMoveRight.anim
│       │   ├── player
│       │   │   ├── attack
│       │   │   │   ├── PlayerAttackLeft.anim
│       │   │   │   └── PlayerAttackRight.anim
│       │   │   ├── down
│       │   │   │   ├── PlayerDownLeft.anim
│       │   │   │   └── PlayerDownRight.anim
│       │   │   ├── down_attack
│       │   │   │   ├── PlayerDownAttackLeft.anim
│       │   │   │   └── PlayerDownAttackRight.anim
│       │   │   ├── idle
│       │   │   │   ├── PlayerIdleLeft.anim
│       │   │   │   └── PlayerIdleRight.anim
│       │   │   ├── jump
│       │   │   │   ├── PlayerJumpLeft.anim
│       │   │   │   └── PlayerJumpRight.anim
│       │   │   ├── missile
│       │   │   │   ├── PlayerMissileLeft.anim
│       │   │   │   └── PlayerMissileRight.anim
│       │   │   ├── move
│       │   │   │   ├── PlayerMoveLeft.anim
│       │   │   │   └── PlayerMoveRight.anim
│       │   │   ├── rope
│       │   │   │   └── PlayerRope.anim
│       │   │   ├── slash
│       │   │   │   ├── PlayerSlashLeft.anim
│       │   │   │   └── PlayerSlashRight.anim
│       │   │   └── special
│       │   │       ├── PlayerSpecialLeft.anim
│       │   │       └── PlayerSpecialRight.anim
│       │   ├── skill
│       │   │   ├── attack
│       │   │   │   ├── AttackLeft.anim
│       │   │   │   └── AttackRight.anim
│       │   │   ├── buff
│       │   │   │   └── Buff.anim
│       │   │   ├── doublejump
│       │   │   │   ├── DoubleJumpLeft.anim
│       │   │   │   └── DoubleJumpRight.anim
│       │   │   ├── highjump
│       │   │   │   └── HighJump.anim
│       │   │   ├── missile
│       │   │   │   ├── MissileBallLeft.anim
│       │   │   │   ├── MissileBallRight.anim
│       │   │   │   ├── MissileLeft.anim
│       │   │   │   └── MissileRight.anim
│       │   │   ├── slash
│       │   │   │   ├── SlashLeft.anim
│       │   │   │   └── SlashRight.anim
│       │   │   └── special
│       │   │       ├── SpecialLeft.anim
│       │   │       └── SpecialRight.anim
│       │   └── start
│       │       └── Start.anim
│       ├── edit
│       │   ├── boss1
│       │   │   ├── monster_blue
│       │   │   │   └── monster_blue.dat
│       │   │   ├── monster_red
│       │   │   │   └── monster_red.dat
│       │   │   ├── platform
│       │   │   │   └── platform.dat
│       │   │   ├── portal
│       │   │   │   └── portal.dat
│       │   │   └── rope
│       │   │       └── rope.dat
│       │   ├── boss2
│       │   │   ├── monster_blue
│       │   │   │   └── monster_blue.dat
│       │   │   ├── monster_red
│       │   │   │   └── monster_red.dat
│       │   │   ├── platform
│       │   │   │   └── platform.dat
│       │   │   ├── portal
│       │   │   │   └── portal.dat
│       │   │   └── rope
│       │   │       └── rope.dat
│       │   ├── stage1
│       │   │   ├── monster_blue
│       │   │   │   └── monster_blue.dat
│       │   │   ├── monster_red
│       │   │   │   └── monster_red.dat
│       │   │   ├── platform
│       │   │   │   └── platform.dat
│       │   │   ├── portal
│       │   │   │   └── portal.dat
│       │   │   └── rope
│       │   │       └── rope.dat
│       │   └── stage2
│       │       ├── monster_blue
│       │       │   └── monster_blue.dat
│       │       ├── monster_red
│       │       │   └── monster_red.dat
│       │       ├── platform
│       │       │   └── platform.dat
│       │       ├── portal
│       │       │   └── portal.dat
│       │       └── rope
│       │           └── rope.dat
│       ├── platform
│       │   ├── platform.dat
│       │   └── platform.plat
│       ├── sound
│       │   ├── boss
│       │   │   ├── ball.wav
│       │   │   ├── dead.wav
│       │   │   ├── firebird.wav
│       │   │   ├── genesis.wav
│       │   │   └── tornado.wav
│       │   ├── effect
│       │   │   ├── attack.wav
│       │   │   ├── missile.wav
│       │   │   ├── slash.wav
│       │   │   └── special.wav
│       │   ├── level
│       │   │   ├── boss1.wav
│       │   │   ├── boss2.wav
│       │   │   ├── logo.wav
│       │   │   ├── stage1.wav
│       │   │   ├── stage2.wav
│       │   │   └── start.wav
│       │   ├── monster
│       │   │   └── die.wav
│       │   └── skill
│       │       ├── attack.wav
│       │       ├── buff.wav
│       │       ├── jump.wav
│       │       ├── missile.wav
│       │       ├── slash.wav
│       │       └── special.wav
│       └── texture
│           ├── boss_damage
│           │   ├── magic
│           │   │   └── magic.png
│           │   └── physical
│           │       └── physical.png
│           ├── boss_effect
│           │   ├── ball
│           │   │   └── ball.png
│           │   ├── firebird
│           │   │   └── firebird.png
│           │   ├── genesis
│           │   │   └── genesis.png
│           │   └── tornado
│           │       └── tornado.png
│           ├── boss_skill
│           │   ├── ball
│           │   │   ├── ball_left.png
│           │   │   └── ball_right.png
│           │   ├── firebird
│           │   │   └── firebird.png
│           │   ├── genesis
│           │   │   └── genesis.png
│           │   └── tornado
│           │       └── tornado.png
│           ├── bossenter
│           │   └── bossenter.png
│           ├── character
│           │   ├── boss
│           │   │   ├── ball
│           │   │   │   ├── ball_left.png
│           │   │   │   └── ball_right.png
│           │   │   ├── dead
│           │   │   │   ├── dead_left.png
│           │   │   │   └── dead_right.png
│           │   │   ├── firebird
│           │   │   │   ├── firebird_left.png
│           │   │   │   └── firebird_right.png
│           │   │   ├── genesis
│           │   │   │   ├── genesis_left.png
│           │   │   │   └── genesis_right.png
│           │   │   ├── idle
│           │   │   │   ├── idle_left.png
│           │   │   │   └── idle_right.png
│           │   │   └── tornado
│           │   │       ├── tornado_left.png
│           │   │       └── tornado_right.png
│           │   ├── monster
│           │   │   ├── blue
│           │   │   │   ├── dead
│           │   │   │   │   ├── blue_dead_left.png
│           │   │   │   │   └── blue_dead_right.png
│           │   │   │   ├── idle
│           │   │   │   │   ├── blue_idle_left.png
│           │   │   │   │   └── blue_idle_right.png
│           │   │   │   └── move
│           │   │   │       ├── blue_move_left.png
│           │   │   │       └── blue_move_right.png
│           │   │   └── red
│           │   │       ├── dead
│           │   │       │   ├── red_dead_left.png
│           │   │       │   └── red_dead_right.png
│           │   │       ├── idle
│           │   │       │   ├── red_idle_left.png
│           │   │       │   └── red_idle_right.png
│           │   │       └── move
│           │   │           ├── red_move_left.png
│           │   │           └── red_move_right.png
│           │   └── player
│           │       ├── attack
│           │       │   ├── attack_left.png
│           │       │   └── attack_right.png
│           │       ├── down
│           │       │   ├── down_left.png
│           │       │   └── down_right.png
│           │       ├── down_attack
│           │       │   ├── down_attack_left.png
│           │       │   └── down_attack_right.png
│           │       ├── idle
│           │       │   ├── idle_left.png
│           │       │   └── idle_right.png
│           │       ├── jump
│           │       │   ├── jump_left.png
│           │       │   └── jump_right.png
│           │       ├── missile
│           │       │   ├── missile_left.png
│           │       │   └── missile_right.png
│           │       ├── move
│           │       │   ├── move_left.png
│           │       │   └── move_right.png
│           │       ├── rope
│           │       │   └── rope.png
│           │       ├── slash
│           │       │   ├── slash_left.png
│           │       │   └── slash_right.png
│           │       └── special
│           │           ├── special_left.png
│           │           └── special_right.png
│           ├── damage
│           │   ├── attack
│           │   │   └── attack.png
│           │   ├── miss
│           │   │   └── miss.png
│           │   ├── missile
│           │   │   └── missile.png
│           │   ├── slash
│           │   │   └── slash.png
│           │   └── special
│           │       ├── special.png
│           │       ├── special1.png
│           │       ├── special2.png
│           │       └── special3.png
│           ├── edit
│           │   ├── edit - 복사본.png
│           │   ├── edit.png
│           │   ├── edit1.png
│           │   ├── monster_blue.png
│           │   └── monster_red.png
│           ├── effect
│           │   ├── attack
│           │   │   └── attack.png
│           │   ├── missile
│           │   │   └── missile.png
│           │   ├── slash
│           │   │   └── slash.png
│           │   └── special
│           │       └── special.png
│           ├── link.png
│           ├── logo
│           │   └── logo.png
│           ├── map
│           │   ├── KakaoTalk_20240307_172747313_03.png
│           │   ├── boss.png
│           │   ├── boss1-1.png
│           │   ├── boss1-2.png
│           │   ├── boss1.png
│           │   ├── boss2.png
│           │   ├── bossfinal.png
│           │   ├── stage1.png
│           │   └── stage2.png
│           ├── skill
│           │   ├── attack
│           │   │   ├── attack_left.png
│           │   │   └── attack_right.png
│           │   ├── buff
│           │   │   └── buff.png
│           │   ├── doublejump
│           │   │   ├── doublejump_left.png
│           │   │   └── doublejump_right.png
│           │   ├── highjump
│           │   │   └── highjump.png
│           │   ├── levelup
│           │   │   └── levelup.png
│           │   ├── missile
│           │   │   ├── missile_ball_left.png
│           │   │   ├── missile_ball_right.png
│           │   │   ├── missile_left.png
│           │   │   └── missile_right.png
│           │   ├── slash
│           │   │   ├── slash_left.png
│           │   │   └── slash_right.png
│           │   └── special
│           │       ├── special_left.png
│           │       └── special_right.png
│           ├── start
│           │   └── start.png
│           └── ui
│               ├── bosshud
│               │   ├── bosshp.png
│               │   └── bosshud.png
│               ├── btn
│               │   ├── croa
│               │   │   ├── btn1.png
│               │   │   ├── btn2.png
│               │   │   └── btn3.png
│               │   └── scania
│               │       ├── btn1.png
│               │       ├── btn2.png
│               │       └── btn3.png
│               ├── menu
│               │   ├── menu.png
│               │   ├── menu1.png
│               │   └── playerhp.png
│               ├── minimap
│               │   ├── boss1.png
│               │   ├── boss2.png
│               │   ├── stage1.png
│               │   └── stage2.png
│               └── playerhp
│                   └── playerhp.png
├── QueueWinAPI.sln
├── README.md
└── To do list.cell

```

`GameClient/GameClient.h`:

```h
#pragma once

#include "resource.h"

```

`GameClient/GameClient.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 한국어(대한민국) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_KOR)
LANGUAGE LANG_KOREAN, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_GAMECLIENT          ICON                    "GameClient.ico"

IDI_SMALL               ICON                    "small.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDC_GAMECLIENT MENU
BEGIN
    POPUP "파일(&F)"
    BEGIN
        MENUITEM "끝내기(&X)",                     IDM_EXIT
    END
    POPUP "도움말(&H)"
    BEGIN
        MENUITEM "정보(&A)...",                   IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDC_GAMECLIENT ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "정보 GameClient"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDI_GAMECLIENT,IDC_STATIC,14,14,20,20
    LTEXT           "GameClient, 버전 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2024",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "확인",IDOK,113,41,50,14,WS_GROUP
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_APP_TITLE           "GameClient"
    IDC_GAMECLIENT          "GAMECLIENT"
END

#endif    // 한국어(대한민국) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`GameClient/GameClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c8a4f312-92fd-4c30-addf-ea041231b855}</ProjectGuid>
    <RootNamespace>GameClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup>
    <EnableUnitySupport>true</EnableUnitySupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)OutputFile\bin\</OutDir>
    <TargetName>Maple_d</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)OutputFile\bin\</OutDir>
    <TargetName>Maple</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <MinFilesInUnityFile>8</MinFilesInUnityFile>
      <UnityFilesDirectory>$(ProjectDir)\Unity\</UnityFilesDirectory>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <MinFilesInUnityFile>8</MinFilesInUnityFile>
      <UnityFilesDirectory>$(ProjectDir)\Unity\</UnityFilesDirectory>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="define.h" />
    <ClInclude Include="enum.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="func.h" />
    <ClInclude Include="GameClient.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="qAnimation.h" />
    <ClInclude Include="qAnimator.h" />
    <ClInclude Include="qAsset.h" />
    <ClInclude Include="qAssetMgr.h" />
    <ClInclude Include="qBackground_boss1.h" />
    <ClInclude Include="qBackground_boss2.h" />
    <ClInclude Include="qBackground_stage1.h" />
    <ClInclude Include="qBackground_stage2.h" />
    <ClInclude Include="qBackground_start.h" />
    <ClInclude Include="qBlueDeadState.h" />
    <ClInclude Include="qBoss.h" />
    <ClInclude Include="qBossBallState.h" />
    <ClInclude Include="qBossDeadState.h" />
    <ClInclude Include="qBossEffect_ball.h" />
    <ClInclude Include="qBossEffect_firebird.h" />
    <ClInclude Include="qBossEffect_genesis.h" />
    <ClInclude Include="qBossEffect_tornado.h" />
    <ClInclude Include="qBossFirebirdState.h" />
    <ClInclude Include="qBossGenesisState.h" />
    <ClInclude Include="qBossHP.h" />
    <ClInclude Include="qBossHUD.h" />
    <ClInclude Include="qBossIdleState.h" />
    <ClInclude Include="qBossSkill_ball_left.h" />
    <ClInclude Include="qBossSkill_ball_right.h" />
    <ClInclude Include="qBossSkill_firebird.h" />
    <ClInclude Include="qBossSkill_genesis.h" />
    <ClInclude Include="qBossSkill_tornado.h" />
    <ClInclude Include="qBossTornadoState.h" />
    <ClInclude Include="qButton.h" />
    <ClInclude Include="qCamera.h" />
    <ClInclude Include="qCollider.h" />
    <ClInclude Include="qCollisionMgr.h" />
    <ClInclude Include="qComponent.h" />
    <ClInclude Include="qDamage_attack.h" />
    <ClInclude Include="qDamage_magic.h" />
    <ClInclude Include="qDamage_miss.h" />
    <ClInclude Include="qDamage_missile.h" />
    <ClInclude Include="qDamage_physical.h" />
    <ClInclude Include="qDamage_slash.h" />
    <ClInclude Include="qDamage_special.h" />
    <ClInclude Include="qDbgRender.h" />
    <ClInclude Include="qDummy_blue.h" />
    <ClInclude Include="qDummy_red.h" />
    <ClInclude Include="qEffect_attack.h" />
    <ClInclude Include="qEffect_missile.h" />
    <ClInclude Include="qEffect_slash.h" />
    <ClInclude Include="qEffect_special.h" />
    <ClInclude Include="qEngine.h" />
    <ClInclude Include="qEntity.h" />
    <ClInclude Include="qExp.h" />
    <ClInclude Include="qForce.h" />
    <ClInclude Include="qFSM.h" />
    <ClInclude Include="qGuideMissile.h" />
    <ClInclude Include="qBlueIdleState.h" />
    <ClInclude Include="qKeyMgr.h" />
    <ClInclude Include="qLevel.h" />
    <ClInclude Include="qLevelMgr.h" />
    <ClInclude Include="qLevel_boss1.h" />
    <ClInclude Include="qLevel_boss2.h" />
    <ClInclude Include="qLevel_Editor.h" />
    <ClInclude Include="qLevel_stage1.h" />
    <ClInclude Include="qLevel_stage2.h" />
    <ClInclude Include="qLevel_Logo.h" />
    <ClInclude Include="qLogo.h" />
    <ClInclude Include="qMenu.h" />
    <ClInclude Include="qMinimap_boss1.h" />
    <ClInclude Include="qMinimap_boss2.h" />
    <ClInclude Include="qMinimap_stage1.h" />
    <ClInclude Include="qMinimap_stage2.h" />
    <ClInclude Include="qMissile.h" />
    <ClInclude Include="qMonster_blue.h" />
    <ClInclude Include="qMonster_red.h" />
    <ClInclude Include="qObj.h" />
    <ClInclude Include="qPathMgr.h" />
    <ClInclude Include="qPlatform.h" />
    <ClInclude Include="qPlayer.h" />
    <ClInclude Include="qPlayerHP.h" />
    <ClInclude Include="qPortal.h" />
    <ClInclude Include="qRedDeadState.h" />
    <ClInclude Include="qRedIdleState.h" />
    <ClInclude Include="qRedMoveState.h" />
    <ClInclude Include="qRespawnMgr.h" />
    <ClInclude Include="qRigidbody.h" />
    <ClInclude Include="qRope.h" />
    <ClInclude Include="qSelectObj.h" />
    <ClInclude Include="qSkill_attack_left.h" />
    <ClInclude Include="qSkill_attack_right.h" />
    <ClInclude Include="qSkill_buff.h" />
    <ClInclude Include="qSkill_doublejump_left.h" />
    <ClInclude Include="qSkill_doublejump_right.h" />
    <ClInclude Include="qSkill_highjump.h" />
    <ClInclude Include="qSkill_missile_ball_right.h" />
    <ClInclude Include="qSkill_missile_left.h" />
    <ClInclude Include="qSkill_missile_ball_left.h" />
    <ClInclude Include="qSkill_missile_right.h" />
    <ClInclude Include="qSkill_slash_left.h" />
    <ClInclude Include="qSkill_slash_right.h" />
    <ClInclude Include="qSkill_special_left.h" />
    <ClInclude Include="qSkill_special_right.h" />
    <ClInclude Include="qSound.h" />
    <ClInclude Include="qSoundMgr.h" />
    <ClInclude Include="qLevel_Start.h" />
    <ClInclude Include="qSpawner_blue1.h" />
    <ClInclude Include="qSpawner_blue2.h" />
    <ClInclude Include="qSpawner_blue3.h" />
    <ClInclude Include="qSpawner_red1.h" />
    <ClInclude Include="qSpawner_red2.h" />
    <ClInclude Include="qState.h" />
    <ClInclude Include="qTaskMgr.h" />
    <ClInclude Include="qTexture.h" />
    <ClInclude Include="qTile.h" />
    <ClInclude Include="qTileMap.h" />
    <ClInclude Include="qTimeMgr.h" />
    <ClInclude Include="qBlueMoveState.h" />
    <ClInclude Include="qUI.h" />
    <ClInclude Include="qUIMgr.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="func.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="qAnimation.cpp" />
    <ClCompile Include="qAnimator.cpp" />
    <ClCompile Include="qAsset.cpp" />
    <ClCompile Include="qAssetMgr.cpp" />
    <ClCompile Include="qBackground_boss1.cpp" />
    <ClCompile Include="qBackground_boss2.cpp" />
    <ClCompile Include="qBackground_stage1.cpp" />
    <ClCompile Include="qBackground_stage2.cpp" />
    <ClCompile Include="qBackground_start.cpp" />
    <ClCompile Include="qBlueDeadState.cpp" />
    <ClCompile Include="qBoss.cpp" />
    <ClCompile Include="qBossBallState.cpp" />
    <ClCompile Include="qBossDeadState.cpp" />
    <ClCompile Include="qBossEffect_ball.cpp" />
    <ClCompile Include="qBossEffect_firebird.cpp" />
    <ClCompile Include="qBossEffect_genesis.cpp" />
    <ClCompile Include="qBossEffect_tornado.cpp" />
    <ClCompile Include="qBossFirebirdState.cpp" />
    <ClCompile Include="qBossGenesisState.cpp" />
    <ClCompile Include="qBossHP.cpp" />
    <ClCompile Include="qBossHUD.cpp" />
    <ClCompile Include="qBossIdleState.cpp" />
    <ClCompile Include="qBossSkill_ball_left.cpp" />
    <ClCompile Include="qBossSkill_ball_right.cpp" />
    <ClCompile Include="qBossSkill_firebird.cpp" />
    <ClCompile Include="qBossSkill_genesis.cpp" />
    <ClCompile Include="qBossSkill_tornado.cpp" />
    <ClCompile Include="qBossTornadoState.cpp" />
    <ClCompile Include="qButton.cpp" />
    <ClCompile Include="qCamera.cpp" />
    <ClCompile Include="qCollider.cpp" />
    <ClCompile Include="qCollisionMgr.cpp" />
    <ClCompile Include="qComponent.cpp" />
    <ClCompile Include="qDamage_attack.cpp" />
    <ClCompile Include="qDamage_magic.cpp" />
    <ClCompile Include="qDamage_miss.cpp" />
    <ClCompile Include="qDamage_missile.cpp" />
    <ClCompile Include="qDamage_physical.cpp" />
    <ClCompile Include="qDamage_slash.cpp" />
    <ClCompile Include="qDamage_special.cpp" />
    <ClCompile Include="qDbgRender.cpp" />
    <ClCompile Include="qDummy_blue.cpp" />
    <ClCompile Include="qDummy_red.cpp" />
    <ClCompile Include="qEffect_attack.cpp" />
    <ClCompile Include="qEffect_missile.cpp" />
    <ClCompile Include="qEffect_slash.cpp" />
    <ClCompile Include="qEffect_special.cpp" />
    <ClCompile Include="qEngine.cpp" />
    <ClCompile Include="qEntity.cpp" />
    <ClCompile Include="qExp.cpp" />
    <ClCompile Include="qForce.cpp" />
    <ClCompile Include="qFSM.cpp" />
    <ClCompile Include="qGuideMissile.cpp" />
    <ClCompile Include="qBlueIdleState.cpp" />
    <ClCompile Include="qKeyMgr.cpp" />
    <ClCompile Include="qLevel.cpp" />
    <ClCompile Include="qLevelMgr.cpp" />
    <ClCompile Include="qLevel_boss1.cpp" />
    <ClCompile Include="qLevel_boss2.cpp" />
    <ClCompile Include="qLevel_Editor.cpp" />
    <ClCompile Include="qLevel_stage1.cpp" />
    <ClCompile Include="qLevel_stage2.cpp" />
    <ClCompile Include="qLevel_Logo.cpp" />
    <ClCompile Include="qLogo.cpp" />
    <ClCompile Include="qMenu.cpp" />
    <ClCompile Include="qMinimap_boss1.cpp" />
    <ClCompile Include="qMinimap_boss2.cpp" />
    <ClCompile Include="qMinimap_stage1.cpp" />
    <ClCompile Include="qMinimap_stage2.cpp" />
    <ClCompile Include="qMissile.cpp" />
    <ClCompile Include="qMonster_blue.cpp" />
    <ClCompile Include="qMonster_red.cpp" />
    <ClCompile Include="qObj.cpp" />
    <ClCompile Include="qPathMgr.cpp" />
    <ClCompile Include="qPlatform.cpp" />
    <ClCompile Include="qPlayer.cpp" />
    <ClCompile Include="qPlayerHP.cpp" />
    <ClCompile Include="qPortal.cpp" />
    <ClCompile Include="qRedDeadState.cpp" />
    <ClCompile Include="qRedIdleState.cpp" />
    <ClCompile Include="qRedMoveState.cpp" />
    <ClCompile Include="qRespawnMgr.cpp" />
    <ClCompile Include="qRigidbody.cpp" />
    <ClCompile Include="qRope.cpp" />
    <ClCompile Include="qSelectObj.cpp" />
    <ClCompile Include="qSkill_attack_left.cpp" />
    <ClCompile Include="qSkill_attack_right.cpp" />
    <ClCompile Include="qSkill_buff.cpp" />
    <ClCompile Include="qSkill_doublejump_left.cpp" />
    <ClCompile Include="qSkill_doublejump_right.cpp" />
    <ClCompile Include="qSkill_highjump.cpp" />
    <ClCompile Include="qSkill_missile_ball_right.cpp" />
    <ClCompile Include="qSkill_missile_left.cpp" />
    <ClCompile Include="qSkill_missile_ball_left.cpp" />
    <ClCompile Include="qSkill_missile_right.cpp" />
    <ClCompile Include="qSkill_slash_left.cpp" />
    <ClCompile Include="qSkill_slash_right.cpp" />
    <ClCompile Include="qSkill_special_left.cpp" />
    <ClCompile Include="qSkill_special_right.cpp" />
    <ClCompile Include="qSound.cpp" />
    <ClCompile Include="qSoundMgr.cpp" />
    <ClCompile Include="qLevel_Start.cpp" />
    <ClCompile Include="qSpawner_blue1.cpp" />
    <ClCompile Include="qSpawner_blue2.cpp" />
    <ClCompile Include="qSpawner_blue3.cpp" />
    <ClCompile Include="qSpawner_red1.cpp" />
    <ClCompile Include="qSpawner_red2.cpp" />
    <ClCompile Include="qState.cpp" />
    <ClCompile Include="qTaskMgr.cpp" />
    <ClCompile Include="qTexture.cpp" />
    <ClCompile Include="qTile.cpp" />
    <ClCompile Include="qTileMap.cpp" />
    <ClCompile Include="qTimeMgr.cpp" />
    <ClCompile Include="qBlueMoveState.cpp" />
    <ClCompile Include="qUI.cpp" />
    <ClCompile Include="qUIMgr.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GameClient.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="GameClient.ico" />
    <Image Include="small.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GameClient/GameClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="02. Main">
      <UniqueIdentifier>{a6c1a83b-c9cd-4b59-8815-917bd46a9344}</UniqueIdentifier>
    </Filter>
    <Filter Include="01. 리소스 파일">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="03. Game">
      <UniqueIdentifier>{58e6f517-bf58-47d3-9d4f-e80011b7b9f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\01. Header">
      <UniqueIdentifier>{d8e04ed8-c325-4fba-a649-344b251fcddc}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\02. Engine">
      <UniqueIdentifier>{e57c3e76-57e3-4138-bd8c-b97e30e012e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager">
      <UniqueIdentifier>{1c08b5ee-3682-44c0-889e-f5b536342d82}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level">
      <UniqueIdentifier>{cb12d06f-df98-4c17-9339-b64b9e8b3388}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object">
      <UniqueIdentifier>{97c2a1ab-7064-4b21-98ac-fa322ffb95e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component">
      <UniqueIdentifier>{eef07274-25dd-46f8-9026-74d975c7fae7}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\07. Asset">
      <UniqueIdentifier>{b89d56f0-f5a1-40bd-9145-c3985d93dbd5}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module">
      <UniqueIdentifier>{4ee0d98e-a57d-4d93-8b5a-e2d7f48aaf46}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component\01. Collider">
      <UniqueIdentifier>{ee430b37-98f2-41b0-ba84-de988aeb4b71}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component\02. Animator">
      <UniqueIdentifier>{711fe424-9b9b-41de-852c-08ac508ab974}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component\03. Rigidbody">
      <UniqueIdentifier>{ab2104a5-7076-49d0-804b-7dd471e6b3d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component\04. FSM">
      <UniqueIdentifier>{542c66a8-eb3d-4daf-b573-156f59767132}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\07. DbgRender">
      <UniqueIdentifier>{e25b869f-60eb-4461-8442-ce0899c5783d}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\01. TimeMgr">
      <UniqueIdentifier>{e5f3fc35-8e2e-4e9e-a0cb-0738d5ebe983}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\02. KeyMgr">
      <UniqueIdentifier>{50fcc41c-96f1-47d4-9eb8-88f075e0a903}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\03. AssetMgr">
      <UniqueIdentifier>{070b1ecf-af0a-4a54-9d5c-4bcd5f6033ab}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\07. Asset\Texture">
      <UniqueIdentifier>{8754dae9-11e8-40b3-bdf2-376f58114890}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\07. Asset\Sound">
      <UniqueIdentifier>{9ce71e80-4f2f-4d7a-9a74-65951a7584b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\05. LevelMgr">
      <UniqueIdentifier>{32221453-8fa2-46da-be38-ad3c0e07d260}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\06. CollisionMgr">
      <UniqueIdentifier>{9f43c80c-a177-482f-a6be-ac1ff71cd396}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\04. PathMgr">
      <UniqueIdentifier>{0c8ce007-f76b-46e0-8810-936dba351cdd}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\08. TaskMgr">
      <UniqueIdentifier>{1a02e56f-1a36-4a45-913b-832d4ac31aae}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\Animation">
      <UniqueIdentifier>{ae5107eb-b358-4e88-b931-758471c3cdcc}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State">
      <UniqueIdentifier>{e26ffa26-cbfe-45d6-804a-d3c8014b1cdd}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\06. Component\05. TileMap">
      <UniqueIdentifier>{04b77910-0cfc-4701-94a6-2f5d39296b4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\09. Camera">
      <UniqueIdentifier>{1a156249-b193-4fb8-a7a4-831c9ab6b4d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\10. UIMgr">
      <UniqueIdentifier>{99ba1f23-4f32-40ab-9019-79b01a41c031}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\01. Logo">
      <UniqueIdentifier>{060c9327-902f-4c2c-a0f5-3af3d2dfb754}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\03. Editor">
      <UniqueIdentifier>{b2057e5c-14ef-4d07-95a6-acea35de00fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage">
      <UniqueIdentifier>{7a9de9f3-26f3-404c-9a8f-f6efc8f73dff}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\02. Start">
      <UniqueIdentifier>{71ba6833-250c-4e1f-87f0-a3987d994082}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\11. SoundMgr">
      <UniqueIdentifier>{a3be03a3-a095-4f9c-bdad-54fd45640b0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\1. Player">
      <UniqueIdentifier>{387927ba-5ae7-4818-8912-46de0bdd54c9}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\2. Monster">
      <UniqueIdentifier>{140961b4-6256-481f-a9d8-5cd1121e3d61}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\2. Monster\2. RED">
      <UniqueIdentifier>{5c384c47-5be3-4703-abb9-b1c333bb1d6b}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\2. Monster\1. BLUE">
      <UniqueIdentifier>{bfc21093-8ebf-42ec-96bf-2b5f15413de2}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\2. Monster\3. Dummy_BLUE">
      <UniqueIdentifier>{25bfa282-9986-4916-b698-9b5a1403f241}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\2. Monster\4. Dummy_Red">
      <UniqueIdentifier>{99bfafe4-370e-4b9f-bdef-de2b5fd77317}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\03. Manager\12. RespawnMgr">
      <UniqueIdentifier>{9db607a2-fd80-4ea3-8019-f35664c61a98}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\4. Boss">
      <UniqueIdentifier>{13a51e0e-fbae-4ee4-8366-8ffc06e30764}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background">
      <UniqueIdentifier>{61f9d4fd-02e1-4ba3-b69b-59384a1788ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\3. STAGE_1">
      <UniqueIdentifier>{52c92b9e-6ffa-4ed4-8a59-870ebe5def94}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\4. STAGE_2">
      <UniqueIdentifier>{32a2503b-46c7-4113-8df9-07ce7af83b5f}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\1. LOGO">
      <UniqueIdentifier>{df77344f-b607-405c-89c8-2c288078803d}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\2. START">
      <UniqueIdentifier>{f30bff3b-0abf-41eb-9c4b-a42e709080b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill">
      <UniqueIdentifier>{11b15ce1-ad09-4301-b340-f07a7e6fb034}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect">
      <UniqueIdentifier>{5844f181-35e6-4dff-8772-b0e2656f7f47}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage">
      <UniqueIdentifier>{41d13a27-744b-4e07-8db9-e5e3a98b08ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\9. Platform">
      <UniqueIdentifier>{5590f0c0-c71e-4db1-be1c-4bd293e51693}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\9. Platform\1. Platform">
      <UniqueIdentifier>{ab3dbf2e-aa34-43f0-98c3-38c116f54b88}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\9. Platform\2. Rope">
      <UniqueIdentifier>{5fa6d2a7-f811-4251-8674-4c2d496e1aa6}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\9. Platform\3. Portal">
      <UniqueIdentifier>{3e5283af-4ecc-4e96-8d18-6c18ad3eb787}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI">
      <UniqueIdentifier>{9f4156f9-f6bc-4d96-ab4c-38de7a7264c1}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\11. Tile">
      <UniqueIdentifier>{d15c0527-03ea-4b38-8a0c-2e279cf51ff5}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\12. Missile">
      <UniqueIdentifier>{90a2e921-b1cb-4cdf-80f2-a23562480524}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\12. Missile\GuideMissile">
      <UniqueIdentifier>{1e990868-0c14-49f4-94aa-a047d0fdcae3}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\13. Force">
      <UniqueIdentifier>{c807ea12-8c56-4ed0-82e0-6463658f874f}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner">
      <UniqueIdentifier>{4210ec3f-3e53-49cd-9445-62ca5025a5f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner\1. BLUE_1">
      <UniqueIdentifier>{0a41aa88-0eba-4a36-bc33-d69d623a0866}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner\2. BLUE_2">
      <UniqueIdentifier>{bbe01da3-e1a6-4f04-aa9e-dea49f548cdb}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner\3. BLUE_3">
      <UniqueIdentifier>{d3fe9115-2955-4caf-850c-b534d4973a12}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner\4. RED_1">
      <UniqueIdentifier>{4f462573-8dad-4789-9835-a4060889a0e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\3. Spawner\5. RED_2">
      <UniqueIdentifier>{da8a4b03-e129-41da-bb5b-3906825e2906}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill">
      <UniqueIdentifier>{bd96ce94-7a5e-4eb8-9c7e-d29ecef1918e}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\1. Attack">
      <UniqueIdentifier>{9749c9dd-a27a-4c2e-97e1-f7a1a5984baf}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile">
      <UniqueIdentifier>{64beaa63-4bd1-4273-884b-f2469ea15d0e}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\1. missile">
      <UniqueIdentifier>{213c771e-ac40-435d-9b6d-191ba3e1ba46}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\2. ball">
      <UniqueIdentifier>{1a8865c3-613e-4625-9e75-86d61a2cec35}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\3. Slash">
      <UniqueIdentifier>{2192986a-b9c4-49f5-938a-01f26fd5f01b}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\4. Special">
      <UniqueIdentifier>{25e56372-8235-4013-bdc8-837877cc79a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\5. Buff">
      <UniqueIdentifier>{5a59bfa8-1963-4b56-a040-bfa8b5b9f70e}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\6. DoubleJump">
      <UniqueIdentifier>{2c7c9d56-9d47-4b52-896b-f4f562a4d1a1}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\1. Player_Skill\7. HighJump">
      <UniqueIdentifier>{55b2eb40-60f0-4387-971c-d458443227e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\2. Boss_Skill">
      <UniqueIdentifier>{8cfe83a4-9b31-4900-aea8-9418fed5da93}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\1. Player_Effect">
      <UniqueIdentifier>{17d7ec3d-655b-496b-ba93-df987c33141e}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\1. Player_Effect\4. Special">
      <UniqueIdentifier>{4c91be43-f2a2-4cb6-beda-0dd47fc864ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\1. Player_Effect\1. Attack">
      <UniqueIdentifier>{93c25c4c-6407-42a5-9ce4-fb09478c2468}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\1. Player_Effect\2. Missile">
      <UniqueIdentifier>{ec6d6c07-faec-4afa-90c3-04c435a22e16}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\1. Player_Effect\3. Slash">
      <UniqueIdentifier>{62536544-6639-4570-9ecb-23bcd70eb417}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\2. Boss_Effect">
      <UniqueIdentifier>{10ac7e53-5798-44b9-8a35-358c656757e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\2. Boss_Skill\1. Ball">
      <UniqueIdentifier>{757013bf-a8ba-4a98-9991-668d278ac514}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\2. Boss_Skill\2. Genesis">
      <UniqueIdentifier>{ab942fea-1809-4e1b-a80f-8a7f4da19b66}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\2. Boss_Skill\3. Firebird">
      <UniqueIdentifier>{18bae139-e0ec-4b87-902e-8dbabf5fd082}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\6. Skill\2. Boss_Skill\4. Tornado">
      <UniqueIdentifier>{b9310024-2bf0-4b0d-b22e-f2ed47cf6e27}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\2. Boss_Effect\1. Ball">
      <UniqueIdentifier>{6b0e015d-0ded-4b09-baaa-959ca99898be}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\2. Boss_Effect\2. Genesis">
      <UniqueIdentifier>{b0f3db95-b371-4a97-b02c-971d5ba2ab4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\2. Boss_Effect\3. Firebird">
      <UniqueIdentifier>{fa55fb7b-b9e0-4470-8909-9da8ba447688}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\7. Effect\2. Boss_Effect\4. Tornado">
      <UniqueIdentifier>{b36f6018-7bfc-4665-ac12-2bcb5ccf6cdf}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\2. MonsterState">
      <UniqueIdentifier>{94db36c4-f659-4cd4-b7bf-8c0caaaa14a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\2. MonsterState\1. BLUE">
      <UniqueIdentifier>{fae33fcf-abe9-40f7-876e-2b84bc216413}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\2. MonsterState\2. RED">
      <UniqueIdentifier>{f7351e22-c859-44f1-a0f7-39db0c53427b}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState">
      <UniqueIdentifier>{aad83735-37d8-4323-8c72-dd585f31a060}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\1. PlayerState">
      <UniqueIdentifier>{89fb0671-31f6-4dd1-99c9-265b756dde21}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\1. Idle">
      <UniqueIdentifier>{ff8df37b-2954-4785-adef-2aff877ee785}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\2. Ball">
      <UniqueIdentifier>{5cb524c9-6057-40f7-8366-10cbc45fb433}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\3. Genesis">
      <UniqueIdentifier>{c0f8e12a-836b-4741-a48c-ee376faefb4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\4. Firebird">
      <UniqueIdentifier>{f3997a39-90c8-439d-ac77-8813ab92f9c0}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\5. Tornado">
      <UniqueIdentifier>{5502fb35-823b-4629-aaf6-fb8c405f794c}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\08. Module\State\3. BossState\6. Dead">
      <UniqueIdentifier>{24a19cd5-85f8-4033-8dd8-16f94c0f4b51}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\1. ButtonUI">
      <UniqueIdentifier>{42af13b4-b6a3-4bc9-ac57-fcc244f3d4c6}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\2. MinimapUI">
      <UniqueIdentifier>{20cce0f5-5e6f-4586-8500-42495142121c}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\3. MenuUI">
      <UniqueIdentifier>{c12ec2c7-a3b4-4416-b220-ea9913a7c81f}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\2. MinimapUI\1. stage1">
      <UniqueIdentifier>{61d3683e-a6c3-4439-8474-866aa820b5aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\2. MinimapUI\2. stage2">
      <UniqueIdentifier>{76843e35-cfcc-410f-ac4f-f67b8b2ce024}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\2. MinimapUI\3. boss1">
      <UniqueIdentifier>{f6e41bfe-ec40-47df-bc43-176553fb8f8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\2. MinimapUI\4. boss2">
      <UniqueIdentifier>{560205f1-fb57-4bb8-a2f9-693d7fc5b901}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\3. MenuUI\1. Menu">
      <UniqueIdentifier>{75978af0-54c3-42a3-8b80-1f17e2e55141}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\5. ExpUI">
      <UniqueIdentifier>{22a60f9c-4942-4e90-a8b4-3858b12259cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\4. BossHPUI">
      <UniqueIdentifier>{572c53fa-c28e-4615-a113-f58529cebf28}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\4. BossHPUI\1. HUD">
      <UniqueIdentifier>{a95e70c1-afe3-4eec-a857-d914ea0ff5c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\2. BOSS">
      <UniqueIdentifier>{ca3d70ea-5ec6-4b43-aac8-9fb7bb1af3ff}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\1. QUEENS_LOAD">
      <UniqueIdentifier>{581d34f5-202c-4948-9d81-e3f3bbcf5300}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\1. QUEENS_LOAD\1. STAGE_1">
      <UniqueIdentifier>{cfbb3697-f361-462d-9d3b-e5c218356661}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\1. QUEENS_LOAD\2. STAGE_2">
      <UniqueIdentifier>{315df053-46d6-497c-847a-554bc66d6dea}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\2. BOSS\1. BOSS_1">
      <UniqueIdentifier>{8caf85df-f2a2-45ac-a1e6-5d3aadb583d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\04. Level\04. Stage\2. BOSS\2. BOSS_2">
      <UniqueIdentifier>{458ed9ed-2312-4000-b45a-9bf6c3e25bd1}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\5. BOSS_1">
      <UniqueIdentifier>{6f9dd70e-97d9-40e4-a1d7-764f54167268}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\5. Background\6. BOSS_2">
      <UniqueIdentifier>{1a68b75e-ed74-4250-a368-90409d7bfe05}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage">
      <UniqueIdentifier>{cfdb255b-44e3-43c6-a6d3-d6e0b6682c6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\2. Boss_Skill_Damage">
      <UniqueIdentifier>{ad3d79d8-1af2-4c9f-9c39-c4ce45f7071d}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage\5. Miss">
      <UniqueIdentifier>{df09c42a-dfca-4044-8b88-3528648994f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage\1. Attack">
      <UniqueIdentifier>{81755e83-a1d0-4caa-90b8-dbbfed3cdfd2}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage\2. Missile">
      <UniqueIdentifier>{0ecd0deb-b8a3-4cbe-8d93-24edd85dc6c2}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage\3. Slash">
      <UniqueIdentifier>{269fc529-65fd-4e17-88be-a3cae5154332}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\1. Player_Skill_Damage\4. Special">
      <UniqueIdentifier>{a2ceab87-7853-48ed-ad50-a284725796a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\1. Physical">
      <UniqueIdentifier>{d58f2a3d-59cd-4b1b-bb43-e9f84c7079f0}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\2. Magic">
      <UniqueIdentifier>{b287c2fd-1137-4fa9-b5f7-271cc0322903}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\3. MenuUI\2. PlayerHP">
      <UniqueIdentifier>{c899f7d9-98c5-4694-8dea-2a85d31d8473}</UniqueIdentifier>
    </Filter>
    <Filter Include="03. Game\05. Object\10. UI\4. BossHPUI\2. BossHP">
      <UniqueIdentifier>{925f9473-6645-416d-88c4-58334b06ddea}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="targetver.h">
      <Filter>02. Main</Filter>
    </ClInclude>
    <ClInclude Include="framework.h">
      <Filter>02. Main</Filter>
    </ClInclude>
    <ClInclude Include="GameClient.h">
      <Filter>02. Main</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>02. Main</Filter>
    </ClInclude>
    <ClInclude Include="qEntity.h">
      <Filter>03. Game</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>02. Main</Filter>
    </ClInclude>
    <ClInclude Include="qObj.h">
      <Filter>03. Game\05. Object</Filter>
    </ClInclude>
    <ClInclude Include="qEngine.h">
      <Filter>03. Game\02. Engine</Filter>
    </ClInclude>
    <ClInclude Include="define.h">
      <Filter>03. Game\01. Header</Filter>
    </ClInclude>
    <ClInclude Include="enum.h">
      <Filter>03. Game\01. Header</Filter>
    </ClInclude>
    <ClInclude Include="qSelectObj.h">
      <Filter>03. Game\08. Module</Filter>
    </ClInclude>
    <ClInclude Include="qLevel.h">
      <Filter>03. Game\04. Level</Filter>
    </ClInclude>
    <ClInclude Include="qLevelMgr.h">
      <Filter>03. Game\03. Manager\05. LevelMgr</Filter>
    </ClInclude>
    <ClInclude Include="struct.h">
      <Filter>03. Game\01. Header</Filter>
    </ClInclude>
    <ClInclude Include="qTimeMgr.h">
      <Filter>03. Game\03. Manager\01. TimeMgr</Filter>
    </ClInclude>
    <ClInclude Include="qPlayer.h">
      <Filter>03. Game\05. Object\1. Player</Filter>
    </ClInclude>
    <ClInclude Include="qMissile.h">
      <Filter>03. Game\05. Object\12. Missile</Filter>
    </ClInclude>
    <ClInclude Include="qKeyMgr.h">
      <Filter>03. Game\03. Manager\02. KeyMgr</Filter>
    </ClInclude>
    <ClInclude Include="qComponent.h">
      <Filter>03. Game\06. Component</Filter>
    </ClInclude>
    <ClInclude Include="qCollider.h">
      <Filter>03. Game\06. Component\01. Collider</Filter>
    </ClInclude>
    <ClInclude Include="qAnimator.h">
      <Filter>03. Game\06. Component\02. Animator</Filter>
    </ClInclude>
    <ClInclude Include="qRigidbody.h">
      <Filter>03. Game\06. Component\03. Rigidbody</Filter>
    </ClInclude>
    <ClInclude Include="qFSM.h">
      <Filter>03. Game\06. Component\04. FSM</Filter>
    </ClInclude>
    <ClInclude Include="qDbgRender.h">
      <Filter>03. Game\03. Manager\07. DbgRender</Filter>
    </ClInclude>
    <ClInclude Include="func.h">
      <Filter>03. Game\01. Header</Filter>
    </ClInclude>
    <ClInclude Include="qCollisionMgr.h">
      <Filter>03. Game\03. Manager\06. CollisionMgr</Filter>
    </ClInclude>
    <ClInclude Include="qAsset.h">
      <Filter>03. Game\07. Asset</Filter>
    </ClInclude>
    <ClInclude Include="qSound.h">
      <Filter>03. Game\07. Asset\Sound</Filter>
    </ClInclude>
    <ClInclude Include="qTexture.h">
      <Filter>03. Game\07. Asset\Texture</Filter>
    </ClInclude>
    <ClInclude Include="qAssetMgr.h">
      <Filter>03. Game\03. Manager\03. AssetMgr</Filter>
    </ClInclude>
    <ClInclude Include="qPathMgr.h">
      <Filter>03. Game\03. Manager\04. PathMgr</Filter>
    </ClInclude>
    <ClInclude Include="qTaskMgr.h">
      <Filter>03. Game\03. Manager\08. TaskMgr</Filter>
    </ClInclude>
    <ClInclude Include="qGuideMissile.h">
      <Filter>03. Game\05. Object\12. Missile\GuideMissile</Filter>
    </ClInclude>
    <ClInclude Include="qAnimation.h">
      <Filter>03. Game\08. Module\Animation</Filter>
    </ClInclude>
    <ClInclude Include="qForce.h">
      <Filter>03. Game\05. Object\13. Force</Filter>
    </ClInclude>
    <ClInclude Include="qCamera.h">
      <Filter>03. Game\03. Manager\09. Camera</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_Editor.h">
      <Filter>03. Game\04. Level\03. Editor</Filter>
    </ClInclude>
    <ClInclude Include="qTile.h">
      <Filter>03. Game\05. Object\11. Tile</Filter>
    </ClInclude>
    <ClInclude Include="qTileMap.h">
      <Filter>03. Game\06. Component\05. TileMap</Filter>
    </ClInclude>
    <ClInclude Include="qUI.h">
      <Filter>03. Game\05. Object\10. UI</Filter>
    </ClInclude>
    <ClInclude Include="qUIMgr.h">
      <Filter>03. Game\03. Manager\10. UIMgr</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_Logo.h">
      <Filter>03. Game\04. Level\01. Logo</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_Start.h">
      <Filter>03. Game\04. Level\02. Start</Filter>
    </ClInclude>
    <ClInclude Include="qSoundMgr.h">
      <Filter>03. Game\03. Manager\11. SoundMgr</Filter>
    </ClInclude>
    <ClInclude Include="qBackground_stage1.h">
      <Filter>03. Game\05. Object\5. Background\3. STAGE_1</Filter>
    </ClInclude>
    <ClInclude Include="qLogo.h">
      <Filter>03. Game\05. Object\5. Background\1. LOGO</Filter>
    </ClInclude>
    <ClInclude Include="qBackground_stage2.h">
      <Filter>03. Game\05. Object\5. Background\4. STAGE_2</Filter>
    </ClInclude>
    <ClInclude Include="qBackground_boss1.h">
      <Filter>03. Game\05. Object\5. Background\5. BOSS_1</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_stage1.h">
      <Filter>03. Game\04. Level\04. Stage\1. QUEENS_LOAD\1. STAGE_1</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_stage2.h">
      <Filter>03. Game\04. Level\04. Stage\1. QUEENS_LOAD\2. STAGE_2</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_boss1.h">
      <Filter>03. Game\04. Level\04. Stage\2. BOSS\1. BOSS_1</Filter>
    </ClInclude>
    <ClInclude Include="qBackground_boss2.h">
      <Filter>03. Game\05. Object\5. Background\6. BOSS_2</Filter>
    </ClInclude>
    <ClInclude Include="qLevel_boss2.h">
      <Filter>03. Game\04. Level\04. Stage\2. BOSS\2. BOSS_2</Filter>
    </ClInclude>
    <ClInclude Include="qPlatform.h">
      <Filter>03. Game\05. Object\9. Platform\1. Platform</Filter>
    </ClInclude>
    <ClInclude Include="qRope.h">
      <Filter>03. Game\05. Object\9. Platform\2. Rope</Filter>
    </ClInclude>
    <ClInclude Include="qPortal.h">
      <Filter>03. Game\05. Object\9. Platform\3. Portal</Filter>
    </ClInclude>
    <ClInclude Include="qBackground_start.h">
      <Filter>03. Game\05. Object\5. Background\2. START</Filter>
    </ClInclude>
    <ClInclude Include="qMonster_blue.h">
      <Filter>03. Game\05. Object\2. Monster\1. BLUE</Filter>
    </ClInclude>
    <ClInclude Include="qMonster_red.h">
      <Filter>03. Game\05. Object\2. Monster\2. RED</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_attack_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\1. Attack</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_buff.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\5. Buff</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_special_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\4. Special</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_slash_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\3. Slash</Filter>
    </ClInclude>
    <ClInclude Include="qButton.h">
      <Filter>03. Game\05. Object\10. UI\1. ButtonUI</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_doublejump_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\6. DoubleJump</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_attack_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\1. Attack</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_missile_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\1. missile</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_missile_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\1. missile</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_missile_ball_left.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\2. ball</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_missile_ball_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\2. ball</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_slash_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\3. Slash</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_special_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\4. Special</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_doublejump_right.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\6. DoubleJump</Filter>
    </ClInclude>
    <ClInclude Include="qSkill_highjump.h">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\7. HighJump</Filter>
    </ClInclude>
    <ClInclude Include="qDummy_blue.h">
      <Filter>03. Game\05. Object\2. Monster\3. Dummy_BLUE</Filter>
    </ClInclude>
    <ClInclude Include="qDummy_red.h">
      <Filter>03. Game\05. Object\2. Monster\4. Dummy_Red</Filter>
    </ClInclude>
    <ClInclude Include="qBlueMoveState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClInclude>
    <ClInclude Include="qBlueIdleState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClInclude>
    <ClInclude Include="qRedIdleState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClInclude>
    <ClInclude Include="qRedMoveState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClInclude>
    <ClInclude Include="qBlueDeadState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClInclude>
    <ClInclude Include="qRedDeadState.h">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClInclude>
    <ClInclude Include="qEffect_attack.h">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\1. Attack</Filter>
    </ClInclude>
    <ClInclude Include="qEffect_missile.h">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\2. Missile</Filter>
    </ClInclude>
    <ClInclude Include="qEffect_slash.h">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\3. Slash</Filter>
    </ClInclude>
    <ClInclude Include="qEffect_special.h">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\4. Special</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_miss.h">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\5. Miss</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_attack.h">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\1. Attack</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_missile.h">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\2. Missile</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_slash.h">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\3. Slash</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_special.h">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\4. Special</Filter>
    </ClInclude>
    <ClInclude Include="qRespawnMgr.h">
      <Filter>03. Game\03. Manager\12. RespawnMgr</Filter>
    </ClInclude>
    <ClInclude Include="qSpawner_blue1.h">
      <Filter>03. Game\05. Object\3. Spawner\1. BLUE_1</Filter>
    </ClInclude>
    <ClInclude Include="qSpawner_blue2.h">
      <Filter>03. Game\05. Object\3. Spawner\2. BLUE_2</Filter>
    </ClInclude>
    <ClInclude Include="qSpawner_blue3.h">
      <Filter>03. Game\05. Object\3. Spawner\3. BLUE_3</Filter>
    </ClInclude>
    <ClInclude Include="qSpawner_red1.h">
      <Filter>03. Game\05. Object\3. Spawner\4. RED_1</Filter>
    </ClInclude>
    <ClInclude Include="qSpawner_red2.h">
      <Filter>03. Game\05. Object\3. Spawner\5. RED_2</Filter>
    </ClInclude>
    <ClInclude Include="qBoss.h">
      <Filter>03. Game\05. Object\4. Boss</Filter>
    </ClInclude>
    <ClInclude Include="qBossIdleState.h">
      <Filter>03. Game\08. Module\State\3. BossState\1. Idle</Filter>
    </ClInclude>
    <ClInclude Include="qBossBallState.h">
      <Filter>03. Game\08. Module\State\3. BossState\2. Ball</Filter>
    </ClInclude>
    <ClInclude Include="qBossGenesisState.h">
      <Filter>03. Game\08. Module\State\3. BossState\3. Genesis</Filter>
    </ClInclude>
    <ClInclude Include="qBossFirebirdState.h">
      <Filter>03. Game\08. Module\State\3. BossState\4. Firebird</Filter>
    </ClInclude>
    <ClInclude Include="qBossTornadoState.h">
      <Filter>03. Game\08. Module\State\3. BossState\5. Tornado</Filter>
    </ClInclude>
    <ClInclude Include="qBossDeadState.h">
      <Filter>03. Game\08. Module\State\3. BossState\6. Dead</Filter>
    </ClInclude>
    <ClInclude Include="qState.h">
      <Filter>03. Game\08. Module\State</Filter>
    </ClInclude>
    <ClInclude Include="qBossSkill_ball_left.h">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\1. Ball</Filter>
    </ClInclude>
    <ClInclude Include="qBossSkill_tornado.h">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\4. Tornado</Filter>
    </ClInclude>
    <ClInclude Include="qBossSkill_genesis.h">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\2. Genesis</Filter>
    </ClInclude>
    <ClInclude Include="qBossSkill_firebird.h">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\3. Firebird</Filter>
    </ClInclude>
    <ClInclude Include="qBossSkill_ball_right.h">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\1. Ball</Filter>
    </ClInclude>
    <ClInclude Include="qBossEffect_ball.h">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\1. Ball</Filter>
    </ClInclude>
    <ClInclude Include="qBossEffect_firebird.h">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\3. Firebird</Filter>
    </ClInclude>
    <ClInclude Include="qBossEffect_tornado.h">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\4. Tornado</Filter>
    </ClInclude>
    <ClInclude Include="qBossEffect_genesis.h">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\2. Genesis</Filter>
    </ClInclude>
    <ClInclude Include="qMinimap_stage1.h">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\1. stage1</Filter>
    </ClInclude>
    <ClInclude Include="qMinimap_boss2.h">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\4. boss2</Filter>
    </ClInclude>
    <ClInclude Include="qMinimap_boss1.h">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\3. boss1</Filter>
    </ClInclude>
    <ClInclude Include="qMinimap_stage2.h">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\2. stage2</Filter>
    </ClInclude>
    <ClInclude Include="qBossHP.h">
      <Filter>03. Game\05. Object\10. UI\4. BossHPUI\2. BossHP</Filter>
    </ClInclude>
    <ClInclude Include="qBossHUD.h">
      <Filter>03. Game\05. Object\10. UI\4. BossHPUI\1. HUD</Filter>
    </ClInclude>
    <ClInclude Include="qMenu.h">
      <Filter>03. Game\05. Object\10. UI\3. MenuUI\1. Menu</Filter>
    </ClInclude>
    <ClInclude Include="qExp.h">
      <Filter>03. Game\05. Object\10. UI\5. ExpUI</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_physical.h">
      <Filter>03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\1. Physical</Filter>
    </ClInclude>
    <ClInclude Include="qDamage_magic.h">
      <Filter>03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\2. Magic</Filter>
    </ClInclude>
    <ClInclude Include="qPlayerHP.h">
      <Filter>03. Game\05. Object\10. UI\3. MenuUI\2. PlayerHP</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GameClient.rc">
      <Filter>01. 리소스 파일</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico">
      <Filter>01. 리소스 파일</Filter>
    </Image>
    <Image Include="GameClient.ico">
      <Filter>01. 리소스 파일</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>02. Main</Filter>
    </ClCompile>
    <ClCompile Include="qEntity.cpp">
      <Filter>03. Game</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>02. Main</Filter>
    </ClCompile>
    <ClCompile Include="qObj.cpp">
      <Filter>03. Game\05. Object</Filter>
    </ClCompile>
    <ClCompile Include="qEngine.cpp">
      <Filter>03. Game\02. Engine</Filter>
    </ClCompile>
    <ClCompile Include="qSelectObj.cpp">
      <Filter>03. Game\08. Module</Filter>
    </ClCompile>
    <ClCompile Include="qLevel.cpp">
      <Filter>03. Game\04. Level</Filter>
    </ClCompile>
    <ClCompile Include="qLevelMgr.cpp">
      <Filter>03. Game\03. Manager\05. LevelMgr</Filter>
    </ClCompile>
    <ClCompile Include="qTimeMgr.cpp">
      <Filter>03. Game\03. Manager\01. TimeMgr</Filter>
    </ClCompile>
    <ClCompile Include="qPlayer.cpp">
      <Filter>03. Game\05. Object\1. Player</Filter>
    </ClCompile>
    <ClCompile Include="qMissile.cpp">
      <Filter>03. Game\05. Object\12. Missile</Filter>
    </ClCompile>
    <ClCompile Include="qKeyMgr.cpp">
      <Filter>03. Game\03. Manager\02. KeyMgr</Filter>
    </ClCompile>
    <ClCompile Include="qComponent.cpp">
      <Filter>03. Game\06. Component</Filter>
    </ClCompile>
    <ClCompile Include="qCollider.cpp">
      <Filter>03. Game\06. Component\01. Collider</Filter>
    </ClCompile>
    <ClCompile Include="qAnimator.cpp">
      <Filter>03. Game\06. Component\02. Animator</Filter>
    </ClCompile>
    <ClCompile Include="qRigidbody.cpp">
      <Filter>03. Game\06. Component\03. Rigidbody</Filter>
    </ClCompile>
    <ClCompile Include="qFSM.cpp">
      <Filter>03. Game\06. Component\04. FSM</Filter>
    </ClCompile>
    <ClCompile Include="qDbgRender.cpp">
      <Filter>03. Game\03. Manager\07. DbgRender</Filter>
    </ClCompile>
    <ClCompile Include="func.cpp">
      <Filter>03. Game\01. Header</Filter>
    </ClCompile>
    <ClCompile Include="qCollisionMgr.cpp">
      <Filter>03. Game\03. Manager\06. CollisionMgr</Filter>
    </ClCompile>
    <ClCompile Include="qAsset.cpp">
      <Filter>03. Game\07. Asset</Filter>
    </ClCompile>
    <ClCompile Include="qSound.cpp">
      <Filter>03. Game\07. Asset\Sound</Filter>
    </ClCompile>
    <ClCompile Include="qTexture.cpp">
      <Filter>03. Game\07. Asset\Texture</Filter>
    </ClCompile>
    <ClCompile Include="qAssetMgr.cpp">
      <Filter>03. Game\03. Manager\03. AssetMgr</Filter>
    </ClCompile>
    <ClCompile Include="qPathMgr.cpp">
      <Filter>03. Game\03. Manager\04. PathMgr</Filter>
    </ClCompile>
    <ClCompile Include="qTaskMgr.cpp">
      <Filter>03. Game\03. Manager\08. TaskMgr</Filter>
    </ClCompile>
    <ClCompile Include="qGuideMissile.cpp">
      <Filter>03. Game\05. Object\12. Missile\GuideMissile</Filter>
    </ClCompile>
    <ClCompile Include="qAnimation.cpp">
      <Filter>03. Game\08. Module\Animation</Filter>
    </ClCompile>
    <ClCompile Include="qForce.cpp">
      <Filter>03. Game\05. Object\13. Force</Filter>
    </ClCompile>
    <ClCompile Include="qCamera.cpp">
      <Filter>03. Game\03. Manager\09. Camera</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_Editor.cpp">
      <Filter>03. Game\04. Level\03. Editor</Filter>
    </ClCompile>
    <ClCompile Include="qTile.cpp">
      <Filter>03. Game\05. Object\11. Tile</Filter>
    </ClCompile>
    <ClCompile Include="qTileMap.cpp">
      <Filter>03. Game\06. Component\05. TileMap</Filter>
    </ClCompile>
    <ClCompile Include="qUI.cpp">
      <Filter>03. Game\05. Object\10. UI</Filter>
    </ClCompile>
    <ClCompile Include="qUIMgr.cpp">
      <Filter>03. Game\03. Manager\10. UIMgr</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_Logo.cpp">
      <Filter>03. Game\04. Level\01. Logo</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_Start.cpp">
      <Filter>03. Game\04. Level\02. Start</Filter>
    </ClCompile>
    <ClCompile Include="qSoundMgr.cpp">
      <Filter>03. Game\03. Manager\11. SoundMgr</Filter>
    </ClCompile>
    <ClCompile Include="qBackground_stage1.cpp">
      <Filter>03. Game\05. Object\5. Background\3. STAGE_1</Filter>
    </ClCompile>
    <ClCompile Include="qLogo.cpp">
      <Filter>03. Game\05. Object\5. Background\1. LOGO</Filter>
    </ClCompile>
    <ClCompile Include="qBackground_stage2.cpp">
      <Filter>03. Game\05. Object\5. Background\4. STAGE_2</Filter>
    </ClCompile>
    <ClCompile Include="qBackground_boss1.cpp">
      <Filter>03. Game\05. Object\5. Background\5. BOSS_1</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_stage1.cpp">
      <Filter>03. Game\04. Level\04. Stage\1. QUEENS_LOAD\1. STAGE_1</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_stage2.cpp">
      <Filter>03. Game\04. Level\04. Stage\1. QUEENS_LOAD\2. STAGE_2</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_boss1.cpp">
      <Filter>03. Game\04. Level\04. Stage\2. BOSS\1. BOSS_1</Filter>
    </ClCompile>
    <ClCompile Include="qBackground_boss2.cpp">
      <Filter>03. Game\05. Object\5. Background\6. BOSS_2</Filter>
    </ClCompile>
    <ClCompile Include="qLevel_boss2.cpp">
      <Filter>03. Game\04. Level\04. Stage\2. BOSS\2. BOSS_2</Filter>
    </ClCompile>
    <ClCompile Include="qPlatform.cpp">
      <Filter>03. Game\05. Object\9. Platform\1. Platform</Filter>
    </ClCompile>
    <ClCompile Include="qRope.cpp">
      <Filter>03. Game\05. Object\9. Platform\2. Rope</Filter>
    </ClCompile>
    <ClCompile Include="qPortal.cpp">
      <Filter>03. Game\05. Object\9. Platform\3. Portal</Filter>
    </ClCompile>
    <ClCompile Include="qBackground_start.cpp">
      <Filter>03. Game\05. Object\5. Background\2. START</Filter>
    </ClCompile>
    <ClCompile Include="qMonster_blue.cpp">
      <Filter>03. Game\05. Object\2. Monster\1. BLUE</Filter>
    </ClCompile>
    <ClCompile Include="qMonster_red.cpp">
      <Filter>03. Game\05. Object\2. Monster\2. RED</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_attack_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\1. Attack</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_buff.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\5. Buff</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_special_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\4. Special</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_slash_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\3. Slash</Filter>
    </ClCompile>
    <ClCompile Include="qButton.cpp">
      <Filter>03. Game\05. Object\10. UI\1. ButtonUI</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_doublejump_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\6. DoubleJump</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_attack_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\1. Attack</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_missile_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\1. missile</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_missile_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\1. missile</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_missile_ball_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\2. ball</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_missile_ball_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\2. Missile\2. ball</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_slash_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\3. Slash</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_special_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\4. Special</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_doublejump_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\6. DoubleJump</Filter>
    </ClCompile>
    <ClCompile Include="qSkill_highjump.cpp">
      <Filter>03. Game\05. Object\6. Skill\1. Player_Skill\7. HighJump</Filter>
    </ClCompile>
    <ClCompile Include="qDummy_blue.cpp">
      <Filter>03. Game\05. Object\2. Monster\3. Dummy_BLUE</Filter>
    </ClCompile>
    <ClCompile Include="qDummy_red.cpp">
      <Filter>03. Game\05. Object\2. Monster\4. Dummy_Red</Filter>
    </ClCompile>
    <ClCompile Include="qBlueIdleState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClCompile>
    <ClCompile Include="qBlueMoveState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClCompile>
    <ClCompile Include="qRedIdleState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClCompile>
    <ClCompile Include="qRedMoveState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClCompile>
    <ClCompile Include="qBlueDeadState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\1. BLUE</Filter>
    </ClCompile>
    <ClCompile Include="qRedDeadState.cpp">
      <Filter>03. Game\08. Module\State\2. MonsterState\2. RED</Filter>
    </ClCompile>
    <ClCompile Include="qEffect_attack.cpp">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\1. Attack</Filter>
    </ClCompile>
    <ClCompile Include="qEffect_missile.cpp">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\2. Missile</Filter>
    </ClCompile>
    <ClCompile Include="qEffect_slash.cpp">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\3. Slash</Filter>
    </ClCompile>
    <ClCompile Include="qEffect_special.cpp">
      <Filter>03. Game\05. Object\7. Effect\1. Player_Effect\4. Special</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_miss.cpp">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\5. Miss</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_attack.cpp">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\1. Attack</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_missile.cpp">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\2. Missile</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_slash.cpp">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\3. Slash</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_special.cpp">
      <Filter>03. Game\05. Object\8. Damage\1. Player_Skill_Damage\4. Special</Filter>
    </ClCompile>
    <ClCompile Include="qRespawnMgr.cpp">
      <Filter>03. Game\03. Manager\12. RespawnMgr</Filter>
    </ClCompile>
    <ClCompile Include="qSpawner_blue1.cpp">
      <Filter>03. Game\05. Object\3. Spawner\1. BLUE_1</Filter>
    </ClCompile>
    <ClCompile Include="qSpawner_blue2.cpp">
      <Filter>03. Game\05. Object\3. Spawner\2. BLUE_2</Filter>
    </ClCompile>
    <ClCompile Include="qSpawner_blue3.cpp">
      <Filter>03. Game\05. Object\3. Spawner\3. BLUE_3</Filter>
    </ClCompile>
    <ClCompile Include="qSpawner_red1.cpp">
      <Filter>03. Game\05. Object\3. Spawner\4. RED_1</Filter>
    </ClCompile>
    <ClCompile Include="qSpawner_red2.cpp">
      <Filter>03. Game\05. Object\3. Spawner\5. RED_2</Filter>
    </ClCompile>
    <ClCompile Include="qBoss.cpp">
      <Filter>03. Game\05. Object\4. Boss</Filter>
    </ClCompile>
    <ClCompile Include="qBossIdleState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\1. Idle</Filter>
    </ClCompile>
    <ClCompile Include="qBossBallState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\2. Ball</Filter>
    </ClCompile>
    <ClCompile Include="qBossGenesisState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\3. Genesis</Filter>
    </ClCompile>
    <ClCompile Include="qBossFirebirdState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\4. Firebird</Filter>
    </ClCompile>
    <ClCompile Include="qBossTornadoState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\5. Tornado</Filter>
    </ClCompile>
    <ClCompile Include="qBossDeadState.cpp">
      <Filter>03. Game\08. Module\State\3. BossState\6. Dead</Filter>
    </ClCompile>
    <ClCompile Include="qState.cpp">
      <Filter>03. Game\08. Module\State</Filter>
    </ClCompile>
    <ClCompile Include="qBossSkill_ball_left.cpp">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\1. Ball</Filter>
    </ClCompile>
    <ClCompile Include="qBossSkill_tornado.cpp">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\4. Tornado</Filter>
    </ClCompile>
    <ClCompile Include="qBossSkill_genesis.cpp">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\2. Genesis</Filter>
    </ClCompile>
    <ClCompile Include="qBossSkill_firebird.cpp">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\3. Firebird</Filter>
    </ClCompile>
    <ClCompile Include="qBossSkill_ball_right.cpp">
      <Filter>03. Game\05. Object\6. Skill\2. Boss_Skill\1. Ball</Filter>
    </ClCompile>
    <ClCompile Include="qBossEffect_ball.cpp">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\1. Ball</Filter>
    </ClCompile>
    <ClCompile Include="qBossEffect_firebird.cpp">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\3. Firebird</Filter>
    </ClCompile>
    <ClCompile Include="qBossEffect_tornado.cpp">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\4. Tornado</Filter>
    </ClCompile>
    <ClCompile Include="qBossEffect_genesis.cpp">
      <Filter>03. Game\05. Object\7. Effect\2. Boss_Effect\2. Genesis</Filter>
    </ClCompile>
    <ClCompile Include="qMinimap_stage1.cpp">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\1. stage1</Filter>
    </ClCompile>
    <ClCompile Include="qMinimap_boss2.cpp">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\4. boss2</Filter>
    </ClCompile>
    <ClCompile Include="qMinimap_boss1.cpp">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\3. boss1</Filter>
    </ClCompile>
    <ClCompile Include="qMinimap_stage2.cpp">
      <Filter>03. Game\05. Object\10. UI\2. MinimapUI\2. stage2</Filter>
    </ClCompile>
    <ClCompile Include="qBossHP.cpp">
      <Filter>03. Game\05. Object\10. UI\4. BossHPUI\2. BossHP</Filter>
    </ClCompile>
    <ClCompile Include="qBossHUD.cpp">
      <Filter>03. Game\05. Object\10. UI\4. BossHPUI\1. HUD</Filter>
    </ClCompile>
    <ClCompile Include="qMenu.cpp">
      <Filter>03. Game\05. Object\10. UI\3. MenuUI\1. Menu</Filter>
    </ClCompile>
    <ClCompile Include="qExp.cpp">
      <Filter>03. Game\05. Object\10. UI\5. ExpUI</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_physical.cpp">
      <Filter>03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\1. Physical</Filter>
    </ClCompile>
    <ClCompile Include="qDamage_magic.cpp">
      <Filter>03. Game\05. Object\8. Damage\2. Boss_Skill_Damage\2. Magic</Filter>
    </ClCompile>
    <ClCompile Include="qPlayerHP.cpp">
      <Filter>03. Game\05. Object\10. UI\3. MenuUI\2. PlayerHP</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`GameClient/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++에서 생성한 포함 파일입니다.
// GameClient.rc에서 사용되고 있습니다.
//
#define IDC_MYICON                      2
#define IDD_GAMECLIENT_DIALOG           102
#define IDS_APP_TITLE                   103
#define IDD_ABOUTBOX                    103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDI_GAMECLIENT                  107
#define IDI_SMALL                       108
#define IDC_GAMECLIENT                  109
#define IDR_MAINFRAME                   128
#define IDC_LIST1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif

```

`GameClient/Unity/unity_5A0O4K845Z5PJ068.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossSkill_firebird.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossSkill_genesis.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossSkill_tornado.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossTornadoState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qButton.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qCamera.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qCollider.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qCollisionMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qComponent.cpp"


```

`GameClient/Unity/unity_7H55SN0SWYCZX1GR.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDummy_red.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEffect_attack.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEffect_missile.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEffect_slash.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEffect_special.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEngine.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qEntity.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qExp.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qForce.cpp"


```

`GameClient/Unity/unity_82JTMKED0AVROIH4.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\func.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\main.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\pch.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qAnimation.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qAnimator.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qAsset.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qAssetMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBackground_boss1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBackground_boss2.cpp"


```

`GameClient/Unity/unity_EE1VTZPILABOSQLZ.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossEffect_genesis.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossEffect_tornado.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossFirebirdState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossGenesisState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossHP.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossHUD.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossIdleState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossSkill_ball_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossSkill_ball_right.cpp"


```

`GameClient/Unity/unity_EZQWBK0BCO39R0YP.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_slash_right.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_special_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_special_right.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSound.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSoundMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_Start.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSpawner_blue1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSpawner_blue2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSpawner_blue3.cpp"


```

`GameClient/Unity/unity_FESXYYTMV2H6VOY7.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qFSM.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qGuideMissile.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBlueIdleState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qKeyMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevelMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_boss1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_boss2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_Editor.cpp"


```

`GameClient/Unity/unity_HWAN4XAD0O5AR76X.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_attack.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_magic.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_miss.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_missile.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_physical.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_slash.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDamage_special.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDbgRender.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qDummy_blue.cpp"


```

`GameClient/Unity/unity_I4PPU87D95RZPHFA.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSpawner_red1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSpawner_red2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qTaskMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qTexture.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qTile.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qTileMap.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qTimeMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBlueMoveState.cpp"


```

`GameClient/Unity/unity_NMEJAB13KAC13461.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRedDeadState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRedIdleState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRedMoveState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRespawnMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRigidbody.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qRope.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSelectObj.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_attack_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_attack_right.cpp"


```

`GameClient/Unity/unity_OG212SEFP9QWTROH.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_stage1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_stage2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLevel_Logo.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qLogo.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMenu.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMinimap_boss1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMinimap_boss2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMinimap_stage1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMinimap_stage2.cpp"


```

`GameClient/Unity/unity_OM7CFU7WRN9LERH9.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_buff.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_doublejump_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_doublejump_right.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_highjump.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_missile_ball_right.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_missile_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_missile_ball_left.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_missile_right.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qSkill_slash_left.cpp"


```

`GameClient/Unity/unity_RO1UJTUPUYEOM3ZU.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qUI.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qUIMgr.cpp"


```

`GameClient/Unity/unity_RV4LWHYO8CTRFWH2.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMissile.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMonster_blue.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qMonster_red.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qObj.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qPathMgr.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qPlatform.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qPlayer.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qPlayerHP.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qPortal.cpp"


```

`GameClient/Unity/unity_VCG54Q6CEIJO9PA1.cpp`:

```cpp

#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBackground_stage1.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBackground_stage2.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBackground_start.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBlueDeadState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBoss.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossBallState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossDeadState.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossEffect_ball.cpp"


#include "Q:\assortrock\51th\Win32API\Queue2nd\WinAPI\GameClient\qBossEffect_firebird.cpp"


```

`GameClient/define.h`:

```h
#pragma once


#define SINGLE(type) public:\
						static type* GetInst()\
						{\
							static type mgr;\
							return &mgr;\
						}\
						private:\
							type();\
							type(const type& _other) = delete;\
						public:\
							~type();


#define USE_PEN(DC, TYPE) qSelectObj SelectPen(DC, qEngine::GetInst()->GetPen(TYPE))
#define USE_BRUSH(DC, TYPE) qSelectObj SelectBrush(DC, qEngine::GetInst()->GetBrush(TYPE))

#define DT qTimeMgr::GetInst()->GetDeltaTime()
#define DC qEngine::GetInst()->GetSubDC()


#define KEY_CHECK(Key, State) qKeyMgr::GetInst()->GetKeyState(Key) == State

#define KEY_TAP(Key)		KEY_CHECK(Key, KEY_STATE::TAP)
#define KEY_PRESSED(Key)	KEY_CHECK(Key, KEY_STATE::PRESSED)
#define KEY_RELEASED(Key)	KEY_CHECK(Key, KEY_STATE::RELEASED)
#define KEY_NONE(Key)		KEY_CHECK(Key, KEY_STATE::NONE)

#define CLONE(Type) virtual Type* Clone() override {return new Type(*this); };
#define CLONE_DISABLE(Type) virtual Type* Clone() override {return nullptr; };

#define PI 3.1415926535f

#define LOG(TYPE, Msg)	{\
							string FuncName = __FUNCTION__;\
							wstring strFuncName = wstring(FuncName.begin(), FuncName.end());\
							WCHAR szLog[256] = {};\
							swprintf_s(szLog, L"{%s : %d} : %s", strFuncName.c_str(), __LINE__, Msg);\
							DebugLog(TYPE, szLog);\
						}


#define TILE_SIZE 64
```

`GameClient/enum.h`:

```h
#pragma once


enum class PEN_TYPE
{
	PEN_RED,
	PEN_GREEN,
	PEN_BLUE,

	END,
};


enum class BRUSH_TYPE
{
	BRUSH_RED,
	BRUSH_GREEN,
	BRUSH_BLUE,
	BRUSH_GRAY,

	BRUSH_HOLLOW,
	BRUSH_BLACK,

	END,
};


enum class LEVEL_TYPE
{
	LOGO,
	START,
	EDITOR,

	STAGE_01,
	STAGE_02,

	BOSS_ENTER,

	BOSS_01,
	BOSS_02,

	END,
};


enum class PLAYER_STATE
{
	IDLE,
	MOVE,
	ATTACK,
	MISSILE,
	SLASH,
	SPECIAL,
	BUFF,
	DOWN,
	DOWN_ATTACK,
	JUMP,
	ROPE,

	END,
};

enum class DIRECTION
{
	RIGHT,
	LEFT,
	DOWN,
};


enum class PLAYER_SKILL
{
	ATTACK,		// 솔라슬래시 (기본기)
	MISSILE,	// 루나 디바이드 (유도탄)
	SLASH,		// 라우드 러쉬 (벽력일섬)
	SPECIAL,	// 크로스 더 스틱스 (크게 한방)
	BUFF,		// 트루사이트 (버프기)
	DOUBLEJUMP,	// 더블점프

	END,
};

enum class BOSS_SKILL
{
	MISSILE,	// 발사
	DARK,		// 다크 제네시스
	FIRE,		// 불새

	END,
};



enum class DBG_SHAPE
{
	CIRCLE,
	RECT,
	LINE
};


enum class LAYER_TYPE
{
	DEFAULT,
	BACKGROUND,

	PLATFORM,
	ROPE,
	PORTAL,

	PLAYER,
	
	MONSTER_BLUE,
	MONSTER_RED,

	DUMMY_BLUE,
	DUMMY_RED,

	BOSS,

	PLAYER_SKILL,
	BOSS_SKILL,

	EFFECT,


	UI,
	END,

	NONE = -1,

};


enum class TASK_TYPE
{
	SPAWN_OBJECT,		// 1 : Level,  2 : LAYER_TYPE,  3 : Object Adress
	DELETE_OBJECT,		// 1 : Object Adress
	CHANGE_LEVEL,
	UI_LBTN_DOWN,		// 1 : UI Object Adress, 2 : true or false
};


enum class LOG_TYPE
{
	DBG_LOG,
	DBG_WARNING,
	DBG_ERROR,
};


enum class EDIT_TYPE
{
	PLATFORM,
	ROPE,
	PORTAL,
	//MONSTER_BLUE,
	//MONSTER_RED,
	DUMMY_BLUE,
	DUMMY_RED,
	END,
};

enum class STAGE_NAME
{
	STAGE1,
	STAGE2,
	BOSS1,
	BOSS2,
};
```

`GameClient/framework.h`:

```h
// header.h: 표준 시스템 포함 파일
// 또는 프로젝트 특정 포함 파일이 들어 있는 포함 파일입니다.
//

#pragma once

#include "targetver.h"
#define WIN32_LEAN_AND_MEAN             // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.
// Windows 헤더 파일
#include <windows.h>
// C 런타임 헤더 파일입니다.
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

```

`GameClient/func.cpp`:

```cpp
#include "pch.h"

#include "qDbgRender.h"

void DrawDebugRect(PEN_TYPE _Type, Vec2 _Pos, Vec2 _Scale, float _Time)
{
	tDbgRenderInfo info{};
	info.Shape = DBG_SHAPE::RECT;
	info.Color = _Type;
	info.Position = _Pos;
	info.Scale = _Scale;
	info.Duration = _Time;
	info.Age = 0.f;

	qDbgRender::GetInst()->AddDbgRenderInfo(info);
}

void DrawDebugCircle(PEN_TYPE _Type, Vec2 _Pos, Vec2 _Scale, float _Time)
{
	tDbgRenderInfo info{};
	info.Shape = DBG_SHAPE::CIRCLE;
	info.Color = _Type;
	info.Position = _Pos;
	info.Scale = _Scale;
	info.Duration = _Time;
	info.Age = 0.f;

	qDbgRender::GetInst()->AddDbgRenderInfo(info);
}

void DrawDebugLine(PEN_TYPE _Type, Vec2 _Start, Vec2 _End, float _Time)
{
	tDbgRenderInfo info{};
	info.Shape = DBG_SHAPE::LINE;
	info.Color = _Type;
	info.Position = _Start;
	info.Scale = _End;
	info.Duration = _Time;
	info.Age = 0.f;

	qDbgRender::GetInst()->AddDbgRenderInfo(info);
}

void DebugLog(LOG_TYPE _Type, const WCHAR* _LogMgs)
{
	tDbgLog log = {};
	log.Type = _Type;
	log.strLog = _LogMgs;

	qDbgRender::GetInst()->AddDbgLog(log);
}


float Saturate(float _Ratio)
{
	if (_Ratio < 0.f)
		_Ratio = 0.f;

	if (1.f < _Ratio)
		_Ratio = 1.f;

	return _Ratio;
}



#include "qObj.h"
bool IsValid(qObj*& _Object)
{
	if (nullptr == _Object)
	{
		return false;
	}
	else if (_Object->IsDead())
	{
		_Object = nullptr;
		return false;
	}

	return true;
}



void SaveWString(const wstring& _str, FILE* _File)
{
	size_t len = _str.length();
	fwrite(&len, sizeof(size_t), 1, _File);
	fwrite(_str.c_str(), sizeof(wchar_t), len, _File);
}


void LoadWString(wstring& _str, FILE* _File)
{
	wchar_t buff[256] = {};
	size_t len = 0;
	fread(&len, sizeof(size_t), 1, _File);
	fread(buff, sizeof(wchar_t), len, _File);
	_str = buff;
}




#include "qTaskMgr.h"
void SpawnObject(qLevel* _Level, LAYER_TYPE _type, qObj* _pSpawned)
{
	tTask task = {};
	task.Type = TASK_TYPE::SPAWN_OBJECT;
	task.Param1 = (DWORD_PTR)_Level;
	task.Param2 = (DWORD_PTR)_type;
	task.Param3 = (DWORD_PTR)_pSpawned;

	qTaskMgr::GetInst()->AddTask(task);
}

void ChangeLevel(LEVEL_TYPE _NextLevelType)
{
	tTask task = {};
	task.Type = TASK_TYPE::CHANGE_LEVEL;
	task.Param1 = (DWORD_PTR)_NextLevelType;

	qTaskMgr::GetInst()->AddTask(task);
}

```

`GameClient/func.h`:

```h
#pragma once

void DrawDebugRect(PEN_TYPE _Type, Vec2 _Pos, Vec2 _Scale, float _Time);
void DrawDebugCircle(PEN_TYPE _Type, Vec2 _Pos, Vec2 _Scale, float _Time);
void DrawDebugLine(PEN_TYPE _Type, Vec2 _Start, Vec2 _End, float _Time);

void DebugLog(LOG_TYPE _Type, const WCHAR* _LogMgs);


template<typename T1, typename T2>
void Safe_Del_Map(map<T1, T2>& _map)
{
	for (const auto& pair : _map)
	{
		if (nullptr != pair.second)
		{
			delete pair.second;
		}
	}

	_map.clear();
}


template<typename T>
void Safe_Del_Vec(vector<T*>& _vec)
{
	for (size_t i = 0; i < _vec.size(); ++i)
	{
		if (nullptr != _vec[i])
		{
			delete _vec[i];
		}
	}

	_vec.clear();
}



template<typename T, UINT iSize>
void Safe_Del_Arr(T* (&Arr)[iSize])
{
	for (UINT i = 0; i < iSize; ++i)
	{
		if (nullptr != Arr[i])
		{
			delete Arr[i];
			Arr[i] = nullptr;
		}
	}
}


float Saturate(float _Ratio);

class qObj;
class qLevel;

bool IsValid(qObj*& _Object);

void SaveWString(const wstring& _str, FILE* _File);
void LoadWString(wstring& _str, FILE* _File);


// ==============
// Task 관련 함수
// ==============

void SpawnObject(qLevel* _Level, LAYER_TYPE _type, qObj* _pSpawned);
void ChangeLevel(LEVEL_TYPE _NextLevelType);
```

`GameClient/main.cpp`:

```cpp
#include "pch.h"

#include <crtdbg.h>

#include "framework.h"
#include "GameClient.h"
#include "Resource.h"
#include "qEngine.h"


// 전역 변수:
HINSTANCE   hInst;      // 현재 인스턴스입니다.
HWND        g_hWnd;     // 메인 윈도우 핸들

WCHAR szTitle[100];                  // 제목 표시줄 텍스트입니다.
WCHAR szWindowClass[100];            // 기본 창 클래스 이름입니다.

// 이 코드 모듈에 포함된 함수의 선언을 전달합니다:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);


// SAL : 주석 언어
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    // 랜드값 시간으로 주기
    srand((unsigned int)time(nullptr));

    // 메모리 릭 확인
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
    //_CrtSetBreakAlloc(1557);

    // 윈도우 클래스 등록
    MyRegisterClass(hInstance);

    // 윈도우 생성
    hInst = hInstance; // 인스턴스 핸들을 전역 변수에 저장합니다.

    // CreateWindow 윈도우 생성
    // 반환값은 윈도우 핸들 (ID) 값,
    // 커널오브젝트 : OS 가 관리하는 오브젝트, 직접적인 접근이 불가능하고 ID 값을 통해서 제어함

    g_hWnd = CreateWindowW(L"Window Class Key", L"Maple Story", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

    if (!g_hWnd)
        return FALSE;


    // 윈도우를 화면에 보여줄지 말지 설정
    ShowWindow(g_hWnd, true);
    UpdateWindow(g_hWnd);


    // Engine 초기화
    if (FAILED(qEngine::GetInst()->init(hInst, g_hWnd, POINT{ 1600, 900 })))
    {
        // Engine 초기화 실패 ==> 프로그램 종료
        MessageBox(nullptr, L"엔진 초기화 실패", L"에러 발생", MB_OK);
        return 0;
    }

    // 리소스 (단축키 테이블 핸들 얻기)
    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_GAMECLIENT));

    // 메세지 루프
    // 메세지 정보를 받을 구조체 변수
    MSG msg;


    // GetMessage
    // 1. 리턴 조건 - 메세지 큐에서 메세지가 있으면 리턴
    // 2. WM_QUIT 이 발생하면 GetMessage 함수는 false 를 반환
    //    WM_QUIT 이외 메세지면 GetMessage 함수는 true 를 반환
    
    //while (GetMessage(&msg, nullptr, 0, 0))
    //{
    //    
    //    if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
    //    {
    //        TranslateMessage(&msg);
    //        DispatchMessage(&msg);
    //    }
    //}

    // Peek 엿보다
    // 메세지가 있던 없던, 리턴된다.
    // 메세지가 있었으면 true, 메세지가 없었으면 false
    
    {
        while (true)
        {
            if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
            {
                // 꺼내온 메세지가 WM_QUIT면 게임 종료
                if (msg.message == WM_QUIT)
                    break;

                if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else
            {
                // Game Logic
                // 메세지가 큐에 없을 때에는 게임 코드 실행

                qEngine::GetInst()->progress();

            }
        }
    }
    
    return (int) msg.wParam;
}




ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_GAMECLIENT));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName = nullptr;
    wcex.lpszClassName  = L"Window Class Key";
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}



// CallBack
// 함수의 주소를 알려줘서, 특정 상황(조건)이 맞으면 알려준 함수가 호출되는 구조

// 각 윈도우들은 해당 윈도우에 메세지가 발생 했을 때 처리를 해줄 프로시저 함수를 등록해야 한다.
// 메인 윈도우는 MyRegisterClass 함수 안에서 윈도우 정보를 만들 때 호출한 함수의 주소를 등록해둠
// 도움말 윈도우는 다이얼로그 형태로서, DialogBox 함수를 호출할 때 사용할 프로시저 함수의 주소를 입력으로 넣어줬다.

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // 메뉴 선택을 구문 분석합니다:
            switch (wmId)
            {
            case IDM_ABOUT:
                // 윈도우 생성 함수
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// 정보 대화 상자의 메시지 처리기입니다.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}

```

`GameClient/pch.cpp`:

```cpp
#include "pch.h"


```

`GameClient/pch.h`:

```h
#pragma once

#include <Windows.h>
#include <vector>	// 동적배열
#include <list>		// 연결형 리스트
#include <map>		// 이진탐색트리
#include <string>	// 문자열 전용 관리
#include <assert.h>
#include <ctime>


// TransparentBlt 이 구현되어 있는 라이브러리 링크
#pragma comment(lib, "Msimg32.lib")


using std::vector;
using std::list;
using std::map;
using std::make_pair;

using std::string;
using std::wstring;

#include "define.h"
#include "enum.h"
#include "struct.h"
#include "func.h"
#include "qDbgRender.h"

#include "qSelectObj.h"

// png 로딩 관련 추가
#include <objidl.h>
#include <gdiplus.h>
#pragma comment(lib, "GdiPlus.lib")
using namespace Gdiplus;


// 사운드
#include <mmsystem.h>
#include <dsound.h>
#include <dinput.h>
#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "dsound.lib")

```

`GameClient/qAnimation.cpp`:

```cpp
#include "pch.h"
#include "qAnimation.h"

#include "qObj.h"
#include "qAnimation.h"
#include "qAnimator.h"
#include "qTexture.h"

#include "qTimeMgr.h"
#include "qPathMgr.h"
#include "qCamera.h"

qAnimation::qAnimation()
	: m_Animator(nullptr)
	, m_Atlas(nullptr)
	, m_Time(0.f)
	, m_CurFrmIdx(0)
	, m_bFinish(false)
{
}

qAnimation::~qAnimation()
{
}

void qAnimation::finaltick()
{
	if (m_bFinish)
		return;

	// 현재 프레임 정보
	const tAnimFrm& frm = m_vecFrm[m_CurFrmIdx];

	m_Time += DT;

	if (frm.Duration <= m_Time)
	{
		m_Time -= frm.Duration;
		++m_CurFrmIdx;

		// 프레임이 마지막에 도달했다.
		if (m_vecFrm.size() <= m_CurFrmIdx)
		{
			--m_CurFrmIdx;
			m_bFinish = true;
		}
	}

}

void qAnimation::render()
{

	if (nullptr == m_Atlas)
		return;

	// 현재 프레임 정보
	const tAnimFrm& frm = m_vecFrm[m_CurFrmIdx];

	// Animation 을 재생하고 있는 오브젝트
	qObj* pOwnerObj = m_Animator->GetOwner();

	// 오브젝트의 렌더링 위치
	Vec2 vRenderPos = pOwnerObj->GetRenderPos();

	 //AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;


	// 알파블렌드로 그리기
	AlphaBlend(DC
	, (int)vRenderPos.x - frm.SliceSize.x / 2.f + frm.Offset.x
	, (int)vRenderPos.y - frm.SliceSize.y / 2.f + frm.Offset.y
	, frm.SliceSize.x
	, frm.SliceSize.y
	, m_Atlas->GetDC()
	, frm.StartPos.x , frm.StartPos.y
	, frm.SliceSize.x, frm.SliceSize.y
	, bf);


	//// 현재 프레임 이미지를 오브젝트 위치에 렌더링
	//TransparentBlt(DC
	//				, (int)vRenderPos.x - frm.SliceSize.x / 2.f + frm.Offset.x
	//				, (int)vRenderPos.y - frm.SliceSize.y / 2.f + frm.Offset.y
	//				, (int)frm.SliceSize.x, (int)frm.SliceSize.y
	//				, m_Atlas->GetDC()
	//				, (int)frm.StartPos.x, (int)frm.StartPos.y
	//				, (int)frm.SliceSize.x, (int)frm.SliceSize.y
	//				, RGB(255, 0, 255));
}

void qAnimation::Create(qTexture* _AtlasTex, Vec2 _StartPos, Vec2 _SliceSize, int _FrameCount, int _FPS)
{
	m_Atlas = _AtlasTex;

	// 프레임 정보 생성
	for (int i = 0; i < _FrameCount; ++i)
	{
		tAnimFrm frm = {};
		frm.Duration = 1.f / (float)_FPS;
		frm.StartPos = _StartPos + Vec2(_SliceSize.x * i, 0.f);
		frm.SliceSize = _SliceSize;

		m_vecFrm.push_back(frm);
	}
}

void qAnimation::Save(const wstring& _strRelativeFolderPath)
{
	wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
	strFilePath += _strRelativeFolderPath;
	strFilePath += GetName();
	strFilePath += L".anim";

	FILE* pFile = nullptr;
	_wfopen_s(&pFile, strFilePath.c_str(), L"w");

	if (nullptr == pFile)
	{
		LOG(LOG_TYPE::DBG_ERROR, L"애니메이션 저장 실패");
		return;
	}

	// 애니메이션 정보를 저장
	// 애니메이션 이름 저장
	fwprintf_s(pFile, L"[ANIMATION_NAME]\n");
	
	wstring strAnimName = GetName();
	fwprintf_s(pFile, L"%s\n\n", strAnimName.c_str());

	// 아틀라스 텍스쳐 정보 저장
	fwprintf_s(pFile, L"[ATLAS_TEXTURE]\n");

	if (nullptr == m_Atlas)
	{
		fwprintf_s(pFile, L"[ATLAS_KEY]\t%s\n", L"None");
		fwprintf_s(pFile, L"[ATLAS_PATH\t%s\n", L"None");
	}
	else
	{
		fwprintf_s(pFile, L"[ATLAS_KEY]\t%s\n", m_Atlas->GetKey().c_str());
		fwprintf_s(pFile, L"[ATLAS_PATH]\t%s\n", m_Atlas->GetRelativePath().c_str());
	}

	fwprintf_s(pFile, L"\n");

	// 프레임 정보
	// 프레임 개수를 저장
	fwprintf_s(pFile, L"[FRAME_COUNT]\n");
	fwprintf_s(pFile, L"%d\n\n", (int)m_vecFrm.size());

	// 각각의 프레임 정보를 저장
	size_t FrmCount = m_vecFrm.size();
	for (size_t i = 0; i < m_vecFrm.size(); ++i)
	{
		fwprintf_s(pFile, L"[FRAME_INDEX]\t%d\n", (int)i);
		fwprintf_s(pFile, L"[START_POS] \t%f  %f\n", m_vecFrm[i].StartPos.x, m_vecFrm[i].StartPos.y);
		fwprintf_s(pFile, L"[SLICE_SIZE]\t\t%f  %f\n", m_vecFrm[i].SliceSize.x, m_vecFrm[i].SliceSize.y);
		fwprintf_s(pFile, L"[OFFSET]\t\t%f  %f\n", m_vecFrm[i].Offset.x, m_vecFrm[i].Offset.y);
		fwprintf_s(pFile, L"[DURATION]  \t%f\n", m_vecFrm[i].Duration);
		fwprintf_s(pFile, L"\n");
	}
	
	fclose(pFile);

}

int qAnimation::Load(const wstring& _strRelativeFilePath)
{
	wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
	strFilePath += _strRelativeFilePath;

	FILE* pFile = nullptr;
	_wfopen_s(&pFile, strFilePath.c_str(), L"r");

	if (nullptr == pFile)
	{
		return E_FAIL;
	}

	// 애니메이션의 정보를 읽기
	// 애니메이션 이름
	wchar_t szReadBuff[256] = {};

	while (EOF != fwscanf_s(pFile, L"%s", szReadBuff, 256))
	{
		wstring strRead = szReadBuff;

		if (strRead == L"[ANIMATION_NAME]")
		{
			fwscanf_s(pFile, L"%s", szReadBuff, 256);
			SetName(szReadBuff);
		}
		else if (strRead == L"[ATLAS_TEXTURE]")
		{
			fwscanf_s(pFile, L"%s", szReadBuff, 256);
			fwscanf_s(pFile, L"%s", szReadBuff, 256);
			wstring strKey = szReadBuff;

			fwscanf_s(pFile, L"%s", szReadBuff, 256);
			fwscanf_s(pFile, L"%s", szReadBuff, 256);
			wstring strPath = szReadBuff;

			if (strKey != L"None" && strPath != L"None")
			{
				m_Atlas = qAssetMgr::GetInst()->LoadTexture(strKey, strPath);
			}
		}
		else if (strRead == L"[FRAME_COUNT]")
		{
			int frmcount = 0;
			fwscanf_s(pFile, L"%d", &frmcount);

			for (int i = 0; i < frmcount; ++i)
			{
				tAnimFrm frm = {};
				
				// [START_POS] 가 나올때 까지 읽어들인다.

				do { fwscanf_s(pFile, L"%s", szReadBuff, 256); } while (wcscmp(szReadBuff, L"[START_POS]"));

				fwscanf_s(pFile, L"%f%f", &frm.StartPos.x, &frm.StartPos.y);
				fwscanf_s(pFile, L"%s", szReadBuff, 256);
				fwscanf_s(pFile, L"%f%f", &frm.SliceSize.x, &frm.SliceSize.y);
				fwscanf_s(pFile, L"%s", szReadBuff, 256);
				fwscanf_s(pFile, L"%f%f", &frm.Offset.x, &frm.Offset.y);
				fwscanf_s(pFile, L"%s", szReadBuff, 256);
				fwscanf_s(pFile, L"%f", &frm.Duration);

				m_vecFrm.push_back(frm);
			}
		}
	}
	
	
	fclose(pFile);

	return S_OK;
}

```

`GameClient/qAnimation.h`:

```h
#pragma once
#include "qEntity.h"

struct tAnimFrm
{
    Vec2    StartPos;
    Vec2    SliceSize;

    Vec2    Offset;

    float   Duration;
};

class qAnimator;
class qTexture;

class qAnimation : public qEntity
{
    friend class qAnimator;

public:
    CLONE(qAnimation);

public:
    qAnimation();
    ~qAnimation();


    void finaltick();
    void render();
    void Create(qTexture* _AtlasTex, Vec2 _StartPos, Vec2 _SliceSize, int _FrameCount, int _FPS);
    bool IsFinish() { return m_bFinish; }
    void SetAtlasTexture(qTexture* _Atlas) { m_Atlas = _Atlas; }

    int GetCurFrmIdx() { return m_CurFrmIdx; }

    void Save(const wstring& _strRelativeFolderPath);
    int Load(const wstring& _strRelativeFilePath);

public:
    void Reset()
    {
        m_Time = 0.f;
        m_CurFrmIdx = 0;
        m_bFinish = false;
    }

    tAnimFrm& GetFrame(int _Idx) { return m_vecFrm[_Idx]; }

    
private:
    qAnimator*          m_Animator;     // Animation 을 소유하고 있는 Animator
    qTexture*           m_Atlas;        // Animation 이미지를 보유하고 있는 Atlas Texture
    vector<tAnimFrm>    m_vecFrm;       // 각 프레임 정보

    float               m_Time;         // 누적시간 체크
    int                 m_CurFrmIdx;    // 현재 프레임
    bool                m_bFinish;      // 애니메이션 재생이 종료됨을 알림

    // bool m_bFinish 를 반환하는 함수 만들기
};


```

`GameClient/qAnimator.cpp`:

```cpp
#include "pch.h"
#include "qAnimator.h"

#include "qAnimation.h"

qAnimator::qAnimator()
	: m_CurAnim(nullptr)
	, m_Repeat(false)
{
}

qAnimator::qAnimator(const qAnimator& _Other)
	: qComponent(_Other)
	, m_CurAnim(nullptr)
	, m_Repeat(_Other.m_Repeat)
{
	// 원본 Animator 가 보유한 Animation 들을 복제해서 가져온다.
	for (const auto& pair : _Other.m_mapAnim)
	{
		qAnimation* pCloneAnim = pair.second->Clone();

		pCloneAnim->m_Animator = this;
		m_mapAnim.insert(make_pair(pair.first, pCloneAnim));
	}

	// 현재 재생중인 애니메이션 설정
	if (nullptr != _Other.m_CurAnim)
	{
		m_CurAnim = FindAnimation(_Other.m_CurAnim->GetName());
	}
}

qAnimator::~qAnimator()
{
	Safe_Del_Map(m_mapAnim);
}

void qAnimator::finaltick()
{
	if (nullptr != m_CurAnim)
	{

		if (m_CurAnim->IsFinish() && m_Repeat)
		{
			m_CurAnim->Reset();
		}

		m_CurAnim->finaltick();
	}
}

void qAnimator::render()
{
	if (nullptr != m_CurAnim)
	{
		m_CurAnim->render();
	}
}

void qAnimator::CreateAnimation(const wstring& _AnimName, qTexture* _Atlas, Vec2 _StartPos, Vec2 _SliceSize, int _FrameCount, int _FPS)
{
	// 동일한 이름의 Animation 이 이미 Animator 에 있는 경우
	qAnimation* pAnim = FindAnimation(_AnimName);
	assert(!pAnim);

	// Animation 객체 하나를 생성시킨다.
	pAnim = new qAnimation;
	pAnim->Create(_Atlas, _StartPos, _SliceSize, _FrameCount, _FPS);

	// Animation  이 Animator 에 등록되는 이름(키) 을 알게 한다.
	pAnim->SetName(_AnimName);

	// Animation 에 본인이 소속되는 Animator 를 알게 한다.
	pAnim->m_Animator = this;

	// Animator 가 Animation 을 Map 에 넣는다.
	m_mapAnim.insert(make_pair(_AnimName, pAnim));
}

qAnimation* qAnimator::FindAnimation(const wstring& _AnimName)
{
	map<wstring, qAnimation*>::iterator iter = m_mapAnim.find(_AnimName);

	if (iter == m_mapAnim.end())
		return nullptr;

	return iter->second;
}

void qAnimator::LoadAnimation(const wstring& _strRelativeFilePath)
{
	
	// 애니메이션을 만들어서 지정된 경로로부터 로딩을 진행
	qAnimation* pNewAnim = new qAnimation;
	if (FAILED(pNewAnim->Load(_strRelativeFilePath)))
	{
		delete pNewAnim;
		LOG(LOG_TYPE::DBG_ERROR, L"애니메이션 로딩 실패");
		return;
	}
	pNewAnim->m_Animator = this;
	m_mapAnim.insert(make_pair(pNewAnim->GetName(), pNewAnim));
}


void qAnimator::Play(const wstring& _AnimName, bool _Repeat)
{
	m_CurAnim = FindAnimation(_AnimName);

	if (nullptr == m_CurAnim)
	{
		LOG(LOG_TYPE::DBG_ERROR, L"Play 할 애니메이션을 찾을 수 없음");
		return;
	}
	m_CurAnim->Reset();
	m_Repeat = _Repeat;
}

```

`GameClient/qAnimator.h`:

```h
#pragma once
#include "qComponent.h"
#include "qAnimation.h"

class qAnimation;
class qTexture;

class qAnimator : public qComponent
{
public:
	CLONE(qAnimator);

public:
	qAnimator();
	qAnimator(const qAnimator& _Other);
	~qAnimator();


	virtual void finaltick() override;
	void render();

	void CreateAnimation(const wstring& _AnimName, qTexture* _Atlas, Vec2 _StartPos, Vec2 _SliceSize, int _FrameCount, int _FPS);
	qAnimation* FindAnimation(const wstring& _AnimName);
	void LoadAnimation(const wstring& _strRelativeFilePath);

	void Play(const wstring& _AnimName, bool _Repeat);

	bool IsFinish() { return m_CurAnim->IsFinish(); }

public:
	qAnimation* GetCurAnim() { return m_CurAnim; }


private:
	map<wstring, qAnimation*>	m_mapAnim;
	qAnimation*					m_CurAnim;
	bool						m_Repeat;



};


```

`GameClient/qAsset.cpp`:

```cpp
#include "pch.h"
#include "qAsset.h"

qAsset::qAsset()
{
	
}


qAsset::~qAsset()
{

}
```

`GameClient/qAsset.h`:

```h
#pragma once
#include "qEntity.h"
class qAsset : public qEntity
{
public:
	friend class qAssetMgr;
	
	qAsset();
	~qAsset();


public:
	const wstring& GetKey() { return m_Key; }
	const wstring& GetRelativePath() { return m_RelativePath; }

public:
	CLONE_DISABLE(qAsset);
	virtual int Load(const wstring& _strFilePath) = 0;


private:
	wstring		m_Key;			// 로딩할 때 사용한 키
	wstring		m_RelativePath;	// 상대 경로


};


```

`GameClient/qAssetMgr.cpp`:

```cpp
#include "pch.h"
#include "qAssetMgr.h"

#include "qPathMgr.h"
#include "qTexture.h"
#include "qSound.h"

qAssetMgr::qAssetMgr()
{}

qAssetMgr::~qAssetMgr()
{
    Safe_Del_Map(m_mapTex);

    Safe_Del_Map(m_mapSound);
}

void qAssetMgr::init()
{
}

qTexture* qAssetMgr::LoadTexture(const wstring & _Key, const wstring & _strRelativePath)
{
    // 이미 해당 키로 등록된 텍스쳐가 있으며
    qTexture* pTex = FindTexture(_Key);
    if (nullptr != pTex)
    {
        return pTex;
    }

    // Full Path 로 만들기
    wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
    strFilePath += _strRelativePath;

    // 텍스쳐 객체 생성
    // 텍스쳐 로딩
    pTex = new qTexture;
    if (FAILED(pTex->Load(strFilePath)))
    {
        MessageBox(nullptr, _strRelativePath.c_str(), L"텍스쳐 로딩 실패", MB_OK);
        delete pTex;

        return nullptr;
    }

    // map 에 로딩된 텍스쳐를 등록
    m_mapTex.insert(make_pair(_Key, pTex));

    // 텍스쳐 에셋에 본인의 키값과 상대경로를 알려줌
    pTex->m_Key = _Key;
    pTex->m_RelativePath = _strRelativePath;

    return pTex;

}

qTexture* qAssetMgr::CreateTexture(const wstring& _Key, UINT _Width, UINT _Height)
{
    // 이미 해당키로 등록된 텍스쳐가 있으면
    assert(!FindTexture(_Key));

    // 텍스쳐 객체 생성
    qTexture* pTex = new qTexture;
    if (FAILED(pTex->Create(_Width, _Height)))
    {
        MessageBox(nullptr, _Key.c_str(), L"텍스쳐 생성 실패", MB_OK);
        delete pTex;
        return nullptr;
    }

    // map 에 로딩된 텍스쳐를 등록
    m_mapTex.insert(make_pair(_Key, pTex));

    // 텍스쳐 에셋에 본인의 키값과 상대경로를 알려줌
    pTex->m_Key = _Key;

    return pTex;

}

qTexture* qAssetMgr::FindTexture(const wstring& _Key)
{
    map<wstring, qTexture*>::iterator iter = m_mapTex.find(_Key);

    if (iter == m_mapTex.end())
        return nullptr;

    return iter->second;
}

qSound* qAssetMgr::LoadSound(const wstring& _Key, const wstring& _strRelativePath)
{
    // 이미 해당 키로 등록된 사운드가 있으며
    qSound* pSound = FindSound(_Key);
    if (nullptr != pSound)
    {
        return pSound;
    }

    // Full Path 로 만들기
    wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
    strFilePath += _strRelativePath;

    // 사운드 객체 생성
    // 사운드 로딩
    pSound = new qSound;
    if (FAILED(pSound->Load(strFilePath)))
    {
        MessageBox(nullptr, _strRelativePath.c_str(), L"사운드 로딩 실패", MB_OK);
        delete pSound;
        return nullptr;
    }

    // map 에 로딩된 텍스쳐를 등록
    m_mapSound.insert(make_pair(_Key, pSound));

    // 텍스쳐 에셋에 본인의 키값과 상대경로를 알려줌
    pSound->m_Key = _Key;
    pSound->m_RelativePath = _strRelativePath;

    return pSound;
}

qSound* qAssetMgr::FindSound(const wstring& _Key)
{
    return nullptr;
}

```

`GameClient/qAssetMgr.h`:

```h
#pragma once

class qTexture;
class qSound;

class qAssetMgr
{
	SINGLE(qAssetMgr)

public:
	void init();

	qTexture* LoadTexture(const wstring& _Key, const wstring& _strRelativePath);
	qTexture* CreateTexture(const wstring& _Key, UINT _Width, UINT _Height);
	qTexture* FindTexture(const wstring& _Key);

	qSound* LoadSound(const wstring& _Key, const wstring& _strRelativePath);
	qSound* FindSound(const wstring& _Key);


private:
	map<wstring, qTexture*> m_mapTex;
	map<wstring, qSound*> m_mapSound;

};


```

`GameClient/qBackground_boss1.cpp`:

```cpp
#include "pch.h"
#include "qBackground_boss1.h"

qBackground_boss1::qBackground_boss1()
{
	m_Img = qAssetMgr::GetInst()->LoadTexture(L"boss1", L"texture\\map\\boss1.png");
}

qBackground_boss1::~qBackground_boss1()
{
}

void qBackground_boss1::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_Img->GetWidth(), m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight(), SRCCOPY);
}

```

`GameClient/qBackground_boss1.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;

class qBackground_boss1 : public qObj
{
public:
	CLONE(qBackground_boss1);

public:
	qBackground_boss1();
	~qBackground_boss1();

	void render();
	UINT GetWidth() { return m_Img->GetWidth(); }
	UINT GetHeight() { return m_Img->GetHeight(); }

private:
	qTexture* m_Img;

};


```

`GameClient/qBackground_boss2.cpp`:

```cpp
#include "pch.h"
#include "qBackground_boss2.h"

qBackground_boss2::qBackground_boss2()
{
	m_Img = qAssetMgr::GetInst()->LoadTexture(L"boss2", L"texture\\map\\boss2.png");
}

qBackground_boss2::~qBackground_boss2()
{
}

void qBackground_boss2::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_Img->GetWidth(), m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight(), SRCCOPY);
}

```

`GameClient/qBackground_boss2.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;

class qBackground_boss2 : public qObj
{
public:
	CLONE(qBackground_boss2);

public:
	qBackground_boss2();
	~qBackground_boss2();

	void render();
	UINT GetWidth() { return m_Img->GetWidth(); }
	UINT GetHeight() { return m_Img->GetHeight(); }

private:
	qTexture* m_Img;

};


```

`GameClient/qBackground_stage1.cpp`:

```cpp
#include "pch.h"
#include "qBackground_stage1.h"

qBackground_stage1::qBackground_stage1()
{
	m_Img = qAssetMgr::GetInst()->LoadTexture(L"stage1", L"texture\\map\\stage1.png");
}

qBackground_stage1::~qBackground_stage1()
{
}

void qBackground_stage1::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	//BLENDFUNCTION bf = {};
	//
	//bf.BlendOp = AC_SRC_OVER;
	//bf.BlendFlags = 0;
	//bf.SourceConstantAlpha = 255;
	//bf.AlphaFormat = AC_SRC_ALPHA;
	//
	//AlphaBlend(DC
	//	, (int)vPos.x//(int)(vPos.x - m_Img->GetWidth() * 0.5f)
	//	, (int)vPos.y//(int)(vPos.y - m_Img->GetHeight() * 0.5f)
	//	, m_Img->GetWidth()
	//	, m_Img->GetHeight()
	//	, m_Img->GetDC()
	//	, 0, 0
	//	, m_Img->GetWidth(), m_Img->GetHeight()
	//	, bf);

	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_Img->GetWidth(), m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight(), SRCCOPY);

	//TransparentBlt(DC, (int)vPos.x, (int)vPos.y, m_Img->GetWidth(), m_Img->GetHeight(), m_Img->GetDC(), 0, 0, m_Img->GetWidth(), m_Img->GetHeight(), SRCCOPY);
}

```

`GameClient/qBackground_stage1.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;

class qBackground_stage1 : public qObj
{
public:
	CLONE(qBackground_stage1);

public:
	qBackground_stage1();
	~qBackground_stage1();

	void render();
	UINT GetWidth() { return m_Img->GetWidth(); }
	UINT GetHeight() { return m_Img->GetHeight(); }

private:
	qTexture*		m_Img;
};
```

`GameClient/qBackground_stage2.cpp`:

```cpp
#include "pch.h"
#include "qBackground_stage2.h"

qBackground_stage2::qBackground_stage2()
{
	m_Img = qAssetMgr::GetInst()->LoadTexture(L"stage2", L"texture\\map\\stage2.png");
}

qBackground_stage2::~qBackground_stage2()
{
}

void qBackground_stage2::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_Img->GetWidth(), m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight(), SRCCOPY);
}

```

`GameClient/qBackground_stage2.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;

class qBackground_stage2 : public qObj
{
public:
	CLONE(qBackground_stage2);


public:
	qBackground_stage2();
	~qBackground_stage2();

	void render();
	UINT GetWidth() { return m_Img->GetWidth(); }
	UINT GetHeight() { return m_Img->GetHeight(); }

private:
	qTexture* m_Img;
};


```

`GameClient/qBackground_start.cpp`:

```cpp
#include "pch.h"
#include "qBackground_start.h"

#include "qAnimator.h"
#include "qCamera.h"

#include "qTaskMgr.h"


qBackground_start::qBackground_start()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* Start = qAssetMgr::GetInst()->LoadTexture(L"Start", L"texture\\start\\start.png");

	//애니메이션 CREATE
	m_Animator->CreateAnimation(L"Start", Start, Vec2(0.f, 0.f), Vec2(1600.f, 900.f), 20, 5);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"Start")->Save(L"animation\\start\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\start\\Start.anim");

	m_Animator->Play(L"Start", true);
}

qBackground_start::qBackground_start(const qBackground_start& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qBackground_start::~qBackground_start()
{
}

void qBackground_start::tick()
{
	qObj::tick();
}

```

`GameClient/qBackground_start.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qBackground_start : public qObj
{
public:
	CLONE(qBackground_start);


public:
	qBackground_start();
	qBackground_start(const qBackground_start& _Other);
	~qBackground_start();

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void tick() override;


private:
	qAnimator*		m_Animator;
};


```

`GameClient/qBlueDeadState.cpp`:

```cpp
#include "pch.h"
#include "qBlueDeadState.h"

#include "qSound.h"

qBlueDeadState::qBlueDeadState()
{
	
}

qBlueDeadState::~qBlueDeadState()
{
}

void qBlueDeadState::Enter()
{
	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\monster\\die.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	init();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{

		GetAnimator()->Play(L"BlueDeadRight", false);
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"BlueDeadLeft", false);
	}
}

void qBlueDeadState::FinalTick()
{


	if (L"BlueDeadLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();
		}
	}



	if (L"BlueDeadRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();

		
		}
	}



	
}

void qBlueDeadState::Exit()
{
	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qBlueDeadState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qBlueDeadState : public qState
{
public:
	CLONE(qBlueDeadState);

	qBlueDeadState();
	~qBlueDeadState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;


private:
	qSound*			pSound;

};


```

`GameClient/qBlueIdleState.cpp`:

```cpp
#include "pch.h"
#include "qBlueIdleState.h"



qBlueIdleState::qBlueIdleState()
	: m_Time(0.f)
{
}

qBlueIdleState::~qBlueIdleState()
{
}


void qBlueIdleState::Enter()
{
	init();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"BlueIdleRight", true);
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"BlueIdleLeft", true);
	}
}


void qBlueIdleState::FinalTick()
{

	qObj* pBlue = GetBlackboardData<qObj*>(L"Blue");
	float pBlueSpeed = GetBlackboardData<float>(L"BlueSpeed");
	int pBlueHP = GetBlackboardData<int>(L"BlueHP");

	m_Time += DT;
	if (m_Time > 3.f)
	{
		GetFSM()->ChangeState(L"Move");
	}


	//	GetFSM()->ChangeState(L"Trace");

}

void qBlueIdleState::Exit()
{
	m_Time = 0.f;
}



```

`GameClient/qBlueIdleState.h`:

```h
#pragma once
#include "qState.h"

class qBlueIdleState : public qState
{
public:
	
	CLONE(qBlueIdleState);
	
	qBlueIdleState();
	~qBlueIdleState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;



private:
	Vec2			m_Pos;
	float			m_Time;
};


```

`GameClient/qBlueMoveState.cpp`:

```cpp
#include "pch.h"
#include "qBlueMoveState.h"

qBlueMoveState::qBlueMoveState()
	: m_Dir(1.f)
{
}

qBlueMoveState::~qBlueMoveState()
{
}

void qBlueMoveState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BlueMoveRight", true);
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BlueMoveLeft", true);
	}
}

void qBlueMoveState::FinalTick()
{
	qObj* pBlue = GetBlackboardData<qObj*>(L"Blue");
	float pBlueSpeed = GetBlackboardData<float>(L"BlueSpeed");
	float pMaxDist = GetBlackboardData<float>(L"MaxDist");
	int pBlueHP = GetBlackboardData<int>(L"BlueHP");

	Vec2 vPos = GetObj()->GetPos();


	vPos.x += m_Dir * pBlueSpeed * DT;

	GetObj()->SetPos(vPos);

	float Dist = abs(m_CenterPos.x - vPos.x) - pMaxDist;
	if (10.f < Dist)
	{
		m_Dir *= -1.f;
		vPos.x += Dist * m_Dir;
		GetObj()->SetPos(vPos);

		if (m_Dir == -1.f)
		{
			GetObj()->SetDir(DIRECTION::LEFT);
			GetFSM()->ChangeState(L"Idle");
		}
		else if (m_Dir == 1.f)
		{
			GetObj()->SetDir(DIRECTION::RIGHT);
			GetFSM()->ChangeState(L"Idle");
		}
	}

	

}

void qBlueMoveState::Exit()
{
}

```

`GameClient/qBlueMoveState.h`:

```h
#pragma once
#include "qState.h"

class qBlueMoveState : public qState
{
public:

	CLONE(qBlueMoveState);

	qBlueMoveState();
	~qBlueMoveState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;


private:
	Vec2		m_CenterPos;
	float		m_MaxDistance;
	float		m_Dir;
};


```

`GameClient/qBoss.cpp`:

```cpp
#include "pch.h"
#include "qBoss.h"

#include "qCollider.h"
#include "qRigidbody.h"
#include "qAnimator.h"
#include "qAnimation.h"

#include "qPlayer.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qFSM.h"

#include "qBossIdleState.h"
#include "qBossBallState.h"
#include "qBossGenesisState.h"
#include "qBossFirebirdState.h"
#include "qBossTornadoState.h"
#include "qBossDeadState.h"

#include "qUIMgr.h"


qBoss::qBoss()
	: m_Dir(DIRECTION::LEFT)
	//, m_BossHP(63000000)

{


	// 콜라이더 설정
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(Vec2(100.f, 190.f));


	// 중력 설정
	m_Rigidbody = (qRigidbody*)AddComponent(new qRigidbody);
	m_Rigidbody->SetMass(1.f);
	m_Rigidbody->UseGravity(true);
	m_Rigidbody->SetMaxGravitySpeed(1500.f);
	//m_Rigidbody->SetGround(true);


	// State 설정
	m_FSM = (qFSM*)AddComponent(new qFSM);
	m_FSM->AddState(L"Idle", new qBossIdleState);
	m_FSM->AddState(L"Ball", new qBossBallState);
	m_FSM->AddState(L"Genesis", new qBossGenesisState);
	m_FSM->AddState(L"Firebird", new qBossFirebirdState);
	m_FSM->AddState(L"Tornado", new qBossTornadoState);
	m_FSM->AddState(L"Dead", new qBossDeadState);




	// 애니메이션 설정
	m_Animator = (qAnimator*)AddComponent(new qAnimator);


	// Animation Resister
	// IDLE
	//qTexture* pBossIdleLeft = qAssetMgr::GetInst()->LoadTexture(L"BossIdleLeft", L"texture\\character\\boss\\idle\\idle_left.png");
	//qTexture* pBossIdleRight = qAssetMgr::GetInst()->LoadTexture(L"BossIdleRight", L"texture\\character\\boss\\idle\\idle_right.png");

	// BALL (다크니스 볼)
	//qTexture* pBossBallLeft = qAssetMgr::GetInst()->LoadTexture(L"BossBallLeft", L"texture\\character\\boss\\ball\\ball_left.png");
	//qTexture* pBossBallRight = qAssetMgr::GetInst()->LoadTexture(L"BossBallRight", L"texture\\character\\boss\\ball\\ball_right.png");

	// GENESIS (다크 제네시스)
	//qTexture* pBossGenesisLeft = qAssetMgr::GetInst()->LoadTexture(L"BossGenesisLeft", L"texture\\character\\boss\\genesis\\genesis_left.png");
	//qTexture* pBossGenesisRight = qAssetMgr::GetInst()->LoadTexture(L"BossGenesisRight", L"texture\\character\\boss\\genesis\\genesis_right.png");

	// FIREBIRD (화염 장판)
	//qTexture* pBossFirebirdLeft = qAssetMgr::GetInst()->LoadTexture(L"BossFirebirdLeft", L"texture\\character\\boss\\firebird\\firebird_left.png");
	//qTexture* pBossFirebirdRight = qAssetMgr::GetInst()->LoadTexture(L"BossFirebirdRight", L"texture\\character\\boss\\firebird\\firebird_right.png");

	// TORNADO (어비스 토네이도)
	//qTexture* pBossTornadoLeft = qAssetMgr::GetInst()->LoadTexture(L"BossTornadoLeft", L"texture\\character\\boss\\tornado\\tornado_left.png");
	//qTexture* pBossTornadoRight = qAssetMgr::GetInst()->LoadTexture(L"BossTonardoRight", L"texture\\character\\boss\\tornado\\tornado_right.png");

	// DEAD
	//qTexture* pBossDeadLeft = qAssetMgr::GetInst()->LoadTexture(L"BossDeadLeft", L"texture\\character\\boss\\dead\\dead_left.png");
	//qTexture* pBossDeadRight = qAssetMgr::GetInst()->LoadTexture(L"BossDeadRight", L"texture\\character\\boss\\dead\\dead_right.png");


	// Animation Create
	// IDLE
	//m_Animator->CreateAnimation(L"BossIdleLeft", pBossIdleLeft, Vec2(0.f, 0.f), Vec2(145.f, 200.f), 8, 10);
	//m_Animator->CreateAnimation(L"BossIdleRight", pBossIdleRight, Vec2(0.f, 0.f), Vec2(145.f, 200.f), 8, 10);

	// BALL
	//m_Animator->CreateAnimation(L"BossBallLeft", pBossBallLeft, Vec2(0.f, 0.f), Vec2(550.f, 350.f), 17, 10);
	//m_Animator->CreateAnimation(L"BossBallRight", pBossBallRight, Vec2(0.f, 0.f), Vec2(550.f, 350.f), 17, 10);

	// GENESIS
	//m_Animator->CreateAnimation(L"BossGenesisLeft", pBossGenesisLeft, Vec2(0.f, 0.f), Vec2(420.f, 360.f), 32, 10);
	//m_Animator->CreateAnimation(L"BossGenesisRight", pBossGenesisRight, Vec2(0.f, 0.f), Vec2(420.f, 360.f), 32, 10);

	// FIREBIRD
	//m_Animator->CreateAnimation(L"BossFirebirdLeft", pBossFirebirdLeft, Vec2(0.f, 0.f), Vec2(200.f, 300.f), 23, 10);
	//m_Animator->CreateAnimation(L"BossFirebirdRight", pBossFirebirdRight, Vec2(0.f, 0.f), Vec2(200.f, 300.f), 23, 10);

	// TORNADO
	//m_Animator->CreateAnimation(L"BossTornadoLeft", pBossTornadoLeft, Vec2(0.f, 0.f), Vec2(400.f, 500.f), 26, 10);
	//m_Animator->CreateAnimation(L"BossTornadoRight", pBossTornadoRight, Vec2(0.f, 0.f), Vec2(400.f, 500.f), 26, 10);

	// DEAD
	//m_Animator->CreateAnimation(L"BossDeadLeft", pBossDeadLeft, Vec2(0.f, 0.f), Vec2(300.f, 310.f), 29, 8);
	//m_Animator->CreateAnimation(L"BossDeadRight", pBossDeadRight, Vec2(0.f, 0.f), Vec2(300.f, 310.f), 29, 8);


	// Animation Save
	// IDLE
	//m_Animator->FindAnimation(L"BossIdleLeft")->Save(L"animation\\boss\\idle\\");
	//m_Animator->FindAnimation(L"BossIdleRight")->Save(L"animation\\boss\\idle\\");

	// BALL
	//m_Animator->FindAnimation(L"BossBallLeft")->Save(L"animation\\boss\\ball\\");
	//m_Animator->FindAnimation(L"BossBallRight")->Save(L"animation\\boss\\ball\\");

	// GENESIS
	//m_Animator->FindAnimation(L"BossGenesisLeft")->Save(L"animation\\boss\\genesis\\");
	//m_Animator->FindAnimation(L"BossGenesisRight")->Save(L"animation\\boss\\genesis\\");

	// FIREBIRD
	//m_Animator->FindAnimation(L"BossFirebirdLeft")->Save(L"animation\\boss\\firebird\\");
	//m_Animator->FindAnimation(L"BossFirebirdRight")->Save(L"animation\\boss\\firebird\\");

	// TORNADO
	//m_Animator->FindAnimation(L"BossTornadoLeft")->Save(L"animation\\boss\\tornado\\");
	//m_Animator->FindAnimation(L"BossTornadoRight")->Save(L"animation\\boss\\tornado\\");

	// DEAD
	//m_Animator->FindAnimation(L"BossDeadLeft")->Save(L"animation\\boss\\dead\\");
	//m_Animator->FindAnimation(L"BossDeadRight")->Save(L"animation\\boss\\dead\\");


	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss\\idle\\BossIdleLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\idle\\BossIdleRight.anim");

	m_Animator->LoadAnimation(L"animation\\boss\\ball\\BossBallLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\ball\\BossBallRight.anim");

	m_Animator->LoadAnimation(L"animation\\boss\\genesis\\BossGenesisLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\genesis\\BossGenesisRight.anim");

	m_Animator->LoadAnimation(L"animation\\boss\\firebird\\BossFirebirdLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\firebird\\BossFirebirdRight.anim");

	m_Animator->LoadAnimation(L"animation\\boss\\tornado\\BossTornadoLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\tornado\\BossTornadoRight.anim");

	m_Animator->LoadAnimation(L"animation\\boss\\dead\\BossDeadLeft.anim");
	m_Animator->LoadAnimation(L"animation\\boss\\dead\\BossDeadRight.anim");

	
}

qBoss::qBoss(const qBoss& _Other)
	: qObj(_Other)
	//, m_BossHP(63000000)
	, m_Dir(_Other.m_Dir)
	, m_Animator(nullptr)
{
	m_Collider = GetComponent<qCollider>();
	m_Animator = GetComponent<qAnimator>();
	m_Rigidbody = GetComponent<qRigidbody>();
}

qBoss::~qBoss()
{
}

void qBoss::begin()
{
	qObj::begin();

	SetCenterPos(GetPos());

	qObj* pPlayer = qLevelMgr::GetInst()->FindObjectByName(L"Player");
	m_FSM->SetBlackboardData(L"Player", DATA_TYPE::OBJECT, pPlayer);

	qObj* pBossBallLeft = qLevelMgr::GetInst()->FindObjectByName(L"BossBallLeft");
	m_FSM->SetBlackboardData(L"BossBallLeft", DATA_TYPE::OBJECT, pBossBallLeft);

	m_FSM->SetBlackboardData(L"Boss", DATA_TYPE::OBJECT, this);

	m_FSM->ChangeState(L"Idle");

}

void qBoss::tick()
{
	qObj::tick();

	GetBossHP();

	GetAttackCount();
	GetMissileCount();
	GetSlashCount();
	GetSpecialCount();

}

void qBoss::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{

	if (L"AttackRight" == _OtherObj->GetName() || L"AttackLeft" == _OtherObj->GetName())
	{
		SetBossHP(GetBossHP() - GetAttackDamage());

		if (GetBossHP() <= 0)
		{
			m_FSM->ChangeState(L"Dead");
		}

		PlusAttackCount();
	}

	if (L"BallRight" == _OtherObj->GetName() || L"BallLeft" == _OtherObj->GetName())
	{
		SetBossHP(GetBossHP() - GetMissileDamage());

		if (GetBossHP() <= 0)
		{
			m_FSM->ChangeState(L"Dead");
		}

		PlusMissileCount();
	}

	if (L"SlashRight" == _OtherObj->GetName() || L"SlashLeft" == _OtherObj->GetName())
	{
		SetBossHP(GetBossHP() - GetSlashDamage());

		if (GetBossHP() <= 0)
		{
			m_FSM->ChangeState(L"Dead");
		}

		PlusSlashCount();
	}

	if (L"SpecialRight" == _OtherObj->GetName() || L"SpecialLeft" == _OtherObj->GetName())
	{
		SetBossHP(GetBossHP() - GetSpecialDamage());

		if (GetBossHP() <= 0)
		{
			m_FSM->ChangeState(L"Dead");
		}

		PlusSpecialCount();
	}

}

void qBoss::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qBoss.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;
class qCollider;
class qFSM;
class qAnimator;


class qBoss : public qObj
{
public:

	CLONE(qBoss);

	qBoss();
	qBoss(const qBoss& _Other);
	~qBoss();

public:
	virtual void begin() override;
	virtual void tick() override;

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;




private:

	//int				m_BossHP;
	DIRECTION		m_Dir;
	
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qRigidbody*		m_Rigidbody;
	qFSM*			m_FSM;



};


```

`GameClient/qBossBallState.cpp`:

```cpp
#include "pch.h"
#include "qBossBallState.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qBossSkill_ball_left.h"
#include "qBossSkill_ball_right.h"
#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"


qBossBallState::qBossBallState()
	: m_Time(0.f)
	, m_Dir(-1.f)
	, m_OneShot(true)
{
}

qBossBallState::~qBossBallState()
{
}

void qBossBallState::Enter()
{
	init();

	//qObj* pBossBallLeft = GetBlackboardData<qObj*>(L"BossBallLeft");

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossBallRight", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\ball.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossBallLeft", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\ball.wav");
		pSound->SetVolume(30.f);
		pSound->Play();

	}
}

void qBossBallState::FinalTick()
{
	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");


	if (L"BossBallRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 9)
		{
			if (m_OneShot == true)
			{
				// 다크니스 볼 발사
				qBossSkill_ball_right* pBossSkillBallRight = new qBossSkill_ball_right;
				pBossSkillBallRight->SetName(L"BossSkillBallRight");

				Vec2 vBossSkillBallRightPos = GetObj()->GetPos() + Vec2(70.f, 33.f);
				Vec2 vBossSkillBallRightScale = Vec2(120.f, 60.f);

				pBossSkillBallRight->SetPos(vBossSkillBallRightPos);
				pBossSkillBallRight->SetScale(vBossSkillBallRightScale);

				if (L"BossSkillBallRight" == pBossSkillBallRight->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillBallRight);
				}

				m_OneShot = false;
			}
		}

		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}

	if (L"BossBallLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 9)
		{
			if (m_OneShot == true)
			{
				// 다크니스 볼 발사
				qBossSkill_ball_left* pBossSkillBallLeft = new qBossSkill_ball_left;
				pBossSkillBallLeft->SetName(L"BossSkillBallLeft");

				Vec2 vBossSkillBallLeftPos = GetObj()->GetPos() + Vec2(-70.f, 33.f);
				Vec2 vBossSkillBallLeftScale = Vec2(120.f, 60.f);

				pBossSkillBallLeft->SetPos(vBossSkillBallLeftPos);
				pBossSkillBallLeft->SetScale(vBossSkillBallLeftScale);

				if (L"BossSkillBallLeft" == pBossSkillBallLeft->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillBallLeft);
				}

				m_OneShot = false;
			}
		}

		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}
	
	
}

void qBossBallState::Exit()
{
	m_OneShot = true;
	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qBossBallState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qBossBallState : public qState
{
public:

	CLONE(qBossBallState);

	qBossBallState();
	~qBossBallState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }


private:
	Vec2		m_Pos;
	Vec2		m_CenterPos;
	float		m_Time;
	float		m_Dir;
	bool		m_OneShot;
	qSound*		pSound;
};


```

`GameClient/qBossDeadState.cpp`:

```cpp
#include "pch.h"
#include "qBossDeadState.h"

#include "qSound.h"

qBossDeadState::qBossDeadState()
	: m_Time(0.f)
	, m_Dir(-1.f)
{
}

qBossDeadState::~qBossDeadState()
{
}

void qBossDeadState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossDeadRight", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\dead.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossDeadLeft", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\dead.wav");
		pSound->SetVolume(50.f);
		pSound->Play();
	}
}

void qBossDeadState::FinalTick()
{
	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");

	if (L"BossDeadRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();
		}
	}

	if (L"BossDeadLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();
		}
	}
}

void qBossDeadState::Exit()
{
}

```

`GameClient/qBossDeadState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qBossDeadState : public qState
{
public:
	CLONE(qBossDeadState);
	
	qBossDeadState();
	~qBossDeadState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }


private:
	Vec2		m_Pos;
	Vec2		m_CenterPos;
	float		m_Time;
	float		m_Dir;
	qSound*		pSound;

};


```

`GameClient/qBossEffect_ball.cpp`:

```cpp
#include "pch.h"
#include "qBossEffect_ball.h"

#include "qAnimator.h"

#include "qTaskMgr.h"


qBossEffect_ball::qBossEffect_ball()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BallEffect = qAssetMgr::GetInst()->LoadTexture(L"BallEffect", L"texture\\boss_effect\\ball\\ball.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"BallEffect", BallEffect, Vec2(0.f, 0.f), Vec2(200.f, 200.f), 6, 10);

	// Animation Save
	m_Animator->FindAnimation(L"BallEffect")->Save(L"animation\\boss_effect\\ball\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_effect\\ball\\BallEffect.anim");

	m_Animator->Play(L"BallEffect", false);


}

qBossEffect_ball::~qBossEffect_ball()
{
}

void qBossEffect_ball::tick()
{
	qObj::tick();

	if (L"BallEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

void qBossEffect_ball::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qBossEffect_ball.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qBossEffect_ball : public qObj
{
	CLONE(qBossEffect_ball);

public:
	qBossEffect_ball();
	~qBossEffect_ball();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
};


```

`GameClient/qBossEffect_firebird.cpp`:

```cpp
#include "pch.h"
#include "qBossEffect_firebird.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qBossEffect_firebird::qBossEffect_firebird()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* FirebirdEffect = qAssetMgr::GetInst()->LoadTexture(L"FirebirdEffect", L"texture\\boss_effect\\firebird\\firebird.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"FirebirdEffect", FirebirdEffect, Vec2(0.f, 0.f), Vec2(180.f, 180.f), 6, 10);

	// Animation Save
	m_Animator->FindAnimation(L"FirebirdEffect")->Save(L"animation\\boss_effect\\firebird\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_effect\\firebird\\FirebirdEffect.anim");

	m_Animator->Play(L"FirebirdEffect", false);
}

qBossEffect_firebird::~qBossEffect_firebird()
{
}

void qBossEffect_firebird::tick()
{
	qObj::tick();

	if (L"FirebirdEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

void qBossEffect_firebird::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qBossEffect_firebird.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qBossEffect_firebird : public qObj
{
public:
	CLONE(qBossEffect_firebird);

	qBossEffect_firebird();
	~qBossEffect_firebird();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
};


```

`GameClient/qBossEffect_genesis.cpp`:

```cpp
#include "pch.h"
#include "qBossEffect_genesis.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qBossEffect_genesis::qBossEffect_genesis()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* GenesisEffect = qAssetMgr::GetInst()->LoadTexture(L"GenesisEffect", L"texture\\boss_effect\\genesis\\genesis.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"GenesisEffect", GenesisEffect, Vec2(0.f, 0.f), Vec2(200.f, 200.f), 6, 10);

	// Animation Save
	m_Animator->FindAnimation(L"GenesisEffect")->Save(L"animation\\boss_effect\\genesis\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_effect\\genesis\\GenesisEffect.anim");

	m_Animator->Play(L"GenesisEffect", false);
}

qBossEffect_genesis::~qBossEffect_genesis()
{
}

void qBossEffect_genesis::tick()
{
	qObj::tick();

	if (L"GenesisEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

void qBossEffect_genesis::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qBossEffect_genesis.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qBossEffect_genesis : public qObj
{
	CLONE(qBossEffect_genesis);

public:
	qBossEffect_genesis();
	~qBossEffect_genesis();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
};


```

`GameClient/qBossEffect_tornado.cpp`:

```cpp
#include "pch.h"
#include "qBossEffect_tornado.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qBossEffect_tornado::qBossEffect_tornado()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* TornadoEffect = qAssetMgr::GetInst()->LoadTexture(L"TornadoEffect", L"texture\\boss_effect\\tornado\\tornado.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"TornadoEffect", TornadoEffect, Vec2(0.f, 0.f), Vec2(130.f, 130.f), 7, 10);

	// Animation Save
	m_Animator->FindAnimation(L"TornadoEffect")->Save(L"animation\\boss_effect\\tornado\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_effect\\tornado\\TornadoEffect.anim");

	m_Animator->Play(L"TornadoEffect", false);
}

qBossEffect_tornado::~qBossEffect_tornado()
{
}

void qBossEffect_tornado::tick()
{
	qObj::tick();

	if (L"TornadoEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

void qBossEffect_tornado::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qBossEffect_tornado.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qBossEffect_tornado : public qObj
{
public:
	CLONE(qBossEffect_tornado);

	qBossEffect_tornado();
	~qBossEffect_tornado();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
};


```

`GameClient/qBossFirebirdState.cpp`:

```cpp
#include "pch.h"
#include "qBossFirebirdState.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qBossSkill_firebird.h"
#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

qBossFirebirdState::qBossFirebirdState()
	: m_Time(0.f)
	, m_Dir(-1.f)
	, m_OneShot(true)
{
}

qBossFirebirdState::~qBossFirebirdState()
{
}

void qBossFirebirdState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossFirebirdRight", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\firebird.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossFirebirdLeft", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\firebird.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
}

void qBossFirebirdState::FinalTick()
{
	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");
	qObj* pPlayer = GetBlackboardData<qObj*>(L"Player");


	if (L"BossFirebirdRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 12)
		{
			if (m_OneShot == true)
			{
				// 불새 소환
				qBossSkill_firebird* pBossSkillFirebird = new qBossSkill_firebird;
				pBossSkillFirebird->SetName(L"BossSkillFirebird");

				Vec2 vBossSkillFirebirdScale = Vec2(700.f, 400.f);

				pBossSkillFirebird->SetPos(Vec2(pPlayer->GetPos().x, GetObj()->GetPos().y - 56.f));
				pBossSkillFirebird->SetScale(vBossSkillFirebirdScale);

				if (L"BossSkillFirebird" == pBossSkillFirebird->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillFirebird);
				}

				m_OneShot = false;

			}
		}


		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}

	else if (L"BossFirebirdLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 12)
		{
			if (m_OneShot == true)
			{
				// 불새 소환
				qBossSkill_firebird* pBossSkillFirebird = new qBossSkill_firebird;
				pBossSkillFirebird->SetName(L"BossSkillFirebird");

				Vec2 vBossSkillFirebirdScale = Vec2(700.f, 400.f);

				pBossSkillFirebird->SetPos(Vec2(pPlayer->GetPos().x, GetObj()->GetPos().y - 56.f));
				pBossSkillFirebird->SetScale(vBossSkillFirebirdScale);

				if (L"BossSkillFirebird" == pBossSkillFirebird->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillFirebird);
				}

				m_OneShot = false;

			}
		}



		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}
}

void qBossFirebirdState::Exit()
{
	m_OneShot = true;
	pSound->SetVolume(30.f);
	pSound->Stop();
}




```

`GameClient/qBossFirebirdState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qBossFirebirdState : public qState
{
public:
	CLONE(qBossFirebirdState);

	qBossFirebirdState();
	~qBossFirebirdState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }


private:
	Vec2		m_Pos;
	Vec2		m_CenterPos;
	float		m_Time;
	float		m_Dir;
	qSound*		pSound;
	bool		m_OneShot;
};


```

`GameClient/qBossGenesisState.cpp`:

```cpp
#include "pch.h"
#include "qBossGenesisState.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qBossSkill_genesis.h"
#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

qBossGenesisState::qBossGenesisState()
	: m_Time(0.f)
	, m_Dir(-1.f)
	, m_OneShot(true)
{
}

qBossGenesisState::~qBossGenesisState()
{
}

void qBossGenesisState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossGenesisRight", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\genesis.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossGenesisLeft", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\genesis.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
}

void qBossGenesisState::FinalTick()
{
	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");


	if (L"BossGenesisRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 5)
		{
			if (m_OneShot == true)
			{
				// 다크 제네시스 소환 1
				qBossSkill_genesis* pBossSkillGenesis1 = new qBossSkill_genesis;
				pBossSkillGenesis1->SetName(L"BossSkillGenesis1");

				Vec2 vBossSkillGenesisPos1 = GetObj()->GetPos() + Vec2(-550.f, -185.f);
				Vec2 vBossSkillGenesisScale1 = Vec2(300.f, 590.f);

				pBossSkillGenesis1->SetPos(vBossSkillGenesisPos1);
				pBossSkillGenesis1->SetScale(vBossSkillGenesisScale1);

				if (L"BossSkillGenesis1" == pBossSkillGenesis1->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis1);
				}


				// 다크 제네시스 소환 2
				qBossSkill_genesis* pBossSkillGenesis2 = new qBossSkill_genesis;
				pBossSkillGenesis2->SetName(L"BossSkillGenesis2");

				Vec2 vBossSkillGenesisPos2 = GetObj()->GetPos() + Vec2(-250.f, -185.f);
				Vec2 vBossSkillGenesisScale2 = Vec2(300.f, 590.f);

				pBossSkillGenesis2->SetPos(vBossSkillGenesisPos2);
				pBossSkillGenesis2->SetScale(vBossSkillGenesisScale2);

				if (L"BossSkillGenesis2" == pBossSkillGenesis2->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis2);
				}


				// 다크 제네시스 소환 3
				qBossSkill_genesis* pBossSkillGenesis3 = new qBossSkill_genesis;
				pBossSkillGenesis3->SetName(L"BossSkillGenesis3");

				Vec2 vBossSkillGenesisPos3 = GetObj()->GetPos() + Vec2(250.f, -185.f);
				Vec2 vBossSkillGenesisScale3 = Vec2(300.f, 590.f);

				pBossSkillGenesis3->SetPos(vBossSkillGenesisPos3);
				pBossSkillGenesis3->SetScale(vBossSkillGenesisScale3);

				if (L"BossSkillGenesis3" == pBossSkillGenesis3->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis3);
				}


				// 다크 제네시스 소환 4
				qBossSkill_genesis* pBossSkillGenesis4 = new qBossSkill_genesis;
				pBossSkillGenesis4->SetName(L"BossSkillGenesis4");

				Vec2 vBossSkillGenesisPos4 = GetObj()->GetPos() + Vec2(550.f, -185.f);
				Vec2 vBossSkillGenesisScale4 = Vec2(300.f, 590.f);

				pBossSkillGenesis4->SetPos(vBossSkillGenesisPos4);
				pBossSkillGenesis4->SetScale(vBossSkillGenesisScale4);

				if (L"BossSkillGenesis4" == pBossSkillGenesis4->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis4);
				}

				m_OneShot = false;

			}
		}


		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}



	else if (L"BossGenesisLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 5)
		{
			if (m_OneShot == true)
			{
				// 다크 제네시스 소환 1
				qBossSkill_genesis* pBossSkillGenesis1 = new qBossSkill_genesis;
				pBossSkillGenesis1->SetName(L"BossSkillGenesis1");

				Vec2 vBossSkillGenesisPos1 = GetObj()->GetPos() + Vec2(-550.f, -185.f);
				Vec2 vBossSkillGenesisScale1 = Vec2(300.f, 590.f);

				pBossSkillGenesis1->SetPos(vBossSkillGenesisPos1);
				pBossSkillGenesis1->SetScale(vBossSkillGenesisScale1);

				if (L"BossSkillGenesis1" == pBossSkillGenesis1->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis1);
				}


				// 다크 제네시스 소환 2
				qBossSkill_genesis* pBossSkillGenesis2 = new qBossSkill_genesis;
				pBossSkillGenesis2->SetName(L"BossSkillGenesis2");

				Vec2 vBossSkillGenesisPos2 = GetObj()->GetPos() + Vec2(-250.f, -185.f);
				Vec2 vBossSkillGenesisScale2 = Vec2(300.f, 590.f);

				pBossSkillGenesis2->SetPos(vBossSkillGenesisPos2);
				pBossSkillGenesis2->SetScale(vBossSkillGenesisScale2);

				if (L"BossSkillGenesis2" == pBossSkillGenesis2->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis2);
				}


				// 다크 제네시스 소환 3
				qBossSkill_genesis* pBossSkillGenesis3 = new qBossSkill_genesis;
				pBossSkillGenesis3->SetName(L"BossSkillGenesis3");

				Vec2 vBossSkillGenesisPos3 = GetObj()->GetPos() + Vec2(250.f, -185.f);
				Vec2 vBossSkillGenesisScale3 = Vec2(300.f, 590.f);

				pBossSkillGenesis3->SetPos(vBossSkillGenesisPos3);
				pBossSkillGenesis3->SetScale(vBossSkillGenesisScale3);

				if (L"BossSkillGenesis3" == pBossSkillGenesis3->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis3);
				}


				// 다크 제네시스 소환 4
				qBossSkill_genesis* pBossSkillGenesis4 = new qBossSkill_genesis;
				pBossSkillGenesis4->SetName(L"BossSkillGenesis4");

				Vec2 vBossSkillGenesisPos4 = GetObj()->GetPos() + Vec2(550.f, -185.f);
				Vec2 vBossSkillGenesisScale4 = Vec2(300.f, 590.f);

				pBossSkillGenesis4->SetPos(vBossSkillGenesisPos4);
				pBossSkillGenesis4->SetScale(vBossSkillGenesisScale4);

				if (L"BossSkillGenesis4" == pBossSkillGenesis4->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillGenesis4);
				}

				m_OneShot = false;

			}
		}

		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}
}

void qBossGenesisState::Exit()
{
	m_OneShot = true;
	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qBossGenesisState.h`:

```h
#pragma once
#include "qState.h"



class qSound;

class qBossGenesisState : public qState
{
public:
	CLONE(qBossGenesisState);

	qBossGenesisState();
	~qBossGenesisState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }


private:
	Vec2		m_Pos;
	Vec2		m_CenterPos;
	float		m_Time;
	float		m_Dir;
	qSound*		pSound;
	bool		m_OneShot;
};


```

`GameClient/qBossHP.cpp`:

```cpp
#include "pch.h"
#include "qBossHP.h"

qBossHP::qBossHP()
{
	m_HPImg = qAssetMgr::GetInst()->LoadTexture(L"hp", L"texture\\ui\\bosshud\\bosshp.png");
}

qBossHP::~qBossHP()
{
}

void qBossHP::tick_ui()
{
	GetBossHP();

	GetOwner()->GetAttackCount();
	GetOwner()->GetMissileCount();
	GetOwner()->GetSlashCount();
	GetOwner()->GetSpecialCount();
}

void qBossHP::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	//// AlphaBlending
	//BLENDFUNCTION bf = {};

	//bf.BlendOp = AC_SRC_OVER;
	//bf.BlendFlags = 0;
	//bf.SourceConstantAlpha = 255;
	//bf.AlphaFormat = AC_SRC_ALPHA;

	//AlphaBlend(DC, (int)(vPos.x)
	//	, (int)(vPos.y)
	//	, m_HPImg->GetWidth(), m_HPImg->GetHeight()
	//	, m_HPImg->GetDC(), 0, 0, m_HPImg->GetWidth(), m_HPImg->GetHeight(), bf);


	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_HPImg->GetWidth() - (m_HPImg->GetWidth() * GetOwner()->GetAttackCount() * 0.02380f + m_HPImg->GetWidth() * GetOwner()->GetMissileCount() * 0.02539f + m_HPImg->GetWidth() * GetOwner()->GetSlashCount() * 0.02698f + m_HPImg->GetWidth() * GetOwner()->GetSpecialCount() * 0.03968f), m_HPImg->GetHeight()
		, m_HPImg->GetDC()
		, 0, 0
		, m_HPImg->GetWidth(), m_HPImg->GetHeight(), SRCCOPY);
}

```

`GameClient/qBossHP.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;


class qBossHP : public qUI
{
public:
	CLONE(qBossHP);

	qBossHP();
	~qBossHP();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;

	void SetImage(qTexture* _Tex) { m_HPImg = _Tex; }


private:
	qTexture*		m_HPImg;

};


```

`GameClient/qBossHUD.cpp`:

```cpp
#include "pch.h"
#include "qBossHUD.h"

qBossHUD::qBossHUD()
{
	m_HUDImg = qAssetMgr::GetInst()->LoadTexture(L"hud", L"texture\\ui\\bosshud\\bosshud.png");
}

qBossHUD::~qBossHUD()
{
}

void qBossHUD::tick_ui()
{
	//qUI::tick();
}

void qBossHUD::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_HUDImg->GetWidth(), m_HUDImg->GetHeight()
		, m_HUDImg->GetDC(), 0, 0, m_HUDImg->GetWidth(), m_HUDImg->GetHeight(), bf);




}

```

`GameClient/qBossHUD.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qBossHUD : public qUI
{
public:
	CLONE(qBossHUD);

	qBossHUD();
	~qBossHUD();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;

	void SetImage(qTexture* _Tex) { m_HUDImg = _Tex; }



private:
	qTexture* m_HUDImg;
};


```

`GameClient/qBossIdleState.cpp`:

```cpp
#include "pch.h"
#include "qBossIdleState.h"
#include "qKeyMgr.h"


qBossIdleState::qBossIdleState()
	: m_Time(0.f)
	, m_Dir(-1.f)
{
}

qBossIdleState::~qBossIdleState()
{
}

void qBossIdleState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossIdleRight", true);
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossIdleLeft", true);
	}
	
}

void qBossIdleState::FinalTick()
{

	qObj* pPlayer = GetBlackboardData<qObj*>(L"Player");

	Vec2 PlayerPos = pPlayer->GetPos();
	Vec2 PlayerPrevPos = pPlayer->GetPrevPos();

	float fDist = m_CenterPos.x - PlayerPos.x;
	float PrevDir = m_Dir;

	if (fDist < 0)
	{
		SetDir(1.f);
	}
	else if (fDist > 0)
	{
		SetDir(-1.f);
	}

	if (m_Dir == 1.f && PrevDir != m_Dir)
	{
		GetAnimator()->Play(L"BossIdleRight", true);
		GetObj()->SetDir(DIRECTION::RIGHT);
	}
	else if (m_Dir == -1.f && PrevDir != m_Dir)
	{
		GetAnimator()->Play(L"BossIdleLeft", true);
		GetObj()->SetDir(DIRECTION::LEFT);
	}



	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");

	int state = rand() % 4;

	m_Time += DT;
	if (m_Time > 3.f)
	{
		if (state == 0)
		{
			GetFSM()->ChangeState(L"Ball");
		}
		else if (state == 1)
		{
			GetFSM()->ChangeState(L"Genesis");
		}
		else if (state == 2)
		{
			GetFSM()->ChangeState(L"Firebird");
		}
		else if (state == 3)
		{
			GetFSM()->ChangeState(L"Tornado");
		}
	}

	if (KEY_TAP(KEY::Q))
	{
		GetFSM()->ChangeState(L"Ball");
	}
	else if (KEY_TAP(KEY::W))
	{
		GetFSM()->ChangeState(L"Genesis");
	}
	else if (KEY_TAP(KEY::E))
	{
		GetFSM()->ChangeState(L"Firebird");
	}
	else if (KEY_TAP(KEY::R))
	{
		GetFSM()->ChangeState(L"Tornado");
	}

	
}

void qBossIdleState::Exit()
{
	m_Time = 0.f;
}

```

`GameClient/qBossIdleState.h`:

```h
#pragma once
#include "qState.h"

class qBossIdleState : public qState
{
public:

	CLONE(qBossIdleState);

	qBossIdleState();
	~qBossIdleState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }

private:
	Vec2		m_Pos;
	float		m_Time;
	Vec2		m_CenterPos;
	float		m_Dir;
};


```

`GameClient/qBossSkill_ball_left.cpp`:

```cpp
#include "pch.h"
#include "qBossSkill_ball_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

#include "qBossEffect_ball.h"
#include "qDamage_physical.h"


qBossSkill_ball_left::qBossSkill_ball_left()
	: m_BallSpeed(500.f)
{

	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BossSkillBallLeft = qAssetMgr::GetInst()->LoadTexture(L"BossSkillBallLeft", L"texture\\boss_skill\\ball\\ball_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"BossSkillBallLeft", BossSkillBallLeft, Vec2(0.f, 0.f), Vec2(120.f, 60.f), 8, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"BossSkillBallLeft")->Save(L"animation\\boss_skill\\ball\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\boss_skill\\ball\\BossSkillBallLeft.anim");

	m_Animator->Play(L"BossSkillBallLeft", true);



	// 콜라이더
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 0.f));
	m_Collider->SetScale(Vec2(120.f, 60.f));
}

qBossSkill_ball_left::qBossSkill_ball_left(const qBossSkill_ball_left& _Other)
	: m_BallSpeed(500.f)
{
	m_Animator = GetComponent<qAnimator>();
}

qBossSkill_ball_left::~qBossSkill_ball_left()
{
}

void qBossSkill_ball_left::tick()
{
	qObj::tick();

	Vec2 vPos = GetPos();
	Vec2 vDir = Vec2(-1.f, 0.f);

	vPos += vDir * m_BallSpeed * DT;

	SetPos(vPos);
}

void qBossSkill_ball_left::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qBossEffect_ball* pBallEffect = new qBossEffect_ball;
		pBallEffect->SetName(L"BallEffect");

		Vec2 vBallEffectPos = _OtherObj->GetPos() + Vec2(30.f, -20.f);
		Vec2 vBallEffectScale = Vec2(200.f, 200.f);

		pBallEffect->SetPos(vBallEffectPos);
		pBallEffect->SetScale(vBallEffectScale);

		if (L"BallEffect" == pBallEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pBallEffect);
		}
	}

	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qDamage_physical* pDamagePhysical = new qDamage_physical;
		pDamagePhysical->SetName(L"DamagePhysical");

		Vec2 vDamagePhysicalPos = _OtherObj->GetPos() + Vec2(0.f, -80.f);
		Vec2 vDamagePhysicalScale = Vec2(181.f, 58.f);

		pDamagePhysical->SetPos(vDamagePhysicalPos);
		pDamagePhysical->SetScale(vDamagePhysicalScale);

		if (L"DamagePhysical" == pDamagePhysical->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamagePhysical);
		}
	}



	// 적과 부딪혔을때 Destroy();
	if (_OtherObj->GetName() == L"Player")
	{
		Destroy();
	}
}

```

`GameClient/qBossSkill_ball_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qBossSkill_ball_left : public qObj
{
	CLONE(qBossSkill_ball_left);

public:
	qBossSkill_ball_left();
	qBossSkill_ball_left(const qBossSkill_ball_left& _Other);
	~qBossSkill_ball_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;

	float			m_BallSpeed;
};


```

`GameClient/qBossSkill_ball_right.cpp`:

```cpp
#include "pch.h"
#include "qBossSkill_ball_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

#include "qBossEffect_ball.h"
#include "qDamage_physical.h"

qBossSkill_ball_right::qBossSkill_ball_right()
	: m_BallSpeed(500.f)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BossSkillBallRight = qAssetMgr::GetInst()->LoadTexture(L"BossSkillBallRight", L"texture\\boss_skill\\ball\\ball_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"BossSkillBallRight", BossSkillBallRight, Vec2(0.f, 0.f), Vec2(120.f, 60.f), 8, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"BossSkillBallRight")->Save(L"animation\\boss_skill\\ball\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\boss_skill\\ball\\BossSkillBallRight.anim");

	m_Animator->Play(L"BossSkillBallRight", true);



	// 콜라이더
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 0.f));
	m_Collider->SetScale(Vec2(120.f, 60.f));
}

qBossSkill_ball_right::~qBossSkill_ball_right()
{
}

void qBossSkill_ball_right::tick()
{
	qObj::tick();

	Vec2 vPos = GetPos();
	Vec2 vDir = Vec2(1.f, 0.f);

	vPos += vDir * m_BallSpeed * DT;

	SetPos(vPos);
}

void qBossSkill_ball_right::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qBossEffect_ball* pBallEffect = new qBossEffect_ball;
		pBallEffect->SetName(L"BallEffect");

		Vec2 vBallEffectPos = _OtherObj->GetPos() + Vec2(-30.f, -20.f);
		Vec2 vBallEffectScale = Vec2(200.f, 200.f);

		pBallEffect->SetPos(vBallEffectPos);
		pBallEffect->SetScale(vBallEffectScale);

		if (L"BallEffect" == pBallEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pBallEffect);
		}
	}

	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qDamage_physical* pDamagePhysical = new qDamage_physical;
		pDamagePhysical->SetName(L"DamagePhysical");

		Vec2 vDamagePhysicalPos = _OtherObj->GetPos() + Vec2(0.f, -80.f);
		Vec2 vDamagePhysicalScale = Vec2(181.f, 58.f);

		pDamagePhysical->SetPos(vDamagePhysicalPos);
		pDamagePhysical->SetScale(vDamagePhysicalScale);

		if (L"DamagePhysical" == pDamagePhysical->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamagePhysical);
		}
	}



	// 적과 부딪혔을때 Destroy();
	if (_OtherObj->GetName() == L"Player")
	{
		Destroy();
	}
}

```

`GameClient/qBossSkill_ball_right.h`:

```h
#pragma once
#include "qObj.h"

class qBossSkill_ball_right : public qObj
{
public:
	CLONE(qBossSkill_ball_right);

	qBossSkill_ball_right();
	~qBossSkill_ball_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;

	float			m_BallSpeed;
};


```

`GameClient/qBossSkill_firebird.cpp`:

```cpp
#include "pch.h"
#include "qBossSkill_firebird.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

#include "qBossEffect_firebird.h"
#include "qDamage_magic.h"

qBossSkill_firebird::qBossSkill_firebird()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BossSkillFirebird = qAssetMgr::GetInst()->LoadTexture(L"BossSkillFirebird", L"texture\\boss_skill\\firebird\\firebird.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"BossSkillFirebird", BossSkillFirebird, Vec2(0.f, 0.f), Vec2(700.f, 400.f), 20, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"BossSkillFirebird")->Save(L"animation\\boss_skill\\firebird\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\boss_skill\\firebird\\BossSkillFirebird.anim");

	m_Animator->Play(L"BossSkillFirebird", false);




	// 콜라이더
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(10.f, 3.f));
	//m_Collider->SetScale(Vec2(450.f, 300.f));
	m_Collider->SetScale(Vec2(0.f, 0.f));

}

qBossSkill_firebird::~qBossSkill_firebird()
{
}

void qBossSkill_firebird::tick()
{
	qObj::tick();

	if (m_Animator->GetCurAnim()->GetCurFrmIdx() == 12)
	{
		m_Collider->SetScale(Vec2(450.f, 300.f));
	}


	if (L"BossSkillFirebird" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();
		}
	}
}

void qBossSkill_firebird::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qBossEffect_firebird* pFirebirdEffect = new qBossEffect_firebird;
		pFirebirdEffect->SetName(L"FirebirdEffect");

		Vec2 vFirebirdEffectPos = _OtherObj->GetPos() + Vec2(0.f, -20.f);
		Vec2 vFirebirdEffectScale = Vec2(180.f, 180.f);

		pFirebirdEffect->SetPos(vFirebirdEffectPos);
		pFirebirdEffect->SetScale(vFirebirdEffectScale);

		if (L"FirebirdEffect" == pFirebirdEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pFirebirdEffect);
		}
	}

	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qDamage_magic* pDamageMagic = new qDamage_magic;
		pDamageMagic->SetName(L"DamageMagic");

		Vec2 vDamageMagicPos = _OtherObj->GetPos() + Vec2(0.f, -80.f);
		Vec2 vDamageMagicScale = Vec2(181.f, 58.f);

		pDamageMagic->SetPos(vDamageMagicPos);
		pDamageMagic->SetScale(vDamageMagicScale);

		if (L"DamageMagic" == pDamageMagic->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageMagic);
		}
	}
}

```

`GameClient/qBossSkill_firebird.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qBossSkill_firebird : public qObj
{
	CLONE(qBossSkill_firebird);

public:
	qBossSkill_firebird();
	~qBossSkill_firebird();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;
};


```

`GameClient/qBossSkill_genesis.cpp`:

```cpp
#include "pch.h"
#include "qBossSkill_genesis.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

#include "qBossEffect_genesis.h"
#include "qDamage_magic.h"

qBossSkill_genesis::qBossSkill_genesis()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BossSkillGenesis = qAssetMgr::GetInst()->LoadTexture(L"BossSkillGenesis", L"texture\\boss_skill\\genesis\\genesis.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"BossSkillGenesis", BossSkillGenesis, Vec2(0.f, 0.f), Vec2(300.f, 590.f), 26, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"BossSkillGenesis")->Save(L"animation\\boss_skill\\genesis\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\boss_skill\\genesis\\BossSkillGenesis.anim");

	m_Animator->Play(L"BossSkillGenesis", false);


	// 콜라이더
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 10.f));
	m_Collider->SetScale(Vec2(0.f, 0.f));
}

qBossSkill_genesis::~qBossSkill_genesis()
{

}

void qBossSkill_genesis::tick()
{
	qObj::tick();

	if (m_Animator->GetCurAnim()->GetCurFrmIdx() == 12)
	{
		m_Collider->SetScale(Vec2(190.f, 550.f));
	}


	if (L"BossSkillGenesis" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();
		}
	}

}

void qBossSkill_genesis::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qBossEffect_genesis* pGenesisEffect = new qBossEffect_genesis;
		pGenesisEffect->SetName(L"GenesisEffect");

		Vec2 vGenesisEffectPos = _OtherObj->GetPos() + Vec2(0.f, -20.f);
		Vec2 vGenesisEffectScale = Vec2(200.f, 200.f);

		pGenesisEffect->SetPos(vGenesisEffectPos);
		pGenesisEffect->SetScale(vGenesisEffectScale);

		if (L"GenesisEffect" == pGenesisEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pGenesisEffect);
		}
	}



	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qDamage_magic* pDamageMagic = new qDamage_magic;
		pDamageMagic->SetName(L"DamageMagic");

		Vec2 vDamageMagicPos = _OtherObj->GetPos() + Vec2(0.f, -80.f);
		Vec2 vDamageMagicScale = Vec2(181.f, 58.f);

		pDamageMagic->SetPos(vDamageMagicPos);
		pDamageMagic->SetScale(vDamageMagicScale);

		if (L"DamageMagic" == pDamageMagic->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageMagic);
		}
	}
}

```

`GameClient/qBossSkill_genesis.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qBossSkill_genesis : public qObj
{
	CLONE(qBossSkill_genesis);

public:

	qBossSkill_genesis();
	~qBossSkill_genesis();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;
};


```

`GameClient/qBossSkill_tornado.cpp`:

```cpp
#include "pch.h"
#include "qBossSkill_tornado.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

#include "qBossEffect_tornado.h"
#include "qDamage_physical.h"

qBossSkill_tornado::qBossSkill_tornado()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* BossSkillTornado = qAssetMgr::GetInst()->LoadTexture(L"BossSkillTornado", L"texture\\boss_skill\\tornado\\tornado.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"BossSkillTornado", BossSkillTornado, Vec2(0.f, 0.f), Vec2(265.f, 600.f), 14, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"BossSkillTornado")->Save(L"animation\\boss_skill\\tornado\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\boss_skill\\tornado\\BossSkillTornado.anim");

	m_Animator->Play(L"BossSkillTornado", false);


	// 콜라이더
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 22.f));
	m_Collider->SetScale(Vec2(0.f, 0.f));
}

qBossSkill_tornado::~qBossSkill_tornado()
{
}

void qBossSkill_tornado::tick()
{
	qObj::tick();

	if (m_Animator->GetCurAnim()->GetCurFrmIdx() == 3)
	{
		m_Collider->SetScale(Vec2(150.f, 400.f));
	}


	if (L"BossSkillTornado" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();
		}
	}
}

void qBossSkill_tornado::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qBossEffect_tornado* pTornadoEffect = new qBossEffect_tornado;
		pTornadoEffect->SetName(L"TornadoEffect");

		Vec2 vTornadoEffectPos = _OtherObj->GetPos() + Vec2(0.f, -20.f);
		Vec2 vTonardoEffectScale = Vec2(130.f, 130.f);

		pTornadoEffect->SetPos(vTornadoEffectPos);
		pTornadoEffect->SetScale(vTonardoEffectScale);

		if (L"TornadoEffect" == pTornadoEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pTornadoEffect);
		}
	}


	if (LAYER_TYPE::PLAYER == _OtherObj->GetLayerType())
	{
		qDamage_physical* pDamagePhysical = new qDamage_physical;
		pDamagePhysical->SetName(L"DamagePhysical");

		Vec2 vDamagePhysicalPos = _OtherObj->GetPos() + Vec2(0.f, -80.f);
		Vec2 vDamagePhysicalScale = Vec2(181.f, 58.f);

		pDamagePhysical->SetPos(vDamagePhysicalPos);
		pDamagePhysical->SetScale(vDamagePhysicalScale);

		if (L"DamagePhysical" == pDamagePhysical->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamagePhysical);
		}
	}


}

```

`GameClient/qBossSkill_tornado.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qBossSkill_tornado : public qObj
{
	CLONE(qBossSkill_tornado);

public:
	qBossSkill_tornado();
	~qBossSkill_tornado();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;

};


```

`GameClient/qBossTornadoState.cpp`:

```cpp
#include "pch.h"
#include "qBossTornadoState.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qBossSkill_tornado.h"
#include "qLevel.h"
#include "qLevelMgr.h"

#include "qTaskMgr.h"

qBossTornadoState::qBossTornadoState()
	: m_Time(0.f)
	, m_Dir(-1.f)
	, m_OneShot(true)
{

}

qBossTornadoState::~qBossTornadoState()
{
	
}

void qBossTornadoState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}
	else if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"BossTornadoRight", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\tornado.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"BossTornadoLeft", false);

		// 스킬 사운드
		pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\boss\\tornado.wav");
		pSound->SetVolume(30.f);
		pSound->Play();
	}
}

void qBossTornadoState::FinalTick()
{
	qObj* pBoss = GetBlackboardData<qObj*>(L"Boss");
	qObj* pPlayer = GetBlackboardData<qObj*>(L"Player");

	if (L"BossTornadoRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 18)
		{
			if (m_OneShot == true)
			{
				// 불새 소환
				qBossSkill_tornado* pBossSkillTornado = new qBossSkill_tornado;
				pBossSkillTornado->SetName(L"BossSkillTornado");

				Vec2 vBossSkillTornadoScale = Vec2(265.f, 600.f);

				pBossSkillTornado->SetPos(Vec2(pPlayer->GetPos().x, GetObj()->GetPos().y - 130.f));
				pBossSkillTornado->SetScale(vBossSkillTornadoScale);

				if (L"BossSkillTornado" == pBossSkillTornado->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillTornado);
				}

				m_OneShot = false;

			}
		}



		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}

	if (L"BossTornadoLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->GetCurAnim()->GetCurFrmIdx() == 18)
		{
			if (m_OneShot == true)
			{
				// 불새 소환
				qBossSkill_tornado* pBossSkillTornado = new qBossSkill_tornado;
				pBossSkillTornado->SetName(L"BossSkillTornado");

				Vec2 vBossSkillTornadoScale = Vec2(265.f, 600.f);

				pBossSkillTornado->SetPos(Vec2(pPlayer->GetPos().x, GetObj()->GetPos().y - 130.f));
				pBossSkillTornado->SetScale(vBossSkillTornadoScale);

				if (L"BossSkillTornado" == pBossSkillTornado->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::BOSS_SKILL, pBossSkillTornado);
				}

				m_OneShot = false;

			}
		}



		if (GetAnimator()->IsFinish())
		{
			GetFSM()->ChangeState(L"Idle");
		}
	}
}

void qBossTornadoState::Exit()
{
	m_OneShot = true;
	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qBossTornadoState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qBossTornadoState : public qState
{
public:
	CLONE(qBossTornadoState);

	qBossTornadoState();
	~qBossTornadoState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;

	void SetDir(float _Dir) { m_Dir = _Dir; }
	float GetDir() { return m_Dir; }


private:
	Vec2		m_Pos;
	Vec2		m_CenterPos;
	float		m_Time;
	float		m_Dir;
	qSound*		pSound;
	bool		m_OneShot;
};


```

`GameClient/qButton.cpp`:

```cpp
#include "pch.h"
#include "qButton.h"

qButton::qButton()
	: m_Func(nullptr)
	, m_NormalImg(nullptr)
	, m_HoverImg(nullptr)
	, m_DownImg(nullptr)
{
	m_NormalImg = qAssetMgr::GetInst()->LoadTexture(L"normal", L"texture\\ui\\btn\\scania\\btn1.png");
	m_HoverImg = qAssetMgr::GetInst()->LoadTexture(L"hover", L"texture\\ui\\btn\\scania\\btn2.png");
	m_DownImg = qAssetMgr::GetInst()->LoadTexture(L"down", L"texture\\ui\\btn\\scania\\btn3.png");
}

qButton::~qButton()
{
}

void qButton::tick_ui()
{
	//qUI::tick();

	if (IsLbtnDowned())
	{
		LButtonClicked();
	}
}

void qButton::render_ui()
{
	//qUI::render_ui();

	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;


	if (IsLbtnDowned())
	{
		if (nullptr == m_DownImg)
			qUI::render_ui();

		AlphaBlend(DC, (int)(vPos.x)
			, (int)(vPos.y)
			, m_DownImg->GetWidth(), m_DownImg->GetHeight()
			, m_DownImg->GetDC(), 0, 0, m_DownImg->GetWidth(), m_DownImg->GetHeight(), bf);

	}
	else if (IsMouseOn())
	{

		if (nullptr == m_HoverImg)
			qUI::render_ui();


		AlphaBlend(DC, (int)(vPos.x)
			, (int)(vPos.y)
			, m_HoverImg->GetWidth(), m_HoverImg->GetHeight()
			, m_HoverImg->GetDC(), 0, 0, m_HoverImg->GetWidth(), m_HoverImg->GetHeight(), bf);


	}
	else
	{
		if (nullptr == m_NormalImg)
			qUI::render_ui();

		AlphaBlend(DC, (int)(vPos.x)
			, (int)(vPos.y)
			, m_NormalImg->GetWidth(), m_NormalImg->GetHeight()
			, m_NormalImg->GetDC(), 0, 0, m_NormalImg->GetWidth(), m_NormalImg->GetHeight(), bf);

	}

	
	
}

void qButton::LButtonClicked()
{
	if (nullptr != m_Func)
	{
		m_Func();
	}
}

```

`GameClient/qButton.h`:

```h
#pragma once
#include "qUI.h"

typedef void(*BUTTON_CALLBACK)(void);

class qButton : public qUI
{
public:
	CLONE(qButton);

	qButton();
	~qButton();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;
	virtual void LButtonClicked() override;

public:
	void SetCallBack(BUTTON_CALLBACK _Func) { m_Func = _Func; }

	void SetNormalImage(qTexture* _Tex) { m_NormalImg = _Tex; }
	void SetHoverImage(qTexture* _Tex) { m_HoverImg = _Tex; }
	void SetDownImage(qTexture* _Tex) { m_DownImg = _Tex; }


private:
	BUTTON_CALLBACK		m_Func;
	qTexture*			m_NormalImg;
	qTexture*			m_HoverImg;
	qTexture*			m_DownImg;
};


```

`GameClient/qCamera.cpp`:

```cpp
#include "pch.h"
#include "qCamera.h"

#include "qEngine.h"
#include "qKeyMgr.h"
#include "qTimeMgr.h"
#include "qPlayer.h"
#include "qLevelMgr.h"
#include "qLevel.h"

#include "qObj.h"
#include "qBackground_stage1.h"
#include "qBackground_stage2.h"

qCamera::qCamera()
	: m_CamSpeed(500.f)
	, m_FadeTex(nullptr)
	, m_RightBlock(false)
{
}

qCamera::~qCamera()
{
}

void qCamera::init()
{
	Vec2 vResol = qEngine::GetInst()->GetResolution();
	m_LookAt = Vec2(vResol.x * 0.5f, vResol.y * 0.5f);

	//// 윈도우 해상도랑 동일한 크기의 검은색 텍스쳐를 생성
	m_FadeTex = qAssetMgr::GetInst()->CreateTexture(L"FadeTexture", (UINT)vResol.x, (UINT)vResol.y);

	//// 윈도우 해상도랑 동일한 크기의 붉은색 텍스쳐를 생성
	//m_RedTex = qAssetMgr::GetInst()->CreateTexture(L"RedTexture", (UINT)vResol.x, (UINT)vResol.y);

	//// Red Texture 에 Red Brush로 Rectangle 을 그린다.
	//USE_BRUSH(m_RedTex->GetDC(), BRUSH_TYPE::BRUSH_RED);
	//Rectangle(m_RedTex->GetDC(), -1, -1, (UINT)vResol.x + 1, (UINT)vResol.y + 1);

	//for (UINT Row = 0; Row < vResol.y; ++Row)
	//{
	//	for (UINT Col = 0; Col < vResol.x; ++Col)
	//	{
	//		SetPixel(m_RedTex->GetDC(), Col, Row, RGB(255, 0, 0));
	//	}
	//}
}

void qCamera::tick()
{
	// 카메라 이동
	Move();
	
	// 해상도 중심과 카메라가 바라보고 있는 지점 간의 차이값
	Vec2 vResol = qEngine::GetInst()->GetResolution();
	m_Diff = m_LookAt - Vec2(vResol.x * 0.5f, vResol.y * 0.5f);

	// 카메라 효과
	CameraEffect();


}

void qCamera::render()
{
	if (m_EffectList.empty())
		return;

	CAM_EFFECT_INFO& info = m_EffectList.front();

	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = (int)info.Alpha;
	bf.AlphaFormat = 0;

	AlphaBlend(DC, 0, 0, m_FadeTex->GetWidth(), m_FadeTex->GetHeight()
		, m_FadeTex->GetDC(), 0, 0, m_FadeTex->GetWidth(), m_FadeTex->GetHeight(), bf);
}


void qCamera::Move()
{
	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();

	if (nullptr == pCurLevel)
		return;

	if(pCurLevel->GetName() == L"Editor")
	{
		if (KEY_PRESSED(KEY::W))
			m_LookAt.y -= DT * m_CamSpeed;
		if (KEY_PRESSED(KEY::S))
			m_LookAt.y += DT * m_CamSpeed;
		if (KEY_PRESSED(KEY::A))
			m_LookAt.x -= DT * m_CamSpeed;
		if (KEY_PRESSED(KEY::D))
			m_LookAt.x += DT * m_CamSpeed;
	}
	if (pCurLevel->GetName() == L"Stage1")
	{
		qBackground_stage1* BackGround = (qBackground_stage1*)pCurLevel->FindObjectByName(L"Stage1");
		
		if (nullptr == BackGround)
			return;
		
		if (!m_Owner)
			return;
		
		//m_LookAt = m_Owner->GetPos();
		
		UINT Width = BackGround->GetWidth();
		UINT Height = BackGround->GetHeight();
		
		// 카메라 벽 못넘게 하기
		Vec2 vPos = GetRealPos(m_Owner->GetPos());
		Vec2 vRenderPos = m_Owner->GetRenderPos();
		
		// 현재 위치 표시
		wchar_t szBuff[256] = {};
		static float fTime = 0.f;
		fTime += DT;
		if (fTime >= 1.f)
		{
			swprintf_s(szBuff, L"x : %f, y : %f", vPos.x, vPos.y);
			LOG(LOG_TYPE::DBG_ERROR, szBuff);
			fTime = 0.f;
		}
		
		if (vPos.x <= 800.f)
		{
			m_LookAt.x = 800.f;
		}

		// 스테이지 1 카메라 못넘게하기 (오른쪽) == 3535
		else if (vPos.x >= 3535.f)
		{
			m_LookAt.x = Width - 800;
		}
		else
		{
			m_LookAt.x = m_Owner->GetPos().x;
		}
		
		m_LookAt.y = 477.f;
		
}
	else if (pCurLevel->GetName() == L"Stage2")
	{
		qBackground_stage2* BackGround = (qBackground_stage2*)pCurLevel->FindObjectByName(L"Stage2");
		
		if (nullptr == BackGround)
			return;

		//m_LookAt.x = m_Owner->GetPos().x;
		//m_LookAt.y = m_Owner->GetPos().y;

		UINT Width = BackGround->GetWidth();
		UINT Height = BackGround->GetHeight();
		
		// 카메라 벽 못넘게 하기
		Vec2 vPos = GetRealPos(m_Owner->GetPos());
		Vec2 vRenderPos = m_Owner->GetRenderPos();
		
		//현재 위치 표시
		wchar_t szBuff[256] = {};
		static float fTime = 0.f;
		fTime += DT;
		if (fTime >= 1.f)
		{
			swprintf_s(szBuff, L"x : %f, y : %f", vPos.x, vPos.y);
			LOG(LOG_TYPE::DBG_ERROR, szBuff);
			fTime = 0.f;
		}
		// X 좌표 계산
		// 왼쪽 벽 못넘게 하기
		if (vPos.x <= 800.f)
		{
			m_LookAt.x = 800.f;
		}
		//스테이지 2 카메라 못넘게하기 (오른쪽) == 1561
		else if (vPos.x >= 1561.f)
		{
			m_LookAt.x = Width - 800;
		}
		else
		{
			m_LookAt.x = m_Owner->GetPos().x;
		}

		float vDist = m_LookAt.y - vPos.y;

		m_LookAt.y = 1190.f;

		// Y좌표 계산
		//if (vDist < -150.f)
		//{
		//	m_LookAt.y = Height * 0.7;
		//}
		//else if (vDist >= -150.f)
		//{
		//	m_LookAt.y = m_Owner->GetPos().y;
		//}
		//else if (vDist <= -150.f && vDist >= 60)
		//{
		//	m_LookAt.y = Height * 0.5;
		//}
		
		
	}
	else if (pCurLevel->GetName() == L"Boss1")
	{
		qBackground_stage2* BackGround = (qBackground_stage2*)pCurLevel->FindObjectByName(L"Boss1");

		if (nullptr == BackGround)
			return;


		UINT Width = BackGround->GetWidth();
		UINT Height = BackGround->GetHeight();

		// 카메라 벽 못넘게 하기
		Vec2 vPos = GetRealPos(m_Owner->GetPos());
		Vec2 vRenderPos = m_Owner->GetRenderPos();
		wchar_t szBuff[256] = {};
		static float fTime = 0.f;
		fTime += DT;
		if (fTime >= 1.f)
		{
			swprintf_s(szBuff, L"x : %f, y : %f", vPos.x, vPos.y);
			LOG(LOG_TYPE::DBG_ERROR, szBuff);
			fTime = 0.f;
		}
		if (vPos.x <= 800.f)
		{
			m_LookAt.x = 800.f;
		}
		// 보스 1 카메라 못넘게하기 (오른쪽) == 
		else if (vPos.x >= 1246.f)
		{
			m_LookAt.x = Width - 800;
		}
		else
		{
			m_LookAt.x = m_Owner->GetPos().x;
		}
		
		m_LookAt.y = 496.f;
	}

	else if (pCurLevel->GetName() == L"Boss2")
	{
		qBackground_stage2* BackGround = (qBackground_stage2*)pCurLevel->FindObjectByName(L"Boss2");

		if (nullptr == BackGround)
			return;


		UINT Width = BackGround->GetWidth();
		UINT Height = BackGround->GetHeight();

		// 카메라 벽 못넘게 하기
		Vec2 vPos = GetRealPos(m_Owner->GetPos());
		Vec2 vRenderPos = m_Owner->GetRenderPos();
		wchar_t szBuff[256] = {};
		static float fTime = 0.f;
		fTime += DT;
		if (fTime >= 1.f)
		{
			swprintf_s(szBuff, L"x : %f, y : %f", vPos.x, vPos.y);
			LOG(LOG_TYPE::DBG_ERROR, szBuff);
			fTime = 0.f;
		}
		if (vPos.x <= 800.f)
		{
			m_LookAt.x = 800.f;
		}
		// 보스 1 카메라 못넘게하기 (오른쪽) == 
		else if (vPos.x >= 1246.f)
		{
			m_LookAt.x = Width - 800;
		}

		else
		{
			m_LookAt.x = m_Owner->GetPos().x;
		}

		m_LookAt.y = 485.f;
	}
}

void qCamera::CameraEffect()
{
	while (true)
	{
		if (m_EffectList.empty())
			return;

		CAM_EFFECT_INFO& info = m_EffectList.front();
		info.Time += DT;

		if (info.Duration < info.Time)
		{
			m_EffectList.pop_front();
		}
		else
		{
			break;
		}
	}

	CAM_EFFECT_INFO& info = m_EffectList.front();

	if (CAM_EFFECT::FADE_IN == info.Effect)
	{
		info.Alpha = (1.f - (info.Time / info.Duration)) * 255.f;
	}
	else if (CAM_EFFECT::FADE_OUT == info.Effect)
	{
		info.Alpha = (info.Time / info.Duration) * 255.f;
	}
}

void qCamera::SetCameraEffect(CAM_EFFECT _Effect, float _Duration)
{
	CAM_EFFECT_INFO info = {};

	info.Effect = _Effect;
	info.Duration = _Duration;
	info.Time = 0.f;
	info.Alpha = 0.f;

	m_EffectList.push_back(info);
}

```

`GameClient/qCamera.h`:

```h
#pragma once

enum class CAM_EFFECT
{
	FADE_IN,
	FADE_OUT,
	NONE,
};

struct CAM_EFFECT_INFO
{
	CAM_EFFECT		Effect;
	float			Duration;
	float			Time;
	float			Alpha;

};

class qObj;
class qTexture;

class qCamera
{
	SINGLE(qCamera)

public:
	void init();
	void tick();
	void render();

public:
	Vec2 GetRenderPos(Vec2 _RealPos) { return _RealPos - m_Diff; }
	Vec2 GetRealPos(Vec2 _RenderPos) { return _RenderPos + m_Diff; }
	void SetCameraEffect(CAM_EFFECT _Effect, float _Duration);

	void SetOwner(qObj* _Owner) { m_Owner = _Owner; }


private:
	void Move();
	void CameraEffect();

private:
	Vec2					m_LookAt;
	Vec2					m_Diff;
	float					m_CamSpeed;
	
	bool					m_RightBlock;

	qObj*					m_Owner;	

	list<CAM_EFFECT_INFO>	m_EffectList;

	qTexture*				m_FadeTex;
	qTexture*				m_RedTex;

};


```

`GameClient/qCollider.cpp`:

```cpp
#include "pch.h"
#include "qCollider.h"

#include "qLevelMgr.h"
#include "qLevel.h"

qCollider::qCollider()
	: m_Active(true)
	, m_OverlapCount(0)
	, m_bRegister(true)
{
}

qCollider::qCollider(const qCollider& _Other)
	: qComponent(_Other)
	, m_OffsetPos(_Other.m_OffsetPos)
	, m_Scale(_Other.m_Scale)
	, m_OverlapCount(0)
	, m_Active(_Other.m_Active)
	, m_bRegister(_Other.m_bRegister)
{
}

qCollider::~qCollider()
{
}

void qCollider::finaltick()
{
	m_FinalPos = GetOwner()->GetPos() + m_OffsetPos;

	if (m_bRegister)
	{
		// 충돌체를 소유하고 있는 오브젝트의 소속 레이어에 자신을 등록시킨다.
		qLevel* pLevel = qLevelMgr::GetInst()->GetCurrentLevel();
		pLevel->RegisterCollider(this);

		// 비활성화 상태면 등록옵션을 정지한다. (다음번 프레임부터 등록이 되지 않는다.)
		if (!m_Active)
		{
			m_bRegister = false;
		}

	}

	// 비활성화 상태의 충돌체는 DebugRender 를 요청하지 않는다.
	if (!m_Active)
	{
		return;
	}

	if (0 != m_OverlapCount)
	{
		DrawDebugRect(PEN_TYPE::PEN_RED, m_FinalPos, m_Scale, 0.f);
	}
	else
	{
		DrawDebugRect(PEN_TYPE::PEN_GREEN, m_FinalPos, m_Scale, 0.f);
	}

}


void qCollider::BeginOverlap(qCollider* _OtherCollider)
{
	m_OverlapCount++;

	GetOwner()->BeginOverlap(this, _OtherCollider->GetOwner(), _OtherCollider);
}

void qCollider::OnOverlap(qCollider* _OtherCollider)
{
	GetOwner()->OnOverlap(this, _OtherCollider->GetOwner(), _OtherCollider);
}

void qCollider::EndOverlap(qCollider* _OtherCollider)
{
	m_OverlapCount--;

	GetOwner()->EndOverlap(this, _OtherCollider->GetOwner(), _OtherCollider);
}

```

`GameClient/qCollider.h`:

```h
#pragma once
#include "qComponent.h"

class qCollider : public qComponent
{
public:

	CLONE(qCollider);

	friend class qCollisionMgr;

	qCollider();
	qCollider(const qCollider& _Other);
	~qCollider();


public:
	virtual void finaltick() override;
	

public:
	void SetOffsetPos(Vec2 _Offset) { m_OffsetPos = _Offset; }
	void SetScale(Vec2 _Scale) { m_Scale = _Scale; }

	Vec2 GetFinalPos() { return m_FinalPos; }
	Vec2 GetScale() { return m_Scale; }

	void SetActive(bool _Set) 
	{ 
		m_Active = _Set; 

		if (m_Active)
		{
			m_bRegister = true;
		}
	}

	bool IsActive() { return m_Active; }


private:

	void BeginOverlap(qCollider* _OtherCollider);
	void OnOverlap(qCollider* _OtherCollider);
	void EndOverlap(qCollider* _OtherCollider);


private:
	Vec2	m_OffsetPos;		// 소유 오브젝트로부터 상대적인 좌표
	Vec2	m_Scale;

	Vec2	m_FinalPos;			// 최종 좌표 (소유 오브젝트 포지션 + 오프셋 포즈)
	
	
	UINT	m_OverlapCount;		// 카운트를 활용하여 충돌상태를 체크한다.

	bool	m_Active;			// 충돌체 활성화, 비활성화 상태 bool
	bool	m_bRegister;		// 충돌체를 레벨에 등록할지 말지의 상태
};


```

`GameClient/qCollisionMgr.cpp`:

```cpp
#include "pch.h"
#include "qCollisionMgr.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qCollider.h"


qCollisionMgr::qCollisionMgr()
	: m_Matrix{}
{

}

qCollisionMgr::~qCollisionMgr()
{

}

void qCollisionMgr::init()
{

}

void qCollisionMgr::tick()
{
	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();

	for (int Row = 0; Row < (UINT)LAYER_TYPE::END; ++Row)
	{
		for (int Col = 0; Col < (UINT)LAYER_TYPE::END; ++Col)
		{
			if (m_Matrix[Row] & (1 << Col))
			{
				const vector<qCollider*>& vecLeft = pCurLevel->GetColliders((LAYER_TYPE)Row);
				const vector<qCollider*>& vecRight = pCurLevel->GetColliders((LAYER_TYPE)Col);

				for (size_t i = 0; i < vecLeft.size(); ++i)
				{
					for (size_t j = 0; j < vecRight.size(); ++j)
					{
						COLLIDER_ID id = {};

						id.LeftID = vecLeft[i]->GetID();
						id.RightID = vecRight[j]->GetID();

						map<ULONGLONG, bool>::iterator iter = m_mapCollisionInfo.find(id.ID);

						// 등록된 적이 없으면 등록시킨다.
						if (iter == m_mapCollisionInfo.end())
						{
							m_mapCollisionInfo.insert(make_pair(id.ID, false));
							iter = m_mapCollisionInfo.find(id.ID);
						}

						bool bDead = vecLeft[i]->GetOwner()->IsDead() || vecRight[j]->GetOwner()->IsDead();
						bool bDeactive = !vecLeft[i]->IsActive() || !vecRight[j]->IsActive();

						// 두 충돌체가 지금 충돌중이다.
						if (IsCollision(vecLeft[i], vecRight[j]))
						{
							// 이전에도 충돌중이었다.
							if (iter->second)
							{
								vecLeft[i]->OnOverlap(vecRight[j]);
								vecRight[j]->OnOverlap(vecLeft[i]);
							}

							// 이전에는 충돌중이 아니었다.
							else
							{
								vecLeft[i]->BeginOverlap(vecRight[j]);
								vecRight[j]->BeginOverlap(vecLeft[i]);
							}

							iter->second = true;

							// 두 충돌체 중 하나라도 Dead 상태거나, 비활성화 상태라면 추가로 충돌 해제를 호출시켜 준다.
							if (bDead || bDeactive)
							{
								vecLeft[i]->EndOverlap(vecRight[j]);
								vecRight[j]->EndOverlap(vecLeft[i]);

								iter->second = false;
							}
						}

						// 두 충돌체가 지금 충돌중이 아니다.
						else
						{
							// 이전에는 충돌중이었다.
							if (iter->second)
							{
								vecLeft[i]->EndOverlap(vecRight[j]);
								vecRight[j]->EndOverlap(vecLeft[i]);
							}

							iter->second = false;
						}
					}
				}

			}
		}
	}
}


void qCollisionMgr::CollisionCheck(LAYER_TYPE Layer1, LAYER_TYPE Layer2)
{
	UINT Row = (UINT)Layer1;
	UINT Col = (UINT)Layer2;

	if (Row > Col)
	{
		Row = (UINT)Layer2;
		Col = (UINT)Layer1;
	}

	m_Matrix[Row] |= (1 << Col);
	// m_Matrix[Row] = m_Matrix[Row] | (1 << Col);
}

void qCollisionMgr::CollisionUnCheck(LAYER_TYPE _Layer1, LAYER_TYPE _Layer2)
{
	UINT Row = (UINT)_Layer1;
	UINT Col = (UINT)_Layer2;

	if (Row > Col)
	{
		Row = (UINT)_Layer2;
		Col = (UINT)_Layer1;
	}

	m_Matrix[Row] &= ~(1 << Col);
}


bool qCollisionMgr::IsCollision(qCollider* _Left, qCollider* _Right)
{
	Vec2 vLeftPos = _Left->GetFinalPos();
	Vec2 vLeftScale = _Left->GetScale();

	Vec2 vRightPos = _Right->GetFinalPos();
	Vec2 vRightScale = _Right->GetScale();

	if (abs(vLeftPos.x - vRightPos.x) <= (vLeftScale.x + vRightScale.x) * 0.5f
		&& abs(vLeftPos.y - vRightPos.y) <= (vLeftScale.y + vRightScale.y) * 0.5f)
	{
		return true;
	}

	return false;
}


```

`GameClient/qCollisionMgr.h`:

```h
#pragma once

class qCollider;

union COLLIDER_ID
{
	struct
	{
		DWORD LeftID;
		DWORD RightID;
	};

	ULONGLONG ID;
};

class qCollisionMgr
{
	SINGLE(qCollisionMgr)

private:
	WORD					m_Matrix[(UINT)LAYER_TYPE::END];

	// 각각의 충돌체가 서로 이전에도 충돌중이었는지에 대한 정보를 저장하고 있어야 한다.
	map<ULONGLONG, bool>	m_mapCollisionInfo;
	

public:
	void CollisionCheck(LAYER_TYPE _Layer1, LAYER_TYPE _Layer2);
	void CollisionCheckClear() { memset(m_Matrix, 0, sizeof(WORD) * (UINT)LAYER_TYPE::END); }
	void CollisionUnCheck(LAYER_TYPE _Layer1, LAYER_TYPE _Layer2);


private:
	bool IsCollision(qCollider* _Left, qCollider* _Right);



public:
	void init();
	void tick();

};


```

`GameClient/qComponent.cpp`:

```cpp
#include "pch.h"
#include "qComponent.h"

qComponent::qComponent()
	: m_Owner(nullptr)
{
}

qComponent::qComponent(const qComponent& _Other)
	: m_Owner(nullptr)
{
}

qComponent::~qComponent()
{
}

```

`GameClient/qComponent.h`:

```h
#pragma once
#include "qEntity.h"

#include "qObj.h"

class qComponent : public qEntity
{
private:
	qObj*		m_Owner;		// 컴포넌트를 소유하고 있는 오브젝트

public:
	qObj* GetOwner() { return m_Owner; }


public:
	virtual void finaltick() = 0;
	virtual qComponent* Clone() = 0;


public:
	qComponent();
	qComponent(const qComponent& _Other);
	~qComponent();

	friend class qObj;

};


```

`GameClient/qDamage_attack.cpp`:

```cpp
#include "pch.h"
#include "qDamage_attack.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qDamage_attack::qDamage_attack()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageAttack = qAssetMgr::GetInst()->LoadTexture(L"DamageAttack", L"texture\\damage\\attack\\attack.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageAttack", DamageAttack, Vec2(0.f, 0.f), Vec2(258.f, 112.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageAttack")->Save(L"animation\\damage\\attack\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\damage\\attack\\DamageAttack.anim");

	m_Animator->Play(L"DamageAttack", false);

}

qDamage_attack::qDamage_attack(const qDamage_attack& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qDamage_attack::~qDamage_attack()
{
}

void qDamage_attack::tick()
{
	qObj::tick();

	if (L"DamageAttack" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}


```

`GameClient/qDamage_attack.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qDamage_attack : public qObj
{
	CLONE(qDamage_attack);

public:
	qDamage_attack();
	qDamage_attack(const qDamage_attack& _Other);
	~qDamage_attack();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_magic.cpp`:

```cpp
#include "pch.h"
#include "qDamage_magic.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qDamage_magic::qDamage_magic()
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageMagic = qAssetMgr::GetInst()->LoadTexture(L"DamageMagic", L"texture\\boss_damage\\magic\\magic.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageMagic", DamageMagic, Vec2(0.f, 0.f), Vec2(181.f, 58.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageMagic")->Save(L"animation\\boss_damage\\magic\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_damage\\magic\\DamageMagic.anim");

	m_Animator->Play(L"DamageMagic", false);
}

qDamage_magic::~qDamage_magic()
{
}

void qDamage_magic::tick()
{
	qObj::tick();

	if (L"DamageMagic" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_magic.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qDamage_magic : public qObj
{
	CLONE(qDamage_magic);

public:
	qDamage_magic();
	~qDamage_magic();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_miss.cpp`:

```cpp
#include "pch.h"
#include "qDamage_miss.h"

#include "qAnimator.h"

#include "qTaskMgr.h"

qDamage_miss::qDamage_miss()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageMiss = qAssetMgr::GetInst()->LoadTexture(L"DamageMiss", L"texture\\damage\\miss\\miss.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageMiss", DamageMiss, Vec2(0.f, 0.f), Vec2(140.f, 60.f), 5, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageMiss")->Save(L"animation\\damage\\miss\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\damage\\miss\\DamageMiss.anim");

	m_Animator->Play(L"DamageMiss", false);
}

qDamage_miss::qDamage_miss(const qDamage_miss& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qDamage_miss::~qDamage_miss()
{
}

void qDamage_miss::tick()
{
	qObj::tick();

	if (L"DamageMiss" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_miss.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qDamage_miss : public qObj
{
	CLONE(qDamage_miss);

public:
	qDamage_miss();
	qDamage_miss(const qDamage_miss& _Other);
	~qDamage_miss();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }


private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_missile.cpp`:

```cpp
#include "pch.h"
#include "qDamage_missile.h"

#include "qAnimator.h"
#include "qTaskMgr.h"


qDamage_missile::qDamage_missile()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageMissile = qAssetMgr::GetInst()->LoadTexture(L"DamageMissile", L"texture\\damage\\missile\\missile.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageMissile", DamageMissile, Vec2(0.f, 0.f), Vec2(258.f, 112.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageMissile")->Save(L"animation\\damage\\missile\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\damage\\missile\\DamageMissile.anim");

	m_Animator->Play(L"DamageMissile", false);
}

qDamage_missile::qDamage_missile(const qDamage_missile& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qDamage_missile::~qDamage_missile()
{
}

void qDamage_missile::tick()
{
	qObj::tick();

	if (L"DamageMissile" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_missile.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;

class qDamage_missile : public qObj
{
	CLONE(qDamage_missile);

public:
	qDamage_missile();
	qDamage_missile(const qDamage_missile& _Other);
	~qDamage_missile();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_physical.cpp`:

```cpp
#include "pch.h"
#include "qDamage_physical.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qDamage_physical::qDamage_physical()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamagePhysical = qAssetMgr::GetInst()->LoadTexture(L"DamagePhysical", L"texture\\boss_damage\\physical\\physical.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamagePhysical", DamagePhysical, Vec2(0.f, 0.f), Vec2(181.f, 58.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamagePhysical")->Save(L"animation\\boss_damage\\physical\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\boss_damage\\physical\\DamagePhysical.anim");

	m_Animator->Play(L"DamagePhysical", false);
}

qDamage_physical::~qDamage_physical()
{
}

void qDamage_physical::tick()
{
	qObj::tick();

	if (L"DamagePhysical" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_physical.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;
class qTexture;

class qDamage_physical : public qObj
{
	CLONE(qDamage_physical);

public:
	qDamage_physical();
	~qDamage_physical();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_slash.cpp`:

```cpp
#include "pch.h"
#include "qDamage_slash.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qDamage_slash::qDamage_slash()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageSlash = qAssetMgr::GetInst()->LoadTexture(L"DamageSlash", L"texture\\damage\\slash\\slash.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageSlash", DamageSlash, Vec2(0.f, 0.f), Vec2(258.f, 112.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageSlash")->Save(L"animation\\damage\\slash\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\damage\\slash\\DamageSlash.anim");

	m_Animator->Play(L"DamageSlash", false);
}

qDamage_slash::qDamage_slash(const qDamage_slash& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qDamage_slash::~qDamage_slash()
{
}

void qDamage_slash::tick()
{
	qObj::tick();

	if (L"DamageSlash" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_slash.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;

class qDamage_slash : public qObj
{
	CLONE(qDamage_slash);

public:
	qDamage_slash();
	qDamage_slash(const qDamage_slash& _Other);
	~qDamage_slash();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDamage_special.cpp`:

```cpp
#include "pch.h"
#include "qDamage_special.h"

#include "qAnimator.h"
#include "qTaskMgr.h"

qDamage_special::qDamage_special()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DamageSpecial = qAssetMgr::GetInst()->LoadTexture(L"DamageSpecial", L"texture\\damage\\special\\special.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"DamageSpecial", DamageSpecial, Vec2(0.f, 0.f), Vec2(322.f, 216.f), 14, 10);

	// Animation Save
	m_Animator->FindAnimation(L"DamageSpecial")->Save(L"animation\\damage\\special\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\damage\\special\\DamageSpecial.anim");

	m_Animator->Play(L"DamageSpecial", false);
}

qDamage_special::qDamage_special(const qDamage_special& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qDamage_special::~qDamage_special()
{
}

void qDamage_special::tick()
{
	qObj::tick();

	if (L"DamageSpecial" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

		}
	}
}

```

`GameClient/qDamage_special.h`:

```h
#pragma once
#include "qObj.h"

class qAnimator;

class qDamage_special : public qObj
{
	CLONE(qDamage_special);

public:
	qDamage_special();
	qDamage_special(const qDamage_special& _Other);
	~qDamage_special();

	virtual void tick();

	qAnimator* GetAnimator() { return m_Animator; }

private:
	qAnimator* m_Animator;
};


```

`GameClient/qDbgRender.cpp`:

```cpp
#include "pch.h"
#include "qDbgRender.h"

#include "qEngine.h"
#include "qTimeMgr.h"
#include "qKeyMgr.h"
#include "qCamera.h"

qDbgRender::qDbgRender()
	: m_bRender(true)
	, m_LogLife(2.f)
	, m_LogSpace(18)
	, m_LogStartPos(Vec2(10.f, 10.f))
{
	
}

qDbgRender::~qDbgRender()
{

}

void qDbgRender::tick()
{
	if (KEY_TAP(KEY::_7))
	{
		m_bRender ? m_bRender = false : m_bRender = true;
	}
}

void qDbgRender::render()
{
	list<tDbgRenderInfo>::iterator iter = m_RenderList.begin();

	for (; iter != m_RenderList.end();)
	{
		USE_BRUSH(DC, BRUSH_TYPE::BRUSH_HOLLOW);
		qSelectObj SelectPen(DC, qEngine::GetInst()->GetPen(iter->Color));

		Vec2 vRenderPos = qCamera::GetInst()->GetRenderPos(iter->Position);

		// DBG 가 Rect 면 사각형을 그린다.
		if (m_bRender && DBG_SHAPE::RECT == iter->Shape)
		{
			Rectangle(DC,
				  (int)(vRenderPos.x - iter->Scale.x / 2.f)
				, (int)(vRenderPos.y - iter->Scale.y / 2.f)
				, (int)(vRenderPos.x + iter->Scale.x / 2.f)
				, (int)(vRenderPos.y + iter->Scale.y / 2.f));
		}

		// DBG 가 Circle 면 원을 그린다.
		else if(m_bRender && DBG_SHAPE::CIRCLE == iter->Shape)
		{
			Ellipse(DC,
				  (int)(iter->Position.x - iter->Scale.x / 2.f)
				, (int)(iter->Position.y - iter->Scale.y / 2.f)
				, (int)(iter->Position.x + iter->Scale.x / 2.f)
				, (int)(iter->Position.y + iter->Scale.y / 2.f));
		}
		// DBG 가 Line 이면 선을 그린다.
		else if (m_bRender && DBG_SHAPE::LINE == iter->Shape)
		{
			Vec2 vEndPos = qCamera::GetInst()->GetRenderPos(iter->Scale);

			// MoveToEx 현재 위치를 지정된 시점으로 옮긴다.
			MoveToEx(DC, (int)vRenderPos.x, (int)vEndPos.y, nullptr);

			// 현재 위치에서 지정된 시점까지 선을 그린다.
			LineTo(DC, (int)vRenderPos.x, (int)vEndPos.y);
		}

		// 해당 디버그렌더 정보가 수명을 다하면 리스트에서 제거한다.
		(*iter).Age += DT;
		if (iter->Duration < iter->Age)
		{
			iter = m_RenderList.erase(iter);
		}
		else
		{
			++iter;
		}
	}


	// 로그 정보 출력
	list<tDbgLog>::iterator logiter = m_LogList.begin();

	SetBkMode(DC, TRANSPARENT);

	int i = 0;
	for (; logiter != m_LogList.end();)
	{
		if (m_bRender)
		{
			// 오래된 로그일수록 아래쪽에 출력이 되어야 함
			// 로그의 y 축 offset 위치를 구함
			int yoffset = ((int)m_LogList.size() - (i + 1)) * m_LogSpace;

			switch (logiter->Type)
			{
			case LOG_TYPE::DBG_LOG:
				SetTextColor(DC, RGB(255, 255, 255));
				break;
			case LOG_TYPE::DBG_WARNING:
				SetTextColor(DC, RGB(240, 240, 20));
				break;
			case LOG_TYPE::DBG_ERROR:
				SetTextColor(DC, RGB(240, 20, 20));
				break;
			}

			TextOut(DC
					, (int)m_LogStartPos.x
					, (int)m_LogStartPos.y + yoffset
					, logiter->strLog.c_str()
					, (int)logiter->strLog.length());
		}

		// 로그 나이 계산
		logiter->Age += DT;

		// 수명이 넘은 로그는 삭제
		if (m_LogLife <= logiter->Age)
		{
			logiter = m_LogList.erase(logiter);
		}
		else
		{
			++logiter;
		}

		++i;
	}

	SetBkMode(DC, OPAQUE);
	SetTextColor(DC, RGB(0, 0, 0));

}

```

`GameClient/qDbgRender.h`:

```h
#pragma once
class qDbgRender
{
	SINGLE(qDbgRender)


private:
	list<tDbgRenderInfo>	m_RenderList;
	list<tDbgLog>			m_LogList;
	bool					m_bRender;


	float					m_LogLife;			// 남아있는 시간
	int						m_LogSpace;			// 장간
	Vec2					m_LogStartPos;		// 시작 위치


public:
	void AddDbgRenderInfo(const tDbgRenderInfo& _info)
	{
		m_RenderList.push_back(_info);
	}

	void AddDbgLog(const tDbgLog& _info) { m_LogList.push_back(_info); }


	bool IsDbgRender() { return m_bRender; }

public:
	void tick();
	void render();
};


```

`GameClient/qDummy_blue.cpp`:

```cpp
#include "pch.h"
#include "qDummy_blue.h"

#include "qCollider.h"
#include "qTexture.h"

qDummy_blue::qDummy_blue()
{
	// 콜라이더 설정
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(Vec2(65.f, 85.f));

	m_Img = qAssetMgr::GetInst()->LoadTexture(L"monster_blue", L"texture\\edit\\monster_blue.png");

	SetName(L"DummyBlue");
}

qDummy_blue::qDummy_blue(const qDummy_blue& _Other)
{
	m_Collider = GetComponent<qCollider>();

	m_Img = qAssetMgr::GetInst()->LoadTexture(L"monster_blue", L"texture\\edit\\monster_blue.png");
}

qDummy_blue::~qDummy_blue()
{
}

void qDummy_blue::begin()
{
	qObj::begin();
}

void qDummy_blue::tick()
{
	qObj::tick();
}

void qDummy_blue::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC
		, (int)(vPos.x - m_Img->GetWidth() * 0.5f)
		, (int)(vPos.y - m_Img->GetHeight() * 0.5f)
		, m_Img->GetWidth()
		, m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight()
		, bf);
}

```

`GameClient/qDummy_blue.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;
class qCollider;

class qDummy_blue : public qObj
{
public:
	CLONE(qDummy_blue);

	qDummy_blue();
	qDummy_blue(const qDummy_blue& _Other);
	~qDummy_blue();


public:
	virtual void begin() override;
	virtual void tick() override;
	virtual void render() override;


private:
	Vec2			m_Pos;
	qTexture*		m_Img;
	qCollider*		m_Collider;
};


```

`GameClient/qDummy_red.cpp`:

```cpp
#include "pch.h"
#include "qDummy_red.h"

#include "qCollider.h"
#include "qTexture.h"

qDummy_red::qDummy_red()
{
	// 콜라이더 설정
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(Vec2(57.f, 70.f));

	m_Img = qAssetMgr::GetInst()->LoadTexture(L"monster_red", L"texture\\edit\\monster_red.png");

	SetName(L"DummyRed");
}

qDummy_red::qDummy_red(const qDummy_red& _Other)
{
	m_Collider = GetComponent<qCollider>();

	m_Img = qAssetMgr::GetInst()->LoadTexture(L"monster_red", L"texture\\edit\\monster_red.png");
}

qDummy_red::~qDummy_red()
{
}

void qDummy_red::begin()
{
	qObj::begin();
}

void qDummy_red::tick()
{
	qObj::tick();
}

void qDummy_red::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC
		, (int)(vPos.x - m_Img->GetWidth() * 0.5f)
		, (int)(vPos.y - m_Img->GetHeight() * 0.5f)
		, m_Img->GetWidth()
		, m_Img->GetHeight()
		, m_Img->GetDC()
		, 0, 0
		, m_Img->GetWidth(), m_Img->GetHeight()
		, bf);
}

```

`GameClient/qDummy_red.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;
class qCollider;

class qDummy_red : public qObj
{
public:
	CLONE(qDummy_red);

	qDummy_red();
	qDummy_red(const qDummy_red& _Other);
	~qDummy_red();


public:
	virtual void begin() override;
	virtual void tick() override;
	virtual void render() override;


private:
	Vec2			m_Pos;
	qTexture*		m_Img;
	qCollider*		m_Collider;
};


```

`GameClient/qEffect_attack.cpp`:

```cpp
#include "pch.h"
#include "qEffect_attack.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qTaskMgr.h"

qEffect_attack::qEffect_attack()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* AttackEffect = qAssetMgr::GetInst()->LoadTexture(L"AttackEffect", L"texture\\effect\\attack\\attack.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"AttackEffect", AttackEffect, Vec2(0.f, 0.f), Vec2(150.f, 150.f), 8, 10);

	// Animation Save
	m_Animator->FindAnimation(L"AttackEffect")->Save(L"animation\\effect\\attack\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\effect\\attack\\AttackEffect.anim");

	m_Animator->Play(L"AttackEffect", false);

	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\effect\\attack.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qEffect_attack::qEffect_attack(const qEffect_attack& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qEffect_attack::~qEffect_attack()
{
}

void qEffect_attack::tick()
{
	qObj::tick();

	if (L"AttackEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qEffect_attack::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{

}

```

`GameClient/qEffect_attack.h`:

```h
#pragma once
#include "qObj.h"

class qSound;
class qAnimator;
class qTexture;

class qEffect_attack : public qObj
{
	CLONE(qEffect_attack);

public:
	qEffect_attack();
	qEffect_attack(const qEffect_attack& _Other);
	~qEffect_attack();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qEffect_missile.cpp`:

```cpp
#include "pch.h"
#include "qEffect_missile.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qTaskMgr.h"

qEffect_missile::qEffect_missile()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* MissileEffect = qAssetMgr::GetInst()->LoadTexture(L"MissileEffect", L"texture\\effect\\missile\\missile.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"MissileEffect", MissileEffect, Vec2(0.f, 0.f), Vec2(150.f, 130.f), 8, 10);

	// Animation Save
	m_Animator->FindAnimation(L"MissileEffect")->Save(L"animation\\effect\\missile\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\effect\\missile\\MissileEffect.anim");

	m_Animator->Play(L"MissileEffect", false);

	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\effect\\missile.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qEffect_missile::qEffect_missile(const qEffect_missile& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qEffect_missile::~qEffect_missile()
{
}

void qEffect_missile::tick()
{
	qObj::tick();

	if (L"MissileEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qEffect_missile::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qEffect_missile.h`:

```h
#pragma once
#include "qObj.h"

class qSound;
class qAnimator;
class qTexture;



class qEffect_missile : public qObj
{
	CLONE(qEffect_missile);

public:
	qEffect_missile();
	qEffect_missile(const qEffect_missile& _Other);
	~qEffect_missile();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qEffect_slash.cpp`:

```cpp
#include "pch.h"
#include "qEffect_slash.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qTaskMgr.h"

qEffect_slash::qEffect_slash()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SlashEffect = qAssetMgr::GetInst()->LoadTexture(L"SlashEffect", L"texture\\effect\\slash\\slash.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"SlashEffect", SlashEffect, Vec2(0.f, 0.f), Vec2(200.f, 200.f), 7, 10);

	// Animation Save
	m_Animator->FindAnimation(L"SlashEffect")->Save(L"animation\\effect\\slash\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\effect\\slash\\SlashEffect.anim");

	m_Animator->Play(L"SlashEffect", false);

	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\effect\\slash.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qEffect_slash::qEffect_slash(const qEffect_slash& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qEffect_slash::~qEffect_slash()
{
}

void qEffect_slash::tick()
{
	qObj::tick();

	if (L"SlashEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qEffect_slash::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}




```

`GameClient/qEffect_slash.h`:

```h
#pragma once
#include "qObj.h"

class qSound;
class qAnimator;
class qTexture;


class qEffect_slash : public qObj
{
	CLONE(qEffect_slash);

public:
	qEffect_slash();
	qEffect_slash(const qEffect_slash& _Other);
	~qEffect_slash();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qSound* pSound;

};


```

`GameClient/qEffect_special.cpp`:

```cpp
#include "pch.h"
#include "qEffect_special.h"

#include "qAnimator.h"
#include "qSound.h"

#include "qTaskMgr.h"


qEffect_special::qEffect_special()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SpecialEffect = qAssetMgr::GetInst()->LoadTexture(L"SpecialEffect", L"texture\\effect\\special\\special.png");

	// Animation CREATE
	m_Animator->CreateAnimation(L"SpecialEffect", SpecialEffect, Vec2(0.f, 0.f), Vec2(330.f, 345.f), 11, 10);

	// Animation Save
	m_Animator->FindAnimation(L"SpecialEffect")->Save(L"animation\\effect\\special\\");

	// Animation Load
	m_Animator->LoadAnimation(L"animation\\effect\\special\\SpecialEffect.anim");

	m_Animator->Play(L"SpecialEffect", false);

	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\effect\\special.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qEffect_special::qEffect_special(const qEffect_special& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qEffect_special::~qEffect_special()
{
}

void qEffect_special::tick()
{
	qObj::tick();

	if (L"SpecialEffect" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qEffect_special::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

```

`GameClient/qEffect_special.h`:

```h
#pragma once
#include "qObj.h"

class qSound;
class qAnimator;
class qTexture;

class qEffect_special : public qObj
{
public:

	CLONE(qEffect_special);

	qEffect_special();
	qEffect_special(const qEffect_special& _Other);
	~qEffect_special();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qSound* pSound;

};


```

`GameClient/qEngine.cpp`:

```cpp
#include "pch.h"
#include "qEngine.h"

#include "qPathMgr.h"
#include "qLevelMgr.h"
#include "qTimeMgr.h"
#include "qDbgRender.h"
#include "qKeyMgr.h"
#include "qCollisionMgr.h"
#include "qAssetMgr.h"
#include "qTaskMgr.h"
#include "qCamera.h"
#include "qUIMgr.h"
#include "qSoundMgr.h"

#include "qTexture.h"

qEngine::qEngine()
	: m_hMainWnd(nullptr)
	, m_Resolution{}
	, m_hDC(nullptr)
	, m_arrPen{}
	, m_arrBrush{}
{

}

qEngine::~qEngine()
{
	// DC 삭제
	ReleaseDC(m_hMainWnd, m_hDC);

	// Pen 삭제
	for (int i = 0; i < (UINT)PEN_TYPE::END; i++)
	{
		DeleteObject(m_arrPen[i]);
	}
	
	// Brush 삭제
	for (int i = 0; i < (UINT)BRUSH_TYPE::END; i++)
	{
		DeleteObject(m_arrBrush[i]);
	}

}

int qEngine::init(HINSTANCE _hInst, HWND _hWnd, POINT _Resolution)
{
	m_hInstance = _hInst;
	m_hMainWnd = _hWnd;
	m_Resolution = _Resolution;

	// 입력된 해상도를 가져가기 위한 실제 윈도우의 크기를 계산
	RECT rt = { 0, 0, m_Resolution.x, m_Resolution.y };
	AdjustWindowRect(&rt, WS_OVERLAPPEDWINDOW, false);


	// 윈도우 크기를 변경
	SetWindowPos(m_hMainWnd, nullptr, 0, 0, rt.right - rt.left, rt.bottom - rt.top, 0);
	
	// DC, 펜, 브러쉬 생성
	CreateDefaultGDIObject();

	// Manager 초기화
	qPathMgr::GetInst()->init();
	qKeyMgr::GetInst()->init();
	qTimeMgr::GetInst()->init();
	qSoundMgr::GetInst()->init();
	qAssetMgr::GetInst()->init();
	qLevelMgr::GetInst()->init();

	qCamera::GetInst()->init();
	


	return S_OK;

}

void qEngine::progress()
{
	// ============
	// Manager Tick
	// ============
	qTimeMgr::GetInst()->tick();
	qKeyMgr::GetInst()->tick();
	qDbgRender::GetInst()->tick();
	qCamera::GetInst()->tick();
	qUIMgr::GetInst()->tick();

	// ==============
	// Level Progress
	// ==============
	qLevelMgr::GetInst()->progress();
	qCollisionMgr::GetInst()->tick();

	// =========
	// Rendering
	// =========
	// 화면 Clear
	{
		USE_BRUSH(m_SubTex->GetDC(), BRUSH_TYPE::BRUSH_GRAY);
		Rectangle(m_SubTex->GetDC(), -1, -1, m_Resolution.x + 1, m_Resolution.y + 1);
	}

	qLevelMgr::GetInst()->render();
	qCamera::GetInst()->render();
	qDbgRender::GetInst()->render();

	// Sub -> Main
	BitBlt(m_hDC, 0, 0, m_Resolution.x, m_Resolution.y, m_SubTex->GetDC(), 0, 0, SRCCOPY);

	// =========
	// Task 처리
	// =========
	qTaskMgr::GetInst()->tick();
}

void qEngine::CreateDefaultGDIObject()
{
	// DC(Device Context) 생성
	// DC 란? 렌더링과 관련
	// 비트맵에 렌더링하기 위해 필요한 필수 정보 집합체
	// DC 보유 정보
	// GetDC 로 생성되는 DC 의 정보
	// 목적지 비트맵 - 입력 윈도우의 비트맵

	// 메인 윈도우를 타겟으로 지정하는 DC 생성
	m_hDC = ::GetDC(m_hMainWnd);

	// 메인 비트맵(윈도우) 에 출력하기 전에 먼저 그림들이 그려지는 텍스쳐
	m_SubTex = qAssetMgr::GetInst()->CreateTexture(L"SubTexture", (UINT)m_Resolution.x, (UINT)m_Resolution.y);



	// 자주 사용할 펜 생성
	m_arrPen[(UINT)PEN_TYPE::PEN_RED] = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
	m_arrPen[(UINT)PEN_TYPE::PEN_GREEN] = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
	m_arrPen[(UINT)PEN_TYPE::PEN_BLUE] = CreatePen(PS_SOLID, 1, RGB(0, 0, 255));

	// 자주 사용할 브러쉬 생성
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_RED] = CreateSolidBrush(RGB(255, 0, 0));
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_GREEN] = CreateSolidBrush(RGB(0, 255, 0));
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_BLUE] = CreateSolidBrush(RGB(0, 0, 255));
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_GRAY] = CreateSolidBrush(RGB(100, 100, 100));
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_HOLLOW] = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
	m_arrBrush[(UINT)BRUSH_TYPE::BRUSH_BLACK] = (HBRUSH)GetStockObject(BLACK_BRUSH);


}

HDC qEngine::GetSubDC()
{
	return m_SubTex->GetDC();
}

```

`GameClient/qEngine.h`:

```h
#pragma once
// 게임 최고 관리자

class qTexture;

class qEngine
{
	SINGLE(qEngine)

private:
	HINSTANCE	m_hInstance;		// 프로세스 메모리 핸들
	HWND		m_hMainWnd;			// 메인 윈도우 핸들
	POINT		m_Resolution;		// 메인 윈도우 해상도
	HDC			m_hDC;				// 메인 윈도우 DC

	qTexture*	m_SubTex;			// 더블 버퍼링 용도 텍스쳐

	HPEN		m_arrPen[(UINT)PEN_TYPE::END];
	HBRUSH		m_arrBrush[(UINT)BRUSH_TYPE::END];


public:
	int init(HINSTANCE _hInst, HWND _hWnd, POINT _Resolution);
	void progress();

private:
	void CreateDefaultGDIObject();


public:
	HINSTANCE GetProcessInstance() { return m_hInstance; }
	HWND GetMainWnd() { return m_hMainWnd; }
	HDC GetMainDC() { return m_hDC; }
	HDC GetSubDC();

	Vec2 GetResolution() { return m_Resolution; }

	HPEN GetPen(PEN_TYPE _type) { return m_arrPen[(UINT)_type]; }
	HBRUSH GetBrush(BRUSH_TYPE _type) { return m_arrBrush[(UINT)_type]; }

};


```

`GameClient/qEntity.cpp`:

```cpp
#include "pch.h"
#include "qEntity.h"

// 구현
UINT qEntity::g_NextID = 0;

qEntity::qEntity()
	: m_ID(g_NextID++)
{
}

qEntity::qEntity(const qEntity& _Other)
	: m_ID(g_NextID++)
	, m_strName(_Other.m_strName)
{
}

qEntity::~qEntity()
{
}

```

`GameClient/qEntity.h`:

```h
#pragma once

// 정적 변수
// 1. 함수 내
// 2. 파일
// 3. 클래스

class qEntity
{

private:
	// 정적 멤버 선언
	static UINT g_NextID;	// 특정 클래스 내에 멤버로 정적변수를 선언


private:
	UINT		m_ID;		// 객체별 고유 ID
	wstring		m_strName;


public:
	UINT GetID() { return m_ID; }

	void SetName(const wstring& _Name) { m_strName = _Name; }
	const wstring& GetName() { return m_strName; }

public:
	// qEntity 클래스는 추상클래스이다.
	virtual qEntity* Clone() = 0;

public:
	qEntity();
	qEntity(const qEntity& _Other);
	virtual ~qEntity();
};


```

`GameClient/qExp.cpp`:

```cpp
#include "pch.h"
#include "qExp.h"

```

`GameClient/qExp.h`:

```h
#pragma once
#include "qUI.h"
class qExp : public qUI
{

};


```

`GameClient/qFSM.cpp`:

```cpp
#include "pch.h"
#include "qFSM.h"

#include "qState.h"

qFSM::qFSM()
	: m_CurState(nullptr)
{
}

qFSM::qFSM(const qFSM& _Other)
	: qComponent(_Other)
	, m_CurState(nullptr)
{

}

qFSM::~qFSM()
{
	Safe_Del_Map(m_mapState);
}

void qFSM::finaltick()
{
	if (nullptr == m_CurState)
		return;

	m_CurState->FinalTick();
}

void qFSM::AddState(const wstring& _strStateName, qState* _State)
{
	assert(!FindState(_strStateName));

	// 상태의 소유자(FSM) 세팅하기
	_State->m_Owner = this;

	// 상태 추가
	m_mapState.insert(make_pair(_strStateName, _State));
}

qState* qFSM::FindState(const wstring& _strStateName)
{
	map<wstring, qState*>::iterator iter = m_mapState.find(_strStateName);

	if (iter == m_mapState.end())
	{
		return nullptr;
	}

	return iter->second;
}

void qFSM::ChangeState(const wstring& _strNextStateName)
{
	if (m_CurState && (_strNextStateName == m_CurState->GetName()))
		return;

	if (nullptr != m_CurState)
		m_CurState->Exit();

	m_CurState = FindState(_strNextStateName);

	assert(m_CurState);

	m_CurState->Enter();
}

void qFSM::SetBlackboardData(const wstring& _DataKey, DATA_TYPE _Type, void* _pData)
{
	tBlackboardData data = { _Type, _pData };
	m_mapData.insert(make_pair(_DataKey, data));
}

```

`GameClient/qFSM.h`:

```h
#pragma once
#include "qComponent.h"

enum class DATA_TYPE
{
	INT,
	FLOAT,
	VEC2,
	OBJECT,
};

struct tBlackboardData
{
	DATA_TYPE	Type;
	void* pData;
};

class qState;

class qFSM : public qComponent
{
public:
	CLONE(qFSM);

	qFSM();
	qFSM(const qFSM& _Other);
	~qFSM();


public:
	virtual void finaltick() override;


public:
	void AddState(const wstring& _strStateName, qState* _State);
	qState* FindState(const wstring& _strStateName);
	void ChangeState(const wstring& _strNextStateName);
	void SetBlackboardData(const wstring& _DataKey, DATA_TYPE _Type, void* _pData);

	template<typename T>
	T GetBlackboardData(const wstring& _DataKey);

private:
	static map<wstring, tBlackboardData>	m_mapGlobalData;

	map<wstring, tBlackboardData>			m_mapData;
	map<wstring, qState*>					m_mapState;
	qState*									m_CurState;
};

template<typename T>
inline T qFSM::GetBlackboardData(const wstring& _DataKey)
{
	map<wstring, tBlackboardData>::iterator iter = m_mapData.find(_DataKey);

	assert(iter != m_mapData.end());

	if constexpr (std::is_same_v<int, T>)
	{
		assert(DATA_TYPE::INT == iter->second.Type);
		return *((T*)iter->second.pData);
	}

	if (std::is_same_v<float, T>)
	{
		assert(DATA_TYPE::FLOAT == iter->second.Type);
		return *((T*)iter->second.pData);
	}

	if (std::is_same_v<Vec2, T>)
	{
		assert(DATA_TYPE::VEC2 == iter->second.Type);
		return *((T*)iter->second.pData);
	}

	if constexpr (std::is_same_v<qObj*, T>)
	{
		assert(DATA_TYPE::OBJECT == iter->second.Type);
		return (T)iter->second.pData;
	}

	
}

```

`GameClient/qForce.cpp`:

```cpp
#include "pch.h"
#include "qForce.h"

#include "qLevel.h"
#include "qLevelMgr.h"
#include "qRigidbody.h"


qForce::qForce()
	: m_Force(0.f)
	, m_Range(0.f)
	, m_Time(0.f)
	, m_Age(0.f)
{
}

qForce::~qForce()
{
}

void qForce::tick()
{
	AddForce(LAYER_TYPE::MONSTER_BLUE);
	AddForce(LAYER_TYPE::MONSTER_RED);
	AddForce(LAYER_TYPE::PLAYER);

	DrawDebugCircle(PEN_TYPE::PEN_BLUE, GetPos(), Vec2(m_Range * 2.f, m_Range * 2.f), 0.f);

	m_Age += DT;

	if (m_Time < m_Age)
	{
		Destroy();
	}

}

void qForce::AddForce(LAYER_TYPE _type)
{
	// 레벨에서 Force 주변에 있는 물체들에게 힘을 적용시킨다.
	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();
	const vector<qObj*>& vecObj = pCurLevel->GetObjects(_type);

	for (size_t i = 0; i < vecObj.size(); ++i)
	{
		float fDist = GetPos().GetDistance(vecObj[i]->GetPos());
		if (fDist <= m_Range)
		{
			qRigidbody* pComponent = vecObj[i]->GetComponent<qRigidbody>();
			if (nullptr == pComponent)
				continue;

			// 물체가 Force 와 가까울수록 1에 가까운 비율값이 나온다.
			// 물체가 Force 와 멀수록 0에 가까운 비율값이 나온다. Force의 Range 를 벗어나면 Ratio 는 0이다.
			float fRatio = Saturate(1.f - fDist / m_Range);
			float Force = m_Force * fRatio;

			Vec2 vForce = vecObj[i]->GetPos() - GetPos();
			if (!vForce.IsZero())
			{
				vForce.Normalize();
				vForce *= Force;
				pComponent->AddForce(vForce);
			}
		}
	}
}

```

`GameClient/qForce.h`:

```h
#pragma once
#include "qObj.h"


class qForce : public qObj
{

	CLONE(qForce);

public: 
	qForce();
	~qForce();

	virtual void tick() override;

public:
	void SetForce(float _Force, float _Range, float _Time)
	{
		m_Force = _Force;
		m_Range = _Range;
		m_Time = _Time;
	}

private:
	void AddForce(LAYER_TYPE _type);


private:
	float	m_Force;	// 힘의 크기
	float	m_Range;	// 힘의 범위
	float	m_Time;		// 힘이 유지되는 시간

	float	m_Age;

};


```

`GameClient/qGuideMissile.cpp`:

```cpp
#include "pch.h"
#include "qGuideMissile.h"

#include "qLevelMgr.h"
#include "qLevel.h"

qGuideMissile::qGuideMissile()
	: m_Target(nullptr)
	, m_Range(1000.f)
{
}

qGuideMissile::~qGuideMissile()
{
}



void qGuideMissile::tick()
{
	// 추적할 대상이 있는지 없는지 확인
	//if (nullptr == m_Target || m_Target->IsDead())
	//{
	//	FindTarget();
	//}

	if (!IsValid(m_Target))
	{
		FindTarget();
	}


	// 대상 탐색을 했는데도 아직 타겟이 없다면
	if (m_Target)
	{
		// 미사일이 추적할 대상을 향하는 각도를 구해서 각도설정을 해준다.
		float fSlide = GetPos().GetDistance(m_Target->GetPos());	// 빗변
		float fDown = m_Target->GetPos().x - GetPos().x;			// 밑변
		float fHeight = m_Target->GetPos().y - GetPos().y;			// 높이

		// 코사인 비율값으로 각도를 얻는다.
		float fAngle = acosf(fDown / fSlide);

		// 몬스터의 위치가 미사일보다 아래있다면, 코사인 비율에 대한 각도가 더 큰 값이 나와야 하는데,
		// 아크 코사인 함수가 리턴 범위가 -180 ~ 180 이기 때문에, 전각 360 도에서 리턴된 값을 빼서 반대편의 큰 각도를 알아낸다.
		if (GetPos().y < m_Target->GetPos().y)
		{
			fAngle = PI * 2.f - fAngle;
		}

		SetAngle(fAngle);
	}
	else
	{
		SetAngle(PI / 2.f);		// 타겟 없으면 그냥 위로 쏜다.
	}

	qMissile::tick();
}

void qGuideMissile::FindTarget()
{
	if (LAYER_TYPE::EFFECT == GetLayerType())
	{
		// 플레이어를 탐색
		qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();
		m_Target = pCurLevel->FindObjectByName(L"Player");
	}
	else if (LAYER_TYPE::EFFECT == GetLayerType())
	{
		// 몬스터 전체 목록을 받아옴
		qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();
		const vector<qObj*>& vecMonster = pCurLevel->GetObjects(LAYER_TYPE::MONSTER_BLUE);

		// 미사일의 위치
		Vec2 vMissilePos = GetPos();

		float fMinDist = m_Range;
		m_Target = nullptr;

		for (size_t i = 0; i < vecMonster.size(); ++i)
		{
			// Dead 상태인 오브젝트는 거른다.
			if (vecMonster[i]->IsDead())
			{
				continue;
			}

			// 몬스터와 미사일의 거리를 구한다.
			float fDist = vMissilePos.GetDistance(vecMonster[i]->GetPos());

			if (fDist < fMinDist)
			{
				fMinDist = fDist;
				m_Target = vecMonster[i];
			}
		}
	}
}


void qGuideMissile::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Monster")
	{
		//Destroy();
	}
}



```

`GameClient/qGuideMissile.h`:

```h
#pragma once
#include "qMissile.h"

class qGuideMissile : public qMissile
{
private:
	qObj*		m_Target;
	float       m_Range;

public:
	virtual void tick() override;


private:
	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	void FindTarget();

public:
	qGuideMissile();
	~qGuideMissile();

};


```

`GameClient/qKeyMgr.cpp`:

```cpp
#include "pch.h"
#include "qKeyMgr.h"

#include "qEngine.h"



UINT g_RealKey[(UINT)KEY::KEY_END] =
{
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
	'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
	'Z', 'X', 'C', 'V', 'B', 'N', 'M',

	VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN,

	VK_RETURN,
	VK_SPACE,
	VK_MENU,
	VK_CONTROL,
	VK_LSHIFT,
	VK_ESCAPE,

	VK_LBUTTON,
	VK_RBUTTON,
};

qKeyMgr::qKeyMgr()
{

}

qKeyMgr::~qKeyMgr()
{

}

void qKeyMgr::init()
{
	for (int i = 0; i < (int)KEY::KEY_END; ++i)
	{
		tKeyInfo info = {};
		info.eKey = (KEY)i;
		info.eKeyState = KEY_STATE::NONE;
		info.bPressed = false;

		m_vecKeyInfo.push_back(info);
	}
}


void qKeyMgr::tick()
{

	// Main Window 가 포커싱 상태이다.
	if (qEngine::GetInst()->GetMainWnd() == GetFocus())
	{
		for (UINT i = 0; i < (UINT)m_vecKeyInfo.size(); ++i)
		{
			// 지금 키가 눌려있는지 체크
			if (0x8001 & GetAsyncKeyState(g_RealKey[(UINT)m_vecKeyInfo[i].eKey]))
			{
				// 이전에도 눌려있었는지
				if (m_vecKeyInfo[i].bPressed)
				{
					m_vecKeyInfo[i].eKeyState = KEY_STATE::PRESSED;
				}
				else
				{
					m_vecKeyInfo[i].eKeyState = KEY_STATE::TAP;
				}

				m_vecKeyInfo[i].bPressed = true;
			}

			// 키가 안눌려있음
			else
			{
				// 이전에는 눌려있었음
				if (m_vecKeyInfo[i].bPressed)
				{
					m_vecKeyInfo[i].eKeyState = KEY_STATE::RELEASED;
				}
				else
				{
					m_vecKeyInfo[i].eKeyState = KEY_STATE::NONE;
				}

				m_vecKeyInfo[i].bPressed = false;
			}
		}

		// 마우스 좌표 계산
		m_PrevMousePos = m_MousePos;

		POINT ptMousePos = {};
		GetCursorPos(&ptMousePos);
		ScreenToClient(qEngine::GetInst()->GetMainWnd(), &ptMousePos);
		m_MousePos = ptMousePos;
		m_DragDir = m_MousePos - m_PrevMousePos;

	}

	// 윈도우 포커싱 해제됨
	else
	{
		for (UINT i = 0; i < (UINT)m_vecKeyInfo.size(); ++i)
		{
			if (m_vecKeyInfo[i].eKeyState == KEY_STATE::TAP || m_vecKeyInfo[i].eKeyState == KEY_STATE::PRESSED)
			{
				m_vecKeyInfo[i].eKeyState = KEY_STATE::RELEASED;
			}
			else
			{
				m_vecKeyInfo[i].eKeyState = KEY_STATE::NONE;
			}

			m_vecKeyInfo[i].bPressed = false;
		}
	}


	
}

```

`GameClient/qKeyMgr.h`:

```h
#pragma once

enum class KEY
{
	_0, _1, _2, _3, _4, _5, _6, _7, _8, _9,
	Q, W, E, R, T, Y, U, I, O, P,
	A, S, D, F, G, H, J, K, L,
	Z, X, C, V, B, N, M,

	LEFT, RIGHT, UP, DOWN,

	ENTER,
	SPACE,
	ALT,
	CTRL,
	SHIFT,
	ESC,

	LBTN,
	RBTN,

	KEY_END,
};


enum class KEY_STATE
{
	TAP,			// 막 눌렀을때
	PRESSED,		// 눌려있을때
	RELEASED,		// 막 뗐을때
	NONE,
};



struct tKeyInfo
{
	KEY			eKey;			// 키의 종류
	KEY_STATE	eKeyState;		// 키의 상태값
	bool		bPressed;		// 지금 눌려있는지

};

class qKeyMgr
{
	SINGLE(qKeyMgr);

public:
	void init();
	void tick();

public:
	KEY_STATE GetKeyState(KEY _Key){return m_vecKeyInfo[(UINT)_Key].eKeyState;	}
	Vec2 GetMousePos() { return m_MousePos; }
	Vec2 GetDragDir() { return m_DragDir; }

private:
	vector<tKeyInfo>	m_vecKeyInfo;

	Vec2				m_MousePos;
	Vec2				m_PrevMousePos;
	Vec2				m_DragDir;

};


```

`GameClient/qLevel.cpp`:

```cpp
#include "pch.h"
#include "qLevel.h"

#include "qObj.h"
#include "qCollider.h"
#include "qPathMgr.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"
#include "qDummy_blue.h"
#include "qDummy_red.h"

qLevel::qLevel()
{

}

qLevel::~qLevel()
{
	for (UINT i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		Safe_Del_Vec(m_arrObj[i]);
	}
	
}


void qLevel::begin()
{
	for (int i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		for (size_t j = 0; j < m_arrObj[i].size(); ++j)
		{
			m_arrObj[i][j]->begin();
		}
	}

	
}

void qLevel::tick()
{
	for (int i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		for (size_t j = 0; j < m_arrObj[i].size(); ++j)
		{
			m_arrObj[i][j]->tick();
		}
	}
}

void qLevel::finaltick()
{
	// 이전프레임 충돌체 등록 정보 Clear
	for (UINT i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		m_arrCollider[i].clear();
	}


	for (int i = 0; i < (UINT)LAYER_TYPE::END; i++)
	{
		for (size_t j = 0; j < m_arrObj[i].size(); ++j)
		{
			m_arrObj[i][j]->finaltick();
		}
	}
}

void qLevel::render()
{
	for (int i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		vector<qObj*>::iterator iter = m_arrObj[i].begin();

		for (; iter != m_arrObj[i].end(); )
		{
			if ((*iter)->IsDead())
			{
				iter = m_arrObj[i].erase(iter);
			}
			else
			{
				(*iter)->render();
				++iter;
			}
		}
		
	}
}

void qLevel::AddObject(LAYER_TYPE _Layer, qObj* _Obj)
{
	m_arrObj[(UINT)_Layer].push_back(_Obj);
	_Obj->m_Type = _Layer;
}


void qLevel::RegisterCollider(qCollider* _Collider)
{
	LAYER_TYPE Layer = _Collider->GetOwner()->GetLayerType();
	m_arrCollider[(UINT)Layer].push_back(_Collider);
}


qObj* qLevel::FindObjectByName(const wstring& _Name)
{
	for (UINT i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		qObj* pFindObj = FindObjectByName((LAYER_TYPE)i, _Name);
		
		if (pFindObj)
		{
			return pFindObj;
		}
	}

	return nullptr;
}

qObj* qLevel::FindObjectByName(LAYER_TYPE _Type, const wstring& _Name)
{
	for (size_t i = 0; i < m_arrObj[(UINT)_Type].size(); ++i)
	{
		if (_Name == m_arrObj[(UINT)_Type][i]->GetName())
		{
			return m_arrObj[(UINT)_Type][i];
		}
	}

	return nullptr;
}

void qLevel::DeleteAllObjects()
{
	for (UINT i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{
		DeleteObjects((LAYER_TYPE)i);
	}
}

void qLevel::DeleteObjects(LAYER_TYPE _LayerType)
{
	vector<qObj*>& vecObjects = m_arrObj[(UINT)_LayerType];

	if (vecObjects.empty())
		return;

	for (size_t i = 0; i < vecObjects.size(); ++i)
	{
		delete vecObjects[i];
	}

	vecObjects.clear();
}





void qLevel::SavePlatform(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();
	if (STAGE_NAME::STAGE1 == m_stageName)
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (STAGE_NAME::STAGE2 == m_stageName)
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (STAGE_NAME::BOSS1 == m_stageName)
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (STAGE_NAME::BOSS2 == m_stageName)
	{
		strFullPath += L"edit\\boss2\\";
	}
	
	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;


	_wfopen_s(&pFile, strFullPath.c_str(), L"wb");

	if (nullptr == pFile)
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"파일 저장 실패", L"Error", MB_OK);
		return;
	}

	size_t len = m_arrObj[(UINT)LAYER_TYPE::PLATFORM].size();

	fwrite(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::PLATFORM].size(); ++i)
	{
		Vec2 vPos = m_arrObj[(UINT)LAYER_TYPE::PLATFORM][i]->GetPos();
		Vec2 vScale = m_arrObj[(UINT)LAYER_TYPE::PLATFORM][i]->GetScale();

		fwrite(&vPos, sizeof(Vec2), 1, pFile);
		fwrite(&vScale, sizeof(Vec2), 1, pFile);
	}

	fclose(pFile);

	//for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::PLATFORM].size(); ++i)
	//{
	//	delete m_arrObj[(UINT)LAYER_TYPE::PLATFORM][i];
	//}
	//m_arrObj[(UINT)LAYER_TYPE::PLATFORM].resize(0);
}

void qLevel::SaveRope(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();
	
	if (STAGE_NAME::STAGE1 == m_stageName)
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (STAGE_NAME::STAGE2 == m_stageName)
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (STAGE_NAME::BOSS1 == m_stageName)
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (STAGE_NAME::BOSS2 == m_stageName)
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;


	_wfopen_s(&pFile, strFullPath.c_str(), L"wb");

	if (nullptr == pFile)
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"파일 저장 실패", L"Error", MB_OK);
		return;
	}

	size_t len = m_arrObj[(UINT)LAYER_TYPE::ROPE].size();

	fwrite(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::ROPE].size(); ++i)
	{
		Vec2 vPos = m_arrObj[(UINT)LAYER_TYPE::ROPE][i]->GetPos();
		Vec2 vScale = m_arrObj[(UINT)LAYER_TYPE::ROPE][i]->GetScale();

		fwrite(&vPos, sizeof(Vec2), 1, pFile);
		fwrite(&vScale, sizeof(Vec2), 1, pFile);
	}

	fclose(pFile);

	//for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::ROPE].size(); ++i)
	//{
	//	delete m_arrObj[(UINT)LAYER_TYPE::ROPE][i];
	//}
	//m_arrObj[(UINT)LAYER_TYPE::ROPE].resize(0);
}

void qLevel::SavePortal(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (STAGE_NAME::STAGE1 == m_stageName)
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (STAGE_NAME::STAGE2 == m_stageName)
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (STAGE_NAME::BOSS1 == m_stageName)
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (STAGE_NAME::BOSS2 == m_stageName)
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;


	_wfopen_s(&pFile, strFullPath.c_str(), L"wb");

	if (nullptr == pFile)
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"파일 저장 실패", L"Error", MB_OK);
		return;
	}

	size_t len = m_arrObj[(UINT)LAYER_TYPE::PORTAL].size();

	fwrite(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::PORTAL].size(); ++i)
	{
		Vec2 vPos = m_arrObj[(UINT)LAYER_TYPE::PORTAL][i]->GetPos();
		Vec2 vScale = m_arrObj[(UINT)LAYER_TYPE::PORTAL][i]->GetScale();

		fwrite(&vPos, sizeof(Vec2), 1, pFile);
		fwrite(&vScale, sizeof(Vec2), 1, pFile);
	}

	fclose(pFile);
}



void qLevel::SaveMonster_blue(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (STAGE_NAME::STAGE1 == m_stageName)
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (STAGE_NAME::STAGE2 == m_stageName)
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (STAGE_NAME::BOSS1 == m_stageName)
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (STAGE_NAME::BOSS2 == m_stageName)
	{
		strFullPath += L"edit\\boss2\\";
	}

	 strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"wb");

	if (nullptr == pFile)
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"파일 저장 실패", L"Error", MB_OK);
		return;
	}

	size_t len = m_arrObj[(UINT)LAYER_TYPE::DUMMY_BLUE].size();

	fwrite(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::DUMMY_BLUE].size(); ++i)
	{
		Vec2 vPos = m_arrObj[(UINT)LAYER_TYPE::DUMMY_BLUE][i]->GetPos();
		Vec2 vScale = m_arrObj[(UINT)LAYER_TYPE::DUMMY_BLUE][i]->GetScale();

		fwrite(&vPos, sizeof(Vec2), 1, pFile);
		fwrite(&vScale, sizeof(Vec2), 1, pFile);
	}

	fclose(pFile);
}


void qLevel::SaveMonster_red(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (STAGE_NAME::STAGE1 == m_stageName)
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (STAGE_NAME::STAGE2 == m_stageName)
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (STAGE_NAME::BOSS1 == m_stageName)
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (STAGE_NAME::BOSS2 == m_stageName)
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"wb");

	if (nullptr == pFile)
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"파일 저장 실패", L"Error", MB_OK);
		return;
	}

	size_t len = m_arrObj[(UINT)LAYER_TYPE::DUMMY_RED].size();

	fwrite(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < m_arrObj[(UINT)LAYER_TYPE::DUMMY_RED].size(); ++i)
	{
		Vec2 vPos = m_arrObj[(UINT)LAYER_TYPE::DUMMY_RED][i]->GetPos();
		Vec2 vScale = m_arrObj[(UINT)LAYER_TYPE::DUMMY_RED][i]->GetScale();

		fwrite(&vPos, sizeof(Vec2), 1, pFile);
		fwrite(&vScale, sizeof(Vec2), 1, pFile);
	}

	fclose(pFile);
}



void qLevel::LoadPlatform(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();
	if (L"Stage1" == GetName())
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (L"Stage2" == GetName())
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (L"Boss1" == GetName())
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (L"Boss2" == GetName())
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"rb");

	if (nullptr == pFile)
		return;

	size_t len = 0;

	fread(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < len; ++i)
	{
		Vec2 vPos;
		Vec2 vScale;

		fread(&vPos, sizeof(Vec2), 1, pFile);
		fread(&vScale, sizeof(Vec2), 1, pFile);

		qPlatform* pPlatform = new qPlatform(vPos, vScale);
		AddObject(LAYER_TYPE::PLATFORM, pPlatform);
	}

	fclose(pFile);
}

void qLevel::LoadRope(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (L"Stage1" == GetName())
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (L"Stage2" == GetName())
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (L"Boss1" == GetName())
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (L"Boss2" == GetName())
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"rb");

	if (nullptr == pFile)
		return;

	size_t len = 0;

	fread(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < len; ++i)
	{
		Vec2 vPos;
		Vec2 vScale;

		fread(&vPos, sizeof(Vec2), 1, pFile);
		fread(&vScale, sizeof(Vec2), 1, pFile);

		qRope* pRope = new qRope(vPos, vScale);
		AddObject(LAYER_TYPE::ROPE, pRope);
	}

	fclose(pFile);
}

void qLevel::LoadPortal(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();
	if (L"Stage1" == GetName())
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (L"Stage2" == GetName())
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (L"Boss1" == GetName())
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (L"Boss2" == GetName())
	{
		strFullPath += L"edit\\boss2\\";
	}

	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"rb");

	if (nullptr == pFile)
		return;

	size_t len = 0;

	fread(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < len; ++i)
	{
		Vec2 vPos;
		Vec2 vScale;

		fread(&vPos, sizeof(Vec2), 1, pFile);
		fread(&vScale, sizeof(Vec2), 1, pFile);

		qPortal* pPortal = new qPortal(vPos, vScale);
		AddObject(LAYER_TYPE::PORTAL, pPortal);
	}

	fclose(pFile);
}

void qLevel::LoadMonster_blue(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (L"Stage1" == GetName())
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (L"Stage2" == GetName())
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (L"Boss1" == GetName())
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (L"Boss2" == GetName())
	{
		strFullPath += L"edit\\boss2\\";
	}


	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"rb");

	size_t len = 0;

	fread(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < len; ++i)
	{
		Vec2 vPos;
		Vec2 vScale;

		fread(&vPos, sizeof(Vec2), 1, pFile);
		fread(&vScale, sizeof(Vec2), 1, pFile);

		qDummy_blue* pMonster = new qDummy_blue;
		pMonster->SetPos(vPos.x, vPos.y);
		pMonster->SetScale(vScale.x, vScale.y);
		pMonster->SetDir(DIRECTION::LEFT);
		AddObject(LAYER_TYPE::DUMMY_BLUE, pMonster);
	}

	fclose(pFile);
}

void qLevel::LoadMonster_red(const wstring& _strRelativePath)
{
	wstring strFullPath = qPathMgr::GetInst()->GetContentPath();

	if (L"Stage1" == GetName())
	{
		strFullPath += L"edit\\stage1\\";
	}
	else if (L"Stage2" == GetName())
	{
		strFullPath += L"edit\\stage2\\";
	}
	else if (L"Boss1" == GetName())
	{
		strFullPath += L"edit\\boss1\\";
	}
	else if (L"Boss2" == GetName())
	{
		strFullPath += L"edit\\boss2\\";
	}


	strFullPath += _strRelativePath;

	FILE* pFile = nullptr;

	_wfopen_s(&pFile, strFullPath.c_str(), L"rb");

	size_t len = 0;

	fread(&len, sizeof(size_t), 1, pFile);

	for (size_t i = 0; i < len; ++i)
	{
		Vec2 vPos;
		Vec2 vScale;

		fread(&vPos, sizeof(Vec2), 1, pFile);
		fread(&vScale, sizeof(Vec2), 1, pFile);

		qDummy_red* pMonster = new qDummy_red;
		AddObject(LAYER_TYPE::DUMMY_RED, pMonster);
	}

	fclose(pFile);
}




```

`GameClient/qLevel.h`:

```h
#pragma once
#include "qEntity.h"

class qObj;
class qCollider;
class qPlatform;

class qLevel : public qEntity
{

public:
	friend class qUIMgr;

	CLONE_DISABLE(qLevel);


public:
	qLevel();
	~qLevel();

public:
	// 시점 함수
	virtual void begin();			// 레벨이 시작될 때
	virtual void tick();			// 매 프레임마다 호출
	virtual void finaltick();		// 매 프레임마다 호출
	virtual void render();			// 매 프레임마다 호출

	virtual void Enter() PURE;		// 레벨이 전환되고 처음 초기화 작업
	virtual void Exit() PURE;		// 레벨이 끝날때 할 일


public:
	void AddObject(LAYER_TYPE _Layer, qObj* _Obj);
	void RegisterCollider(qCollider* _Collider);
	qObj* FindObjectByName(const wstring& _Name);
	qObj* FindObjectByName(LAYER_TYPE _Type, const wstring& _Name);

	const vector<qObj*>& GetObjects(LAYER_TYPE _Type) { return m_arrObj[(UINT)_Type]; }
	const vector<qCollider*>& GetColliders(LAYER_TYPE _Layer) { return m_arrCollider[(UINT)_Layer]; }

	void SetStageName(STAGE_NAME _name) { m_stageName = _name; }

	void SetPos(Vec2 _Pos) { m_Pos = _Pos; }
	Vec2 GetPos() { return m_Pos; }


protected:
	void DeleteAllObjects();
	void DeleteObjects(LAYER_TYPE _LayerType);


protected:
	void SavePlatform(const wstring& _strRelativePath);
	void SaveRope(const wstring& _strRelativePath);
	void SavePortal(const wstring& _strRelativePath);
	void SaveMonster_blue(const wstring& _strRelativePath);
	void SaveMonster_red(const wstring& _strRelativePath);


	void LoadPlatform(const wstring& _strRelativePath);
	void LoadRope(const wstring& _strRelativePath);
	void LoadPortal(const wstring& _strRelativePath);
	void LoadMonster_blue(const wstring& _strRelativePath);
	void LoadMonster_red(const wstring& _strRelativePath);

private:
	vector<qObj*>		m_arrObj[(UINT)LAYER_TYPE::END];
	vector<qCollider*>	m_arrCollider[(UINT)LAYER_TYPE::END];
	STAGE_NAME			m_stageName;

	Vec2				m_Pos;
};


```

`GameClient/qLevelMgr.cpp`:

```cpp
#include "pch.h"
#include "qLevelMgr.h"
#include "qCollisionMgr.h"

#include "qLevel.h"
#include "qLevel_Logo.h"
#include "qLevel_Start.h"
#include "qLevel_Editor.h"
#include "qLevel_stage1.h"
#include "qLevel_stage2.h"


#include "qLevel_boss1.h"
#include "qLevel_boss2.h"

#include "qPlayer.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"

qLevelMgr::qLevelMgr()
	: m_arrLevel{}
	, m_pCurrentLevel(nullptr)
{

}


qLevelMgr::~qLevelMgr()
{
	Safe_Del_Arr(m_arrLevel);
}



qObj* qLevelMgr::FindObjectByName(const wstring& _StrName)
{
	return m_pCurrentLevel->FindObjectByName(_StrName);
;}

void qLevelMgr::init()
{
	// 모든 레벨 생성

	m_arrLevel[(UINT)LEVEL_TYPE::LOGO] = new qLevel_Logo;
	m_arrLevel[(UINT)LEVEL_TYPE::START] = new qLevel_Start;
	m_arrLevel[(UINT)LEVEL_TYPE::EDITOR] = new qLevel_Editor;
	m_arrLevel[(UINT)LEVEL_TYPE::EDITOR]->SetPos(Vec2(0.f, 0.f));
	m_arrLevel[(UINT)LEVEL_TYPE::STAGE_01] = new qLevel_stage1;
	m_arrLevel[(UINT)LEVEL_TYPE::STAGE_02] = new qLevel_stage2;
	m_arrLevel[(UINT)LEVEL_TYPE::BOSS_01] = new qLevel_boss1;
	m_arrLevel[(UINT)LEVEL_TYPE::BOSS_02] = new qLevel_boss2;

	// 처음 시작할 레벨 
	::ChangeLevel(LEVEL_TYPE::BOSS_02);
	
}

void qLevelMgr::progress()
{
	if (nullptr == m_pCurrentLevel)
		return;

	m_pCurrentLevel->tick();
	m_pCurrentLevel->finaltick();

}

void qLevelMgr::render()
{
	if (nullptr == m_pCurrentLevel)
		return;

	m_pCurrentLevel->render();
}


void qLevelMgr::ChangeLevel(LEVEL_TYPE _NextLevelType)
{
	if (m_arrLevel[(UINT)_NextLevelType] == m_pCurrentLevel)
	{
		LOG(LOG_TYPE::DBG_ERROR, L"현재 레벨과 변경하려는 레벨이 동일합니다.");
		return;
	}

	// 기존 레벨에서 Exit 한다.
	if (m_pCurrentLevel)
		m_pCurrentLevel->Exit();

	// 새로운 레벨로 포인터의 주소값을 교체한다.
	m_pCurrentLevel = m_arrLevel[(UINT)_NextLevelType];
	assert(m_pCurrentLevel);

	// 변경된 새로운 레벨로 Enter 한다.
	m_pCurrentLevel->Enter();
	m_pCurrentLevel->begin();
}

```

`GameClient/qLevelMgr.h`:

```h
#pragma once

class qLevel;



class qLevelMgr
{
	SINGLE(qLevelMgr)

public:
	friend class qTaskMgr;


private:
	qLevel*		m_arrLevel[(UINT)LEVEL_TYPE::END];
	qLevel*		m_pCurrentLevel;


private:
	void ChangeLevel(LEVEL_TYPE _NextLevelType);


public:
	qObj* FindObjectByName(const wstring& _StrName);
	

public:
	void init();
	void progress();
	void render();


public:
	qLevel* GetCurrentLevel() { return m_pCurrentLevel; }

};


```

`GameClient/qLevel_Editor.cpp`:

```cpp
#include "pch.h"
#include "qLevel_Editor.h"
#include "qKeyMgr.h"
#include "qTile.h"
#include "qPathMgr.h"
#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qCollider.h"
#include "qTexture.h"
#include "qAnimation.h"
#include "qAnimator.h"

#include "qMonster_red.h"
#include "qMonster_blue.h"
#include "qDummy_blue.h"
#include "qDummy_red.h"

#include "qBackground_stage1.h"
#include "qBackground_stage2.h"
#include "qBackground_boss1.h"
#include "qBackground_boss2.h"

#include "qLevel_stage1.h"
#include "qLevel_stage2.h"
#include "qLevel_boss1.h"
#include "qLevel_boss2.h"

#include "qUI.h"
#include "qButton.h"

qLevel_Editor::qLevel_Editor()
	: m_EditTile(nullptr)
	, m_Type(EDIT_TYPE::END)
	, m_CurImg(nullptr)
	, m_Background(nullptr)
{
	SetName(L"Editor");
	
}

qLevel_Editor::~qLevel_Editor()
{
}

void qLevel_Editor::begin()
{
	qLevel::begin();

	//m_CurImg = qAssetMgr::GetInst()->LoadTexture(L"edit", L"texture\\edit\\edit1.png");

}

void qLevel_Editor::tick()
{
	qLevel::tick();

	if (KEY_TAP(KEY::_1))
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"스테이지 1 설정", L"STAGE", MB_OK);
		m_CurImg = qAssetMgr::GetInst()->LoadTexture(L"stage1", L"texture\\map\\stage1.png");
		m_CurImg->SetName(L"Stage1");

		SetStageName(STAGE_NAME::STAGE1);
	}
	else if (KEY_TAP(KEY::_2))
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"스테이지 2 설정", L"STAGE", MB_OK);
		m_CurImg = qAssetMgr::GetInst()->LoadTexture(L"stage2", L"texture\\map\\stage2.png");
		m_CurImg->SetName(L"Stage2");

		SetStageName(STAGE_NAME::STAGE2);
	}
	else if (KEY_TAP(KEY::_3))
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"보스 스테이지 1 설정", L"STAGE", MB_OK);
		m_CurImg = qAssetMgr::GetInst()->LoadTexture(L"boss1", L"texture\\map\\boss1.png");
		m_CurImg->SetName(L"Boss1");

		SetStageName(STAGE_NAME::BOSS1);
	}
	else if (KEY_TAP(KEY::_4))
	{
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"보스 스테이지 2 설정", L"STAGE", MB_OK);
		m_CurImg = qAssetMgr::GetInst()->LoadTexture(L"boss2", L"texture\\map\\boss2.png");
		m_CurImg->SetName(L"Boss2");

		SetStageName(STAGE_NAME::BOSS2);
	}

	// SetType 후 edit MessageBox
	if (KEY_TAP(KEY::I))
	{
		SetType(EDIT_TYPE::PLATFORM);
		ResetInfo();
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"PLATFORM EDIT", L"EDITOR TOOL", MB_OK);
	}
	if (KEY_TAP(KEY::O))
	{
		SetType(EDIT_TYPE::ROPE);
		ResetInfo();
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"ROPE EDIT", L"EDITOR TOOL", MB_OK);
	}
	if (KEY_TAP(KEY::P))
	{
		SetType(EDIT_TYPE::PORTAL);
		ResetInfo();
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"PORTAL EDIT", L"EDITOR TOOL", MB_OK);
	}
	else if (KEY_TAP(KEY::K))
	{
		SetType(EDIT_TYPE::DUMMY_BLUE);
		ResetInfo();
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"MONSTER BLUE EDIT", L"EDITOR TOOL", MB_OK);
	}
	else if (KEY_TAP(KEY::L))
	{
		SetType(EDIT_TYPE::DUMMY_RED);
		ResetInfo();
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"MONSTER RED EDIT", L"EDITOR TOOL", MB_OK);
	}

	
	// 사용할 Type 으로 변경
	if (EDIT_TYPE::PLATFORM == GetType())
	{
		Platform();
	}
	else if (EDIT_TYPE::ROPE == GetType())
	{
		Rope();
	}
	else if (EDIT_TYPE::PORTAL == GetType())
	{
		Portal();
	}
	else if (EDIT_TYPE::DUMMY_BLUE == GetType())
	{
		Monster_blue();
	}
	else if (EDIT_TYPE::DUMMY_RED == GetType())
	{
		Monster_red();
	}

	// 그린 Edit 저장
	if (KEY_TAP(KEY::_9))
	{
		SavePlatform(L"platform\\platform.dat");
		SaveRope(L"rope\\rope.dat");
		SavePortal(L"portal\\portal.dat");
		SaveMonster_blue(L"monster_blue\\monster_blue.dat");	
		SaveMonster_red(L"monster_red\\monster_red.dat");	
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"저장 완료", L"EDITOR", MB_OK);
	}

	// 저장되어있는 Edit 불러오기
	else if (KEY_TAP(KEY::_0))
	{
		LoadPlatform(L"platform\\platform.dat");
		LoadRope(L"rope\\rope.dat");
		LoadPortal(L"portal\\portal.dat");
		LoadMonster_blue(L"monster_blue\\monster_blue.dat");
		LoadMonster_red(L"monster_red\\monster_red.dat");
		
		MessageBox(qEngine::GetInst()->GetMainWnd(), L"로딩 완료", L"EDITOR", MB_OK);
	}


	if (KEY_TAP(KEY::Z))
	{
		ChangeLevel(LEVEL_TYPE::STAGE_01);
	}
	if (KEY_TAP(KEY::X))
	{
		ChangeLevel(LEVEL_TYPE::STAGE_02);
	}
	if (KEY_TAP(KEY::C))
	{
		ChangeLevel(LEVEL_TYPE::BOSS_01);
	}
	if (KEY_TAP(KEY::V))
	{
		ChangeLevel(LEVEL_TYPE::BOSS_02);
	}
}

void qLevel_Editor::Enter()
{
	qCamera::GetInst()->SetOwner(nullptr);
	

}

void qLevel_Editor::Exit()
{
	DeleteAllObjects();
}

void qLevel_Editor::Platform()
{

	if (KEY_TAP(KEY::LBTN))
	{
		m_tInfo.StartPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_PRESSED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_RELEASED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
		float x = abs((m_tInfo.StartPos.x + m_tInfo.EndPos.x) * 0.5f);
		float y = abs((m_tInfo.StartPos.y + m_tInfo.EndPos.y) * 0.5f);

		float width = abs(m_tInfo.EndPos.x - m_tInfo.StartPos.x);
		float height = abs(m_tInfo.EndPos.y - m_tInfo.StartPos.y);

		qPlatform* pPlatform = new qPlatform(Vec2(x, y), Vec2(width, height));
 		AddObject(LAYER_TYPE::PLATFORM, pPlatform);

		memset(&m_tInfo, 0, sizeof(tInfo));
	}
}

void qLevel_Editor::Rope()
{
	if (KEY_TAP(KEY::LBTN))
	{
		m_tInfo.StartPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_PRESSED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_RELEASED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
		float x = abs((m_tInfo.StartPos.x + m_tInfo.EndPos.x) * 0.5f);
		float y = abs((m_tInfo.StartPos.y + m_tInfo.EndPos.y) * 0.5f);

		float width = abs(m_tInfo.EndPos.x - m_tInfo.StartPos.x);
		float height = abs(m_tInfo.EndPos.y - m_tInfo.StartPos.y);

		qRope* pRope = new qRope(Vec2(x, y), Vec2(width, height));
		pRope->SetName(L"Rope");
		AddObject(LAYER_TYPE::ROPE, pRope);

		memset(&m_tInfo, 0, sizeof(tInfo));
	}
}

void qLevel_Editor::Portal()
{
	if (KEY_TAP(KEY::LBTN))
	{
		m_tInfo.StartPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_PRESSED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
	}
	else if (KEY_RELEASED(KEY::LBTN))
	{
		m_tInfo.EndPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
		float x = abs((m_tInfo.StartPos.x + m_tInfo.EndPos.x) * 0.5f);
		float y = abs((m_tInfo.StartPos.y + m_tInfo.EndPos.y) * 0.5f);

		float width = abs(m_tInfo.EndPos.x - m_tInfo.StartPos.x);
		float height = abs(m_tInfo.EndPos.y - m_tInfo.StartPos.y);

		qPortal* pPortal = new qPortal(Vec2(x, y), Vec2(width, height));
		AddObject(LAYER_TYPE::PORTAL, pPortal);

		memset(&m_tInfo, 0, sizeof(tInfo));
	}
}

void qLevel_Editor::Monster_blue()
{
	if (KEY_TAP(KEY::LBTN))
	{
		Vec2 vPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
		qDummy_blue* pMonster = new qDummy_blue;
		pMonster->SetPos(vPos);
		pMonster->SetScale(100.f, 100.f);
		pMonster->SetName(L"Blue");

		AddObject(LAYER_TYPE::DUMMY_BLUE, pMonster);

	}
}

void qLevel_Editor::Monster_red()
{
	if (KEY_TAP(KEY::LBTN))
	{
		Vec2 vPos = qCamera::GetInst()->GetRealPos(qKeyMgr::GetInst()->GetMousePos());
		qDummy_red* pMonster = new qDummy_red;
		pMonster->SetPos(vPos);
		pMonster->SetScale(100.f, 100.f);
		pMonster->SetName(L"Red");

		AddObject(LAYER_TYPE::DUMMY_RED, pMonster);
	}
}


void qLevel_Editor::render()
{

	// Rendering
	if (nullptr == m_CurImg)
		return;
		
	Vec2 vPos = qCamera::GetInst()->GetRenderPos(GetPos());


	StretchBlt(DC, vPos.x, vPos.y
		, m_CurImg->GetWidth(), m_CurImg->GetHeight()
		, m_CurImg->GetDC()
		, 0, 0
		, m_CurImg->GetWidth(), m_CurImg->GetHeight(), SRCCOPY);

	//m_BlueImg = qAssetMgr::GetInst()->LoadTexture(L"monster_blue", L"texture\\edit\\monster_blue.png");

	//Vec2 vMousePos = qCamera::GetInst()->GetRenderPos(qKeyMgr::GetInst()->GetMousePos());

	

	if (m_Type == EDIT_TYPE::PLATFORM || m_Type == EDIT_TYPE::ROPE || m_Type == EDIT_TYPE::PORTAL)
	{
		USE_PEN(DC, PEN_TYPE::PEN_GREEN);
		USE_BRUSH(DC, BRUSH_TYPE::BRUSH_HOLLOW);

		Vec2 Start = qCamera::GetInst()->GetRenderPos(m_tInfo.StartPos);
		Vec2 End = qCamera::GetInst()->GetRenderPos(m_tInfo.EndPos);

		Rectangle(DC, Start.x, Start.y, End.x, End.y);
	}

	

	qLevel::render();
}





```

`GameClient/qLevel_Editor.h`:

```h
#pragma once
#include "qLevel.h"

class qTile;
class qTexture;
class qPlatform;
class qRope;
class qPortal;
class qMonster_blue;
class qMonster_red;

class qObj;
class qCamera;


class qLevel_Editor : public qLevel
{
public:
	qLevel_Editor();
	~qLevel_Editor();


private:
	virtual void begin() override;			
	virtual void tick() override;
	virtual void render() override;

	virtual void Enter() override;
	virtual void Exit() override;


private:
	void Platform();
	void Rope();
	void Portal();
	void Monster_blue();
	void Monster_red();

	void ResetInfo()
	{
		memset(&m_tInfo, sizeof(tInfo), 0);
	}

	void SetType(EDIT_TYPE _EditType) { m_Type = _EditType; }
	EDIT_TYPE GetType() { return m_Type; }


private:
	qTile*			m_EditTile;

	tInfo			m_tInfo;
	EDIT_TYPE		m_Type;

	qTexture*		m_Img;
	qTexture*		m_BlueImg;

	qTexture*		m_CurImg;
	qObj*			m_Background;

	//qPlatform*	m_TestPlatform;
	//tInfo			m_TestInfo;

};


```

`GameClient/qLevel_Logo.cpp`:

```cpp
#include "pch.h"
#include "qLevel_Logo.h"

#include "qLevelMgr.h"
#include "qPathMgr.h"
#include "qKeyMgr.h"

#include "qSound.h"
#include "qAssetMgr.h"

#include "qAnimator.h"
#include "qAnimation.h"

#include "qObj.h"
#include "qLogo.h"
 

qLevel_Logo::qLevel_Logo()
{
	SetName(L"logo");

}

qLevel_Logo::~qLevel_Logo()
{
}

void qLevel_Logo::begin()
{
	qLevel::begin();

	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\logo.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

void qLevel_Logo::tick()
{
	qLevel::tick();

	//if (KEY_TAP(KEY::ENTER))
	//{
	//	ChangeLevel(LEVEL_TYPE::START);
	//}

}


void qLevel_Logo::Enter()
{
	qObj* pLogo = new qLogo;
	pLogo->SetName(L"Logo");
	pLogo->SetPos(800.f, 450.f);
	pLogo->SetScale(1600.f, 900.f);
	AddObject(LAYER_TYPE::BACKGROUND, pLogo);


}

void qLevel_Logo::Exit()
{
	// 페이드 아웃
	//qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_OUT, 1.f);

	// 사운드 끄기
	pSound->SetVolume(30.f);
	pSound->Stop();

	DeleteAllObjects();
}

```

`GameClient/qLevel_Logo.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qAnimator;

class qLevel_Logo : public qLevel
{
public:
	qLevel_Logo();
	~qLevel_Logo();


public:
	virtual void begin() override;
	virtual void tick() override;
	virtual void Enter() override;
	virtual void Exit() override;


private:
	qSound*			pSound;
	//qAnimator*		m_Animator;

};


```

`GameClient/qLevel_Start.cpp`:

```cpp
#include "pch.h"
#include "qLevel_Start.h"

#include "qLevelMgr.h"
#include "qPathMgr.h"
#include "qKeyMgr.h"

#include "qSound.h"
#include "qButton.h"
#include "qAssetMgr.h"

#include "qAnimation.h"
#include "qAnimator.h"

#include "qObj.h"
#include "qBackground_start.h"



void ButtonCallBackFunc()
{
	//qLevel* pLevel = qLevelMgr::GetInst()->GetCurrentLevel();
	//qStart* pStart = dynamic_cast<qStart*>(pLevel);
	//if (nullptr == pStart)
	//	return;

	ChangeLevel(LEVEL_TYPE::STAGE_01);
}


qLevel_Start::qLevel_Start()
{
	SetName(L"Start");

	if (KEY_TAP(KEY::E))
	{
		ChangeLevel(LEVEL_TYPE::EDITOR);
	}
}

qLevel_Start::~qLevel_Start()
{
}

void qLevel_Start::begin()
{
	// 사운드 로딩
	//qSound* pSound = CAssetMgr::GetInst()->LoadSound(L"BGM_01", L"sound\\BGM_Stage1.wav");
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\start.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

void qLevel_Start::Enter()
{

	qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_IN, 0.7f);

	qBackground_start* pStartBack = new qBackground_start;
	pStartBack->SetName(L"Start");
	pStartBack->SetPos(800.f, 450.f);
	pStartBack->SetScale(1600.f, 900.f);
	AddObject(LAYER_TYPE::BACKGROUND, pStartBack);

	// 화면 해상도
	Vec2 vResol = qEngine::GetInst()->GetResolution();

	// UI 추가
	qButton* pUI = new qButton;
	m_NormalImg = qAssetMgr::GetInst()->FindTexture(L"normal");
	m_HoverImg = qAssetMgr::GetInst()->FindTexture(L"hover");
	m_DownImg = qAssetMgr::GetInst()->FindTexture(L"down");

	if (pUI->IsMouseOn())
	{
		pUI->SetHoverImage(m_HoverImg);
	}
	else if (pUI->IsLbtnDowned())
	{
		pUI->SetDownImage(m_DownImg);
	}
	else
	{
		pUI->SetNormalImage(m_NormalImg);
	}


	pUI->SetCallBack(&ButtonCallBackFunc);
	pUI->SetScale(Vec2(90.f, 30.f));
	pUI->SetPos(Vec2(vResol.x - (pUI->GetScale().x + 30), 30.f));
	
	AddObject(LAYER_TYPE::UI, pUI);





}

void qLevel_Start::Exit()
{
	// 사운드 끄기

	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qLevel_Start.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qTexture;

class qLevel_Start : public qLevel
{
public:
	qLevel_Start();
	~qLevel_Start();

public:
	virtual void begin() override;

	virtual void Enter() override;
	virtual void Exit() override;


private:
	qSound* pSound;
	qTexture* m_NormalImg;
	qTexture* m_HoverImg;
	qTexture* m_DownImg;

};


```

`GameClient/qLevel_boss1.cpp`:

```cpp
#include "pch.h"
#include "qLevel_boss1.h"

#include "qCollisionMgr.h"
#include "qPlayer.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"

#include "qMinimap_boss1.h"
#include "qMenu.h"

#include "qBackground_boss1.h"

#include "qSound.h"

qLevel_boss1::qLevel_boss1()
{
	SetName(L"Boss1");
}

qLevel_boss1::~qLevel_boss1()
{
}

void qLevel_boss1::begin()
{
	qLevel::begin();

	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\boss1.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_IN, 0.7f);
}

void qLevel_boss1::tick()
{
	qLevel::tick();

	if (KEY_TAP(KEY::ENTER))
	{
		::ChangeLevel(LEVEL_TYPE::EDITOR);
	}

	if (KEY_TAP(KEY::Z))
	{
		::ChangeLevel(LEVEL_TYPE::STAGE_01);
	}

	if (KEY_TAP(KEY::X))
	{
		::ChangeLevel(LEVEL_TYPE::STAGE_02);
	}

	if (KEY_TAP(KEY::V))
	{
		::ChangeLevel(LEVEL_TYPE::BOSS_02);
	}

}

void qLevel_boss1::Enter()
{
	// UI 추가
	// 화면 해상도
	Vec2 vResol = qEngine::GetInst()->GetResolution();

	// 미니맵 UI 추가
	qMinimap_boss1* pMinimap_boss1 = new qMinimap_boss1;
	m_Minimap = qAssetMgr::GetInst()->FindTexture(L"minimap_boss1");

	pMinimap_boss1->SetImage(m_Minimap);
	pMinimap_boss1->SetScale(Vec2(158.f, 145.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMinimap_boss1->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMinimap_boss1);


	// 메뉴 UI 추가
	qMenu* pMenu = new qMenu;
	m_Menu = qAssetMgr::GetInst()->FindTexture(L"menu");

	pMenu->SetImage(m_Menu);
	pMenu->SetScale(Vec2(1600.f, 900.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMenu->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMenu);
	

	// 레벨에 오브젝트 추가
	//
	// Background
	qObj* pBack = new qBackground_boss1;
	pBack->SetName(L"Boss1");
	pBack->SetPos(0.f, 0.f);
	AddObject(LAYER_TYPE::BACKGROUND, pBack);

	// Player
	qObj* pPlayer = new qPlayer;
	pPlayer->SetName(L"Player");
	pPlayer->SetPos(223.f, 771.f);
	pPlayer->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::PLAYER, pPlayer);


	// 플랫폼 생성
	//qObj* pPlatform = new qPlatform;
	//pPlatform->SetName(L"Platform");
	//pPlatform->SetPos(Vec2(640.f, 700.f));
	//AddObject(LAYER_TYPE::PLATFORM, pPlatform);


	// 콜라이더 읽어오기
	LoadPlatform(L"platform\\platform.dat");
	LoadRope(L"rope\\rope.dat");
	LoadPortal(L"portal\\portal.dat");

	LoadMonster_blue(L"monster_blue\\monster_blue.dat");
	LoadMonster_red(L"monster_red\\monster_red.dat");

	// 레벨 충돌 설정하기
	qCollisionMgr::GetInst()->CollisionCheckClear();

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::ROPE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PORTAL);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_BLUE, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_RED, LAYER_TYPE::PLATFORM);
}

void qLevel_boss1::Exit()
{

	pSound->SetVolume(30.f);
	pSound->Stop();

	// 레벨에 있는 모든 오브젝트 삭제한다.
	DeleteAllObjects();
}

```

`GameClient/qLevel_boss1.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qTexture;

class qLevel_boss1 : public qLevel
{
public:
	qLevel_boss1();
	~qLevel_boss1();

public:
	virtual void begin() override;
	virtual void tick() override;

	virtual void Enter() override;
	virtual void Exit() override;

private:
	qSound*			pSound;
	qTexture*		m_Minimap;
	qTexture*		m_Menu;
};


```

`GameClient/qLevel_boss2.cpp`:

```cpp
#include "pch.h"
#include "qLevel_boss2.h"
#include "qCollisionMgr.h"
#include "qPlayer.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"

#include "qBackground_boss2.h"
#include "qMinimap_boss2.h"
#include "qMenu.h"

#include "qBoss.h"
#include "qBossHUD.h"
#include "qBossHP.h"
#include "qPlayerHP.h"

#include "qSound.h"

qLevel_boss2::qLevel_boss2()
{
	SetName(L"Boss2");
}

qLevel_boss2::~qLevel_boss2()
{
}

void qLevel_boss2::begin()
{
	qLevel::begin();

	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\boss2.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_IN, 0.7f);
}

void qLevel_boss2::tick()
{
	qLevel::tick();

	if (KEY_TAP(KEY::ENTER))
	{
		ChangeLevel(LEVEL_TYPE::EDITOR);
	}

	if (KEY_TAP(KEY::Z))
	{
		::ChangeLevel(LEVEL_TYPE::STAGE_01);
	}

	if (KEY_TAP(KEY::X))
	{
		::ChangeLevel(LEVEL_TYPE::STAGE_02);
	}

	if (KEY_TAP(KEY::C))
	{
		::ChangeLevel(LEVEL_TYPE::BOSS_01);
	}






}

void qLevel_boss2::Enter()
{

	// UI 추가
	// 화면 해상도
	Vec2 vResol = qEngine::GetInst()->GetResolution();


	// 미니맵 UI 추가
	qMinimap_boss2* pMinimap_boss2 = new qMinimap_boss2;
	m_Minimap = qAssetMgr::GetInst()->FindTexture(L"minimap_boss2");

	pMinimap_boss2->SetImage(m_Minimap);
	pMinimap_boss2->SetScale(Vec2(158.f, 130.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMinimap_boss2->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMinimap_boss2);
	

	// 메뉴 UI 추가
	qMenu* pMenu = new qMenu;
	m_Menu = qAssetMgr::GetInst()->FindTexture(L"menuno");

	pMenu->SetImage(m_Menu);
	pMenu->SetScale(Vec2(1600.f, 900.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMenu->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMenu);





	// 레벨에 오브젝트 추가
	//
	// Background
	qObj* pBack = new qBackground_boss2;
	pBack->SetName(L"Boss2");
	pBack->SetPos(0.f, 0.f);
	AddObject(LAYER_TYPE::BACKGROUND, pBack);

	// Player
	qObj* pPlayer = new qPlayer;
	pPlayer->SetName(L"Player");
	pPlayer->SetPos(156.f, 755.f);
	pPlayer->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::PLAYER, pPlayer);

	// Boss
	qObj* pBoss = new qBoss;
	pBoss->SetName(L"Boss");
	pBoss->SetPos(910.f, 693.f);
	pBoss->SetScale(100.f, 100.f);
	pBoss->SetDir(DIRECTION::LEFT);
	
	AddObject(LAYER_TYPE::BOSS, pBoss);


	// 보스 HUD
	qBossHUD* pBossHud = new qBossHUD;
	m_BossHud = qAssetMgr::GetInst()->FindTexture(L"hud");

	pBossHud->SetImage(m_BossHud);
	pBossHud->SetScale(Vec2(801.f, 40.f));

	//pBossHud->SetPos(Vec2(vResol.x - (pBossHud->GetScale().x + 800), 500.f));
	pBossHud->SetPos(Vec2(400.f, 0.f));

	AddObject(LAYER_TYPE::UI, pBossHud);


	// 보스 HP
	qBossHP* pBossHP = new qBossHP;
	m_BossHp = qAssetMgr::GetInst()->FindTexture(L"hp");

	pBossHP->SetImage(m_BossHp);
	pBossHP->SetScale(Vec2(801.f, 40.f));
	pBossHP->SetPos(Vec2(439.f, 4.f));
	pBossHP->SetOwner(pBoss);

	AddObject(LAYER_TYPE::UI, pBossHP);


	// 플레이어 Hp
	qPlayerHP* pPlayerHP = new qPlayerHP;
	m_PlayerHP = qAssetMgr::GetInst()->FindTexture(L"playerhp");

	pPlayerHP->SetImage(m_PlayerHP);
	pPlayerHP->SetScale(Vec2(169.f, 11.f));
	pPlayerHP->SetPos(Vec2(719.f, 843.f));
	pPlayerHP->SetOwner(pPlayer);

	AddObject(LAYER_TYPE::UI, pPlayerHP);
	


	// 콜라이더 읽어오기
	LoadPlatform(L"platform\\platform.dat");
	LoadRope(L"rope\\rope.dat");
	LoadPortal(L"portal\\portal.dat");

	LoadMonster_blue(L"monster_blue\\monster_blue.dat");
	LoadMonster_red(L"monster_red\\monster_red.dat");


	// 레벨 충돌 설정하기
	qCollisionMgr::GetInst()->CollisionCheckClear();
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::MONSTER_BLUE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::MONSTER_RED);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::BOSS);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER_SKILL, LAYER_TYPE::BOSS);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::BOSS, LAYER_TYPE::PLATFORM);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::BOSS_SKILL);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PORTAL);

	
}

void qLevel_boss2::Exit()
{

	pSound->SetVolume(30.f);
	pSound->Stop();

	// 레벨에 있는 모든 오브젝트 삭제한다.
	DeleteAllObjects();
}

```

`GameClient/qLevel_boss2.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qTexture;

class qLevel_boss2 : public qLevel
{
public:
	qLevel_boss2();
	~qLevel_boss2();

public:
	virtual void begin() override;
	virtual void tick() override;

	virtual void Enter() override;
	virtual void Exit() override;

private:
	qSound*			pSound;
	qTexture*		m_Minimap;
	qTexture*		m_Menu;
	qTexture*		m_BossHud;
	qTexture*		m_BossHp;
	qTexture*		m_PlayerHP;
};


```

`GameClient/qLevel_stage1.cpp`:

```cpp
#include "pch.h"
#include "qLevel_stage1.h"

#include "qKeyMgr.h"
#include "qForce.h"

#include "qLevelMgr.h"
#include "qCollisionMgr.h"
#include "qPlayer.h"

#include "qMinimap_stage1.h"
#include "qMenu.h"
#include "qAssetMgr.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"
#include "qBackground_stage1.h"

#include "qSound.h"

qLevel_stage1::qLevel_stage1()
{
	SetName(L"Stage1");
}

qLevel_stage1::~qLevel_stage1()
{
}

void qLevel_stage1::begin()
{
	qLevel::begin();

	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\stage1.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	// 페이드 인 페이드 아웃
	qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_IN, 0.7f);
	//qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_OUT, 1.f);


}

void qLevel_stage1::tick()
{
	qLevel::tick();

	//if (KEY_TAP(KEY::LBTN))
	//{
	//	Vec2 vMousePos = qKeyMgr::GetInst()->GetMousePos();
	//	Vec2 vPos = qCamera::GetInst()->GetRenderPos(vMousePos);

	//	qForce* pForce = new qForce();
	//	pForce->SetPos(vPos);
	//	pForce->SetForce(1000.f, 500.f, 2.f);
	//	SpawnObject(this, LAYER_TYPE::FORCE, pForce);
	//}

	if (KEY_TAP(KEY::ENTER))
	{
		ChangeLevel(LEVEL_TYPE::EDITOR);
	}

	if (KEY_TAP(KEY::X))
	{
		ChangeLevel(LEVEL_TYPE::STAGE_02);
	}

	if (KEY_TAP(KEY::C))
	{
		ChangeLevel(LEVEL_TYPE::BOSS_01);
	}

	if (KEY_TAP(KEY::V))
	{
		ChangeLevel(LEVEL_TYPE::BOSS_02);
	}
}

void qLevel_stage1::Enter()
{
	// UI 추가
	// 화면 해상도
	Vec2 vResol = qEngine::GetInst()->GetResolution();


	// 미니맵 UI 추가
	qMinimap_stage1* pMinimap_stage1 = new qMinimap_stage1;
	m_Minimap = qAssetMgr::GetInst()->FindTexture(L"minimap_stage1");

	pMinimap_stage1->SetImage(m_Minimap);
	pMinimap_stage1->SetScale(Vec2(214.f, 142.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMinimap_stage1->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMinimap_stage1);


	// 메뉴 UI 추가
	qMenu* pMenu = new qMenu;
	m_Menu = qAssetMgr::GetInst()->FindTexture(L"menu");

	pMenu->SetImage(m_Menu);
	pMenu->SetScale(Vec2(1600.f, 900.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMenu->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMenu);




	// 레벨에 오브젝트 추가
	// 
	// Background
	qObj* pBack = new qBackground_stage1;
	pBack->SetName(L"Stage1");
	pBack->SetPos(0.0f, 0.f);
	AddObject(LAYER_TYPE::BACKGROUND, pBack);
	

	// Player
	qObj* pObject = new qPlayer;
	pObject->SetName(L"Player");
	pObject->SetPos(1342.f, 744.f);
	pObject->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::PLAYER, pObject);


	// 플레이어 클론
	//qObj* pPlayerClone = pObject->Clone();
	//pPlayerClone->SetPos(800.f, 400.f);
	//m_pCurrentLevel->AddObject(LAYER_TYPE::PLAYER, pPlayerClone);


	// 콜라이더 읽어오기
	LoadPlatform(L"platform\\platform.dat");
	LoadRope(L"rope\\rope.dat");
	LoadPortal(L"portal\\portal.dat");

	LoadMonster_blue(L"monster_blue\\monster_blue.dat");
	LoadMonster_red(L"monster_red\\monster_red.dat");



	// 레벨 충돌 설정하기
	qCollisionMgr::GetInst()->CollisionCheckClear();

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_BLUE, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_RED, LAYER_TYPE::PLATFORM);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::ROPE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PORTAL);


	
}

void qLevel_stage1::Exit()
{
	

	pSound->SetVolume(30.f);
	pSound->Stop();

	// 레벨에 있는 모든 오브젝트 삭제한다.
	DeleteAllObjects();

	//qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_OUT, 1.f);
}

```

`GameClient/qLevel_stage1.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qTexture;

class qLevel_stage1 : public qLevel
{
public:
	qLevel_stage1();
	~qLevel_stage1();

	virtual void begin() override;
	virtual void tick() override;
		    
	virtual void Enter() override;
	virtual void Exit() override;

private:
	qSound*			pSound;
	qTexture*		m_Minimap;
	qTexture*		m_Menu;
};



```

`GameClient/qLevel_stage2.cpp`:

```cpp
#include "pch.h"
#include "qLevel_stage2.h"

#include "qKeyMgr.h"
#include "qLevelMgr.h"

#include "qCollisionMgr.h"
#include "qPlayer.h"

#include "qMinimap_stage2.h"
#include "qMenu.h"
#include "qAssetMgr.h"

#include "qPlatform.h"
#include "qRope.h"
#include "qPortal.h"
#include "qMonster_red.h"
#include "qMonster_blue.h"

#include "qSpawner_blue1.h"
#include "qSpawner_blue2.h"
#include "qSpawner_blue3.h"
#include "qSpawner_red1.h"
#include "qSpawner_red2.h"

#include "qBackground_stage2.h"

#include "qSound.h"


qLevel_stage2::qLevel_stage2()
{
	SetName(L"Stage2");
}

qLevel_stage2::~qLevel_stage2()
{
}

void qLevel_stage2::begin()
{
	qLevel::begin();

	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\level\\stage2.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_IN, 0.7f);
}

void qLevel_stage2::tick()
{
	qLevel::tick();

	wchar_t szBuff[256] = {};
	Vec2 vMousePos = qKeyMgr::GetInst()->GetMousePos();
	Vec2 vRenderPos = qCamera::GetInst()->GetRealPos(vMousePos);
	swprintf_s(szBuff, L"%f, %f", vRenderPos.x, vRenderPos.y);
	static float AccTime = 0.f;

	if (AccTime >= 1.f)
	{
		LOG(LOG_TYPE::DBG_WARNING, szBuff);
		AccTime = 0.f;
	}

	if (KEY_TAP(KEY::ENTER))
	{
		ChangeLevel(LEVEL_TYPE::EDITOR);
	}

	if (KEY_TAP(KEY::Z))
	{
		::ChangeLevel(LEVEL_TYPE::STAGE_01);
	}

	if (KEY_TAP(KEY::C))
	{
		::ChangeLevel(LEVEL_TYPE::BOSS_01);
	}

	if (KEY_TAP(KEY::V))
	{
		ChangeLevel(LEVEL_TYPE::BOSS_02);
	}
	


}

void qLevel_stage2::Enter()
{
	// UI 추가
	// 화면 해상도
	Vec2 vResol = qEngine::GetInst()->GetResolution();

	// 미니맵 UI 추가
	qMinimap_stage2* pMinimap_stage2 = new qMinimap_stage2;
	m_Minimap = qAssetMgr::GetInst()->FindTexture(L"minimap_stage2");

	pMinimap_stage2->SetImage(m_Minimap);
	pMinimap_stage2->SetScale(Vec2(147.f, 160.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMinimap_stage2->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMinimap_stage2);


	// 메뉴 UI 추가
	qMenu* pMenu = new qMenu;
	m_Menu = qAssetMgr::GetInst()->FindTexture(L"menu");

	pMenu->SetImage(m_Menu);
	pMenu->SetScale(Vec2(1600.f, 900.f));

	//pMinimap_stage1->SetPos(Vec2(vResol.x - (pMinimap_stage1->GetScale().x + 30), 30.f));

	pMenu->SetPos(Vec2(0.f, 0.f));

	AddObject(LAYER_TYPE::UI, pMenu);



	// 레벨에 오브젝트 추가
	// 
	// Background
	qObj* pBack = new qBackground_stage2;
	pBack->SetName(L"Stage2");
	pBack->SetPos(0.f, 0.f);
	AddObject(LAYER_TYPE::BACKGROUND, pBack);

	// Player
	qObj* pPlayer = new qPlayer;
	pPlayer->SetName(L"Player");
	pPlayer->SetPos(1821.f, 1454.f);
	pPlayer->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::PLAYER, pPlayer);

	// 몬스터 블루1 (티구르) 생성
	qObj* pBlue1 = new qMonster_blue(DIRECTION::LEFT);
	pBlue1->SetName(L"Blue");
	pBlue1->SetPos(1377.f, 1448.f);
	pBlue1->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pBlue1);
	
	qObj* pSpawnBlue1 = new qSpawner_blue1;
	pSpawnBlue1->SetOwner(pBlue1);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pSpawnBlue1);
	
	// 몬스터 블루2 (티구르) 생성
	qObj* pBlue2 = new qMonster_blue(DIRECTION::RIGHT);
	pBlue2->SetName(L"Blue");
	pBlue2->SetPos(972.f, 1448.f);
	pBlue2->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pBlue2);

	qObj* pSpawnBlue2 = new qSpawner_blue2;
	pSpawnBlue2->SetOwner(pBlue2);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pSpawnBlue2);


	// 몬스터 블루3 (티구르) 생성
	qObj* pBlue3 = new qMonster_blue(DIRECTION::LEFT);
	pBlue3->SetName(L"Blue");
	pBlue3->SetPos(543.f, 1448.f);
	pBlue3->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pBlue3);

	qObj* pSpawnBlue3 = new qSpawner_blue3;
	pSpawnBlue3->SetOwner(pBlue3);
	AddObject(LAYER_TYPE::MONSTER_BLUE, pSpawnBlue3);


	// 레드 몬스터(티루) 생성
	qObj* pRed1 = new qMonster_red(DIRECTION::LEFT);
	pRed1->SetName(L"Red");
	pRed1->SetPos(1336.f, 1093.f);
	pRed1->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::MONSTER_RED, pRed1);

	qObj* pSpawnRed1 = new qSpawner_red1;
	pSpawnRed1->SetOwner(pRed1);
	AddObject(LAYER_TYPE::MONSTER_RED, pSpawnRed1);

	// 몬스터 생성
	qObj* pRed2 = new qMonster_red(DIRECTION::RIGHT);
	pRed2->SetName(L"Red");
	pRed2->SetPos(700.f, 1093.f);
	pRed2->SetScale(100.0f, 100.0f);
	AddObject(LAYER_TYPE::MONSTER_RED, pRed2);

	qObj* pSpawnRed2 = new qSpawner_red2;
	pSpawnRed2->SetOwner(pRed2);
	AddObject(LAYER_TYPE::MONSTER_RED, pSpawnRed2);




	// 콜라이더 읽어오기
	LoadPlatform(L"platform\\platform.dat");
	LoadRope(L"rope\\rope.dat");
	LoadPortal(L"portal\\portal.dat");

	//LoadMonster_blue(L"monster_blue\\monster_blue.dat");
	//LoadMonster_red(L"monster_red\\monster_red.dat");

	// 레벨 충돌 설정하기
	qCollisionMgr::GetInst()->CollisionCheckClear();
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::MONSTER_BLUE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::MONSTER_RED);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::ROPE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER, LAYER_TYPE::PORTAL);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER_SKILL, LAYER_TYPE::MONSTER_BLUE);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::PLAYER_SKILL, LAYER_TYPE::MONSTER_RED);

	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_BLUE, LAYER_TYPE::PLATFORM);
	qCollisionMgr::GetInst()->CollisionCheck(LAYER_TYPE::MONSTER_RED, LAYER_TYPE::PLATFORM);

}

void qLevel_stage2::Exit()
{
	

	pSound->SetVolume(30.f);
	pSound->Stop();

	// 레벨에 있는 모든 오브젝트 삭제한다.
	DeleteAllObjects();

	//qCamera::GetInst()->SetCameraEffect(CAM_EFFECT::FADE_OUT, 1.f);
}



```

`GameClient/qLevel_stage2.h`:

```h
#pragma once
#include "qLevel.h"

class qSound;
class qTexture;

class qLevel_stage2 : public qLevel
{
public:
	qLevel_stage2();
	~qLevel_stage2();

public:

	virtual void begin() override;
	virtual void tick() override;

	virtual void Enter() override;
	virtual void Exit() override;



private:
	qSound*			pSound;
	qTexture*		m_Minimap;
	qTexture*		m_Menu;
};


```

`GameClient/qLogo.cpp`:

```cpp
#include "pch.h"
#include "qLogo.h"

#include "qAnimator.h"
#include "qCamera.h"

#include "qTaskMgr.h"


qLogo::qLogo()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* Logo = qAssetMgr::GetInst()->LoadTexture(L"Logo", L"texture\\logo\\logo.png");

	//애니메이션 CREATE
	m_Animator->CreateAnimation(L"Logo", Logo, Vec2(0.f, 0.f), Vec2(1600.f, 900.f), 48, 14);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"Logo")->Save(L"animation\\logo\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\logo\\Logo.anim");

	m_Animator->Play(L"Logo", false);



	
}

qLogo::qLogo(const qLogo& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qLogo::~qLogo()
{
}

void qLogo::tick()
{
	qObj::tick();


	if (L"Logo" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			ChangeLevel(LEVEL_TYPE::START);
		}
	}
}



```

`GameClient/qLogo.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qLogo : public qObj
{
public:
	CLONE(qLogo);

public:
	qLogo();
	qLogo(const qLogo& _Other);
	~qLogo();

	qAnimator* GetAnimator() { return m_Animator; }

	virtual void tick() override;

private:
	qAnimator*		m_Animator;
};


```

`GameClient/qMenu.cpp`:

```cpp
#include "pch.h"
#include "qMenu.h"

qMenu::qMenu()
{
	m_MenuImg = qAssetMgr::GetInst()->LoadTexture(L"menu", L"texture\\ui\\menu\\menu.png");
	m_MenuNoImg = qAssetMgr::GetInst()->LoadTexture(L"menuno", L"texture\\ui\\menu\\menu1.png");
}

qMenu::~qMenu()
{
}

void qMenu::tick_ui()
{
	//qUI::tick();
}

void qMenu::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_MenuImg->GetWidth(), m_MenuImg->GetHeight()
		, m_MenuImg->GetDC(), 0, 0, m_MenuImg->GetWidth(), m_MenuImg->GetHeight(), bf);
}

```

`GameClient/qMenu.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qMenu : public qUI
{
public:
	CLONE(qMenu);

	qMenu();
	~qMenu();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;

	void SetImage(qTexture* _Tex) { m_MenuImg = _Tex; }

private:
	qTexture*		m_MenuImg;
	qTexture*		m_MenuNoImg;

};


```

`GameClient/qMinimap_boss1.cpp`:

```cpp
#include "pch.h"
#include "qMinimap_boss1.h"

qMinimap_boss1::qMinimap_boss1()
{
	m_MinimapImg_boss1 = qAssetMgr::GetInst()->LoadTexture(L"minimap_boss1", L"texture\\ui\\minimap\\boss1.png");
}

qMinimap_boss1::~qMinimap_boss1()
{
}

void qMinimap_boss1::tick_ui()
{
	//qUI::tick();
}

void qMinimap_boss1::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_MinimapImg_boss1->GetWidth(), m_MinimapImg_boss1->GetHeight()
		, m_MinimapImg_boss1->GetDC(), 0, 0, m_MinimapImg_boss1->GetWidth(), m_MinimapImg_boss1->GetHeight(), bf);
}

```

`GameClient/qMinimap_boss1.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qMinimap_boss1 : public qUI
{
public:
	CLONE(qMinimap_boss1);

	qMinimap_boss1();
	~qMinimap_boss1();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;


	void SetImage(qTexture* _Tex) { m_MinimapImg_boss1 = _Tex; }


private:
	qTexture* m_MinimapImg_boss1;
};


```

`GameClient/qMinimap_boss2.cpp`:

```cpp
#include "pch.h"
#include "qMinimap_boss2.h"

qMinimap_boss2::qMinimap_boss2()
{
	m_MinimapImg_boss2 = qAssetMgr::GetInst()->LoadTexture(L"minimap_boss2", L"texture\\ui\\minimap\\boss2.png");
}

qMinimap_boss2::~qMinimap_boss2()
{
}

void qMinimap_boss2::tick_ui()
{
	//qUI::tick();
}

void qMinimap_boss2::render_ui()
{

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_MinimapImg_boss2->GetWidth(), m_MinimapImg_boss2->GetHeight()
		, m_MinimapImg_boss2->GetDC(), 0, 0, m_MinimapImg_boss2->GetWidth(), m_MinimapImg_boss2->GetHeight(), bf);
}

```

`GameClient/qMinimap_boss2.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qMinimap_boss2 : public qUI
{
	CLONE(qMinimap_boss2);

public:
	qMinimap_boss2();
	~qMinimap_boss2();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;


	void SetImage(qTexture* _Tex) { m_MinimapImg_boss2 = _Tex; }


private:
	qTexture* m_MinimapImg_boss2;
};


```

`GameClient/qMinimap_stage1.cpp`:

```cpp
#include "pch.h"
#include "qMinimap_stage1.h"

qMinimap_stage1::qMinimap_stage1()
{
	m_MinimapImg_stage1 = qAssetMgr::GetInst()->LoadTexture(L"minimap_stage1", L"texture\\ui\\minimap\\stage1.png");
}

qMinimap_stage1::~qMinimap_stage1()
{
}

void qMinimap_stage1::tick_ui()
{
	//qUI::tick();
}

void qMinimap_stage1::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_MinimapImg_stage1->GetWidth(), m_MinimapImg_stage1->GetHeight()
		, m_MinimapImg_stage1->GetDC(), 0, 0, m_MinimapImg_stage1->GetWidth(), m_MinimapImg_stage1->GetHeight(), bf);
}

```

`GameClient/qMinimap_stage1.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qMinimap_stage1 : public qUI
{
public:
	CLONE(qMinimap_stage1);

	qMinimap_stage1();
	~qMinimap_stage1();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;


	void SetImage(qTexture* _Tex) { m_MinimapImg_stage1 = _Tex; }


private:
	qTexture*		m_MinimapImg_stage1;
};


```

`GameClient/qMinimap_stage2.cpp`:

```cpp
#include "pch.h"
#include "qMinimap_stage2.h"

qMinimap_stage2::qMinimap_stage2()
{
	m_MinimapImg_stage2 = qAssetMgr::GetInst()->LoadTexture(L"minimap_stage2", L"texture\\ui\\minimap\\stage2.png");
}

qMinimap_stage2::~qMinimap_stage2()
{
}

void qMinimap_stage2::tick_ui()
{
	//qUI::tick();
}

void qMinimap_stage2::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	// AlphaBlending
	BLENDFUNCTION bf = {};

	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = AC_SRC_ALPHA;

	AlphaBlend(DC, (int)(vPos.x)
		, (int)(vPos.y)
		, m_MinimapImg_stage2->GetWidth(), m_MinimapImg_stage2->GetHeight()
		, m_MinimapImg_stage2->GetDC(), 0, 0, m_MinimapImg_stage2->GetWidth(), m_MinimapImg_stage2->GetHeight(), bf);
}

```

`GameClient/qMinimap_stage2.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qMinimap_stage2 : public qUI
{
public:
	CLONE(qMinimap_stage2);

	qMinimap_stage2();
	~qMinimap_stage2();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;


	void SetImage(qTexture* _Tex) { m_MinimapImg_stage2 = _Tex; }


private:
	qTexture* m_MinimapImg_stage2;
};


```

`GameClient/qMissile.cpp`:

```cpp
#include "pch.h"
#include "qMissile.h"

#include "qCollider.h"
#include "qTimeMgr.h"

qMissile::qMissile()
	: m_Speed(500.f)
	, m_Angle(0.f)
{
	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 0.f));
	m_Collider->SetScale(Vec2(20.f, 20.f));
}

qMissile::~qMissile()
{
}


void qMissile::tick()
{
	Vec2 vPos = GetPos();

	Vec2 vDir = Vec2(cosf(m_Angle), -sinf(m_Angle));

	vPos += vDir * m_Speed * DT;

	SetPos(vPos);

}

void qMissile::render()
{
	Vec2 vPos = GetRenderPos();
	Vec2 vScale = GetScale();

	Ellipse(DC, (int)(vPos.x - vScale.x * 0.5f)
		, (int)(vPos.y - vScale.y * 0.5f)
		, (int)(vPos.x + vScale.x * 0.5f)
		, (int)(vPos.y + vScale.y * 0.5f));
}



```

`GameClient/qMissile.h`:

```h
#pragma once
#include "qObj.h"
class qMissile : public qObj
{
public:
	qMissile();
	~qMissile();


public:
	virtual void tick() override;
	virtual void render() override;

protected:
	void SetSpeed(float _Speed) { m_Speed = _Speed; }
	void SetAngle(float _Angle) { m_Angle = _Angle; }

	float GetSpeed() { return m_Speed; }
	float GetAngle() { return m_Angle; }

	qCollider* GetCollider() { return m_Collider; }


private:
	virtual qMissile* Clone() { return new qMissile(*this); }


private:
	float		m_Speed;
	float		m_Angle;	// 라디안

	qCollider*	m_Collider;

};


```

`GameClient/qMonster_blue.cpp`:

```cpp
#include "pch.h"
#include "qMonster_blue.h"

#include "qCollider.h"
#include "qRigidbody.h"
#include "qAnimator.h"
#include "qAnimation.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qFSM.h"
#include "qBlueIdleState.h"
#include "qBlueMoveState.h"
#include "qBlueDeadState.h"



qMonster_blue::qMonster_blue(DIRECTION _Dir)
	: m_BlueHP(10)
	, m_Speed(100.f)
	, m_MaxDistance(100.f)

{
	SetDir(_Dir);

	
	//// 난수 생성
	//srand((unsigned int)time(NULL));

	//int num = rand() % 1;

	//if (num == 0)
	//{
	//	SetDir(DIRECTION::LEFT);
	//}

	//else if (1 == num)
	//{
	//	SetDir(DIRECTION::RIGHT);
	//}

	// 콜라이더 설정
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(Vec2(65.f, 85.f));


	// 중력 설정
	m_Rigidbody = (qRigidbody*)AddComponent(new qRigidbody);
	m_Rigidbody->SetMass(1.f);
	m_Rigidbody->UseGravity(true);
	m_Rigidbody->SetMaxGravitySpeed(1500.f);
	//m_Rigidbody->SetGround(false);
	

	m_FSM = (qFSM*)AddComponent(new qFSM);
	m_FSM->AddState(L"Idle", new qBlueIdleState);
	m_FSM->AddState(L"Move", new qBlueMoveState);
	m_FSM->AddState(L"Dead", new qBlueDeadState);

	
	// 애니메이션 설정
	m_Animator = (qAnimator*)AddComponent(new qAnimator);
	
	//// Animation Register
	//// IDLE
	//qTexture* pBlueIdleRight = qAssetMgr::GetInst()->LoadTexture(L"BlueIdleRight", L"texture\\character\\monster\\blue\\idle\\blue_idle_right.png");
	//qTexture* pBlueIdleLeft = qAssetMgr::GetInst()->LoadTexture(L"BlueIdleLeft", L"texture\\character\\monster\\blue\\idle\\blue_idle_left.png");
	//
	//// MOVE
	//qTexture* pBlueMoveRight = qAssetMgr::GetInst()->LoadTexture(L"BlueMoveRight", L"texture\\character\\monster\\blue\\move\\blue_move_right.png");
	//qTexture* pBlueMoveLeft = qAssetMgr::GetInst()->LoadTexture(L"BlueMoveLeft", L"texture\\character\\monster\\blue\\move\\blue_move_left.png");

	//// DEAD
	//qTexture* pBlueDeadRight = qAssetMgr::GetInst()->LoadTexture(L"BlueDeadRight", L"texture\\character\\monster\\blue\\dead\\blue_dead_right.png");
	//qTexture* pBlueDeadLeft = qAssetMgr::GetInst()->LoadTexture(L"BlueDeadLeft", L"texture\\character\\monster\\blue\\dead\\blue_dead_left.png");


	//// Animation Create
	//// IDLE
	//m_Animator->CreateAnimation(L"BlueIdleRight", pBlueIdleRight, Vec2(0.f, 0.f), Vec2(60.f, 82.f), 6, 5);
	//m_Animator->CreateAnimation(L"BlueIdleLeft", pBlueIdleLeft, Vec2(0.f, 0.f), Vec2(60.f, 82.f), 6, 5);

	//// MOVE
	//m_Animator->CreateAnimation(L"BlueMoveRight", pBlueMoveRight, Vec2(0.f, 0.f), Vec2(65.f, 91.f), 6, 7);
	//m_Animator->CreateAnimation(L"BlueMoveLeft", pBlueMoveLeft, Vec2(0.f, 0.f), Vec2(65.f, 91.f), 6, 7);

	//// DEAD
	//m_Animator->CreateAnimation(L"BlueDeadRight", pBlueDeadRight, Vec2(0.f, 0.f), Vec2(93.f, 93.f), 12, 8);
	//m_Animator->CreateAnimation(L"BlueDeadLeft", pBlueDeadLeft, Vec2(0.f, 0.f), Vec2(93.f, 93.f), 12, 8);
	//

	//// Animation Save
	//// IDLE
	//m_Animator->FindAnimation(L"BlueIdleRight")->Save(L"animation\\monster\\blue\\idle\\");
	//m_Animator->FindAnimation(L"BlueIdleLeft")->Save(L"animation\\monster\\blue\\idle\\");

	//// MOVE
	//m_Animator->FindAnimation(L"BlueMoveRight")->Save(L"animation\\monster\\blue\\move\\");
	//m_Animator->FindAnimation(L"BlueMoveLeft")->Save(L"animation\\monster\\blue\\move\\");

	//// DEAD
	//m_Animator->FindAnimation(L"BlueDeadRight")->Save(L"animation\\monster\\blue\\dead\\");
	//m_Animator->FindAnimation(L"BlueDeadLeft")->Save(L"animation\\monster\\blue\\dead\\");



	// Animation Load
	m_Animator->LoadAnimation(L"animation\\monster\\blue\\idle\\BlueIdleRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\blue\\idle\\BlueIdleLeft.anim");

	m_Animator->LoadAnimation(L"animation\\monster\\blue\\move\\BlueMoveRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\blue\\move\\BlueMoveLeft.anim");

	m_Animator->LoadAnimation(L"animation\\monster\\blue\\dead\\BlueDeadRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\blue\\dead\\BlueDeadLeft.anim");

	
}

qMonster_blue::qMonster_blue(const qMonster_blue& _Other)
	: qObj(_Other)
	, m_BlueHP(100)
	, m_Speed(_Other.m_Speed)
	, m_MaxDistance(_Other.m_MaxDistance)
	, m_Animator(nullptr)
	, m_Dir(_Other.m_Dir)
	, m_FSM(_Other.m_FSM)
{
	m_Collider = GetComponent<qCollider>();
	m_Animator = GetComponent<qAnimator>();
	m_Rigidbody = GetComponent<qRigidbody>();

	//m_Collider = _Other.m_Collider->Clone();
	//m_Animator = _Other.m_Animator->Clone();
	//m_Rigidbody = _Other.m_Rigidbody->Clone();
}


qMonster_blue::~qMonster_blue()
{
	
}

void qMonster_blue::begin()
{
	qObj::begin();

	
	SetCenterPos(GetPos());

	m_FSM->SetBlackboardData(L"BlueSpeed", DATA_TYPE::FLOAT, &m_Speed);
	m_FSM->SetBlackboardData(L"BlueHP", DATA_TYPE::INT, &m_BlueHP);
	m_FSM->SetBlackboardData(L"MaxDist", DATA_TYPE::FLOAT, &m_MaxDistance);
	m_FSM->SetBlackboardData(L"Blue", DATA_TYPE::OBJECT, this);


	m_FSM->ChangeState(L"Idle");
}

void qMonster_blue::tick()
{
	qObj::tick();
	Vec2 vPos = GetPos();


}


void qMonster_blue::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER_SKILL == _OtherObj->GetLayerType())
	{
		m_FSM->ChangeState(L"Dead");


		//--m_HP;
		//
		//if (0 >= m_HP)
		//{
		//	
		//}
	}


}

void qMonster_blue::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	//if (LAYER_TYPE::PLAYER_SKILL == _OtherObj->GetLayerType())
	//{
	//	m_FSM->ChangeState(L"Dead");

	//}
}








```

`GameClient/qMonster_blue.h`:

```h
#pragma once
#include "qObj.h"

class qTexture;
class qCollider;
class qFSM;
class qAnimator;

class qMonster_blue : public qObj
{
public:

	CLONE(qMonster_blue);

	qMonster_blue(DIRECTION _Dir);
	qMonster_blue(const qMonster_blue& _Other);
	~qMonster_blue();

public:
	virtual void begin() override;
	virtual void tick() override;
	
	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:

	Vec2			m_Pos;

	int				m_BlueHP;
	float			m_Speed;
	float			m_MaxDistance;
	
	DIRECTION		m_Dir;

	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qRigidbody*		m_Rigidbody;


	qFSM*			m_FSM;

	//Vec2			m_Data;
	//float			m_DetectRange;
};


```

`GameClient/qMonster_red.cpp`:

```cpp
#include "pch.h"
#include "qMonster_red.h"

#include "qCollider.h"
#include "qRigidbody.h"
#include "qAnimator.h"
#include "qAnimation.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qFSM.h"

#include "qRedIdleState.h"
#include "qRedMoveState.h"
#include "qRedDeadState.h"

#include "qLevelMgr.h"

qMonster_red::qMonster_red(DIRECTION _Dir)
	: m_RedHP(10)
	, m_Speed(100)
	, m_MaxDistance(100.f)
{
	SetDir(_Dir);

	// 콜라이더 설정
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(Vec2(57.f, 70.f));

	// 중력 설정
	m_Rigidbody = (qRigidbody*)AddComponent(new qRigidbody);
	m_Rigidbody->SetMass(1.f);
	m_Rigidbody->UseGravity(true);
	m_Rigidbody->SetMaxGravitySpeed(1500.f);

	m_FSM = (qFSM*)AddComponent(new qFSM);
	m_FSM->AddState(L"RedIdle", new qRedIdleState);
	m_FSM->AddState(L"RedMove", new qRedMoveState);
	m_FSM->AddState(L"RedDead", new qRedDeadState);


	// 애니메이션 설정
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	//// Animation Register
	//// IDLE
	//qTexture* pRedIdleRight = qAssetMgr::GetInst()->LoadTexture(L"RedIdleRight", L"texture\\character\\monster\\red\\idle\\red_idle_right.png");
	//qTexture* pRedIdleLeft = qAssetMgr::GetInst()->LoadTexture(L"RedIdleLeft", L"texture\\character\\monster\\red\\idle\\red_idle_left.png");

	//// MOVE
	//qTexture* pRedMoveRight = qAssetMgr::GetInst()->LoadTexture(L"RedMoveRight", L"texture\\character\\monster\\red\\move\\red_move_right.png");
	//qTexture* pRedMoveLeft = qAssetMgr::GetInst()->LoadTexture(L"RedMoveLeft", L"texture\\character\\monster\\red\\move\\red_move_left.png");

	//// DEAD
	//qTexture* pRedDeadRight = qAssetMgr::GetInst()->LoadTexture(L"RedDeadRight", L"texture\\character\\monster\\red\\dead\\red_dead_right.png");
	//qTexture* pRedDeadLeft = qAssetMgr::GetInst()->LoadTexture(L"RedDeadLeft", L"texture\\character\\monster\\red\\dead\\red_dead_left.png");


	//// Animation Create
	//// IDLE
	//m_Animator->CreateAnimation(L"RedIdleRight", pRedIdleRight, Vec2(0.f, 0.f), Vec2(57.f, 70.f), 6, 5);
	//m_Animator->CreateAnimation(L"RedIdleLeft", pRedIdleLeft, Vec2(0.f, 0.f), Vec2(57.f, 70.f), 6, 5);

	//// MOVE
	//m_Animator->CreateAnimation(L"RedMoveRight", pRedMoveRight, Vec2(0.f, 0.f), Vec2(61.f, 82.f), 6, 7);
	//m_Animator->CreateAnimation(L"RedMoveLeft", pRedMoveLeft, Vec2(0.f, 0.f), Vec2(61.f, 82.f), 6, 7);

	//// DEAD
	//m_Animator->CreateAnimation(L"RedDeadRight", pRedDeadRight, Vec2(0.f, 0.f), Vec2(82.f, 93.f), 12, 10);
	//m_Animator->CreateAnimation(L"RedDeadLeft", pRedDeadLeft, Vec2(0.f, 0.f), Vec2(82.f, 93.f), 12, 10);


	//// Animation Save
	//// IDLE
	//m_Animator->FindAnimation(L"RedIdleRight")->Save(L"animation\\monster\\red\\idle\\");
	//m_Animator->FindAnimation(L"RedIdleLeft")->Save(L"animation\\monster\\red\\idle\\");

	//// MOVE
	//m_Animator->FindAnimation(L"RedMoveRight")->Save(L"animation\\monster\\red\\move\\");
	//m_Animator->FindAnimation(L"RedMoveLeft")->Save(L"animation\\monster\\red\\move\\");

	//// DEAD
	//m_Animator->FindAnimation(L"RedDeadRight")->Save(L"animation\\monster\\red\\dead\\");
	//m_Animator->FindAnimation(L"RedDeadLeft")->Save(L"animation\\monster\\red\\dead\\");



	// Animation Load
	m_Animator->LoadAnimation(L"animation\\monster\\red\\idle\\RedIdleRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\red\\idle\\RedIdleLeft.anim");

	m_Animator->LoadAnimation(L"animation\\monster\\red\\move\\RedMoveRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\red\\move\\RedMoveLeft.anim");

	m_Animator->LoadAnimation(L"animation\\monster\\red\\dead\\RedDeadRight.anim");
	m_Animator->LoadAnimation(L"animation\\monster\\red\\dead\\RedDeadLeft.anim");


}

qMonster_red::qMonster_red(const qMonster_red& _Other)
	: qObj(_Other)
	, m_RedHP(10)
	, m_Speed(100)
	, m_MaxDistance(100.f)
{
	SetName(L"Red");

	m_Collider = GetComponent<qCollider>();
	m_Animator = GetComponent<qAnimator>();
	m_Rigidbody = GetComponent<qRigidbody>();

}

qMonster_red::~qMonster_red()
{
}

void qMonster_red::begin()
{
	qObj::begin();

	SetCenterPos(GetPos());

	m_FSM->SetBlackboardData(L"RedSpeed", DATA_TYPE::FLOAT, &m_Speed);
	m_FSM->SetBlackboardData(L"RedHP", DATA_TYPE::INT, &m_RedHP);
	m_FSM->SetBlackboardData(L"MaxDist", DATA_TYPE::FLOAT, &m_MaxDistance);
	m_FSM->SetBlackboardData(L"Red", DATA_TYPE::OBJECT, this);

	m_FSM->ChangeState(L"RedIdle");
}

void qMonster_red::tick()
{
	qObj::tick();
}



void qMonster_red::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::PLAYER_SKILL == _OtherObj->GetLayerType())
	{
		m_FSM->ChangeState(L"RedDead");

		//--m_HP;
		//
		//if (0 >= m_HP)
		//{
		//	
		//}
	}
}

void qMonster_red::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	//if (LAYER_TYPE::PLAYER_SKILL == _OtherObj->GetLayerType())
	//{
	//	m_FSM->ChangeState(L"RedDead");

	//	//--m_HP;
	//	//
	//	//if (0 >= m_HP)
	//	//{
	//	//	
	//	//}
	//}
}

```

`GameClient/qMonster_red.h`:

```h
#pragma once
#include "qObj.h"

class qCollider;
class qTexture;

class qMonster_red : public qObj
{
public:
	CLONE(qMonster_red);

	qMonster_red(DIRECTION _Dir);
	qMonster_red(const qMonster_red& _Other);
	~qMonster_red();


public:
	virtual void begin() override;
	virtual void tick() override;
	
	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:

	Vec2		m_Pos;
	int			m_RedHP;
	float		m_Speed;

	float		m_MaxDistance;

	DIRECTION	m_Dir;

	qAnimator*	m_Animator;
	qCollider*	m_Collider;
	qRigidbody* m_Rigidbody;

	qFSM* m_FSM;

};


```

`GameClient/qObj.cpp`:

```cpp
#include "pch.h"
#include "qObj.h"

#include "qEngine.h"
#include "qTimeMgr.h"
#include "qTaskMgr.h"

#include "qComponent.h"
#include "qAnimator.h"

qObj::qObj()
	: m_Type(LAYER_TYPE::NONE)
	, m_bDead(false)
	, m_Animator(nullptr)
	, m_AttackDamage(1500000)
	, m_MissileDamage(1600000)
	, m_SlashDamage(1700000)
	, m_SpecialDamage(2600000)
	, m_BossHP(63000000)
	, m_AttackCount(0)
	, m_MissileCount(0)
	, m_SlashCount(0)
	, m_SpecialCount(0)
	, m_Exp(0)
	, m_PlayerHP(500000)
{
}

qObj::qObj(const qObj& _Other)
	: qEntity(_Other)
	, m_PrevPos(_Other.m_PrevPos)
	, m_Scale(_Other.m_Scale)
	, m_Animator(nullptr)
	, m_Type(_Other.m_Type)
	, m_CenterPos(_Other.m_CenterPos)
	, m_bDead(false)
	, m_Dir(_Other.m_Dir)
	, m_AttackDamage(_Other.m_AttackDamage)
	, m_MissileDamage(_Other.m_MissileDamage)
	, m_SlashDamage(_Other.m_SlashDamage)
	, m_SpecialDamage(_Other.m_SpecialDamage)
	, m_BossHP(_Other.m_BossHP)
	, m_AttackCount(_Other.m_AttackCount)
	, m_MissileCount(_Other.m_MissileCount)
	, m_SlashCount(_Other.m_SlashCount)
	, m_SpecialCount(_Other.m_SpecialCount)
	, m_Exp(_Other.m_Exp)
	, m_PlayerHP(_Other.m_PlayerHP)
{
	for (size_t i = 0; i < _Other.m_vecCom.size(); ++i)
	{
		AddComponent(_Other.m_vecCom[i]->Clone());
	}

}

qObj::~qObj()
{
	Safe_Del_Vec(m_vecCom);
}


void qObj::begin()
{
	
}

void qObj::tick()
{
	
}

void qObj::finaltick()
{
	for (size_t i = 0; i < m_vecCom.size(); ++i)
	{
		m_vecCom[i]->finaltick();
	}
}

void qObj::render()
{
	if (nullptr == m_Animator)
		return;

	m_Animator->render();
}


void qObj::Destroy()
{
	tTask task = {};
	task.Type = TASK_TYPE::DELETE_OBJECT;
	task.Param1 = (DWORD_PTR)this;

	qTaskMgr::GetInst()->AddTask(task);
}

qComponent* qObj::AddComponent(qComponent* _Component)
{
	m_vecCom.push_back(_Component);
	_Component->m_Owner = this;

	if (m_Animator == nullptr)
	{
		// 오브젝트에 추가된 컴포넌트가 Animator 면 별도의 포인터로 따로 가리킨다.
		m_Animator = dynamic_cast<qAnimator*>(_Component);
	}

	return _Component;
}
```

`GameClient/qObj.h`:

```h
#pragma once
#include "qEntity.h"

#include "qEngine.h"
#include "qTimeMgr.h"
#include "qKeyMgr.h"

#include "qAssetMgr.h"
#include "qTexture.h"

#include "qCamera.h"

class qComponent;
class qCollider;
class qAnimator;
class qRigidbody;
class qFSM;


class qObj : public qEntity
{
private:

	DIRECTION			m_Dir;		// 방향
	
	qObj*				m_Owner;

	Vec2				m_CenterPos;
	Vec2				m_Pos;		// 위치
	Vec2				m_PrevPos;	// 이전 프레임에서의 위치
	Vec2				m_Scale;	// 크기
	vector<qComponent*>	m_vecCom;	// 보유 컴포넌트들

	qAnimator*			m_Animator;

	int					m_AttackDamage;
	int					m_MissileDamage;
	int					m_SlashDamage;
	int					m_SpecialDamage;

	int					m_AttackCount;
	int					m_MissileCount;
	int					m_SlashCount;
	int					m_SpecialCount;


	int					m_PhysicalDamage;
	int					m_MagicDamage;

	int					m_PhysicalCount;
	int					m_MagicCount;

	int					m_BossHP;
	int					m_PlayerHP;

	int					m_Exp;

	LAYER_TYPE			m_Type;		// 소속 레이어
	bool				m_bDead;	// 삭제 예정 상태
	

public:

	int GetAttackCount() { return m_AttackCount; }
	void PlusAttackCount() { m_AttackCount += 1; }

	int GetMissileCount() { return m_MissileCount; }
	void PlusMissileCount() { m_MissileCount += 1; }

	int GetSlashCount() { return m_SlashCount; }
	void PlusSlashCount() { m_SlashCount += 1; }

	int GetSpecialCount() { return m_SpecialCount; }
	void PlusSpecialCount() { m_SpecialCount += 1; }

	int GetPhysicalCount() { return m_PhysicalCount; }
	void PlusPhysicalCount() { m_PhysicalCount += 1; }

	int GetMagicCount() { return m_MagicCount; }
	void PlusMagicCount() { m_MagicCount += 1; }


	int GetExp() { return m_Exp; }
	void PlusExp() { m_Exp += 40; }

	int GetBossHP() { return m_BossHP; }
	void SetBossHP(int _hp) { m_BossHP = _hp; }

	int GetPlayerHP() { return m_PlayerHP; }
	void SetPlayerHP(int _hp) { m_PlayerHP = _hp; }


	int GetAttackDamage() { return m_AttackDamage; }
	int GetMissileDamage() { return m_MissileDamage; }
	int GetSlashDamage() { return m_SlashDamage; }
	int GetSpecialDamage() { return m_SpecialDamage; }

	int GetPhysicalDamage() { return m_PhysicalDamage; }
	int GetMagicDamage() { return m_MagicDamage; }


	void SetDir(DIRECTION _Dir) { m_Dir = _Dir; }
	DIRECTION GetDir() { return m_Dir; }

	void SetPos(Vec2 _Pos) { m_Pos = _Pos; }
	void SetScale(Vec2 _Scale) { m_Scale = _Scale; }

	void SetPos(float _x, float _y) { m_Pos.x = _x; m_Pos.y = _y; }
	void SetScale(float _width, float _height) { m_Scale.x = _width; m_Scale.y = _height; }
	void SetCenterPos(Vec2 _CenterPos) { m_CenterPos = _CenterPos; }


	void SetOwner(qObj* _Owner) { m_Owner = _Owner; }
	qObj* GetOwner() { return m_Owner; }

	Vec2 GetCenterPos() { return m_CenterPos; }
	Vec2 GetPos() { return m_Pos; }
	Vec2 GetPrevPos() { return m_PrevPos; }
	Vec2 GetRenderPos() { return qCamera::GetInst()->GetRenderPos(m_Pos); }
	Vec2 GetScale() { return m_Scale; }

	LAYER_TYPE GetLayerType() { return m_Type; }
	void SetLayerType(LAYER_TYPE _Type) { m_Type = _Type; }


	bool IsDead() { return m_bDead; }

	void Destroy();

	qComponent* AddComponent(qComponent* _Component);

	template<typename T>
	T* GetComponent()
	{
		for (size_t i = 0; i < m_vecCom.size(); ++i)
		{
			T* pComponent = dynamic_cast<T*>(m_vecCom[i]);

			if (pComponent)
			{
				return pComponent;
			}
		}

		return nullptr;
	}

public:
	virtual void begin();		
	virtual void tick();		// 오브젝트가 매 프레임마다 해야할 작업을 구현
	virtual void finaltick() final;	// 오브젝트가 소유한 컴포넌트들이 매 프레임마다 해야할 작업을 구현
	virtual void render();


	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider){}	// 막 충돌했을 때
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider){}		// 충돌중일 때
	virtual void EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider){}		// 충돌이 끝났을 때



public:
	virtual qObj* Clone() = 0;	// { return new qObj(*this); }


public:
	qObj();
	qObj(const qObj& _Other);
	~qObj();

	friend class qLevel;
	friend class qTaskMgr;
};


```

`GameClient/qPathMgr.cpp`:

```cpp
#include "pch.h"
#include "qPathMgr.h"

#include "resource.h"
#include "qEngine.h"

qPathMgr::qPathMgr()
{
}

qPathMgr::~qPathMgr()
{
}

void qPathMgr::init()
{
	// 실행경로를 얻어낸다
	wchar_t szBuffer[256] = {};
	GetCurrentDirectory(256, szBuffer);

	// bin 폴더의 상위폴더로 접근한다.
	GetParentPath(szBuffer);

	// \\Content\\ 를 붙여둔다
	m_Content = szBuffer;
	m_Content += L"\\content\\";

	// OutputFile 폴더의 상위폴더로 접근한다.
	GetParentPath(szBuffer);
	m_Solution = szBuffer;

	// String Table 에서 프로젝트 이름을 얻어온다.
	wchar_t szProjName[50] = {};
	LoadStringW(qEngine::GetInst()->GetProcessInstance(), IDS_APP_TITLE, szProjName, 50);

	// Solution 경로에서 프로젝트 이름을 붙인다.
	m_Proj = m_Solution + L"\\" + szProjName;
}

void qPathMgr::render()
{
	TextOut(DC, 10, 10, m_Solution.c_str(), (int)m_Solution.length());
	TextOut(DC, 10, 30, m_Proj.c_str(), (int)m_Proj.length());
	TextOut(DC, 10, 50, m_Content.c_str(), (int)m_Content.length());
}

void qPathMgr::GetParentPath(_Inout_ wchar_t* _Buffer)
{
	size_t len = wcslen(_Buffer);

	for (size_t i = len - 1; 0 < i; --i)
	{
		if (L'\\' == _Buffer[i])
		{
			_Buffer[i] = L'\0';
			break;
		}
	}
}

```

`GameClient/qPathMgr.h`:

```h
#pragma once
class qPathMgr
{
	SINGLE(qPathMgr);
private:
	wstring		m_Content;
	wstring		m_Solution;
	wstring		m_Proj;

public:
	void init();
	void render();

private:
	void GetParentPath(_Inout_ wchar_t* _Buffer);

public:
	const wstring& GetContentPath() { return m_Content; }
	const wstring& GetSolutionPath() { return m_Solution; }
	const wstring& GetProjPath() { return m_Proj; }
};


```

`GameClient/qPlatform.cpp`:

```cpp
#include "pch.h"
#include "qPlatform.h"

#include "qCollider.h"
#include "qRigidbody.h"
#include "qPlayer.h"

#include "qLevelMgr.h"
#include "qLevel.h"

qPlatform::qPlatform()
	: m_Collider(nullptr)
{
	//SetScale(Vec2(500.f, 100.f));
	//m_Collider = (qCollider*)AddComponent(new qCollider);
	//m_Collider->SetScale(GetScale());
}

qPlatform::qPlatform(Vec2 _Pos, Vec2 _Scale)
	: m_Collider(nullptr)
{
	SetPos(_Pos);
	SetScale(_Scale);
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(GetScale());
}

qPlatform::~qPlatform()
{
}

void qPlatform::tick()
{
	qObj::tick();
	
	//wchar_t szBuff[256] = {};
	//static float AccTime = 0.f;
	//AccTime += DT;
	//swprintf_s(szBuff, L"x : %f, y : %f", m_Collider->GetFinalPos().x, m_Collider->GetFinalPos().y);

	//if (AccTime >= 1.f)
	//{
	//	LOG(LOG_TYPE::DBG_ERROR, szBuff);
	//	AccTime = 0.f;
	//}
}

void qPlatform::render()
{
	qObj::render();
	//if (L"Test" == GetName())
	//{
	//	USE_PEN(DC, PEN_TYPE::PEN_GREEN);
	//	USE_BRUSH(DC, BRUSH_TYPE::BRUSH_HOLLOW);
	//
	//	Vec2 vPos = qCamera::GetInst()->GetRenderPos(GetPos());
	//	Vec2 vScale = qCamera::GetInst()->GetRealPos(GetScale());
	//
	//	Rectangle(DC, (int)vPos.x, (int)vPos.y, (int)vScale.x, (int)vScale.y);
	//}
	//else
	//{
	//	return;
	//}
}

void qPlatform::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player" || _OtherObj->GetName() == L"Blue" || _OtherObj->GetName() == L"Red" 
		|| _OtherObj->GetName() == L"Blue1" || _OtherObj->GetName() == L"Boss")
	{
		qRigidbody* pRB = _OtherObj->GetComponent<qRigidbody>();
		if (GetPrevPos().y + (GetScale().y * 0.5) <= _OtherObj->GetPos().y)
		{
			pRB->SetGround(true);
		}
 	}
}

void qPlatform::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	// 포탈 클래스 만들기

	//if (_OtherObj->GetName() == L"Player")
	//{
 	//	dynamic_cast<qPlayer*>(_OtherObj)->SetPortal(true);
	//}

}

void qPlatform::EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player")
	{
		qRigidbody* pRB = _OtherObj->GetComponent<qRigidbody>();
		pRB->SetGround(false);
	}	
}
```

`GameClient/qPlatform.h`:

```h
#pragma once
#include "qObj.h"


class qPlatform : public qObj
{
	CLONE(qPlatform)

public:
	qPlatform();
	qPlatform(Vec2 _Pos, Vec2 _Scale);
	~qPlatform();

	virtual void tick();
	virtual void render();

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qCollider*		m_Collider;
};


```

`GameClient/qPlayer.cpp`:

```cpp
#include "pch.h"
#include "qPlayer.h"

#include "qLevelMgr.h"
#include "qLevel.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qAnimation.h"
#include "qDbgRender.h"
#include "qRigidbody.h"

#include "qRope.h"

#include "qFSM.h"

#include "qMissile.h"
#include "qGuideMissile.h"

#include "qSkill_attack_left.h"
#include "qSkill_attack_right.h"
#include "qSkill_missile_left.h"
#include "qSkill_missile_right.h"
#include "qSkill_missile_ball_left.h"
#include "qSkill_missile_ball_right.h"
#include "qSkill_slash_left.h"
#include "qSkill_slash_right.h"
#include "qSkill_special_left.h"
#include "qSkill_special_right.h"
#include "qSkill_buff.h"
#include "qSkill_doublejump_left.h"
#include "qSkill_doublejump_right.h"
#include "qSkill_highjump.h"

#include "qBossSkill_ball_left.h"

#include "qDamage_miss.h"

#include "qDbgRender.h"
#include "qCamera.h"

#include "qBossIdleState.h"
#include "qBossBallState.h"
#include "qBossGenesisState.h"
#include "qBossFirebirdState.h"
#include "qBossTornadoState.h"
#include "qBossDeadState.h"


void BeGround()
{
	LOG(LOG_TYPE::DBG_WARNING, L"Grounded!!!");
	LOG(LOG_TYPE::DBG_WARNING, L"Grounded!!!");
}

void BeAir()
{
	LOG(LOG_TYPE::DBG_WARNING, L"Air!!!");
	LOG(LOG_TYPE::DBG_WARNING, L"Air!!!");
}


qPlayer::qPlayer()
	: m_State(PLAYER_STATE::IDLE)
	, m_Speed(150.f)
	, m_SlashSpeed(900.f)
	, m_SlashMaxRange(0.f)
	, m_Slash(true)
	, m_Hud(100.f)
	, m_Level(LEVEL_TYPE::END)
	, m_PlayerImg(nullptr)
	, m_DoubleJumpCount(2)
	, m_CurJumpCount(0)
	, m_bRope(false)
{

	m_Pos = GetPos();

	// Player의 컴포넌트 설정
	
	m_BodyCol = (qCollider*)AddComponent(new qCollider);
	m_Animator = (qAnimator*)AddComponent(new qAnimator);
	m_RigidBody = (qRigidbody*)AddComponent(new qRigidbody);


	m_BodyCol->SetName(L"Body Collider");
	m_BodyCol->SetOffsetPos(Vec2(0.f, 0.f));
	m_BodyCol->SetScale(Vec2(70.f, 70.f));
	m_BodyCol->SetActive(true);

	
	//// Animation 추가
	////IDLE
	//qTexture* pIdleLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerIdleLeft", L"texture\\character\\player\\idle\\idle_left.png");
	//qTexture* pIdleRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerIdleRight", L"texture\\character\\player\\idle\\idle_right.png");

	//// MOVE
	//qTexture* pMoveLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerMoveLeft", L"texture\\character\\player\\move\\move_left.png");
	//qTexture* pMoveRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerMoveRight", L"texture\\character\\player\\move\\move_right.png");

	//// DOWN
	//qTexture* pDownLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerDownLeft", L"texture\\character\\player\\down\\down_left.png");
	//qTexture* pDownRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerDownRight", L"texture\\character\\player\\down\\down_right.png");

	//// DOWN ATTACK
	//qTexture* pDownAttackLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerDownAttackLeft", L"texture\\character\\player\\down_attack\\down_attack_left.png");
	//qTexture* pDownAttackRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerDownAttackRight", L"texture\\character\\player\\down_attack\\down_attack_right.png");

	//// JUMP
	//qTexture* pJumpLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerJumpLeft", L"texture\\character\\player\\jump\\jump_left.png");
	//qTexture* pJumpRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerJumpRight", L"texture\\character\\player\\jump\\jump_right.png");

	//// ROPE
	//qTexture* pRope = qAssetMgr::GetInst()->LoadTexture(L"PlayerRope", L"texture\\character\\player\\rope\\rope.png");

	//// ATTACK
	//qTexture* pAttackLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerAttackLeft", L"texture\\character\\player\\attack\\attack_left.png");
	//qTexture* pAttackRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerAttackRight", L"texture\\character\\player\\attack\\attack_right.png");
	//
	//// MISSILE
	//qTexture* pMissileLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerMissileLeft", L"texture\\character\\player\\missile\\missile_left.png");
	//qTexture* pMissileRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerMissileRight", L"texture\\character\\player\\missile\\missile_right.png");

	//// SLASH
	//qTexture* pSlashLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerSlashLeft", L"texture\\character\\player\\slash\\slash_left.png");
	//qTexture* pSlashRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerSlashRight", L"texture\\character\\player\\slash\\slash_right.png");

	//// SPECIAL
	//qTexture* pSpecialLeft = qAssetMgr::GetInst()->LoadTexture(L"PlayerSpecialLeft", L"texture\\character\\player\\special\\special_left.png");
	//qTexture* pSpecialRight = qAssetMgr::GetInst()->LoadTexture(L"PlayerSpecialRight", L"texture\\character\\player\\special\\special_right.png");


	////애니메이션 CREATE
	////IDLE
	//m_Animator->CreateAnimation(L"PlayerIdleLeft", pIdleLeft, Vec2(0.f, 0.f), Vec2(114.f, 78.f), 3, 3);
	//m_Animator->CreateAnimation(L"PlayerIdleRight", pIdleRight, Vec2(0.f, 0.f), Vec2(114.f, 78.f), 3, 3);

	//// MOVE
	//m_Animator->CreateAnimation(L"PlayerMoveLeft", pMoveLeft, Vec2(0.f, 0.f), Vec2(110.f, 84.f), 4, 3);
	//m_Animator->CreateAnimation(L"PlayerMoveRight", pMoveRight, Vec2(0.f, 0.f), Vec2(110.f, 84.f), 4, 3);

	//// DOWN
	//m_Animator->CreateAnimation(L"PlayerDownLeft", pDownLeft, Vec2(0.f, 0.f), Vec2(132.f, 67.f), 1, 3);
	//m_Animator->CreateAnimation(L"PlayerDownRight", pDownRight, Vec2(0.f, 0.f), Vec2(132.f, 67.f), 1, 3);

	//// DOWN ATTACK
	//m_Animator->CreateAnimation(L"PlayerDownAttackLeft", pDownAttackLeft, Vec2(0.f, 0.f), Vec2(132.f, 67.f), 3, 3);
	//m_Animator->CreateAnimation(L"PlayerDownAttackRight", pDownAttackRight, Vec2(0.f, 0.f), Vec2(132.f, 67.f), 3, 3);

	//// JUMP
	//m_Animator->CreateAnimation(L"PlayerJumpLeft", pJumpLeft, Vec2(0.f, 0.f), Vec2(60.f, 100.f), 1, 3);
	//m_Animator->CreateAnimation(L"PlayerJumpRight", pJumpRight, Vec2(0.f, 0.f), Vec2(60.f, 100.f), 1, 3);

	//// ROPE
	//m_Animator->CreateAnimation(L"PlayerRope", pRope, Vec2(0.f, 0.f), Vec2(72.f, 81.f), 1, 3);

	//// ATTACK
	//m_Animator->CreateAnimation(L"PlayerAttackLeft", pAttackLeft, Vec2(0.f, 0.f), Vec2(223.f, 149.f), 3, 6);
	//m_Animator->CreateAnimation(L"PlayerAttackRight", pAttackRight, Vec2(0.f, 0.f), Vec2(223.f, 149.f), 3, 6);

	//// MISSILE
	//m_Animator->CreateAnimation(L"PlayerMissileLeft", pMissileLeft, Vec2(0.f, 0.f), Vec2(227.f, 140.f), 3, 8);
	//m_Animator->CreateAnimation(L"PlayerMissileRight", pMissileRight, Vec2(0.f, 0.f), Vec2(227.f, 140.f), 3, 8);

	//// SLASH
	//m_Animator->CreateAnimation(L"PlayerSlashLeft", pSlashLeft, Vec2(0.f, 0.f), Vec2(182.f, 78.f), 2, 5);
	//m_Animator->CreateAnimation(L"PlayerSlashRight", pSlashRight, Vec2(0.f, 0.f), Vec2(182.f, 78.f), 2, 5);

	//// SPECIAL
	//m_Animator->CreateAnimation(L"PlayerSpecialLeft", pSpecialLeft, Vec2(0.f, 0.f), Vec2(188.f, 148.f), 3, 6);
	//m_Animator->CreateAnimation(L"PlayerSpecialRight", pSpecialRight, Vec2(0.f, 0.f), Vec2(188.f, 148.f), 3, 6);



	//// 애니메이션 SAVE
	//// IDLE
	//m_Animator->FindAnimation(L"PlayerIdleLeft")->Save(L"animation\\player\\idle\\");
	//m_Animator->FindAnimation(L"PlayerIdleRight")->Save(L"animation\\player\\idle\\");

	//// MOVE
	//m_Animator->FindAnimation(L"PlayerMoveLeft")->Save(L"animation\\player\\move\\");
	//m_Animator->FindAnimation(L"PlayerMoveRight")->Save(L"animation\\player\\move\\");

	//// DOWN
	//m_Animator->FindAnimation(L"PlayerDownLeft")->Save(L"animation\\player\\down\\");
	//m_Animator->FindAnimation(L"PlayerDownRight")->Save(L"animation\\player\\down\\");

	//// DOWN_ATTACK
	//m_Animator->FindAnimation(L"PlayerDownAttackLeft")->Save(L"animation\\player\\down_attack\\");
	//m_Animator->FindAnimation(L"PlayerDownAttackRight")->Save(L"animation\\player\\down_attack\\");

	//// JUMP
	//m_Animator->FindAnimation(L"PlayerJumpLeft")->Save(L"animation\\player\\jump\\");
	//m_Animator->FindAnimation(L"PlayerJumpRight")->Save(L"animation\\player\\jump\\");

	//// ROPE
	//m_Animator->FindAnimation(L"PlayerRope")->Save(L"animation\\player\\rope\\");

	//// ATTACK
	//m_Animator->FindAnimation(L"PlayerAttackLeft")->Save(L"animation\\player\\attack\\");
	//m_Animator->FindAnimation(L"PlayerAttackRight")->Save(L"animation\\player\\attack\\");

	//// MISSILE
	//m_Animator->FindAnimation(L"PlayerMissileLeft")->Save(L"animation\\player\\missile\\");
	//m_Animator->FindAnimation(L"PlayerMissileRight")->Save(L"animation\\player\\missile\\");

	//// SLASH
	//m_Animator->FindAnimation(L"PlayerSlashLeft")->Save(L"animation\\player\\slash\\");
	//m_Animator->FindAnimation(L"PlayerSlashRight")->Save(L"animation\\player\\slash\\");

	//// SPECIAL
	//m_Animator->FindAnimation(L"PlayerSpecialLeft")->Save(L"animation\\player\\special\\");
	//m_Animator->FindAnimation(L"PlayerSpecialRight")->Save(L"animation\\player\\special\\");



	// Load Animation

	m_Animator->LoadAnimation(L"animation\\player\\idle\\PlayerIdleLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\idle\\PlayerIdleRight.anim");


	m_Animator->LoadAnimation(L"animation\\player\\move\\PlayerMoveLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\move\\PlayerMoveRight.anim");


	m_Animator->LoadAnimation(L"animation\\player\\down\\PlayerDownLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\down\\PlayerDownRight.anim");


	m_Animator->LoadAnimation(L"animation\\player\\down_attack\\PlayerDownAttackLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\down_attack\\PlayerDownAttackRight.anim");

	m_Animator->LoadAnimation(L"animation\\player\\jump\\PlayerJumpLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\jump\\PlayerJumpRight.anim");

	m_Animator->LoadAnimation(L"animation\\player\\rope\\PlayerRope.anim");

	m_Animator->LoadAnimation(L"animation\\player\\attack\\PlayerAttackLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\attack\\PlayerAttackRight.anim");

	m_Animator->LoadAnimation(L"animation\\player\\missile\\PlayerMissileLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\missile\\PlayerMissileRight.anim");

	m_Animator->LoadAnimation(L"animation\\player\\slash\\PlayerSlashLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\slash\\PlayerSlashRight.anim");

	m_Animator->LoadAnimation(L"animation\\player\\special\\PlayerSpecialLeft.anim");
	m_Animator->LoadAnimation(L"animation\\player\\special\\PlayerSpecialRight.anim");


	// 강체 설정
	m_RigidBody->SetMass(1.f);
	m_RigidBody->SetMaxWalkSpeed(300.f);
	m_RigidBody->SetFriction(2000.f);

	// 중력 관련 설정
	m_RigidBody->UseGravity(true);
	m_RigidBody->SetMaxGravitySpeed(1500.f);
	m_RigidBody->SetJumpSpeed(400.f);

	// CallBack 설정
	m_RigidBody->SetGroundFunc(&BeGround);
	m_RigidBody->SetAirFunc(&BeAir);

	// Delegate
	m_RigidBody->SetGroundDelegate(this, (DELEGATE)&qPlayer::RestoreJumpCount);
	m_RigidBody->SetGround(true);

	// 카메라
	qCamera::GetInst()->SetOwner(this);

	// FSM
	//m_FSM = (qFSM*)AddComponent(new qFSM);
	//m_FSM->AddState(L"IDLE", new qPlayerState);



	m_Animator->Play(L"PlayerIdleLeft", true);

}

qPlayer::qPlayer(const qPlayer& _Other)
	: qObj(_Other)
	, m_Speed(_Other.m_Speed)
	, m_PlayerImg(_Other.m_PlayerImg)
	, m_BodyCol(nullptr)
	, m_Animator(nullptr)
	, m_RigidBody(nullptr)
	, m_DoubleJumpCount(_Other.m_DoubleJumpCount)
	, m_CurJumpCount(_Other.m_CurJumpCount)
{
	m_BodyCol = GetComponent<qCollider>();
	m_Animator = GetComponent<qAnimator>();
	m_RigidBody = GetComponent<qRigidbody>();

	m_RigidBody->SetGroundDelegate(this, (DELEGATE)&qPlayer::RestoreJumpCount);
}

qPlayer::~qPlayer()
{
	
}


void qPlayer::begin()
{
	qObj::begin();
	// CallBack 설정
	m_RigidBody->SetGroundFunc(&BeGround);
	m_RigidBody->SetAirFunc(&BeAir);


	// 플레이어 방향 설정
	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();

	if (pCurLevel->GetName() == L"Stage1")
	{
		SetDir(DIRECTION::LEFT);
		m_Animator->Play(L"PlayerIdleLeft", true);
	}
	else if (pCurLevel->GetName() == L"Stage2")
	{
		SetDir(DIRECTION::LEFT);
		m_Animator->Play(L"PlayerIdleLeft", true);
	}
	else if (pCurLevel->GetName() == L"Boss1")
	{
		SetDir(DIRECTION::RIGHT);
		m_Animator->Play(L"PlayerIdleRight", true);
	}
	else if (pCurLevel->GetName() == L"Boss2")
	{
		SetDir(DIRECTION::RIGHT); 
		m_Animator->Play(L"PlayerIdleRight", true);
	}


	// Delegate
	//m_RigidBody->SetGroundDelegate(this, (DELEGATE)&qPlayer::RestoreJumpCount);


	// 블랙보드
	//m_FSM->SetBlackboardData(L"Player", DATA_TYPE::OBJECT, this);

	// 블랙보드로 넘겨주기
	//m_FSM->SetBlackboardData(L"pHud", DATA_TYPE::FLOAT, &m_Hud);
	//m_FSM->SetBlackboardData(L"pSpeed", DATA_TYPE::FLOAT, &m_Speed);
	//m_FSM->SetBlackboardData(L"pPlayer", DATA_TYPE::OBJECT, this);

	//m_FSM->ChangeState(L"IDLE");

}

void qPlayer::tick()
{

	qObj::tick();

	GetExp();

	GetPlayerHP();

	GetPhysicalCount();
	GetMagicCount();

	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();

	m_Pos = GetPos();

	wchar_t szBuff[256] = {};
	static float Time = 0.f;

	Time += DT;
	if (Time >= 1.f)
	{
		swprintf_s(szBuff, L"%f, %f", m_Pos.x, m_Pos.y);
		LOG(LOG_TYPE::DBG_WARNING, szBuff);
		Time = 0.f;
	}


	// ======
	//  ROPE
	// ======
	qRope* pRope = (qRope*)pCurLevel->FindObjectByName(L"Rope");

	if (m_bRope)
	{
		if (KEY_PRESSED(KEY::UP))
		{
			SetPos(m_Rope->GetPos().x, m_Pos.y);
			m_RigidBody->SetRope(true);
			m_Animator->Play(L"PlayerRope", true);
			m_Pos += Vec2(0.f, -1.f) * 200.f * DT;
			SetPos(m_Rope->GetPos().x, m_Pos.y);
			return;
		}
		if (KEY_PRESSED(KEY::DOWN))
		{
			SetPos(m_Rope->GetPos().x, m_Pos.y);
			m_RigidBody->SetRope(true);
			m_Animator->Play(L"PlayerRope", true);
			m_Pos += Vec2(0.f, 1.f) * 200.f * DT;
			SetPos(m_Rope->GetPos().x, m_Pos.y);
			return;
		}
	}
	else
	{

	}

	
	
	

	// ======
	//  MOVE
	// ======
	

	if (KEY_PRESSED(KEY::LEFT) && m_RigidBody->IsGround() 
		&& PLAYER_STATE::ATTACK != m_State && PLAYER_STATE::MISSILE != m_State && PLAYER_STATE::SLASH != m_State
		&& PLAYER_STATE::SPECIAL != m_State)
	{
		m_State = PLAYER_STATE::MOVE;
		SetDir(DIRECTION::LEFT);
		m_Pos += Vec2(-1.f, 0.f) * m_Speed * DT;
		//m_RigidBody->AddForce(Vec2(-1000.f, 0.f));
	}
	else if (KEY_TAP(KEY::LEFT) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::MOVE;
		SetDir(DIRECTION::LEFT);
		m_Animator->Play(L"PlayerMoveLeft", true);
	}
	else if (KEY_RELEASED(KEY::LEFT) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::IDLE;
		SetDir(DIRECTION::LEFT);
		m_Slash = true;
		m_Animator->Play(L"PlayerIdleLeft", true);
	}


	if (KEY_PRESSED(KEY::RIGHT) && m_RigidBody->IsGround()
		&& PLAYER_STATE::ATTACK != m_State && PLAYER_STATE::MISSILE != m_State && PLAYER_STATE::SLASH != m_State
		&& PLAYER_STATE::SPECIAL != m_State)
	{
		m_State = PLAYER_STATE::MOVE;
		SetDir(DIRECTION::RIGHT);
		m_Pos += Vec2(1.f, 0.f) * m_Speed * DT;
		//m_RigidBody->AddForce(Vec2(1000.f, 0.f));
	}
	else if (KEY_TAP(KEY::RIGHT) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::MOVE;
		SetDir(DIRECTION::RIGHT);
		m_Animator->Play(L"PlayerMoveRight", true);
	}
	else if (KEY_RELEASED(KEY::RIGHT) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::IDLE;
		SetDir(DIRECTION::RIGHT);
		m_Slash = true;
		m_Animator->Play(L"PlayerIdleRight", true);
	}

	// ======
	//  DOWN
	// ======

	if (KEY_TAP(KEY::DOWN) && m_RigidBody->IsGround() && PLAYER_STATE::IDLE == GetState())
	{
		if (GetDir() == DIRECTION::LEFT)
		{
			m_State = PLAYER_STATE::DOWN;
			m_Animator->Play(L"PlayerDownLeft", true);

		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_State = PLAYER_STATE::DOWN;
			m_Animator->Play(L"PlayerDownRight", true);
		}
	}

	// =============
	//  DOWN ATTACK
	// =============


	else if (KEY_PRESSED(KEY::DOWN))
	{
		if (KEY_TAP(KEY::CTRL))
		{
			m_State = PLAYER_STATE::DOWN_ATTACK;
			
			if (GetDir() == DIRECTION::LEFT)
			{
				m_Animator->Play(L"PlayerDownAttackLeft", false);
			}
			else if (GetDir() == DIRECTION::RIGHT)
			{
				m_Animator->Play(L"PlayerDownAttackRight", false);
			}
		}
	}


	else if (KEY_RELEASED(KEY::DOWN) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::IDLE;
		m_Slash = true;

		if (GetDir() == DIRECTION::LEFT)
		{
			m_Animator->Play(L"PlayerIdleLeft", true);
		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_Animator->Play(L"PlayerIdleRight", true);
		}
	}

	// =======================
	//    솔라슬래시 / ATTACK
	// =======================

	if (KEY_TAP(KEY::A) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::ATTACK;

		if (GetDir() == DIRECTION::LEFT)
		{
			m_Animator->Play(L"PlayerAttackLeft", false);
			
			// 솔라 슬래시 스킬 이펙트

			qSkill_attack_left* pAttackLeft = new qSkill_attack_left;
			pAttackLeft->SetName(L"AttackLeft");
			

			Vec2 vAttackLeftPos = GetPos() + Vec2(-100.f, 0.f);
			Vec2 vAttackLeftScale = Vec2(410.f, 240.f);

			pAttackLeft->SetPos(vAttackLeftPos);
			pAttackLeft->SetScale(vAttackLeftScale);

			if (L"AttackLeft" == pAttackLeft->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pAttackLeft);
			}


		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_Animator->Play(L"PlayerAttackRight", false);

			// 솔라 슬래시 스킬 이펙트

			qSkill_attack_right* pAttackRight = new qSkill_attack_right;
			pAttackRight->SetName(L"AttackRight");
			
			Vec2 vAttackRightPos = GetPos() + Vec2(100.f, 0.f);
			Vec2 vAttackRightScale = Vec2(410.f, 240.f);

			pAttackRight->SetPos(vAttackRightPos);
			pAttackRight->SetScale(vAttackRightScale);

			if (L"AttackRight" == pAttackRight->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pAttackRight);
			}
		}
	}

	if (L"PlayerAttackLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleLeft", true);
		}
	}
	else if (L"PlayerAttackRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleRight", true);
		}
	}

	// ============================
	//    루나 디바이드 / MISSILE
	// ============================

	if (KEY_TAP(KEY::S) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::MISSILE;

		if (GetDir() == DIRECTION::LEFT)
		{
			m_Animator->Play(L"PlayerMissileLeft", false);


			// 루나 디바이드 스킬 이펙트
			qSkill_missile_left* pMissileLeft = new qSkill_missile_left;
			pMissileLeft->SetName(L"MissileLeft");
			

			Vec2 vMissileLeftPos = GetPos() + Vec2(-50.f, 0.f);
			Vec2 vMissileLeftScale = Vec2(240.f, 195.f);

			pMissileLeft->SetPos(vMissileLeftPos);
			pMissileLeft->SetScale(vMissileLeftScale);

			if (L"MissileLeft" == pMissileLeft->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pMissileLeft);
			}

			// 루나 디바이드 미사일
			qSkill_missile_ball_left* pBallLeft = new qSkill_missile_ball_left;
			pBallLeft->SetName(L"BallLeft");
			

			Vec2 vBallLeftPos = GetPos() + Vec2(-50.f, 0.f);
			Vec2 vBallLeftScale = Vec2(100.f, 70.f);

			pBallLeft->SetPos(vBallLeftPos);
			pBallLeft->SetScale(vBallLeftScale);

			if (L"BallLeft" == pBallLeft->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pBallLeft);
			}

		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_Animator->Play(L"PlayerMissileRight", false);

			// 루나 디바이드 스킬 이펙트
			qSkill_missile_right* pMissileRight = new qSkill_missile_right;
			pMissileRight->SetName(L"MissileRight");
			

			Vec2 vMissileRightPos = GetPos() + Vec2(50.f, 0.f);
			Vec2 vMissileRightScale = Vec2(240.f, 195.f);

			pMissileRight->SetPos(vMissileRightPos);
			pMissileRight->SetScale(vMissileRightScale);

			if (L"MissileRight" == pMissileRight->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pMissileRight);
			}


			// 루나 디바이드 미사일
			qSkill_missile_ball_right* pBallRight = new qSkill_missile_ball_right;
			pBallRight->SetName(L"BallRight");
			

			Vec2 vBallRightPos = GetPos() + Vec2(50.f, 0.f);
			Vec2 vBallRightScale = Vec2(100.f, 70.f);

			pBallRight->SetPos(vBallRightPos);
			pBallRight->SetScale(vBallRightScale);

			if (L"BallRight" == pBallRight->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pBallRight);
			}
		}
	}

	if (L"PlayerMissileLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleLeft", true);
		}
	}
	else if (L"PlayerMissileRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleRight", true);
		}
	}

	// =========================
	//     라우드러시 / SLASH
	// =========================

	if (m_Slash)
	{
		if (KEY_TAP(KEY::D) && m_RigidBody->IsGround())
		{
			if (DIRECTION::LEFT == GetDir())
			{
				m_CenterPos = GetPos();

				// 라우드 러쉬 스킬 이펙트
				qSkill_slash_left* pSlashLeft = new qSkill_slash_left;
				pSlashLeft->SetName(L"SlashLeft");
				

				Vec2 vSlashLeftPos = GetPos();
				Vec2 vSlashLeftScale = Vec2(675.f, 215.f);

				pSlashLeft->SetOwner(this);
				pSlashLeft->SetPos(vSlashLeftPos);
				pSlashLeft->SetScale(vSlashLeftScale);

				if (L"SlashLeft" == pSlashLeft->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pSlashLeft);
				}
			}
			else if (DIRECTION::RIGHT == GetDir())
			{
				m_CenterPos = GetPos();

				// 라우드 러쉬 스킬 이펙트
				qSkill_slash_right* pSlashRight = new qSkill_slash_right;
				pSlashRight->SetName(L"SlashRight");
				

				Vec2 vSlashRightPos = GetPos();
				Vec2 vSlashRightScale = Vec2(675.f, 215.f);

				pSlashRight->SetOwner(this);
				pSlashRight->SetPos(vSlashRightPos);
				pSlashRight->SetScale(vSlashRightScale);

				if (L"SlashRight" == pSlashRight->GetName())
				{
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pSlashRight);
				}
			}
		}

		if (KEY_PRESSED(KEY::D) && m_RigidBody->IsGround())
		{
			SetState(PLAYER_STATE::SLASH);

			if (GetDir() == DIRECTION::LEFT)
			{	
				m_SlashMaxRange += m_SlashSpeed * DT;
				m_Pos += Vec2(-1.f, 0.f) * m_SlashSpeed * DT;

				m_Animator->Play(L"PlayerSlashLeft", false);
			}
			else if (GetDir() == DIRECTION::RIGHT)
			{
				m_SlashMaxRange += m_SlashSpeed * DT;
				m_Pos += Vec2(1.f, 0.f) * m_SlashSpeed * DT;


				m_Animator->Play(L"PlayerSlashRight", false);

			}
		}

		if (350.f < m_SlashMaxRange)
		{
			m_SlashMaxRange = 0.f;
			m_Slash = false;
		}
	}


	if (L"PlayerSlashLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleLeft", true);
		}
	}
	else if (L"PlayerSlashRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleRight", true);
		}
	}


	// ==============================
	//    크로스 더 스틱스 / SPECIAL
	// ==============================



	if (KEY_TAP(KEY::F) && m_RigidBody->IsGround())
	{
		m_State = PLAYER_STATE::SPECIAL;

		if (GetDir() == DIRECTION::LEFT)
		{
			m_Animator->Play(L"PlayerSpecialLeft", false);

			// 크로스 더 스틱스 스킬 이펙트

			qSkill_special_left* pSpecialLeft = new qSkill_special_left;
			pSpecialLeft->SetName(L"SpecialLeft");
			

			Vec2 vSpecialLeftPos = GetPos() + Vec2(-100.f, -130.f);
			Vec2 vSpecialLeftScale = Vec2(500.f, 400.f);

			pSpecialLeft->SetPos(vSpecialLeftPos);
			pSpecialLeft->SetScale(vSpecialLeftScale);

			if (L"SpecialLeft" == pSpecialLeft->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pSpecialLeft);
			}

		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_Animator->Play(L"PlayerSpecialRight", false);

			// 크로스 더 스틱스 스킬 이펙트

			qSkill_special_right* pSpecialRight = new qSkill_special_right;
			pSpecialRight->SetName(L"SpecialRight");
			

			Vec2 vSpecialRightPos = GetPos() + Vec2(100.f, -130.f);
			Vec2 vSpecialRightScale = Vec2(500.f, 400.f);

			pSpecialRight->SetPos(vSpecialRightPos);
			pSpecialRight->SetScale(vSpecialRightScale);

			if (L"SpecialRight" == pSpecialRight->GetName())
			{
				SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pSpecialRight);
			}
		}
	}

	if (L"PlayerSpecialLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleLeft", true);
		}
	}
	else if (L"PlayerSpecialRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			m_State = PLAYER_STATE::IDLE;
			m_Slash = true;
			m_Animator->Play(L"PlayerIdleRight", true);
		}
	}

	// ======================
	//     트루사이트 / BUFF
	// ======================

	if (KEY_TAP(KEY::G) && m_RigidBody->IsGround())
	{
		// 트루 사이트 스킬 이펙트
		qSkill_buff* pBuff = new qSkill_buff;
		pBuff->SetName(L"Buff");

		Vec2 vBuffPos = GetPos() + Vec2(0.f, -100.f);
		Vec2 vBuffScale = Vec2(400.f, 400.f);

		pBuff->SetPos(vBuffPos);
		pBuff->SetScale(vBuffScale);

		
		if (L"Buff" == pBuff->GetName())
		{
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pBuff);
		}
	}

	//SPACE 누르면 점프!

	if (L"PlayerJumpLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_RigidBody->IsGround())
		{
			if (KEY_PRESSED(KEY::LEFT))
			{
				m_State = PLAYER_STATE::MOVE;
				m_Slash = true;
				m_Animator->Play(L"PlayerMoveLeft", true);
			}
			else
			{
				m_State = PLAYER_STATE::IDLE;
				m_Slash = true;
				m_Animator->Play(L"PlayerIdleLeft", true);
			}
		}
		else
		{
			if (KEY_PRESSED(KEY::LEFT))
			{
				m_Pos += Vec2(-1.f, 0.f) * m_Speed * DT;
			}

			if (KEY_PRESSED(KEY::LEFT) && KEY_TAP(KEY::SPACE))
			{
				if (m_DoubleJumpCount > m_CurJumpCount)
				{
					DoubleJump();
					m_CurJumpCount += 1;
				}
			}
		}

	}
	else if (L"PlayerJumpRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_RigidBody->IsGround())
		{
			if (KEY_PRESSED(KEY::RIGHT))
			{
				m_State = PLAYER_STATE::MOVE;
				m_Animator->Play(L"PlayerMoveRight", true);
			}
			else
			{
				m_State = PLAYER_STATE::IDLE;
				m_Slash = true;
				m_Animator->Play(L"PlayerIdleRight", true);
			}
		}
		else
		{
			if (KEY_PRESSED(KEY::RIGHT))
			{
				m_Pos += Vec2(1.f, 0.f) * m_Speed * DT;
			}

			if (KEY_PRESSED(KEY::RIGHT) && KEY_TAP(KEY::SPACE))
			{
				if (m_DoubleJumpCount > m_CurJumpCount)
				{
					DoubleJump();
					m_CurJumpCount += 1;
				}

			}
			
		}
	}

	if (KEY_TAP(KEY::SPACE))
	{
		//Shoot();

		if (m_DoubleJumpCount > m_CurJumpCount)
		{
			Jump();

			if (m_CurJumpCount == 1)
			{
				qSkill_highjump* pHighJump = new qSkill_highjump;
				pHighJump->SetName(L"Highjump");

				Vec2 vHighJumpPos = GetPos() + Vec2(0.f, 50.f);
				Vec2 vHighJumpScale = Vec2(185.f, 255.f);

				pHighJump->SetPos(vHighJumpPos);
				pHighJump->SetScale(vHighJumpScale);

				if (L"Highjump" == pHighJump->GetName())
				{
					// TASK
					SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pHighJump);
				}
			}

			m_CurJumpCount += 1;
		}

		if (GetDir() == DIRECTION::LEFT)
		{
			m_Animator->Play(L"PlayerJumpLeft", true);

		}
		else if (GetDir() == DIRECTION::RIGHT)
		{
			m_Animator->Play(L"PlayerJumpRight", true);
		}

	}

	SetPos(m_Pos);

	
	if (m_Portal)
	{
		if (pCurLevel->GetName() == L"Stage1")
		{
			if (KEY_TAP(KEY::UP))
			{
				ChangeLevel(LEVEL_TYPE::STAGE_02);
			}
		}
		if (pCurLevel->GetName() == L"Stage2")
		{
			if (KEY_TAP(KEY::UP))
			{
				ChangeLevel(LEVEL_TYPE::BOSS_01);
			}
		}
		if (pCurLevel->GetName() == L"Boss1")
		{
			if (KEY_TAP(KEY::UP))
			{
				ChangeLevel(LEVEL_TYPE::BOSS_02);
			}
		}
	}

}





void qPlayer::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType()
		|| LAYER_TYPE::BOSS == _OtherObj->GetLayerType())
	{
		qDamage_miss* pDamageMiss = new qDamage_miss();
		pDamageMiss->SetName(L"DamageMiss");

		Vec2 vDamageMissPos = GetPos() + Vec2(0.f, -50.f);
		Vec2 vDamageMissScale = Vec2(140.f, 60.f);

		pDamageMiss->SetPos(vDamageMissPos);
		pDamageMiss->SetScale(vDamageMissScale);

		if (L"DamageMiss" == pDamageMiss->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageMiss);
		}
	}

	if (L"BossSkillBallRight" == _OtherObj->GetName() || L"BossSkillBallLeft" == _OtherObj->GetName()
		|| L"BossSkillTornado" == _OtherObj->GetName())
	{
		SetPlayerHP(GetPlayerHP() - GetPhysicalDamage());

		PlusPhysicalCount();
	}

	if (L"BossSkillGenesis1" == _OtherObj->GetName() || L"BossSkillGenesis2" == _OtherObj->GetName()
		|| L"BossSkillGenesis3" == _OtherObj->GetName() || L"BossSkillGenesis4" == _OtherObj->GetName() || L"BossSkillFirebird" == _OtherObj->GetName())
	{
		SetPlayerHP(GetPlayerHP() - GetMagicDamage());

		PlusMagicCount();
	}



}


void qPlayer::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{

}


void qPlayer::EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	int a = 0;
}



//void qPlayer::Shoot()
//{
//	qMissile* pMissile = new qGuideMissile;
//	pMissile->SetName(L"Missile");
//
//	Vec2 vMissilePos = GetPos();
//	vMissilePos.y -= GetScale().y / 2.f;
//
//	pMissile->SetPos(vMissilePos);
//	pMissile->SetScale(Vec2(20.f, 20.f));
//
//	// TASK
//	SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_MISSILE, pMissile);
//
//	// LOG
//	LOG(LOG_TYPE::DBG_LOG, L"미사일 발사!");
//}

void qPlayer::Jump()
{
	m_RigidBody->jump();

	
}

void qPlayer::DoubleJump()
{
	m_RigidBody->doublejump();

	if (DIRECTION::LEFT == GetDir())
	{
		// 더블점프 스킬 이펙트
		qSkill_doublejump_left* pDoubleJumpLeft = new qSkill_doublejump_left;
		pDoubleJumpLeft->SetName(L"DoubleJumpLeft");

		Vec2 vDoubleJumpLeftPos = GetPos() + Vec2(30.f, 0.f);
		Vec2 vDoubleJumpLeftScale = Vec2(255.f, 185.f);

		pDoubleJumpLeft->SetPos(vDoubleJumpLeftPos);
		pDoubleJumpLeft->SetScale(vDoubleJumpLeftScale);
		
		if (L"DoubleJumpLeft" == pDoubleJumpLeft->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pDoubleJumpLeft);
		}
	}
	else if (DIRECTION::RIGHT == GetDir())
	{
		// 더블점프 스킬 이펙트
		qSkill_doublejump_right* pDoubleJumpRight = new qSkill_doublejump_right;
		pDoubleJumpRight->SetName(L"DoubleJumpRight");

		Vec2 vDoubleJumpRightPos = GetPos() + Vec2(-30.f, 0.f);
		Vec2 vDoubleJumpRightScale = Vec2(255.f, 185.f);

		pDoubleJumpRight->SetPos(vDoubleJumpRightPos);
		pDoubleJumpRight->SetScale(vDoubleJumpRightScale);

		if (L"DoubleJumpRight" == pDoubleJumpRight->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::PLAYER_SKILL, pDoubleJumpRight);
		}
	}
}






```

`GameClient/qPlayer.h`:

```h
#pragma once
#include "qObj.h"

class qCollider;
class qAnimator;
class qRigidbody;
class qFSM;
class qRope;

class qPlayer : public qObj
{
private:
	PLAYER_STATE	m_State;
	

	float			m_Speed;
	float			m_Hud;
	float			m_SlashSpeed;
	float			m_SlashMaxRange;
	bool			m_Slash;

	bool			m_Portal;		// 포탈
	bool			m_bRope;
	qRope*			m_Rope;

	LEVEL_TYPE		m_Level;

	Vec2			m_Pos;
	Vec2			m_CenterPos;

	qTexture*		m_PlayerImg;

	qCollider*		m_HeadCol;
	qCollider*		m_BodyCol;
	qAnimator*		m_Animator;
	qRigidbody*		m_RigidBody;
	qFSM*			m_FSM;

	int				m_DoubleJumpCount;
	int				m_CurJumpCount;

public:
	virtual void begin();
	virtual void tick();	


	//void Shoot();
	void Jump();
	void DoubleJump();
	void RestoreJumpCount()
	{
		m_CurJumpCount = 0;
	}


	void SetTargetRope(qRope* _Rope) { m_Rope = _Rope; }


	bool IsPortal() { return m_Portal; }
	void SetPortal(bool _Portal)
	{
		m_Portal = _Portal;
	}

	LEVEL_TYPE GetLevel() { return m_Level; }
	void SetLevel(LEVEL_TYPE _Level)
	{
		m_Level = _Level;
	}

	void SetRope(bool _Rope) { m_bRope = _Rope; }

	PLAYER_STATE GetState() { return m_State; }
	void SetState(PLAYER_STATE _State) { m_State = _State; }


	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;


public:
	CLONE(qPlayer);

public:
	qPlayer();
	qPlayer(const qPlayer& _Other);
	~qPlayer();

	friend class qRigidbody;
};


```

`GameClient/qPlayerHP.cpp`:

```cpp
#include "pch.h"
#include "qPlayerHP.h"

qPlayerHP::qPlayerHP()
{
	m_HPImg = qAssetMgr::GetInst()->LoadTexture(L"playerhp", L"texture\\ui\\menu\\playerhp.png");
}

qPlayerHP::~qPlayerHP()
{
}

void qPlayerHP::tick_ui()
{
	GetPlayerHP();

	GetOwner()->GetPhysicalCount();
	GetOwner()->GetMagicCount();
}

void qPlayerHP::render_ui()
{
	qUI::render_ui();

	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();

	StretchBlt(DC, (int)vPos.x, (int)vPos.y
		, m_HPImg->GetWidth() - (m_HPImg->GetWidth() * GetOwner()->GetPhysicalCount() * 0.0608f + m_HPImg->GetWidth() * GetOwner()->GetMagicCount() * 0.0768f), m_HPImg->GetHeight()
		, m_HPImg->GetDC()
		, 0, 0
		, m_HPImg->GetWidth(), m_HPImg->GetHeight(), SRCCOPY);
}

```

`GameClient/qPlayerHP.h`:

```h
#pragma once
#include "qUI.h"

class qTexture;

class qPlayerHP : public qUI
{
	CLONE(qPlayerHP);

public:

	qPlayerHP();
	~qPlayerHP();

public:
	virtual void tick_ui() override;
	virtual void render_ui() override;

	void SetImage(qTexture* _Tex) { m_HPImg = _Tex; }


private:
	qTexture* m_HPImg;
};


```

`GameClient/qPortal.cpp`:

```cpp
#include "pch.h"
#include "qPortal.h"

#include "qCollider.h"
#include "qPlayer.h"

#include "qLevelMgr.h"
#include "qLevel.h"

qPortal::qPortal()
	: m_Collider(nullptr)
{
}

qPortal::qPortal(Vec2 _Pos, Vec2 _Scale)
	: m_Collider(nullptr)
{
	SetPos(_Pos);
	SetScale(_Scale);
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(GetScale());
}

qPortal::~qPortal()
{
}

void qPortal::tick()
{
	qObj::tick();
}

void qPortal::render()
{
	qObj::render();
}

void qPortal::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{

}

void qPortal::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player")
	{
		dynamic_cast<qPlayer*>(_OtherObj)->SetPortal(true);
	}
}

void qPortal::EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player")
	{
		dynamic_cast<qPlayer*>(_OtherObj)->SetPortal(false);
	}
}

```

`GameClient/qPortal.h`:

```h
#pragma once
#include "qObj.h"

class qPortal : public qObj
{
	CLONE(qPortal);

public:
	qPortal();
	qPortal(Vec2 _Pos, Vec2 _Scale);
	~qPortal();

	virtual void tick();
	virtual void render();

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qCollider* m_Collider;
};


```

`GameClient/qRedDeadState.cpp`:

```cpp
#include "pch.h"
#include "qRedDeadState.h"

#include "qSound.h"

qRedDeadState::qRedDeadState()
{
}

qRedDeadState::~qRedDeadState()
{
}

void qRedDeadState::Enter()
{
	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\monster\\die.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

	init();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"RedDeadRight", false);
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"RedDeadLeft", false);
	}
}

void qRedDeadState::FinalTick()
{
	if (L"RedDeadLeft" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();
		}
	}



	if (L"RedDeadRight" == GetAnimator()->GetCurAnim()->GetName())
	{
		if (GetAnimator()->IsFinish())
		{
			GetObj()->Destroy();
		}
	}
}

void qRedDeadState::Exit()
{
	pSound->SetVolume(30.f);
	pSound->Stop();
}

```

`GameClient/qRedDeadState.h`:

```h
#pragma once
#include "qState.h"

class qSound;

class qRedDeadState : public qState
{
public:
	CLONE(qRedDeadState);

	qRedDeadState();
	~qRedDeadState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;


private:
	qSound*			pSound;
};


```

`GameClient/qRedIdleState.cpp`:

```cpp
#include "pch.h"
#include "qRedIdleState.h"

qRedIdleState::qRedIdleState()
	: m_Time(0.f)
{
}

qRedIdleState::~qRedIdleState()
{
}

void qRedIdleState::Enter()
{
	init();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"RedIdleRight", true);
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		GetAnimator()->Play(L"RedIdleLeft", true);
	}
}

void qRedIdleState::FinalTick()
{
	qObj* pRed = GetBlackboardData<qObj*>(L"Red");
	float pRedSpeed = GetBlackboardData<float>(L"RedSpeed");
	int pRedHP = GetBlackboardData<int>(L"RedHP");

	m_Time += DT;
	if (m_Time > 3.f)
	{
		GetFSM()->ChangeState(L"RedMove");
	}

}

void qRedIdleState::Exit()
{
	m_Time = 0.f;
}

```

`GameClient/qRedIdleState.h`:

```h
#pragma once
#include "qState.h"

class qRedIdleState : public qState
{
public:
	CLONE(qRedIdleState);

	qRedIdleState();
	~qRedIdleState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;



private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qRedMoveState.cpp`:

```cpp
#include "pch.h"
#include "qRedMoveState.h"

qRedMoveState::qRedMoveState()
	: m_Dir(1.f)
{
}

qRedMoveState::~qRedMoveState()
{
}

void qRedMoveState::Enter()
{
	init();

	m_CenterPos = GetObj()->GetCenterPos();

	if (DIRECTION::RIGHT == GetObj()->GetDir())
	{
		m_Dir = 1.f;
	}
	else if (DIRECTION::LEFT == GetObj()->GetDir())
	{
		m_Dir = -1.f;
	}

	if (m_Dir == 1.f)
	{
		GetAnimator()->Play(L"RedMoveRight", true);
	}
	else if (m_Dir == -1.f)
	{
		GetAnimator()->Play(L"RedMoveLeft", true);
	}
}

void qRedMoveState::FinalTick()
{
	qObj* pRed = GetBlackboardData<qObj*>(L"Red");
	float pRedSpeed = GetBlackboardData<float>(L"RedSpeed");
	float pMaxDist = GetBlackboardData<float>(L"MaxDist");
	int pRedHP = GetBlackboardData<int>(L"RedHP");

	Vec2 vPos = GetObj()->GetPos();


	vPos.x += m_Dir * pRedSpeed * DT;

	GetObj()->SetPos(vPos);

	float Dist = abs(m_CenterPos.x - vPos.x) - pMaxDist;
	if (10.f < Dist)
	{
		m_Dir *= -1.f;
		vPos.x += Dist * m_Dir;
		GetObj()->SetPos(vPos);

		if (m_Dir == -1.f)
		{
			GetObj()->SetDir(DIRECTION::LEFT);
			GetFSM()->ChangeState(L"RedIdle");
		}
		else if (m_Dir == 1.f)
		{
			GetObj()->SetDir(DIRECTION::RIGHT);
			GetFSM()->ChangeState(L"RedIdle");
		}
	}
}

void qRedMoveState::Exit()
{
}

```

`GameClient/qRedMoveState.h`:

```h
#pragma once
#include "qState.h"

class qRedMoveState : public qState
{
public:

	CLONE(qRedMoveState);

	qRedMoveState();
	~qRedMoveState();

public:
	virtual void Enter() override;
	virtual void FinalTick() override;
	virtual void Exit() override;


private:
	Vec2		m_CenterPos;
	float		m_MaxDistance;
	float		m_Dir;
};


```

`GameClient/qRespawnMgr.cpp`:

```cpp
#include "pch.h"
#include "qRespawnMgr.h"

void qRespawnMgr::init()
{
	for (UINT i = 0; i < (UINT)LAYER_TYPE::END; ++i)
	{

	}
}

void qRespawnMgr::progress()
{
}

```

`GameClient/qRespawnMgr.h`:

```h
#pragma once


class qMonster_blue;
class qMonster_red;

class qRespawnMgr
{
	SINGLE(qRespawnMgr)

public:
	void init();
	void progress();



private:
	qObj*		m_arrBlue[(UINT)LAYER_TYPE::MONSTER_BLUE];
	qObj*		m_pCurrentBlue;


	qObj*		m_arrRed[(UINT)LAYER_TYPE::MONSTER_RED];
	qObj*		m_pCurrentRed;

	bool		Dead;

};


```

`GameClient/qRigidbody.cpp`:

```cpp
#include "pch.h"
#include "qRigidbody.h"
#include "qPlayer.h"

qRigidbody::qRigidbody()
	: m_Mass(1.f)
	, m_InitWalkSpeed(0.f)
	, m_MaxWalkSpeed(0.f)
	, m_MaxGravitySpeed(0.f)
	, m_Friction(500.f)
	, m_GravityAccel(980.f)
	, m_UseGravity(false)
	, m_JumpSpeed(400.f)
	, m_DoubleJumpSpeed(500.f)
	, m_GroundFunc(nullptr)
	, m_AirFunc(nullptr)
	, m_GroundInst(nullptr)
	, m_AirInst(nullptr)
	, m_GroundDelegate(nullptr)
	, m_AirDelegate(nullptr)
{
}

qRigidbody::qRigidbody(const qRigidbody& _Other)
	: qComponent(_Other)
	, m_Mass(_Other.m_Mass)
	, m_InitWalkSpeed(_Other.m_InitWalkSpeed)
	, m_MaxWalkSpeed(_Other.m_MaxWalkSpeed)
	, m_MaxGravitySpeed(_Other.m_MaxGravitySpeed)
	, m_Friction(_Other.m_Friction)
	, m_GravityAccel(_Other.m_GravityAccel)
	, m_UseGravity(_Other.m_UseGravity)
	, m_JumpSpeed(_Other.m_JumpSpeed)
	, m_DoubleJumpSpeed(_Other.m_DoubleJumpSpeed)
	, m_GroundFunc(nullptr)
	, m_AirFunc(nullptr)
	, m_GroundInst(nullptr)
	, m_AirInst(nullptr)
	, m_GroundDelegate(nullptr)
	, m_AirDelegate(nullptr)
{
}



qRigidbody::~qRigidbody()
{
}

void qRigidbody::jump()
{
	if (L"Player" == GetOwner()->GetName())
	{
		m_VelocityByGravity += Vec2(0.f, -1.f) * m_JumpSpeed;
	}
	
	SetGround(false);
}

void qRigidbody::doublejump()
{
	if (L"Player" == GetOwner()->GetName())
	{
		if (DIRECTION::LEFT == GetOwner()->GetDir())
		{
			m_VelocityByGravity += Vec2(-1.f, 0.f) * m_DoubleJumpSpeed;
		}
		else if (DIRECTION::RIGHT == GetOwner()->GetDir())
		{
			m_VelocityByGravity += Vec2(1.f, 0.f) * m_DoubleJumpSpeed;
		}
	}

	SetGround(false);
}



void qRigidbody::finaltick()
{
	Vec2 vObjPos = GetOwner()->GetPos();

	// F = M x A
	Vec2 vAccel = m_Force / m_Mass;

	// 가속도
	// 중력을 사용할 때, 공중에서 힘이 적용된 경우
	if (m_UseGravity && !m_Ground)
	{
		m_Velocity += vAccel * DT * 0.5f;
	}
	else
	{
		m_Velocity += vAccel * DT * 1.f;
	}

	// 최대속도 제한
	if (0.f != m_MaxWalkSpeed && m_MaxWalkSpeed < m_Velocity.Length())
	{
		m_Velocity.Normalize();
		m_Velocity *= m_MaxWalkSpeed;
	}

	// 최소 속도 보정
	if (m_InitWalkSpeed != 0.f && m_Velocity.Length() < 10.f && !vAccel.IsZero())
	{
		Vec2 vForceDir = m_Force;
		vForceDir.Normalize();
		m_Velocity = vForceDir * m_InitWalkSpeed;
	}

	// 만약 RigidBody 에 적용된 힘이 없으면서, 속도는 있는 경우
	// 마찰에 의해서 현재 속도를 줄인다.

	if (m_Force.IsZero())
	{
		float Speed = m_Velocity.Length();
		

		// 중력 기능을 켰고, 공중 상태인 경우
		if (m_UseGravity && !m_Ground)
		{
			// 마찰을 더 적게 적용한다.
			Speed -= m_Friction * DT * 0.2f;
		}
		else
		{
			Speed -= m_Friction * DT;
		}

		// 마찰에 의해서 속도가 역으로 생길 수는 없기 때문에,
		// 감소된 속력의 크기가 음수가 되지 않게 보정한다.
		if (Speed < 0)
			Speed = 0.f;

		if (!m_Velocity.IsZero())
			m_Velocity.Normalize();

		m_Velocity *= Speed;
	}


	// 중력 가속도에 의한 속도 증가
	if (m_UseGravity && !m_Ground && !m_Rope)
	{
		m_VelocityByGravity += Vec2(0.0f, 1.f) * m_GravityAccel * DT;

		if (0.f != m_MaxGravitySpeed && m_MaxGravitySpeed < m_VelocityByGravity.Length())
		{
			m_VelocityByGravity.Normalize();
			m_VelocityByGravity *= m_MaxGravitySpeed;
		}
	}

	// 최종 속도
	Vec2 vFinalVelocity = m_Velocity + m_VelocityByGravity;


	// 현재 속도에 따른 이동
	// 속도 = 거리 / 시간
	vObjPos += vFinalVelocity * DT;
	GetOwner()->SetPos(vObjPos);

	// 이번 프레임 힘 초기화
	m_Force = Vec2(0.f, 0.f);
	m_AddVelocity = Vec2(0.f, 0.f);

	// DebugRender
	DrawDebugLine(PEN_TYPE::PEN_BLUE, vObjPos, vObjPos + vFinalVelocity, 0.f);

}


```

`GameClient/qRigidbody.h`:

```h
#pragma once
#include "qComponent.h"

typedef void(*CALL_BACK)(void);
typedef void(qObj::*DELEGATE)(void);

// vector : 크기, 방향	
// scalar : 크기			

// 속도 : Velocity
// 속력 : Speed

// 빗변의 길이를 1로 하면 방향만 나오며, 그러면 그것을 normalize (정규화) 라고 한다.


class qRigidbody : public qComponent
{
public:

	CLONE(qRigidbody);

	qRigidbody();
	qRigidbody(const qRigidbody& _Other);
	~qRigidbody();

	virtual void finaltick() override;


public:
	void AddForce(Vec2 _vForce) { m_Force += _vForce; }						// 힘 추가

	void SetMass(float _Mass) { m_Mass = _Mass; }							// 질량 설정
	void SetInitialWalkSpeed(float _Speed) { m_InitWalkSpeed = _Speed; }	// 초기 이동속도 설정
	void SetMaxWalkSpeed(float _Speed) { m_MaxWalkSpeed = _Speed; }			// 최대 이동속도 설정
	void SetMaxGravitySpeed(float _Speed) { m_MaxGravitySpeed = _Speed; }	// 최대 중력가속도 설정
	void SetFriction(float _Friction) { m_Friction = _Friction; }
	void SetJumpSpeed(float _Speed) { m_JumpSpeed = _Speed; }

	void jump();
	void doublejump();

	float GetMass() { return m_Mass; }
	float GetInitWalkSpeed() { return m_InitWalkSpeed; }
	float GetMaxWalkSpeed() { return m_MaxWalkSpeed; }
	float GetFriction() { return m_Friction; }
	Vec2  GetGravityVelocity() { return m_VelocityByGravity; }


	void SetGroundFunc(void(*_pFunc)(void)) { m_GroundFunc = _pFunc; }
	void SetAirFunc(void(*_pFunc)(void)) { m_AirFunc = _pFunc; }
	void SetRopeFunc(void(*_pFunc)(void)) { m_RopeFunc = _pFunc; }

	void SetGroundDelegate(qObj* _Inst, DELEGATE _MemFunc)
	{
		m_GroundInst = _Inst;
		m_GroundDelegate = _MemFunc;
	}

	void SetAirDelegate(qObj* _Inst, DELEGATE _MemFunc)
	{
		m_AirInst = _Inst;
		m_AirDelegate = _MemFunc;
	}

	void SetRopeDelegate(qObj* _Inst, DELEGATE _MemFunc)
	{
		m_RopeInst = _Inst;
		m_RopeDelegate = _MemFunc;
	}

	void UseGravity(bool _Use)
	{
		m_UseGravity = _Use;
		if (!m_UseGravity)
			m_VelocityByGravity = Vec2(0.f, 0.f);
	}

	void SetGround(bool _Ground)
	{
		m_Ground = _Ground;

		if (m_Ground)
		{
			m_VelocityByGravity = Vec2(0.f, 0.f);

			if (nullptr != m_GroundFunc)
				m_GroundFunc();

			if (m_GroundInst && m_GroundDelegate)
				(m_GroundInst->*m_GroundDelegate)();
		}
		else
		{
			if (nullptr != m_AirFunc)
				m_AirFunc();

			if (m_AirInst && m_AirDelegate)
				(m_AirInst->*m_AirDelegate)();
		}
	}

	void SetRope(bool _Rope)
	{
		m_Rope = _Rope;

		if (m_Rope)
		{
			m_VelocityByGravity = Vec2(0.f, 0.f);

			if (nullptr != m_RopeFunc)
				m_RopeFunc();

			if (m_RopeInst && m_RopeDelegate)
				(m_RopeInst->*m_RopeDelegate)();
		}
	}



	bool IsGround() { return m_Ground; }
	bool IsWall() { return m_Wall; }
	bool IsRope() { return m_Rope; }

private:

	Vec2	m_Velocity;				// 속도 (방향, 크기정보를 갖고 있다. 그래서 vector 라 부른다.
	Vec2	m_VelocityByGravity;	// 중력에 의해서 증가하는 속도
	Vec2	m_AddVelocity;			// 최종 속도에 누적될 속도

	float	m_Mass;					// 질량
	Vec2	m_Force;				// 힘

	float	m_InitWalkSpeed;		// 최소 보장 속력
	float	m_MaxWalkSpeed;			// 최대 제한 속력
	float	m_MaxGravitySpeed;		// 중력으로 발생한 낙하속도 제한

	float	m_Friction;				// 마찰력

	float	m_GravityAccel;			// 중력 가속도
	bool	m_UseGravity;			// 중력 사용 <-> 미사용 bool
	bool	m_Ground;				// 땅 위에 서있는지 체크
	float	m_JumpSpeed;			// 점프 속력
	float	m_DoubleJumpSpeed;		// 더플점프 속력


	// 로프
	bool	m_Rope;					// 로프상태인지 체크

	// 벽 구현하기
	bool	m_Wall;					// 벽에 부딪혔는지 체크



	// Ground, Air, Rope   On / Off 호출시킬 함수포인터
	CALL_BACK	m_GroundFunc;
	CALL_BACK	m_AirFunc;
	CALL_BACK	m_RopeFunc;

	// Delegate
	qObj*		m_GroundInst;
	DELEGATE	m_GroundDelegate;

	qObj*		m_AirInst;
	DELEGATE	m_AirDelegate;

	qObj*		m_RopeInst;
	DELEGATE	m_RopeDelegate;

};


```

`GameClient/qRope.cpp`:

```cpp
#include "pch.h"
#include "qRope.h"

#include "qCollider.h"
#include "qRigidbody.h"
#include "qPlayer.h"

#include "qKeyMgr.h"
#include "qLevelMgr.h"
#include "qLevel.h"

qRope::qRope()
	: m_Collider(nullptr)
{
}

qRope::qRope(Vec2 _Pos, Vec2 _Scale)
	: m_Collider(nullptr)

{
	SetPos(_Pos);
	SetScale(_Scale);
	m_Collider = (qCollider*)AddComponent(new qCollider);
	m_Collider->SetScale(GetScale());
}

qRope::~qRope()
{
}

void qRope::tick()
{
	qObj::tick();
}

void qRope::render()
{
	qObj::render();
}

void qRope::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player")
	{
		qPlayer* pPlayer = static_cast<qPlayer*>(_OtherObj);
		pPlayer->SetRope(true);
		pPlayer->SetTargetRope(this);	

	}
}

void qRope::OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
}

void qRope::EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (_OtherObj->GetName() == L"Player")
	{
		qRigidbody* pRB = _OtherObj->GetComponent<qRigidbody>();
		pRB->SetRope(false);
		static_cast<qPlayer*>(_OtherObj)->SetRope(false);
	}
}

```

`GameClient/qRope.h`:

```h
#pragma once
#include "qObj.h"

class qRope : public qObj
{
	CLONE(qRope);

public:
	qRope();
	qRope(Vec2 _Pos, Vec2 _Scale);
	~qRope();

	virtual void tick();
	virtual void render();


	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void OnOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;
	virtual void EndOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;


private:
	qCollider*		m_Collider;
};


```

`GameClient/qSelectObj.cpp`:

```cpp
#include "pch.h"
#include "qSelectObj.h"

qSelectObj::qSelectObj(HDC _dc, HGDIOBJ _SelectedObj)
	: m_DC(_dc)
	, m_hPrev(nullptr)
{
	m_hPrev = SelectObject(m_DC, _SelectedObj);
}

qSelectObj::~qSelectObj()
{
	SelectObject(m_DC, m_hPrev);

	
}

```

`GameClient/qSelectObj.h`:

```h
#pragma once
class qSelectObj
{

private:
	HDC			m_DC;
	HGDIOBJ		m_hPrev;


public:
	qSelectObj(HDC _dc, HGDIOBJ _SelectedObj);
	~qSelectObj();


};


```

`GameClient/qSkill_attack_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_attack_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_attack.h"
#include "qDamage_attack.h"

#include "qTaskMgr.h"


qSkill_attack_left::qSkill_attack_left()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{

	// 애니메이션
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// 애니메이션 추가
	qTexture* AttackLeft = qAssetMgr::GetInst()->LoadTexture(L"AttackLeft", L"texture\\skill\\attack\\attack_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"AttackLeft", AttackLeft, Vec2(0.f, 0.f), Vec2(410.f, 240.f), 12, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"AttackLeft")->Save(L"animation\\skill\\attack\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\attack\\AttackLeft.anim");

	m_Animator->Play(L"AttackLeft", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(-10.f, 0.f));
	m_Collider->SetScale(Vec2(300.f, 180.f));


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\attack.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

}

qSkill_attack_left::qSkill_attack_left(const qSkill_attack_left& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_attack_left::~qSkill_attack_left()
{
}

void qSkill_attack_left::tick()
{
	qObj::tick();

	if (L"AttackLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
	
}

void qSkill_attack_left::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{


		qEffect_attack* pAttackEffect = new qEffect_attack;
		pAttackEffect->SetName(L"AttackEffect");

		Vec2 vAttackEffectPos = _OtherObj->GetPos() + Vec2(50.f, 0.f);
		Vec2 vAttackEffectScale = Vec2(150.f, 150.f);

		pAttackEffect->SetPos(vAttackEffectPos);
		pAttackEffect->SetScale(vAttackEffectScale);

		if (L"AttackEffect" == pAttackEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pAttackEffect);
		}

	}


	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_attack* pDamageAttack = new qDamage_attack;
		pDamageAttack->SetName(L"DamageAttack");

		Vec2 vDamageAttackPos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageAttackScale = Vec2(258.f, 112.f);

		pDamageAttack->SetPos(vDamageAttackPos);
		pDamageAttack->SetScale(vDamageAttackScale);

		if (L"DamageAttack" == pDamageAttack->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageAttack);
		}
	}


}



```

`GameClient/qSkill_attack_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_attack_left : public qObj
{
	CLONE(qSkill_attack_left);

public:
	qSkill_attack_left();
	qSkill_attack_left(const qSkill_attack_left& _Other);
	~qSkill_attack_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;



private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qSound*			pSound;
};


```

`GameClient/qSkill_attack_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_attack_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qEffect_attack.h"
#include "qLevel.h"
#include "qLevelMgr.h"
#include "qDamage_attack.h"

#include "qTaskMgr.h"


qSkill_attack_right::qSkill_attack_right()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{

	// 애니메이션
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// 애니메이션 추가
	qTexture* AttackRight = qAssetMgr::GetInst()->LoadTexture(L"AttackRight", L"texture\\skill\\attack\\attack_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"AttackRight", AttackRight, Vec2(0.f, 0.f), Vec2(410.f, 240.f), 12, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"AttackRight")->Save(L"animation\\skill\\attack\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\attack\\AttackRight.anim");

	m_Animator->Play(L"AttackRight", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(10.f, 0.f));
	m_Collider->SetScale(Vec2(300.f, 180.f));


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\attack.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

}

qSkill_attack_right::qSkill_attack_right(const qSkill_attack_right& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_attack_right::~qSkill_attack_right()
{
}

void qSkill_attack_right::tick()
{
	qObj::tick();

	if (L"AttackRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}

}

void qSkill_attack_right::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{


		qEffect_attack* pAttackEffect = new qEffect_attack;
		pAttackEffect->SetName(L"AttackEffect");

		Vec2 vAttackEffectPos = _OtherObj->GetPos() + Vec2(-30.f, 0.f);
		Vec2 vAttackEffectScale = Vec2(150.f, 150.f);

		pAttackEffect->SetPos(vAttackEffectPos);
		pAttackEffect->SetScale(vAttackEffectScale);

		if (L"AttackEffect" == pAttackEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pAttackEffect);
		}

	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_attack* pDamageAttack = new qDamage_attack;
		pDamageAttack->SetName(L"DamageAttack");

		Vec2 vDamageAttackPos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageAttackScale = Vec2(258.f, 112.f);

		pDamageAttack->SetPos(vDamageAttackPos);
		pDamageAttack->SetScale(vDamageAttackScale);

		if (L"DamageAttack" == pDamageAttack->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageAttack);
		}
	}
}



```

`GameClient/qSkill_attack_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_attack_right : public qObj
{
	CLONE(qSkill_attack_right);

public:
	qSkill_attack_right();
	qSkill_attack_right(const qSkill_attack_right& _Other);
	~qSkill_attack_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;


private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qSound*			pSound;
};


```

`GameClient/qSkill_buff.cpp`:

```cpp
#include "pch.h"
#include "qSkill_buff.h"

#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"


qSkill_buff::qSkill_buff()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* Buff = qAssetMgr::GetInst()->LoadTexture(L"Buff", L"texture\\skill\\buff\\buff.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"Buff", Buff, Vec2(0.f, 0.f), Vec2(400.f, 400.f), 17, 10);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"Buff")->Save(L"animation\\skill\\buff\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\buff\\Buff.anim");

	m_Animator->Play(L"Buff", false);


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\buff.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_buff::qSkill_buff(const qSkill_buff& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_buff::~qSkill_buff()
{
}

void qSkill_buff::tick()
{
	qObj::tick();

	if (L"Buff" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_buff.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_buff : public qObj
{
	CLONE(qSkill_buff);

public:
	qSkill_buff();
	qSkill_buff(const qSkill_buff& _Other);
	~qSkill_buff();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }



private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qSkill_doublejump_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_doublejump_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"


qSkill_doublejump_left::qSkill_doublejump_left()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DoubleJumpLeft = qAssetMgr::GetInst()->LoadTexture(L"DoubleJumpLeft", L"texture\\skill\\doublejump\\doublejump_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"DoubleJumpLeft", DoubleJumpLeft, Vec2(0.f, 0.f), Vec2(255.f, 185.f), 10, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"DoubleJumpLeft")->Save(L"animation\\skill\\doublejump\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\doublejump\\DoubleJumpLeft.anim");

	m_Animator->Play(L"DoubleJumpLeft", false);


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\jump.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

}

qSkill_doublejump_left::qSkill_doublejump_left(const qSkill_doublejump_left& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_doublejump_left::~qSkill_doublejump_left()
{
}

void qSkill_doublejump_left::tick()
{
	qObj::tick();

	if (L"DoubleJumpLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_doublejump_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_doublejump_left : public qObj
{
	CLONE(qSkill_doublejump_left);

public:
	qSkill_doublejump_left();
	qSkill_doublejump_left(const qSkill_doublejump_left& _Other);
	~qSkill_doublejump_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }

	

private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qSkill_doublejump_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_doublejump_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"


qSkill_doublejump_right::qSkill_doublejump_right()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* DoubleJumpRight = qAssetMgr::GetInst()->LoadTexture(L"DoubleJumpRight", L"texture\\skill\\doublejump\\doublejump_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"DoubleJumpRight", DoubleJumpRight, Vec2(0.f, 0.f), Vec2(255.f, 185.f), 10, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"DoubleJumpRight")->Save(L"animation\\skill\\doublejump\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\doublejump\\DoubleJumpRight.anim");

	m_Animator->Play(L"DoubleJumpRight", false);



	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\jump.wav");
	pSound->SetVolume(30.f);
	pSound->Play();

}

qSkill_doublejump_right::qSkill_doublejump_right(const qSkill_doublejump_right& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_doublejump_right::~qSkill_doublejump_right()
{
}

void qSkill_doublejump_right::tick()
{
	qObj::tick();

	if (L"DoubleJumpRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_doublejump_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_doublejump_right : public qObj
{
	CLONE(qSkill_doublejump_right);

public:
	qSkill_doublejump_right();
	qSkill_doublejump_right(const qSkill_doublejump_right& _Other);
	~qSkill_doublejump_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }



private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qSkill_highjump.cpp`:

```cpp
#include "pch.h"
#include "qSkill_highjump.h"

#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"


qSkill_highjump::qSkill_highjump()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* HighJump = qAssetMgr::GetInst()->LoadTexture(L"HighJump", L"texture\\skill\\highjump\\highjump.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"HighJump", HighJump, Vec2(0.f, 0.f), Vec2(185.f, 255.f), 10, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"HighJump")->Save(L"animation\\skill\\highjump\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\highjump\\HighJump.anim");

	m_Animator->Play(L"HighJump", false);


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\jump.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_highjump::qSkill_highjump(const qSkill_highjump& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_highjump::~qSkill_highjump()
{
}

void qSkill_highjump::tick()
{
	qObj::tick();

	if (L"HighJump" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_highjump.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_highjump : public qObj
{
	CLONE(qSkill_highjump);

public:
	qSkill_highjump();
	qSkill_highjump(const qSkill_highjump& _Other);
	~qSkill_highjump();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }



private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};


```

`GameClient/qSkill_missile_ball_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_missile_ball_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_missile.h"
#include "qDamage_missile.h"

#include "qTaskMgr.h"

qSkill_missile_ball_left::qSkill_missile_ball_left()
	: m_Animator(nullptr)
	, m_BallSpeed(600.f)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* MissileBallLeft = qAssetMgr::GetInst()->LoadTexture(L"MissileBallLeft", L"texture\\skill\\missile\\missile_ball_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"MissileBallLeft", MissileBallLeft, Vec2(0.f, 0.f), Vec2(100.f, 70.f), 4, 5);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"MissileBallLeft")->Save(L"animation\\skill\\missile\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\missile\\MissileBallLeft.anim");

	m_Animator->Play(L"MissileBallLeft", true);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 0.f));
	m_Collider->SetScale(Vec2(60.f, 30.f));
}

qSkill_missile_ball_left::qSkill_missile_ball_left(const qSkill_missile_ball_left& _Other)
	: m_Animator(nullptr)
	, m_BallSpeed(600.f)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_missile_ball_left::~qSkill_missile_ball_left()
{
}

void qSkill_missile_ball_left::tick()
{
	qObj::tick();

	Vec2 vPos = GetPos();
	Vec2 vDir = Vec2(-1.f, 0.f);

	vPos += vDir * m_BallSpeed * DT;

	SetPos(vPos);
}


void qSkill_missile_ball_left::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_missile* pMissileEffect = new qEffect_missile;
		pMissileEffect->SetName(L"MissileEffect");

		Vec2 vMissileEffectPos = _OtherObj->GetPos() + Vec2(30.f, 0.f);
		Vec2 vMissileEffectScale = Vec2(150.f, 130.f);

		pMissileEffect->SetPos(vMissileEffectPos);
		pMissileEffect->SetScale(vMissileEffectScale);

		if (L"MissileEffect" == pMissileEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pMissileEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_missile* pDamageMissile = new qDamage_missile;
		pDamageMissile->SetName(L"DamageMissile");

		Vec2 vDamageMissilePos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageMissileScale = Vec2(258.f, 112.f);

		pDamageMissile->SetPos(vDamageMissilePos);
		pDamageMissile->SetScale(vDamageMissileScale);

		if (L"DamageMissile" == pDamageMissile->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageMissile);
		}
	}



	// 적과 부딪혔을때 Destroy();
	if (_OtherObj->GetName() == L"Blue" || _OtherObj->GetName() == L"Red" || _OtherObj->GetName() == L"Boss")
	{
		Destroy();
	}




}

```

`GameClient/qSkill_missile_ball_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qSkill_missile_ball_left : public qObj
{
	CLONE(qSkill_missile_ball_left);

public:
	qSkill_missile_ball_left();
	qSkill_missile_ball_left(const qSkill_missile_ball_left& _Other);
	~qSkill_missile_ball_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;

	float	   m_BallSpeed;
};


```

`GameClient/qSkill_missile_ball_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_missile_ball_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_missile.h"
#include "qDamage_missile.h"

#include "qTaskMgr.h"

qSkill_missile_ball_right::qSkill_missile_ball_right()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
	, m_BallSpeed(600.f)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* MissileBallRight = qAssetMgr::GetInst()->LoadTexture(L"MissileBallRight", L"texture\\skill\\missile\\missile_ball_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"MissileBallRight", MissileBallRight, Vec2(0.f, 0.f), Vec2(100.f, 70.f), 4, 5);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"MissileBallRight")->Save(L"animation\\skill\\missile\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\missile\\MissileBallRight.anim");

	m_Animator->Play(L"MissileBallRight", true);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(0.f, 0.f));
	m_Collider->SetScale(Vec2(60.f, 30.f));
}

qSkill_missile_ball_right::qSkill_missile_ball_right(const qSkill_missile_ball_right& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
	, m_BallSpeed(600.f)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_missile_ball_right::~qSkill_missile_ball_right()
{
}

void qSkill_missile_ball_right::tick()
{
	qObj::tick();

	Vec2 vPos = GetPos();
	Vec2 vDir = Vec2(1.f, 0.f);

	vPos += vDir * m_BallSpeed * DT;

	SetPos(vPos);
}


void qSkill_missile_ball_right::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_missile* pMissileEffect = new qEffect_missile;
		pMissileEffect->SetName(L"MissileEffect");

		Vec2 vMissileEffectPos = _OtherObj->GetPos() + Vec2(-30.f, 0.f);
		Vec2 vMissileEffectScale = Vec2(150.f, 130.f);

		pMissileEffect->SetPos(vMissileEffectPos);
		pMissileEffect->SetScale(vMissileEffectScale);

		if (L"MissileEffect" == pMissileEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pMissileEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_missile* pDamageMissile = new qDamage_missile;
		pDamageMissile->SetName(L"DamageMissile");

		Vec2 vDamageMissilePos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageMissileScale = Vec2(258.f, 112.f);

		pDamageMissile->SetPos(vDamageMissilePos);
		pDamageMissile->SetScale(vDamageMissileScale);

		if (L"DamageMissile" == pDamageMissile->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageMissile);
		}
	}


	// 적과 부딪혔을때 Destroy();
	if (_OtherObj->GetName() == L"Blue" || _OtherObj->GetName() == L"Red" || _OtherObj->GetName() == L"Boss")
	{
		Destroy();
	}
}

```

`GameClient/qSkill_missile_ball_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;

class qSkill_missile_ball_right : public qObj
{
	CLONE(qSkill_missile_ball_right);

public:
	qSkill_missile_ball_right();
	qSkill_missile_ball_right(const qSkill_missile_ball_right& _Other);
	~qSkill_missile_ball_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator* m_Animator;
	qCollider* m_Collider;

	float	   m_BallSpeed;
};


```

`GameClient/qSkill_missile_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_missile_left.h"

#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"

qSkill_missile_left::qSkill_missile_left()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* MissileLeft = qAssetMgr::GetInst()->LoadTexture(L"MissileLeft", L"texture\\skill\\missile\\missile_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"MissileLeft", MissileLeft, Vec2(0.f, 0.f), Vec2(240.f, 195.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"MissileLeft")->Save(L"animation\\skill\\missile\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\missile\\MissileLeft.anim");

	m_Animator->Play(L"MissileLeft", false);



	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\missile.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_missile_left::qSkill_missile_left(const qSkill_missile_left& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_missile_left::~qSkill_missile_left()
{
}

void qSkill_missile_left::tick()
{
	qObj::tick();

	if (L"MissileLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_missile_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_missile_left : public qObj
{
	CLONE(qSkill_missile_left);

public:
	qSkill_missile_left();
	qSkill_missile_left(const qSkill_missile_left& _Other);
	~qSkill_missile_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }



private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};

```

`GameClient/qSkill_missile_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_missile_right.h"

#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qTaskMgr.h"

qSkill_missile_right::qSkill_missile_right()
	: m_Animator(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* MissileRight = qAssetMgr::GetInst()->LoadTexture(L"MissileRight", L"texture\\skill\\missile\\missile_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"MissileRight", MissileRight, Vec2(0.f, 0.f), Vec2(240.f, 195.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"MissileRight")->Save(L"animation\\skill\\missile\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\missile\\MissileRight.anim");

	m_Animator->Play(L"MissileRight", false);



	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\missile.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_missile_right::qSkill_missile_right(const qSkill_missile_right& _Other)
	: m_Animator(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_missile_right::~qSkill_missile_right()
{
}

void qSkill_missile_right::tick()
{
	qObj::tick();

	if (L"MissileRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

```

`GameClient/qSkill_missile_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_missile_right : public qObj
{
	CLONE(qSkill_missile_right);

public:
	qSkill_missile_right();
	qSkill_missile_right(const qSkill_missile_right& _Other);
	~qSkill_missile_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }



private:
	qAnimator*		m_Animator;
	qSound*			pSound;
};

```

`GameClient/qSkill_slash_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_slash_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_slash.h"
#include "qDamage_slash.h"

#include "qTaskMgr.h"

qSkill_slash_left::qSkill_slash_left()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SlashLeft = qAssetMgr::GetInst()->LoadTexture(L"SlashLeft", L"texture\\skill\\slash\\slash_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"SlashLeft", SlashLeft, Vec2(0.f, 0.f), Vec2(675.f, 215.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"SlashLeft")->Save(L"animation\\skill\\slash\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\slash\\SlashLeft.anim");

	m_Animator->Play(L"SlashLeft", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(-100.f, 0.f));
	m_Collider->SetScale(Vec2(250.f, 100.f));


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\slash.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_slash_left::qSkill_slash_left(const qSkill_slash_left& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_slash_left::~qSkill_slash_left()
{
}

void qSkill_slash_left::tick()
{
	qObj::tick();

	SetPos(m_Owner->GetPos());

	if (L"SlashLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qSkill_slash_left::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_slash* pSlashEffect = new qEffect_slash;
		pSlashEffect->SetName(L"SlashEffect");

		Vec2 vSlashEffectPos = _OtherObj->GetPos() + Vec2(30.f, 0.f);
		Vec2 vSlashEffectScale = Vec2(200.f, 200.f);

		pSlashEffect->SetPos(vSlashEffectPos);
		pSlashEffect->SetScale(vSlashEffectScale);

		if (L"SlashEffect" == pSlashEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pSlashEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_slash* pDamageSlash = new qDamage_slash;
		pDamageSlash->SetName(L"DamageSlash");

		Vec2 vDamageSlashPos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageSlashScale = Vec2(258.f, 112.f);

		pDamageSlash->SetPos(vDamageSlashPos);
		pDamageSlash->SetScale(vDamageSlashScale);

		if (L"DamageSlash" == pDamageSlash->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageSlash);
		}
	}
}


```

`GameClient/qSkill_slash_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_slash_left : public qObj
{
	CLONE(qSkill_slash_left);

public:
	qSkill_slash_left();
	qSkill_slash_left(const qSkill_slash_left& _Other);
	~qSkill_slash_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

	void SetOwner(qObj* _Owner) { m_Owner = _Owner; }

private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qObj*			m_Owner;
	qSound*			pSound;
};


```

`GameClient/qSkill_slash_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_slash_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_slash.h"
#include "qDamage_slash.h"

#include "qTaskMgr.h"

qSkill_slash_right::qSkill_slash_right()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
	, m_Owner(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SlashRight = qAssetMgr::GetInst()->LoadTexture(L"SlashRight", L"texture\\skill\\slash\\slash_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"SlashRight", SlashRight, Vec2(0.f, 0.f), Vec2(675.f, 215.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"SlashRight")->Save(L"animation\\skill\\slash\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\slash\\SlashRight.anim");

	m_Animator->Play(L"SlashRight", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(100.f, 0.f));
	m_Collider->SetScale(Vec2(250.f, 100.f));


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\slash.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_slash_right::qSkill_slash_right(const qSkill_slash_right& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
	, m_Owner(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_slash_right::~qSkill_slash_right()
{
}

void qSkill_slash_right::tick()
{
	qObj::tick();


	SetPos(m_Owner->GetPos());

	if (L"SlashRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qSkill_slash_right::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_slash* pSlashEffect = new qEffect_slash;
		pSlashEffect->SetName(L"SlashEffect");

		Vec2 vSlashEffectPos = _OtherObj->GetPos() + Vec2(-30.f, 0.f);
		Vec2 vSlashEffectScale = Vec2(200.f, 200.f);

		pSlashEffect->SetPos(vSlashEffectPos);
		pSlashEffect->SetScale(vSlashEffectScale);

		if (L"SlashEffect" == pSlashEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pSlashEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_slash* pDamageSlash = new qDamage_slash;
		pDamageSlash->SetName(L"DamageSlash");

		Vec2 vDamageSlashPos = _OtherObj->GetPos() + Vec2(0.f, -90.f);
		Vec2 vDamageSlashScale = Vec2(258.f, 112.f);

		pDamageSlash->SetPos(vDamageSlashPos);
		pDamageSlash->SetScale(vDamageSlashScale);

		if (L"DamageSlash" == pDamageSlash->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageSlash);
		}
	}
}


```

`GameClient/qSkill_slash_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_slash_right : public qObj
{
	CLONE(qSkill_slash_right);

public:
	qSkill_slash_right();
	qSkill_slash_right(const qSkill_slash_right& _Other);
	~qSkill_slash_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	void SetOwner(qObj* _Owner) { m_Owner = _Owner; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;


private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qObj*			m_Owner;
	qSound*			pSound;
};


```

`GameClient/qSkill_special_left.cpp`:

```cpp
#include "pch.h"
#include "qSkill_special_left.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_special.h"
#include "qDamage_special.h"

#include "qTaskMgr.h"


qSkill_special_left::qSkill_special_left()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SpecialLeft = qAssetMgr::GetInst()->LoadTexture(L"SpecialLeft", L"texture\\skill\\special\\special_left.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"SpecialLeft", SpecialLeft, Vec2(0.f, 0.f), Vec2(580.f, 450.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"SpecialLeft")->Save(L"animation\\skill\\special\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\special\\SpecialLeft.anim");

	m_Animator->Play(L"SpecialLeft", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(-80.f, 30.f));
	m_Collider->SetScale(Vec2(300.f, 300.f));


	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\special.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_special_left::qSkill_special_left(const qSkill_special_left& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_special_left::~qSkill_special_left()
{
}

void qSkill_special_left::tick()
{
	qObj::tick();

	if (L"SpecialLeft" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qSkill_special_left::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_special* pSpecialEffect = new qEffect_special;
		pSpecialEffect->SetName(L"SpecialEffect");

		Vec2 vSpecialEffectPos = _OtherObj->GetPos() + Vec2(10.f, 0.f);
		Vec2 vSpecialEffectScale = Vec2(330.f, 345.f);

		pSpecialEffect->SetPos(vSpecialEffectPos);
		pSpecialEffect->SetScale(vSpecialEffectScale);

		if (L"SpecialEffect" == pSpecialEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pSpecialEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_special* pDamageSpecial = new qDamage_special;
		pDamageSpecial->SetName(L"DamageSpecial");

		Vec2 vDamageSpecialPos = _OtherObj->GetPos() + Vec2(0.f, -150.f);
		Vec2 vDamageSpecialScale = Vec2(322.f, 216.f);

		pDamageSpecial->SetPos(vDamageSpecialPos);
		pDamageSpecial->SetScale(vDamageSpecialScale);

		if (L"DamageSpecial" == pDamageSpecial->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageSpecial);
		}
	}
}


```

`GameClient/qSkill_special_left.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_special_left : public qObj
{
	CLONE(qSkill_special_left);

public:
	qSkill_special_left();
	qSkill_special_left(const qSkill_special_left& _Other);
	~qSkill_special_left();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qSound*			pSound;
};


```

`GameClient/qSkill_special_right.cpp`:

```cpp
#include "pch.h"
#include "qSkill_special_right.h"

#include "qCollider.h"
#include "qAnimator.h"
#include "qCamera.h"
#include "qSound.h"

#include "qLevel.h"
#include "qLevelMgr.h"

#include "qEffect_special.h"
#include "qDamage_special.h"

#include "qTaskMgr.h"


qSkill_special_right::qSkill_special_right()
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = (qAnimator*)AddComponent(new qAnimator);

	// Animation 추가
	qTexture* SpecialRight = qAssetMgr::GetInst()->LoadTexture(L"SpecialRight", L"texture\\skill\\special\\special_right.png");

	// 애니메이션 CREATE
	m_Animator->CreateAnimation(L"SpecialRight", SpecialRight, Vec2(0.f, 0.f), Vec2(580.f, 450.f), 11, 13);

	// 애니메이션 SAVE
	m_Animator->FindAnimation(L"SpecialRight")->Save(L"animation\\skill\\special\\");

	// 애니메이션 LOAD
	m_Animator->LoadAnimation(L"animation\\skill\\special\\SpecialRight.anim");

	m_Animator->Play(L"SpecialRight", false);


	// 콜라이더

	m_Collider = (qCollider*)AddComponent(new qCollider);

	m_Collider->SetOffsetPos(Vec2(80.f, 30.f));
	m_Collider->SetScale(Vec2(300.f, 300.f));



	// 스킬 사운드
	pSound = qAssetMgr::GetInst()->LoadSound(L"BGM_START", L"sound\\skill\\special.wav");
	pSound->SetVolume(30.f);
	pSound->Play();
}

qSkill_special_right::qSkill_special_right(const qSkill_special_right& _Other)
	: m_Animator(nullptr)
	, m_Collider(nullptr)
{
	m_Animator = GetComponent<qAnimator>();
}

qSkill_special_right::~qSkill_special_right()
{
}

void qSkill_special_right::tick()
{
	qObj::tick();

	if (L"SpecialRight" == m_Animator->GetCurAnim()->GetName())
	{
		if (m_Animator->IsFinish())
		{
			Destroy();

			pSound->SetVolume(30.f);
			pSound->Stop();
		}
	}
}

void qSkill_special_right::BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider)
{
	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qEffect_special* pSpecialEffect = new qEffect_special;
		pSpecialEffect->SetName(L"SpecialEffect");

		Vec2 vSpecialEffectPos = _OtherObj->GetPos() + Vec2(-10.f, 0.f);
		Vec2 vSpecialEffectScale = Vec2(330.f, 345.f);

		pSpecialEffect->SetPos(vSpecialEffectPos);
		pSpecialEffect->SetScale(vSpecialEffectScale);

		if (L"SpecialEffect" == pSpecialEffect->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pSpecialEffect);
		}
	}

	if (LAYER_TYPE::MONSTER_BLUE == _OtherObj->GetLayerType() || LAYER_TYPE::BOSS == _OtherObj->GetLayerType()
		|| LAYER_TYPE::MONSTER_RED == _OtherObj->GetLayerType())
	{
		qDamage_special* pDamageSpecial = new qDamage_special;
		pDamageSpecial->SetName(L"DamageSpecial");

		Vec2 vDamageSpecialPos = _OtherObj->GetPos() + Vec2(0.f, -150.f);
		Vec2 vDamageSpecialScale = Vec2(322.f, 216.f);

		pDamageSpecial->SetPos(vDamageSpecialPos);
		pDamageSpecial->SetScale(vDamageSpecialScale);

		if (L"DamageSpecial" == pDamageSpecial->GetName())
		{
			// TASK
			SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::EFFECT, pDamageSpecial);
		}
	}
}


```

`GameClient/qSkill_special_right.h`:

```h
#pragma once
#include "qObj.h"

class qCamera;
class qTexture;
class qAnimator;
class qSound;

class qSkill_special_right : public qObj
{
	CLONE(qSkill_special_right);

public:
	qSkill_special_right();
	qSkill_special_right(const qSkill_special_right& _Other);
	~qSkill_special_right();

	virtual void tick() override;

	qAnimator* GetAnimator() { return m_Animator; }
	qCollider* GetCollider() { return m_Collider; }

	virtual void BeginOverlap(qCollider* _OwnCollider, qObj* _OtherObj, qCollider* _OtherCollider) override;

private:
	qAnimator*		m_Animator;
	qCollider*		m_Collider;
	qSound*			pSound;
};


```

`GameClient/qSound.cpp`:

```cpp
#include "pch.h"
#include "qSound.h"
#include "qSoundMgr.h"

qSound::qSound()
{
}

qSound::~qSound()
{
}

int qSound::Load(const wstring& _strFilePath)
{
	if (nullptr == qSoundMgr::GetInst()->GetSoundDevice())
		assert(nullptr);

	wchar_t szExt[10] = { 0 };
	_wsplitpath_s(_strFilePath.c_str(), nullptr, 0, nullptr, 0, nullptr, 0, szExt, 10);

	if (!wcscmp(szExt, L".wav"))
	{
		if (false == LoadWaveSound(_strFilePath))
			assert(nullptr);
	}
	else
		assert(nullptr);

	return true;
}


bool qSound::LoadWaveSound(const wstring& _strPath)
{
	HMMIO	hFile; // File Handle

	wstring strFilePath = _strPath;

	//CreateFile
	hFile = mmioOpen((wchar_t*)strFilePath.c_str(), NULL, MMIO_READ);// wave 파일 열기

	if (nullptr == hFile)
	{
		MessageBox(NULL, L"사운드 로딩 실패", L"에러", MB_OK);
		return false;
	}

	// Chunk, wave 파일 구조 분석
	MMCKINFO	pParent;
	memset(&pParent, 0, sizeof(pParent));
	pParent.fccType = mmioFOURCC('W', 'A', 'V', 'E');
	mmioDescend(hFile, &pParent, NULL, MMIO_FINDRIFF);

	MMCKINFO	pChild;
	memset(&pChild, 0, sizeof(pChild));
	pChild.ckid = mmioFOURCC('f', 'm', 't', ' ');
	mmioDescend(hFile, &pChild, &pParent, MMIO_FINDCHUNK);

	WAVEFORMATEX	wft;
	memset(&wft, 0, sizeof(wft));
	mmioRead(hFile, (char*)&wft, sizeof(wft));

	mmioAscend(hFile, &pChild, 0);
	pChild.ckid = mmioFOURCC('d', 'a', 't', 'a');
	mmioDescend(hFile, &pChild, &pParent, MMIO_FINDCHUNK);

	memset(&m_tBuffInfo, 0, sizeof(DSBUFFERDESC));
	m_tBuffInfo.dwBufferBytes = pChild.cksize;
	m_tBuffInfo.dwSize = sizeof(DSBUFFERDESC);
	m_tBuffInfo.dwFlags = DSBCAPS_STATIC | DSBCAPS_LOCSOFTWARE | DSBCAPS_CTRLVOLUME;
	m_tBuffInfo.lpwfxFormat = &wft;

	if (FAILED(qSoundMgr::GetInst()->GetSoundDevice()->CreateSoundBuffer(&m_tBuffInfo, &m_pSoundBuffer, NULL)))
	{
		MessageBox(NULL, L"웨이브 파일 로딩 실패", L"에러", MB_OK);
		return false;
	}

	void* pWrite1 = NULL;
	void* pWrite2 = NULL;
	DWORD dwlength1, dwlength2;

	m_pSoundBuffer->Lock(0, pChild.cksize, &pWrite1, &dwlength1
		, &pWrite2, &dwlength2, 0L);

	if (pWrite1 != nullptr)
		mmioRead(hFile, (char*)pWrite1, dwlength1);
	if (pWrite2 != nullptr)
		mmioRead(hFile, (char*)pWrite2, dwlength2);

	m_pSoundBuffer->Unlock(pWrite1, dwlength1, pWrite2, dwlength2);

	mmioClose(hFile, 0);

	// 기본 볼륨 50으로 설정
	SetVolume(50.f);

	return true;
}




void qSound::Play(bool _bLoop)
{
	m_pSoundBuffer->SetCurrentPosition(0);

	if (_bLoop)
		m_pSoundBuffer->Play(0, 0, DSBPLAY_LOOPING);
	else
		m_pSoundBuffer->Play(0, 0, 0);
}


void qSound::PlayToBGM(bool _bLoop)
{
	qSoundMgr::GetInst()->RegisterToBGM(this);

	if (_bLoop)
		m_pSoundBuffer->Play(0, 0, DSBPLAY_LOOPING);
	else
		m_pSoundBuffer->Play(0, 0, 0);
}

void qSound::Stop(bool _bReset)
{
	m_pSoundBuffer->Stop();

	if (_bReset)
		m_pSoundBuffer->SetCurrentPosition(0);
}

void qSound::SetVolume(float _fVolume)
{
	m_iVolume = GetDecibel(_fVolume);
	m_pSoundBuffer->SetVolume(m_iVolume);
}

void qSound::SetPosition(float _fPosition)
{
	Stop(true);

	DWORD dwBytes = (DWORD)((_fPosition / 100.f) * (float)m_tBuffInfo.dwBufferBytes);
	m_pSoundBuffer->SetCurrentPosition(dwBytes);
}

int qSound::GetDecibel(float _fVolume)
{
	if (_fVolume > 100.f)
		_fVolume = 100.f;
	else if (_fVolume <= 0.f)
		_fVolume = 0.00001f;

	// 1 ~ 100 의 값을 데시벨로 변환
	int iVolume = (LONG)(-2000.0 * log10(100.f / _fVolume));

	if (iVolume < -10000)
		iVolume = -10000;
	return  iVolume;
}


```

`GameClient/qSound.h`:

```h
#pragma once
#include "qAsset.h"


class qSound : public qAsset
{
public:
	friend class qAssetMgr;

	CLONE_DISABLE(qSound);

public:
	qSound();
	~qSound();

public:
	virtual int Load(const wstring& _strFilePath);

public:
    // 사운드 재생
    void Play(bool _bLoop = false);

    // 배경음악으로 재생
    void PlayToBGM(bool _bLoop = false);

    // 정지
    void Stop(bool _bReset = false);

    // 볼륨 설정 (0 ~ 100)
    void SetVolume(float _fVolume);

    // 사운드 재생 위치 (0 ~ 100)
    void SetPosition(float _fPosition); // 0 ~ 100 


    int GetDecibel(float _fVolume);



private:
    bool LoadWaveSound(const wstring& _strPath);


private:
    LPDIRECTSOUNDBUFFER		m_pSoundBuffer;
    DSBUFFERDESC			m_tBuffInfo;
    int						m_iVolume;
};


```

`GameClient/qSoundMgr.cpp`:

```cpp
#include "pch.h"
#include "qSoundMgr.h"

#include "qEngine.h"
#include "qSound.h"


qSoundMgr::qSoundMgr()
	: m_pSound(nullptr)
{}


qSoundMgr::~qSoundMgr()
{
	// DirectSound8 객체 메모리 해제
	m_pSound->Release();
}


int qSoundMgr::init()
{
	if (FAILED(DirectSoundCreate8(NULL, &m_pSound, NULL)))
	{
		MessageBox(NULL, L"사운드 디바이스 생성 실패", L"SYSTEM ERROR", MB_OK);
		return false;
	}

	// 사운드 협조레벨 설정
	HWND hWnd = qEngine::GetInst()->GetMainWnd();
	if (FAILED(m_pSound->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE)))
	{
		MessageBox(NULL, L"사운드 매니저 초기화 실패", L"SYSTEM ERROR", MB_OK);
		return false;
	}

	return true;
}

void qSoundMgr::RegisterToBGM(qSound* _pSound)
{
	if (m_pBGM != nullptr)
		m_pBGM->Stop(true);

	m_pBGM = _pSound;
}

```

`GameClient/qSoundMgr.h`:

```h
#pragma once

class qSound;

class qSoundMgr
{
	SINGLE(qSoundMgr);

public:
	int init();
	LPDIRECTSOUND8 GetSoundDevice() { return m_pSound; }
	void RegisterToBGM(qSound* _pSound);


private:
	LPDIRECTSOUND8	m_pSound;	// 사운드 카드 제어
	qSound* m_pBGM;		// BGM Sound

};


```

`GameClient/qSpawner_blue1.cpp`:

```cpp
#include "pch.h"
#include "qSpawner_blue1.h"

#include "qMonster_blue.h"
#include "qLevelMgr.h"

qSpawner_blue1::qSpawner_blue1()
	: m_Time(0.f)
{
}

qSpawner_blue1::~qSpawner_blue1()
{
}

void qSpawner_blue1::begin()
{
	qObj::begin();

	
}

void qSpawner_blue1::tick()
{
	qObj::tick();

	if (nullptr != GetOwner())
	{
		if (GetOwner()->IsDead())
		{
			SetOwner(nullptr);
		}
	}
	if (nullptr == GetOwner())
	{
		m_Time += DT;
	}

	if (m_Time > 5.f)
	{
		qObj* pBlue1 = new qMonster_blue(DIRECTION::LEFT);
		pBlue1->SetName(L"Blue");
		pBlue1->SetPos(1377.f, 1448.f);
		pBlue1->SetScale(100.0f, 100.0f);
		SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::MONSTER_BLUE, pBlue1);
		SetOwner(pBlue1);
		pBlue1->begin();
		m_Time = 0.f;
	}
}

```

`GameClient/qSpawner_blue1.h`:

```h
#pragma once
#include "qObj.h"

class qSpawner_blue1 : public qObj
{
public:

	CLONE(qSpawner_blue1);

	qSpawner_blue1();
	~qSpawner_blue1();

public:
	virtual void begin() override;
	virtual void tick() override;




private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qSpawner_blue2.cpp`:

```cpp
#include "pch.h"
#include "qSpawner_blue2.h"

#include "qMonster_blue.h"
#include "qLevelMgr.h"

qSpawner_blue2::qSpawner_blue2()
	: m_Time(0.f)
{
}

qSpawner_blue2::~qSpawner_blue2()
{
}

void qSpawner_blue2::begin()
{
	qObj::begin();
}

void qSpawner_blue2::tick()
{
	qObj::tick();

	if (nullptr != GetOwner())
	{
		if (GetOwner()->IsDead())
		{
			SetOwner(nullptr);
		}
	}
	if (nullptr == GetOwner())
	{
		m_Time += DT;
	}

	if (m_Time > 5.f)
	{
		qObj* pBlue2 = new qMonster_blue(DIRECTION::RIGHT);
		pBlue2->SetName(L"Blue");
		pBlue2->SetPos(972.f, 1448.f);
		pBlue2->SetScale(100.0f, 100.0f);
		SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::MONSTER_BLUE, pBlue2);
		SetOwner(pBlue2);
		pBlue2->begin();
		m_Time = 0.f;
	}
}

```

`GameClient/qSpawner_blue2.h`:

```h
#pragma once
#include "qObj.h"

class qSpawner_blue2 : public qObj
{
public:

	CLONE(qSpawner_blue2);

	qSpawner_blue2();
	~qSpawner_blue2();

public:
	virtual void begin() override;
	virtual void tick() override;




private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qSpawner_blue3.cpp`:

```cpp
#include "pch.h"
#include "qSpawner_blue3.h"

#include "qMonster_blue.h"
#include "qLevelMgr.h"

qSpawner_blue3::qSpawner_blue3()
	: m_Time(0.f)
{
}

qSpawner_blue3::~qSpawner_blue3()
{
}

void qSpawner_blue3::begin()
{
	qObj::begin();
}

void qSpawner_blue3::tick()
{
	qObj::tick();

	if (nullptr != GetOwner())
	{
		if (GetOwner()->IsDead())
		{
			SetOwner(nullptr);
		}
	}
	if (nullptr == GetOwner())
	{
		m_Time += DT;
	}

	if (m_Time > 5.f)
	{
		qObj* pBlue3 = new qMonster_blue(DIRECTION::LEFT);
		pBlue3->SetName(L"Blue");
		pBlue3->SetPos(543.f, 1448.f);
		pBlue3->SetScale(100.0f, 100.0f);
		SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::MONSTER_BLUE, pBlue3);
		SetOwner(pBlue3);
		pBlue3->begin();
		m_Time = 0.f;
	}
}

```

`GameClient/qSpawner_blue3.h`:

```h
#pragma once
#include "qObj.h"

class qSpawner_blue3 : public qObj
{
public:

	CLONE(qSpawner_blue3);

	qSpawner_blue3();
	~qSpawner_blue3();

public:
	virtual void begin() override;
	virtual void tick() override;




private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qSpawner_red1.cpp`:

```cpp
#include "pch.h"
#include "qSpawner_red1.h"

#include "qMonster_red.h"
#include "qLevelMgr.h"

qSpawner_red1::qSpawner_red1()
	: m_Time(0.f)
{
}

qSpawner_red1::~qSpawner_red1()
{
}

void qSpawner_red1::begin()
{
	qObj::begin();
}

void qSpawner_red1::tick()
{
	qObj::tick();

	if (nullptr != GetOwner())
	{
		if (GetOwner()->IsDead())
		{
			SetOwner(nullptr);
		}
	}
	if (nullptr == GetOwner())
	{
		m_Time += DT;
	}

	if (m_Time > 5.f)
	{
		qObj* pRed1 = new qMonster_red(DIRECTION::LEFT);
		pRed1->SetName(L"Red");
		pRed1->SetPos(1336.f, 1093.f);
		pRed1->SetScale(100.0f, 100.0f);
		SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::MONSTER_RED, pRed1);
		SetOwner(pRed1);
		pRed1->begin();
		m_Time = 0.f;
	}
}

```

`GameClient/qSpawner_red1.h`:

```h
#pragma once
#include "qObj.h"

class qSpawner_red1 : public qObj
{
public:

	CLONE(qSpawner_red1);

	qSpawner_red1();
	~qSpawner_red1();

public:
	virtual void begin() override;
	virtual void tick() override;




private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qSpawner_red2.cpp`:

```cpp
#include "pch.h"
#include "qSpawner_red2.h"

#include "qMonster_red.h"
#include "qLevelMgr.h"

qSpawner_red2::qSpawner_red2()
	: m_Time(0.f)
{
}

qSpawner_red2::~qSpawner_red2()
{
}

void qSpawner_red2::begin()
{
	qObj::begin();
}

void qSpawner_red2::tick()
{
	qObj::tick();

	if (nullptr != GetOwner())
	{
		if (GetOwner()->IsDead())
		{
			SetOwner(nullptr);
		}
	}
	if (nullptr == GetOwner())
	{
		m_Time += DT;
	}

	if (m_Time > 5.f)
	{
		qObj* pRed2 = new qMonster_red(DIRECTION::RIGHT);
		pRed2->SetName(L"Red");
		pRed2->SetPos(700.f, 1093.f);
		pRed2->SetScale(100.0f, 100.0f);
		SpawnObject(qLevelMgr::GetInst()->GetCurrentLevel(), LAYER_TYPE::MONSTER_RED, pRed2);
		SetOwner(pRed2);
		pRed2->begin();
		m_Time = 0.f;
	}
}

```

`GameClient/qSpawner_red2.h`:

```h
#pragma once
#include "qObj.h"

class qSpawner_red2 : public qObj
{
public:

	CLONE(qSpawner_red2);

	qSpawner_red2();
	~qSpawner_red2();

public:
	virtual void begin() override;
	virtual void tick() override;




private:
	Vec2		m_Pos;
	float		m_Time;
};


```

`GameClient/qState.cpp`:

```cpp
#include "pch.h"
#include "qState.h"

qState::qState()
	: m_Owner(nullptr)
{
}

qState::~qState()
{
}

void qState::init()
{
	if (nullptr == m_Animator || nullptr == m_Rigidbody || nullptr == m_Collider)
	{
		m_Animator = GetObj()->GetComponent<qAnimator>();
		m_Rigidbody = GetObj()->GetComponent<qRigidbody>();
		m_Collider = GetObj()->GetComponent<qCollider>();
	}

}

```

`GameClient/qState.h`:

```h
#pragma once
#include "qEntity.h"

#include "qFSM.h"

#include "qAnimation.h"
#include "qAnimator.h"
#include "qRigidbody.h"
#include "qCollider.h"

class qState : public qEntity
{
public:

	friend class qFSM;

	qState();
	~qState();

public:

	virtual void Enter() PURE;
	virtual void FinalTick() PURE;
	virtual void Exit() PURE;


protected:
	qObj* GetObj() { return m_Owner->GetOwner(); }
	qFSM* GetFSM() { return m_Owner; }

	template<typename T>
	T GetBlackboardData(const wstring& _DataName)
	{
		return m_Owner->GetBlackboardData<T>(_DataName);
	}

	void init();

public:
	void SetDir(DIRECTION _Dir) { m_Dir = _Dir; }
	DIRECTION GetDir() { return m_Dir; }

public:
	qAnimator* GetAnimator() { return m_Animator; }

private:
	DIRECTION		m_Dir;


private:
	qFSM*			m_Owner;
	qAnimator*		m_Animator;
	qRigidbody*		m_Rigidbody;
	qCollider*		m_Collider;
};


```

`GameClient/qTaskMgr.cpp`:

```cpp
#include "pch.h"
#include "qTaskMgr.h"

#include "qLevelMgr.h"
#include "qLevel.h"
#include "qObj.h"
#include "qUI.h"

qTaskMgr::qTaskMgr()
{

}

qTaskMgr::~qTaskMgr()
{

}


void qTaskMgr::tick()
{
	ClearGC();

	ExcuteTask();
}


void qTaskMgr::ClearGC()
{
	Safe_Del_Vec(m_GC);

	m_GC.clear();
}

void qTaskMgr::ExcuteTask()
{

	static bool bLevelChanged = false;
	bLevelChanged = false;

	for (size_t i = 0; i < m_vecTask.size(); ++i)
	{
		switch (m_vecTask[i].Type)
		{
		case TASK_TYPE::SPAWN_OBJECT:
		{
			qLevel* pSpawnLevel = (qLevel*)m_vecTask[i].Param1;
			LAYER_TYPE Layer = (LAYER_TYPE)m_vecTask[i].Param2;
			qObj* pObj = (qObj*)m_vecTask[i].Param3;

			if (qLevelMgr::GetInst()->GetCurrentLevel() != pSpawnLevel)
			{
				delete pObj;
			}
			pSpawnLevel->AddObject(Layer, pObj);
		}
		break;
		case TASK_TYPE::DELETE_OBJECT:
		{
			qObj* pObject = (qObj*)m_vecTask[i].Param1;

			if (pObject->m_bDead)
			{
				continue;
			}


			pObject->m_bDead = true;

			// GC 에서 수거
			m_GC.push_back(pObject);
		}

		break;
		case TASK_TYPE::CHANGE_LEVEL:
		{
			assert(!bLevelChanged);
			bLevelChanged = true;

			LEVEL_TYPE NextType = (LEVEL_TYPE)m_vecTask[i].Param1;
			qLevelMgr::GetInst()->ChangeLevel(NextType);
		}
		break;

		case TASK_TYPE::UI_LBTN_DOWN:
		{
			qUI* pUI = (qUI*)m_vecTask[i].Param1;
			bool bLbtnDown = (bool)m_vecTask[i].Param2;
			pUI->m_MouseLbtnDown = bLbtnDown;
		}
		break;
		}
	}

	m_vecTask.clear();
}

```

`GameClient/qTaskMgr.h`:

```h
#pragma once


class qTaskMgr
{
	SINGLE(qTaskMgr)

private:

	vector<tTask>	m_vecTask;
	vector<qObj*>	m_GC;	// Garbage Collector;

public:
	void tick();
	void AddTask(const tTask& _Task) { m_vecTask.push_back(_Task); }

private:
	void ClearGC();
	void ExcuteTask();
};


```

`GameClient/qTexture.cpp`:

```cpp
#include "pch.h"
#include "qTexture.h"
#include "qEngine.h"

qTexture::qTexture()
    : m_hDC{}
    , m_hBit{}
    , m_Info{}
{
}

qTexture::~qTexture()
{
    DeleteDC(m_hDC);
    DeleteObject(m_hBit);
}

int qTexture::Load(const wstring& _strFilePath)
{

    wchar_t szExt[50] = {};
    _wsplitpath_s(_strFilePath.c_str(), nullptr, 0, nullptr, 0, nullptr, 0, szExt, 50);

    if (!wcscmp(szExt, L".bmp") || !wcscmp(szExt, L".BMP"))
    {
        m_hBit = (HBITMAP)LoadImage(nullptr, _strFilePath.c_str()
            , IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);

        if (nullptr == m_hBit)
        {
            MessageBox(nullptr, L"비트맵 로딩 실패", L"Asset 로딩 실패", MB_OK);
            return E_FAIL;
        }
    }
    else if (!wcscmp(szExt, L".png") || !wcscmp(szExt, L".PNG"))
    {
        ULONG_PTR gdiplusToken = 0;
        GdiplusStartupInput gdiplusinput = {};
        GdiplusStartup(&gdiplusToken, &gdiplusinput, nullptr);

        Image* pImg = Image::FromFile(_strFilePath.c_str(), 0);
        Bitmap* pBitmap = (Bitmap*)pImg->Clone();
        Gdiplus::Status status = pBitmap->GetHBITMAP(Color(0, 0, 0, 0), &m_hBit);
        assert(status == Gdiplus::Status::Ok);
    }

    // 로드된 비트맵의 정보를 확인한다.
    GetObject(m_hBit, sizeof(BITMAP), &m_Info);

    // DC 를 생성시켜서 로드된 비트맵이랑 연결한다.
    m_hDC = CreateCompatibleDC(qEngine::GetInst()->GetMainDC());
    DeleteObject(SelectObject(m_hDC, m_hBit));

    return S_OK;
}

int qTexture::Create(UINT _Width, UINT _Height)
{
    // DC 생성
    m_hDC = CreateCompatibleDC(qEngine::GetInst()->GetMainDC());

    // Bitmap 생성
    m_hBit = CreateCompatibleBitmap(qEngine::GetInst()->GetMainDC(), _Width, _Height);

    // SubDC 가 SubBitmap 을 지정하게 함
    HBITMAP hPrevBitmap = (HBITMAP)SelectObject(m_hDC, m_hBit);
    DeleteObject(hPrevBitmap);

    // 로드된 비트맵의 정보를 확인한다.
    GetObject(m_hBit, sizeof(BITMAP), &m_Info);

    return S_OK;
}

```

`GameClient/qTexture.h`:

```h
#pragma once
#include "qAsset.h"

class qTexture : public qAsset
{
public:
	friend class qAssetMgr;

	qTexture();
	~qTexture();

public:
	virtual int Load(const wstring& _strFilePath) override;
	int Create(UINT _Width, UINT _Height);


public:
	HDC GetDC() { return m_hDC; }
	UINT GetWidth() { return m_Info.bmWidth; }
	UINT GetHeight() { return m_Info.bmHeight; }

private:
	HDC			m_hDC;
	HBITMAP		m_hBit;
	BITMAP		m_Info;

};


```

`GameClient/qTile.cpp`:

```cpp
#include "pch.h"
#include "qTile.h"

#include "qTileMap.h"
#include "qPathMgr.h"

qTile::qTile()
{
	m_TileMap = (qTileMap*)AddComponent(new qTileMap);
}

qTile::~qTile()
{
}

void qTile::begin()
{
}

void qTile::tick()
{
}

void qTile::render()
{
	m_TileMap->render();
}

void qTile::SetRow(UINT _Row)
{
	m_TileMap->SetRow(_Row);
}

void qTile::SetCol(UINT _Col)
{
	m_TileMap->SetCol(_Col);
}

void qTile::SetRowCol(UINT _Row, UINT _Col)
{
	m_TileMap->SetRowCol(_Row, _Col);
}

void qTile::SetAtlasTex(qTexture* _Atlas)
{
	m_TileMap->SetAtlasTex(_Atlas);
}

void qTile::Clicked(Vec2 _vMousePos)
{
	m_TileMap->Clicked(_vMousePos);
}

//void qTile::SaveToFile(const wstring& _RelativePath)
//{
//	wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
//	strFilePath += _RelativePath;
//
//	FILE* File = nullptr;
//	_wfopen_s(&File, strFilePath.c_str(), L"wb");
//
//	// 타일의 위치
//	Vec2 vPos = GetPos();
//	fwrite(&vPos, sizeof(Vec2), 1, File);
//
//	m_TileMap->SaveToFile(File);
//
//	fclose(File);
//}
//
//void qTile::LoadToFile(const wstring& _RelativePath)
//{
//	wstring strFilePath = qPathMgr::GetInst()->GetContentPath();
//	strFilePath += _RelativePath;
//
//	FILE* File = nullptr;
//	_wfopen_s(&File, strFilePath.c_str(), L"rb");
//
//	Vec2 vPos;
//	fread(&vPos, sizeof(Vec2), 1, File);
//	SetPos(vPos);
//
//	m_TileMap->LoadFromFile(File);
//
//	fclose(File);
//}

```

`GameClient/qTile.h`:

```h
#pragma once
#include "qObj.h"

class qTileMap;

class qTile : public qObj
{
public:
	CLONE(qTile);

public:
	qTile();
	~qTile();

private:
	virtual void begin() override;
	virtual void tick() override;
	virtual void render() override;

public:
	void SetRow(UINT _Row);
	void SetCol(UINT _Col);
	void SetRowCol(UINT _Row, UINT _Col);
	void SetAtlasTex(qTexture* _Atlas);

	void Clicked(Vec2 _vMousePos);


public:
	//void SaveToFile(const wstring& _RelativePath);
	//void LoadToFile(const wstring& _RelativePath);


private:
	qTileMap*	m_TileMap;


};


```

`GameClient/qTileMap.cpp`:

```cpp
#include "pch.h"
#include "qTileMap.h"

#include "qEngine.h"
#include "qDbgRender.h"

#include "qTexture.h"



qTileMap::qTileMap()
	: m_Row(1)
	, m_Col(1)
	, m_TileSize(Vec2(TILE_SIZE, TILE_SIZE))
	, m_AtlasTex(nullptr)
	, m_MaxImgRow(0)
	, m_MaxImgCol(0)
{
}

qTileMap::~qTileMap()
{
}

void qTileMap::finaltick()
{
}

void qTileMap::render()
{
	render_tile();

	if (qDbgRender::GetInst()->IsDbgRender())
	{
		render_grid();
	}
}




void qTileMap::render_grid()
{
	Vec2 vRenderPos = GetOwner()->GetRenderPos();

	USE_PEN(DC, PEN_TYPE::PEN_GREEN);
	USE_BRUSH(DC, BRUSH_TYPE::BRUSH_HOLLOW);

	for (UINT i = 0; i < m_Row; ++i)
	{
		for (UINT j = 0; j < m_Col; ++j)
		{
			Rectangle(DC, (int)(vRenderPos.x + m_TileSize.x * j), (int)(vRenderPos.y + m_TileSize.y * i),
				(int)(vRenderPos.x + m_TileSize.x * j + m_TileSize.x), (int)(vRenderPos.y + m_TileSize.y * i + m_TileSize.y));
		}
	}
}

void qTileMap::render_tile()
{
	if (nullptr == m_AtlasTex)
		return;

	Vec2 vRenderPos = GetOwner()->GetRenderPos();

	USE_PEN(DC, PEN_TYPE::PEN_GREEN);
	USE_BRUSH(DC, BRUSH_TYPE::BRUSH_HOLLOW);

	for (UINT i = 0; i < m_Row; ++i)
	{
		for (UINT j = 0; j < m_Col; ++j)
		{
			// 현재 i(행), j(열) 을 1차원 인덱스로 바꾸어서 렌더링하려는 타일의 정보를 Vector 에서 꺼내온다.
			int TileIdx = m_Col * i + j;

			// 해당 타일정보에서 이미지 인덱스를 확인하고, 아틀라스 텍스쳐에서 이미지 인덱스에 맞는 부위를 화면에 출력한다.
			UINT TileImgRow = m_vecTileInfo[TileIdx].ImgIdx / m_MaxImgCol;
			UINT TileImgCol = m_vecTileInfo[TileIdx].ImgIdx % m_MaxImgCol;

			// 해당 타일의 이미지 인덱스가 아틀라스가 보유한 타일 행, 열을 초과한 경우
			assert(!(m_MaxImgRow <= TileImgRow));

			BitBlt(DC, (int)(vRenderPos.x + m_TileSize.x * j)
				     , (int)(vRenderPos.y + m_TileSize.y * i)
				     , m_TileSize.x, m_TileSize.y
				     , m_AtlasTex->GetDC()
				     , TileImgCol * m_TileSize.x
				     , TileImgRow * m_TileSize.y, SRCCOPY);
		}
	}
}

void qTileMap::Clicked(Vec2 _vMousePos)
{
	// 마우스 좌표를 실제 게임 공간 좌표로 변경한다.
	_vMousePos = qCamera::GetInst()->GetRealPos(_vMousePos);

	// 클릭한 지점이 타일 영역을 벗어나 있으면 return 한다.
	Vec2 vObjPos = GetOwner()->GetPos();

	if (_vMousePos.x < vObjPos.x
		|| _vMousePos.y < vObjPos.y
		|| vObjPos.x + m_Col * m_TileSize.x < _vMousePos.x
		|| vObjPos.y + m_Row * m_TileSize.y < _vMousePos.y)
	{
		return;
	}

	// 타일 전체가 이동된 경우를 생각해서 마우스 위치를 보정해 준다.
	_vMousePos -= vObjPos;

	// 마우스로 클릭한 지점에 몇행 몇열인지 계산
	int ClickCol = (int)_vMousePos.x / m_TileSize.x;
	int ClickRow = (int)_vMousePos.y / m_TileSize.y;

	// 클릭한 지점의 타일을 1차원 인덱스로 변경해서 타일 벡터에서 해당 정보에 접근한다.
	int TileIdx = m_Col * ClickRow + ClickCol;

	// 해당 타일 정보에서 참조 이미지 인덱스를 1개 증가시킨다.
	m_vecTileInfo[TileIdx].ImgIdx += 1;

	// 만약 이미지 인덱스가, 아틀라스에서 제공하는 이미지 개수를 초과해서 참조하게 되면
	// 다시 첫번째 이미지를 참조하도록 이미지 인덱스를 0으로 설정한다.
	if (m_MaxImgCol * m_MaxImgRow <= m_vecTileInfo[TileIdx].ImgIdx)
	{
		m_vecTileInfo[TileIdx].ImgIdx = 0;
	}

}


void qTileMap::SetRow(UINT _Row)
{
	m_Row = _Row;
	m_vecTileInfo.clear();
	m_vecTileInfo.resize(m_Row * m_Col);
}

void qTileMap::SetCol(UINT _Col)
{
	m_Col = _Col;
	m_vecTileInfo.clear();
	m_vecTileInfo.resize(m_Row * m_Col);
}

void qTileMap::SetRowCol(UINT _Row, UINT _Col)
{
	m_Row = _Row;
	m_Col = _Col;

	m_vecTileInfo.clear();
	m_vecTileInfo.resize(m_Row * m_Col);
}

void qTileMap::SetAtlasTex(qTexture* _Atlas)
{
	m_AtlasTex = _Atlas;

	if (m_AtlasTex)
	{
		m_MaxImgCol = m_AtlasTex->GetWidth() / m_TileSize.x;
		m_MaxImgRow = m_AtlasTex->GetHeight() / m_TileSize.y;
	}
}


void qTileMap::SaveToFile(FILE* _File)
{
	fwrite(&m_Row, sizeof(UINT), 1, _File);
	fwrite(&m_Col, sizeof(UINT), 1, _File);
	fwrite(&m_TileSize, sizeof(Vec2), 1, _File);
	fwrite(m_vecTileInfo.data(), sizeof(tTileInfo), m_vecTileInfo.size(), _File);

	bool bAtlasTex = m_AtlasTex;
	fwrite(&bAtlasTex, sizeof(bool), 1, _File);

	if (bAtlasTex)
	{
		wstring strKey = m_AtlasTex->GetKey();
		wstring strRelativePath = m_AtlasTex->GetRelativePath();

		SaveWString(strKey, _File);
		SaveWString(strRelativePath, _File);
	}
}

void qTileMap::LoadPlatform(FILE* _File)
{
	fread(&m_Row, sizeof(UINT), 1, _File);
	fread(&m_Col, sizeof(UINT), 1, _File);
	fread(&m_TileSize, sizeof(Vec2), 1, _File);
	SetRowCol(m_Row, m_Col);
	fread(m_vecTileInfo.data(), sizeof(tTileInfo), m_vecTileInfo.size(), _File);

	bool bAtlasTex = m_AtlasTex;
	fread(&bAtlasTex, sizeof(bool), 1, _File);

	if (bAtlasTex)
	{
		wstring strKey, strRelativePath;

		LoadWString(strKey, _File);
		LoadWString(strRelativePath, _File);
		m_AtlasTex = qAssetMgr::GetInst()->LoadTexture(strKey, strRelativePath);

		SetAtlasTex(m_AtlasTex);
	}
}
```

`GameClient/qTileMap.h`:

```h
#pragma once
#include "qComponent.h"

struct tTileInfo
{
	int ImgIdx;

	tTileInfo()
		: ImgIdx(0)
	{}
};



class qTileMap : public qComponent
{
public:
	CLONE(qTileMap);

public:
	qTileMap();
	//qTileMap(const qTileMap& _Other);
	~qTileMap();


public:
	virtual void finaltick() override;
	void render();

	void SaveToFile(FILE* _File);
	void LoadPlatform(FILE* _File);

	
public:
	
	void SetRow(UINT _Row);
	void SetCol(UINT _Col);
	void SetRowCol(UINT _Row, UINT _Col);

	UINT GetRow() { return m_Row; }
	UINT GetCol() { return m_Col; }

	void SetAtlasTex(qTexture* _Atlas);
	qTexture* GetAtlasTex() { return m_AtlasTex; }

	void Clicked(Vec2 _vMousePos);
	

private:
	void render_grid();
	void render_tile();


private:
	UINT					m_Row;				// 행
	UINT					m_Col;				// 열
	Vec2					m_TileSize;			// 타일 개당 사이즈
	
	qTexture*				m_AtlasTex;			// 타일이 사용하는 아틀라스 텍스쳐
	UINT					m_MaxImgRow;		// 아틀라스 텍스쳐가 보유하고 있는 타일 이미지 세로(행) 개수
	UINT					m_MaxImgCol;		// 아틀라스 텍스쳐가 보유하고 있는 타일 이미지 가로(행) 개수

	vector<tTileInfo>		m_vecTileInfo;

};


```

`GameClient/qTimeMgr.cpp`:

```cpp
#include "pch.h"
#include "qTimeMgr.h"

#include "qEngine.h"


qTimeMgr::qTimeMgr()
	: m_llCurCount{}
	, m_llPrevCount{}
	, m_llFrequency{}
	, m_FPS(0)
	, m_DeltaTime(0.f)
	, m_Time(0.f)
{

}


qTimeMgr::~qTimeMgr()
{

}

void qTimeMgr::init()
{
	// 1초에 셀 수 있는 카운트 기준을 얻는다.
	QueryPerformanceFrequency(&m_llFrequency);

	QueryPerformanceCounter(&m_llCurCount);
	m_llPrevCount = m_llCurCount;
}

void qTimeMgr::tick()
{
	// 현재 카운트 계산
	QueryPerformanceCounter(&m_llCurCount);

	// 이전 카운트와 현재 카운트의 차이값을 통해서 1프레임 간의 시간값을 계산
	m_DeltaTime = (float)(m_llCurCount.QuadPart - m_llPrevCount.QuadPart) / (float)m_llFrequency.QuadPart;

	// DT 보정
	if (1.f / 60.f < m_DeltaTime)
		m_DeltaTime = 1.f / 60.f;

	// 누적시간을 통해서 프로그램이 실행된 이후로 지나간 시간값을 기록
	m_Time += m_DeltaTime;

	// 현재 카운트 값을 이전 카운트로 복사해둠
	m_llPrevCount = m_llCurCount;

	// 초당 실행 횟수 (FPS) 계산
	++m_FPS;

	// 1초에 한번씩 TextOut 출력
	static float AccTime = 0.f;
	AccTime += m_DeltaTime;

	if (1.f < AccTime)
	{
		WCHAR szBuff[255] = {};
		swprintf_s(szBuff, L"DeltaTime : %f, FPS : %d ", m_DeltaTime, m_FPS);
		SetWindowText(qEngine::GetInst()->GetMainWnd(), szBuff);
		AccTime = 0.f;
		m_FPS = 0;
	}
}

```

`GameClient/qTimeMgr.h`:

```h
#pragma once
class qTimeMgr
{
	SINGLE(qTimeMgr)

private:
	LARGE_INTEGER		m_llCurCount;
	LARGE_INTEGER		m_llPrevCount;
	LARGE_INTEGER		m_llFrequency;

	UINT				m_FPS;

	float				m_DeltaTime;		// 프레임 간격 시간 (1 프레임 실행하는데 걸리는 시간)
	float				m_Time;				// 프로그램이 켜진 이후로 진행된 시간


public:
	void init();
	void tick();

public:
	float GetDeltaTime() { return m_DeltaTime; }
	float GetTime() { return m_Time; }
	UINT GetFPS() { return m_FPS; }
};


```

`GameClient/qUI.cpp`:

```cpp
#include "pch.h"
#include "qUI.h"

#include "qTaskMgr.h"

qUI::qUI()
	: m_MouseOn(false)
	, m_MouseLbtnDown(false)
{
}

qUI::~qUI()
{
}

void qUI::tick()
{
	// FinalPos °č»ę
	m_vFinalPos = GetPos();

	CheckMouseOn();

	if (KEY_RELEASED(KEY::LBTN) && m_MouseLbtnDown)
	{
		qTaskMgr::GetInst()->AddTask(tTask{ TASK_TYPE::UI_LBTN_DOWN, (DWORD_PTR)this, false });
	}

	tick_ui();
}

void qUI::render()
{
	qObj::render();

	render_ui();


}

void qUI::render_ui()
{
	Vec2 vPos = GetFinalPos();
	Vec2 vScale = GetScale();
}

void qUI::CheckMouseOn()
{
	Vec2 vPos = GetPos();
	Vec2 vScale = GetScale();
	Vec2 vMousePos = qKeyMgr::GetInst()->GetMousePos();

	m_MouseOnPrev = m_MouseOn;

	if (vPos.x <= vMousePos.x && vMousePos.x <= vPos.x + vScale.x
		&& vPos.y <= vMousePos.y && vMousePos.y <= vPos.y + vScale.y)
	{
		m_MouseOn = true;
	}
	else
	{
		m_MouseOn = false;
	}
}

void qUI::LButtonDown()
{
	m_MouseLbtnDown = true;
}

void qUI::LButtonUp()
{
}

void qUI::LButtonClicked()
{
}



```

`GameClient/qUI.h`:

```h
#pragma once
#include "qObj.h"


class qUI : public qObj
{
public:
	friend class qTaskMgr;

public:
	qUI();
	~qUI();

public:
	virtual void tick() final;
	virtual void render() final;

	virtual void render_ui();
	virtual void tick_ui() = 0;

public:
	Vec2 GetFinalPos() { return m_vFinalPos; }

	bool IsMouseOn() { return m_MouseOn; }
	bool IsLbtnDowned() { return m_MouseLbtnDown; }

	void AddChildUI(qUI* _UI)
	{
		m_vecChildUI.push_back(_UI);
		_UI->m_ParentUI = this;
	}


public:
	virtual void LButtonDown();			// UI 에 마우스 왼쪽버튼 누른 경우
	virtual void LButtonUp();			// UI 에 마우스 왼쪽버튼 뗀 경우
	virtual void LButtonClicked();		// UI 에 마우스 왼쪽 버튼을 누르고, 뗀 경우


private:
	virtual void CheckMouseOn();

private:

	qUI*			m_ParentUI;
	vector<qUI*>	m_vecChildUI;

	Vec2			m_vFinalPos;

	bool			m_MouseOn;
	bool			m_MouseOnPrev;
	bool			m_MouseLbtnDown;
};


```

`GameClient/qUIMgr.cpp`:

```cpp
#include "pch.h"
#include "qUIMgr.h"

#include "qLevelMgr.h"
#include "qLevel.h"
#include "qUI.h"

qUIMgr::qUIMgr()
{
}


qUIMgr::~qUIMgr()
{
}

void qUIMgr::tick()
{
	// 마우스 상태 확인
	bool LBtnTap = KEY_TAP(KEY::LBTN);
	bool LBtnReleased = KEY_RELEASED(KEY::LBTN);

	// 현재 레벨에 있는 UI 들의 이벤트를 처리한다.
	qLevel* pCurLevel = qLevelMgr::GetInst()->GetCurrentLevel();
	if (nullptr == pCurLevel)
		return;

	const vector<qObj*>& vecUI = pCurLevel->GetObjects(LAYER_TYPE::UI);

	for (size_t i = 0; i < vecUI.size(); ++i) 
	{
		qUI* pUI = (qUI*)vecUI[i];

		//pUI = GetPriorityUI(pUI);

		// 왼쪽 버튼이 눌렸고, 그게 해당 UI 안에서 라면
		if (LBtnTap && pUI->IsMouseOn())
		{
			pUI->LButtonDown();
		}

		else if (LBtnReleased && pUI->IsMouseOn())
		{
			pUI->LButtonUp();

			if (pUI->IsLbtnDowned())
			{
				pUI->LButtonClicked();
			}
		}
	}




}

```

`GameClient/qUIMgr.h`:

```h
#pragma once
class qUIMgr
{
	SINGLE(qUIMgr);

public:
	void tick();
	
	void SetOwner(qObj* _Owner) { m_Owner = _Owner; }

private:

	qObj*		m_Owner;

};


```

`GameClient/struct.h`:

```h
#pragma once

struct Vec2
{
public:
	float x;
	float y;


public:

	bool IsZero()
	{
		return x == 0.f && y == 0.f;
	}

	// 빗변 구하는 공식
	float GetDistance(Vec2 _Other)
	{
		return sqrtf(powf(x - _Other.x, 2) + powf(y - _Other.y, 2));
	}

	// Length (빗변)
	float Length()
	{
		return sqrtf(x * x + y * y);
	}

	// 정규화
	void Normalize()
	{
		// 0, 0 벡터에 정규화를 하면 문제
		assert(!(x == 0.f && y == 0.f));

		float fLen = Length();
		x /= fLen;
		y /= fLen;
	}


public:
	Vec2 operator +(float f) { return Vec2(x + f, y + f); }
	Vec2 operator -(float f) { return Vec2(x - f, y - f); }
	Vec2 operator *(float f) { return Vec2(x * f, y * f); }
	Vec2 operator /(float f) { assert(f); return Vec2(x / f, y / f); }

	Vec2 operator + (Vec2 _Other) { return Vec2(x + _Other.x, y + _Other.y); }
	Vec2 operator - (Vec2 _Other) { return Vec2(x - _Other.x, y - _Other.y); }
	Vec2 operator * (Vec2 _Other) { return Vec2(x * _Other.x, y * _Other.y); }
	Vec2 operator / (Vec2 _Other) { assert(!(0.f == _Other.x || 0.f == _Other.y));  return Vec2(x / _Other.x, y / _Other.y); }


	void operator +=(float _f)
	{
		x += _f;
		y += _f;
	}

	void operator +=(Vec2 _Other)
	{
		x += _Other.x;
		y += _Other.y;
	}

	void operator -=(float _f)
	{
		x -= _f;
		y -= _f;
	}

	void operator -=(Vec2 _Other)
	{
		x -= _Other.x;
		y -= _Other.y;
	}

	void operator *=(float _f)
	{
		x *= _f;
		y *= _f;
	}

	void operator *=(Vec2 _Other)
	{
		x *= _Other.x;
		y *= _Other.y;
	}

	void operator /=(float _f)
	{
		assert(_f);

		x /= _f;
		y /= _f;
	}

	void operator /=(Vec2 _Other)
	{
		assert(_Other.x && _Other.y);

		x /= _Other.x;
		y /= _Other.y;
	}




public:
	Vec2()
		: x(0.f)
		, y(0.f)
	{

	}

	Vec2(float _x, float _y)
		: x(_x)
		, y(_y)
	{

	}

	Vec2(int _x, int _y)
		: x(float(_x))
		, y(float(_y))
	{

	}

	Vec2(POINT _pt)
		: x((float)_pt.x)
		, y((float)_pt.y)
	{

	}

	~Vec2()
	{

	}
};


struct tDbgRenderInfo
{
	DBG_SHAPE	Shape;
	Vec2		Position;
	Vec2		Scale;
	PEN_TYPE	Color;

	float		Duration;
	float		Age;
};


struct tDbgLog
{
	LOG_TYPE	Type;		// 로그의 종류
	wstring		strLog;		// 로그 메세지
	float		Age;		// 로그가 출력된 시간
};



struct tTask
{
	TASK_TYPE	Type;
	DWORD_PTR	Param1;		// 레벨종류
	DWORD_PTR	Param2;		// 레이어 타입
	DWORD_PTR	Param3;		// 스폰할 오브젝트

};


struct tInfo
{
	Vec2		StartPos;
	Vec2		EndPos;
};


```

`GameClient/targetver.h`:

```h
#pragma once

// // SDKDDKVer.h를 포함하면 최고 수준의 가용성을 가진 Windows 플랫폼이 정의됩니다.
// 이전 Windows 플랫폼용 애플리케이션을 빌드하려는 경우에는 SDKDDKVer.h를 포함하기 전에
// WinSDKVer.h를 포함하고 _WIN32_WINNT를 지원하려는 플랫폼으로 설정합니다.
#include <SDKDDKVer.h>

```

`OutputFile/content/animation/boss/ball/BossBallLeft.anim`:

```anim
[ANIMATION_NAME]
BossBallLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossBallLeft
[ATLAS_PATH]	texture\character\boss\ball\ball_left.png

[FRAME_COUNT]
17

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	550.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	1100.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1650.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	2200.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2750.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	3850.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	4950.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	5500.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	6050.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	6600.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	7150.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	7700.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	8250.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	8800.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		-47.000000  -52.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/ball/BossBallRight.anim`:

```anim
[ANIMATION_NAME]
BossBallRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossBallRight
[ATLAS_PATH]	texture\character\boss\ball\ball_right.png

[FRAME_COUNT]
17

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	550.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	1100.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1650.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	2200.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2750.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	3850.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	4950.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	5500.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	6050.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	6600.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	7150.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	7700.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	8250.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	8800.000000  0.000000
[SLICE_SIZE]		550.000000  350.000000
[OFFSET]		46.000000  -52.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/dead/BossDeadLeft.anim`:

```anim
[ANIMATION_NAME]
BossDeadLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossDeadLeft
[ATLAS_PATH]	texture\character\boss\dead\dead_left.png

[FRAME_COUNT]
29

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	1
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	2
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	3
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	4
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	5
[START_POS] 	1500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	6
[START_POS] 	1800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	7
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	8
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	9
[START_POS] 	2700.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	10
[START_POS] 	3000.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	11
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	12
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	13
[START_POS] 	3900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	14
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	15
[START_POS] 	4500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	16
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	17
[START_POS] 	5100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	18
[START_POS] 	5400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	19
[START_POS] 	5700.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	20
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	21
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	22
[START_POS] 	6600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	23
[START_POS] 	6900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	24
[START_POS] 	7200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	25
[START_POS] 	7500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	26
[START_POS] 	7800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	27
[START_POS] 	8100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	28
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		3.000000  -62.000000
[DURATION]  	0.125000


```

`OutputFile/content/animation/boss/dead/BossDeadRight.anim`:

```anim
[ANIMATION_NAME]
BossDeadRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossDeadRight
[ATLAS_PATH]	texture\character\boss\dead\dead_right.png

[FRAME_COUNT]
29

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	1
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	2
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	3
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	4
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	5
[START_POS] 	1500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	6
[START_POS] 	1800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	7
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	8
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	9
[START_POS] 	2700.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	10
[START_POS] 	3000.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	11
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	12
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	13
[START_POS] 	3900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	14
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	15
[START_POS] 	4500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	16
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	17
[START_POS] 	5100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	18
[START_POS] 	5400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	19
[START_POS] 	5700.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	20
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	21
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	22
[START_POS] 	6600.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	23
[START_POS] 	6900.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	24
[START_POS] 	7200.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	25
[START_POS] 	7500.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	26
[START_POS] 	7800.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	27
[START_POS] 	8100.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000

[FRAME_INDEX]	28
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		300.000000  310.000000
[OFFSET]		-4.000000  -62.000000
[DURATION]  	0.125000


```

`OutputFile/content/animation/boss/firebird/BossFirebirdLeft.anim`:

```anim
[ANIMATION_NAME]
BossFirebirdLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossFirebirdLeft
[ATLAS_PATH]	texture\character\boss\firebird\firebird_left.png

[FRAME_COUNT]
23

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	1800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	2200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	2600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	3000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	3400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	3800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	4000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		1.000000  -49.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/firebird/BossFirebirdRight.anim`:

```anim
[ANIMATION_NAME]
BossFirebirdRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossFirebirdRight
[ATLAS_PATH]	texture\character\boss\firebird\firebird_right.png

[FRAME_COUNT]
23

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	1800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	2200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	2600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	3000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	3400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	3800.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	4000.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		200.000000  300.000000
[OFFSET]		-2.000000  -49.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/genesis/BossGenesisLeft.anim`:

```anim
[ANIMATION_NAME]
BossGenesisLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossGenesisLeft
[ATLAS_PATH]	texture\character\boss\genesis\genesis_left.png

[FRAME_COUNT]
32

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	420.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	840.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1260.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1680.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	2520.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2940.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	3360.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	3780.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	4620.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	5040.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	5460.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	5880.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	6720.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	7140.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	7560.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	7980.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	8820.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	9240.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	23
[START_POS] 	9660.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	24
[START_POS] 	10080.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	25
[START_POS] 	10500.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	26
[START_POS] 	10920.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	27
[START_POS] 	11340.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	28
[START_POS] 	11760.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	29
[START_POS] 	12180.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	30
[START_POS] 	12600.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	31
[START_POS] 	13020.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		3.000000  -73.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/genesis/BossGenesisRight.anim`:

```anim
[ANIMATION_NAME]
BossGenesisRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossGenesisRight
[ATLAS_PATH]	texture\character\boss\genesis\genesis_right.png

[FRAME_COUNT]
32

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-3.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	420.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	840.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1260.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1680.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	2520.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2940.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	3360.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	3780.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	4620.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	5040.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	5460.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	5880.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	6720.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	7140.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	7560.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	7980.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	8820.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	9240.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	23
[START_POS] 	9660.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	24
[START_POS] 	10080.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	25
[START_POS] 	10500.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	26
[START_POS] 	10920.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	27
[START_POS] 	11340.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	28
[START_POS] 	11760.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	29
[START_POS] 	12180.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	30
[START_POS] 	12600.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000

[FRAME_INDEX]	31
[START_POS] 	13020.000000  0.000000
[SLICE_SIZE]		420.000000  360.000000
[OFFSET]		-4.000000  -73.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/idle/BossIdleLeft.anim`:

```anim
[ANIMATION_NAME]
BossIdleLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossIdleLeft
[ATLAS_PATH]	texture\character\boss\idle\idle_left.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	145.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	290.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	435.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	580.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	725.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	870.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1015.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		10.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/idle/BossIdleRight.anim`:

```anim
[ANIMATION_NAME]
BossIdleRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossIdleRight
[ATLAS_PATH]	texture\character\boss\idle\idle_right.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	145.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	290.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	435.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	580.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	725.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	870.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1015.000000  0.000000
[SLICE_SIZE]		145.000000  200.000000
[OFFSET]		-10.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/tornado/BossTornadoLeft.anim`:

```anim
[ANIMATION_NAME]
BossTornadoLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossTornadoLeft
[ATLAS_PATH]	texture\character\boss\tornado\tornado_left.png

[FRAME_COUNT]
26

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	4000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	5200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	5600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	6800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	7200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	7600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	8000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	8800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	23
[START_POS] 	9200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	24
[START_POS] 	9600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	25
[START_POS] 	10000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		-11.000000  -143.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss/tornado/BossTornadoRight.anim`:

```anim
[ANIMATION_NAME]
BossTornadoRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossTonardoRight
[ATLAS_PATH]	texture\character\boss\tornado\tornado_right.png

[FRAME_COUNT]
26

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	4000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	5200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	5600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	6800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	7200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	7600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	8000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	8800.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	23
[START_POS] 	9200.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	24
[START_POS] 	9600.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000

[FRAME_INDEX]	25
[START_POS] 	10000.000000  0.000000
[SLICE_SIZE]		400.000000  500.000000
[OFFSET]		10.000000  -143.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_damage/magic/DamageMagic.anim`:

```anim
[ANIMATION_NAME]
DamageMagic

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageMagic
[ATLAS_PATH]	texture\boss_damage\magic\magic.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	181.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	362.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	543.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	724.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	905.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1086.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1267.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	1448.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	1629.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	1810.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_damage/physical/DamagePhysical.anim`:

```anim
[ANIMATION_NAME]
DamagePhysical

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamagePhysical
[ATLAS_PATH]	texture\boss_damage\physical\physical.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	181.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	362.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	543.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	724.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	905.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1086.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1267.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	1448.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	1629.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	1810.000000  0.000000
[SLICE_SIZE]		181.000000  58.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_effect/ball/BallEffect.anim`:

```anim
[ANIMATION_NAME]
BallEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	BallEffect
[ATLAS_PATH]	texture\boss_effect\ball\ball.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1000.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_effect/firebird/FirebirdEffect.anim`:

```anim
[ANIMATION_NAME]
FirebirdEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	FirebirdEffect
[ATLAS_PATH]	texture\boss_effect\firebird\firebird.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	180.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	360.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	540.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	720.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		180.000000  180.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_effect/genesis/GenesisEffect.anim`:

```anim
[ANIMATION_NAME]
GenesisEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	GenesisEffect
[ATLAS_PATH]	texture\boss_effect\genesis\genesis.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1000.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_effect/tornado/TornadoEffect.anim`:

```anim
[ANIMATION_NAME]
TornadoEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	TornadoEffect
[ATLAS_PATH]	texture\boss_effect\tornado\tornado.png

[FRAME_COUNT]
7

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	130.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	260.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	390.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	520.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	650.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	780.000000  0.000000
[SLICE_SIZE]		130.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/ball/BossBallLeft.anim`:

```anim
[ANIMATION_NAME]
BossBallLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossBallLeft
[ATLAS_PATH]	texture\character\boss\ball\ball_left.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	160.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	320.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	480.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	640.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	960.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1120.000000  0.000000
[SLICE_SIZE]		160.000000  80.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/ball/BossSkillBallLeft.anim`:

```anim
[ANIMATION_NAME]
BossSkillBallLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossSkillBallLeft
[ATLAS_PATH]	texture\boss_skill\ball\ball_left.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	120.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	360.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	480.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	720.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	840.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/ball/BossSkillBallRight.anim`:

```anim
[ANIMATION_NAME]
BossSkillBallRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossSkillBallRight
[ATLAS_PATH]	texture\boss_skill\ball\ball_right.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	120.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	360.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	480.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	720.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	840.000000  0.000000
[SLICE_SIZE]		120.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/firebird/BossSkillFirebird.anim`:

```anim
[ANIMATION_NAME]
BossSkillFirebird

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossSkillFirebird
[ATLAS_PATH]	texture\boss_skill\firebird\firebird.png

[FRAME_COUNT]
20

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	700.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	1400.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	3500.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	4900.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	5600.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	7000.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	7700.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	8400.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	9100.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	9800.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	10500.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	11200.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	11900.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	12600.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	13300.000000  0.000000
[SLICE_SIZE]		700.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/genesis/BossSkillGenesis.anim`:

```anim
[ANIMATION_NAME]
BossSkillGenesis

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossSkillGenesis
[ATLAS_PATH]	texture\boss_skill\genesis\genesis.png

[FRAME_COUNT]
26

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1500.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1800.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2100.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2700.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	3000.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	3900.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	4200.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	4500.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	17
[START_POS] 	5100.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	18
[START_POS] 	5400.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	19
[START_POS] 	5700.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	20
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	21
[START_POS] 	6300.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	22
[START_POS] 	6600.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	23
[START_POS] 	6900.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	24
[START_POS] 	7200.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	25
[START_POS] 	7500.000000  0.000000
[SLICE_SIZE]		300.000000  590.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/boss_skill/tornado/BossSkillTornado.anim`:

```anim
[ANIMATION_NAME]
BossSkillTornado

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossSkillTornado
[ATLAS_PATH]	texture\boss_skill\tornado\tornado.png

[FRAME_COUNT]
14

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	265.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	530.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	795.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1060.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1325.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1590.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1855.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2120.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2385.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2650.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	2915.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	3180.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	3445.000000  0.000000
[SLICE_SIZE]		265.000000  600.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/bossenter/BossEnter.anim`:

```anim
[ANIMATION_NAME]
BossEnter

[ATLAS_TEXTURE]
[ATLAS_KEY]	BossEnter
[ATLAS_PATH]	texture\bossenter\bossenter.png

[FRAME_COUNT]
10

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	3
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	4
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	5
[START_POS] 	8000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	6
[START_POS] 	9600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	7
[START_POS] 	11200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	8
[START_POS] 	12800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333

[FRAME_INDEX]	9
[START_POS] 	14400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/damage/attack/DamageAttack.anim`:

```anim
[ANIMATION_NAME]
DamageAttack

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageAttack
[ATLAS_PATH]	texture\damage\attack\attack.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	258.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	516.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	774.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1032.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1290.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1548.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1806.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2064.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2322.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2580.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/damage/miss/DamageMiss.anim`:

```anim
[ANIMATION_NAME]
DamageMiss

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageMiss
[ATLAS_PATH]	texture\damage\miss\miss.png

[FRAME_COUNT]
5

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		140.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	140.000000  0.000000
[SLICE_SIZE]		140.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	280.000000  0.000000
[SLICE_SIZE]		140.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	420.000000  0.000000
[SLICE_SIZE]		140.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	560.000000  0.000000
[SLICE_SIZE]		140.000000  60.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/damage/missile/DamageMissile.anim`:

```anim
[ANIMATION_NAME]
DamageMissile

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageMissile
[ATLAS_PATH]	texture\damage\missile\missile.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	258.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	516.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	774.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1032.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1290.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1548.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1806.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2064.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2322.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2580.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/damage/slash/DamageSlash.anim`:

```anim
[ANIMATION_NAME]
DamageSlash

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageSlash
[ATLAS_PATH]	texture\damage\slash\slash.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	258.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	516.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	774.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1032.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1290.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1548.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1806.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2064.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2322.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	2580.000000  0.000000
[SLICE_SIZE]		258.000000  112.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/damage/special/DamageSpecial.anim`:

```anim
[ANIMATION_NAME]
DamageSpecial

[ATLAS_TEXTURE]
[ATLAS_KEY]	DamageSpecial
[ATLAS_PATH]	texture\damage\special\special.png

[FRAME_COUNT]
14

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	322.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	644.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	966.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1288.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1610.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1932.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2254.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2576.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2898.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	3220.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	3542.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	3864.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	4186.000000  0.000000
[SLICE_SIZE]		322.000000  216.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/effect/attack/AttackEffect.anim`:

```anim
[ANIMATION_NAME]
AttackEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	AttackEffect
[ATLAS_PATH]	texture\effect\attack\attack.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	150.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	450.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	750.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1050.000000  0.000000
[SLICE_SIZE]		150.000000  150.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/effect/missile/MissileEffect.anim`:

```anim
[ANIMATION_NAME]
MissileEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	MissileEffect
[ATLAS_PATH]	texture\effect\missile\missile.png

[FRAME_COUNT]
8

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	150.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	450.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	750.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	900.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	1050.000000  0.000000
[SLICE_SIZE]		150.000000  130.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/effect/slash/SlashEffect.anim`:

```anim
[ANIMATION_NAME]
SlashEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	SlashEffect
[ATLAS_PATH]	texture\effect\slash\slash.png

[FRAME_COUNT]
7

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	600.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1000.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		200.000000  200.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/effect/special/SpecialEffect.anim`:

```anim
[ANIMATION_NAME]
SpecialEffect

[ATLAS_TEXTURE]
[ATLAS_KEY]	SpecialEffect
[ATLAS_PATH]	texture\effect\special\special.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	330.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	660.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	990.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1320.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	1650.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	1980.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2310.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	2640.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	2970.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	3300.000000  0.000000
[SLICE_SIZE]		330.000000  345.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/logo/Logo.anim`:

```anim
[ANIMATION_NAME]
Logo

[ATLAS_TEXTURE]
[ATLAS_KEY]	Logo
[ATLAS_PATH]	texture\logo\logo.png

[FRAME_COUNT]
48

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	1
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	2
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	3
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	4
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	5
[START_POS] 	8000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	6
[START_POS] 	9600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	7
[START_POS] 	11200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	8
[START_POS] 	12800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	9
[START_POS] 	14400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	10
[START_POS] 	16000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	11
[START_POS] 	17600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	12
[START_POS] 	19200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	13
[START_POS] 	20800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	14
[START_POS] 	22400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	15
[START_POS] 	24000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	16
[START_POS] 	25600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	17
[START_POS] 	27200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	18
[START_POS] 	28800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	19
[START_POS] 	30400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	20
[START_POS] 	32000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	21
[START_POS] 	33600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	22
[START_POS] 	35200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	23
[START_POS] 	36800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	24
[START_POS] 	38400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	25
[START_POS] 	40000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	26
[START_POS] 	41600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	27
[START_POS] 	43200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	28
[START_POS] 	44800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	29
[START_POS] 	46400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	30
[START_POS] 	48000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	31
[START_POS] 	49600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	32
[START_POS] 	51200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	33
[START_POS] 	52800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	34
[START_POS] 	54400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	35
[START_POS] 	56000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	36
[START_POS] 	57600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	37
[START_POS] 	59200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	38
[START_POS] 	60800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	39
[START_POS] 	62400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	40
[START_POS] 	64000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	41
[START_POS] 	65600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	42
[START_POS] 	67200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	43
[START_POS] 	68800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	44
[START_POS] 	70400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	45
[START_POS] 	72000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	46
[START_POS] 	73600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429

[FRAME_INDEX]	47
[START_POS] 	75200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.071429


```

`OutputFile/content/animation/monster/blue/dead/BlueDeadLeft.anim`:

```anim
[ANIMATION_NAME]
BlueDeadLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueDeadLeft
[ATLAS_PATH]	texture\character\monster\blue\dead\blue_dead_left.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	1
[START_POS] 	93.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	2
[START_POS] 	186.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	3
[START_POS] 	279.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	4
[START_POS] 	372.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	5
[START_POS] 	465.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	6
[START_POS] 	558.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	7
[START_POS] 	651.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	8
[START_POS] 	744.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	9
[START_POS] 	837.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	10
[START_POS] 	930.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	11
[START_POS] 	1023.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000


```

`OutputFile/content/animation/monster/blue/dead/BlueDeadRight.anim`:

```anim
[ANIMATION_NAME]
BlueDeadRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueDeadRight
[ATLAS_PATH]	texture\character\monster\blue\dead\blue_dead_right.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	1
[START_POS] 	93.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	2
[START_POS] 	186.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	3
[START_POS] 	279.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	4
[START_POS] 	372.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	5
[START_POS] 	465.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	6
[START_POS] 	558.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	7
[START_POS] 	651.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	8
[START_POS] 	744.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	9
[START_POS] 	837.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	10
[START_POS] 	930.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000

[FRAME_INDEX]	11
[START_POS] 	1023.000000  0.000000
[SLICE_SIZE]		93.000000  93.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.125000


```

`OutputFile/content/animation/monster/blue/idle/BlueIdleLeft.anim`:

```anim
[ANIMATION_NAME]
BlueIdleLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueIdleLeft
[ATLAS_PATH]	texture\character\monster\blue\idle\blue_idle_left.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	60.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	120.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	180.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	4
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	5
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/monster/blue/idle/BlueIdleRight.anim`:

```anim
[ANIMATION_NAME]
BlueIdleRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueIdleRight
[ATLAS_PATH]	texture\character\monster\blue\idle\blue_idle_right.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	60.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	120.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	180.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	4
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	5
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		60.000000  82.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/monster/blue/move/BlueMoveLeft.anim`:

```anim
[ANIMATION_NAME]
BlueMoveLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueMoveLeft
[ATLAS_PATH]	texture\character\monster\blue\move\blue_move_left.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	1
[START_POS] 	65.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	2
[START_POS] 	130.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	3
[START_POS] 	195.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	4
[START_POS] 	260.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	5
[START_POS] 	325.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857


```

`OutputFile/content/animation/monster/blue/move/BlueMoveRight.anim`:

```anim
[ANIMATION_NAME]
BlueMoveRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	BlueMoveRight
[ATLAS_PATH]	texture\character\monster\blue\move\blue_move_right.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	1
[START_POS] 	65.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	2
[START_POS] 	130.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	3
[START_POS] 	195.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	4
[START_POS] 	260.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	5
[START_POS] 	325.000000  0.000000
[SLICE_SIZE]		65.000000  91.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857


```

`OutputFile/content/animation/monster/red/dead/RedDeadLeft.anim`:

```anim
[ANIMATION_NAME]
RedDeadLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedDeadLeft
[ATLAS_PATH]	texture\character\monster\red\dead\red_dead_left.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	82.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	164.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	246.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	328.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	410.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	492.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	574.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	656.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	738.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	820.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	902.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/monster/red/dead/RedDeadRight.anim`:

```anim
[ANIMATION_NAME]
RedDeadRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedDeadRight
[ATLAS_PATH]	texture\character\monster\red\dead\red_dead_right.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	82.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	164.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	246.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	328.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	410.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	492.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	574.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	656.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	738.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	820.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	902.000000  0.000000
[SLICE_SIZE]		82.000000  93.000000
[OFFSET]		0.000000  -10.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/monster/red/idle/RedIdleLeft.anim`:

```anim
[ANIMATION_NAME]
RedIdleLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedIdleLeft
[ATLAS_PATH]	texture\character\monster\red\idle\red_idle_left.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	57.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	114.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	171.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	4
[START_POS] 	228.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	5
[START_POS] 	285.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/monster/red/idle/RedIdleRight.anim`:

```anim
[ANIMATION_NAME]
RedIdleRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedIdleRight
[ATLAS_PATH]	texture\character\monster\red\idle\red_idle_right.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	57.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	114.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	171.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	4
[START_POS] 	228.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	5
[START_POS] 	285.000000  0.000000
[SLICE_SIZE]		57.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/monster/red/move/RedMoveLeft.anim`:

```anim
[ANIMATION_NAME]
RedMoveLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedMoveLeft
[ATLAS_PATH]	texture\character\monster\red\move\red_move_left.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	1
[START_POS] 	61.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	2
[START_POS] 	122.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	3
[START_POS] 	183.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	4
[START_POS] 	244.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	5
[START_POS] 	305.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857


```

`OutputFile/content/animation/monster/red/move/RedMoveRight.anim`:

```anim
[ANIMATION_NAME]
RedMoveRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	RedMoveRight
[ATLAS_PATH]	texture\character\monster\red\move\red_move_right.png

[FRAME_COUNT]
6

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	1
[START_POS] 	61.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	2
[START_POS] 	122.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	3
[START_POS] 	183.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	4
[START_POS] 	244.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857

[FRAME_INDEX]	5
[START_POS] 	305.000000  0.000000
[SLICE_SIZE]		61.000000  82.000000
[OFFSET]		0.000000  -5.000000
[DURATION]  	0.142857


```

`OutputFile/content/animation/player/attack/PlayerAttackLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerAttackLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerAttackLeft
[ATLAS_PATH]	texture\character\player\attack\attack_left.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667

[FRAME_INDEX]	1
[START_POS] 	223.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667

[FRAME_INDEX]	2
[START_POS] 	446.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667


```

`OutputFile/content/animation/player/attack/PlayerAttackRight.anim`:

```anim
[ANIMATION_NAME]
PlayerAttackRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerAttackRight
[ATLAS_PATH]	texture\character\player\attack\attack_right.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667

[FRAME_INDEX]	1
[START_POS] 	223.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667

[FRAME_INDEX]	2
[START_POS] 	446.000000  0.000000
[SLICE_SIZE]		223.000000  149.000000
[OFFSET]		0.000000  -20.000000
[DURATION]  	0.166667


```

`OutputFile/content/animation/player/down/PlayerDownLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerDownLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerDownLeft
[ATLAS_PATH]	texture\character\player\down\down_left.png

[FRAME_COUNT]
1

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		-23.000000  17.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/down/PlayerDownRight.anim`:

```anim
[ANIMATION_NAME]
PlayerDownRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerDownRight
[ATLAS_PATH]	texture\character\player\down\down_right.png

[FRAME_COUNT]
1

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		23.000000  17.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/down_attack/PlayerDownAttackLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerDownAttackLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerDownAttackLeft
[ATLAS_PATH]	texture\character\player\down_attack\down_attack_left.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		-23.000000  17.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	132.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		-23.000000  17.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	264.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		-23.000000  17.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/down_attack/PlayerDownAttackRight.anim`:

```anim
[ANIMATION_NAME]
PlayerDownAttackRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerDownAttackRight
[ATLAS_PATH]	texture\character\player\down_attack\down_attack_right.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		23.000000  17.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	132.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		23.000000  17.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	264.000000  0.000000
[SLICE_SIZE]		132.000000  67.000000
[OFFSET]		23.000000  17.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/idle/PlayerIdleLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerIdleLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerIdleLeft
[ATLAS_PATH]	texture\character\player\idle\idle_left.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		-20.000000  -6.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	114.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		-20.000000  -6.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	228.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		-20.000000  -6.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/idle/PlayerIdleRight.anim`:

```anim
[ANIMATION_NAME]
PlayerIdleRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerIdleRight
[ATLAS_PATH]	texture\character\player\idle\idle_right.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		20.000000  -6.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	114.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		20.000000  -6.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	228.000000  0.000000
[SLICE_SIZE]		114.000000  78.000000
[OFFSET]		20.000000  -6.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/jump/PlayerJumpLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerJumpLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerJumpLeft
[ATLAS_PATH]	texture\character\player\jump\jump_left.png

[FRAME_COUNT]
1

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		60.000000  100.000000
[OFFSET]		14.000000  -5.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/jump/PlayerJumpRight.anim`:

```anim
[ANIMATION_NAME]
PlayerJumpRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerJumpRight
[ATLAS_PATH]	texture\character\player\jump\jump_right.png

[FRAME_COUNT]
1

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		60.000000  100.000000
[OFFSET]		-14.000000  -5.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/missile/PlayerMissileLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerMissileLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerMissileLeft
[ATLAS_PATH]	texture\character\player\missile\missile_left.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000

[FRAME_INDEX]	1
[START_POS] 	227.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000

[FRAME_INDEX]	2
[START_POS] 	454.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000


```

`OutputFile/content/animation/player/missile/PlayerMissileRight.anim`:

```anim
[ANIMATION_NAME]
PlayerMissileRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerMissileRight
[ATLAS_PATH]	texture\character\player\missile\missile_right.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000

[FRAME_INDEX]	1
[START_POS] 	227.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000

[FRAME_INDEX]	2
[START_POS] 	454.000000  0.000000
[SLICE_SIZE]		227.000000  140.000000
[OFFSET]		0.000000  -23.000000
[DURATION]  	0.130000


```

`OutputFile/content/animation/player/move/PlayerMoveLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerMoveLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerMoveLeft
[ATLAS_PATH]	texture\character\player\move\move_left.png

[FRAME_COUNT]
4

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		-20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	110.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		-20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	220.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		-20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	3
[START_POS] 	330.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		-20.000000  -4.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/move/PlayerMoveRight.anim`:

```anim
[ANIMATION_NAME]
PlayerMoveRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerMoveRight
[ATLAS_PATH]	texture\character\player\move\move_right.png

[FRAME_COUNT]
4

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	1
[START_POS] 	110.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	2
[START_POS] 	220.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		20.000000  -4.000000
[DURATION]  	0.333333

[FRAME_INDEX]	3
[START_POS] 	330.000000  0.000000
[SLICE_SIZE]		110.000000  84.000000
[OFFSET]		20.000000  -4.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/rope/PlayerRope.anim`:

```anim
[ANIMATION_NAME]
PlayerRope

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerRope
[ATLAS_PATH]	texture\character\player\rope\rope.png

[FRAME_COUNT]
1

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		72.000000  81.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.333333


```

`OutputFile/content/animation/player/slash/PlayerSlashLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerSlashLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerSlashLeft
[ATLAS_PATH]	texture\character\player\slash\slash_left.png

[FRAME_COUNT]
2

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		182.000000  78.000000
[OFFSET]		-35.000000  -5.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	182.000000  0.000000
[SLICE_SIZE]		182.000000  78.000000
[OFFSET]		-35.000000  -5.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/player/slash/PlayerSlashRight.anim`:

```anim
[ANIMATION_NAME]
PlayerSlashRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerSlashRight
[ATLAS_PATH]	texture\character\player\slash\slash_right.png

[FRAME_COUNT]
2

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		182.000000  78.000000
[OFFSET]		35.000000  -5.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	182.000000  0.000000
[SLICE_SIZE]		182.000000  78.000000
[OFFSET]		35.000000  -5.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/player/special/PlayerSpecialLeft.anim`:

```anim
[ANIMATION_NAME]
PlayerSpecialLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerSpecialLeft
[ATLAS_PATH]	texture\character\player\special\special_left.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667

[FRAME_INDEX]	1
[START_POS] 	188.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667

[FRAME_INDEX]	2
[START_POS] 	376.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667


```

`OutputFile/content/animation/player/special/PlayerSpecialRight.anim`:

```anim
[ANIMATION_NAME]
PlayerSpecialRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	PlayerSpecialRight
[ATLAS_PATH]	texture\character\player\special\special_right.png

[FRAME_COUNT]
3

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667

[FRAME_INDEX]	1
[START_POS] 	188.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667

[FRAME_INDEX]	2
[START_POS] 	376.000000  0.000000
[SLICE_SIZE]		188.000000  148.000000
[OFFSET]		0.000000  -3.000000
[DURATION]  	0.166667


```

`OutputFile/content/animation/skill/attack/AttackLeft.anim`:

```anim
[ANIMATION_NAME]
AttackLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	AttackLeft
[ATLAS_PATH]	texture\skill\attack\attack_left.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	410.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	820.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	1230.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	1640.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	2050.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	2460.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	2870.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	3280.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	3690.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	4100.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	11
[START_POS] 	4510.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/attack/AttackRight.anim`:

```anim
[ANIMATION_NAME]
AttackRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	AttackRight
[ATLAS_PATH]	texture\skill\attack\attack_right.png

[FRAME_COUNT]
12

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	410.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	820.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	1230.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	1640.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	2050.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	2460.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	2870.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	3280.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	3690.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	4100.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	11
[START_POS] 	4510.000000  0.000000
[SLICE_SIZE]		410.000000  240.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/buff/Buff.anim`:

```anim
[ANIMATION_NAME]
Buff

[ATLAS_TEXTURE]
[ATLAS_KEY]	Buff
[ATLAS_PATH]	texture\skill\buff\buff.png

[FRAME_COUNT]
17

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	1
[START_POS] 	400.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	2
[START_POS] 	800.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	3
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	4
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	5
[START_POS] 	2000.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	6
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	7
[START_POS] 	2800.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	8
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	9
[START_POS] 	3600.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	10
[START_POS] 	4000.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	11
[START_POS] 	4400.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	12
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	13
[START_POS] 	5200.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	14
[START_POS] 	5600.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	15
[START_POS] 	6000.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000

[FRAME_INDEX]	16
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		400.000000  400.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.100000


```

`OutputFile/content/animation/skill/doublejump/DoubleJumpLeft.anim`:

```anim
[ANIMATION_NAME]
DoubleJumpLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	DoubleJumpLeft
[ATLAS_PATH]	texture\skill\doublejump\doublejump_left.png

[FRAME_COUNT]
10

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	255.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	510.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	765.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	1020.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	1275.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	1530.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	1785.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	2040.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	2295.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/doublejump/DoubleJumpRight.anim`:

```anim
[ANIMATION_NAME]
DoubleJumpRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	DoubleJumpRight
[ATLAS_PATH]	texture\skill\doublejump\doublejump_right.png

[FRAME_COUNT]
10

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	255.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	510.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	765.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	1020.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	1275.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	1530.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	1785.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	2040.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	2295.000000  0.000000
[SLICE_SIZE]		255.000000  185.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/highjump/HighJump.anim`:

```anim
[ANIMATION_NAME]
HighJump

[ATLAS_TEXTURE]
[ATLAS_KEY]	HighJump
[ATLAS_PATH]	texture\skill\highjump\highjump.png

[FRAME_COUNT]
10

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	185.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	370.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	555.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	740.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	925.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	1110.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	1295.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	1480.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	1665.000000  0.000000
[SLICE_SIZE]		185.000000  255.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/missile/MissileBallLeft.anim`:

```anim
[ANIMATION_NAME]
MissileBallLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	MissileBallLeft
[ATLAS_PATH]	texture\skill\missile\missile_ball_left.png

[FRAME_COUNT]
4

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	100.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/skill/missile/MissileBallRight.anim`:

```anim
[ANIMATION_NAME]
MissileBallRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	MissileBallRight
[ATLAS_PATH]	texture\skill\missile\missile_ball_right.png

[FRAME_COUNT]
4

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	100.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	200.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	300.000000  0.000000
[SLICE_SIZE]		100.000000  70.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`OutputFile/content/animation/skill/missile/MissileLeft.anim`:

```anim
[ANIMATION_NAME]
MissileLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	MissileLeft
[ATLAS_PATH]	texture\skill\missile\missile_left.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	480.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	720.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	960.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	1440.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	1680.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	1920.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	2160.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/missile/MissileRight.anim`:

```anim
[ANIMATION_NAME]
MissileRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	MissileRight
[ATLAS_PATH]	texture\skill\missile\missile_right.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	240.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	480.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	720.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	960.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	1200.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	1440.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	1680.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	1920.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	2160.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	2400.000000  0.000000
[SLICE_SIZE]		240.000000  195.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/slash/SlashLeft.anim`:

```anim
[ANIMATION_NAME]
SlashLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	SlashLeft
[ATLAS_PATH]	texture\skill\slash\slash_left.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	675.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	1350.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	2025.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	2700.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	3375.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	4050.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	4725.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	5400.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	6075.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	6750.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/slash/SlashRight.anim`:

```anim
[ANIMATION_NAME]
SlashRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	SlashRight
[ATLAS_PATH]	texture\skill\slash\slash_right.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	675.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	1350.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	2025.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	2700.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	3375.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	4050.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	4725.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	5400.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	6075.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	6750.000000  0.000000
[SLICE_SIZE]		675.000000  215.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/special/SpecialLeft.anim`:

```anim
[ANIMATION_NAME]
SpecialLeft

[ATLAS_TEXTURE]
[ATLAS_KEY]	SpecialLeft
[ATLAS_PATH]	texture\skill\special\special_left.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	580.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	1160.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	1740.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	2320.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	2900.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	3480.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	4060.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	4640.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	5220.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	5800.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/skill/special/SpecialRight.anim`:

```anim
[ANIMATION_NAME]
SpecialRight

[ATLAS_TEXTURE]
[ATLAS_KEY]	SpecialRight
[ATLAS_PATH]	texture\skill\special\special_right.png

[FRAME_COUNT]
11

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	1
[START_POS] 	580.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	2
[START_POS] 	1160.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	3
[START_POS] 	1740.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	4
[START_POS] 	2320.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	5
[START_POS] 	2900.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	6
[START_POS] 	3480.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	7
[START_POS] 	4060.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	8
[START_POS] 	4640.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	9
[START_POS] 	5220.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923

[FRAME_INDEX]	10
[START_POS] 	5800.000000  0.000000
[SLICE_SIZE]		580.000000  450.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.076923


```

`OutputFile/content/animation/start/Start.anim`:

```anim
[ANIMATION_NAME]
Start

[ATLAS_TEXTURE]
[ATLAS_KEY]	Start
[ATLAS_PATH]	texture\start\start.png

[FRAME_COUNT]
20

[FRAME_INDEX]	0
[START_POS] 	0.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	1
[START_POS] 	1600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	2
[START_POS] 	3200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	3
[START_POS] 	4800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	4
[START_POS] 	6400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	5
[START_POS] 	8000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	6
[START_POS] 	9600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	7
[START_POS] 	11200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	8
[START_POS] 	12800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	9
[START_POS] 	14400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	10
[START_POS] 	16000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	11
[START_POS] 	17600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	12
[START_POS] 	19200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	13
[START_POS] 	20800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	14
[START_POS] 	22400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	15
[START_POS] 	24000.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	16
[START_POS] 	25600.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	17
[START_POS] 	27200.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	18
[START_POS] 	28800.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000

[FRAME_INDEX]	19
[START_POS] 	30400.000000  0.000000
[SLICE_SIZE]		1600.000000  900.000000
[OFFSET]		0.000000  0.000000
[DURATION]  	0.200000


```

`QueueWinAPI.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34316.72
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GameClient", "GameClient\GameClient.vcxproj", "{C8A4F312-92FD-4C30-ADDF-EA041231B855}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Debug|x64.ActiveCfg = Debug|x64
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Debug|x64.Build.0 = Debug|x64
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Debug|x86.ActiveCfg = Debug|Win32
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Debug|x86.Build.0 = Debug|Win32
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Release|x64.ActiveCfg = Release|x64
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Release|x64.Build.0 = Release|x64
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Release|x86.ActiveCfg = Release|Win32
		{C8A4F312-92FD-4C30-ADDF-EA041231B855}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7C2CC878-66F9-4A55-A1D6-FE6A72BF71CA}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
![image](https://github.com/P2nkrose/WinAPI_MapleStory/assets/124218203/021ef96c-90de-4a48-b151-9151451aa1d1)

<h1>Copycat’s Maple Story</h1>

> Windows API를 활용한 2D Game Copy Project


### 프로젝트 개요

---

|  📋 프로젝트 이름 | Copycat’s Maple Story |
| --- | --- |
|  🗓️ 프로젝트 기간 | 2024.03-2024.04 |
|  🛠️ 개발 환경 및 언어 | C++
||Windows API
||Visual Studio 2022 |
| 👥 멤버 | 김도규  @부트 스프링   |

```
2003년 출시된 메이플스토리의 모작으로, C++, Windows API를 활용해 제작했습니다.
개발자는 Collider Tool을 통해서 Platform의 지형을 직접 설정할수 있고, Monster Tool을 
이용해 몬스터를 해당 위치에 직접 배치할 수 있으며, Atlas Texture를 가져와 
애니메이션을 제작할 수 있는 기능을 추가했습니다.

직관적인 인터페이스를 통해 개발 효율성과 확장성을 증가시켰습니다.
또 원작 게임의 컨텐츠를 차용하여, 사용자는 스킬 사용을 통한 몬스터 사냥, 보스레이드 등
Ability의 성장을 경험할 수 있습니다.
```



### 프로젝트 설명

---

**게임 설명**


| 게임명 | 메이플스토리 |
| --- | --- |
| 개발 / 출시 | 위젯스튜디오 (넥슨) / 2003년 4월 29일 |
| 플랫폼 | PC (Microsoft Windows) |
| 장르 | 2D 횡스크롤 MMORPG |

**프로젝트에 반영된 게임의 특징**

- 게임 플레이 및 매커니즘

```
메이플 스토리는 좌/우/점프키를 활용하는
2D 횡스크롤 게임입니다.

캐릭터가 갖고있는 고유 스킬을 활용하여
필드의 몬스터를 사냥하며, Exp를 얻게 됩니다.
Exp가 일정게이지까지 오르면 레벨업을 하며
보스 스테이지는 다양한 보스의 패턴을 피하며
클리어를 할 수 있습니다.
```

- 스테이지

```
원작 게임을 고증하여 게임 시작 시 Nexon 로고,
월드맵 선택 화면에서 서버를 선택할수 있습니다.

스테이지는 총 4개로 구성되어 있으며,
배경은 직업군의 시작마을인 「퀸스로드」입니다.
마을로 시작하여 사냥터 스테이지, 보스로 이동
하는 스테이지, 보스 스테이지로 구성됩니다.
```

- 캐릭터

```
게임 플레이에 사용되는 캐릭터는
「시그너스」직업군의 소울마스터 입니다.
캐릭터는 하나만 선택할수 있으며, 5개의 스킬을
사용할 수 있습니다.
* 버프스킬/기본스킬/원거리스킬/이동스킬/필살

캐릭터는 기본이동 외 2단 점프 및 대시를
사용하여 이동할수 있습니다.
```

- 몬스터 및 보스

```
원작 게임과 동일한 느낌을 주기 위하여
「퀸스로드 수련의 숲」에 분포된 몬스터 2종을
그대로 구현하였습니다.
몬스터가 죽으면, 일정 시간 후 Respawn 되며,
캐릭터는 Exp를 획득할 수 있습니다.

보스는 시그너스이며, 4개의 패턴을 구현합니다.
```


**프로젝트 설명**

<aside>
🛠 손쉽게 Collider, 몬스터 배치가 가능한 Edit Tool

</aside>

- Collider Edit Tool
    
    
    | 개요 | 맵을 구성하는 Platform과 Rope, Portal 등을 스테이지 별 알맞는               에셋에 따른 Spawn Position을 지정할 수 있는 모드 |
    | --- | --- |
    | 세부 기능 | - Level 내 Background Object에 맞는 Platform, Rope 및 기타 Collider를              Drag &  Drop을 통한 편리한 위치 지정 |
    - Collider Edit Tool 구현
        
        [동영상 첨부]
        

- Monster deploy Edit Tool
    
    
    | 개요 | 해당 Level에 맞는 Field의 몬스터를, 마우스 클릭으로 deploy 하는 모드 |
    | --- | --- |
    | 세부 기능 | - Level 내 Background Object에 맞는 몬스터의 위치를, 마우스클릭으로   해당 MousePos의 위치로 몬스터가 Spawn되게 지정 |
    - Monster deploy Edit Tool 구현
        
        [동영상 첨부]
        

<aside>
🍄 원작 ‘메이플스토리’의 플레이 방식 / 컨텐츠를 재현

</aside>

- 조작 방식
    
    
    | 상호작용 | MOVE | DOWN / ATTACK | ROPE |
    | --- | --- | --- | --- |
    | 키보드 | ⬅️ ➡️ | ⬇️ + CTRL | ⬆️ ⬇️ |
    | 상호작용 | SKILL | (DOUBLE)  JUMP | JUMP DASH |
    | 키보드 | A S D F G  | SPACE BAR  | SPACE BAR  + ⬅️ ➡️ + SPACE BAR  |

```