Project Path: arc_gmh5225_dwmhook_0y3wcgzb

Source Tree:

```txt
arc_gmh5225_dwmhook_0y3wcgzb
├── README.md
├── dwmhook
│   ├── FW1
│   │   ├── CFW1ColorRGBA.cpp
│   │   ├── CFW1ColorRGBA.h
│   │   ├── CFW1ColorRGBAInterface.cpp
│   │   ├── CFW1DWriteRenderTarget.cpp
│   │   ├── CFW1DWriteRenderTarget.h
│   │   ├── CFW1DWriteRenderTargetInterface.cpp
│   │   ├── CFW1Factory.cpp
│   │   ├── CFW1Factory.h
│   │   ├── CFW1FactoryInterface.cpp
│   │   ├── CFW1FontWrapper.cpp
│   │   ├── CFW1FontWrapper.h
│   │   ├── CFW1FontWrapperInterface.cpp
│   │   ├── CFW1GlyphAtlas.cpp
│   │   ├── CFW1GlyphAtlas.h
│   │   ├── CFW1GlyphAtlasInterface.cpp
│   │   ├── CFW1GlyphProvider.cpp
│   │   ├── CFW1GlyphProvider.h
│   │   ├── CFW1GlyphProviderInterface.cpp
│   │   ├── CFW1GlyphRenderStates.cpp
│   │   ├── CFW1GlyphRenderStates.h
│   │   ├── CFW1GlyphRenderStatesInterface.cpp
│   │   ├── CFW1GlyphSheet.cpp
│   │   ├── CFW1GlyphSheet.h
│   │   ├── CFW1GlyphSheetInterface.cpp
│   │   ├── CFW1GlyphVertexDrawer.cpp
│   │   ├── CFW1GlyphVertexDrawer.h
│   │   ├── CFW1GlyphVertexDrawerInterface.cpp
│   │   ├── CFW1Object.h
│   │   ├── CFW1StateSaver.cpp
│   │   ├── CFW1StateSaver.h
│   │   ├── CFW1TextGeometry.cpp
│   │   ├── CFW1TextGeometry.h
│   │   ├── CFW1TextGeometryInterface.cpp
│   │   ├── CFW1TextRenderer.cpp
│   │   ├── CFW1TextRenderer.h
│   │   ├── CFW1TextRendererInterface.cpp
│   │   ├── FW1CompileSettings.h
│   │   ├── FW1FontWrapper.cpp
│   │   ├── FW1FontWrapper.h
│   │   ├── FW1Precompiled.cpp
│   │   └── FW1Precompiled.h
│   ├── MinHook.h
│   ├── ck.h
│   ├── dwmhook.vcxproj
│   ├── dwmhook.vcxproj.filters
│   ├── includes.hpp
│   ├── main.cpp
│   ├── minhook-debug.lib
│   ├── minhook.lib
│   ├── render.cpp
│   ├── render.hpp
│   ├── save_state.cpp
│   └── save_state.hpp
└── dwmhook.sln

```

`README.md`:

```md
# dwmhook
Not my code. only for saving

```
d2d1.DrawingContext::PresentDWM
d2d1.DrawingContext::PresentMultiplaneOverlay
```

```

`dwmhook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30104.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dwmhook", "dwmhook\dwmhook.vcxproj", "{BF574599-3CE2-4360-B229-D747272D45CF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BF574599-3CE2-4360-B229-D747272D45CF}.Debug|x64.ActiveCfg = Debug|x64
		{BF574599-3CE2-4360-B229-D747272D45CF}.Debug|x64.Build.0 = Debug|x64
		{BF574599-3CE2-4360-B229-D747272D45CF}.Release|x64.ActiveCfg = Release|x64
		{BF574599-3CE2-4360-B229-D747272D45CF}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {51E0A73F-C664-4A65-85CA-663F187C0F94}
	EndGlobalSection
EndGlobal

```

`dwmhook/FW1/CFW1ColorRGBA.cpp`:

```cpp
// CFW1ColorRGBA.cpp

#include "FW1Precompiled.h"

#include "CFW1ColorRGBA.h"


namespace FW1FontWrapper {


// Construct
CFW1ColorRGBA::CFW1ColorRGBA() :
	m_color32(0xffffffff)
{
}


// Destruct
CFW1ColorRGBA::~CFW1ColorRGBA() {
}


// Init
HRESULT CFW1ColorRGBA::initColor(IFW1Factory *pFW1Factory, UINT32 initialColor32) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	m_color32 = initialColor32;
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1ColorRGBA.h`:

```h
// CFW1ColorRGBA.h

#ifndef IncludeGuard__FW1_CFW1ColorRGBA
#define IncludeGuard__FW1_CFW1ColorRGBA

#include "CFW1Object.h"


namespace FW1FontWrapper {


// A color
class CFW1ColorRGBA : public CFW1Object<IFW1ColorRGBA> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1Color32
		virtual void STDMETHODCALLTYPE SetColor(UINT32 Color);
		virtual void STDMETHODCALLTYPE SetColor(FLOAT Red, FLOAT Green, FLOAT Blue, FLOAT Alpha);
		virtual void STDMETHODCALLTYPE SetColor(const FLOAT *pColor);
		virtual void STDMETHODCALLTYPE SetColor(const BYTE *pColor);
		
		virtual UINT32 STDMETHODCALLTYPE GetColor32();
	
	// Public functions
	public:
		CFW1ColorRGBA();
		
		HRESULT initColor(IFW1Factory *pFW1Factory, UINT32 initialColor32);
	
	// Internal functions
	private:
		virtual ~CFW1ColorRGBA();
	
	// Internal data
	private:
		UINT32						m_color32;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1ColorRGBA

```

`dwmhook/FW1/CFW1ColorRGBAInterface.cpp`:

```cpp
// CFW1ColorRGBAInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1ColorRGBA.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1ColorRGBA::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1ColorRGBA))) {
		*ppvObject = static_cast<IFW1ColorRGBA*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(UINT32 Color) {
	m_color32 = Color;
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(FLOAT Red, FLOAT Green, FLOAT Blue, FLOAT Alpha) {
	UINT32 color32;
	BYTE *colorBytes = reinterpret_cast<BYTE*>(&color32);
	colorBytes[0] = static_cast<BYTE>(Red * 255.0f + 0.5f);
	colorBytes[1] = static_cast<BYTE>(Green * 255.0f + 0.5f);
	colorBytes[2] = static_cast<BYTE>(Blue * 255.0f + 0.5f);
	colorBytes[3] = static_cast<BYTE>(Alpha * 255.0f + 0.5f);
	
	m_color32 = color32;
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(const FLOAT *pColor) {
	SetColor(pColor[0], pColor[1], pColor[2], pColor[3]);
}


// Set the color
void STDMETHODCALLTYPE CFW1ColorRGBA::SetColor(const BYTE *pColor) {
	UINT32 color32;
	BYTE *colorBytes = reinterpret_cast<BYTE*>(&color32);
	for(int i=0; i < 4; ++i)
		colorBytes[i] = pColor[i];
	
	m_color32 = color32;
}


// Get the color
UINT32 STDMETHODCALLTYPE CFW1ColorRGBA::GetColor32() {
	return m_color32;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1DWriteRenderTarget.cpp`:

```cpp
// CFW1DWriteRenderTarget.cpp

#include "FW1Precompiled.h"

#include "CFW1DWriteRenderTarget.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1DWriteRenderTarget::CFW1DWriteRenderTarget() :
	m_pRenderTarget(NULL),
	m_hDC(NULL),
	m_hBlackBrush(NULL),
	m_bmWidthBytes(0),
	m_bmBytesPixel(0),
	m_renderTargetWidth(0),
	m_renderTargetHeight(0)
{
}


// Destruct
CFW1DWriteRenderTarget::~CFW1DWriteRenderTarget() {
	if(m_hBlackBrush != NULL)
		DeleteObject(m_hBlackBrush);
	
	SAFE_RELEASE(m_pRenderTarget);
	
	for(RenderingParamsMap::iterator it = m_renderingParams.begin(); it != m_renderingParams.end(); ++it)
		it->second->Release();
}


// Init
HRESULT CFW1DWriteRenderTarget::initRenderTarget(
	IFW1Factory *pFW1Factory,
	IDWriteFactory *pDWriteFactory,
	UINT renderTargetWidth,
	UINT renderTargetHeight
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_renderTargetWidth = 384;
	if(renderTargetWidth > 0)
		m_renderTargetWidth = renderTargetWidth;
	
	m_renderTargetHeight = 384;
	if(renderTargetHeight > 0)
		m_renderTargetHeight = renderTargetHeight;
	
	// Create render target
	hResult = createRenderTarget(pDWriteFactory);
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create render target
HRESULT CFW1DWriteRenderTarget::createRenderTarget(IDWriteFactory *pDWriteFactory) {
	IDWriteGdiInterop *pGDIInterop;
	HRESULT hResult = pDWriteFactory->GetGdiInterop(&pGDIInterop);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to get GDI interop";
	}
	else {
		IDWriteBitmapRenderTarget *pRenderTarget;
		hResult = pGDIInterop->CreateBitmapRenderTarget(
			NULL,
			m_renderTargetWidth,
			m_renderTargetHeight,
			&pRenderTarget
		);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create bitmap render target";
		}
		else {
			hResult = pRenderTarget->SetPixelsPerDip(1.0f);
			hResult = S_OK;
			
			HDC hDC = pRenderTarget->GetMemoryDC();
			if(hDC == NULL) {
				m_lastError = L"Failed to get render target DC";
				hResult = E_FAIL;
			}
			else {
				HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));
				if(hBrush == NULL) {
					m_lastError = L"Failed to create brush";
					hResult = E_FAIL;
				}
				else {
					HBITMAP hBitmap = static_cast<HBITMAP>(GetCurrentObject(hDC, OBJ_BITMAP));
					if(hBitmap == NULL) {
						m_lastError = L"GetCurrentObject failed";
						hResult = E_FAIL;
					}
					else {
						DIBSECTION dib;
						int iResult = GetObject(hBitmap, sizeof(dib), &dib);
						if(iResult < sizeof(dib)) {
							m_lastError = L"GetObject failed";
							hResult = E_FAIL;
						}
						else {
							// Store render target resources and info
							m_pRenderTarget = pRenderTarget;
							
							m_hDC = hDC;
							m_hBlackBrush = hBrush;
							
							m_bmBits = dib.dsBm.bmBits;
							m_bmWidthBytes = static_cast<UINT>(dib.dsBm.bmWidthBytes);
							m_bmBytesPixel = static_cast<UINT>(dib.dsBm.bmBitsPixel) / 8;
							
							hResult = S_OK;
						}
					}
					
					if(FAILED(hResult))
						DeleteObject(hBrush);
				}
			}
			
			if(FAILED(hResult))
				pRenderTarget->Release();
		}
		
		pGDIInterop->Release();
	}
	
	// Create rendering params for all accepted rendering modes
	if(SUCCEEDED(hResult)) {
		const UINT renderingModeCount = 2;
		DWRITE_RENDERING_MODE renderingModes[renderingModeCount] = {
			DWRITE_RENDERING_MODE_DEFAULT,
			DWRITE_RENDERING_MODE_ALIASED
		};
		
		for(UINT i=0; i < renderingModeCount; ++i) {
			DWRITE_RENDERING_MODE renderingMode = renderingModes[i];
			IDWriteRenderingParams *pRenderingParams;
			
			hResult = pDWriteFactory->CreateCustomRenderingParams(
				1.0f,
				0.0f,
				0.0f,
				DWRITE_PIXEL_GEOMETRY_FLAT,
				renderingMode,
				&pRenderingParams
			);
			if(SUCCEEDED(hResult))
				m_renderingParams.insert(std::make_pair(renderingMode, pRenderingParams));
		}
		
		if(m_renderingParams.empty()) {
			m_lastError = L"Failed to create rendering params";
			hResult = E_FAIL;
		}
		else
			hResult = S_OK;
	}
	
	return hResult;
}


// Init glyph data
void CFW1DWriteRenderTarget::initGlyphData(
	const DWRITE_FONT_METRICS *fontMetrics,
	const DWRITE_GLYPH_METRICS *glyphMetrics,
	FLOAT fontSize,
	DWGlyphData *outGlyphData
) {
	// Calculate pixel-space coordinates
	FLOAT fscale = fontSize / static_cast<FLOAT>(fontMetrics->designUnitsPerEm);
	
	FLOAT l = static_cast<FLOAT>(glyphMetrics->leftSideBearing) * fscale;
	FLOAT t = static_cast<FLOAT>(glyphMetrics->topSideBearing) * fscale;
	
	FLOAT r = static_cast<FLOAT>(glyphMetrics->rightSideBearing) * fscale;
	FLOAT b = static_cast<FLOAT>(glyphMetrics->bottomSideBearing) * fscale;
	
	FLOAT v = static_cast<FLOAT>(glyphMetrics->verticalOriginY) * fscale;
	
	FLOAT aw = static_cast<FLOAT>(glyphMetrics->advanceWidth) * fscale;
	FLOAT ah = static_cast<FLOAT>(glyphMetrics->advanceHeight) * fscale;
	
	// Set up glyph data
	outGlyphData->offsetX = floor(l);
	outGlyphData->offsetY = floor(t) - floor(v);
	outGlyphData->maxWidth = static_cast<LONG>(aw - r - l + 2.0f);
	outGlyphData->maxHeight = static_cast<LONG>(ah - b - t + 2.0f);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1DWriteRenderTarget.h`:

```h
// CFW1DWriteRenderTarget.h

#ifndef IncludeGuard__FW1_CFW1DWriteRenderTarget
#define IncludeGuard__FW1_CFW1DWriteRenderTarget

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Render target that provides pixels of one glyph-image at a time
class CFW1DWriteRenderTarget : public CFW1Object<IFW1DWriteRenderTarget> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1DWriteRenderTarget
		virtual HRESULT STDMETHODCALLTYPE DrawGlyphTemp(
			IDWriteFontFace *pFontFace,
			UINT16 GlyphIndex,
			FLOAT FontSize,
			DWRITE_RENDERING_MODE RenderingMode,
			DWRITE_MEASURING_MODE MeasuringMode,
			FW1_GLYPHIMAGEDATA *pOutData
		);
	
	// Public functions
	public:
		CFW1DWriteRenderTarget();
		
		HRESULT initRenderTarget(
			IFW1Factory *pFW1Factory,
			IDWriteFactory *pDWriteFactory,
			UINT renderTargetWidth,
			UINT renderTargetHeight
		);
	
	// Internal types
	private:
		struct DWGlyphData {
			FLOAT					offsetX;
			FLOAT					offsetY;
			LONG					maxWidth;
			LONG					maxHeight;
		};
		
		typedef std::map<DWRITE_RENDERING_MODE, IDWriteRenderingParams*> RenderingParamsMap;
	
	// Internal functions
	private:
		virtual ~CFW1DWriteRenderTarget();
		
		HRESULT createRenderTarget(IDWriteFactory *pDWriteFactory);
		
		void initGlyphData(
			const DWRITE_FONT_METRICS *fontMetrics,
			const DWRITE_GLYPH_METRICS *glyphMetrics,
			FLOAT fontSize,
			DWGlyphData *outGlyphData
		);
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		IDWriteBitmapRenderTarget	*m_pRenderTarget;
		HDC							m_hDC;
		HBRUSH						m_hBlackBrush;
		LPVOID						m_bmBits;
		UINT						m_bmWidthBytes;
		UINT						m_bmBytesPixel;
		UINT						m_renderTargetWidth;
		UINT						m_renderTargetHeight;
		RenderingParamsMap			m_renderingParams;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1DWriteRenderTarget

```

`dwmhook/FW1/CFW1DWriteRenderTargetInterface.cpp`:

```cpp
// CFW1DWriteRenderTargetInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1DWriteRenderTarget.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1DWriteRenderTarget::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1DWriteRenderTarget))) {
		*ppvObject = static_cast<IFW1DWriteRenderTarget*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Draw glyph to temporary storage
HRESULT STDMETHODCALLTYPE CFW1DWriteRenderTarget::DrawGlyphTemp(
	IDWriteFontFace *pFontFace,
	UINT16 GlyphIndex,
	FLOAT FontSize,
	DWRITE_RENDERING_MODE RenderingMode,
	DWRITE_MEASURING_MODE MeasuringMode,
	FW1_GLYPHIMAGEDATA *pOutData
) {
	// Font metrics
	DWRITE_FONT_METRICS fontMetrics;
	pFontFace->GetMetrics(&fontMetrics);
	
	// Glyph metrics
	DWRITE_GLYPH_METRICS glyphMetrics;
	HRESULT hResult = pFontFace->GetDesignGlyphMetrics(&GlyphIndex, 1, &glyphMetrics, FALSE);
	if(FAILED(hResult))
		return hResult;
	
	// Calculate pixel measurements
	DWGlyphData dwGlyphData;
	initGlyphData(&fontMetrics, &glyphMetrics, FontSize, &dwGlyphData);
	
	// Set up drawing
	FLOAT glyphAdvance = 0.0f;
	DWRITE_GLYPH_OFFSET glyphOffset = {0.0f, 0.0f};
	
	DWRITE_GLYPH_RUN glyphRun;
	ZeroMemory(&glyphRun, sizeof(glyphRun));
	glyphRun.fontFace = pFontFace;
	glyphRun.fontEmSize = FontSize;
	glyphRun.glyphCount = 1;
	glyphRun.glyphIndices = &GlyphIndex;
	glyphRun.glyphAdvances = &glyphAdvance;
	glyphRun.glyphOffsets = &glyphOffset;
	
	// Clear background
	RECT rect;
	SetRect(&rect, 0, 0, 2+dwGlyphData.maxWidth+5, 2+dwGlyphData.maxHeight+5);
	int iRet = FillRect(m_hDC, &rect, m_hBlackBrush);
	if(iRet == 0) {
	}
	
	// Rendering mode
	IDWriteRenderingParams *pRenderingParams;
	
	RenderingParamsMap::iterator it = m_renderingParams.find(RenderingMode);
	if(it != m_renderingParams.end())
		pRenderingParams = it->second;
	else
		pRenderingParams = m_renderingParams.begin()->second;
	
	// Draw
	hResult = m_pRenderTarget->DrawGlyphRun(
		2.0f - dwGlyphData.offsetX,
		2.0f - dwGlyphData.offsetY,
		MeasuringMode,
		&glyphRun,
		pRenderingParams,
		RGB(255, 255, 255),
		&rect
	);
	if(FAILED(hResult))
		return hResult;
	
	// Clip to valid render target to avoid buffer overruns in case the glyph was too large
	rect.left = std::max(rect.left, 0L);
	rect.top = std::max(rect.top, 0L);
	rect.right = std::min(static_cast<LONG>(m_renderTargetWidth), rect.right);
	rect.bottom = std::min(static_cast<LONG>(m_renderTargetHeight), rect.bottom);
	
	// Return glyph data
	pOutData->Metrics.OffsetX = dwGlyphData.offsetX + static_cast<FLOAT>(rect.left) - 2.0f;
	pOutData->Metrics.OffsetY = dwGlyphData.offsetY + static_cast<FLOAT>(rect.top) - 2.0f;
	pOutData->Metrics.Width = static_cast<UINT>(rect.right - rect.left);
	pOutData->Metrics.Height = static_cast<UINT>(rect.bottom - rect.top);
	pOutData->pGlyphPixels =
		static_cast<const char*>(m_bmBits)
		+ rect.top * m_bmWidthBytes
		+ rect.left * m_bmBytesPixel;
	pOutData->RowPitch = m_bmWidthBytes;
	pOutData->PixelStride = m_bmBytesPixel;
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1Factory.cpp`:

```cpp
// CFW1Factory.cpp

#include "FW1Precompiled.h"

#include "CFW1Factory.h"


namespace FW1FontWrapper {


// Construct
CFW1Factory::CFW1Factory() :
	m_cRefCount(1)
{
	InitializeCriticalSection(&m_errorStringCriticalSection);
}


// Destruct
CFW1Factory::~CFW1Factory() {
	DeleteCriticalSection(&m_errorStringCriticalSection);
}


// Init
HRESULT CFW1Factory::initFactory() {
	return S_OK;
}


// Create a DWrite factory
HRESULT CFW1Factory::createDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	HRESULT hResult = E_FAIL;
	
	typedef HRESULT (WINAPI * PFN_DWRITECREATEFACTORY)(__in DWRITE_FACTORY_TYPE factoryType, __in REFIID iid, __out IUnknown **factory);
	PFN_DWRITECREATEFACTORY pfnDWriteCreateFactory = NULL;
	
#ifdef FW1_DELAYLOAD_DWRITE_DLL
	HMODULE hDWriteLib = LoadLibrary(TEXT("DWrite.dll"));
	if(hDWriteLib == NULL) {
		DWORD dwErr = GetLastError();
		dwErr;
		setErrorString(L"Failed to load DWrite.dll");
	}
	else {
		pfnDWriteCreateFactory =
			reinterpret_cast<PFN_DWRITECREATEFACTORY>(GetProcAddress(hDWriteLib, "DWriteCreateFactory"));
		if(pfnDWriteCreateFactory == NULL) {
			DWORD dwErr = GetLastError();
			dwErr;
			setErrorString(L"Failed to load DWriteCreateFactory");
		}
	}
#else
	pfnDWriteCreateFactory = DWriteCreateFactory;
#endif
	
	if(pfnDWriteCreateFactory != NULL) {
		IDWriteFactory *pDWriteFactory;
		
		hResult = pfnDWriteCreateFactory(
			DWRITE_FACTORY_TYPE_SHARED,
			__uuidof(IDWriteFactory),
			reinterpret_cast<IUnknown**>(&pDWriteFactory)
		);
		if(FAILED(hResult)) {
			setErrorString(L"DWriteCreateFactory failed");
		}
		else {
			*ppDWriteFactory = pDWriteFactory;
				
			hResult = S_OK;
		}
	}
	
	return hResult;
}


// Set error string
void CFW1Factory::setErrorString(const wchar_t *str) {
	EnterCriticalSection(&m_errorStringCriticalSection);
	m_lastError = str;
	LeaveCriticalSection(&m_errorStringCriticalSection);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1Factory.h`:

```h
// CFW1Factory.h

#ifndef IncludeGuard__FW1_CFW1Factory
#define IncludeGuard__FW1_CFW1Factory


namespace FW1FontWrapper {


// Factory that creates FW1 objects
class CFW1Factory : public IFW1Factory {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		virtual ULONG STDMETHODCALLTYPE AddRef();
		virtual ULONG STDMETHODCALLTYPE Release();
		
		// IFW1Factory
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			LPCWSTR pszFontFamily,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			IDWriteFactory *pDWriteFactory,
			const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			ID3D11Device *pDevice,
			IFW1GlyphAtlas *pGlyphAtlas,
			IFW1GlyphProvider *pGlyphProvider,
			IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			IFW1GlyphRenderStates *pGlyphRenderStates,
			IDWriteFactory *pDWriteFactory,
			const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
			IFW1FontWrapper **ppFontWrapper
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphVertexDrawer(
			ID3D11Device *pDevice,
			UINT VertexBufferSize,
			IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphRenderStates(
			ID3D11Device *pDevice,
			BOOL DisableGeometryShader,
			BOOL AnisotropicFiltering,
			IFW1GlyphRenderStates **ppGlyphRenderStates
		);
		virtual HRESULT STDMETHODCALLTYPE CreateTextRenderer(
			IFW1GlyphProvider *pGlyphProvider,
			IFW1TextRenderer **ppTextRenderer
		);
		virtual HRESULT STDMETHODCALLTYPE CreateTextGeometry(
			IFW1TextGeometry **ppTextGeometry
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphProvider(
			IFW1GlyphAtlas *pGlyphAtlas,
			IDWriteFactory *pDWriteFactory,
			IDWriteFontCollection *pFontCollection,
			UINT MaxGlyphWidth,
			UINT MaxGlyphHeight,
			IFW1GlyphProvider **ppGlyphProvider
		);
		virtual HRESULT STDMETHODCALLTYPE CreateDWriteRenderTarget(
			IDWriteFactory *pDWriteFactory,
			UINT RenderTargetWidth,
			UINT RenderTargetHeight,
			IFW1DWriteRenderTarget **ppRenderTarget
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphAtlas(
			ID3D11Device *pDevice,
			UINT GlyphSheetWidth,
			UINT GlyphSheetHeight,
			BOOL HardwareCoordBuffer,
			BOOL AllowOversizedGlyph,
			UINT MaxGlyphCountPerSheet,
			UINT MipLevels,
			UINT MaxGlyphSheetCount,
			IFW1GlyphAtlas **ppGlyphAtlas
		);
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphSheet(
			ID3D11Device *pDevice,
			UINT GlyphSheetWidth,
			UINT GlyphSheetHeight,
			BOOL HardwareCoordBuffer,
			BOOL AllowOversizedGlyph,
			UINT MaxGlyphCount,
			UINT MipLevels,
			IFW1GlyphSheet **ppGlyphSheet
		);
		virtual HRESULT STDMETHODCALLTYPE CreateColor(
			UINT32 Color,
			IFW1ColorRGBA **ppColor
		);
	
	// Public functions
	public:
		CFW1Factory();
		
		HRESULT initFactory();
	
	// Internal functions
	private:
		virtual ~CFW1Factory();
		
		HRESULT createDWriteFactory(IDWriteFactory **ppDWriteFactory);
		
		void setErrorString(const wchar_t *str);
	
	// Internal data
	private:
		ULONG						m_cRefCount;
		
		std::wstring				m_lastError;
		CRITICAL_SECTION			m_errorStringCriticalSection;
	
	private:
		CFW1Factory(const CFW1Factory&);
		CFW1Factory& operator=(const CFW1Factory&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1Factory

```

`dwmhook/FW1/CFW1FactoryInterface.cpp`:

```cpp
// CFW1FactoryInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1Factory.h"

#include "CFW1FontWrapper.h"
#include "CFW1GlyphVertexDrawer.h"
#include "CFW1GlyphRenderStates.h"
#include "CFW1TextRenderer.h"
#include "CFW1TextGeometry.h"
#include "CFW1GlyphProvider.h"
#include "CFW1DWriteRenderTarget.h"
#include "CFW1GlyphAtlas.h"
#include "CFW1GlyphSheet.h"
#include "CFW1ColorRGBA.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1Factory::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IUnknown))) {
		*ppvObject = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IFW1Factory))) {
		*ppvObject = static_cast<IFW1Factory*>(this);
		AddRef();
		return S_OK;
	}
	
	*ppvObject = NULL;
	return E_NOINTERFACE;
}


// Add reference
ULONG STDMETHODCALLTYPE CFW1Factory::AddRef() {
	return static_cast<ULONG>(InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRefCount)));
}


// Release
ULONG STDMETHODCALLTYPE CFW1Factory::Release() {
	ULONG newCount = static_cast<ULONG>(InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRefCount)));
	
	if(newCount == 0)
		delete this;
	
	return newCount;
}


// Create font wrapper with default settings
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	LPCWSTR pszFontFamily,
	IFW1FontWrapper **ppFontWrapper
) {
	FW1_FONTWRAPPERCREATEPARAMS createParams;
	ZeroMemory(&createParams, sizeof(createParams));
	
	createParams.GlyphSheetWidth = 512;
	createParams.GlyphSheetHeight = 512;
	createParams.MaxGlyphCountPerSheet = 2048;
	createParams.SheetMipLevels = 1;
	createParams.AnisotropicFiltering = FALSE;
	createParams.MaxGlyphWidth = 384;
	createParams.MaxGlyphHeight = 384;
	createParams.DisableGeometryShader = FALSE;
	createParams.VertexBufferSize = 0;
	createParams.DefaultFontParams.pszFontFamily = pszFontFamily;
	createParams.DefaultFontParams.FontWeight = DWRITE_FONT_WEIGHT_NORMAL;
	createParams.DefaultFontParams.FontStyle = DWRITE_FONT_STYLE_NORMAL;
	createParams.DefaultFontParams.FontStretch = DWRITE_FONT_STRETCH_NORMAL;
	createParams.DefaultFontParams.pszLocale = L"";
	
	return CreateFontWrapper(pDevice, NULL, &createParams, ppFontWrapper);
}


// Create font wrapper
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	IDWriteFactory *pDWriteFactory,
	const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
	IFW1FontWrapper **ppFontWrapper
) {
	if(pCreateParams == NULL || ppFontWrapper == NULL)
		return E_INVALIDARG;
	
	HRESULT hResult;
	
	// If no DWrite factory is provided, attempt to create one
	if(pDWriteFactory == NULL)
		hResult = createDWriteFactory(&pDWriteFactory);
	else {
		pDWriteFactory->AddRef();
		hResult = S_OK;
	}
	if(FAILED(hResult)) {
	}
	else {
		// Get system font collection
		IDWriteFontCollection *pFontCollection;
		
		hResult = pDWriteFactory->GetSystemFontCollection(&pFontCollection, FALSE);
		if(FAILED(hResult)) {
			setErrorString(L"GetSystemFontCollection failed");
		}
		else {
			// Create glyph atlas
			IFW1GlyphAtlas *pGlyphAtlas;
			
			hResult = CreateGlyphAtlas(
				pDevice,
				pCreateParams->GlyphSheetWidth,
				pCreateParams->GlyphSheetHeight,
				(pCreateParams->DisableGeometryShader == FALSE) ? TRUE : FALSE,
				TRUE,
				pCreateParams->MaxGlyphCountPerSheet,
				pCreateParams->SheetMipLevels,
				4096,
				&pGlyphAtlas
			);
			if(FAILED(hResult)) {
			}
			else {
				// Create glyph provider
				IFW1GlyphProvider *pGlyphProvider;
				
				hResult = CreateGlyphProvider(
					pGlyphAtlas,
					pDWriteFactory,
					pFontCollection,
					pCreateParams->MaxGlyphWidth,
					pCreateParams->MaxGlyphHeight,
					&pGlyphProvider
				);
				if(FAILED(hResult)) {
				}
				else {
					// Create glyph vertex drawer
					IFW1GlyphVertexDrawer *pGlyphVertexDrawer;
					
					hResult = CreateGlyphVertexDrawer(
						pDevice,
						pCreateParams->VertexBufferSize,
						&pGlyphVertexDrawer
					);
					if(FAILED(hResult)) {
					}
					else {
						// Create glyph render states
						IFW1GlyphRenderStates *pGlyphRenderStates;
						
						hResult = CreateGlyphRenderStates(
							pDevice,
							pCreateParams->DisableGeometryShader,
							pCreateParams->AnisotropicFiltering,
							&pGlyphRenderStates
						);
						if(FAILED(hResult)) {
						}
						else {
							// Create font wrapper
							IFW1FontWrapper *pFontWrapper;
							
							hResult = CreateFontWrapper(
								pDevice,
								pGlyphAtlas,
								pGlyphProvider,
								pGlyphVertexDrawer,
								pGlyphRenderStates,
								pDWriteFactory,
								&pCreateParams->DefaultFontParams,
								&pFontWrapper
							);
							if(FAILED(hResult)) {
							}
							else {
								// Success
								*ppFontWrapper = pFontWrapper;
								
								hResult = S_OK;
							}
							
							pGlyphRenderStates->Release();
						}
						
						pGlyphVertexDrawer->Release();
					}
					
					pGlyphProvider->Release();
				}
				
				pGlyphAtlas->Release();
			}
			
			pFontCollection->Release();
		}
		
		pDWriteFactory->Release();
	}
	
	return hResult;
}


// Create font wrapper
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateFontWrapper(
	ID3D11Device *pDevice,
	IFW1GlyphAtlas *pGlyphAtlas,
	IFW1GlyphProvider *pGlyphProvider,
	IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
	IFW1GlyphRenderStates *pGlyphRenderStates,
	IDWriteFactory *pDWriteFactory,
	const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
	IFW1FontWrapper **ppFontWrapper
) {
	if(ppFontWrapper == NULL)
		return E_INVALIDARG;
	
	CFW1FontWrapper *pFontWrapper = new CFW1FontWrapper;
	HRESULT hResult = pFontWrapper->initFontWrapper(
		this,
		pDevice,
		pGlyphAtlas,
		pGlyphProvider,
		pGlyphVertexDrawer,
		pGlyphRenderStates,
		pDWriteFactory,
		pDefaultFontParams
	);
	if(FAILED(hResult)) {
		pFontWrapper->Release();
		setErrorString(L"initFontWrapper failed");
	}
	else {
		*ppFontWrapper = pFontWrapper;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph vertex drawer
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphVertexDrawer(
	ID3D11Device *pDevice,
	UINT VertexBufferSize,
	IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
) {
	if(ppGlyphVertexDrawer == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphVertexDrawer *pGlyphVertexDrawer = new CFW1GlyphVertexDrawer;
	HRESULT hResult = pGlyphVertexDrawer->initVertexDrawer(
		this,
		pDevice,
		VertexBufferSize
	);
	if(FAILED(hResult)) {
		pGlyphVertexDrawer->Release();
		setErrorString(L"initVertexDrawer failed");
	}
	else {
		*ppGlyphVertexDrawer = pGlyphVertexDrawer;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph render states
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphRenderStates(
	ID3D11Device *pDevice,
	BOOL DisableGeometryShader,
	BOOL AnisotropicFiltering,
	IFW1GlyphRenderStates **ppGlyphRenderStates
) {
	if(ppGlyphRenderStates == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphRenderStates *pGlyphRenderStates = new CFW1GlyphRenderStates;
	HRESULT hResult = pGlyphRenderStates->initRenderResources(
		this,
		pDevice,
		(DisableGeometryShader == FALSE),
		(AnisotropicFiltering != FALSE)
	);
	if(FAILED(hResult)) {
		pGlyphRenderStates->Release();
		setErrorString(L"initRenderResources failed");
	}
	else {
		*ppGlyphRenderStates = pGlyphRenderStates;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create DWrite text renderer
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateTextRenderer(
	IFW1GlyphProvider *pGlyphProvider,
	IFW1TextRenderer **ppTextRenderer
) {
	if(ppTextRenderer == NULL)
		return E_INVALIDARG;
	
	CFW1TextRenderer *pTextRenderer = new CFW1TextRenderer;
	HRESULT hResult = pTextRenderer->initTextRenderer(this, pGlyphProvider);
	if(FAILED(hResult)) {
		pTextRenderer->Release();
		setErrorString(L"initTextRenderer failed");
	}
	else {
		*ppTextRenderer = pTextRenderer;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create text geometry
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateTextGeometry(
	IFW1TextGeometry **ppTextGeometry
) {
	if(ppTextGeometry == NULL)
		return E_INVALIDARG;
	
	CFW1TextGeometry *pTextGeometry = new CFW1TextGeometry;
	HRESULT hResult = pTextGeometry->initTextGeometry(this);
	if(FAILED(hResult)) {
		pTextGeometry->Release();
		setErrorString(L"initTextGeometry failed");
	}
	else {
		*ppTextGeometry = pTextGeometry;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph provider
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphProvider(
	IFW1GlyphAtlas *pGlyphAtlas,
	IDWriteFactory *pDWriteFactory,
	IDWriteFontCollection *pFontCollection,
	UINT MaxGlyphWidth,
	UINT MaxGlyphHeight,
	IFW1GlyphProvider **ppGlyphProvider
) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphProvider *pGlyphProvider = new CFW1GlyphProvider;
	HRESULT hResult = pGlyphProvider->initGlyphProvider(
		this,
		pGlyphAtlas,
		pDWriteFactory,
		pFontCollection,
		MaxGlyphWidth,
		MaxGlyphHeight
	);
	if(FAILED(hResult)) {
		pGlyphProvider->Release();
		setErrorString(L"initGlyphProvider failed");
	}
	else {
		*ppGlyphProvider = pGlyphProvider;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create DWrite render target
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateDWriteRenderTarget(
	IDWriteFactory *pDWriteFactory,
	UINT RenderTargetWidth,
	UINT RenderTargetHeight,
	IFW1DWriteRenderTarget **ppRenderTarget
) {
	if(ppRenderTarget == NULL)
		return E_INVALIDARG;
	
	CFW1DWriteRenderTarget *pRenderTarget = new CFW1DWriteRenderTarget;
	HRESULT hResult = pRenderTarget->initRenderTarget(this, pDWriteFactory, RenderTargetWidth, RenderTargetHeight);
	if(FAILED(hResult)) {
		pRenderTarget->Release();
		setErrorString(L"initRenderTarget failed");
	}
	else {
		*ppRenderTarget = pRenderTarget;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph atlas
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphAtlas(
	ID3D11Device *pDevice,
	UINT GlyphSheetWidth,
	UINT GlyphSheetHeight,
	BOOL HardwareCoordBuffer,
	BOOL AllowOversizedGlyph,
	UINT MaxGlyphCountPerSheet,
	UINT MipLevels,
	UINT MaxGlyphSheetCount,
	IFW1GlyphAtlas **ppGlyphAtlas
) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphAtlas *pGlyphAtlas = new CFW1GlyphAtlas;
	HRESULT hResult = pGlyphAtlas->initGlyphAtlas(
		this,
		pDevice,
		GlyphSheetWidth,
		GlyphSheetHeight,
		(HardwareCoordBuffer != FALSE),
		(AllowOversizedGlyph != FALSE),
		MaxGlyphCountPerSheet,
		MipLevels,
		MaxGlyphSheetCount
	);
	if(FAILED(hResult)) {
		pGlyphAtlas->Release();
		setErrorString(L"initGlyphAtlas failed");
	}
	else {
		*ppGlyphAtlas = pGlyphAtlas;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create glyph sheet
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateGlyphSheet(
	ID3D11Device *pDevice,
	UINT GlyphSheetWidth,
	UINT GlyphSheetHeight,
	BOOL HardwareCoordBuffer,
	BOOL AllowOversizedGlyph,
	UINT MaxGlyphCount,
	UINT MipLevels,
	IFW1GlyphSheet **ppGlyphSheet
) {
	if(ppGlyphSheet == NULL)
		return E_INVALIDARG;
	
	CFW1GlyphSheet *pGlyphSheet = new CFW1GlyphSheet;
	HRESULT hResult = pGlyphSheet->initGlyphSheet(
		this,
		pDevice,
		GlyphSheetWidth,
		GlyphSheetHeight,
		(HardwareCoordBuffer != FALSE),
		(AllowOversizedGlyph != FALSE),
		MaxGlyphCount,
		MipLevels
	);
	if(FAILED(hResult)) {
		pGlyphSheet->Release();
		setErrorString(L"initGlyphSheet failed");
	}
	else {
		*ppGlyphSheet = pGlyphSheet;
		
		hResult = S_OK;
	}
	
	return hResult;
}


// Create color
HRESULT STDMETHODCALLTYPE CFW1Factory::CreateColor(UINT32 Color, IFW1ColorRGBA **ppColor) {
	if(ppColor == NULL)
		return E_INVALIDARG;
	
	CFW1ColorRGBA *pColor = new CFW1ColorRGBA;
	HRESULT hResult = pColor->initColor(this, Color);
	if(FAILED(hResult)) {
		pColor->Release();
		setErrorString(L"initColor failed");
	}
	else {
		*ppColor = pColor;
		
		hResult = S_OK;
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1FontWrapper.cpp`:

```cpp
// CFW1FontWrapper.cpp

#include "FW1Precompiled.h"

#include "CFW1FontWrapper.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1FontWrapper::CFW1FontWrapper() :
	m_pDevice(NULL),
	m_featureLevel(D3D_FEATURE_LEVEL_9_1),
	m_pDWriteFactory(NULL),
	
	m_pGlyphAtlas(NULL),
	m_pGlyphProvider(NULL),
	
	m_pGlyphRenderStates(NULL),
	m_pGlyphVertexDrawer(NULL),
	
	m_defaultTextInited(false),
	m_pDefaultTextFormat(NULL)
{
	InitializeCriticalSection(&m_textRenderersCriticalSection);
	InitializeCriticalSection(&m_textGeometriesCriticalSection);
}


// Destruct
CFW1FontWrapper::~CFW1FontWrapper() {
	SAFE_RELEASE(m_pFW1Factory);
	
	SAFE_RELEASE(m_pDevice);
	SAFE_RELEASE(m_pDWriteFactory);
	
	SAFE_RELEASE(m_pGlyphAtlas);
	SAFE_RELEASE(m_pGlyphProvider);
	
	SAFE_RELEASE(m_pGlyphRenderStates);
	SAFE_RELEASE(m_pGlyphVertexDrawer);
	
	while(!m_textRenderers.empty()) {
		m_textRenderers.top()->Release();
		m_textRenderers.pop();
	}
	
	while(!m_textGeometries.empty()) {
		m_textGeometries.top()->Release();
		m_textGeometries.pop();
	}
	
	SAFE_RELEASE(m_pDefaultTextFormat);
	
	DeleteCriticalSection(&m_textRenderersCriticalSection);
	DeleteCriticalSection(&m_textGeometriesCriticalSection);
}


// Init
HRESULT CFW1FontWrapper::initFontWrapper(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	IFW1GlyphAtlas *pGlyphAtlas,
	IFW1GlyphProvider *pGlyphProvider,
	IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
	IFW1GlyphRenderStates *pGlyphRenderStates,
	IDWriteFactory *pDWriteFactory,
	const FW1_DWRITEFONTPARAMS *pDefaultFontParams
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(
		pDevice == NULL ||
		pGlyphAtlas == NULL ||
		pGlyphProvider == NULL ||
		pGlyphVertexDrawer == NULL ||
		pGlyphRenderStates == NULL ||
		pDWriteFactory == NULL
	)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	m_featureLevel = m_pDevice->GetFeatureLevel();
	
	pDWriteFactory->AddRef();
	m_pDWriteFactory = pDWriteFactory;
	
	pGlyphAtlas->AddRef();
	m_pGlyphAtlas = pGlyphAtlas;
	pGlyphProvider->AddRef();
	m_pGlyphProvider = pGlyphProvider;
	
	pGlyphRenderStates->AddRef();
	m_pGlyphRenderStates = pGlyphRenderStates;
	pGlyphVertexDrawer->AddRef();
	m_pGlyphVertexDrawer = pGlyphVertexDrawer;
	
	// Create default text format for strings, if provided
	if(pDefaultFontParams->pszFontFamily != NULL && pDefaultFontParams->pszFontFamily[0] != 0) {
		IDWriteTextFormat *pTextFormat;
		hResult = m_pDWriteFactory->CreateTextFormat(
			pDefaultFontParams->pszFontFamily,
			NULL,
			pDefaultFontParams->FontWeight,
			pDefaultFontParams->FontStyle,
			pDefaultFontParams->FontStretch,
			32.0f,
			(pDefaultFontParams->pszLocale != NULL) ? pDefaultFontParams->pszLocale : L"",
			&pTextFormat
		);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create DWrite text format";
		}
		else {
			m_pDefaultTextFormat = pTextFormat;
			m_defaultTextInited = true;
			
			hResult = S_OK;
		}
	}
	
	return hResult;
}


// Create text layout from string
IDWriteTextLayout* CFW1FontWrapper::createTextLayout(
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT fontSize,
	const FW1_RECTF *pLayoutRect,
	UINT flags
) {
	if(m_defaultTextInited) {
		UINT32 stringLength = 0;
		while(pszString[stringLength] != 0)
			++stringLength;
		
		// Create DWrite text layout for the string
		IDWriteTextLayout *pTextLayout;
		HRESULT hResult = m_pDWriteFactory->CreateTextLayout(
			pszString,
			stringLength,
			m_pDefaultTextFormat,
			pLayoutRect->Right - pLayoutRect->Left,
			pLayoutRect->Bottom - pLayoutRect->Top,
			&pTextLayout
		);
		if(SUCCEEDED(hResult)) {
			// Layout settings
			DWRITE_TEXT_RANGE allText = {0, stringLength};
			pTextLayout->SetFontSize(fontSize, allText);
			
			if(pszFontFamily != NULL)
				pTextLayout->SetFontFamilyName(pszFontFamily, allText);
			
			if((flags & FW1_NOWORDWRAP) != 0)
				pTextLayout->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
			
			if(flags & FW1_RIGHT)
				pTextLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
			else if(flags & FW1_CENTER)
				pTextLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
			if(flags & FW1_BOTTOM)
				pTextLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
			else if(flags & FW1_VCENTER)
				pTextLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
			
			return pTextLayout;
		}
	}
	
	return NULL;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1FontWrapper.h`:

```h
// CFW1FontWrapper.h

#ifndef IncludeGuard__FW1_CFW1FontWrapper
#define IncludeGuard__FW1_CFW1FontWrapper

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Font-wrapper simplifying drawing strings and text-layouts
class CFW1FontWrapper : public CFW1Object<IFW1FontWrapper> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1FontWrapper
		virtual HRESULT STDMETHODCALLTYPE GetFactory(IFW1Factory **ppFactory);
		
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(IDWriteFactory **ppDWriteFactory);
		virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas);
		virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider);
		virtual HRESULT STDMETHODCALLTYPE GetRenderStates(IFW1GlyphRenderStates **ppRenderStates);
		virtual HRESULT STDMETHODCALLTYPE GetVertexDrawer(IFW1GlyphVertexDrawer **ppVertexDrawer);
		
		virtual void STDMETHODCALLTYPE DrawTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			FLOAT FontSize,
			FLOAT X,
			FLOAT Y,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			FLOAT X,
			FLOAT Y,
			UINT32 Color,
			UINT Flags
		);
		virtual void STDMETHODCALLTYPE DrawString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT32 Color,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual FW1_RECTF STDMETHODCALLTYPE MeasureString(
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE AnalyzeString(
			ID3D11DeviceContext *pContext,
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT FontSize,
			const FW1_RECTF *pLayoutRect,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
		
		virtual void STDMETHODCALLTYPE AnalyzeTextLayout(
			ID3D11DeviceContext *pContext,
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
		
		virtual void STDMETHODCALLTYPE DrawGeometry(
			ID3D11DeviceContext *pContext,
			IFW1TextGeometry *pGeometry,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix,
			UINT Flags
		);
		
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1FontWrapper();
		
		HRESULT initFontWrapper(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			IFW1GlyphAtlas *pGlyphAtlas,
			IFW1GlyphProvider *pGlyphProvider,
			IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			IFW1GlyphRenderStates *pGlyphRenderStates,
			IDWriteFactory *pDWriteFactory,
			const FW1_DWRITEFONTPARAMS *pDefaultFontParams
		);
	
	// Internal functions
	private:
		virtual ~CFW1FontWrapper();
		
		IDWriteTextLayout* createTextLayout(
			const WCHAR *pszString,
			const WCHAR *pszFontFamily,
			FLOAT fontSize,
			const FW1_RECTF *pLayoutRect,
			UINT flags
		);
	
	// Internal data
	private:
		std::wstring					m_lastError;
		
		ID3D11Device					*m_pDevice;
		D3D_FEATURE_LEVEL				m_featureLevel;
		IDWriteFactory					*m_pDWriteFactory;
		
		IFW1GlyphAtlas					*m_pGlyphAtlas;
		IFW1GlyphProvider				*m_pGlyphProvider;
		
		IFW1GlyphRenderStates			*m_pGlyphRenderStates;
		IFW1GlyphVertexDrawer			*m_pGlyphVertexDrawer;
		
		CRITICAL_SECTION				m_textRenderersCriticalSection;
		std::stack<IFW1TextRenderer*>	m_textRenderers;
		CRITICAL_SECTION				m_textGeometriesCriticalSection;
		std::stack<IFW1TextGeometry*>	m_textGeometries;
		
		bool							m_defaultTextInited;
		IDWriteTextFormat				*m_pDefaultTextFormat;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1FontWrapper

```

`dwmhook/FW1/CFW1FontWrapperInterface.cpp`:

```cpp
// CFW1FontWrapperInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1FontWrapper.h"

#include "CFW1StateSaver.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1FontWrapper))) {
		*ppvObject = static_cast<IFW1FontWrapper*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the factory that created this object
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetFactory(IFW1Factory **ppFactory) {
	if(ppFactory == NULL)
		return E_INVALIDARG;
	
	m_pFW1Factory->AddRef();
	*ppFactory = m_pFW1Factory;
	
	return S_OK;
}


// Get D3D11 device
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get DWrite factory
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	if(ppDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_pDWriteFactory->AddRef();
	*ppDWriteFactory = m_pDWriteFactory;
	
	return S_OK;
}


// Get glyph atlas
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	m_pGlyphAtlas->AddRef();
	*ppGlyphAtlas = m_pGlyphAtlas;
	
	return S_OK;
}


// Get glyph provider
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	m_pGlyphProvider->AddRef();
	*ppGlyphProvider = m_pGlyphProvider;
	
	return S_OK;
}


// Get render states
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetRenderStates(IFW1GlyphRenderStates **ppRenderStates) {
	if(ppRenderStates == NULL)
		return E_INVALIDARG;
	
	m_pGlyphRenderStates->AddRef();
	*ppRenderStates = m_pGlyphRenderStates;
	
	return S_OK;
}


// Get vertex drawer
HRESULT STDMETHODCALLTYPE CFW1FontWrapper::GetVertexDrawer(IFW1GlyphVertexDrawer **ppVertexDrawer) {
	if(ppVertexDrawer == NULL)
		return E_INVALIDARG;
	
	m_pGlyphVertexDrawer->AddRef();
	*ppVertexDrawer = m_pGlyphVertexDrawer;
	
	return S_OK;
}


// Draw text layout
void STDMETHODCALLTYPE CFW1FontWrapper::DrawTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags
) {
	DrawTextLayout(pContext, pTextLayout, OriginX, OriginY, Color, NULL, NULL, Flags);
}


// Draw text layout
void STDMETHODCALLTYPE CFW1FontWrapper::DrawTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	IFW1TextGeometry *pTextGeometry = NULL;
	
	// If needed, get a text geometry to store vertices in
	if((Flags & FW1_ANALYZEONLY) == 0 && (Flags & FW1_CACHEONLY) == 0) {
		EnterCriticalSection(&m_textGeometriesCriticalSection);
		if(!m_textGeometries.empty()) {
			pTextGeometry = m_textGeometries.top();
			m_textGeometries.pop();
		}
		LeaveCriticalSection(&m_textGeometriesCriticalSection);
		
		if(pTextGeometry == NULL) {
			IFW1TextGeometry *pNewTextGeometry;
			HRESULT hResult = m_pFW1Factory->CreateTextGeometry(&pNewTextGeometry);
			if(FAILED(hResult)) {
			}
			else {
				pTextGeometry = pNewTextGeometry;
			}
		}
		
		if(pTextGeometry != NULL)
			pTextGeometry->Clear();
	}
	
	// Draw
	AnalyzeTextLayout(pContext, pTextLayout, OriginX, OriginY, Color, Flags, pTextGeometry);
	if((Flags & FW1_ANALYZEONLY) == 0 && (Flags & FW1_CACHEONLY) == 0) {
		DrawGeometry(pContext, pTextGeometry, pClipRect, pTransformMatrix, Flags);
	}
	
	if(pTextGeometry != NULL) {
		// Keep the text geometry for future use
		EnterCriticalSection(&m_textGeometriesCriticalSection);
		m_textGeometries.push(pTextGeometry);
		LeaveCriticalSection(&m_textGeometriesCriticalSection);
	}
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	FLOAT FontSize,
	FLOAT X,
	FLOAT Y,
	UINT32 Color,
	UINT Flags
) {
	FW1_RECTF rect;
	
	rect.Left = rect.Right = X;
	rect.Top = rect.Bottom = Y;
	
	DrawString(pContext, pszString, NULL, FontSize, &rect, Color, NULL, NULL, Flags | FW1_NOWORDWRAP);
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	FLOAT X,
	FLOAT Y,
	UINT32 Color,
	UINT Flags
) {
	FW1_RECTF rect;
	
	rect.Left = rect.Right = X;
	rect.Top = rect.Bottom = Y;
	
	DrawString(pContext, pszString, pszFontFamily, FontSize, &rect, Color, NULL, NULL, Flags | FW1_NOWORDWRAP);
}


// Draw text
void STDMETHODCALLTYPE CFW1FontWrapper::DrawString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT32 Color,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		// Draw
		DrawTextLayout(
			pContext,
			pTextLayout,
			pLayoutRect->Left,
			pLayoutRect->Top,
			Color,
			pClipRect,
			pTransformMatrix,
			Flags
		);
		
		pTextLayout->Release();
	}
}


// Measure text
FW1_RECTF STDMETHODCALLTYPE CFW1FontWrapper::MeasureString(
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT Flags
) {
	FW1_RECTF stringRect = {pLayoutRect->Left, pLayoutRect->Top, pLayoutRect->Left, pLayoutRect->Top};
	
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		// Get measurements
		DWRITE_OVERHANG_METRICS overhangMetrics;
		HRESULT hResult = pTextLayout->GetOverhangMetrics(&overhangMetrics);
		if(SUCCEEDED(hResult)) {
			stringRect.Left = floor(pLayoutRect->Left - overhangMetrics.left);
			stringRect.Top = floor(pLayoutRect->Top - overhangMetrics.top);
			stringRect.Right = ceil(pLayoutRect->Left + overhangMetrics.right);
			stringRect.Bottom = ceil(pLayoutRect->Top + overhangMetrics.bottom);
		}
		
		pTextLayout->Release();
	}
	
	return stringRect;
}


// Create geometry from a string
void STDMETHODCALLTYPE CFW1FontWrapper::AnalyzeString(
	ID3D11DeviceContext *pContext,
	const WCHAR *pszString,
	const WCHAR *pszFontFamily,
	FLOAT FontSize,
	const FW1_RECTF *pLayoutRect,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	IDWriteTextLayout *pTextLayout = createTextLayout(pszString, pszFontFamily, FontSize, pLayoutRect, Flags);
	if(pTextLayout != NULL) {
		AnalyzeTextLayout(
			pContext,
			pTextLayout,
			pLayoutRect->Left,
			pLayoutRect->Top,
			Color,
			Flags,
			pTextGeometry
		);
		
		pTextLayout->Release();
	}
}


// Create geometry from a text layout
void STDMETHODCALLTYPE CFW1FontWrapper::AnalyzeTextLayout(
	ID3D11DeviceContext *pContext,
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	// Get a text renderer
	IFW1TextRenderer *pTextRenderer = NULL;
	
	EnterCriticalSection(&m_textRenderersCriticalSection);
	if(!m_textRenderers.empty()) {
		pTextRenderer = m_textRenderers.top();
		m_textRenderers.pop();
	}
	LeaveCriticalSection(&m_textRenderersCriticalSection);
	
	if(pTextRenderer == NULL) {
		IFW1TextRenderer *pNewTextRenderer;
		HRESULT hResult = m_pFW1Factory->CreateTextRenderer(m_pGlyphProvider, &pNewTextRenderer);
		if(FAILED(hResult)) {
		}
		else {
			pTextRenderer = pNewTextRenderer;
		}
	}
	
	// Create geometry
	if(pTextRenderer != NULL) {
		HRESULT hResult = pTextRenderer->DrawTextLayout(pTextLayout, OriginX, OriginY, Color, Flags, pTextGeometry);
		if(FAILED(hResult)) {
		}
		
		// Flush the glyph atlas in case any new glyphs were added
		if((Flags & FW1_NOFLUSH) == 0)
			m_pGlyphAtlas->Flush(pContext);
		
		// Keep the text renderer for future use
		EnterCriticalSection(&m_textRenderersCriticalSection);
		m_textRenderers.push(pTextRenderer);
		LeaveCriticalSection(&m_textRenderersCriticalSection);
	}
}


// Draw vertices
void STDMETHODCALLTYPE CFW1FontWrapper::DrawGeometry(
	ID3D11DeviceContext *pContext,
	IFW1TextGeometry *pGeometry,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix,
	UINT Flags
) {
	FW1_VERTEXDATA vertexData = pGeometry->GetGlyphVerticesTemp();
	if(vertexData.TotalVertexCount > 0 || (Flags & FW1_RESTORESTATE) == 0) {
		if(m_featureLevel < D3D_FEATURE_LEVEL_10_0 || m_pGlyphRenderStates->HasGeometryShader() == FALSE)
			Flags |= FW1_NOGEOMETRYSHADER;
		
		// Save state
		CFW1StateSaver stateSaver;
		bool restoreState = false;
		if((Flags & FW1_RESTORESTATE) != 0) {
			if(SUCCEEDED(stateSaver.saveCurrentState(pContext)))
				restoreState = true;
		}
		
		// Set shaders etc.
		if((Flags & FW1_STATEPREPARED) == 0)
			m_pGlyphRenderStates->SetStates(pContext, Flags);
		if((Flags & FW1_CONSTANTSPREPARED) == 0)
			m_pGlyphRenderStates->UpdateShaderConstants(pContext, pClipRect, pTransformMatrix);
		
		// Draw glyphs
		UINT temp = m_pGlyphVertexDrawer->DrawVertices(pContext, m_pGlyphAtlas, &vertexData, Flags, 0xffffffff);
		temp;
		
		// Restore state
		if(restoreState)
			stateSaver.restoreSavedState();
	}
}


// Flush the glyph atlas
void STDMETHODCALLTYPE CFW1FontWrapper::Flush(ID3D11DeviceContext *pContext) {
	m_pGlyphAtlas->Flush(pContext);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphAtlas.cpp`:

```cpp
// CFW1GlyphAtlas.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphAtlas.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphAtlas::CFW1GlyphAtlas() :
	m_pDevice(NULL),
	m_sheetWidth(0),
	m_sheetHeight(0),
	m_hardwareCoordBuffer(false),
	m_allowOversizedGlyph(false),
	m_maxGlyphCount(0),
	m_mipLevelCount(0),
	
	m_glyphSheets(0),
	m_sheetCount(0),
	m_maxSheetCount(0),
	m_currentSheetIndex(0),
	m_flushedSheetIndex(0)
{
	InitializeCriticalSection(&m_glyphSheetsCriticalSection);
}


// Destruct
CFW1GlyphAtlas::~CFW1GlyphAtlas() {
	SAFE_RELEASE(m_pDevice);
	
	for(UINT i=0; i < m_sheetCount; ++i)
		m_glyphSheets[i]->Release();
	delete[] m_glyphSheets;
	
	DeleteCriticalSection(&m_glyphSheetsCriticalSection);
}


// Init
HRESULT CFW1GlyphAtlas::initGlyphAtlas(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT sheetWidth,
	UINT sheetHeight,
	bool coordBuffer,
	bool allowOversizedGlyph,
	UINT maxGlyphCount,
	UINT mipLevelCount,
	UINT maxSheetCount
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	
	m_sheetWidth = sheetWidth;
	m_sheetHeight = sheetHeight;
	m_hardwareCoordBuffer = coordBuffer;
	m_allowOversizedGlyph = allowOversizedGlyph;
	m_mipLevelCount = mipLevelCount;
	m_maxGlyphCount = maxGlyphCount;
	
	m_maxSheetCount = 4096;
	if(maxSheetCount > 0 && maxSheetCount < 655536)
		m_maxSheetCount = maxSheetCount;
	m_glyphSheets = new IFW1GlyphSheet* [m_maxSheetCount];
	
	// Default glyph
	BYTE glyph0Pixels[256];
	FillMemory(glyph0Pixels, 256, 0xff);
	
	FW1_GLYPHMETRICS glyph0Metrics;
	glyph0Metrics.OffsetX = 0.0f;
	glyph0Metrics.OffsetY = 0.0f;
	glyph0Metrics.Width = 16;
	glyph0Metrics.Height = 16;
	
	UINT glyph0 = InsertGlyph(&glyph0Metrics, glyph0Pixels, 16, 1);
	if(glyph0 == 0xffffffff)
		return E_FAIL;
	else
		return S_OK;
}


// Create new glyph sheet
HRESULT CFW1GlyphAtlas::createGlyphSheet(IFW1GlyphSheet **ppGlyphSheet) {
	IFW1GlyphSheet *pGlyphSheet;
	HRESULT hResult = m_pFW1Factory->CreateGlyphSheet(
		m_pDevice,
		m_sheetWidth,
		m_sheetHeight,
		m_hardwareCoordBuffer,
		m_allowOversizedGlyph,
		m_maxGlyphCount,
		m_mipLevelCount,
		&pGlyphSheet
	);
	if(FAILED(hResult)) {
	}
	else {
		*ppGlyphSheet = pGlyphSheet;
		
		hResult = S_OK;
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphAtlas.h`:

```h
// CFW1GlyphAtlas.h

#ifndef IncludeGuard__FW1_CFW1GlyphAtlas
#define IncludeGuard__FW1_CFW1GlyphAtlas

#include "CFW1Object.h"


namespace FW1FontWrapper {


class CFW1GlyphAtlas : public CFW1Object<IFW1GlyphAtlas> {
	// Interface
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphAtlas
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual UINT STDMETHODCALLTYPE GetTotalGlyphCount();
		virtual UINT STDMETHODCALLTYPE GetSheetCount();
		
		virtual HRESULT STDMETHODCALLTYPE GetSheet(UINT SheetIndex, IFW1GlyphSheet **ppGlyphSheet);
		
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(UINT SheetIndex);
		virtual HRESULT STDMETHODCALLTYPE BindSheet(ID3D11DeviceContext *pContext, UINT SheetIndex, UINT Flags);
		
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			const FW1_GLYPHMETRICS *pGlyphMetrics,
			const void *pGlyphData,
			UINT RowPitch,
			UINT PixelStride
		);
		virtual UINT STDMETHODCALLTYPE InsertSheet(IFW1GlyphSheet *pGlyphSheet);
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1GlyphAtlas();
		
		HRESULT initGlyphAtlas(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			UINT sheetWidth,
			UINT sheetHeight,
			bool coordBuffer,
			bool allowOversizedTexture,
			UINT maxGlyphCountPerSheet,
			UINT mipLevelCount,
			UINT maxSheetCount
		);
	
	// Internal functions
	private:
		virtual ~CFW1GlyphAtlas();
		
		HRESULT createGlyphSheet(IFW1GlyphSheet **ppGlyphSheet);
	
	// Internal data
	private:
		ID3D11Device				*m_pDevice;
		UINT						m_sheetWidth;
		UINT						m_sheetHeight;
		bool						m_hardwareCoordBuffer;
		bool						m_allowOversizedGlyph;
		UINT						m_maxGlyphCount;
		UINT						m_mipLevelCount;
		
		IFW1GlyphSheet				**m_glyphSheets;
		UINT						m_sheetCount;
		UINT						m_maxSheetCount;
		UINT						m_currentSheetIndex;
		UINT						m_flushedSheetIndex;
		
		CRITICAL_SECTION			m_glyphSheetsCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphAtlas

```

`dwmhook/FW1/CFW1GlyphAtlasInterface.cpp`:

```cpp
// CFW1GlyphAtlasInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphAtlas.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphAtlas))) {
		*ppvObject = static_cast<IFW1GlyphAtlas*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this atlas
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get total glyph count in atlas
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::GetTotalGlyphCount() {
	UINT total = 0;
	
	for(UINT i=0; i < m_sheetCount; ++i) {
		FW1_GLYPHSHEETDESC desc;
		m_glyphSheets[i]->GetDesc(&desc);
		
		total += desc.GlyphCount;
	}
	
	return total;
}


// Get sheet count
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::GetSheetCount() {
	return m_sheetCount;
}


// Get sheet
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::GetSheet(UINT SheetIndex, IFW1GlyphSheet **ppGlyphSheet) {
	if(ppGlyphSheet == NULL)
		return E_INVALIDARG;
	
	if(SheetIndex < m_sheetCount) {
		*ppGlyphSheet = m_glyphSheets[SheetIndex];
		
		return S_OK;
	}
	
	*ppGlyphSheet = NULL;
	
	return E_INVALIDARG;
}

// Get texture coordinates
const FW1_GLYPHCOORDS* STDMETHODCALLTYPE CFW1GlyphAtlas::GetGlyphCoords(UINT SheetIndex) {
	if(SheetIndex < m_sheetCount)
		return m_glyphSheets[SheetIndex]->GetGlyphCoords();
	
	return 0;
}


// Set sheet shader resources
HRESULT STDMETHODCALLTYPE CFW1GlyphAtlas::BindSheet(ID3D11DeviceContext *pContext, UINT SheetIndex, UINT Flags) {
	if(SheetIndex < m_sheetCount)
		return m_glyphSheets[SheetIndex]->BindSheet(pContext, Flags);
	
	return E_INVALIDARG;
}


// Insert texture into atlas
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::InsertGlyph(
	const FW1_GLYPHMETRICS *pGlyphMetrics,
	const void *pGlyphData,
	UINT RowPitch,
	UINT PixelStride
) {
	UINT glyphIndex = 0xffffffff;
	UINT sheetIndex = 0;
	
	// Get open sheet range
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	UINT start = m_currentSheetIndex;
	UINT end = m_sheetCount;
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	// Attempt to insert glyph
	for(UINT i=start; i < end; ++i) {
		IFW1GlyphSheet *pGlyphSheet = m_glyphSheets[i];
		
		glyphIndex = pGlyphSheet->InsertGlyph(pGlyphMetrics, pGlyphData, RowPitch, PixelStride);
		if(glyphIndex != 0xffffffff) {
			sheetIndex = i;
			break;
		}
	}
	
	// Try to create a new glyph sheet on failure
	if(glyphIndex == 0xffffffff && m_sheetCount < m_maxSheetCount) {
		IFW1GlyphSheet *pGlyphSheet;
		if(SUCCEEDED(createGlyphSheet(&pGlyphSheet))) {
			glyphIndex = pGlyphSheet->InsertGlyph(pGlyphMetrics, pGlyphData, RowPitch, PixelStride);
			
			UINT newSheetIndex = InsertSheet(pGlyphSheet);
			if(newSheetIndex != 0xffffffff)
				sheetIndex = newSheetIndex;
			else
				glyphIndex = 0xffffffff;
			
			pGlyphSheet->Release();
		}
	}
	
	if(glyphIndex == 0xffffffff)
		return 0xffffffff;
	
	return (sheetIndex << 16) | glyphIndex;
}


// Insert glyph sheets
UINT STDMETHODCALLTYPE CFW1GlyphAtlas::InsertSheet(IFW1GlyphSheet *pGlyphSheet) {
	if(pGlyphSheet == NULL)
		return 0xffffffff;
	
	UINT sheetIndex = 0xffffffff;
	
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	if(m_sheetCount < m_maxSheetCount) {
		pGlyphSheet->AddRef();
		
		sheetIndex = m_sheetCount;
		
		m_glyphSheets[sheetIndex] = pGlyphSheet;
		
		_WriteBarrier();
		MemoryBarrier();
		
		++m_sheetCount;
		
		// Restrict the number of open sheets
		UINT numActiveSheets = 4;
		
		if(m_sheetCount > m_currentSheetIndex + numActiveSheets) {
			m_glyphSheets[m_currentSheetIndex]->CloseSheet();
			
			++m_currentSheetIndex;
		}
	}
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	return sheetIndex;
}


// Flush all sheets with possible new glyphs
void STDMETHODCALLTYPE CFW1GlyphAtlas::Flush(ID3D11DeviceContext *pContext) {
	UINT first = 0;
	UINT end = 0;
	
	EnterCriticalSection(&m_glyphSheetsCriticalSection);
	
	first = m_flushedSheetIndex;
	end = m_sheetCount;
	
	m_flushedSheetIndex = m_currentSheetIndex;
	
	LeaveCriticalSection(&m_glyphSheetsCriticalSection);
	
	for(UINT i=first; i < end; ++i)
		m_glyphSheets[i]->Flush(pContext);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphProvider.cpp`:

```cpp
// CFW1GlyphProvider.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphProvider.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphProvider::CFW1GlyphProvider() :
	m_pGlyphAtlas(NULL),
	
	m_pDWriteFactory(NULL),
	m_maxGlyphWidth(0),
	m_maxGlyphHeight(0),
	
	m_pFontCollection(NULL)
{
	InitializeCriticalSection(&m_renderTargetsCriticalSection);
	InitializeCriticalSection(&m_glyphMapsCriticalSection);
	InitializeCriticalSection(&m_fontsCriticalSection);
	InitializeCriticalSection(&m_insertGlyphCriticalSection);
}


// Destruct
CFW1GlyphProvider::~CFW1GlyphProvider() {
	SAFE_RELEASE(m_pGlyphAtlas);
	
	SAFE_RELEASE(m_pDWriteFactory);
	
	while(!m_glyphRenderTargets.empty()) {
		m_glyphRenderTargets.top()->Release();
		m_glyphRenderTargets.pop();
	}
	
	SAFE_RELEASE(m_pFontCollection);
	for(size_t i=0; i < m_fonts.size(); ++i)
		SAFE_RELEASE(m_fonts[i].pFontFace);
	
	for(FontMap::iterator it = m_fontMap.begin(); it != m_fontMap.end(); ++it) {
		GlyphMap *glyphMap = (*it).second;
		
		delete[] glyphMap->glyphs;
		delete glyphMap;
	}
	
	DeleteCriticalSection(&m_renderTargetsCriticalSection);
	DeleteCriticalSection(&m_glyphMapsCriticalSection);
	DeleteCriticalSection(&m_fontsCriticalSection);
	DeleteCriticalSection(&m_insertGlyphCriticalSection);
}


// Init glyph provider
HRESULT CFW1GlyphProvider::initGlyphProvider(
	IFW1Factory *pFW1Factory,
	IFW1GlyphAtlas *pGlyphAtlas,
	IDWriteFactory *pDWriteFactory,
	IDWriteFontCollection *pFontCollection,
	UINT maxGlyphWidth,
	UINT maxGlyphHeight
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pGlyphAtlas == NULL || pDWriteFactory == NULL || pFontCollection == NULL)
		return E_INVALIDARG;
	
	pGlyphAtlas->AddRef();
	m_pGlyphAtlas = pGlyphAtlas;
	
	pDWriteFactory->AddRef();
	m_pDWriteFactory = pDWriteFactory;
	
	m_maxGlyphWidth = 384;
	if(maxGlyphWidth > 0 && maxGlyphWidth <= 8192)
		m_maxGlyphWidth = maxGlyphWidth;
	m_maxGlyphHeight = 384;
	if(maxGlyphHeight > 0 && maxGlyphHeight <= 8192)
		m_maxGlyphHeight = maxGlyphHeight;
	
	pFontCollection->AddRef();
	m_pFontCollection = pFontCollection;
	
	return S_OK;
}


// Get font index from DWrite font-face
UINT CFW1GlyphProvider::getFontIndexFromFontFace(IDWriteFontFace *pFontFace) {
	UINT fontIndex = 0xffffffff;
	
	EnterCriticalSection(&m_fontsCriticalSection);
	
	// Search for a matching fontface by pointer
	for(size_t i=0; i < m_fonts.size(); ++i) {
		const FontInfo &fontInfo = m_fonts[i];
		
		if(pFontFace == fontInfo.pFontFace) {
			fontIndex = static_cast<UINT>(i);
			break;
		}
	}
	
	LeaveCriticalSection(&m_fontsCriticalSection);
	
	// Get font-face name
	if(fontIndex == 0xffffffff) {
		std::wstring uniqueName = getUniqueNameFromFontFace(pFontFace);
		if(uniqueName.size() > 0) {
			IDWriteFontFace *pOldFontFace = NULL;
			
			pFontFace->AddRef();
			
			EnterCriticalSection(&m_fontsCriticalSection);
			
			// Search for a matching fontface by name
			for(size_t i=0; i < m_fonts.size(); ++i) {
				FontInfo &fontInfo = m_fonts[i];
				
				if(fontInfo.uniqueName == uniqueName) {
					pOldFontFace = fontInfo.pFontFace;
					fontInfo.pFontFace = pFontFace;
					fontIndex = static_cast<UINT>(i);
					break;
				}
			}
			
			// Add new font
			if(fontIndex == 0xffffffff) {
				FontInfo fontInfo;
				
				fontInfo.pFontFace = pFontFace;
				fontInfo.uniqueName = uniqueName;
				
				fontIndex = static_cast<UINT>(m_fonts.size());
				m_fonts.push_back(fontInfo);
			}
			
			LeaveCriticalSection(&m_fontsCriticalSection);
			
			SAFE_RELEASE(pOldFontFace);
		}
		else
			fontIndex = 0;
	}
	
	return fontIndex;
}


// Get unique name for a DWrite font-face
std::wstring CFW1GlyphProvider::getUniqueNameFromFontFace(IDWriteFontFace *pFontFace) {
	std::wstring uniqueName;
	
	IDWriteFont *pFont;
	HRESULT hResult = m_pFontCollection->GetFontFromFontFace(pFontFace, &pFont);
	if(SUCCEEDED(hResult)) {
		// Family name
		IDWriteFontFamily *pFontFamily;
		hResult = pFont->GetFontFamily(&pFontFamily);
		if(SUCCEEDED(hResult)) {
			IDWriteLocalizedStrings *pFamilyNames;
			hResult = pFontFamily->GetFamilyNames(&pFamilyNames);
			if(SUCCEEDED(hResult)) {
				UINT32 index;
				BOOL exists;
				hResult = pFamilyNames->FindLocaleName(L"en-us", &index, &exists);
				if(FAILED(hResult) || !exists)
					index = 0;
					
				if(pFamilyNames->GetCount() > index) {
					UINT32 length;
					hResult = pFamilyNames->GetStringLength(index, &length);
					if(SUCCEEDED(hResult)) {
						std::vector<WCHAR> str(length+1);
						
						hResult = pFamilyNames->GetString(index, &str[0], length+1);
						if(SUCCEEDED(hResult))
							uniqueName = &str[0];
					}
				}
				
				pFamilyNames->Release();
			}
			
			pFontFamily->Release();
		}
		
		// Face name
		IDWriteLocalizedStrings *pFaceNames;
		hResult = pFont->GetFaceNames(&pFaceNames);
		if(SUCCEEDED(hResult)) {
			UINT32 index;
			BOOL exists;
			hResult = pFaceNames->FindLocaleName(L"en-us", &index, &exists);
			if(FAILED(hResult) || !exists)
				index = 0;
					
			if(pFaceNames->GetCount() > index) {
				UINT32 length;
				hResult = pFaceNames->GetStringLength(index, &length);
				if(SUCCEEDED(hResult)) {
					std::vector<WCHAR> str(length+1);
						
					hResult = pFaceNames->GetString(index, &str[0], length+1);
					if(SUCCEEDED(hResult))
						uniqueName.append(&str[0]);
				}
			}
				
			pFaceNames->Release();
		}
		
		// Simulations
		if(uniqueName.size() > 0) {
			DWRITE_FONT_SIMULATIONS simulations = pFontFace->GetSimulations();
			if(simulations == DWRITE_FONT_SIMULATIONS_BOLD)
				uniqueName += L"SimBold";
			else if(simulations == DWRITE_FONT_SIMULATIONS_OBLIQUE)
				uniqueName += L"SimOblique";
		}
	}
	
	return uniqueName;
}


// Render and insert new glyph into a glyph-map
UINT CFW1GlyphProvider::insertNewGlyph(GlyphMap *glyphMap, UINT16 glyphIndex, IDWriteFontFace *pFontFace) {
	UINT glyphAtlasId = 0xffffffff;
	
	// Get a render target
	IFW1DWriteRenderTarget *pRenderTarget = NULL;
	
	EnterCriticalSection(&m_renderTargetsCriticalSection);
	
	if(!m_glyphRenderTargets.empty()) {
		pRenderTarget = m_glyphRenderTargets.top();
		m_glyphRenderTargets.pop();
	}
	
	LeaveCriticalSection(&m_renderTargetsCriticalSection);
	
	if(pRenderTarget == NULL) {
		IFW1DWriteRenderTarget *pNewRenderTarget;
		HRESULT hResult = m_pFW1Factory->CreateDWriteRenderTarget(
			m_pDWriteFactory,
			m_maxGlyphWidth,
			m_maxGlyphHeight,
			&pNewRenderTarget
		);
		if(FAILED(hResult)) {
		}
		else {
			pRenderTarget = pNewRenderTarget;
		}
	}
	
	if(pRenderTarget != NULL) {
		// Draw the glyph image
		DWRITE_RENDERING_MODE renderingMode = DWRITE_RENDERING_MODE_DEFAULT;
		DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL;
		if((glyphMap->fontFlags & FW1_ALIASED) != 0) {
			renderingMode = DWRITE_RENDERING_MODE_ALIASED;
			measuringMode = DWRITE_MEASURING_MODE_GDI_CLASSIC;
		}
		
		FW1_GLYPHIMAGEDATA glyphData;
		HRESULT hResult = pRenderTarget->DrawGlyphTemp(
			pFontFace,
			glyphIndex,
			glyphMap->fontSize,
			renderingMode,
			measuringMode,
			&glyphData
		);
		if(FAILED(hResult)) {
		}
		else {
			// Insert into the atlas and the glyph-map
			EnterCriticalSection(&m_insertGlyphCriticalSection);
			
			glyphAtlasId = glyphMap->glyphs[glyphIndex];
			if(glyphAtlasId == 0xffffffff) {
				glyphAtlasId = m_pGlyphAtlas->InsertGlyph(
					&glyphData.Metrics,
					glyphData.pGlyphPixels,
					glyphData.RowPitch,
					glyphData.PixelStride
				);
				if(glyphAtlasId != 0xffffffff)
					glyphMap->glyphs[glyphIndex] = glyphAtlasId;
			}
			
			LeaveCriticalSection(&m_insertGlyphCriticalSection);
		}
		
		// Keep the render target for future use
		EnterCriticalSection(&m_renderTargetsCriticalSection);
		m_glyphRenderTargets.push(pRenderTarget);
		LeaveCriticalSection(&m_renderTargetsCriticalSection);
	}
	
	return glyphAtlasId;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphProvider.h`:

```h
// CFW1GlyphProvider.h

#ifndef IncludeGuard__FW1_CFW1GlyphProvider
#define IncludeGuard__FW1_CFW1GlyphProvider

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Fonts and glyphs-maps collection to match glyphs to images in a glyph-atlas
class CFW1GlyphProvider : public CFW1Object<IFW1GlyphProvider> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphProvider
		virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(IDWriteFactory **ppDWriteFactory);
		virtual HRESULT STDMETHODCALLTYPE GetDWriteFontCollection(IDWriteFontCollection **ppFontCollection);
		
		virtual const void* STDMETHODCALLTYPE GetGlyphMapFromFont(
			IDWriteFontFace *pFontFace,
			FLOAT FontSize,
			UINT FontFlags
		);
		virtual UINT STDMETHODCALLTYPE GetAtlasIdFromGlyphIndex(
			const void* pGlyphMap,
			UINT16 GlyphIndex,
			IDWriteFontFace *pFontFace,
			UINT FontFlags
		);
	
	// Public functions
	public:
		CFW1GlyphProvider();
		
		HRESULT initGlyphProvider(
			IFW1Factory *pFW1Factory,
			IFW1GlyphAtlas *pGlyphAtlas,
			IDWriteFactory *pDWriteFactory,
			IDWriteFontCollection *pFontCollection,
			UINT maxGlyphWidth,
			UINT maxGlyphHeight
		);
	
	// Internal types
	private:
		struct GlyphMap {
			FLOAT							fontSize;
			UINT							fontFlags;
			
			UINT							*glyphs;
			UINT							glyphCount;
		};
		
		struct FontInfo {
			IDWriteFontFace					*pFontFace;
			std::wstring					uniqueName;
		};
		
		typedef std::pair<UINT, std::pair<UINT, FLOAT> > FontId;
		typedef std::map<FontId, GlyphMap*> FontMap;
		
		FontId makeFontId(UINT fontIndex, UINT fontFlags, FLOAT fontSize) {
			UINT relevantFlags = (fontFlags & (FW1_ALIASED));
			return std::make_pair(fontIndex, std::make_pair(relevantFlags, fontSize));
		}
	
	// Internal functions
	private:
		virtual ~CFW1GlyphProvider();
		
		UINT getFontIndexFromFontFace(IDWriteFontFace *pFontFace);
		std::wstring getUniqueNameFromFontFace(IDWriteFontFace *pFontFace);
		
		UINT insertNewGlyph(GlyphMap *glyphMap, UINT16 glyphIndex, IDWriteFontFace *pFontFace);
	
	// Internal data
	private:
		IFW1GlyphAtlas						*m_pGlyphAtlas;
		
		IDWriteFactory						*m_pDWriteFactory;
		UINT								m_maxGlyphWidth;
		UINT								m_maxGlyphHeight;
		std::stack<IFW1DWriteRenderTarget*>	m_glyphRenderTargets;
		
		IDWriteFontCollection				*m_pFontCollection;
		std::vector<FontInfo>				m_fonts;
		
		FontMap								m_fontMap;
		
		CRITICAL_SECTION					m_renderTargetsCriticalSection;
		CRITICAL_SECTION					m_glyphMapsCriticalSection;
		CRITICAL_SECTION					m_fontsCriticalSection;
		CRITICAL_SECTION					m_insertGlyphCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphProvider

```

`dwmhook/FW1/CFW1GlyphProviderInterface.cpp`:

```cpp
// CFW1GlyphProviderInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphProvider.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphProvider))) {
		*ppvObject = static_cast<IFW1GlyphProvider*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get glyph atlas
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetGlyphAtlas(IFW1GlyphAtlas **ppGlyphAtlas) {
	if(ppGlyphAtlas == NULL)
		return E_INVALIDARG;
	
	m_pGlyphAtlas->AddRef();
	*ppGlyphAtlas = m_pGlyphAtlas;
	
	return S_OK;
}


// Get DWrite factory
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetDWriteFactory(IDWriteFactory **ppDWriteFactory) {
	if(ppDWriteFactory == NULL)
		return E_INVALIDARG;
	
	m_pDWriteFactory->AddRef();
	*ppDWriteFactory = m_pDWriteFactory;
	
	return S_OK;
}


// Get DWrite font collection
HRESULT STDMETHODCALLTYPE CFW1GlyphProvider::GetDWriteFontCollection(IDWriteFontCollection **ppFontCollection) {
	if(ppFontCollection == NULL)
		return E_INVALIDARG;
	
	m_pFontCollection->AddRef();
	*ppFontCollection = m_pFontCollection;
	
	return S_OK;
}


// Get glyph map
const void* STDMETHODCALLTYPE CFW1GlyphProvider::GetGlyphMapFromFont(
	IDWriteFontFace *pFontFace,
	FLOAT FontSize,
	UINT FontFlags
) {
	// Get font id
	UINT fontIndex = getFontIndexFromFontFace(pFontFace);
	FontId fontId = makeFontId(fontIndex, FontFlags, FontSize);
	
	const void *glyphMap = 0;
	
	// Get the glyph-map
	EnterCriticalSection(&m_glyphMapsCriticalSection);
	FontMap::iterator it = m_fontMap.find(fontId);
	if(it != m_fontMap.end())
		glyphMap = (*it).second;
	LeaveCriticalSection(&m_glyphMapsCriticalSection);
	
	if(glyphMap == 0 && (FontFlags & FW1_NONEWGLYPHS) == 0) {
		// Create a new glyph-map
		GlyphMap *newGlyphMap = new GlyphMap;
		newGlyphMap->fontSize = FontSize;
		newGlyphMap->fontFlags = FontFlags;
		newGlyphMap->glyphCount = pFontFace->GetGlyphCount();
		newGlyphMap->glyphs = new UINT[newGlyphMap->glyphCount];
		for(UINT i=0; i < newGlyphMap->glyphCount; ++i)
			newGlyphMap->glyphs[i] = 0xffffffff;
		
		bool needless = false;
		
		// Inert the new glyph-map and map the font-id to its index
		EnterCriticalSection(&m_glyphMapsCriticalSection);
		
		it = m_fontMap.find(fontId);
		if(it != m_fontMap.end()) {
			glyphMap = (*it).second;
			needless = true;
		}
		else {
			m_fontMap.insert(std::make_pair(fontId, newGlyphMap));
			glyphMap = newGlyphMap;
		}
		
		LeaveCriticalSection(&m_glyphMapsCriticalSection);
		
		if(needless) {// Simultaneous creation on two threads
			delete[] newGlyphMap->glyphs;
			delete newGlyphMap;
		}
		else {
			UINT glyphAtlasId = insertNewGlyph(newGlyphMap, 0, pFontFace);
			glyphAtlasId;
		}
	}
	
	return glyphMap;
}


// Get atlas id of a glyph
UINT STDMETHODCALLTYPE CFW1GlyphProvider::GetAtlasIdFromGlyphIndex(
	const void *pGlyphMap,
	UINT16 GlyphIndex,
	IDWriteFontFace *pFontFace,
	UINT FontFlags
) {
	GlyphMap *glyphMap = static_cast<GlyphMap*>(const_cast<void*>(pGlyphMap));
	
	if(glyphMap == 0)
		return 0;
	
	if(GlyphIndex >= glyphMap->glyphCount)
		return 0;
	
	// Get the atlas id for this glyph
	UINT glyphAtlasId = glyphMap->glyphs[GlyphIndex];
	if(glyphAtlasId == 0xffffffff && (FontFlags & FW1_NONEWGLYPHS) == 0)
		glyphAtlasId = insertNewGlyph(glyphMap, GlyphIndex, pFontFace);
	
	// Fall back to the font default-glyph or the atlas default-glyph on failure
	if(glyphAtlasId == 0xffffffff) {
		glyphAtlasId = glyphMap->glyphs[0];
		
		if((FontFlags & FW1_NONEWGLYPHS) == 0) {
			if(glyphAtlasId == 0xffffffff) {
				if(GlyphIndex == 0)
					glyphAtlasId = 0;
				else
					glyphAtlasId = GetAtlasIdFromGlyphIndex(pGlyphMap, 0, pFontFace, FontFlags);
			}
			
			EnterCriticalSection(&m_insertGlyphCriticalSection);
			if(glyphMap->glyphs[GlyphIndex] == 0xffffffff)
				glyphMap->glyphs[GlyphIndex] = glyphAtlasId;
			LeaveCriticalSection(&m_insertGlyphCriticalSection);
		}
		
		if(glyphAtlasId == 0xffffffff)
			glyphAtlasId = 0;
	}
	
	return glyphAtlasId;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphRenderStates.cpp`:

```cpp
// CFW1GlyphRenderStates.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphRenderStates.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphRenderStates::CFW1GlyphRenderStates() :
	m_pfnD3DCompile(NULL),
	
	m_pDevice(NULL),
	m_featureLevel(D3D_FEATURE_LEVEL_9_1),
	
	m_pVertexShaderQuad(NULL),
	m_pVertexShaderClipQuad(NULL),
	m_pQuadInputLayout(NULL),
	
	m_pVertexShaderPoint(NULL),
	m_pPointInputLayout(NULL),
	m_pGeometryShaderPoint(NULL),
	m_pGeometryShaderClipPoint(NULL),
	m_hasGeometryShader(false),
	
	m_pPixelShader(NULL),
	m_pPixelShaderClip(NULL),
	
	m_pConstantBuffer(NULL),
	
	m_pBlendState(NULL),
	m_pSamplerState(NULL),
	m_pRasterizerState(NULL),
	m_pDepthStencilState(NULL)
{
}


// Destruct
CFW1GlyphRenderStates::~CFW1GlyphRenderStates() {
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pVertexShaderQuad);
	SAFE_RELEASE(m_pVertexShaderClipQuad);
	SAFE_RELEASE(m_pQuadInputLayout);
	
	SAFE_RELEASE(m_pVertexShaderPoint);
	SAFE_RELEASE(m_pPointInputLayout);
	SAFE_RELEASE(m_pGeometryShaderPoint);
	SAFE_RELEASE(m_pGeometryShaderClipPoint);
	
	SAFE_RELEASE(m_pPixelShader);
	SAFE_RELEASE(m_pPixelShaderClip);
	
	SAFE_RELEASE(m_pConstantBuffer);
	
	SAFE_RELEASE(m_pBlendState);
	SAFE_RELEASE(m_pSamplerState);
	SAFE_RELEASE(m_pRasterizerState);
	SAFE_RELEASE(m_pDepthStencilState);
}


// Init
HRESULT CFW1GlyphRenderStates::initRenderResources(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	bool wantGeometryShader,
	bool anisotropicFiltering
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	m_featureLevel = m_pDevice->GetFeatureLevel();
	
	// D3DCompiler
#ifdef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	HMODULE hD3DCompiler = LoadLibrary(D3DCOMPILER_DLL);
	if(hD3DCompiler == NULL) {
		DWORD dwErr = GetLastError();
		dwErr;
		m_lastError = std::wstring(L"Failed to load ") + D3DCOMPILER_DLL_W;
		hResult = E_FAIL;
	}
	else {
		m_pfnD3DCompile = reinterpret_cast<pD3DCompile>(GetProcAddress(hD3DCompiler, "D3DCompile"));
		if(m_pfnD3DCompile == NULL) {
			DWORD dwErr = GetLastError();
			dwErr;
			m_lastError = std::wstring(L"Failed to load D3DCompile from ") + D3DCOMPILER_DLL_W;
			hResult = E_FAIL;
		}
		else {
			hResult = S_OK;
		}
	}
#else
	m_pfnD3DCompile = D3DCompile;
	hResult = S_OK;
#endif
	
	// Create all needed resources
	if(SUCCEEDED(hResult))
		hResult = createQuadShaders();
	if(SUCCEEDED(hResult))
		hResult = createPixelShaders();
	if(SUCCEEDED(hResult))
		hResult = createConstantBuffer();
	if(SUCCEEDED(hResult))
		hResult = createRenderStates(anisotropicFiltering);
	if(SUCCEEDED(hResult) && wantGeometryShader) {
		hResult = createGlyphShaders();
		if(FAILED(hResult))
			hResult = S_OK;
	}
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
#ifdef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	FreeLibrary(hD3DCompiler);
#endif
	
	return hResult;
}


// Create quad shaders
HRESULT CFW1GlyphRenderStates::createQuadShaders() {
	// Vertex shaders
	const char vsSimpleStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"};\r\n"
	"\r\n"
	"struct VSIn {\r\n"
	"	float4 Position : POSITION;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct VSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"VSOut VS(VSIn Input) {\r\n"
	"	VSOut Output;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(Input.Position.xy, 0.0f, 1.0f));\r\n"
	"	Output.GlyphColor = Input.GlyphColor;\r\n"
	"	Output.TexCoord = Input.Position.zw;\r\n"
	"	\r\n"
	"	return Output;\r\n"
	"}\r\n"
	"";
	
	const char vsClipStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"	float4 ClipRect : packoffset(c4);\r\n"
	"};\r\n"
	"\r\n"
	"struct VSIn {\r\n"
	"	float4 Position : POSITION;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct VSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : CLIPDISTANCE;\r\n"
	"};\r\n"
	"\r\n"
	"VSOut VS(VSIn Input) {\r\n"
	"	VSOut Output;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(Input.Position.xy, 0.0f, 1.0f));\r\n"
	"	Output.GlyphColor = Input.GlyphColor;\r\n"
	"	Output.TexCoord = Input.Position.zw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(Input.Position.xy, -Input.Position.xy);\r\n"
	"	\r\n"
	"	return Output;\r\n"
	"}\r\n"
	"";
	
	// Shader compile profile
	const char *vs_profile = "vs_4_0_level_9_1";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		vs_profile = "vs_5_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
		vs_profile = "vs_4_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_9_3)
		vs_profile = "vs_4_0_level_9_3";
	
	// Compile vertex shader
	ID3DBlob *pVSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		vsSimpleStr,
		sizeof(vsSimpleStr),
		NULL,
		NULL,
		NULL,
		"VS",
		vs_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pVSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile vertex shader";
	}
	else {
		// Create vertex shader
		ID3D11VertexShader *pVS;
		
		hResult = m_pDevice->CreateVertexShader(pVSCode->GetBufferPointer(), pVSCode->GetBufferSize(), NULL, &pVS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create vertex shader";
		}
		else {
			// Compile clipping vertex shader
			ID3DBlob *pVSClipCode;
			
			hResult = m_pfnD3DCompile(
				vsClipStr,
				sizeof(vsClipStr),
				NULL,
				NULL,
				NULL,
				"VS",
				vs_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pVSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping vertex shader";
			}
			else {
				// Create vertex shader
				ID3D11VertexShader *pVSClip;
				
				hResult = m_pDevice->CreateVertexShader(
					pVSClipCode->GetBufferPointer(),
					pVSClipCode->GetBufferSize(),
					NULL,
					&pVSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping vertex shader";
				}
				else {
					// Create input layout
					ID3D11InputLayout *pInputLayout;
					
					// Quad vertex input layout
					D3D11_INPUT_ELEMENT_DESC inputElements[] = {
						{"POSITION", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
						{"GLYPHCOLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0}
					};
					
					hResult = m_pDevice->CreateInputLayout(
						inputElements,
						2,
						pVSCode->GetBufferPointer(),
						pVSCode->GetBufferSize(),
						&pInputLayout
					);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to create input layout";
					}
					else {
						// Success
						m_pVertexShaderQuad = pVS;
						m_pVertexShaderClipQuad = pVSClip;
						m_pQuadInputLayout = pInputLayout;
						
						hResult = S_OK;
					}
					
					if(FAILED(hResult))
						pVSClip->Release();
				}
				
				pVSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pVS->Release();
		}
		
		pVSCode->Release();
	}
	
	return hResult;
}

// Create point to quad geometry shader
HRESULT CFW1GlyphRenderStates::createGlyphShaders() {
	if(m_featureLevel < D3D_FEATURE_LEVEL_10_0)
		return E_FAIL;
	
	// Geometry shader constructing glyphs from point input and texture buffer
	const char gsSimpleStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"};\r\n"
	"\r\n"
	"Buffer<float4> tex0 : register(t0);\r\n"
	"\r\n"
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct GSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"[maxvertexcount(4)]\r\n"
	"void GS(point GSIn Input[1], inout TriangleStream<GSOut> TriStream) {\r\n"
	"	const float2 basePosition = Input[0].PositionIndex.xy;\r\n"
	"	const uint glyphIndex = asuint(Input[0].PositionIndex.z);\r\n"
	"	\r\n"
	"	float4 texCoords = tex0.Load(uint2(glyphIndex*2, 0));\r\n"
	"	float4 offsets = tex0.Load(uint2(glyphIndex*2+1, 0));\r\n"
	"	\r\n"
	"	GSOut Output;\r\n"
	"	Output.GlyphColor = Input[0].GlyphColor;\r\n"
	"	\r\n"
	"	float4 positions = basePosition.xyxy + offsets;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xy;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zy;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xw;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zw;\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	TriStream.RestartStrip();\r\n"
	"}\r\n"
	"";
	
	// Geometry shader with rect clipping
	const char gsClipStr[] =
	"cbuffer ShaderConstants : register(b0) {\r\n"
	"	float4x4 TransformMatrix : packoffset(c0);\r\n"
	"	float4 ClipRect : packoffset(c4);\r\n"
	"};\r\n"
	"\r\n"
	"Buffer<float4> tex0 : register(t0);\r\n"
	"\r\n"
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"struct GSOut {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : SV_ClipDistance;\r\n"
	"};\r\n"
	"\r\n"
	"[maxvertexcount(4)]\r\n"
	"void GS(point GSIn Input[1], inout TriangleStream<GSOut> TriStream) {\r\n"
	"	const float2 basePosition = Input[0].PositionIndex.xy;\r\n"
	"	const uint glyphIndex = asuint(Input[0].PositionIndex.z);\r\n"
	"	\r\n"
	"	float4 texCoords = tex0.Load(uint2(glyphIndex*2, 0));\r\n"
	"	float4 offsets = tex0.Load(uint2(glyphIndex*2+1, 0));\r\n"
	"	\r\n"
	"	GSOut Output;\r\n"
	"	Output.GlyphColor = Input[0].GlyphColor;\r\n"
	"	\r\n"
	"	float4 positions = basePosition.xyxy + offsets;\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xy;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.xy, -positions.xy);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zy, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zy;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.zy, -positions.zy);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.xw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.xw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.xw, -positions.xw);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	Output.Position = mul(TransformMatrix, float4(positions.zw, 0.0f, 1.0f));\r\n"
	"	Output.TexCoord = texCoords.zw;\r\n"
	"	Output.ClipDistance = ClipRect + float4(positions.zw, -positions.zw);\r\n"
	"	TriStream.Append(Output);\r\n"
	"	\r\n"
	"	TriStream.RestartStrip();\r\n"
	"}\r\n"
	"";
	
	// Vertex shader
	const char vsEmptyStr[] =
	"struct GSIn {\r\n"
	"	float3 PositionIndex : POSITIONINDEX;\r\n"
	"	float4 GlyphColor : GLYPHCOLOR;\r\n"
	"};\r\n"
	"\r\n"
	"GSIn VS(GSIn Input) {\r\n"
	"	return Input;\r\n"
	"}\r\n"
	"";
	
	// Shader compile profiles
	const char *vs_profile = "vs_4_0";
	const char *gs_profile = "gs_4_0";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
		vs_profile = "vs_5_0";
		gs_profile = "gs_5_0";
	}
	
	// Compile geometry shader
	ID3DBlob *pGSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		gsSimpleStr,
		sizeof(gsSimpleStr),
		NULL,
		NULL,
		NULL,
		"GS",
		gs_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pGSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile geometry shader";
	}
	else {
		// Create geometry shader
		ID3D11GeometryShader *pGS;
		
		hResult = m_pDevice->CreateGeometryShader(pGSCode->GetBufferPointer(), pGSCode->GetBufferSize(), NULL, &pGS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create geometry shader";
		}
		else {
			// Compile clipping geometry shader
			ID3DBlob *pGSClipCode;
			
			hResult = m_pfnD3DCompile(
				gsClipStr,
				sizeof(gsClipStr),
				NULL,
				NULL,
				NULL,
				"GS",
				gs_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pGSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping geometry shader";
			}
			else {
				// Create clipping geometry shader
				ID3D11GeometryShader *pGSClip;
				
				hResult = m_pDevice->CreateGeometryShader(
					pGSClipCode->GetBufferPointer(),
					pGSClipCode->GetBufferSize(),
					NULL,
					&pGSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping geometry shader";
				}
				else {
					ID3DBlob *pVSEmptyCode;
					
					// Compile vertex shader
					hResult = m_pfnD3DCompile(
						vsEmptyStr,
						sizeof(vsEmptyStr),
						NULL,
						NULL,
						NULL,
						"VS",
						vs_profile,
						D3DCOMPILE_OPTIMIZATION_LEVEL3,
						0,
						&pVSEmptyCode,
						NULL
					);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to compile empty vertex shader";
					}
					else {
						// Create vertex shader
						ID3D11VertexShader *pVSEmpty;
						
						hResult = m_pDevice->CreateVertexShader(
							pVSEmptyCode->GetBufferPointer(),
							pVSEmptyCode->GetBufferSize(),
							NULL,
							&pVSEmpty
						);
						if(FAILED(hResult)) {
							m_lastError = L"Failed to create empty vertex shader";
						}
						else {
							ID3D11InputLayout *pInputLayout;
							
							// Input layout for geometry shader
							D3D11_INPUT_ELEMENT_DESC inputElements[] = {
								{"POSITIONINDEX", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
								{"GLYPHCOLOR", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0}
							};
							
							hResult = m_pDevice->CreateInputLayout(
								inputElements,
								2,
								pVSEmptyCode->GetBufferPointer(),
								pVSEmptyCode->GetBufferSize(),
								&pInputLayout
							);
							if(FAILED(hResult)) {
								m_lastError = L"Failed to create input layout for geometry shader";
							}
							else {
								// Success
								m_pVertexShaderPoint = pVSEmpty;
								m_pGeometryShaderPoint = pGS;
								m_pGeometryShaderClipPoint = pGSClip;
								m_pPointInputLayout = pInputLayout;
								m_hasGeometryShader = true;
								
								hResult = S_OK;
							}
							
							if(FAILED(hResult))
								pVSEmpty->Release();
						}
						
						pVSEmptyCode->Release();
					}
					
					if(FAILED(hResult))
						pGSClip->Release();
				}
				
				pGSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pGS->Release();
		}
		
		pGSCode->Release();
	}
	
	return hResult;
}

// Create pixel shaders
HRESULT CFW1GlyphRenderStates::createPixelShaders() {
	// Pixel shader
	const char psStr[] =
	"SamplerState sampler0 : register(s0);\r\n"
	"Texture2D<float> tex0 : register(t0);\r\n"
	"\r\n"
	"struct PSIn {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"};\r\n"
	"\r\n"
	"float4 PS(PSIn Input) : SV_Target {\r\n"
	"	float a = tex0.Sample(sampler0, Input.TexCoord);\r\n"
	"	\r\n"
	"	if(a == 0.0f)\r\n"
	"		discard;\r\n"
	"	\r\n"
	"	return (a * Input.GlyphColor.a) * float4(Input.GlyphColor.rgb, 1.0f);\r\n"
	"}\r\n"
	"";
	
	// Clipping pixel shader
	const char psClipStr[] =
	"SamplerState sampler0 : register(s0);\r\n"
	"Texture2D<float> tex0 : register(t0);\r\n"
	"\r\n"
	"struct PSIn {\r\n"
	"	float4 Position : SV_Position;\r\n"
	"	float4 GlyphColor : COLOR;\r\n"
	"	float2 TexCoord : TEXCOORD;\r\n"
	"	float4 ClipDistance : CLIPDISTANCE;\r\n"
	"};\r\n"
	"\r\n"
	"float4 PS(PSIn Input) : SV_Target {\r\n"
	"	clip(Input.ClipDistance);\r\n"
	"	\r\n"
	"	float a = tex0.Sample(sampler0, Input.TexCoord);\r\n"
	"	\r\n"
	"	if(a == 0.0f)\r\n"
	"		discard;\r\n"
	"	\r\n"
	"	return (a * Input.GlyphColor.a) * float4(Input.GlyphColor.rgb, 1.0f);\r\n"
	"}\r\n"
	"";
	
	// Shader compile profile
	const char *ps_profile = "ps_4_0_level_9_1";
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0)
		ps_profile = "ps_5_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
		ps_profile = "ps_4_0";
	else if(m_featureLevel >= D3D_FEATURE_LEVEL_9_3)
		ps_profile = "ps_4_0_level_9_3";
	
	// Compile pixel shader
	ID3DBlob *pPSCode;
	
	HRESULT hResult = m_pfnD3DCompile(
		psStr,
		sizeof(psStr),
		NULL,
		NULL,
		NULL,
		"PS",
		ps_profile,
		D3DCOMPILE_OPTIMIZATION_LEVEL3,
		0,
		&pPSCode,
		NULL
	);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to compile pixel shader";
	}
	else {
		// Create pixel shader
		ID3D11PixelShader *pPS;
		
		hResult = m_pDevice->CreatePixelShader(pPSCode->GetBufferPointer(), pPSCode->GetBufferSize(), NULL, &pPS);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create pixel shader";
		}
		else {
			// Compile clipping pixel shader
			ID3DBlob *pPSClipCode;
			
			HRESULT hResult = m_pfnD3DCompile(
				psClipStr,
				sizeof(psClipStr),
				NULL,
				NULL,
				NULL,
				"PS",
				ps_profile,
				D3DCOMPILE_OPTIMIZATION_LEVEL3,
				0,
				&pPSClipCode,
				NULL
			);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to compile clipping pixel shader";
			}
			else {
				// Create pixel shader
				ID3D11PixelShader *pPSClip;
				
				hResult = m_pDevice->CreatePixelShader(
					pPSClipCode->GetBufferPointer(),
					pPSClipCode->GetBufferSize(),
					NULL, &pPSClip
				);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create clipping pixel shader";
				}
				else {
					// Success
					m_pPixelShader = pPS;
					m_pPixelShaderClip = pPSClip;
					
					hResult = S_OK;
				}
				
				pPSClipCode->Release();
			}
			
			if(FAILED(hResult))
				pPS->Release();
		}
		
		pPSCode->Release();
	}
	
	return hResult;
}


// Create constant buffer
HRESULT CFW1GlyphRenderStates::createConstantBuffer() {
	// Create constant buffer
	D3D11_BUFFER_DESC constantBufferDesc;
	ID3D11Buffer *pConstantBuffer;
			
	ZeroMemory(&constantBufferDesc, sizeof(constantBufferDesc));
	constantBufferDesc.ByteWidth = sizeof(ShaderConstants);
	constantBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constantBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
			
	HRESULT hResult = m_pDevice->CreateBuffer(&constantBufferDesc, NULL, &pConstantBuffer);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create constant buffer";
	}
	else {
		// Success
		m_pConstantBuffer = pConstantBuffer;
				
		hResult = S_OK;
	}

	return hResult;
}


// Create render states
HRESULT CFW1GlyphRenderStates::createRenderStates(bool anisotropicFiltering) {
	// Create blend-state
	D3D11_BLEND_DESC blendDesc;
	ID3D11BlendState *pBlendState;
	
	ZeroMemory(&blendDesc, sizeof(blendDesc));
	for(int i=0; i < 4; ++i) {
		blendDesc.RenderTarget[i].BlendEnable = TRUE;
		blendDesc.RenderTarget[i].SrcBlend = D3D11_BLEND_ONE;
		blendDesc.RenderTarget[i].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
		blendDesc.RenderTarget[i].BlendOp = D3D11_BLEND_OP_ADD;
		blendDesc.RenderTarget[i].SrcBlendAlpha = D3D11_BLEND_ONE;
		blendDesc.RenderTarget[i].DestBlendAlpha = D3D11_BLEND_ZERO;
		blendDesc.RenderTarget[i].BlendOpAlpha = D3D11_BLEND_OP_ADD;
		blendDesc.RenderTarget[i].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
	}
	
	HRESULT hResult = m_pDevice->CreateBlendState(&blendDesc, &pBlendState);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create blend state";
	}
	else {
		// Create sampler state
		D3D11_SAMPLER_DESC samplerDesc;
		ID3D11SamplerState *pSamplerState;
		
		ZeroMemory(&samplerDesc, sizeof(samplerDesc));
		if(anisotropicFiltering) {
			samplerDesc.Filter = D3D11_FILTER_ANISOTROPIC;
			samplerDesc.MaxAnisotropy = 2;
			if(m_featureLevel >= D3D_FEATURE_LEVEL_9_2)
				samplerDesc.MaxAnisotropy = 5;
		}
		else
			samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
		samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
		samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;
		
		hResult = m_pDevice->CreateSamplerState(&samplerDesc, &pSamplerState);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create sampler state";
		}
		else {
			// Create rasterizer state
			D3D11_RASTERIZER_DESC rasterizerDesc;
			ID3D11RasterizerState *pRasterizerState;
			
			ZeroMemory(&rasterizerDesc, sizeof(rasterizerDesc));
			rasterizerDesc.FillMode = D3D11_FILL_SOLID;
			rasterizerDesc.CullMode = D3D11_CULL_NONE;
			rasterizerDesc.FrontCounterClockwise = FALSE;
			rasterizerDesc.DepthClipEnable = TRUE;
			
			hResult = m_pDevice->CreateRasterizerState(&rasterizerDesc, &pRasterizerState);
			if(FAILED(hResult)) {
				m_lastError = L"Failed to create rasterizer state";
			}
			else {
				// Create depth-stencil state
				D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
				ID3D11DepthStencilState *pDepthStencilState;
				
				ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));
				depthStencilDesc.DepthEnable = FALSE;
				
				hResult = m_pDevice->CreateDepthStencilState(&depthStencilDesc, &pDepthStencilState);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create depth stencil state";
				}
				else {
					// Success
					m_pBlendState = pBlendState;
					m_pSamplerState = pSamplerState;
					m_pRasterizerState = pRasterizerState;
					m_pDepthStencilState = pDepthStencilState;
					
					hResult = S_OK;
				}
				
				if(FAILED(hResult))
					pRasterizerState->Release();
			}
			
			if(FAILED(hResult))
				pSamplerState->Release();
		}
		
		if(FAILED(hResult))
			pBlendState->Release();
	}
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphRenderStates.h`:

```h
// CFW1GlyphRenderStates.h

#ifndef IncludeGuard__FW1_CFW1GlyphRenderStates
#define IncludeGuard__FW1_CFW1GlyphRenderStates

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Shader etc. needed to draw glyphs
class CFW1GlyphRenderStates : public CFW1Object<IFW1GlyphRenderStates> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphRenderStates
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual void STDMETHODCALLTYPE SetStates(ID3D11DeviceContext *pContext, UINT Flags);
		virtual void STDMETHODCALLTYPE UpdateShaderConstants(
			ID3D11DeviceContext *pContext,
			const FW1_RECTF *pClipRect,
			const FLOAT *pTransformMatrix
		);
		virtual BOOL STDMETHODCALLTYPE HasGeometryShader();
	
	// Public functions
	public:
		CFW1GlyphRenderStates();
		
		HRESULT initRenderResources(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			bool wantGeometryShader,
			bool anisotropicFiltering
		);
	
	// Internal types
	private:
		struct ShaderConstants {
			FLOAT					TransformMatrix[16];
			FLOAT					ClipRect[4];
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphRenderStates();
		
		HRESULT createQuadShaders();
		HRESULT createGlyphShaders();
		HRESULT createPixelShaders();
		HRESULT createConstantBuffer();
		HRESULT createRenderStates(bool anisotropicFiltering);
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		pD3DCompile					m_pfnD3DCompile;
		
		ID3D11Device				*m_pDevice;
		D3D_FEATURE_LEVEL			m_featureLevel;
		
		ID3D11VertexShader			*m_pVertexShaderQuad;
		ID3D11VertexShader			*m_pVertexShaderClipQuad;
		ID3D11InputLayout			*m_pQuadInputLayout;
		
		ID3D11VertexShader			*m_pVertexShaderPoint;
		ID3D11InputLayout			*m_pPointInputLayout;
		ID3D11GeometryShader		*m_pGeometryShaderPoint;
		ID3D11GeometryShader		*m_pGeometryShaderClipPoint;
		bool						m_hasGeometryShader;
		
		ID3D11PixelShader			*m_pPixelShader;
		ID3D11PixelShader			*m_pPixelShaderClip;
		
		ID3D11Buffer				*m_pConstantBuffer;
		
		ID3D11BlendState			*m_pBlendState;
		ID3D11SamplerState			*m_pSamplerState;
		ID3D11RasterizerState		*m_pRasterizerState;
		ID3D11DepthStencilState		*m_pDepthStencilState;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphRenderStates

```

`dwmhook/FW1/CFW1GlyphRenderStatesInterface.cpp`:

```cpp
// CFW1GlyphRenderStatesInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphRenderStates.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphRenderStates::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphRenderStates))) {
		*ppvObject = static_cast<IFW1GlyphRenderStates*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by the render states
HRESULT STDMETHODCALLTYPE CFW1GlyphRenderStates::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Set render states for glyph drawing
void STDMETHODCALLTYPE CFW1GlyphRenderStates::SetStates(ID3D11DeviceContext *pContext, UINT Flags) {
	if(m_hasGeometryShader && ((Flags & FW1_NOGEOMETRYSHADER) == 0)) {
		// Point vertices with geometry shader
		pContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);
		pContext->IASetInputLayout(m_pPointInputLayout);
		pContext->VSSetShader(m_pVertexShaderPoint, NULL, 0);
		if((Flags & FW1_CLIPRECT) != 0)
			pContext->GSSetShader(m_pGeometryShaderClipPoint, NULL, 0);
		else
			pContext->GSSetShader(m_pGeometryShaderPoint, NULL, 0);
		pContext->PSSetShader(m_pPixelShader, NULL, 0);
		pContext->GSSetConstantBuffers(0, 1, &m_pConstantBuffer);
	}
	else {
		// Quads constructed on the CPU
		pContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		pContext->IASetInputLayout(m_pQuadInputLayout);
		if((Flags & FW1_CLIPRECT) != 0) {
			pContext->VSSetShader(m_pVertexShaderClipQuad, NULL, 0);
			pContext->PSSetShader(m_pPixelShaderClip, NULL, 0);
		}
		else {
			pContext->VSSetShader(m_pVertexShaderQuad, NULL, 0);
			pContext->PSSetShader(m_pPixelShader, NULL, 0);
		}
		pContext->VSSetConstantBuffers(0, 1, &m_pConstantBuffer);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0)
			pContext->GSSetShader(NULL, NULL, 0);
	}
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
		pContext->DSSetShader(NULL, NULL, 0);
		pContext->HSSetShader(NULL, NULL, 0);
	}
	
	pContext->OMSetBlendState(m_pBlendState, NULL, 0xffffffff);
	pContext->OMSetDepthStencilState(m_pDepthStencilState, 0);
	
	pContext->RSSetState(m_pRasterizerState);
	
	pContext->PSSetSamplers(0, 1, &m_pSamplerState);
}


// Update constant buffer
void STDMETHODCALLTYPE CFW1GlyphRenderStates::UpdateShaderConstants(
	ID3D11DeviceContext *pContext,
	const FW1_RECTF *pClipRect,
	const FLOAT *pTransformMatrix
) {
	// Shader constants
	ShaderConstants constants;
	ZeroMemory(&constants, sizeof(constants));
	
	// Transform matrix
	if(pTransformMatrix != NULL)
		CopyMemory(constants.TransformMatrix, pTransformMatrix, 16*sizeof(FLOAT));
	else {
		// Get viewport size for orthographic transform
		FLOAT w = 512.0f;
		FLOAT h = 512.0f;
		
		D3D11_VIEWPORT vp;
		UINT nvp = 1;
		pContext->RSGetViewports(&nvp, &vp);
		if(nvp > 0) {
			if(vp.Width >= 1.0f && vp.Height >= 1.0f) {
				w = vp.Width;
				h = vp.Height;
			}
		}
		
		constants.TransformMatrix[0] = 2.0f / w;
		constants.TransformMatrix[12] = -1.0f;
		constants.TransformMatrix[5] = -2.0f / h;
		constants.TransformMatrix[13] = 1.0f;
		constants.TransformMatrix[10] = 1.0f;
		constants.TransformMatrix[15] = 1.0f;
	}
	
	// Clip rect
	if(pClipRect != NULL) {
		constants.ClipRect[0] = -pClipRect->Left;
		constants.ClipRect[1] = -pClipRect->Top;
		constants.ClipRect[2] = pClipRect->Right;
		constants.ClipRect[3] = pClipRect->Bottom;
	}
	else {
		constants.ClipRect[0] = FLT_MAX;
		constants.ClipRect[1] = FLT_MAX;
		constants.ClipRect[2] = FLT_MAX;
		constants.ClipRect[3] = FLT_MAX;
	}
	
	// Update constant buffer
	D3D11_MAPPED_SUBRESOURCE msr;
	HRESULT hResult = pContext->Map(m_pConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
	if(SUCCEEDED(hResult)) {
		CopyMemory(msr.pData, &constants, sizeof(constants));
		
		pContext->Unmap(m_pConstantBuffer, 0);
	}
}


// Check for geometry shader
BOOL STDMETHODCALLTYPE CFW1GlyphRenderStates::HasGeometryShader() {
	return (m_hasGeometryShader ? TRUE : FALSE);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphSheet.cpp`:

```cpp
// CFW1GlyphSheet.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphSheet.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphSheet::CFW1GlyphSheet() :
	m_sheetWidth(0),
	m_sheetHeight(0),
	m_hardwareCoordBuffer(false),
	m_allowOversizedGlyph(false),
	
	m_textureData(0),
	m_glyphCoords(0),
	m_maxGlyphCount(0),
	m_glyphCount(0),
	m_mipLevelCount(0),
	m_alignWidth(0),
	
	m_pDevice(NULL),
	
	m_pTexture(NULL),
	m_pTextureSRV(NULL),
	m_pCoordBuffer(NULL),
	m_pCoordBufferSRV(NULL),
	
	m_closed(false),
	m_static(false),
	
	m_heightRange(0),
	
	m_updatedGlyphCount(0)
{
	ZeroMemory(&m_dirtyRect, sizeof(m_dirtyRect));
	InitializeCriticalSection(&m_sheetCriticalSection);
	InitializeCriticalSection(&m_flushCriticalSection);
}


// Destruct
CFW1GlyphSheet::~CFW1GlyphSheet() {
	delete[] m_textureData;
	delete[] m_glyphCoords;
	
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pTexture);
	SAFE_RELEASE(m_pTextureSRV);
	SAFE_RELEASE(m_pCoordBuffer);
	SAFE_RELEASE(m_pCoordBufferSRV);
	
	delete m_heightRange;
	
	DeleteCriticalSection(&m_sheetCriticalSection);
	DeleteCriticalSection(&m_flushCriticalSection);
}


// Init
HRESULT CFW1GlyphSheet::initGlyphSheet(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT sheetWidth,
	UINT sheetHeight,
	bool coordBuffer,
	bool allowOversizedGlyph,
	UINT maxGlyphCount,
	UINT mipLevelCount
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	
	// Sheet metrics
	m_sheetWidth = 512;
	if(sheetWidth > 0)
		m_sheetWidth = sheetWidth;
	m_sheetHeight = 512;
	if(sheetHeight > 0)
		m_sheetHeight = sheetHeight;
	
	if(coordBuffer) {
		D3D_FEATURE_LEVEL featureLevel = m_pDevice->GetFeatureLevel();
		if(featureLevel >= D3D_FEATURE_LEVEL_10_0)
			m_hardwareCoordBuffer = true;
	}
	
	m_allowOversizedGlyph = allowOversizedGlyph;
	
	m_maxGlyphCount = 2048;
	if(maxGlyphCount > 0 && maxGlyphCount < 65535)
		m_maxGlyphCount = maxGlyphCount;
	
	if(mipLevelCount > 1) {
		m_mipLevelCount = std::min(mipLevelCount, 5U);// Reasonable mip limit considering borders
		m_alignWidth = (1 << (m_mipLevelCount - 1));
	}
	else {// 0 defaults to 1
		m_mipLevelCount = 1;
		m_alignWidth = 1;
	}
	
	// Storage
	UINT textureSize = m_sheetWidth * m_sheetHeight;
	UINT mipSize = textureSize;
	for(UINT i=1;i<m_mipLevelCount;++i) {
		mipSize >>= 2;
		textureSize += mipSize;
	}
	
	m_textureData = new UINT8[textureSize];
	ZeroMemory(m_textureData, textureSize);
	
	m_glyphCoords = new FW1_GLYPHCOORDS[m_maxGlyphCount];
	
	m_heightRange = new HeightRange(m_sheetWidth / m_alignWidth);
	
	// Device texture/coord-buffer
	hResult = createDeviceResources();
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create sheet texture and (optionally) coord buffer
HRESULT CFW1GlyphSheet::createDeviceResources() {
	// Create sheet texture
	D3D11_TEXTURE2D_DESC textureDesc;
	ID3D11Texture2D *pTexture;
	
	ZeroMemory(&textureDesc, sizeof(textureDesc));
	textureDesc.Width = m_sheetWidth;
	textureDesc.Height = m_sheetHeight;
	textureDesc.ArraySize = 1;
	textureDesc.Format = DXGI_FORMAT_R8_UNORM;
	textureDesc.SampleDesc.Count = 1;
	textureDesc.Usage = D3D11_USAGE_DEFAULT;
	textureDesc.MipLevels = m_mipLevelCount;
	textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	
	HRESULT hResult = m_pDevice->CreateTexture2D(&textureDesc, NULL, &pTexture);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create glyph sheet texture";
	}
	else {
		ID3D11ShaderResourceView *pTextureSRV;
		
		hResult = m_pDevice->CreateShaderResourceView(pTexture, NULL, &pTextureSRV);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create shader resource view for glyph sheet texture";
		}
		else {
			// Create coord buffer if enabled
			if(m_hardwareCoordBuffer) {
				D3D11_BUFFER_DESC bufferDesc;
				ID3D11Buffer *pBuffer;
				
				ZeroMemory(&bufferDesc, sizeof(bufferDesc));
				bufferDesc.ByteWidth = m_maxGlyphCount * sizeof(FW1_GLYPHCOORDS);
				bufferDesc.Usage = D3D11_USAGE_DEFAULT;
				bufferDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
				
				hResult = m_pDevice->CreateBuffer(&bufferDesc, NULL, &pBuffer);
				if(FAILED(hResult)) {
					m_lastError = L"Failed to create glyph coord buffer";
				}
				else {
					D3D11_SHADER_RESOURCE_VIEW_DESC bufferSRVDesc;
					ID3D11ShaderResourceView *pBufferSRV;
					
					ZeroMemory(&bufferSRVDesc, sizeof(bufferSRVDesc));
					bufferSRVDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
					bufferSRVDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
					bufferSRVDesc.Buffer.ElementOffset = 0;
					bufferSRVDesc.Buffer.ElementWidth = m_maxGlyphCount * 2;// Two float4 per glyphcoords
					
					hResult = m_pDevice->CreateShaderResourceView(pBuffer, &bufferSRVDesc, &pBufferSRV);
					if(FAILED(hResult)) {
						m_lastError = L"Failed to create shader resource view for glyph coord buffer";
					}
					else {
						m_pCoordBuffer = pBuffer;
						m_pCoordBufferSRV = pBufferSRV;
					}
					
					if(FAILED(hResult))
						pBuffer->Release();
				}
			}
			
			if(SUCCEEDED(hResult)) {
				m_pTexture = pTexture;
				m_pTextureSRV = pTextureSRV;
			}
			else
				pTextureSRV->Release();
		}
		
		if(FAILED(hResult))
			pTexture->Release();
	}
	
	return hResult;
}


// Height-range helper class, used to fit glyphs in the sheet

CFW1GlyphSheet::HeightRange::HeightRange(UINT totalWidth) : m_totalWidth(totalWidth) {
	m_heights = new UINT[m_totalWidth];
	ZeroMemory(m_heights, m_totalWidth * sizeof(UINT));
}

CFW1GlyphSheet::HeightRange::~HeightRange() {
	delete[] m_heights;
}

UINT CFW1GlyphSheet::HeightRange::findMin(UINT width, UINT *outMin) {
	if(width > m_totalWidth)
		width = m_totalWidth;
	
	UINT currentMax = findMax(0, width);
	UINT currentMin = currentMax;
	UINT minX = 0;
	
	for(UINT i=1; i < m_totalWidth-width; ++i) {
		if(m_heights[i+width-1] >= currentMax)
			currentMax = m_heights[i+width-1];
		else if(m_heights[i-1] == currentMax) {
			currentMax = findMax(i, width);
			if(currentMax < currentMin) {
				currentMin = currentMax;
				minX = i;
			}
		}
	}
	
	*outMin = currentMin;
	return minX;
}

void CFW1GlyphSheet::HeightRange::update(UINT startX, UINT width, UINT newHeight) {
	if(width > m_totalWidth)
		width = m_totalWidth;
	
	for(UINT i=0; i < width; ++i)
		m_heights[startX+i] = newHeight;
}

UINT CFW1GlyphSheet::HeightRange::findMax(UINT startX, UINT width) {
	UINT currentMax = m_heights[startX];
	for(UINT i=1; i < width; ++i)
		currentMax = std::max(currentMax, m_heights[startX+i]);
	
	return currentMax;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphSheet.h`:

```h
// CFW1GlyphSheet.h

#ifndef IncludeGuard__FW1_CFW1GlyphSheet
#define IncludeGuard__FW1_CFW1GlyphSheet

#include "CFW1Object.h"


namespace FW1FontWrapper {


// A texture containing multiple glyphimages
class CFW1GlyphSheet : public CFW1Object<IFW1GlyphSheet> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphSheet
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		virtual void STDMETHODCALLTYPE GetDesc(FW1_GLYPHSHEETDESC *pDesc);
		
		virtual HRESULT STDMETHODCALLTYPE GetSheetTexture(ID3D11ShaderResourceView **ppSheetTextureSRV);
		virtual HRESULT STDMETHODCALLTYPE GetCoordBuffer(ID3D11ShaderResourceView **ppCoordBufferSRV);
		
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords();
		virtual HRESULT STDMETHODCALLTYPE BindSheet(ID3D11DeviceContext *pContext, UINT Flags);
		
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			const FW1_GLYPHMETRICS *pGlyphMetrics,
			const void *pGlyphData,
			UINT RowPitch,
			UINT PixelStride
		);
		virtual void STDMETHODCALLTYPE CloseSheet();
		virtual void STDMETHODCALLTYPE Flush(ID3D11DeviceContext *pContext);
	
	// Public functions
	public:
		CFW1GlyphSheet();
		
		HRESULT initGlyphSheet(
			IFW1Factory *pFW1Factory,
			ID3D11Device *pDevice,
			UINT sheetWidth,
			UINT sheetHeight,
			bool coordBuffer,
			bool allowOversizedGlyph,
			UINT maxGlyphCount,
			UINT mipLevelCount
		);
	
	// Internal types
	private:
		struct RectUI {
			UINT					left;
			UINT					top;
			UINT					right;
			UINT					bottom;
		};
		
		class HeightRange {
			public:
				HeightRange(UINT totalWidth);
				~HeightRange();
				
				UINT findMin(UINT width, UINT *outMin);
				void update(UINT startX, UINT width, UINT newHeight);
			
			private:
				HeightRange();
				HeightRange(const HeightRange&);
				HeightRange& operator=(const HeightRange&);
				
				UINT findMax(UINT startX, UINT width);
				
				UINT				*m_heights;
				UINT				m_totalWidth;
		};
		
		class CriticalSectionLock {
			public:
				CriticalSectionLock(LPCRITICAL_SECTION pCriticalSection) : m_pCriticalSection(pCriticalSection) {
					EnterCriticalSection(m_pCriticalSection);
				}
				~CriticalSectionLock() {
					LeaveCriticalSection(m_pCriticalSection);
				}
			
			private:
				CriticalSectionLock();
				CriticalSectionLock(const CriticalSectionLock&);
				CriticalSectionLock& operator=(const CriticalSectionLock&);
				
				LPCRITICAL_SECTION	m_pCriticalSection;
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphSheet();
		
		HRESULT createDeviceResources();
	
	// Internal data
	private:
		std::wstring				m_lastError;
		
		UINT						m_sheetWidth;
		UINT						m_sheetHeight;
		bool						m_hardwareCoordBuffer;
		bool						m_allowOversizedGlyph;
		UINT						m_mipLevelCount;
		UINT						m_alignWidth;
		
		UINT8						*m_textureData;
		FW1_GLYPHCOORDS				*m_glyphCoords;
		UINT						m_maxGlyphCount;
		UINT						m_glyphCount;
		
		ID3D11Device				*m_pDevice;
		
		ID3D11Texture2D				*m_pTexture;
		ID3D11ShaderResourceView	*m_pTextureSRV;
		ID3D11Buffer				*m_pCoordBuffer;
		ID3D11ShaderResourceView	*m_pCoordBufferSRV;
		
		bool						m_closed;
		bool						m_static;
		
		HeightRange					*m_heightRange;
		
		UINT						m_updatedGlyphCount;
		RectUI						m_dirtyRect;
		CRITICAL_SECTION			m_sheetCriticalSection;
		CRITICAL_SECTION			m_flushCriticalSection;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphSheet

```

`dwmhook/FW1/CFW1GlyphSheetInterface.cpp`:

```cpp
// CFW1GlyphSheetInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphSheet.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphSheet))) {
		*ppvObject = static_cast<IFW1GlyphSheet*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this sheet
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Get sheet desc
void STDMETHODCALLTYPE CFW1GlyphSheet::GetDesc(FW1_GLYPHSHEETDESC *pDesc) {
	pDesc->GlyphCount = m_glyphCount;
	pDesc->Width = m_sheetWidth;
	pDesc->Height = m_sheetHeight;
	pDesc->MipLevels = m_mipLevelCount;
}


// Get the sheet texture
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetSheetTexture(ID3D11ShaderResourceView **ppSheetTextureSRV) {
	if(ppSheetTextureSRV == NULL)
		return E_INVALIDARG;
	
	m_pTextureSRV->AddRef();
	*ppSheetTextureSRV = m_pTextureSRV;
	
	return S_OK;
}


// Get the glyph coordinate buffer
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::GetCoordBuffer(ID3D11ShaderResourceView **ppCoordBufferSRV) {
	if(ppCoordBufferSRV == NULL)
		return E_INVALIDARG;
	
	if(m_pCoordBufferSRV != NULL)
		m_pCoordBufferSRV->AddRef();
	*ppCoordBufferSRV = m_pCoordBufferSRV;
	
	return S_OK;
}


// Get glyph coordinate array for all glyphs in the sheet
const FW1_GLYPHCOORDS* STDMETHODCALLTYPE CFW1GlyphSheet::GetGlyphCoords() {
	return m_glyphCoords;
}


// Set sheet shader resources
HRESULT STDMETHODCALLTYPE CFW1GlyphSheet::BindSheet(ID3D11DeviceContext *pContext, UINT Flags) {
	pContext->PSSetShaderResources(0, 1, &m_pTextureSRV);
	if((Flags & FW1_NOGEOMETRYSHADER) == 0 && m_hardwareCoordBuffer)
		pContext->GSSetShaderResources(0, 1, &m_pCoordBufferSRV);
	
	return S_OK;
}


// Insert a new glyph in the sheet
UINT STDMETHODCALLTYPE CFW1GlyphSheet::InsertGlyph(
	const FW1_GLYPHMETRICS *pGlyphMetrics,
	LPCVOID pGlyphData,
	UINT RowPitch,
	UINT PixelStride
) {
	if(m_closed)
		return 0xffffffff;
	if(m_glyphCount >= m_maxGlyphCount)
		return 0xffffffff;
	
	CriticalSectionLock lock(&m_sheetCriticalSection);
	
	if(m_closed)
		return 0xffffffff;
	if(m_glyphCount >= m_maxGlyphCount)
		return 0xffffffff;
	
	const UINT &width = pGlyphMetrics->Width;
	const UINT &height = pGlyphMetrics->Height;
	
	// Position the glyph if it fits
	UINT blockWidth = width / m_alignWidth + 1;
	if(width % m_alignWidth != 0)
		++blockWidth;
	UINT blockHeight = height / m_alignWidth + 1;
	if(height % m_alignWidth != 0)
		++blockHeight;
	
	UINT blockX;
	UINT blockY;
	UINT positionX;
	UINT positionY;
	
	if(m_glyphCount > 0 || !m_allowOversizedGlyph) {
		if(m_alignWidth + width + m_alignWidth > m_sheetWidth)
			return 0xffffffff;
		
		// Position the glyph at the lowest Y possible (fills reasonably well with different sized glyphs)
		blockX = m_heightRange->findMin(blockWidth, &blockY);
		
		positionX = m_alignWidth + blockX * m_alignWidth;
		positionY = m_alignWidth + blockY * m_alignWidth;
		
		if(positionY + height + m_alignWidth > m_sheetHeight)
			return 0xffffffff;
	}
	else {
		blockX = 0;
		blockY = 0;
		
		positionX = m_alignWidth;
		positionY = m_alignWidth;
	}
	
	m_heightRange->update(blockX, blockWidth, blockY + blockHeight);
	
	// Store glyph coordinates
	FLOAT coordOffset = static_cast<FLOAT>(m_alignWidth) * 0.5f;
	
	UINT alignedWidth = (blockWidth - 1) * m_alignWidth;
	UINT alignedHeight = (blockHeight - 1) * m_alignWidth;
	
	FW1_GLYPHCOORDS glyphCoords;
	glyphCoords.TexCoordLeft = (static_cast<FLOAT>(positionX) - coordOffset) / static_cast<FLOAT>(m_sheetWidth);
	glyphCoords.TexCoordTop = (static_cast<FLOAT>(positionY) - coordOffset) / static_cast<FLOAT>(m_sheetHeight);
	glyphCoords.TexCoordRight =
		(static_cast<FLOAT>(positionX + alignedWidth) + coordOffset) / static_cast<FLOAT>(m_sheetWidth);
	glyphCoords.TexCoordBottom =
		(static_cast<FLOAT>(positionY + alignedHeight) + coordOffset) / static_cast<FLOAT>(m_sheetHeight);
	glyphCoords.PositionLeft = pGlyphMetrics->OffsetX - coordOffset;
	glyphCoords.PositionTop = pGlyphMetrics->OffsetY - coordOffset;
	glyphCoords.PositionRight = pGlyphMetrics->OffsetX + static_cast<FLOAT>(alignedWidth) + coordOffset;
	glyphCoords.PositionBottom = pGlyphMetrics->OffsetY + static_cast<FLOAT>(alignedHeight) + coordOffset;
	
	UINT glyphIndex = m_glyphCount;
	
	m_glyphCoords[glyphIndex] = glyphCoords;
	
	// Glyph pixels
	for(UINT i=0; i < height && i < m_sheetHeight-positionY; ++i) {
		const UINT8 *src = static_cast<const UINT8*>(pGlyphData) + i*RowPitch;
		UINT8 *dst = m_textureData + (positionY+i)*m_sheetWidth + positionX;
		for(UINT j=0; j < width && j < m_sheetWidth-positionX; ++j)
			dst[j] = src[j*PixelStride];
	}
	
	// Update dirty rect to be flushed to device texture
	if(m_updatedGlyphCount == 0) {
		m_dirtyRect.left = positionX - m_alignWidth;
		m_dirtyRect.top = positionY - m_alignWidth;
		m_dirtyRect.right = std::min(positionX + width + m_alignWidth, m_sheetWidth);
		m_dirtyRect.bottom = std::min(positionY + height + m_alignWidth, m_sheetHeight);
	}
	else {
		m_dirtyRect.left = std::min(m_dirtyRect.left, positionX - m_alignWidth);
		m_dirtyRect.top = std::min(m_dirtyRect.top, positionY - m_alignWidth);
		m_dirtyRect.right = std::min(std::max(m_dirtyRect.right, positionX + width + m_alignWidth), m_sheetWidth);
		m_dirtyRect.bottom = std::min(std::max(m_dirtyRect.bottom, positionY + height + m_alignWidth), m_sheetHeight);
	}
	
	_WriteBarrier();
	MemoryBarrier();
	
	++m_glyphCount;
	++m_updatedGlyphCount;
	
	return glyphIndex;
}


// Disallow insertion of additional glyphs in this sheet
void STDMETHODCALLTYPE CFW1GlyphSheet::CloseSheet() {
	EnterCriticalSection(&m_sheetCriticalSection);
	m_closed = true;
	LeaveCriticalSection(&m_sheetCriticalSection);
}


// Flush any inserted glyphs
void STDMETHODCALLTYPE CFW1GlyphSheet::Flush(ID3D11DeviceContext *pContext) {
	EnterCriticalSection(&m_flushCriticalSection);
	if(!m_static) {
		EnterCriticalSection(&m_sheetCriticalSection);
		
		UINT glyphCount = m_glyphCount;
		RectUI dirtyRect = m_dirtyRect;
		
		UINT updatedGlyphCount = m_updatedGlyphCount;
		m_updatedGlyphCount = 0;
		
		if(m_closed)
			m_static = true;
		
		LeaveCriticalSection(&m_sheetCriticalSection);
		
		if(updatedGlyphCount > 0) {
			// Update coord buffer
			if(m_hardwareCoordBuffer) {
				UINT startIndex = glyphCount - updatedGlyphCount;
				UINT endIndex = glyphCount;
				
				D3D11_BOX dstBox;
				ZeroMemory(&dstBox, sizeof(dstBox));
				dstBox.left = startIndex * sizeof(FW1_GLYPHCOORDS);
				dstBox.right = endIndex * sizeof(FW1_GLYPHCOORDS);
				dstBox.top = 0;
				dstBox.bottom = 1;
				dstBox.front = 0;
				dstBox.back = 1;
				
				pContext->UpdateSubresource(
					m_pCoordBuffer,
					0,
					&dstBox,
					m_glyphCoords + startIndex,
					0,
					0
				);
			}
			
			// Update texture
			if(dirtyRect.right > dirtyRect.left && dirtyRect.bottom > dirtyRect.top) {
				UINT8 *srcMem = m_textureData;
				
				D3D11_BOX dstBox;
				ZeroMemory(&dstBox, sizeof(dstBox));
				dstBox.left = dirtyRect.left;
				dstBox.right = dirtyRect.right;
				dstBox.top = dirtyRect.top;
				dstBox.bottom = dirtyRect.bottom;
				dstBox.front = 0;
				dstBox.back = 1;
				
				// Update each mip-level
				for(UINT i=0; i < m_mipLevelCount; ++i) {
					pContext->UpdateSubresource(
						m_pTexture,
						D3D11CalcSubresource(i, 0, m_mipLevelCount),
						&dstBox,
						srcMem + dstBox.top * (m_sheetWidth >> i) + dstBox.left,
						m_sheetWidth >> i,
						0
					);
					
					if(i+1 < m_mipLevelCount) {
						UINT8 *nextMip = srcMem + (m_sheetWidth >> i) * (m_sheetHeight >> i);
						
						dstBox.left >>= 1;
						dstBox.right >>= 1;
						dstBox.top >>= 1;
						dstBox.bottom >>= 1;
						
						// Calculate the next mip-level for the current dirty-rect
						for(UINT j = dstBox.top; j < dstBox.bottom; ++j) {
							const UINT8 *src0 = srcMem + j * 2 * (m_sheetWidth >> i);
							const UINT8 *src1 = src0 + (m_sheetWidth >> i);
							UINT8 *dst = nextMip + j * (m_sheetWidth >> (i+1));
							
							for(UINT k = dstBox.left; k < dstBox.right; ++k) {
								UINT src = src0[k*2] + src0[k*2+1] + src1[k*2] + src1[k*2+1];
								dst[k] = static_cast<UINT8>(src >> 2);
							}
						}
						
						srcMem = nextMip;
					}
				}
			}
		}
		
		// This sheet is now static, save some memory
		if(m_static) {
			delete[] m_textureData;
			m_textureData = 0;
		}
	}
	
	LeaveCriticalSection(&m_flushCriticalSection);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphVertexDrawer.cpp`:

```cpp
// CFW1GlyphVertexDrawer.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphVertexDrawer.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1GlyphVertexDrawer::CFW1GlyphVertexDrawer() :
	m_pDevice(NULL),
	
	m_pVertexBuffer(NULL),
	m_pIndexBuffer(NULL),
	m_vertexBufferSize(0),
	m_maxIndexCount(0)
{
}


// Destruct
CFW1GlyphVertexDrawer::~CFW1GlyphVertexDrawer() {
	SAFE_RELEASE(m_pDevice);
	
	SAFE_RELEASE(m_pVertexBuffer);
	SAFE_RELEASE(m_pIndexBuffer);
}


// Init
HRESULT CFW1GlyphVertexDrawer::initVertexDrawer(
	IFW1Factory *pFW1Factory,
	ID3D11Device *pDevice,
	UINT vertexBufferSize
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pDevice == NULL)
		return E_INVALIDARG;
	
	pDevice->AddRef();
	m_pDevice = pDevice;
	D3D_FEATURE_LEVEL featureLevel = m_pDevice->GetFeatureLevel();
	
	m_vertexBufferSize = 4096 * 16;
	if(vertexBufferSize >= 1024) {
		if(featureLevel < D3D_FEATURE_LEVEL_9_2)
			vertexBufferSize = std::min(vertexBufferSize, 512U*1024U);
		m_vertexBufferSize = vertexBufferSize;
	}
	
	m_maxIndexCount = (m_vertexBufferSize * 3) / (2 * sizeof(QuadVertex));
	if(m_maxIndexCount < 64)
		m_maxIndexCount = 64;
	
	// Create device buffers
	hResult = createBuffers();
	
	if(SUCCEEDED(hResult))
		hResult = S_OK;
	
	return hResult;
}


// Create vertex/index buffers
HRESULT CFW1GlyphVertexDrawer::createBuffers() {
	// Create vertex buffer
	D3D11_BUFFER_DESC vertexBufferDesc;
	ID3D11Buffer *pVertexBuffer;
	
	ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
	vertexBufferDesc.ByteWidth = m_vertexBufferSize;
	vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	
	HRESULT hResult = m_pDevice->CreateBuffer(&vertexBufferDesc, NULL, &pVertexBuffer);
	if(FAILED(hResult)) {
		m_lastError = L"Failed to create vertex buffer";
	}
	else {
		// Create index buffer
		D3D11_BUFFER_DESC indexBufferDesc;
		D3D11_SUBRESOURCE_DATA initData;
		ID3D11Buffer *pIndexBuffer;
		
		ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));
		indexBufferDesc.ByteWidth = sizeof(UINT16) * m_maxIndexCount;
		indexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
		indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		
		UINT16 *indices = new UINT16[m_maxIndexCount];
		for(UINT i=0; i < m_maxIndexCount/6; ++i) {
			indices[i*6] = static_cast<UINT16>(i*4);
			indices[i*6+1] = static_cast<UINT16>(i*4+1);
			indices[i*6+2] = static_cast<UINT16>(i*4+2);
			indices[i*6+3] = static_cast<UINT16>(i*4+1);
			indices[i*6+4] = static_cast<UINT16>(i*4+3);
			indices[i*6+5] = static_cast<UINT16>(i*4+2);
		}
		
		ZeroMemory(&initData, sizeof(initData));
		initData.pSysMem = indices;
		
		hResult = m_pDevice->CreateBuffer(&indexBufferDesc, &initData, &pIndexBuffer);
		if(FAILED(hResult)) {
			m_lastError = L"Failed to create index buffer";
		}
		else {
			// Success
			m_pVertexBuffer = pVertexBuffer;
			m_pIndexBuffer = pIndexBuffer;
			
			hResult = S_OK;
		}
		
		delete[] indices;
		
		if(FAILED(hResult))
			pVertexBuffer->Release();
	}
	
	return hResult;
}


// Draw vertices
UINT CFW1GlyphVertexDrawer::drawVertices(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *vertexData,
	UINT preboundSheet
) {
	if(vertexData->SheetCount == 0 || vertexData->TotalVertexCount == 0)
		return preboundSheet;
	
	UINT maxVertexCount = m_vertexBufferSize / sizeof(FW1_GLYPHVERTEX);
	
	UINT currentSheet = 0;
	UINT activeSheet = preboundSheet;
	UINT currentVertex = 0;
	UINT nextSheetStart = vertexData->pVertexCounts[0];
	
	while(currentVertex < vertexData->TotalVertexCount) {
		// Fill the vertex buffer
		UINT vertexCount = std::min(vertexData->TotalVertexCount - currentVertex, maxVertexCount);
		
		D3D11_MAPPED_SUBRESOURCE msr;
		HRESULT hResult = pContext->Map(m_pVertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
		if(SUCCEEDED(hResult)) {
			CopyMemory(msr.pData, vertexData->pVertices + currentVertex, vertexCount * sizeof(FW1_GLYPHVERTEX));
			
			pContext->Unmap(m_pVertexBuffer, 0);
			
			// Draw all glyphs in the buffer
			UINT drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					// Bind sheet shader resources
					pGlyphAtlas->BindSheet(pContext, currentSheet, 0);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, nextSheetStart - currentVertex);
				pContext->Draw(drawCount, drawnVertices);
				
				drawnVertices += drawCount;
				currentVertex += drawCount;
			}
		}
		else
			break;
	}
	
	return activeSheet;
}


// Draw vertices as quads
UINT CFW1GlyphVertexDrawer::drawGlyphsAsQuads(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *vertexData,
	UINT preboundSheet
) {
	if(vertexData->SheetCount == 0 || vertexData->TotalVertexCount == 0)
		return preboundSheet;
	
	UINT maxVertexCount = m_vertexBufferSize / sizeof(QuadVertex);
	if(maxVertexCount > 4 * (m_maxIndexCount / 6))
		maxVertexCount = 4 * (m_maxIndexCount / 6);
	if(maxVertexCount % 4 != 0)
		maxVertexCount -= (maxVertexCount % 4);
	
	UINT currentSheet = 0;
	UINT activeSheet = preboundSheet;
	const FW1_GLYPHCOORDS *sheetGlyphCoords = 0;
	if(activeSheet < vertexData->SheetCount)
		sheetGlyphCoords = pGlyphAtlas->GetGlyphCoords(activeSheet);
	UINT currentVertex = 0;
	UINT nextSheetStart = vertexData->pVertexCounts[0];
	
	while(currentVertex < vertexData->TotalVertexCount) {
		// Fill the vertex buffer
		UINT vertexCount = std::min((vertexData->TotalVertexCount - currentVertex) * 4, maxVertexCount);
		
		D3D11_MAPPED_SUBRESOURCE msr;
		HRESULT hResult = pContext->Map(m_pVertexBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &msr);
		if(SUCCEEDED(hResult)) {
			QuadVertex *bufferVertices = static_cast<QuadVertex*>(msr.pData);
			
			// Convert to quads when filling the buffer
			UINT savedCurrentSheet = currentSheet;
			UINT savedActiveSheet = activeSheet;
			UINT savedNextSheetStart = nextSheetStart;
			UINT savedCurrentVertex = currentVertex;
			
			UINT drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					sheetGlyphCoords = pGlyphAtlas->GetGlyphCoords(currentSheet);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, (nextSheetStart - currentVertex) * 4);
				
				for(UINT i=0; i < drawCount/4; ++i) {
					FW1_GLYPHVERTEX glyphVertex = vertexData->pVertices[currentVertex + i];
					glyphVertex.PositionX = glyphVertex.PositionX;
					glyphVertex.PositionY = glyphVertex.PositionY;
					
					const FW1_GLYPHCOORDS &glyphCoords = sheetGlyphCoords[glyphVertex.GlyphIndex];
					
					QuadVertex quadVertex;
					
					quadVertex.color = glyphVertex.GlyphColor;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionLeft;
					quadVertex.positionY = glyphVertex.PositionY + glyphCoords.PositionTop;
					quadVertex.texCoordX = glyphCoords.TexCoordLeft;
					quadVertex.texCoordY = glyphCoords.TexCoordTop;
					bufferVertices[drawnVertices + i*4 + 0] = quadVertex;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionRight;
					quadVertex.texCoordX = glyphCoords.TexCoordRight;
					bufferVertices[drawnVertices + i*4 + 1] = quadVertex;
					
					quadVertex.positionY = glyphVertex.PositionY + glyphCoords.PositionBottom;
					quadVertex.texCoordY = glyphCoords.TexCoordBottom;
					bufferVertices[drawnVertices + i*4 + 3] = quadVertex;
					
					quadVertex.positionX = glyphVertex.PositionX + glyphCoords.PositionLeft;
					quadVertex.texCoordX = glyphCoords.TexCoordLeft;
					bufferVertices[drawnVertices + i*4 + 2] = quadVertex;
				}
				
				drawnVertices += drawCount;
				currentVertex += drawCount / 4;
			}
			
			pContext->Unmap(m_pVertexBuffer, 0);
			
			// Draw all glyphs in the buffer
			currentSheet = savedCurrentSheet;
			activeSheet = savedActiveSheet;
			nextSheetStart = savedNextSheetStart;
			currentVertex = savedCurrentVertex;
			
			drawnVertices = 0;
			while(drawnVertices < vertexCount) {
				while(currentVertex >= nextSheetStart) {
					++currentSheet;
					nextSheetStart += vertexData->pVertexCounts[currentSheet];
				}
				
				if(currentSheet != activeSheet) {
					// Bind sheet shader resources
					pGlyphAtlas->BindSheet(pContext, currentSheet, FW1_NOGEOMETRYSHADER);
					activeSheet = currentSheet;
				}
				
				UINT drawCount = std::min(vertexCount - drawnVertices, (nextSheetStart - currentVertex) * 4);
				pContext->DrawIndexed((drawCount/2)*3, 0, drawnVertices);
				
				drawnVertices += drawCount;
				currentVertex += drawCount / 4;
			}
		}
		else
			break;
	}
	
	return activeSheet;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1GlyphVertexDrawer.h`:

```h
// CFW1GlyphVertexDrawer.h

#ifndef IncludeGuard__FW1_CFW1GlyphVertexDrawer
#define IncludeGuard__FW1_CFW1GlyphVertexDrawer

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Draws glyph-vertices from system memory using a dynamic vertex buffer
class CFW1GlyphVertexDrawer : public CFW1Object<IFW1GlyphVertexDrawer> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1GlyphVertexDrawer
		virtual HRESULT STDMETHODCALLTYPE GetDevice(ID3D11Device **ppDevice);
		
		virtual UINT STDMETHODCALLTYPE DrawVertices(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *pVertexData,
			UINT Flags,
			UINT PreboundSheet
		);
	
	// Public functions
	public:
		CFW1GlyphVertexDrawer();
		
		HRESULT initVertexDrawer(IFW1Factory *pFW1Factory, ID3D11Device *pDevice, UINT vertexBufferSize);
	
	// Internal types
	private:
		struct QuadVertex {
			FLOAT						positionX;
			FLOAT						positionY;
			FLOAT						texCoordX;
			FLOAT						texCoordY;
			UINT32						color;
		};
	
	// Internal functions
	private:
		virtual ~CFW1GlyphVertexDrawer();
		
		HRESULT createBuffers();
		
		UINT drawVertices(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *vertexData,
			UINT preboundSheet
		);
		UINT drawGlyphsAsQuads(
			ID3D11DeviceContext *pContext,
			IFW1GlyphAtlas *pGlyphAtlas,
			const FW1_VERTEXDATA *vertexData,
			UINT preboundSheet
		);
	
	// Internal data
	private:
		std::wstring					m_lastError;
		
		ID3D11Device					*m_pDevice;
		
		ID3D11Buffer					*m_pVertexBuffer;
		ID3D11Buffer					*m_pIndexBuffer;
		UINT							m_vertexBufferSize;
		UINT							m_maxIndexCount;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1GlyphVertexDrawer

```

`dwmhook/FW1/CFW1GlyphVertexDrawerInterface.cpp`:

```cpp
// CFW1GlyphVertexDrawerInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1GlyphVertexDrawer.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1GlyphVertexDrawer))) {
		*ppvObject = static_cast<IFW1GlyphVertexDrawer*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Get the D3D11 device used by this vetex drawer
HRESULT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::GetDevice(ID3D11Device **ppDevice) {
	if(ppDevice == NULL)
		return E_INVALIDARG;
	
	m_pDevice->AddRef();
	*ppDevice = m_pDevice;
	
	return S_OK;
}


// Draw vertices
UINT STDMETHODCALLTYPE CFW1GlyphVertexDrawer::DrawVertices(
	ID3D11DeviceContext *pContext,
	IFW1GlyphAtlas *pGlyphAtlas,
	const FW1_VERTEXDATA *pVertexData,
	UINT Flags,
	UINT PreboundSheet
) {
	UINT stride;
	UINT offset = 0;
	
	if((Flags & FW1_NOGEOMETRYSHADER) == 0)
		stride = sizeof(FW1_GLYPHVERTEX);
	else {
		stride = sizeof(QuadVertex);
		if((Flags & FW1_BUFFERSPREPARED) == 0)
			pContext->IASetIndexBuffer(m_pIndexBuffer, DXGI_FORMAT_R16_UINT, 0);
	}
	if((Flags & FW1_BUFFERSPREPARED) == 0)
		pContext->IASetVertexBuffers(0, 1, &m_pVertexBuffer, &stride, &offset);
	
	if((Flags & FW1_NOGEOMETRYSHADER) == 0)
		return drawVertices(pContext, pGlyphAtlas, pVertexData, PreboundSheet);
	else
		return drawGlyphsAsQuads(pContext, pGlyphAtlas, pVertexData, PreboundSheet);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1Object.h`:

```h
// CFW1Object.h

#ifndef IncludeGuard__FW1_CFW1Object
#define IncludeGuard__FW1_CFW1Object


namespace FW1FontWrapper {


// Helper baseclass to avoid writing IUnknown and IFW1Object implementations once per class
template<class IBase>
class CFW1Object : public IBase {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) = 0 {
			if(ppvObject == NULL)
				return E_INVALIDARG;
			
			if(IsEqualIID(riid, __uuidof(IUnknown))) {
				*ppvObject = static_cast<IUnknown*>(this);
				AddRef();
				return S_OK;
			}
			else if(IsEqualIID(riid, __uuidof(IFW1Object))) {
				*ppvObject = static_cast<IFW1Object*>(this);
				AddRef();
				return S_OK;
			}
			
			*ppvObject = NULL;
			return E_NOINTERFACE;
		}
		
		virtual ULONG STDMETHODCALLTYPE AddRef() {
			return static_cast<ULONG>(InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRefCount)));
		}
		
		virtual ULONG STDMETHODCALLTYPE Release() {
			ULONG newCount = static_cast<ULONG>(InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRefCount)));
			
			if(newCount == 0)
				delete this;
			
			return newCount;
		}
		
		// IFW1Object
		virtual HRESULT STDMETHODCALLTYPE GetFactory(IFW1Factory **ppFW1Factory) {
			if(ppFW1Factory == NULL)
				return E_INVALIDARG;
			
			m_pFW1Factory->AddRef();
			*ppFW1Factory = m_pFW1Factory;
			
			return S_OK;
		}
	
	// Internal functions
	protected:
		CFW1Object() :
			m_cRefCount(1),
			
			m_pFW1Factory(NULL)
		{
		}
		
		virtual ~CFW1Object() {
			if(m_pFW1Factory != NULL)
				m_pFW1Factory->Release();
		}
		
		HRESULT initBaseObject(IFW1Factory *pFW1Factory) {
			if(pFW1Factory == NULL)
				return E_INVALIDARG;
			
			pFW1Factory->AddRef();
			m_pFW1Factory = pFW1Factory;
			
			return S_OK;
		}
	
	// Internal data
	protected:
		IFW1Factory					*m_pFW1Factory;
	
	private:
		ULONG						m_cRefCount;
	
	private:
		CFW1Object(const CFW1Object&);
		CFW1Object& operator=(const CFW1Object&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1Object

```

`dwmhook/FW1/CFW1StateSaver.cpp`:

```cpp
// CFW1StateSaver.cpp

#include "FW1Precompiled.h"

#include "CFW1StateSaver.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1StateSaver::CFW1StateSaver() :
	m_savedState(false),
	m_featureLevel(D3D_FEATURE_LEVEL_11_0),
	m_pContext(NULL),
	m_primitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED),
	m_pInputLayout(NULL),
	m_pBlendState(NULL),
	m_sampleMask(0xffffffff),
	m_pDepthStencilState(NULL),
	m_stencilRef(0),
	m_pRasterizerState(NULL),
	m_pPSSRV(NULL),
	m_pSamplerState(NULL),
	m_pVS(NULL),
	m_numVSClassInstances(0),
	m_pVSConstantBuffer(NULL),
	m_pGS(NULL),
	m_numGSClassInstances(0),
	m_pGSConstantBuffer(NULL),
	m_pGSSRV(NULL),
	m_pPS(NULL),
	m_numPSClassInstances(0),
	m_pHS(NULL),
	m_numHSClassInstances(0),
	m_pDS(NULL),
	m_numDSClassInstances(0),
	m_pVB(NULL),
	m_vertexStride(0),
	m_vertexOffset(0),
	m_pIndexBuffer(NULL),
	m_indexFormat(DXGI_FORMAT_UNKNOWN),
	m_indexOffset(0)
{
	for(int i=0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	for(int i=0; i < 256; ++i) {
		m_pVSClassInstances[i] = NULL;
		m_pGSClassInstances[i] = NULL;
		m_pPSClassInstances[i] = NULL;
		m_pHSClassInstances[i] = NULL;
		m_pDSClassInstances[i] = NULL;
	}
}


// Destruct
CFW1StateSaver::~CFW1StateSaver() {
	releaseSavedState();
}


// Save all states that are changed by the font-wrapper when drawing a string
HRESULT CFW1StateSaver::saveCurrentState(ID3D11DeviceContext *pContext) {
	if(m_savedState)
		releaseSavedState();
	if(pContext == NULL)
		return E_INVALIDARG;
	
	ID3D11Device *pDevice;
	pContext->GetDevice(&pDevice);
	if(pDevice != NULL) {
		m_featureLevel = pDevice->GetFeatureLevel();
		pDevice->Release();
	}
	
	pContext->AddRef();
	m_pContext = pContext;
	
	m_pContext->IAGetPrimitiveTopology(&m_primitiveTopology);
	m_pContext->IAGetInputLayout(&m_pInputLayout);
	
	m_pContext->OMGetBlendState(&m_pBlendState, m_blendFactor, &m_sampleMask);
	m_pContext->OMGetDepthStencilState(&m_pDepthStencilState, &m_stencilRef);
	
	m_pContext->RSGetState(&m_pRasterizerState);
	
	m_numVSClassInstances = 256;
	m_pContext->VSGetShader(&m_pVS, m_pVSClassInstances, &m_numVSClassInstances);
	m_pContext->VSGetConstantBuffers(0, 1, &m_pVSConstantBuffer);
	
	m_numPSClassInstances = 256;
	m_pContext->PSGetShader(&m_pPS, m_pPSClassInstances, &m_numPSClassInstances);
	m_pContext->PSGetShaderResources(0, 1, &m_pPSSRV);
	pContext->PSGetSamplers(0, 1, &m_pSamplerState);
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0) {
		m_numGSClassInstances = 256;
		m_pContext->GSGetShader(&m_pGS, m_pGSClassInstances, &m_numGSClassInstances);
		m_pContext->GSGetConstantBuffers(0, 1, &m_pGSConstantBuffer);
		
		m_pContext->GSGetShaderResources(0, 1, &m_pGSSRV);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
			m_numHSClassInstances = 256;
			m_pContext->HSGetShader(&m_pHS, m_pHSClassInstances, &m_numHSClassInstances);
			
			m_numDSClassInstances = 256;
			m_pContext->DSGetShader(&m_pDS, m_pDSClassInstances, &m_numDSClassInstances);
		}
	}
	
	m_pContext->IAGetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);
	
	m_pContext->IAGetIndexBuffer(&m_pIndexBuffer, &m_indexFormat, &m_indexOffset);
	
	m_savedState = true;
	
	return S_OK;
}


// Restore state
HRESULT CFW1StateSaver::restoreSavedState() {
	if(!m_savedState)
		return E_FAIL;
	
	m_pContext->IASetPrimitiveTopology(m_primitiveTopology);
	m_pContext->IASetInputLayout(m_pInputLayout);
	
	m_pContext->OMSetBlendState(m_pBlendState, m_blendFactor, m_sampleMask);
	m_pContext->OMSetDepthStencilState(m_pDepthStencilState, m_stencilRef);
	
	m_pContext->RSSetState(m_pRasterizerState);
	
	m_pContext->VSSetShader(m_pVS, m_pVSClassInstances, m_numVSClassInstances);
	m_pContext->VSSetConstantBuffers(0, 1, &m_pVSConstantBuffer);
	
	m_pContext->PSSetShader(m_pPS, m_pPSClassInstances, m_numPSClassInstances);
	m_pContext->PSSetShaderResources(0, 1, &m_pPSSRV);
	m_pContext->PSSetSamplers(0, 1, &m_pSamplerState);
	
	if(m_featureLevel >= D3D_FEATURE_LEVEL_10_0) {
		m_pContext->GSSetShader(m_pGS, m_pGSClassInstances, m_numGSClassInstances);
		m_pContext->GSSetConstantBuffers(0, 1, &m_pGSConstantBuffer);
		
		m_pContext->GSSetShaderResources(0, 1, &m_pGSSRV);
		
		if(m_featureLevel >= D3D_FEATURE_LEVEL_11_0) {
			m_pContext->HSSetShader(m_pHS, m_pHSClassInstances, m_numHSClassInstances);
			
			m_pContext->DSSetShader(m_pDS, m_pDSClassInstances, m_numDSClassInstances);
		}
	}
	
	m_pContext->IASetVertexBuffers(0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset);
	
	m_pContext->IASetIndexBuffer(m_pIndexBuffer, m_indexFormat, m_indexOffset);
	
	return S_OK;
}


// Release state
void CFW1StateSaver::releaseSavedState() {
	m_primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
	SAFE_RELEASE(m_pInputLayout);
	SAFE_RELEASE(m_pBlendState);
	for(int i=0; i < 4; ++i)
		m_blendFactor[i] = 0.0f;
	m_sampleMask = 0xffffffff;
	SAFE_RELEASE(m_pDepthStencilState);
	m_stencilRef = 0;
	SAFE_RELEASE(m_pRasterizerState);
	SAFE_RELEASE(m_pPSSRV);
	SAFE_RELEASE(m_pSamplerState);
	SAFE_RELEASE(m_pVS);
	for(UINT i=0; i < m_numVSClassInstances; ++i)
		SAFE_RELEASE(m_pVSClassInstances[i]);
	m_numVSClassInstances = 0;
	SAFE_RELEASE(m_pVSConstantBuffer);
	SAFE_RELEASE(m_pGS);
	for(UINT i=0; i < m_numGSClassInstances; ++i)
		SAFE_RELEASE(m_pGSClassInstances[i]);
	m_numGSClassInstances = 0;
	SAFE_RELEASE(m_pGSConstantBuffer);
	SAFE_RELEASE(m_pGSSRV);
	SAFE_RELEASE(m_pPS);
	for(UINT i=0; i < m_numPSClassInstances; ++i)
		SAFE_RELEASE(m_pPSClassInstances[i]);
	m_numPSClassInstances = 0;
	SAFE_RELEASE(m_pHS);
	for(UINT i=0; i < m_numHSClassInstances; ++i)
		SAFE_RELEASE(m_pHSClassInstances[i]);
	m_numHSClassInstances = 0;
	SAFE_RELEASE(m_pDS);
	for(UINT i=0; i < m_numDSClassInstances; ++i)
		SAFE_RELEASE(m_pDSClassInstances[i]);
	m_numDSClassInstances = 0;
	SAFE_RELEASE(m_pVB);
	m_vertexStride = 0;
	m_vertexOffset = 0;
	SAFE_RELEASE(m_pIndexBuffer);
	m_indexFormat = DXGI_FORMAT_UNKNOWN;
	m_indexOffset = 0;
	
	SAFE_RELEASE(m_pContext);
	m_featureLevel = D3D_FEATURE_LEVEL_11_0;
	
	m_savedState = false;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1StateSaver.h`:

```h
// CFW1StateSaver.h

#ifndef IncludeGuard__FW1_CFW1StateSaver
#define IncludeGuard__FW1_CFW1StateSaver


namespace FW1FontWrapper {


// Saves all the states that can be changed when drawing a string
class CFW1StateSaver {
	// Public functions
	public:
		CFW1StateSaver();
		~CFW1StateSaver();
		
		HRESULT saveCurrentState(ID3D11DeviceContext *pContext);
		HRESULT restoreSavedState();
		void releaseSavedState();
	
	// Internal data
	private:
		bool						m_savedState;
		D3D_FEATURE_LEVEL			m_featureLevel;
		ID3D11DeviceContext			*m_pContext;
		D3D11_PRIMITIVE_TOPOLOGY	m_primitiveTopology;
		ID3D11InputLayout			*m_pInputLayout;
		ID3D11BlendState			*m_pBlendState;
		FLOAT						m_blendFactor[4];
		UINT						m_sampleMask;
		ID3D11DepthStencilState		*m_pDepthStencilState;
		UINT						m_stencilRef;
		ID3D11RasterizerState		*m_pRasterizerState;
		ID3D11ShaderResourceView	*m_pPSSRV;
		ID3D11SamplerState			*m_pSamplerState;
		ID3D11VertexShader			*m_pVS;
		ID3D11ClassInstance			*m_pVSClassInstances[256];
		UINT						m_numVSClassInstances;
		ID3D11Buffer				*m_pVSConstantBuffer;
		ID3D11GeometryShader		*m_pGS;
		ID3D11ClassInstance			*m_pGSClassInstances[256];
		UINT						m_numGSClassInstances;
		ID3D11Buffer				*m_pGSConstantBuffer;
		ID3D11ShaderResourceView	*m_pGSSRV;
		ID3D11PixelShader			*m_pPS;
		ID3D11ClassInstance			*m_pPSClassInstances[256];
		UINT						m_numPSClassInstances;
		ID3D11HullShader			*m_pHS;
		ID3D11ClassInstance			*m_pHSClassInstances[256];
		UINT						m_numHSClassInstances;
		ID3D11DomainShader			*m_pDS;
		ID3D11ClassInstance			*m_pDSClassInstances[256];
		UINT						m_numDSClassInstances;
		ID3D11Buffer				*m_pVB;
		UINT						m_vertexStride;
		UINT						m_vertexOffset;
		ID3D11Buffer				*m_pIndexBuffer;
		DXGI_FORMAT					m_indexFormat;
		UINT						m_indexOffset;
	
	private:
		CFW1StateSaver(const CFW1StateSaver&);
		CFW1StateSaver& operator=(const CFW1StateSaver&);
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1StateSaver

```

`dwmhook/FW1/CFW1TextGeometry.cpp`:

```cpp
// CFW1TextGeometry.cpp

#include "FW1Precompiled.h"

#include "CFW1TextGeometry.h"


namespace FW1FontWrapper {


// Construct
CFW1TextGeometry::CFW1TextGeometry() :
	m_maxSheetIndex(0),
	m_sorted(false)
{
}


// Destruct
CFW1TextGeometry::~CFW1TextGeometry() {
}


// Init glyph provider
HRESULT CFW1TextGeometry::initTextGeometry(IFW1Factory *pFW1Factory) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	return hResult;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1TextGeometry.h`:

```h
// CFW1TextGeometry.h

#ifndef IncludeGuard__FW1_CFW1TextGeometry
#define IncludeGuard__FW1_CFW1TextGeometry

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Vector of vertices with sorting per glyph sheet
class CFW1TextGeometry : public CFW1Object<IFW1TextGeometry> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1TextGeometry
		virtual void STDMETHODCALLTYPE Clear();
		virtual void STDMETHODCALLTYPE AddGlyphVertex(const FW1_GLYPHVERTEX *pVertex);
		
		virtual FW1_VERTEXDATA STDMETHODCALLTYPE GetGlyphVerticesTemp();
	
	// Public functions
	public:
		CFW1TextGeometry();
		
		HRESULT initTextGeometry(IFW1Factory *pFW1Factory);
	
	// Internal functions
	private:
		virtual ~CFW1TextGeometry();
	
	// Internal data
	private:
		std::vector<FW1_GLYPHVERTEX>	m_vertices;
		std::vector<FW1_GLYPHVERTEX>	m_sortedVertices;
		
		UINT							m_maxSheetIndex;
		std::vector<UINT>				m_vertexCounts;
		std::vector<UINT>				m_vertexStartIndices;
		bool							m_sorted;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1TextGeometry

```

`dwmhook/FW1/CFW1TextGeometryInterface.cpp`:

```cpp
// CFW1TextGeometryInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1TextGeometry.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1TextGeometry::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IFW1TextGeometry))) {
		*ppvObject = static_cast<IFW1TextGeometry*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// Clear geometry
void STDMETHODCALLTYPE CFW1TextGeometry::Clear() {
	m_vertices.clear();
	m_maxSheetIndex = 0;
	
	m_sorted = false;
}


// Add a vertex
void STDMETHODCALLTYPE CFW1TextGeometry::AddGlyphVertex(const FW1_GLYPHVERTEX *pVertex) {
	m_vertices.push_back(*pVertex);
	
	UINT sheetIndex = pVertex->GlyphIndex >> 16;
	m_maxSheetIndex = std::max(m_maxSheetIndex, sheetIndex);
	
	m_sorted = false;
}


// Get current glyph vertices
FW1_VERTEXDATA STDMETHODCALLTYPE CFW1TextGeometry::GetGlyphVerticesTemp() {
	FW1_VERTEXDATA vertexData;
	
	if(!m_vertices.empty()) {
		UINT32 sheetCount = m_maxSheetIndex + 1;
		
		// Sort and prepare vertices
		if(!m_sorted) {
			m_sortedVertices.resize(m_vertices.size());
			m_vertexCounts.resize(sheetCount);
			m_vertexStartIndices.resize(sheetCount);
			
			std::fill(m_vertexCounts.begin(), m_vertexCounts.end(), 0);
			
			UINT * const vertexCounts = &m_vertexCounts[0];
			const FW1_GLYPHVERTEX * const vertices = &m_vertices[0];
			const UINT32 vertexCount = static_cast<UINT32>(m_vertices.size());
			
			for(UINT32 i=0; i < vertexCount; ++i) {
				UINT32 sheetIndex = vertices[i].GlyphIndex >> 16;
				
				++vertexCounts[sheetIndex];
			}
			
			UINT * const vertexStartIndices = &m_vertexStartIndices[0];
			
			UINT currentStartIndex = 0;
			for(UINT32 i=0; i < sheetCount; ++i) {
				vertexStartIndices[i] = currentStartIndex;
				
				currentStartIndex += vertexCounts[i];
			}
			
			FW1_GLYPHVERTEX * const sortedVertices = &m_sortedVertices[0];
			
			for(UINT32 i=0; i < vertexCount; ++i) {
				const FW1_GLYPHVERTEX &vertex = vertices[i];
				UINT32 sheetIndex = vertex.GlyphIndex >> 16;
				
				UINT &vertexIndex = vertexStartIndices[sheetIndex];
				
				sortedVertices[vertexIndex] = vertex;
				sortedVertices[vertexIndex].GlyphIndex &= 0xffff;
				
				++vertexIndex;
			}
			
			m_sorted = true;
		}
		
		vertexData.SheetCount = sheetCount;
		vertexData.pVertexCounts = &m_vertexCounts[0];
		vertexData.TotalVertexCount = static_cast<UINT>(m_vertices.size());
		vertexData.pVertices = &m_sortedVertices[0];
	}
	else {
		vertexData.SheetCount = 0;
		vertexData.pVertexCounts = 0;
		vertexData.TotalVertexCount = 0;
		vertexData.pVertices = 0;
	}
	
	return vertexData;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1TextRenderer.cpp`:

```cpp
// CFW1TextRenderer.cpp

#include "FW1Precompiled.h"

#include "CFW1TextRenderer.h"

#define SAFE_RELEASE(pObject) { if(pObject) { (pObject)->Release(); (pObject) = NULL; } }


namespace FW1FontWrapper {


// Construct
CFW1TextRenderer::CFW1TextRenderer() :
	m_pGlyphProvider(NULL),
	
	m_currentFlags(0),
	m_currentColor(0xff000000),
	
	m_cachedGlyphMap(0),
	m_pCachedGlyphMapFontFace(NULL),
	m_cachedGlyphMapFontSize(0),
	
	m_pDWriteTextRendererProxy(0)
{
}


// Destruct
CFW1TextRenderer::~CFW1TextRenderer() {
	SAFE_RELEASE(m_pGlyphProvider);
	
	delete m_pDWriteTextRendererProxy;
}


// Init
HRESULT CFW1TextRenderer::initTextRenderer(
	IFW1Factory *pFW1Factory,
	IFW1GlyphProvider *pGlyphProvider
) {
	HRESULT hResult = initBaseObject(pFW1Factory);
	if(FAILED(hResult))
		return hResult;
	
	if(pGlyphProvider == NULL)
		return E_INVALIDARG;
	
	pGlyphProvider->AddRef();
	m_pGlyphProvider = pGlyphProvider;
	
	m_pDWriteTextRendererProxy = new CDWriteTextRendererProxy(this);
	
	return S_OK;
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/CFW1TextRenderer.h`:

```h
// CFW1TextRenderer.h

#ifndef IncludeGuard__FW1_CFW1TextRenderer
#define IncludeGuard__FW1_CFW1TextRenderer

#include "CFW1Object.h"


namespace FW1FontWrapper {


// Converts a DWrite text layout to vertices
class CFW1TextRenderer : public CFW1Object<IFW1TextRenderer> {
	public:
		// IUnknown
		virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
		
		// IFW1DWriteTextRenderer
		virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider);
		
		virtual HRESULT STDMETHODCALLTYPE DrawTextLayout(
			IDWriteTextLayout *pTextLayout,
			FLOAT OriginX,
			FLOAT OriginY,
			UINT32 Color,
			UINT Flags,
			IFW1TextGeometry *pTextGeometry
		);
	
	// Public functions
	public:
		CFW1TextRenderer();
		
		HRESULT initTextRenderer(
			IFW1Factory *pFW1Factory,
			IFW1GlyphProvider *pGlyphProvider
		);
	
	// Internal functions
	private:
		virtual ~CFW1TextRenderer();
		
		// IDWritePixelSnapping interface (called via proxy)
		HRESULT IsPixelSnappingDisabled(void *clientDrawingContext, BOOL *isDisabled);
		HRESULT GetCurrentTransform(void *clientDrawingContext, DWRITE_MATRIX *transform);
		HRESULT GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip);
		
		// IDWriteTextRenderer interface (called via proxy)
		HRESULT DrawGlyphRun(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			DWRITE_MEASURING_MODE measuringMode,
			const DWRITE_GLYPH_RUN *glyphRun,
			const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawUnderline(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			const DWRITE_UNDERLINE *underline,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawStrikethrough(
			void *clientDrawingContext,
			FLOAT baselineOriginX,
			FLOAT baselineOriginY,
			const DWRITE_STRIKETHROUGH *strikethrough,
			IUnknown *clientDrawingEffect
		);
		HRESULT DrawInlineObject(
			void *clientDrawingContext,
			FLOAT originX,
			FLOAT originY,
			IDWriteInlineObject *inlineObject,
			BOOL isSideways,
			BOOL isRightToLeft,
			IUnknown *clientDrawingEffect
		);
	
	// Internal data
	private:
		IFW1GlyphProvider			*m_pGlyphProvider;
		
		UINT						m_currentFlags;
		UINT32						m_currentColor;
		
		const void					*m_cachedGlyphMap;
		IDWriteFontFace				*m_pCachedGlyphMapFontFace;
		FLOAT						m_cachedGlyphMapFontSize;
	
	
	// Proxy for IDWriteTextRenderer interface
	private:
		class CDWriteTextRendererProxy : public IDWriteTextRenderer {
			public:
				virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) {
					return m_realObject->QueryInterface(riid, ppvObject);
				}
				virtual ULONG STDMETHODCALLTYPE AddRef() {
					return m_realObject->AddRef();
				}
				virtual ULONG STDMETHODCALLTYPE Release() {
					return m_realObject->Release();
				}
				
				virtual HRESULT STDMETHODCALLTYPE IsPixelSnappingDisabled(void *clientDrawingContext, BOOL *isDisabled) {
					return m_realObject->IsPixelSnappingDisabled(clientDrawingContext, isDisabled);
				}
				virtual HRESULT STDMETHODCALLTYPE GetCurrentTransform(void *clientDrawingContext, DWRITE_MATRIX *transform) {
					return m_realObject->GetCurrentTransform(clientDrawingContext, transform);
				}
				virtual HRESULT STDMETHODCALLTYPE GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip) {
					return m_realObject->GetPixelsPerDip(clientDrawingContext, pixelsPerDip);
				}
				
				virtual HRESULT STDMETHODCALLTYPE DrawGlyphRun(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN *glyphRun, const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawGlyphRun(clientDrawingContext, baselineOriginX, baselineOriginY, measuringMode, glyphRun, glyphRunDescription, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawUnderline(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, const DWRITE_UNDERLINE *underline, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawUnderline(clientDrawingContext, baselineOriginX, baselineOriginY, underline, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawStrikethrough(void *clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, const DWRITE_STRIKETHROUGH *strikethrough, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawStrikethrough(clientDrawingContext, baselineOriginX, baselineOriginY, strikethrough, clientDrawingEffect);
				}
				virtual HRESULT STDMETHODCALLTYPE DrawInlineObject(void *clientDrawingContext, FLOAT originX, FLOAT originY, IDWriteInlineObject *inlineObject, BOOL isSideways, BOOL isRightToLeft, IUnknown *clientDrawingEffect) {
					return m_realObject->DrawInlineObject(clientDrawingContext, originX, originY, inlineObject, isSideways, isRightToLeft, clientDrawingEffect);
				}
			
			public:
				CDWriteTextRendererProxy(CFW1TextRenderer *realObject) : m_realObject(realObject) {}
			
			private:
				CDWriteTextRendererProxy(const CDWriteTextRendererProxy&);
				CDWriteTextRendererProxy& operator=(const CDWriteTextRendererProxy&);
			
			private:
				CFW1TextRenderer	*m_realObject;
		} *m_pDWriteTextRendererProxy;
};


}// namespace FW1FontWrapper


#endif// IncludeGuard__FW1_CFW1TextRenderer

```

`dwmhook/FW1/CFW1TextRendererInterface.cpp`:

```cpp
// CFW1TextRendererInterface.cpp

#include "FW1Precompiled.h"

#include "CFW1TextRenderer.h"


namespace FW1FontWrapper {


// Query interface
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::QueryInterface(REFIID riid, void **ppvObject) {
	if(ppvObject == NULL)
		return E_INVALIDARG;
	
	if(IsEqualIID(riid, __uuidof(IDWritePixelSnapping))) {
		*ppvObject = static_cast<IDWritePixelSnapping*>(m_pDWriteTextRendererProxy);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IDWriteTextRenderer))) {
		*ppvObject = static_cast<IDWriteTextRenderer*>(m_pDWriteTextRendererProxy);
		AddRef();
		return S_OK;
	}
	else if(IsEqualIID(riid, __uuidof(IFW1TextRenderer))) {
		*ppvObject = static_cast<IFW1TextRenderer*>(this);
		AddRef();
		return S_OK;
	}
	
	return CFW1Object::QueryInterface(riid, ppvObject);
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::IsPixelSnappingDisabled(
	void *clientDrawingContext,
	BOOL *isDisabled
) {
	clientDrawingContext;
	
	*isDisabled = FALSE;
	
	return S_OK;
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::GetCurrentTransform(
	void *clientDrawingContext,
	DWRITE_MATRIX *transform
) {
	clientDrawingContext;
	
	transform->dx = 0.0f;
	transform->dy = 0.0f;
	transform->m11 = 1.0f;
	transform->m12 = 0.0f;
	transform->m21 = 0.0f;
	transform->m22 = 1.0f;
	
	return S_OK;
}


// IDWritePixelSnapping method
HRESULT CFW1TextRenderer::GetPixelsPerDip(void *clientDrawingContext, FLOAT *pixelsPerDip) {
	clientDrawingContext;
	
	*pixelsPerDip = 96.0f;
	
	return S_OK;
}


// IDWriteTextRenderer method
// Convert a run of glyphs to vertices
HRESULT CFW1TextRenderer::DrawGlyphRun(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	DWRITE_MEASURING_MODE measuringMode,
	const DWRITE_GLYPH_RUN *glyphRun,
	const DWRITE_GLYPH_RUN_DESCRIPTION *glyphRunDescription,
	IUnknown *clientDrawingEffect
) {
	glyphRunDescription;
	measuringMode;
	
	const UINT flags = m_currentFlags;
	
	// Get glyph map for the current font
	const void *glyphMap;
	if(glyphRun->fontFace == m_pCachedGlyphMapFontFace && glyphRun->fontEmSize == m_cachedGlyphMapFontSize)
		glyphMap = m_cachedGlyphMap;
	else {
		glyphMap = m_pGlyphProvider->GetGlyphMapFromFont(glyphRun->fontFace, glyphRun->fontEmSize, flags);
		
		// Cache the glyph map as it's likely to be used in subsequent glyph runs
		m_cachedGlyphMap = glyphMap;
		m_pCachedGlyphMapFontFace = glyphRun->fontFace;
		m_cachedGlyphMapFontSize = glyphRun->fontEmSize;
	}
	
	// Skip if not interested in the actual glyphs
	if((flags & FW1_ANALYZEONLY) != 0)
		return S_OK;
	
	if((flags & FW1_CACHEONLY) != 0) {
		// Only request the glyphs from the provider to have them drawn to the atlas
		for(UINT i=0; i < glyphRun->glyphCount; ++i) {
			UINT atlasId = m_pGlyphProvider->GetAtlasIdFromGlyphIndex(
				glyphMap,
				glyphRun->glyphIndices[i],
				glyphRun->fontFace,
				flags
			);
			atlasId;
		}
	}
	else {
		// Glyph vertex
		FW1_GLYPHVERTEX glyphVertex;
		glyphVertex.PositionY = floor(baselineOriginY + 0.5f);
		glyphVertex.GlyphColor = m_currentColor;
		
		float positionX = floor(baselineOriginX + 0.5f);
		
		// Optional drawing effect
		if(clientDrawingEffect != NULL) {
			IFW1ColorRGBA *pColor;
			HRESULT hResult = clientDrawingEffect->QueryInterface(&pColor);
			if(SUCCEEDED(hResult)) {
				glyphVertex.GlyphColor = pColor->GetColor32();
				pColor->Release();
			}
		}
		
		// Add a vertex for each glyph in the run
		IFW1TextGeometry *pTextGeometry = static_cast<IFW1TextGeometry*>(clientDrawingContext);
		if(pTextGeometry != NULL) {
			for(UINT i=0; i < glyphRun->glyphCount; ++i) {
				glyphVertex.GlyphIndex = m_pGlyphProvider->GetAtlasIdFromGlyphIndex(
					glyphMap,
					glyphRun->glyphIndices[i],
					glyphRun->fontFace,
					flags
				);
				
				if((glyphRun->bidiLevel & 0x1) != 0)
					positionX -= glyphRun->glyphAdvances[i];
				
				glyphVertex.PositionX = floor(positionX + 0.5f);
				pTextGeometry->AddGlyphVertex(&glyphVertex);
				
				if((glyphRun->bidiLevel & 0x1) == 0)
					positionX += glyphRun->glyphAdvances[i];
			}
		}
	}
	
	return S_OK;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawUnderline(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	const DWRITE_UNDERLINE *underline,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	baselineOriginX;
	baselineOriginY;
	underline;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawStrikethrough(
	void *clientDrawingContext,
	FLOAT baselineOriginX,
	FLOAT baselineOriginY,
	const DWRITE_STRIKETHROUGH *strikethrough,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	baselineOriginX;
	baselineOriginY;
	strikethrough;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// IDWriteTextRenderer method
HRESULT CFW1TextRenderer::DrawInlineObject(
	void *clientDrawingContext,
	FLOAT originX,
	FLOAT originY,
	IDWriteInlineObject *inlineObject,
	BOOL isSideways,
	BOOL isRightToLeft,
	IUnknown *clientDrawingEffect
) {
	clientDrawingContext;
	originX;
	originY;
	inlineObject;
	isSideways;
	isRightToLeft;
	clientDrawingEffect;
	
	return E_NOTIMPL;
}


// Get glyph provider
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::GetGlyphProvider(IFW1GlyphProvider **ppGlyphProvider) {
	if(ppGlyphProvider == NULL)
		return E_INVALIDARG;
	
	m_pGlyphProvider->AddRef();
	*ppGlyphProvider = m_pGlyphProvider;
	
	return S_OK;
}


// Draw a text layout
HRESULT STDMETHODCALLTYPE CFW1TextRenderer::DrawTextLayout(
	IDWriteTextLayout *pTextLayout,
	FLOAT OriginX,
	FLOAT OriginY,
	UINT32 Color,
	UINT Flags,
	IFW1TextGeometry *pTextGeometry
) {
	m_currentFlags = Flags;
	m_currentColor = Color;
	
	m_cachedGlyphMap = 0;
	m_pCachedGlyphMapFontFace = NULL;
	m_cachedGlyphMapFontSize = 0.0f;
	
	return pTextLayout->Draw(pTextGeometry, m_pDWriteTextRendererProxy, OriginX, OriginY);
}


}// namespace FW1FontWrapper

```

`dwmhook/FW1/FW1CompileSettings.h`:

```h
// FW1CompileSettings.h

#ifndef IncludeGuard__FW1_FW1CompileSettings_h
#define IncludeGuard__FW1_FW1CompileSettings_h


// Define if building a DLL for the font-wrapper
#define FW1_COMPILETODLL

// Define to use LoadLibrary instead of linking to DLLs
#define FW1_DELAYLOAD_DWRITE_DLL
#define FW1_DELAYLOAD_D3DCOMPILER_XX_DLL


#endif// IncludeGuard__FW1_FW1CompileSettings_h

```

`dwmhook/FW1/FW1FontWrapper.cpp`:

```cpp
// FW1FontWrapper.cpp

#include "FW1Precompiled.h"

#include "CFW1Factory.h"

#ifndef FW1_DELAYLOAD_DWRITE_DLL
	#pragma comment (lib, "DWrite.lib")
#endif

#ifndef FW1_DELAYLOAD_D3DCOMPILER_XX_DLL
	#pragma comment (lib, "DWrite.lib")
#endif

#ifdef FW1_COMPILETODLL
	#ifndef _M_X64
		#pragma comment (linker, "/EXPORT:FW1CreateFactory=_FW1CreateFactory@8,@1")
	#endif
#endif


// Create FW1 factory
extern "C" HRESULT STDMETHODCALLTYPE FW1CreateFactory(UINT32 Version, IFW1Factory **ppFactory) {
	if(Version != FW1_VERSION)
		return E_FAIL;
	
	if(ppFactory == NULL)
		return E_INVALIDARG;
	
	FW1FontWrapper::CFW1Factory *pFactory = new FW1FontWrapper::CFW1Factory;
	HRESULT hResult = pFactory->initFactory();
	if(FAILED(hResult)) {
		pFactory->Release();
	}
	else {
		*ppFactory = pFactory;
		
		hResult = S_OK;
	}
	
	return hResult;
}

```

`dwmhook/FW1/FW1FontWrapper.h`:

```h
// FW1FontWrapper.h

// v1.1, October 2011
// Written by Erik Rufelt

#ifndef IncludeGuard__FW1_FW1FontWrapper_h
#define IncludeGuard__FW1_FW1FontWrapper_h

#include <D3D11.h>
#include <DWrite.h>


/// <summary>The current FW1 version.</summary>
/// <remarks>This constant should be used when calling FW1CreateFactory to make sure the library version matches the headers.</remarks>
#define FW1_VERSION 0x110f

#define FW1_DLL_W L"FW1FontWrapper.dll"
#define FW1_DLL_A "FW1FontWrapper.dll"

#ifdef UNICODE
	#define FW1_DLL FW1_DLL_W
#else
	#define FW1_DLL FW1_DLL_A
#endif

/// <summary>Describes overrides for how an FW1 operation is performed.</summary>
/// <remarks>These flags can be used for any FW1 methods that take a flags parameter. Not all flags have any meaning for all methods however.
/// Consult the documentation page for a particular method for information on what flags are valid.</remarks>
enum FW1_TEXT_FLAG {
	/// <summary>Text is left-aligned. This is the default.</summary>
	FW1_LEFT = 0x0,
	
	/// <summary>Text is centered horizontally.</summary>
	FW1_CENTER = 0x1,
	
	/// <summary>Text is right-aligned.</summary>
	FW1_RIGHT = 0x2,
	
	/// <summary>Text is aligned at the top of the layout-box. This is the default.</summary>
	FW1_TOP = 0x0,
	
	/// <summary>Text is centered vertically.</summary>
	FW1_VCENTER = 0x4,
	
	/// <summary>Text is aligned at the bottom of the layout-box.</summary>
	FW1_BOTTOM = 0x8,
	
	/// <summary>No automatic wrapping when the text overflows the layout-box.</summary>
	FW1_NOWORDWRAP = 0x10,
	
	/// <summary>Text is drawn without anti-aliasing.</summary>
	FW1_ALIASED = 0x20,
	
	/// <summary>If a clip-rect is specified together with this flag, all text is clipped to inside the specified rectangle.</summary>
	FW1_CLIPRECT = 0x40,
	
	/// <summary>No geometry shader is used when drawing glyphs. Indexed quads are constructed on the CPU instead of in the geometry shader.</summary>
	FW1_NOGEOMETRYSHADER = 0x80,
	
	/// <summary>The transform matrix and the clip-rect is not updated in the internal constant-buffer. Can be used as an optimization when a previous call has already set the correct data.</summary>
	FW1_CONSTANTSPREPARED = 0x100,
	
	/// <summary>The internal vertex and index buffer (if used) are assumed to already be bound. Can be used as an optimization when a previous call has already set the buffers.</summary>
	FW1_BUFFERSPREPARED = 0x200,
	
	/// <summary>The correct shaders/constant-buffer etc. are assumed to already be bound. Can be used as an optimization when a previous call has already set the states, or to override the default states.</summary>
	FW1_STATEPREPARED = 0x400,
	
	/// <summary>Can be used as an optimization on subsequent calls, when drawing several strings with the same settings.</summary>
	FW1_IMMEDIATECALL = FW1_CONSTANTSPREPARED | FW1_BUFFERSPREPARED | FW1_STATEPREPARED,
	
	/// <summary>When a draw method returns, the device-context will have been restored to the same state as before the call.</summary>
	FW1_RESTORESTATE = 0x800,
	
	/// <summary>Any new glyphs added during a call are not flushed to the device-resources.
	/// It is a good idea to use this flag for text-operations on deferred contexts, when drawing text on multiple threads simultaneously, in order to guarantee the proper order of operations.</summary>
	FW1_NOFLUSH = 0x1000,
	
	/// <summary>Any new glyphs will be cached in the atlas and glyph-maps, but no geometry is drawn.</summary>
	FW1_CACHEONLY = 0x2000,
	
	/// <summary>No new glyphs will be added to the atlas or glyph-maps. Any glyphs not already present in the atlas will be replaced with a default fall-back glyph (empty box).</summary>
	FW1_NONEWGLYPHS = 0x4000,
	
	/// <summary>A text-layout will be run through DirectWrite and new fonts will be prepared, but no actual drawing will take place, and no additional glyphs will be cached.</summary>
	FW1_ANALYZEONLY = 0x8000,
	
	/// <summary>Don't use.</summary>
	FW1_UNUSED = 0xffffffff
};

/// <summary>Coordinates for a single glyph in the atlas.</summary>
/// <remarks>Each glyph image inserted in a glyph sheet texture gets a unique index in that sheet, and a corresponding FW1_GLYPHCOORDS entry in the sheet's coord buffer, describing its location in the sheet as well as its dimensions.</remarks>
struct FW1_GLYPHCOORDS {
	/// <summary>The left texture coordinate.</summary>
	FLOAT TexCoordLeft;
	
	/// <summary>The top texture coordinate.</summary>
	FLOAT TexCoordTop;
	
	/// <summary>The right texture coordinate.</summary>
	FLOAT TexCoordRight;
	
	/// <summary>The bottom texture coordinate.</summary>
	FLOAT TexCoordBottom;
	
	/// <summary>The offset of the left edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionLeft;
	
	/// <summary>The offset of the top edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionTop;
	
	/// <summary>The offset of the right edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionRight;
	
	/// <summary>The offset of the bottom edge of the glyph image, relative its offset in the text.</summary>
	FLOAT PositionBottom;
};

/// <summary>Description of a glyph sheet.</summary>
/// <remarks></remarks>
struct FW1_GLYPHSHEETDESC {
	/// <summary>The number of glyphs currently stored in this sheet.</summary>
	UINT GlyphCount;
	
	/// <summary>The width of this sheet's texture, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of this sheet's texture, in pixels.</summary>
	UINT Height;
	
	/// <summary>The number of mip-levels for this sheet's texture.</summary>
	UINT MipLevels;
};

/// <summary>Metrics for a glyph image.</summary>
/// <remarks>This structure is filled in as part of the FW1_GLYPHIMAGEDATA structure when a glyph-image is rendered by IFW1DWriteRenderTarget::DrawGlyphTemp.</remarks>
struct FW1_GLYPHMETRICS {
	/// <summary>The horizontal offset from a glyph's position in text to the left edge of its image.</summary>
	FLOAT OffsetX;
	
	/// <summary>The vertical offset form a glyph's position in text to the top edge of its image.</summary>
	FLOAT OffsetY;
	
	/// <summary>The width of the glyph image, in pixels.</summary>
	UINT Width;
	
	/// <summary>The height of the glyph image, in pixels.</summary>
	UINT Height;
};

/// <summary>Image data for a glyph.</summary>
/// <remarks>This structure is filled by the IFW1DWriteRenderTarget::DrawGlyphTemp Method.</remarks>
struct FW1_GLYPHIMAGEDATA {
	/// <summary>Metrics for the glyph.</summary>
	FW1_GLYPHMETRICS Metrics;
	
	/// <summary>Pointer to the pixels of the glyph-image.</summary>
	const void *pGlyphPixels;
	
	/// <summary>The number of bytes in a row of the image data.</summary>
	UINT RowPitch;
	
	/// <summary>The number of bytes between the start of one pixel and the next.</summary>
	UINT PixelStride;
};

/// <summary>A vertex corresponding to a single glyph.</summary>
/// <remarks>When an IFW1TextRenderer draws a string, each output glyph is converted to an FW1_GLYPHVERTEX entry in an IFW1TextGeometry object.</remarks>
struct FW1_GLYPHVERTEX {
	/// <summary>The base X position of the glyph.</summary>
	FLOAT PositionX;
	
	/// <summary>The base Y position of the glyph.</summary>
	FLOAT PositionY;
	
	/// <summary>The index of the glyph.</summary>
	UINT32 GlyphIndex;
	
	/// <summary>The color of the glyph, as 0xAaBbGgRr.</summary>
	UINT32 GlyphColor;
};

/// <summary>An array of vertices, sorted by glyph-sheet.</summary>
/// <remarks>This structure is returned by the IFW1TextGeometry::GetGlyphVerticesTemp Method.</remarks>
struct FW1_VERTEXDATA {
	/// <summary>The number of sheets in the glyph-atlas that are used, starting with the first sheet in the atlas.</summary>
	UINT SheetCount;
	
	/// <summary>An array of <i>SheetCount</i> unsigned integers, which specify the number of glyphs using each sheet.
	/// The sum of all counts is <i>TotalVertexCount</i>. Some counts may be zero.</summary>
	const UINT *pVertexCounts;
	
	/// <summary>The total number of vertices.</summary>
	UINT TotalVertexCount;
	
	/// <summary>An array of <i>TotalVertexCount</i> vertices, sorted by sheet.</summary>
	const FW1_GLYPHVERTEX *pVertices;
};

/// <summary>A rectangle.</summary>
/// <remarks></remarks>
struct FW1_RECTF {
	/// <summary>The X coordinate of the left edge of the rectangle.</summary>
	FLOAT Left;
	
	/// <summary>The Y coordinate of the top edge of the rectangle.</summary>
	FLOAT Top;
	
	/// <summary>The X coordinate of the right edge of the rectangle.</summary>
	FLOAT Right;
	
	/// <summary>The Y coordinate of the bottom edge of the rectangle.</summary>
	FLOAT Bottom;
};

/// <summary>Describes a single font. This structure is used in the FW1_FONTWRAPPERCREATEPARAMS structure.</summary>
/// <remarks>If pszFontFamily is NULL when creating an IFW1FontWrapper object, no default font will be set up.
/// This is perfectly valid when drawing text using one of the DrawTextLayout methods.
/// However, the DrawString methods will silently fail if no default font is set up.<br/>
/// If pszFontFamily is not NULL, the FontWeight, FontStyle and FontStretch members must be set to valid values according to the DirectWrite documentation.
/// Zero is not a valid value for these.</remarks>
struct FW1_DWRITEFONTPARAMS {
	/// <summary>The name of the font-family. Valid values include <i>Arial</i>, <i>Courier New</i>, etc. as long as the specified font is installed.
	/// Unavailable fonts will automatically fall back to a different font.
	/// This member can be set to NULL, if no default font is desired when using the structure to create a font-wrapper.</summary>
	LPCWSTR pszFontFamily;
	
	/// <summary>The font weight. See DirectWrite documentation.</summary>
	DWRITE_FONT_WEIGHT FontWeight;
	
	/// <summary>The font style. See DirectWrite documentation.</summary>
	DWRITE_FONT_STYLE FontStyle;
	
	/// <summary>The font stretch. See DirectWrite documentation.</summary>
	DWRITE_FONT_STRETCH FontStretch;
	
	/// <summary>The locale. NULL for default.</summary>
	LPCWSTR pszLocale;
};

/// <summary>The FW1_FONTWRAPPERCREATEPARAMS is used with the IFW1Factory::CreateFontWrapper method, and describes settings for the created IFW1FontWrapper object.</summary>
/// <remarks>If a member has the value zero, the default value will be chosen instead. See FW1_DWRITEFONTPARAMS for requirements for its members.</remarks>
struct FW1_FONTWRAPPERCREATEPARAMS {
	/// <summary>The width of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetWidth;
	
	/// <summary>The height of the glyph sheet textures to store glyph images in. 0 defaults to 512.</summary>
	UINT GlyphSheetHeight;
	
	/// <summary>The maximum number of glyphs per texture. A buffer of <i>MaxGlyphCountPerSheet * 32</i> bytes is preallocated for each sheet. 0 defaults to 2048.</summary>
	UINT MaxGlyphCountPerSheet;
	
	/// <summary>The number of mip-levels for the glyph sheet textures. 0 defaults to 1.</summary>
	UINT SheetMipLevels;
	
	/// <summary>If set to TRUE, the sampler-state is created with anisotropic filtering.</summary>
	BOOL AnisotropicFiltering;
	
	/// <summary>The maximum width of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphWidth;
	
	/// <summary>The maximum height of a single glyph.
	/// This value is used to decide how large the DirectWrite render target needs to be, which is used when drawing glyph images to put in the atlas.
	/// 0 defaults to 384.</summary>
	UINT MaxGlyphHeight;
	
	/// <summary>If set to TRUE, no geometry shader is used.</summary>
	BOOL DisableGeometryShader;
	
	/// <summary>The size in bytes of the dynamic vertex buffer to upload glyph vertices to when drawing a string. 0 defaults to 4096 * 16.<br/>
	/// Each glyph vertex is either 16 or 20 bytes in size, and each glyph requires either 1 or 4 vertices depending on if the geometry shader is used.</summary>
	UINT VertexBufferSize;
	
	/// <summary>Description of the default font. See FW1_DWRITEFONTPARAMS.</summary>
	FW1_DWRITEFONTPARAMS DefaultFontParams;
};

interface IFW1Factory;
/// <summary>All FW1 interfaces (except for IFW1Factory) inherits from IFW1Object.</summary>
/// <remarks>Since all interfaces inhert from IFW1Object, the factory which created an object can always be queried with its GetFactory method.</remarks>
MIDL_INTERFACE("8D3C3FB1-F2CC-4331-A623-031F74C06617") IFW1Object : public IUnknown {
	public:
		/// <summary>Get the factory that created an object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
		virtual HRESULT STDMETHODCALLTYPE GetFactory(
			__out IFW1Factory **ppFactory
		) = 0;
};

/// <summary>A sheet contains a texture with glyph images, and a coord-buffer with an FW1_GLYPHCOORDS entry for each glyph.</summary>
MIDL_INTERFACE("60CAB266-C805-461d-82C0-392472EECEFA") IFW1GlyphSheet : public IFW1Object {
	public:
		/// <summary>Get the ID3D11Device the sheet is created on.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
		virtual HRESULT STDMETHODCALLTYPE GetDevice(
			__out ID3D11Device **ppDevice
		) = 0;
		
		/// <summary>Get the properties of a glyph sheet.</summary>
		/// <remarks></remarks>
		/// <returns>Returns nothing.</returns>
		/// <param name="pDesc">Pointer to a sheet description.</param>
		virtual void STDMETHODCALLTYPE GetDesc(
			__out FW1_GLYPHSHEETDESC *pDesc
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's texture.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppSheetTextureSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetSheetTexture(
			__out ID3D11ShaderResourceView **ppSheetTextureSRV
		) = 0;
		
		/// <summary>Get the ID3D11ShaderResourceView for the sheet's coord buffer.</summary>
		/// <remarks>The coord buffer contains 32 bytes per glyph, stored as two float4, representing the data in an FW1_GLYPHCOORDS structure.<br/>
		/// If the sheet is created without a hardware coord buffer, the method will return success and set the coord buffer to NULL.
		/// See IFW1Factory::CreateGlyphSheet.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppCoordBufferSRV">Address of a pointer to an ID3D11ShaderResourceView.</param>
		virtual HRESULT STDMETHODCALLTYPE GetCoordBuffer(
			__out ID3D11ShaderResourceView **ppCoordBufferSRV
		) = 0;
		
		/// <summary>Get a sheet's coord-buffer, as an array of FW1_GLYPHCOORDS.</summary>
		/// <remarks>The returned buffer is valid for the lifetime of the sheet, and may only be read and never altered.
		/// The maximum valid index at any given time is one less than the number of glyphs in the sheet, which can be queried using IFW1GlyphSheet::GetDesc.</remarks>
		/// <returns>Returns a constant pointer to the sheet's coord-buffer.</returns>
		virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		) = 0;
		
		/// <summary>Set the sheet shader resources on the provided context.</summary>
		/// <remarks>This method sets the sheet texture as a pixelshader resource for slot 0, and optionally the coord buffer as geometryshader resource for slot 0.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pContext">The context to set the sheet shader resources on.</param>
		/// <param name="Flags">This parameter can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
		/// FW1_NOGEOMETRYSHADER: don't bind the coord buffer as a shader-resource for the geometry shader, even if it's available.
		/// </param>
		virtual HRESULT STDMETHODCALLTYPE BindSheet(
			__in ID3D11DeviceContext *pContext,
			__in UINT Flags
		) = 0;
		
		/// <summary>Insert a glyph into the sheet.</summary>
		/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
		/// <returns>If the glyph is inserted, the index of the new glyph in the sheet is returned. This index can be used to get the glyph's coordinates from the sheet coord buffer. See IFW1GlyphSheet::GetCoordBuffer and IFW1GlyphSheet::GetGlyphCoords.<br/>
		/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
		/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
		/// <param name="pGlyphData">A pointer to image data.</param>
		/// <param name="RowPitch">The number of bytes in a row of image data.</param>
		/// <param name="PixelStride">The number of bytes between successive pixels.</param>
		virtual UINT STDMETHODCALLTYPE InsertGlyph(
			__in const FW1_GLYPHMETRICS *pGlyphMetrics,
			__in const void *pGlyphData,
			__in UINT RowPitch,
			__in UINT PixelStride
		) = 0;
		
		/// <summary>Close the sheet for additional glyphs.</summary>
		/// <remarks>After calling this method any subsequent attempts to insert new glyphs into the sheet will fail.
		/// Calling this method can save some memory as the RAM copy of the texture can be released after the next call to IFW1GlyphSheet::Flush.</remarks>
		/// <returns>No return value.</returns>
		virtual void STDMETHODCALLTYPE CloseSheet(
		) = 0;
		
		/// <summary>Flush any new glyphs to the internal D3D11 buffers.</summary>
		/// <remarks>When glyphs are inserted into the sheet only the CPU-memory resources are updated.
		/// In order for these to be available for use by the GPU, they must be flushed to the device using a device-context.</remarks>
		/// <returns>No return value.</returns>
		/// <param name="pContext">The context to use when updating device resources.</param>
		virtual void STDMETHODCALLTYPE Flush(
			__in ID3D11DeviceContext *pContext
		) = 0;
};

/// <summary>A glyph-atlas is a collection of glyph-sheets.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A31EB6A2-7458-4e24-82B3-945A95623B1F") IFW1GlyphAtlas : public IFW1Object {
	/// <summary>Get the ID3D11Device the atlas is created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the total number of glyphs in all the atlas' sheets.</summary>
	/// <remarks></remarks>
	/// <returns>The total number of glyphs in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetTotalGlyphCount(
	) = 0;
	
	/// <summary>Get the number of texture sheets in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>The number of sheets in the atlas.</returns>
	virtual UINT STDMETHODCALLTYPE GetSheetCount(
	) = 0;
	
	/// <summary>Get a pointer to an IFW1GlyphSheet in the atlas.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="SheetIndex">The index of the sheet to be obtained.</param>
	/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE GetSheet(
		__in UINT SheetIndex,
		__out IFW1GlyphSheet **ppGlyphSheet
	) = 0;
	
	/// <summary>Get a pointer to a sheet's glyph-coord buffer.</summary>
	/// <remarks></remarks>
	/// <returns>If <i>SheetIndex</i> is valid, returns a pointer to a coord buffer. See IFW1GlyphSheet::GetGlyphCoords.</returns>
	/// <param name="SheetIndex">The index of the sheet which coord buffer is to be obtained.</param>
	virtual const FW1_GLYPHCOORDS* STDMETHODCALLTYPE GetGlyphCoords(
		__in UINT SheetIndex
	) = 0;
	
	/// <summary>Bind a sheet's shader resources on a device context.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pContext">The context to set the shader resources on.</param>
	/// <param name="SheetIndex">The index of the sheet to bind.</param>
	/// <param name="Flags">Flags that specify whether to set the geometry shader coord buffer. See IFW1GlyphSheet::BindSheet.</param>
	virtual HRESULT STDMETHODCALLTYPE BindSheet(
		__in ID3D11DeviceContext *pContext,
		__in UINT SheetIndex,
		__in UINT Flags
	) = 0;
	
	/// <summary>Insert a glyph into the atlas.</summary>
	/// <remarks>The parameters for this method can be obtained as part of the FW1_GLYPHIMAGEDATA structure filled in by the IFW1DWriteRenderTarget::DrawGlyphTemp method.</remarks>
	/// <returns>If the glyph is inserted, the ID of the new glyph in the atlas is returned.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is place in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the method fails to insert the glyph, the returned value is 0xFFFFFFFF.</returns>
	/// <param name="pGlyphMetrics">A pointer to an FW1_GLYPHMETRICS structure, specifying the metrics of the glyph to be inserted.</param>
	/// <param name="pGlyphData">A pointer to image data.</param>
	/// <param name="RowPitch">The number of bytes in a row of image data.</param>
	/// <param name="PixelStride">The number of bytes between successive pixels.</param>
	virtual UINT STDMETHODCALLTYPE InsertGlyph(
		__in const FW1_GLYPHMETRICS *pGlyphMetrics,
		__in const void *pGlyphData,
		__in UINT RowPitch,
		__in UINT PixelStride
	) = 0;
	
	/// <summary>Insert a sheet into the atlas.</summary>
	/// <remarks>This method is used internally whenever new glyphs no longer fits in existing sheets. The atlas will hold a reference to the sheet for the remainder of its lifetime.</remarks>
	/// <returns>On success, eturns the index of the sheet in the atlas after insertion.<br/>If the method fails, 0xFFFFFFFF is returned.</returns>
	/// <param name="pGlyphSheet">A pointer ot the glyph sheet to insert.</param>
	virtual UINT STDMETHODCALLTYPE InsertSheet(
		__in IFW1GlyphSheet *pGlyphSheet
	) = 0;
	
	/// <summary>Flush all new or internally updated sheets.</summary>
	/// <remarks>See IFW1GlyphSheet::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use when updating device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>Collection of glyph-maps, mapping font/size/glyph information to an ID in a glyph atlas.</summary>
/// <remarks>Whenever a glyph or glyphmap is queried from the glyph-provider, it will be dynamically inserted if it does not already exist.</remarks>
MIDL_INTERFACE("F8360043-329D-4EC9-B0F8-ACB00FA77420") IFW1GlyphProvider : public IFW1Object {
	/// <summary>Get the IFW1GlyphAtlas this glyph-provider references.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the DirectWrite factory a glyph-provider references.</summary>
	/// <remarks>The DirectWrite factory is used internally to create render-targets needed to draw glyph-images that are put in the glyph-atlas.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the DirectWrite font-collection referenced by a glyph-provider.</summary>
	/// <remarks>The DirectWrite font collection is used internally only to match font-faces to unique names.
	/// Since different IDWriteFontFace objects can reference the same font, a reliable method of identifying a font is required.
	/// This is the only function of the font-collection in the scope of the glyph-provider.
	/// A font-face not from the same collection can still be used when requesting glyphs, in which case it will only be identified by its pointer value.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppFontCollection">Address of a pointer to an IDWriteFontCollection.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFontCollection(
		__out IDWriteFontCollection **ppFontCollection
	) = 0;
	
	/// <summary>Get a pointer identifying a glyph-map matching the specified font.</summary>
	/// <remarks>If the FW1_NONEWGLYPHS flag is not specified, new glyph-maps are created on demand.
	/// The glyph-map returned from this method is not meaningful outside of the glyph provider internals, but is needed for subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex.</remarks>
	/// <returns>A constant pointer identifying a glyph-map.
	/// This pointer should only be used in subsequent calls to IFW1GlyphProvider::GetAtlasIdFromGlyphIndex, and remains valid for the lifetime of the IFW1GlyphProvider.<br/>
	/// A NULL pointer may be returned, if using the FW1_NONEWGLYPHS flag and a matching glyph-map does not exist.</returns>
	/// <param name="pFontFace">A DirectWrite font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyph-maps are created.</param>
	virtual const void* STDMETHODCALLTYPE GetGlyphMapFromFont(
		__in IDWriteFontFace *pFontFace,
		__in FLOAT FontSize,
		__in UINT FontFlags
	) = 0;
	
	/// <summary>Get the ID of the specified glyph in the glyph-atlas.</summary>
	/// <remarks>If FW1_NONEWGLYPHS is not specified, any glyph not currently in the atlas will be inserted before the method returns.</remarks>
	/// <returns>The ID of the specified glyph in the glyph-atlas.
	/// The ID is always <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>, where <i>SheetIndex</i> is the index of the sheet texture the glyph is placed in, and <i>GlyphIndex</i> is the index of the glyph in that sheet.<br/>
	/// If the specified glyph does not exist and can not be inserted on demand, the ID of a fallback glyph is returned.</returns>
	/// <param name="pGlyphMap">A pointer identifying a glyph-map, previously obtained using IFW1GlyphProvider::GetGlyphMapFromFont.
	/// If this parameter is NULL, the ID of the last-resort fallback glyph is returned, which will be zero.</param>
	/// <param name="GlyphIndex">The index of the glyph in the DirectWrite font face.
	/// Glyph indices can be obtained from DirectWrite using IDWriteFontFace::GetGlyphIndices.</param>
	/// <param name="pFontFace">The DirectWrite font face that contains the glyph referenced by GlyphIndex.</param>
	/// <param name="FontFlags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted.</param>
	virtual UINT STDMETHODCALLTYPE GetAtlasIdFromGlyphIndex(
		__in const void *pGlyphMap,
		__in UINT16 GlyphIndex,
		__in IDWriteFontFace *pFontFace,
		__in UINT FontFlags
	) = 0;
};

/// <summary>Container for a DirectWrite render-target, used to draw glyph images that are to be inserted in a glyph atlas.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("A1EB4141-9A66-4097-A5B0-6FC84F8B162C") IFW1DWriteRenderTarget : public IFW1Object {
	/// <summary>Draw a glyph-image.</summary>
	/// <remarks>The data returned in the FW1_GLYPHIMAGEDATA should only be read, and is valid until the next call to a method in the IFW1DWriteRenderTarget.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pFontFace">The DirectWrite font face containing the glyph.</param>
	/// <param name="GlyphIndex">The index of the glyph in the font face.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="RenderingMode">The DirectWrite rendering mode. See DirectWrite documentation.</param>
	/// <param name="MeasuringMode">The DirectWrite measuring mode. See DirectWrite documentation..</param>
	/// <param name="pOutData">A pointer to an FW1_GLYPHIMAGEDATA structure that will be filled in with the glyph image data on success.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawGlyphTemp(
		__in IDWriteFontFace *pFontFace,
		__in UINT16 GlyphIndex,
		__in FLOAT FontSize,
		__in DWRITE_RENDERING_MODE RenderingMode,
		__in DWRITE_MEASURING_MODE MeasuringMode,
		__out FW1_GLYPHIMAGEDATA *pOutData
	) = 0;
};

/// <summary>An RGBA color.</summary>
/// <remarks>An IFW1ColorRGBA object can be set as the drawing effect for a range in an IDWriteTextLayout, to override the default color of the text.</remarks>
MIDL_INTERFACE("A0EA03A0-441D-49BE-9D2C-4AE27BB7A327") IFW1ColorRGBA : public IFW1Object {
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Color">The color to set, as 0xAaBbGgRr.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in UINT32 Color
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="Red">The red component, in [0, 1].</param>
	/// <param name="Green">The green component, in [0, 1].</param>
	/// <param name="Blue">The blue component, in [0, 1].</param>
	/// <param name="Alpha">The alpha component, in [0, 1].</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in FLOAT Red,
		__in FLOAT Green,
		__in FLOAT Blue,
		__in FLOAT Alpha
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four floats in [0, 1], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const FLOAT *pColor
	) = 0;
	
	/// <summary>Set the color.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pColor">Pointer to an array of four bytes in [0, 255], specifying the red, green, blue and alpha components at indices 0 to 3.</param>
	virtual void STDMETHODCALLTYPE SetColor(
		__in const BYTE *pColor
	) = 0;
	
	/// <summary>Get the color.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the color, as 0xAaBbGgRr.</returns>
	virtual UINT32 STDMETHODCALLTYPE GetColor32(
	) = 0;
};

/// <summary>A dynamic list of vertices. Note that this object is a simple array without synchronization and not safe to use simultaneously on more than one thread.</summary>
/// <remarks>When rendering a string, a vertex is inserted into an IFW1TextGeometry object for each glyph.
/// The vertices in an IFW1TextGeometry can be drawn by the IFW1FontWrapper::DrawGeometry method.<br/>
/// A pointer to the actual vertices can be obtained with the IFW1TextGeometry::GetGlyphVerticesTemp method.</remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextGeometry : public IFW1Object {
	/// <summary>Clear any vertices currently contained in the geometry object.</summary>
	/// <remarks>This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	virtual void STDMETHODCALLTYPE Clear(
	) = 0;
	
	/// <summary>Adds a vertex to the geometry.</summary>
	/// <remarks>The GlyphIndex member of the FW1_GLYPHVERTEX specified when inserting a vertex should be the atlas ID of the desired glyph, as <tt>((SheetIndex &lt;&lt; 16) | GlyphIndex)</tt>.
	/// See IFW1GlyphAtlas::InsertGlyph.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pVertex">Pointer to an FW1_GLYPHVERTEX structure describing the vertex.</param>
	virtual void STDMETHODCALLTYPE AddGlyphVertex(
		__in const FW1_GLYPHVERTEX *pVertex
	) = 0;
	
	/// <summary>Get the vertices in the geometry, sorted by glyph sheet.</summary>
	/// <remarks>When glyphs are inserted into the geometry they contain their glyph atlas ID.
	/// The glyphs are internally sorted by glyph sheet, and glyphs returned by GetGlyphVerticesTemp contain the index of the glyph in its containing sheet, and not the atlas ID.<br/>
	/// This method is not thread-safe.</remarks>
	/// <returns>An FW1_VERTEXDATA structure containing the glyph vertices.
	/// The pointers in this structure are owned by the geometry object and should not be modified.
	/// They are valid until the next call to a method in the IFW1TextGeometry.</returns>
	virtual FW1_VERTEXDATA STDMETHODCALLTYPE GetGlyphVerticesTemp(
	) = 0;
};

/// <summary>A text-renderer converts DirectWrite text layouts into glyph-vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("51E05736-6AFF-44A8-9745-77605C99E8F2") IFW1TextRenderer : public IFW1Object {
	/// <summary>Get the IFW1GlyphProvider used by a text-renderer.</summary>
	/// <remarks>The glyph provider is used internally to get the atlas IDs for any glyphs needed when drawing a text layout.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Convert a text layout to vertices.</summary>
	/// <remarks>This method internally calls the IDWriteTextLayout::Draw method, and handles callbacks to convert the formatted text into vertices, which will be stored in the passed IFW1TextGeometry object.
	/// This method is not thread-safe.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="pTextLayout">A DirectWrite text layout. See the DirectWrite documentation.</param>
	/// <param name="OriginX">The X origin of the text.</param>
	/// <param name="OriginY">The Y origin of the text.</param>
	/// <param name="Color">The default text color, as 0xAaGgBbRr.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_ALIASED - No anti-aliasing is used when drawing the glyphs.<br/>
	/// FW1_NONEWGLYPHS - No new glyphs are inserted into the atlas. Not previously cached glyphs are replaced with a fallback glyph (usually an empty box).<br/>
	/// FW1_CACHEONLY - All glyphs are queried from the glyph-provider and cached in the glyph-atlas, but no geometry is produced.<br/>
	/// FW1_ANALYZEONLY - The text-layout is analyzed and glyph-maps are prepared, but the glyphs in the string are not cached and no geometry is produced.<br/>
	/// </param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual HRESULT STDMETHODCALLTYPE DrawTextLayout(
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
};

/// <summary>This interface contains all render states and shaders needed to draw glyphs.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("906928B6-79D8-4b42-8CE4-DC7D7046F206") IFW1GlyphRenderStates : public IFW1Object {
	/// <summary>Get the ID3D11Device that all render states are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Set the internal states on a context.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to set the states on.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - States are set up to draw indexed quads instead of constructing quads in the geometry shader.<br/>
	/// FW1_CLIPRECT - Shaders will be set up to clip any drawn glyphs to the clip-rect set in IFW1GlyphRenderStates::UpdateShaderConstants.
	/// </param>
	virtual void STDMETHODCALLTYPE SetStates(
		__in ID3D11DeviceContext *pContext,
		__in UINT Flags
	) = 0;
	
	/// <summary>Update the internal constant buffer.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The context to use to update the constant buffer.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip drawn glyphs to.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which all glyph vertices will be multiplied with, in the geometry or vertex shader.</param>
	virtual void STDMETHODCALLTYPE UpdateShaderConstants(
		__in ID3D11DeviceContext *pContext,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix
	) = 0;
	
	/// <summary>Returns whether a geometry shader is available.</summary>
	/// <remarks>When an IFW1GlyphRenderStates object is created, it may attempt to create a geometry shader, depending on the parameters passed to IFW1Factory::CreateRenderStates.
	/// If a geometry shader is not created, either because of the specified parameters or because the device feature level does not support geometry shaders, this method will return FALSE.</remarks>
	/// <returns>Returns TRUE if a geometry shader is available, and otherwise returns FALSE.</returns>
	virtual BOOL STDMETHODCALLTYPE HasGeometryShader(
	) = 0;
};

/// <summary>A container for a dynamic vertex and index buffer, used to draw glyph vertices.</summary>
/// <remarks></remarks>
MIDL_INTERFACE("E6CD7A32-5B59-463c-9B1B-D44074FF655B") IFW1GlyphVertexDrawer : public IFW1Object {
	/// <summary>Get the ID3D11Device that the buffers are created on.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Upload the specified vertices to the device buffers and draw them.</summary>
	/// <remarks></remarks>
	/// <returns>Returns the index of the sheet in the atlas that was last bound to the device context during the operation.</returns>
	/// <param name="pContext">The context to use to draw.</param>
	/// <param name="pGlyphAtlas">The glyph atlas containg the glyphs referenced by the vertices.</param>
	/// <param name="pVertexData">Pointer to an FW1_VERTEXDATA structure, containing vertices to be drawn, sorted by glyph sheet.
	/// These are easiest obtained from an IFW1TextGeometry object.</param>
	/// <param name="Flags">Can include zero or more of the following values, ORd together. Any additional values are ignored.<br/>
	/// FW1_NOGEOMETRYSHADER - Vertices are converted to quads on the fly on the CPU, instead of being sent directly to the device for the geometry shader.<br/>
	/// FW1_BUFFERSPREPARED - The internal buffers are assumed to already be set on the device context from a previous call. (Avoids redundant state changes when drawing multiple times).
	/// </param>
	/// <param name="PreboundSheet">If a sheet in the atlas is known to already be correctly set on the device context, specify its index in the atlas with this parameter, to avoid redundant state changes.
	/// If no sheet is known to already be set, specify 0xFFFFFFFF, or another value greater than the number of sheets in the atlas.
	/// </param>
	virtual UINT STDMETHODCALLTYPE DrawVertices(
		__in ID3D11DeviceContext *pContext,
		__in IFW1GlyphAtlas *pGlyphAtlas,
		__in const FW1_VERTEXDATA *pVertexData,
		__in UINT Flags,
		__in UINT PreboundSheet
	) = 0;
};

/// <summary>The IFW1FontWrapper interface is the main interface used to draw text.
/// It holds references to all objects needed to format and convert text to vertices, as well as the D3D11 states and buffers needed to draw them.</summary>
/// <remarks>Create a font-wrapper using IFW1Factory::CreateFontWrapper</remarks>
MIDL_INTERFACE("83347A5C-B0B1-460e-A35C-427E8B85F9F4") IFW1FontWrapper : public IFW1Object {
	/// <summary>Get the ID3D11Device that is used by the font-wrapper.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDevice">Address of a pointer to an ID3D11Device.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDevice(
		__out ID3D11Device **ppDevice
	) = 0;
	
	/// <summary>Get the DirectWrite factory used by the font-wrapper.</summary>
	/// <remarks>The DirectWrite factory is used internally to create text-layouts when drawing strings using any of the DrawString methods.</remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppDWriteFactory">Address of a pointer to an IDWriteFactory.</param>
	virtual HRESULT STDMETHODCALLTYPE GetDWriteFactory(
		__out IDWriteFactory **ppDWriteFactory
	) = 0;
	
	/// <summary>Get the IFW1GlyphAtlas used to cache glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphAtlas(
		__out IFW1GlyphAtlas **ppGlyphAtlas
	) = 0;
	
	/// <summary>Get the IFW1GlyphProvider used to map glyphs to atlas IDs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
	virtual HRESULT STDMETHODCALLTYPE GetGlyphProvider(
		__out IFW1GlyphProvider **ppGlyphProvider
	) = 0;
	
	/// <summary>Get the IFW1GlyphRenderStates containing the render states needed to draw glyphs.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppRenderStates">Address of a pointer to an IFW1GlyphRenderStates.</param>
	virtual HRESULT STDMETHODCALLTYPE GetRenderStates(
		__out IFW1GlyphRenderStates **ppRenderStates
	) = 0;
	
	/// <summary>Get the IFW1GlyphVertexDrawer used to draw glyph vertices.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="ppVertexDrawer">Address of a pointer to an IFW1GlyphVertexDrawer.</param>
	virtual HRESULT STDMETHODCALLTYPE GetVertexDrawer(
		__out IFW1GlyphVertexDrawer **ppVertexDrawer
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a DirectWrite text layout.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.<br/>
	/// The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pTextLayout">The text layout to draw.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when drawing a preconstructed text layout.</param>
	virtual void STDMETHODCALLTYPE DrawTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="X">The X origin of the text.</param>
	/// <param name="Y">The Y origin of the text .</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in FLOAT X,
		__in FLOAT Y,
		__in UINT32 Color,
		__in UINT Flags
	) = 0;
	
	/// <summary>Draw a string.</summary>
	/// <remarks>The pContext parameter can be NULL only if the FW1_NOFLUSH and either the FW1_ANALYZEONLY or the FW1_CACHEONLY flags are specified.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pszString">The NULL-terminated string to draw.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Measure a string.</summary>
	/// <remarks>This function uses the IDWriteTextLayout::GetOverhangMetrics to obtain the size of the string.</remarks>
	/// <returns>The smallest rectangle that completely contains the string if drawn with DrawString and the same parameters as used with MeasureString.</returns>
	/// <param name="pszString">The NULL-terminated string to measure.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual FW1_RECTF STDMETHODCALLTYPE MeasureString(
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT Flags
	) = 0;
	
	/// <summary>Analyze a string and generate geometry to draw it.</summary>
	/// <remarks>pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pszString">The NULL-terminated string to create geometry from.</param>
	/// <param name="pszFontFamily">The font family to use, such as Arial or Courier New.</param>
	/// <param name="FontSize">The size of the font.</param>
	/// <param name="pLayoutRect">A pointer to a rectangle to format the text in.</param>
	/// <param name="Color">The color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeString(
		__in ID3D11DeviceContext *pContext,
		__in const WCHAR *pszString,
		__in const WCHAR *pszFontFamily,
		__in FLOAT FontSize,
		__in const FW1_RECTF *pLayoutRect,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Analyze a text layout and generate geometry to draw it.</summary>
	/// <remarks>Consult the DirectWrite documentation for details on how to construct a text-layout.
	/// pTextGeometry can be NULL if the FW1_ANALYZEONLY or FW1_CACHEONLY flags are specified, as no actual geometry will be generated.
	/// pContext can be NULL if the FW1_NOFLUSH flag is used, as any new glyphs will not be flushed to the device buffers.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">A device context to use to update device buffers when new glyphs are added to the glyph-atlas.</param>
	/// <param name="pTextLayout">The DirectWrite text layout to create geometry from.</param>
	/// <param name="OriginX">The X origin of the text in the layout.</param>
	/// <param name="OriginY">The Y origin of the text in the layout.</param>
	/// <param name="Color">The default color of the text, as 0xAaBbGgRr.</param>
	/// <param name="Flags">See FW1_TEXT_FLAG. The alignment and word-wrapping flags have no meaning when using a preconstructed text layout.</param>
	/// <param name="pTextGeometry">An IFW1TextGeometry object that the output vertices will be appended to.</param>
	virtual void STDMETHODCALLTYPE AnalyzeTextLayout(
		__in ID3D11DeviceContext *pContext,
		__in IDWriteTextLayout *pTextLayout,
		__in FLOAT OriginX,
		__in FLOAT OriginY,
		__in UINT32 Color,
		__in UINT Flags,
		__in IFW1TextGeometry *pTextGeometry
	) = 0;
	
	/// <summary>Draw geometry.</summary>
	/// <remarks></remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to draw on.</param>
	/// <param name="pGeometry">The geometry to draw.</param>
	/// <param name="pClipRect">A pointer to a rectangle to clip the text to if also using the FW1_CLIPRECT flag, or NULL to not clip. This rect is in text-space, and clipping is performed prior to any transformation.</param>
	/// <param name="pTransformMatrix">An array of 16 floats, representing a matrix which the text will be transformed by, or NULL to draw in screen-space.</param>
	/// <param name="Flags">See the FW1_TEXT_FLAG enumeration.</param>
	virtual void STDMETHODCALLTYPE DrawGeometry(
		__in ID3D11DeviceContext *pContext,
		__in IFW1TextGeometry *pGeometry,
		__in const FW1_RECTF *pClipRect,
		__in const FLOAT *pTransformMatrix,
		__in UINT Flags
	) = 0;
	
	/// <summary>Flush any new glyphs to GPU resources.</summary>
	/// <remarks>This method calls IFW1GlyphAtlas::Flush to flush any newly cached glyphs.
	/// This method is only needed if drawing text using the FW1_NOFLUSH flag and delaying flushing data to the device, as otherwise it is implicitly called whenever a string is drawn. See IFW1GlyphAtlas::Flush.</remarks>
	/// <returns>No return value.</returns>
	/// <param name="pContext">The device context to use to update device resources.</param>
	virtual void STDMETHODCALLTYPE Flush(
		__in ID3D11DeviceContext *pContext
	) = 0;
};

/// <summary>
/// Used to create all subsequent FW1 objects.
/// An IFW1Factory can be created using FW1CreateFactory.
/// </summary>
/// <remarks>
/// Any and all FW1 objects are always created through a factory. All FW1 objects inherit from IFW1Object, and holds a reference to the factory that created them.
/// If an object in turn creates new objects, it uses the same factory that created the object itself.
/// For example, a glyph-atlas will ask the factory that created it to create new glyph-sheets as glyphs are added to the atlas.
/// </remarks>
MIDL_INTERFACE("8004DB2B-B5F9-4420-A6A2-E17E15E4C336") IFW1Factory : public IUnknown {
	public:
		/// <summary>Create an IFW1FontWrapper object with default settings.</summary>
		/// <returns>Standard HRESULT error code.</returns>
		/// <remarks></remarks>
		/// <param name="pDevice">The ID3D11Device the font-wrapper will be used with.</param>
		/// <param name="pszFontFamily">The default font-family to use when drawing strings.
		/// Valid values include for example L"Arial" and L"Courier New", provided that the fonts are installed on the system.
		/// Font-fallback will automatically choose a different font if the specified one is not available.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in LPCWSTR pszFontFamily,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pCreateParams">Pointer to an FW1_FONTWRAPPERCREATEPARAMS structure that describes the settings for the new font-wrapper.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_FONTWRAPPERCREATEPARAMS *pCreateParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1FontWrapper object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the font-wrapper will be used with.</param>
		/// <param name="pGlyphAtlas">An IFW1GlyphAtlas that glyph-images will be stored in.</param>
		/// <param name="pGlyphProvider">An IFW1GlyphProvider that handles fonts and glyphmaps.</param>
		/// <param name="pGlyphVertexDrawer">An IFW1GlyphVertexDrawer that handles drawing glyph-vertices.</param>
		/// <param name="pGlyphRenderStates">An IFW1GlyphRenderStates that handles all needed context states when drawing glyphs.</param>
		/// <param name="pDWriteFactory">An IDWriteFactory that is used to create render-targets to draw glyphs with.</param>
		/// <param name="pDefaultFontParams">Pointer to an FW1_DWRITEFONTPARAMS that describes the default font.
		/// Can be NULL if only drawing preconstructed DirectWrite text layouts.</param>
		/// <param name="ppFontWrapper">Address of a pointer to a font-wrapper (See IFW1FontWrapper).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateFontWrapper(
			__in ID3D11Device *pDevice,
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IFW1GlyphProvider *pGlyphProvider,
			__in IFW1GlyphVertexDrawer *pGlyphVertexDrawer,
			__in IFW1GlyphRenderStates *pGlyphRenderStates,
			__in IDWriteFactory *pDWriteFactory,
			__in const FW1_DWRITEFONTPARAMS *pDefaultFontParams,
			__out IFW1FontWrapper **ppFontWrapper
		) = 0;
		
		/// <summary>Create an IFW1GlyphVertexDrawer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the vertex drawer will be used with.</param>
		/// <param name="VertexBufferSize">The size in bytes of the dynamic vertex buffer. An index buffer will be created with a matching size.</param>
		/// <param name="ppGlyphVertexDrawer">Address of a pointer to a glyph-vertex drawer (See IFW1GlyphVertexDrawer).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphVertexDrawer(
			__in ID3D11Device *pDevice,
			__in UINT VertexBufferSize,
			__out IFW1GlyphVertexDrawer **ppGlyphVertexDrawer
		) = 0;
		
		/// <summary>Create an IFW1GlyphRenderStates object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">The ID3D11Device that the render-states will be used with.</param>
		/// <param name="DisableGeometryShader">If TRUE, no geometry shader will be created.</param>
		/// <param name="AnisotropicFiltering">If TRUE, a sampler state enabling anisotropic filtering will be created.</param>
		/// <param name="ppGlyphRenderStates">Address of a pointer to a glyph render-states object (See IFW1GlyphRenderStates).</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphRenderStates(
			__in ID3D11Device *pDevice,
			__in BOOL DisableGeometryShader,
			__in BOOL AnisotropicFiltering,
			__out IFW1GlyphRenderStates **ppGlyphRenderStates
		) = 0;
		
		/// <summary>Create an IFW1TextRenderer object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphProvider">The IFW1GlyphProvider that provides glyph-information for the text-renderer.</param>
		/// <param name="ppTextRenderer">Address of a pointer to a IFW1TextRenderer.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextRenderer(
			__in IFW1GlyphProvider *pGlyphProvider,
			__out IFW1TextRenderer **ppTextRenderer
		) = 0;
		
		/// <summary>Create an IFW1TextGeometry object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="ppTextGeometry">Address of a pointer to an IFW1TextGeometry.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateTextGeometry(
			__out IFW1TextGeometry **ppTextGeometry
		) = 0;
		
		/// <summary>Create an IFW1GlyphProvider object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pGlyphAtlas">A glyph atlas to store glyph images in.</param>
		/// <param name="pDWriteFactory">A DirectWrite factory, used to create glyph render targets.</param>
		/// <param name="pFontCollection">A font collection used to identify fonts from DirectWrite font-face objects.</param>
		/// <param name="MaxGlyphWidth">The maximum width of a single glyph.</param>
		/// <param name="MaxGlyphHeight">The maximum height of a single glyph.</param>
		/// <param name="ppGlyphProvider">Address of a pointer to an IFW1GlyphProvider.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphProvider(
			__in IFW1GlyphAtlas *pGlyphAtlas,
			__in IDWriteFactory *pDWriteFactory,
			__in IDWriteFontCollection *pFontCollection,
			__in UINT MaxGlyphWidth,
			__in UINT MaxGlyphHeight,
			__out IFW1GlyphProvider **ppGlyphProvider
		) = 0;
		
		/// <summary>Create an IFW1DWriteRenderTarget object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDWriteFactory">A DirectWrite factory used to create the internal render target.</param>
		/// <param name="RenderTargetWidth">The width of the render target.</param>
		/// <param name="RenderTargetHeight">The height of the render target.</param>
		/// <param name="ppRenderTarget">Address of a pointer to an IFW1DWriteRenderTarget.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateDWriteRenderTarget(
			__in IDWriteFactory *pDWriteFactory,
			__in UINT RenderTargetWidth,
			__in UINT RenderTargetHeight,
			__out IFW1DWriteRenderTarget **ppRenderTarget
		) = 0;
		
		/// <summary>Create an IFW1GlyphAtlas object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the atlas textures.</param>
		/// <param name="GlyphSheetHeight">Height of the atlas textures.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates for each sheet, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the atlas textures will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCountPerSheet">The maximum number of glyphs in a single sheet texture.</param>
		/// <param name="MipLevels">The number of mip levels for the textures.</param>
		/// <param name="MaxGlyphSheetCount">The maximum number of sheet textures.</param>
		/// <param name="ppGlyphAtlas">Address of a pointer to an IFW1GlyphAtlas.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphAtlas(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCountPerSheet,
			__in UINT MipLevels,
			__in UINT MaxGlyphSheetCount,
			__out IFW1GlyphAtlas **ppGlyphAtlas
		) = 0;
		
		/// <summary>Create an IFW1GlyphSheet object.</summary>
		/// <remarks></remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="pDevice">A D3D11 device used to create device resources.</param>
		/// <param name="GlyphSheetWidth">Width of the sheet texture.</param>
		/// <param name="GlyphSheetHeight">Height of the sheet texture.</param>
		/// <param name="HardwareCoordBuffer">If TRUE, create a D3D11 buffer with glyph coordinates, for use with the geometry shader.</param>
		/// <param name="AllowOversizedGlyph">If FALSE, glyphs that are larger than the sheet texture will be rejected instead of partially inserted.</param>
		/// <param name="MaxGlyphCount">The maximum number of glyphs in the sheet.</param>
		/// <param name="MipLevels">The number of mip levels for the texture.</param>
		/// <param name="ppGlyphSheet">Address of a pointer to an IFW1GlyphSheet.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateGlyphSheet(
			__in ID3D11Device *pDevice,
			__in UINT GlyphSheetWidth,
			__in UINT GlyphSheetHeight,
			__in BOOL HardwareCoordBuffer,
			__in BOOL AllowOversizedGlyph,
			__in UINT MaxGlyphCount,
			__in UINT MipLevels,
			__out IFW1GlyphSheet **ppGlyphSheet
		) = 0;
		
		/// <summary>Create an IFW1ColorRGBA object.</summary>
		/// <remarks>An IFW1ColorRGBA can be set as the drawing effect for a range in a DirectWrite text layout to override the default color.</remarks>
		/// <returns>Standard HRESULT error code.</returns>
		/// <param name="Color">The initial color, as 0xAaBbGgRr.</param>
		/// <param name="ppColor">Address of a pointer to an IFW1ColorRGBA.</param>
		virtual HRESULT STDMETHODCALLTYPE CreateColor(
			__in UINT32 Color,
			__out IFW1ColorRGBA **ppColor
		) = 0;
};

#ifdef FW1_COMPILETODLL
	extern "C" __declspec(dllexport) HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#else
	/// <summary>The FW1CreateFactory method creates an IFWFactory object, that can subsequently be used to create any and all FW1 objects.</summary>
	/// <remarks></remarks>
	/// <returns>Standard HRESULT error code.</returns>
	/// <param name="Version">Set to FW1_VERSION. Is used to make sure the header matches the library version.</param>
	/// <param name="ppFactory">Address of a pointer to an IFW1Factory.</param>
	extern "C" HRESULT STDMETHODCALLTYPE FW1CreateFactory(
		__in UINT32 Version,
		__out IFW1Factory **ppFactory
	);
#endif

typedef HRESULT (STDMETHODCALLTYPE * PFN_FW1CREATEFACTORY) (UINT32 Version, IFW1Factory **ppFactory);


#endif// IncludeGuard__FW1_FW1FontWrapper_h

```

`dwmhook/FW1/FW1Precompiled.cpp`:

```cpp
// FW1Precompiled.cpp

#include "FW1Precompiled.h"


```

`dwmhook/FW1/FW1Precompiled.h`:

```h
// FW1Precompiled.h

#ifndef IncludeGuard__FW1_FW1Precompiled_h
#define IncludeGuard__FW1_FW1Precompiled_h


#define NOMINMAX
#include <D3D11.h>
#include <D3DCompiler.h>
#include <DWrite.h>
#include <intrin.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <cfloat>
#include <cmath>
#include <algorithm>

#include "FW1CompileSettings.h"
#include "FW1FontWrapper.h"


#endif// IncludeGuard__FW1_FW1Precompiled_h

```

`dwmhook/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`dwmhook/ck.h`:

```h
#pragma once

#pragma warning(push, 3)
//
//#define NTDDI_VERSION (0x0A000000) // Windows 10 1507 "Threshold"
//#define _WIN32_WINNT (0x0A00)
//#define WINVER (0x0A00)
//
//#define WIN32_LEAN_AND_MEAN
//#define NOMINMAX

#include <windows.h>
//#include <winternl.h>
#include <process.h>
#include <tlhelp32.h>
#include <dbghelp.h>
#include <assert.h>

#include <ole2.h>
#include <olectl.h>
#include <tchar.h>

#include <dwmapi.h>
#include <d3d11.h>

#include <stdint.h>
#include <stdio.h>
#include <math.h>

#include <stdexcept>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <unordered_map>
#include <algorithm>

#include <atomic>
#include <mutex>
#include <thread>

#pragma warning(pop)

//
// BASIC
//

#define CK_TRACE_INFO ck_printf
#define CK_TRACE_ERROR ck_printf
#define CK_OutputDebugStringA OutputDebugStringA

#define CK_ASSERT(Cond) if (!(Cond)) { CK_TRACE_ERROR("FAIL at FILE:%s LINE:%d", __FILE__, __LINE__); /*__debugbreak();*/ }
#define CK_GUARD_RET(Cond, RetValue) if (!(Cond)) { CK_ASSERT(false); return (RetValue); }
#define CK_GUARD_BRK(Cond) if (!(Cond)) { CK_ASSERT(false); break; }

#define CK_INVALID_PID (DWORD)-1

inline void ck_printf( const char* Format, ... )
{
	char Buf[ 1024 ] = { 0 };
	va_list Args;
	va_start( Args, Format );
	const int Count = vsnprintf_s( Buf, _countof( Buf ) - 1, _TRUNCATE, Format, Args );
	va_end( Args );
	OutputDebugStringA( Buf );
}

//
// HANDLE
//

template<typename T>
inline void SafeDelete( T*& Ptr ) { if ( Ptr ) { delete Ptr; Ptr = NULL; } }

template<typename T>
inline void SafeReleaseCom( T*& Ptr ) { if ( Ptr ) { Ptr->Release(); Ptr = NULL; } }

inline bool IsHandleValid( PVOID Handle ) { return ( Handle != NULL && Handle != INVALID_HANDLE_VALUE ); }

template<typename T, typename Traits>
class TScopedHandle
{
public:
	T Handle;

	inline TScopedHandle() : Handle( NULL ) {}
	inline explicit TScopedHandle( T h ) : Handle( h ) {}
	inline TScopedHandle( TScopedHandle& other ) { Handle = other.Handle; other.Handle = NULL; }

	inline ~TScopedHandle() { Close(); }
	inline void Close() { Traits::Close( Handle ); }

	inline T& operator*() { return Handle; }
	inline T* operator&() { return &Handle; }

	inline const T& operator*() const { return Handle; }
	inline const T* operator&() const { return &Handle; }

	inline T& operator->() { return Handle; }

	inline TScopedHandle& operator=( T h ) { Close(); Handle = h; return *this; }
	inline TScopedHandle& operator=( TScopedHandle& other ) { Close(); Handle = other.Handle; other.Handle = NULL; return *this; }

	inline operator bool() const { return IsHandleValid( Handle ); }
};

struct HANDLE_traits { static void Close( HANDLE& Value ) { if ( IsHandleValid( Value ) ) { ::CloseHandle( Value ); Value = NULL; } } };
struct HKEY_traits { static void Close( HKEY& Value ) { if ( IsHandleValid( Value ) ) { ::RegCloseKey( Value ); Value = NULL; } } };
struct SC_HANDLE_traits { static void Close( SC_HANDLE& Value ) { if ( IsHandleValid( Value ) ) { ::CloseServiceHandle( Value ); Value = NULL; } } };
struct COM_traits { template<typename T> static void Close( T*& Value ) { if ( Value ) { Value->Release(); Value = NULL; } } };

typedef TScopedHandle<HANDLE, HANDLE_traits> CkScopedHandle;
typedef TScopedHandle<HKEY, HKEY_traits> CkScopedRegKey;
typedef TScopedHandle<SC_HANDLE, SC_HANDLE_traits> CkScopedServiceHandle;

//
// STRING
//

inline const char* operator* ( const std::string& s ) { return s.c_str(); }
inline const wchar_t* operator* ( const std::wstring& s ) { return s.c_str(); }

inline bool ck_strw( const std::string& s, std::wstring& out )
{
	out.clear();
	const auto slen = s.length(); CK_GUARD_RET( slen > 0, false );
	int n = MultiByteToWideChar( CP_ACP, 0, s.c_str(), ( int )slen, NULL, 0 ); CK_GUARD_RET( n > 0, false );
	out.resize( n, 0 );
	n = MultiByteToWideChar( CP_ACP, 0, s.c_str(), ( int )slen, &out[ 0 ], n ); CK_GUARD_RET( n > 0, false );
	return true;
}

inline bool ck_stra( const std::wstring& s, std::string& out )
{
	out.clear();
	const auto slen = s.length(); CK_GUARD_RET( slen > 0, false );
	int n = WideCharToMultiByte( CP_ACP, 0, s.c_str(), ( int )slen, 0, 0, 0, 0 ); CK_GUARD_RET( n > 0, false );
	out.resize( n, 0 );
	n = WideCharToMultiByte( CP_ACP, 0, s.c_str(), ( int )slen, &out[ 0 ], n, 0, 0 ); CK_GUARD_RET( n > 0, false );
	return true;
}

inline std::wstring ck_strw( const std::string& s )
{
	std::wstring r;
	ck_strw( s, r );
	return r;
}

inline std::string ck_stra( const std::wstring& s )
{
	std::string r;
	ck_stra( s, r );
	return r;
}

//
// COMMON
//

inline std::wstring CkExtractFileName( LPCWSTR Path )
{
	std::wstring Res;
	const int Len = ( int )wcslen( Path );
	for ( int i = Len - 1; i > 0; --i )
	{
		if ( Path[ i ] == L'\\' || Path[ i ] == L'/' )
		{
			Res.assign( Path + i + 1 );
			break;
		}
	}
	return Res;
}

inline std::wstring CkExtractFilePath( LPCWSTR Path )
{
	std::wstring Res;
	const int Len = ( int )wcslen( Path );
	for ( int i = Len - 1; i > 0; --i )
	{
		if ( Path[ i ] == L'\\' || Path[ i ] == L'/' )
		{
			Res.assign( Path, i + 1 );
			break;
		}
	}
	return Res;
}

inline std::wstring CkGetModulePath( HMODULE Module )
{
	CK_GUARD_RET( Module, L"" );

	wchar_t Buffer[ MAX_PATH ];
	CK_GUARD_RET( GetModuleFileNameW( Module, Buffer, _countof( Buffer ) - 1 ), L"" );

	return CkExtractFilePath( Buffer );
}

inline DWORD CkGetPidByName( LPCWSTR ProcName )
{
	DWORD Pid = CK_INVALID_PID;

	CK_GUARD_RET( ProcName, Pid );

	CkScopedHandle Snapshot( CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 ) );
	CK_GUARD_RET( Snapshot, Pid );

	PROCESSENTRY32W Entry;
	ZeroMemory( &Entry, sizeof( Entry ) );
	Entry.dwSize = sizeof( Entry );

	if ( Process32FirstW( Snapshot.Handle, &Entry ) )
	{
		do
		{
			if ( _wcsicmp( Entry.szExeFile, ProcName ) == 0 )
			{
				Pid = Entry.th32ProcessID;
				break;
			}
		} while ( Process32NextW( Snapshot.Handle, &Entry ) );
	}

	return Pid;
}

inline BOOL CkAdjustPrivilege( LPCSTR PrivilegeName, BOOL Enable )
{
	CK_GUARD_RET( PrivilegeName, FALSE );

	TOKEN_PRIVILEGES Privilege;
	ZeroMemory( &Privilege, sizeof( Privilege ) );
	Privilege.PrivilegeCount = 1;
	Privilege.Privileges[ 0 ].Attributes = ( Enable ? SE_PRIVILEGE_ENABLED : 0 );

	std::wstring NameW( ck_strw( PrivilegeName ) );
	CK_GUARD_RET( LookupPrivilegeValueW( NULL, *NameW, &Privilege.Privileges[ 0 ].Luid ), FALSE );

	CkScopedHandle Token;
	CK_GUARD_RET( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &Token ), FALSE );

	CK_GUARD_RET( AdjustTokenPrivileges( *Token, FALSE, &Privilege, sizeof( Privilege ), NULL, NULL ), FALSE );

	return TRUE;
}

//
// PATTERN
//

inline uint8_t CkParseHex( uint8_t Val )
{
	if ( Val >= '0' && Val <= '9' ) return ( Val - '0' );
	if ( Val >= 'a' && Val <= 'f' ) return ( Val - 'a' ) + 10;
	if ( Val >= 'A' && Val <= 'F' ) return ( Val - 'A' ) + 10;
	return 0;
}

inline uint8_t CkParseByte( const char* Str )
{
	uint8_t hi = CkParseHex( ( uint8_t )Str[ 0 ] );
	uint8_t lo = CkParseHex( ( uint8_t )Str[ 1 ] );
	return ( ( hi << 4 ) | lo );
}

inline std::vector<uint8_t> CkParseByteArray( const char* Str )
{
	std::vector<uint8_t> Result;
	if ( Str )
	{
		const size_t Len = strlen( Str );
		if ( Len )
		{
			std::vector<uint8_t> Tmp;
			Tmp.reserve( Len );

			for ( size_t i = 0; i < Len; i++ )
			{
				if ( isalnum( Str[ i ] ) )
					Tmp.push_back( Str[ i ] );
			}

			const size_t NumBytes = Tmp.size() / 2;
			if ( NumBytes )
			{
				Result.resize( NumBytes );
				for ( size_t i = 0; i < NumBytes; i++ )
				{
					uint8_t hi = CkParseHex( Tmp[ i * 2 ] );
					uint8_t lo = CkParseHex( Tmp[ ( i * 2 ) + 1 ] );
					Result[ i ] = ( ( hi << 4 ) | lo );
				}
			}
		}
	}
	return Result;
}

template<const uint8_t Wildcard>
struct CkWildcard
{
	inline bool operator()( const uint8_t& a, const uint8_t& b ) const
	{
		return ( a == b || b == Wildcard );
	}
};

typedef CkWildcard<0xCC> CkWildcardCC; // Interrupt Type 3
typedef CkWildcard<0xCE> CkWildcardCE; // Interrupt if Overflow

#define CK_PAGE_EXECUTE_RWC (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

template<typename TCompare>
inline std::vector<uint8_t*> CkFindPatternIntern( const std::vector<uint8_t>& Pattern, size_t Limit )
{
	std::vector<uint8_t*> Result;

	SYSTEM_INFO SysInfo;
	ZeroMemory( &SysInfo, sizeof( SysInfo ) );
	GetSystemInfo( &SysInfo );

	uint8_t* MaxAddress = ( uint8_t* )SysInfo.lpMaximumApplicationAddress;
	uint8_t* Ptr = ( uint8_t* )SysInfo.lpMinimumApplicationAddress;

	HANDLE Process = GetCurrentProcess();
	TCompare Compare;

	while ( Ptr < MaxAddress )
	{
		MEMORY_BASIC_INFORMATION MemInfo;
		if ( !VirtualQueryEx( Process, Ptr, &MemInfo, sizeof( MemInfo ) ) )
		{
			CK_TRACE_ERROR( "VirtualQueryEx failed at %p (Err=0x%X)", Ptr, GetLastError() );
			break;
		}

		if ( ( MemInfo.Protect & CK_PAGE_EXECUTE_RWC ) && ( ( MemInfo.Protect & PAGE_GUARD ) == 0 ) && ( ( MemInfo.Protect & PAGE_NOACCESS ) == 0 ) )
		{
			uint8_t* RegionPos = ( uint8_t* )MemInfo.BaseAddress;
			uint8_t* RegionEnd = RegionPos + MemInfo.RegionSize;

			//CK_TRACE_INFO("Scan %p .. %p (0x%X)", RegionPos, RegionEnd, (UINT)MemInfo.RegionSize);

			while ( ( RegionPos = std::search( RegionPos, RegionEnd, Pattern.begin(), Pattern.end(), Compare ) ) != RegionEnd )
			{
				//CK_TRACE_INFO("Found pattern at %p", RegionPos);

				Result.push_back( RegionPos );

				if ( Limit && Result.size() >= Limit )
					return Result;

				RegionPos++;
			}
		}

		Ptr += MemInfo.RegionSize;
	}

	return Result;
}

inline BOOL CkProtectWriteMemory( HANDLE Process, const std::vector<uint8_t>& Data, PVOID Addr, SIZE_T Offset )
{
	DWORD Prot = 0;
	CK_GUARD_RET( VirtualProtectEx( Process, Addr, Data.size(), PAGE_EXECUTE_READWRITE, &Prot ), FALSE );

	//SIZE_T IoSize = 0;
	//CK_GUARD_RET(WriteProcessMemory(Process, (PVOID)((UINT64)Addr + (UINT64)Offset), &PatchBytes[0], PatchBytes.size(), &IoSize), FALSE);

	memcpy( ( PVOID )( ( UINT64 )Addr + ( UINT64 )Offset ), &Data[ 0 ], Data.size() );

	DWORD Prot2 = 0;
	VirtualProtectEx( Process, Addr, Data.size(), Prot, &Prot2 );

	return TRUE;
}

```

`dwmhook/dwmhook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{BF574599-3CE2-4360-B229-D747272D45CF}</ProjectGuid>
    <RootNamespace>dwmhook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>Full</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FW1\CFW1ColorRGBA.cpp" />
    <ClCompile Include="FW1\CFW1ColorRGBAInterface.cpp" />
    <ClCompile Include="FW1\CFW1DWriteRenderTarget.cpp" />
    <ClCompile Include="FW1\CFW1DWriteRenderTargetInterface.cpp" />
    <ClCompile Include="FW1\CFW1Factory.cpp" />
    <ClCompile Include="FW1\CFW1FactoryInterface.cpp" />
    <ClCompile Include="FW1\CFW1FontWrapper.cpp" />
    <ClCompile Include="FW1\CFW1FontWrapperInterface.cpp" />
    <ClCompile Include="FW1\CFW1GlyphAtlas.cpp" />
    <ClCompile Include="FW1\CFW1GlyphAtlasInterface.cpp" />
    <ClCompile Include="FW1\CFW1GlyphProvider.cpp" />
    <ClCompile Include="FW1\CFW1GlyphProviderInterface.cpp" />
    <ClCompile Include="FW1\CFW1GlyphRenderStates.cpp" />
    <ClCompile Include="FW1\CFW1GlyphRenderStatesInterface.cpp" />
    <ClCompile Include="FW1\CFW1GlyphSheet.cpp" />
    <ClCompile Include="FW1\CFW1GlyphSheetInterface.cpp" />
    <ClCompile Include="FW1\CFW1GlyphVertexDrawer.cpp" />
    <ClCompile Include="FW1\CFW1GlyphVertexDrawerInterface.cpp" />
    <ClCompile Include="FW1\CFW1StateSaver.cpp" />
    <ClCompile Include="FW1\CFW1TextGeometry.cpp" />
    <ClCompile Include="FW1\CFW1TextGeometryInterface.cpp" />
    <ClCompile Include="FW1\CFW1TextRenderer.cpp" />
    <ClCompile Include="FW1\CFW1TextRendererInterface.cpp" />
    <ClCompile Include="FW1\FW1FontWrapper.cpp" />
    <ClCompile Include="FW1\FW1Precompiled.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="render.cpp" />
    <ClCompile Include="save_state.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ck.h" />
    <ClInclude Include="FW1\CFW1ColorRGBA.h" />
    <ClInclude Include="FW1\CFW1DWriteRenderTarget.h" />
    <ClInclude Include="FW1\CFW1Factory.h" />
    <ClInclude Include="FW1\CFW1FontWrapper.h" />
    <ClInclude Include="FW1\CFW1GlyphAtlas.h" />
    <ClInclude Include="FW1\CFW1GlyphProvider.h" />
    <ClInclude Include="FW1\CFW1GlyphRenderStates.h" />
    <ClInclude Include="FW1\CFW1GlyphSheet.h" />
    <ClInclude Include="FW1\CFW1GlyphVertexDrawer.h" />
    <ClInclude Include="FW1\CFW1Object.h" />
    <ClInclude Include="FW1\CFW1StateSaver.h" />
    <ClInclude Include="FW1\CFW1TextGeometry.h" />
    <ClInclude Include="FW1\CFW1TextRenderer.h" />
    <ClInclude Include="FW1\FW1CompileSettings.h" />
    <ClInclude Include="FW1\FW1FontWrapper.h" />
    <ClInclude Include="FW1\FW1Precompiled.h" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="render.hpp" />
    <ClInclude Include="save_state.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dwmhook/dwmhook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\FW1">
      <UniqueIdentifier>{7989d646-c2e6-4bbb-8e6c-22be8b25e22b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="render.cpp">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="save_state.cpp">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1ColorRGBA.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1ColorRGBAInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1DWriteRenderTarget.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1DWriteRenderTargetInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1Factory.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1FactoryInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1FontWrapper.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1FontWrapperInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphAtlas.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphAtlasInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphProvider.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphProviderInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphRenderStates.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphRenderStatesInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphSheet.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphSheetInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphVertexDrawer.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1GlyphVertexDrawerInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1StateSaver.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1TextGeometry.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1TextGeometryInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1TextRenderer.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\CFW1TextRendererInterface.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\FW1FontWrapper.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
    <ClCompile Include="FW1\FW1Precompiled.cpp">
      <Filter>Header Files\FW1</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="render.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="save_state.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1ColorRGBA.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1DWriteRenderTarget.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1Factory.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1FontWrapper.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1GlyphAtlas.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1GlyphProvider.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1GlyphRenderStates.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1GlyphSheet.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1GlyphVertexDrawer.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1Object.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1StateSaver.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1TextGeometry.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\CFW1TextRenderer.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\FW1CompileSettings.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\FW1FontWrapper.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="FW1\FW1Precompiled.h">
      <Filter>Header Files\FW1</Filter>
    </ClInclude>
    <ClInclude Include="ck.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`dwmhook/includes.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <cstdio>
#include <Psapi.h>
#include <process.h>
#include <d3d11.h>
#include <dxgi.h>
#include <d3d11_1.h>
#include <intrin.h>
#include <d2d1_1.h>
#include <d2d1_2.h>
#include <d2d1_3.h>
#include <d3d11_2.h>
#include <d2d1_3helper.h>
#include <dwrite_3.h>
#include <dcomp.h>
#include <d3d11_1.h>
#include <DirectXMath.h>
#include <DirectXPackedVector.h>
#include <d3dcompiler.h>

using namespace DirectX;

#pragma comment( lib, "dxgi" )
#pragma comment( lib, "d2d1" )
#pragma comment( lib, "d3d11" )
#pragma comment( lib, "dcomp" )
#pragma comment( lib, "dwrite" )
#ifdef _DEBUG
#pragma comment( lib, "minhook-debug.lib" )
#else
#pragma comment( lib, "minhook.lib" )
#endif
#pragma comment( lib, "d3dcompiler.lib" )

#define SAFE_RELEASE( p )	if( p ) { p->Release(); p = nullptr; }
#define LOG_FILE_PATH		"C:\\DWM_GAY.log"

#include "MinHook.h"
#include "save_state.hpp"
```

`dwmhook/main.cpp`:

```cpp
#include "includes.hpp"
#include "render.hpp"

ID3D11Device* pD3DXDevice = nullptr;
ID3D11DeviceContext* pD3DXDeviceCtx = nullptr;
ID3D11Texture2D* pBackBuffer = nullptr;
ID3D11RenderTargetView* pRenderTarget = nullptr;

IFW1Factory* pFontFactory = nullptr;
IFW1FontWrapper* pFontWrapper = nullptr;

BOOL bDataCompare( const BYTE* pData, const BYTE* bMask, const char* szMask )
{
	for ( ; *szMask; ++szMask, ++pData, ++bMask )
	{
		if ( *szMask == 'x' && *pData != *bMask )
			return FALSE;
	}
	return ( *szMask ) == NULL;
}

DWORD64 FindPattern( const char* szModule, BYTE* bMask, const char* szMask )
{
	MODULEINFO mi{ };
	GetModuleInformation( GetCurrentProcess(), GetModuleHandleA( szModule ), &mi, sizeof( mi ) );

	DWORD64 dwBaseAddress = DWORD64( mi.lpBaseOfDll );
	const auto dwModuleSize = mi.SizeOfImage;

	for ( auto i = 0ul; i < dwModuleSize; i++ )
	{
		if ( bDataCompare( PBYTE( dwBaseAddress + i ), bMask, szMask ) )
			return DWORD64( dwBaseAddress + i );
	}
	return NULL;
}

void AddToLog( const char* fmt, ... )
{
	/*
	va_list va;
	va_start( va, fmt );

	char buff[ 1024 ]{ };
	vsnprintf_s( buff, sizeof( buff ), fmt, va );

	va_end( va );

	FILE* f = nullptr;
	fopen_s( &f, LOG_FILE_PATH, "a" );

	if ( !f )
	{
		char szDst[ 256 ];
		sprintf_s( szDst, "Failed to create file %d", GetLastError() );
		MessageBoxA( 0, szDst, 0, 0 );
		return;
	}

	OutputDebugStringA( buff );
	fprintf_s( f, buff );
	fclose( f );
	*/
}

void DrawEverything( IDXGISwapChain* pDxgiSwapChain )
{
	static bool b = true;
	if ( b )
	{
		pDxgiSwapChain->GetDevice( __uuidof( ID3D11Device ), ( void** )&pD3DXDevice );
		pDxgiSwapChain->AddRef();
		pD3DXDevice->GetImmediateContext( &pD3DXDeviceCtx );

		pDxgiSwapChain->GetBuffer( 0, __uuidof( ID3D11Texture2D ), ( LPVOID* )&backbuffer_ptr );
		pD3DXDevice->CreateRenderTargetView( *backbuffer_ptr, NULL, &rtview_ptr );

		D3D11_RASTERIZER_DESC raster_desc;
		ZeroMemory( &raster_desc, sizeof( raster_desc ) );
		raster_desc.FillMode = D3D11_FILL_SOLID; // D3D11_FILL_WIREFRAME;
		raster_desc.CullMode = D3D11_CULL_BACK; //D3D11_CULL_NONE;
		pD3DXDevice->CreateRasterizerState( &raster_desc, &rasterizer_state_ov );

		// shader

		D3D_SHADER_MACRO shader_macro[] = { NULL, NULL };
		ID3DBlob* vs_blob_ptr = NULL, * ps_blob_ptr = NULL, * error_blob = NULL;

		D3DCompile( shader_code, strlen( shader_code ), NULL, shader_macro, NULL, "VS", "vs_4_0", 0, 0, &vs_blob_ptr, &error_blob );
		D3DCompile( shader_code, strlen( shader_code ), NULL, shader_macro, NULL, "PS", "ps_4_0", 0, 0, &ps_blob_ptr, &error_blob );

		pD3DXDevice->CreateVertexShader( vs_blob_ptr->GetBufferPointer(), vs_blob_ptr->GetBufferSize(), NULL, &vertex_shader_ptr );
		pD3DXDevice->CreatePixelShader( ps_blob_ptr->GetBufferPointer(), ps_blob_ptr->GetBufferSize(), NULL, &pixel_shader_ptr );

		// layout

		D3D11_INPUT_ELEMENT_DESC element_desc[] =
		{
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		};

		pD3DXDevice->CreateInputLayout( element_desc, ARRAYSIZE( element_desc ), vs_blob_ptr->GetBufferPointer(), vs_blob_ptr->GetBufferSize(), &input_layout_ptr );

		// buffers

		SimpleVertex vertices[] =
		{
			{ XMFLOAT3( -1.0f, 1.0f, -1.0f ), XMFLOAT4( 0.0f, 0.0f, 1.0f, 1.0f ) },
			{ XMFLOAT3( 1.0f, 1.0f, -1.0f ), XMFLOAT4( 0.0f, 1.0f, 0.0f, 1.0f ) },
			{ XMFLOAT3( 1.0f, 1.0f, 1.0f ), XMFLOAT4( 0.0f, 1.0f, 1.0f, 1.0f ) },
			{ XMFLOAT3( -1.0f, 1.0f, 1.0f ), XMFLOAT4( 1.0f, 0.0f, 0.0f, 1.0f ) },
			{ XMFLOAT3( -1.0f, -1.0f, -1.0f ), XMFLOAT4( 1.0f, 0.0f, 1.0f, 1.0f ) },
			{ XMFLOAT3( 1.0f, -1.0f, -1.0f ), XMFLOAT4( 1.0f, 1.0f, 0.0f, 1.0f ) },
			{ XMFLOAT3( 1.0f, -1.0f, 1.0f ), XMFLOAT4( 1.0f, 1.0f, 1.0f, 1.0f ) },
			{ XMFLOAT3( -1.0f, -1.0f, 1.0f ), XMFLOAT4( 0.0f, 0.0f, 0.0f, 1.0f ) },
		};

		WORD indices[] =
		{
			3,1,0,
			2,1,3,

			0,5,4,
			1,5,0,

			3,4,7,
			0,4,3,

			1,6,5,
			2,6,1,

			2,7,6,
			3,7,2,

			6,4,5,
			7,4,6,
		};

		D3D11_BUFFER_DESC bd = {};
		D3D11_SUBRESOURCE_DATA data = {};

		bd.Usage = D3D11_USAGE_DEFAULT;
		bd.ByteWidth = sizeof( SimpleVertex ) * 8;
		bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		bd.CPUAccessFlags = 0;
		data.pSysMem = vertices;
		pD3DXDevice->CreateBuffer( &bd, &data, &vertex_buffer_ptr );

		bd.Usage = D3D11_USAGE_DEFAULT;
		bd.ByteWidth = sizeof( WORD ) * 36;
		bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
		bd.CPUAccessFlags = 0;
		data.pSysMem = indices;
		pD3DXDevice->CreateBuffer( &bd, &data, &index_buffer_ptr );

		bd.Usage = D3D11_USAGE_DEFAULT;
		bd.ByteWidth = sizeof( ConstantBuffer );
		bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		bd.CPUAccessFlags = 0;
		pD3DXDevice->CreateBuffer( &bd, NULL, &const_buffer_ptr );

		t0 = GetTickCount64();

		FW1CreateFactory( FW1_VERSION, &pFontFactory );
		pFontFactory->CreateFontWrapper( pD3DXDevice, L"Arial", &pFontWrapper );
		SAFE_RELEASE( pFontFactory );

		render.Initialize( pFontWrapper );

		b = false;
	}
	else
	{
		fix_renderstate();

		render.BeginScene();
		render.FillRect( 10.f, 10.f, 100.f, 100.f, 0xFFFF1010 );
		render.OutlineRect( 9.f, 9.f, 501.f, 501.f, -1 );
		render.DrawLine( XMFLOAT2( 10.f, 50.f ), XMFLOAT2( 25.f, 75.f ), -1 );
		render.RenderText( L"she been bouncing on my lap lap lap", 10.f, 10.f, -1, false, false );
		render.RenderText ( L"we are obama gaming.", 10.f, 50.f, -1, false, true );

		render.RenderText(L"catjpg on top", 700.f, 600.f, 0xFFFFFFFF, false, true);
		render.EndScene();
	}
}

using PresentMPO_ = __int64( __fastcall* )( void*, IDXGISwapChain*, unsigned int, unsigned int, int, __int64, __int64, int );
PresentMPO_ oPresentMPO = NULL;

__int64 __fastcall hkPresentMPO( void* thisptr, IDXGISwapChain* pDxgiSwapChain, unsigned int a3, unsigned int a4, int a5, __int64 a6, __int64 a7, int a8 )
{
	DrawEverything( pDxgiSwapChain );
	return oPresentMPO( thisptr, pDxgiSwapChain, a3, a4, a5, a6, a7, a8 );
}

using PresentDWM_ = __int64( __fastcall* )( void*, IDXGISwapChain*, unsigned int, unsigned int, const struct tagRECT*, unsigned int, const struct DXGI_SCROLL_RECT*, unsigned int, struct IDXGIResource*, unsigned int );
PresentDWM_ oPresentDWM = NULL;

__int64 __fastcall hkPresentDWM( void* thisptr, IDXGISwapChain* pDxgiSwapChain, unsigned int a3, unsigned int a4, const struct tagRECT* a5, unsigned int a6, const struct DXGI_SCROLL_RECT* a7, unsigned int a8, struct IDXGIResource* a9, unsigned int a10 )
{
	DrawEverything( pDxgiSwapChain );
	return oPresentDWM( thisptr, pDxgiSwapChain, a3, a4, a5, a6, a7, a8, a9, a10 );
}

UINT WINAPI MainThread( PVOID )
{
	MH_Initialize();

	while ( !GetModuleHandleA( "dwmcore.dll" ) )
		Sleep( 150 );

	//
	// [ E8 ? ? ? ? ] the relative addr will be converted to absolute addr
	auto ResolveCall = []( DWORD_PTR sig )
	{
		return sig = sig + *reinterpret_cast< PULONG >( sig + 1 ) + 5;
	};

	//
	// [ 48 8D 05 ? ? ? ? ] the relative addr will be converted to absolute addr
	auto ResolveRelative = []( DWORD_PTR sig )
	{
		return sig = sig + *reinterpret_cast< PULONG >( sig + 0x3 ) + 0x7;
	};

	auto dwRender = FindPattern( "d2d1.dll", PBYTE( "\x48\x8D\x05\x00\x00\x00\x00\x33\xED\x48\x8D\x71\x08" ), "xxx????xxxxxx" );

	if ( dwRender )
	{
		dwRender = ResolveRelative( dwRender );

		PDWORD_PTR Vtbl = PDWORD_PTR( dwRender );

		AddToLog( "table 0x%llx\n", dwRender );

		MH_CreateHook( PVOID( Vtbl[ 6 ] ), PVOID( &hkPresentDWM ), reinterpret_cast< PVOID* >( &oPresentDWM ) );
		MH_CreateHook( PVOID( Vtbl[ 7 ] ), PVOID( &hkPresentMPO ), reinterpret_cast< PVOID* >( &oPresentMPO ) );
		MH_EnableHook( MH_ALL_HOOKS );

		AddToLog( "hooked!\n" );
	}

	return 0;
}

BOOL WINAPI DllMain( HMODULE hDll, DWORD dwReason, PVOID )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		DeleteFileA( LOG_FILE_PATH );
		_beginthreadex( nullptr, NULL, MainThread, nullptr, NULL, nullptr );
	}
	return true;
}
```

`dwmhook/render.cpp`:

```cpp
#include "includes.hpp"
#include "render.hpp"

CRender2D render;

static char D3D11FillShader[] =
"struct VSOut"
"{"
"	float4 Col : COLOR;"
"	float4 Pos : SV_POSITION;"
"};"

"VSOut VS(float4 Col : COLOR, float4 Pos : POSITION)"
"{"
"	VSOut Output;"
"	Output.Pos = Pos;"
"	Output.Col = Col;"
"	return Output;"
"}"

"float4 PS(float4 Col : COLOR) : SV_TARGET"
"{"
"	return Col;"
"}";

bool CRender2D::Initialize( IFW1FontWrapper* pFontWrapper )
{
	HRESULT hr;

	if ( !pD3DXDevice )
		return false;

	if ( !pD3DXDeviceCtx )
		return false;

	if ( pFontWrapper )
		this->font = pFontWrapper;

	ID3DBlob* VS, * PS;
	hr = D3DCompile( D3D11FillShader, sizeof( D3D11FillShader ), NULL, NULL, NULL, "VS", "vs_4_0", 0, 0, &VS, NULL );
	if ( FAILED( hr ) )
		return false;

	hr = pD3DXDevice->CreateVertexShader( VS->GetBufferPointer(), VS->GetBufferSize(), NULL, &this->mVS );
	if ( FAILED( hr ) )
	{
		SAFE_RELEASE( VS );
		return false;
	}

	D3D11_INPUT_ELEMENT_DESC layout[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
	};

	hr = pD3DXDevice->CreateInputLayout( layout, ARRAYSIZE( layout ), VS->GetBufferPointer(), VS->GetBufferSize(), &this->mInputLayout );
	SAFE_RELEASE( VS );
	if ( FAILED( hr ) )
		return false;

	D3DCompile( D3D11FillShader, sizeof( D3D11FillShader ), NULL, NULL, NULL, "PS", "ps_4_0", 0, 0, &PS, NULL );
	if ( FAILED( hr ) )
		return false;

	hr = pD3DXDevice->CreatePixelShader( PS->GetBufferPointer(), PS->GetBufferSize(), NULL, &this->mPS );
	if ( FAILED( hr ) )
	{
		SAFE_RELEASE( PS );
		return false;
	}

	D3D11_BUFFER_DESC bufferDesc{ };
	bufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	bufferDesc.ByteWidth = 4 * sizeof( COLOR_VERTEX );
	bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	bufferDesc.MiscFlags = 0;

	hr = pD3DXDevice->CreateBuffer( &bufferDesc, NULL, &this->mVertexBuffer );
	if ( FAILED( hr ) )
		return false;

	D3D11_BLEND_DESC blendStateDescription{ };
	blendStateDescription.RenderTarget[ 0 ].BlendEnable = TRUE;
	blendStateDescription.RenderTarget[ 0 ].SrcBlend = D3D11_BLEND_SRC_ALPHA;
	blendStateDescription.RenderTarget[ 0 ].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDescription.RenderTarget[ 0 ].BlendOp = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[ 0 ].SrcBlendAlpha = D3D11_BLEND_ONE;
	blendStateDescription.RenderTarget[ 0 ].DestBlendAlpha = D3D11_BLEND_ZERO;
	blendStateDescription.RenderTarget[ 0 ].BlendOpAlpha = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[ 0 ].RenderTargetWriteMask = 0x0f;

	hr = pD3DXDevice->CreateBlendState( &blendStateDescription, &this->transparency );
	if ( FAILED( hr ) )
		return false;

	return true;
}

void CRender2D::FillRect( float x, float y, float w, float h, ULONG color )
{
	if ( pD3DXDeviceCtx == NULL )
		return;

	auto a = ( ( color >> 24 ) & 255 );
	auto r = ( ( color >> 16 ) & 255 );
	auto g = ( ( color >> 12 ) & 255 );
	auto b = ( color & 255 );

	UINT viewportNumber = 1;

	D3D11_VIEWPORT vp;

	pD3DXDeviceCtx->RSGetViewports( &viewportNumber, &vp );

	float x0 = x;
	float y0 = y;
	float x1 = x + w;
	float y1 = y + h;

	float xx0 = 2.0f * ( x0 - 0.5f ) / vp.Width - 1.0f;
	float yy0 = 1.0f - 2.0f * ( y0 - 0.5f ) / vp.Height;
	float xx1 = 2.0f * ( x1 - 0.5f ) / vp.Width - 1.0f;
	float yy1 = 1.0f - 2.0f * ( y1 - 0.5f ) / vp.Height;

	COLOR_VERTEX* v = NULL;
	D3D11_MAPPED_SUBRESOURCE mapData;

	if ( FAILED( pD3DXDeviceCtx->Map( this->mVertexBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &mapData ) ) )
		return;

	v = ( COLOR_VERTEX* )mapData.pData;

	v[ 0 ].Position.x = ( float )x0;
	v[ 0 ].Position.y = ( float )y0;
	v[ 0 ].Position.z = 0;
	v[ 0 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 1 ].Position.x = ( float )x1;
	v[ 1 ].Position.y = ( float )y1;
	v[ 1 ].Position.z = 0;
	v[ 1 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 0 ].Position.x = xx0;
	v[ 0 ].Position.y = yy0;
	v[ 0 ].Position.z = 0;
	v[ 0 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 1 ].Position.x = xx1;
	v[ 1 ].Position.y = yy0;
	v[ 1 ].Position.z = 0;
	v[ 1 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 2 ].Position.x = xx0;
	v[ 2 ].Position.y = yy1;
	v[ 2 ].Position.z = 0;
	v[ 2 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 3 ].Position.x = xx1;
	v[ 3 ].Position.y = yy1;
	v[ 3 ].Position.z = 0;
	v[ 3 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	pD3DXDeviceCtx->Unmap( this->mVertexBuffer, NULL );

	UINT Stride = sizeof( COLOR_VERTEX );
	UINT Offset = 0;

	pD3DXDeviceCtx->IASetVertexBuffers( 0, 1, &this->mVertexBuffer, &Stride, &Offset );
	pD3DXDeviceCtx->IASetPrimitiveTopology( D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP );
	pD3DXDeviceCtx->IASetInputLayout( this->mInputLayout );

	pD3DXDeviceCtx->VSSetShader( this->mVS, 0, 0 );
	pD3DXDeviceCtx->PSSetShader( this->mPS, 0, 0 );
	pD3DXDeviceCtx->GSSetShader( NULL, 0, 0 );
	pD3DXDeviceCtx->Draw( 4, 0 );
}

void CRender2D::OutlineRect( float x, float y, float w, float h, ULONG color )
{
	FillRect( x, ( y + h - 1 ), w, 1, color );
	FillRect( x, y, 1, h, color );
	FillRect( x, y, w, 1, color );
	FillRect( ( x + w - 1 ), y, 1, h, color );
}

void CRender2D::DrawLine( const XMFLOAT2& point_1, const XMFLOAT2& point_2, ULONG color )
{
	if ( pD3DXDeviceCtx == NULL )
		return;

	auto a = ( ( color >> 24 ) & 255 );
	auto r = ( ( color >> 16 ) & 255 );
	auto g = ( ( color >> 12 ) & 255 );
	auto b = ( color & 255 );

	float x1 = point_1.x;
	float x2 = point_2.x;

	float y1 = point_1.y;
	float y2 = point_2.y;

	UINT viewportNumber = 1;

	D3D11_VIEWPORT vp;

	pD3DXDeviceCtx->RSGetViewports( &viewportNumber, &vp );

	float xx0 = 2.0f * ( x1 - 0.5f ) / vp.Width - 1.0f;
	float yy0 = 1.0f - 2.0f * ( y1 - 0.5f ) / vp.Height;
	float xx1 = 2.0f * ( x2 - 0.5f ) / vp.Width - 1.0f;
	float yy1 = 1.0f - 2.0f * ( y2 - 0.5f ) / vp.Height;

	COLOR_VERTEX* v = NULL;

	D3D11_MAPPED_SUBRESOURCE mapData;

	if ( FAILED( pD3DXDeviceCtx->Map( this->mVertexBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &mapData ) ) )
		return;

	v = ( COLOR_VERTEX* )mapData.pData;

	v[ 0 ].Position.x = xx0;
	v[ 0 ].Position.y = yy0;

	v[ 0 ].Position.z = 0;
	v[ 0 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	v[ 1 ].Position.x = xx1;
	v[ 1 ].Position.y = yy1;
	v[ 1 ].Position.z = 0;
	v[ 1 ].Color = XMFLOAT4(
		( ( float )r / 255.0f ),
		( ( float )g / 255.0f ),
		( ( float )b / 255.0f ),
		( ( float )a / 255.0f ) );

	pD3DXDeviceCtx->Unmap( this->mVertexBuffer, NULL );

	UINT Stride = sizeof( COLOR_VERTEX );
	UINT Offset = 0;

	pD3DXDeviceCtx->IASetVertexBuffers( 0, 1, &this->mVertexBuffer, &Stride, &Offset );
	pD3DXDeviceCtx->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP );
	pD3DXDeviceCtx->IASetInputLayout( this->mInputLayout );

	pD3DXDeviceCtx->VSSetShader( this->mVS, 0, 0 );
	pD3DXDeviceCtx->PSSetShader( this->mPS, 0, 0 );
	pD3DXDeviceCtx->GSSetShader( NULL, 0, 0 );
	pD3DXDeviceCtx->Draw( 2, 0 );
}

void CRender2D::DrawHealthBar( float x, float y, float w, float health, float max )
{
	this->DrawHealthBar( x, y, w, 2, health, max );
}

void CRender2D::DrawHealthBar( float x, float y, float w, float h, float health, float max )
{
	/*if ( !max )
		return;

	if ( w < 5 )
		return;

	if ( health < 0 )
		health = 0;

	float ratio = health / max;

	ULONG col = ULONG( 0, ( BYTE )( 255 - 255 * ratio ), ( BYTE )( 255 * ratio ), 255 );

	float step = ( w / max );
	float draw = ( step * health );

	FillRect( x, y, w, h, ULONG( 0, 0, 0, 255 ) );
	FillRect( x, y, draw, h, col );*/
}

void CRender2D::RenderText( const wchar_t* txt, float x, float y, ULONG color, bool center, bool shadow )
{
	if ( !this->font )
		return;

	if ( center )
	{
		FW1_RECTF nullRect = { 0.f, 0.f, 0.f, 0.f };
		FW1_RECTF rect = this->font->MeasureString( txt, L"Arial", 17.0f, &nullRect, FW1_NOWORDWRAP );

		auto v = XMFLOAT2{ rect.Right, rect.Bottom };

		x -= v.x / 2.f;
	}

	if ( shadow )
	{
		this->font->DrawString( pD3DXDeviceCtx, txt, 17.0f, x - 1, y, 0xFF000000, FW1_RESTORESTATE );
		this->font->DrawString( pD3DXDeviceCtx, txt, 17.0f, x + 1, y, 0xFF000000, FW1_RESTORESTATE );
		this->font->DrawString( pD3DXDeviceCtx, txt, 17.0f, x, y - 1, 0xFF000000, FW1_RESTORESTATE );
		this->font->DrawString( pD3DXDeviceCtx, txt, 17.0f, x, y + 1, 0xFF000000, FW1_RESTORESTATE );
	}

	this->font->DrawString( pD3DXDeviceCtx, txt, 17.0f, x, y, color, FW1_RESTORESTATE );
}

void CRender2D::RenderText( const char* txt, float x, float y, ULONG color, bool center, bool shadow )
{
	auto cb = MultiByteToWideChar( CP_UTF8, 0, txt, -1, nullptr, NULL );

	wchar_t* wsText = new wchar_t[ cb + sizeof( wchar_t ) ];
	MultiByteToWideChar( CP_UTF8, 0, txt, -1, wsText, cb );

	this->RenderText( wsText, x, y, color, center, shadow );

	delete[] wsText;
}

void CRender2D::BeginScene()
{
	this->restoreState = false;

	if ( SUCCEEDED( this->stateSaver->saveCurrentState( pD3DXDeviceCtx ) ) )
		this->restoreState = true;

	float blendFactor[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	pD3DXDeviceCtx->OMSetBlendState( this->transparency, blendFactor, 0xffffffff );
	pD3DXDeviceCtx->IASetInputLayout( this->mInputLayout );
}

void CRender2D::EndScene()
{
	if ( this->restoreState )
		this->stateSaver->restoreSavedState();
}

void CRender2D::OnReset()
{
	SAFE_RELEASE( this->mVS );
	SAFE_RELEASE( this->mPS );
	SAFE_RELEASE( this->transparency );
	SAFE_RELEASE( this->mInputLayout );
	SAFE_RELEASE( this->mVertexBuffer );

	restoreState = false;
}
```

`dwmhook/render.hpp`:

```hpp
#pragma once

#include <DirectXMath.h>
using namespace DirectX;

extern ID3D11Device* pD3DXDevice;
extern ID3D11DeviceContext* pD3DXDeviceCtx;

#include "ck.h"
#include "FW1/FW1FontWrapper.h"
#include "save_state.hpp"

#define SAFE_RELEASE( p ) if( p ) { p->Release(); p = nullptr; }

static ULONGLONG t0 = 0;
static float accum = 0;

static TScopedHandle<ID3D11Texture2D*, COM_traits> backbuffer_ptr;
static TScopedHandle<ID3D11RenderTargetView*, COM_traits> rtview_ptr;
static TScopedHandle<ID3D11RasterizerState*, COM_traits> rasterizer_state;
static TScopedHandle<ID3D11RasterizerState*, COM_traits> rasterizer_state_ov;

static TScopedHandle<ID3D11VertexShader*, COM_traits> vertex_shader_ptr;
static TScopedHandle<ID3D11PixelShader*, COM_traits> pixel_shader_ptr;
static TScopedHandle<ID3D11InputLayout*, COM_traits> input_layout_ptr;
static TScopedHandle<ID3D11Buffer*, COM_traits> vertex_buffer_ptr;
static TScopedHandle<ID3D11Buffer*, COM_traits> index_buffer_ptr;
static TScopedHandle<ID3D11Buffer*, COM_traits> const_buffer_ptr;

#define STRINGIFY(X) #X

static const char* shader_code = STRINGIFY
(
	cbuffer ConstantBuffer : register( b0 )
{
	matrix World;
	matrix View;
	matrix Projection;
}
struct VS_OUTPUT
{
	float4 Pos : SV_POSITION;
	float4 Color : COLOR0;
};
VS_OUTPUT VS( float4 Pos : POSITION, float4 Color : COLOR )
{
	VS_OUTPUT output = ( VS_OUTPUT )0;
	output.Pos = mul( Pos, World );
	output.Pos = mul( output.Pos, View );
	output.Pos = mul( output.Pos, Projection );
	output.Color = Color;
	return output;
}
float4 PS( VS_OUTPUT input ) : SV_Target
{
	return input.Color;
}
);

struct SimpleVertex
{
	XMFLOAT3 Pos;
	XMFLOAT4 Color;
};

struct ConstantBuffer
{
	XMMATRIX mWorld;
	XMMATRIX mView;
	XMMATRIX mProjection;
};

inline void fix_renderstate()
{
	auto t1 = GetTickCount64();
	float dt = ( t1 - t0 ) * 0.001f;
	accum += dt;
	t0 = t1;

	D3D11_TEXTURE2D_DESC bb;
	ZeroMemory( &bb, sizeof( bb ) );
	backbuffer_ptr->GetDesc( &bb );

	XMMATRIX world = XMMatrixRotationY( accum );
	XMVECTOR eye = XMVectorSet( 0.0f, 1.0f, -5.0f, 0.0f );
	XMVECTOR at = XMVectorSet( 0.0f, 1.0f, 0.0f, 0.0f );
	XMVECTOR up = XMVectorSet( 0.0f, 1.0f, 0.0f, 0.0f );
	XMMATRIX view = XMMatrixLookAtLH( eye, at, up );
	XMMATRIX proj = XMMatrixPerspectiveFovLH( XM_PIDIV2, bb.Width / ( FLOAT )bb.Height, 0.01f, 100.0f );

	//float color[4] = { 0, 0, 0, 0 };
	//device_context_ptr->ClearRenderTargetView(*rtview_ptr, color);
	pD3DXDeviceCtx->OMSetRenderTargets( 1, &rtview_ptr, NULL );

	D3D11_VIEWPORT viewport = { 0.0f, 0.0f, ( float )bb.Width, ( float )bb.Height, 0.0f, 1.0f };
	pD3DXDeviceCtx->RSSetViewports( 1, &viewport );
	pD3DXDeviceCtx->RSSetState( *rasterizer_state_ov );

	pD3DXDeviceCtx->IASetInputLayout( *input_layout_ptr );
	pD3DXDeviceCtx->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );

	UINT stride = sizeof( SimpleVertex ), offset = 0;
	pD3DXDeviceCtx->IASetVertexBuffers( 0, 1, &vertex_buffer_ptr, &stride, &offset );
	pD3DXDeviceCtx->IASetIndexBuffer( *index_buffer_ptr, DXGI_FORMAT_R16_UINT, 0 );

	ConstantBuffer cb;
	cb.mWorld = XMMatrixTranspose( world );
	cb.mView = XMMatrixTranspose( view );
	cb.mProjection = XMMatrixTranspose( proj );
	pD3DXDeviceCtx->UpdateSubresource( *const_buffer_ptr, 0, NULL, &cb, 0, 0 );

	pD3DXDeviceCtx->VSSetShader( *vertex_shader_ptr, NULL, 0 );
	pD3DXDeviceCtx->VSSetConstantBuffers( 0, 1, &const_buffer_ptr );
	pD3DXDeviceCtx->PSSetShader( *pixel_shader_ptr, NULL, 0 );
	//pD3DXDeviceCtx->DrawIndexed( 36, 0, 0 );

	pD3DXDeviceCtx->RSSetState( *rasterizer_state );
}

struct COLOR_VERTEX
{
	XMFLOAT3	Position;
	XMFLOAT4	Color;
};

class CRender2D
{
	ID3D11InputLayout* mInputLayout = nullptr;
	ID3D11Buffer* mVertexBuffer = nullptr;
	ID3D11VertexShader* mVS = nullptr;
	ID3D11PixelShader* mPS = nullptr;
	ID3D11BlendState* transparency = nullptr;
	D3D11StateSaver* stateSaver = new D3D11StateSaver();
	IFW1FontWrapper* font;

	bool restoreState = false;
public:
	CRender2D() = default;
	~CRender2D() = default;

	bool Initialize( IFW1FontWrapper* pFontWrapper );
	void BeginScene();
	void EndScene();
	void OnReset();

	void FillRect( float x, float y, float w, float h, ULONG color );
	void OutlineRect( float x1, float y1, float x2, float y2, ULONG color );
	void DrawLine( const XMFLOAT2& point_1, const XMFLOAT2& point_2, ULONG color );
	void DrawHealthBar( float x, float y, float w, float health, float max );
	void DrawHealthBar( float x, float y, float w, float h, float health, float max );

	void RenderText( const wchar_t* txt, float x, float y, ULONG color, bool center, bool shadow = true );
	void RenderText( const char* txt, float x, float y, ULONG color, bool center, bool shadow = true );
};

extern CRender2D render;


```

`dwmhook/save_state.cpp`:

```cpp
#include "includes.hpp"

D3D11StateSaver::D3D11StateSaver() :
	m_savedState( false ),
	m_featureLevel( D3D_FEATURE_LEVEL_11_0 ),
	m_pContext( NULL ),
	m_primitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED ),
	m_pInputLayout( NULL ),
	m_pBlendState( NULL ),
	m_sampleMask( 0xffffffff ),
	m_pDepthStencilState( NULL ),
	m_stencilRef( 0 ),
	m_pRasterizerState( NULL ),
	m_pPSSRV( NULL ),
	m_pSamplerState( NULL ),
	m_pVS( NULL ),
	m_numVSClassInstances( 0 ),
	m_pVSConstantBuffer( NULL ),
	m_pGS( NULL ),
	m_numGSClassInstances( 0 ),
	m_pGSConstantBuffer( NULL ),
	m_pGSSRV( NULL ),
	m_pPS( NULL ),
	m_numPSClassInstances( 0 ),
	m_pHS( NULL ),
	m_numHSClassInstances( 0 ),
	m_pDS( NULL ),
	m_numDSClassInstances( 0 ),
	m_pVB( NULL ),
	m_vertexStride( 0 ),
	m_vertexOffset( 0 ),
	m_pIndexBuffer( NULL ),
	m_indexFormat( DXGI_FORMAT_UNKNOWN ),
	m_indexOffset( 0 )
{
	for ( int i = 0; i < 4; ++i )
		m_blendFactor[ i ] = 0.0f;
	for ( int i = 0; i < 256; ++i )
	{
		m_pVSClassInstances[ i ] = NULL;
		m_pGSClassInstances[ i ] = NULL;
		m_pPSClassInstances[ i ] = NULL;
		m_pHSClassInstances[ i ] = NULL;
		m_pDSClassInstances[ i ] = NULL;
	}
}

D3D11StateSaver::~D3D11StateSaver()
{
	releaseSavedState();
}

HRESULT D3D11StateSaver::saveCurrentState( ID3D11DeviceContext* pContext )
{
	if ( m_savedState )
		releaseSavedState();
	if ( pContext == NULL )
		return E_INVALIDARG;

	ID3D11Device* pDevice;
	pContext->GetDevice( &pDevice );
	if ( pDevice != NULL ) {
		m_featureLevel = pDevice->GetFeatureLevel();
		pDevice->Release();
	}

	pContext->AddRef();
	m_pContext = pContext;

	m_pContext->IAGetPrimitiveTopology( &m_primitiveTopology );
	m_pContext->IAGetInputLayout( &m_pInputLayout );

	m_pContext->OMGetBlendState( &m_pBlendState, m_blendFactor, &m_sampleMask );
	m_pContext->OMGetDepthStencilState( &m_pDepthStencilState, &m_stencilRef );

	m_pContext->RSGetState( &m_pRasterizerState );

	m_numVSClassInstances = 256;
	m_pContext->VSGetShader( &m_pVS, m_pVSClassInstances, &m_numVSClassInstances );
	m_pContext->VSGetConstantBuffers( 0, 1, &m_pVSConstantBuffer );

	m_numPSClassInstances = 256;
	m_pContext->PSGetShader( &m_pPS, m_pPSClassInstances, &m_numPSClassInstances );
	m_pContext->PSGetShaderResources( 0, 1, &m_pPSSRV );
	pContext->PSGetSamplers( 0, 1, &m_pSamplerState );

	if ( m_featureLevel >= D3D_FEATURE_LEVEL_10_0 )
	{
		m_numGSClassInstances = 256;
		m_pContext->GSGetShader( &m_pGS, m_pGSClassInstances, &m_numGSClassInstances );
		m_pContext->GSGetConstantBuffers( 0, 1, &m_pGSConstantBuffer );

		m_pContext->GSGetShaderResources( 0, 1, &m_pGSSRV );

		if ( m_featureLevel >= D3D_FEATURE_LEVEL_11_0 )
		{
			m_numHSClassInstances = 256;
			m_pContext->HSGetShader( &m_pHS, m_pHSClassInstances, &m_numHSClassInstances );

			m_numDSClassInstances = 256;
			m_pContext->DSGetShader( &m_pDS, m_pDSClassInstances, &m_numDSClassInstances );
		}
	}

	m_pContext->IAGetVertexBuffers( 0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset );

	m_pContext->IAGetIndexBuffer( &m_pIndexBuffer, &m_indexFormat, &m_indexOffset );

	m_savedState = true;

	return S_OK;
}

HRESULT D3D11StateSaver::restoreSavedState()
{
	if ( !m_savedState )
		return E_FAIL;

	m_pContext->IASetPrimitiveTopology( m_primitiveTopology );
	m_pContext->IASetInputLayout( m_pInputLayout );

	m_pContext->OMSetBlendState( m_pBlendState, m_blendFactor, m_sampleMask );
	m_pContext->OMSetDepthStencilState( m_pDepthStencilState, m_stencilRef );

	m_pContext->RSSetState( m_pRasterizerState );

	m_pContext->VSSetShader( m_pVS, m_pVSClassInstances, m_numVSClassInstances );
	m_pContext->VSSetConstantBuffers( 0, 1, &m_pVSConstantBuffer );

	m_pContext->PSSetShader( m_pPS, m_pPSClassInstances, m_numPSClassInstances );
	m_pContext->PSSetShaderResources( 0, 1, &m_pPSSRV );
	m_pContext->PSSetSamplers( 0, 1, &m_pSamplerState );

	if ( m_featureLevel >= D3D_FEATURE_LEVEL_10_0 )
	{
		m_pContext->GSSetShader( m_pGS, m_pGSClassInstances, m_numGSClassInstances );
		m_pContext->GSSetConstantBuffers( 0, 1, &m_pGSConstantBuffer );

		m_pContext->GSSetShaderResources( 0, 1, &m_pGSSRV );

		if ( m_featureLevel >= D3D_FEATURE_LEVEL_11_0 )
		{
			m_pContext->HSSetShader( m_pHS, m_pHSClassInstances, m_numHSClassInstances );

			m_pContext->DSSetShader( m_pDS, m_pDSClassInstances, m_numDSClassInstances );
		}
	}

	m_pContext->IASetVertexBuffers( 0, 1, &m_pVB, &m_vertexStride, &m_vertexOffset );

	m_pContext->IASetIndexBuffer( m_pIndexBuffer, m_indexFormat, m_indexOffset );

	return S_OK;
}

void D3D11StateSaver::releaseSavedState()
{
	m_primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
	SAFE_RELEASE( m_pInputLayout );
	SAFE_RELEASE( m_pBlendState );
	for ( int i = 0; i < 4; ++i )
		m_blendFactor[ i ] = 0.0f;
	m_sampleMask = 0xffffffff;
	SAFE_RELEASE( m_pDepthStencilState );
	m_stencilRef = 0;
	SAFE_RELEASE( m_pRasterizerState );
	SAFE_RELEASE( m_pPSSRV );
	SAFE_RELEASE( m_pSamplerState );
	SAFE_RELEASE( m_pVS );
	for ( UINT i = 0; i < m_numVSClassInstances; ++i )
		SAFE_RELEASE( m_pVSClassInstances[ i ] );
	m_numVSClassInstances = 0;
	SAFE_RELEASE( m_pVSConstantBuffer );
	SAFE_RELEASE( m_pGS );
	for ( UINT i = 0; i < m_numGSClassInstances; ++i )
		SAFE_RELEASE( m_pGSClassInstances[ i ] );
	m_numGSClassInstances = 0;
	SAFE_RELEASE( m_pGSConstantBuffer );
	SAFE_RELEASE( m_pGSSRV );
	SAFE_RELEASE( m_pPS );
	for ( UINT i = 0; i < m_numPSClassInstances; ++i )
		SAFE_RELEASE( m_pPSClassInstances[ i ] );
	m_numPSClassInstances = 0;
	SAFE_RELEASE( m_pHS );
	for ( UINT i = 0; i < m_numHSClassInstances; ++i )
		SAFE_RELEASE( m_pHSClassInstances[ i ] );
	m_numHSClassInstances = 0;
	SAFE_RELEASE( m_pDS );
	for ( UINT i = 0; i < m_numDSClassInstances; ++i )
		SAFE_RELEASE( m_pDSClassInstances[ i ] );
	m_numDSClassInstances = 0;
	SAFE_RELEASE( m_pVB );
	m_vertexStride = 0;
	m_vertexOffset = 0;
	SAFE_RELEASE( m_pIndexBuffer );
	m_indexFormat = DXGI_FORMAT_UNKNOWN;
	m_indexOffset = 0;

	SAFE_RELEASE( m_pContext );
	m_featureLevel = D3D_FEATURE_LEVEL_11_0;

	m_savedState = false;
}
```

`dwmhook/save_state.hpp`:

```hpp
#pragma once

class D3D11StateSaver
{
private:
	bool						m_savedState;
	D3D_FEATURE_LEVEL			m_featureLevel;
	ID3D11DeviceContext* m_pContext;
	D3D11_PRIMITIVE_TOPOLOGY	m_primitiveTopology;
	ID3D11InputLayout* m_pInputLayout;
	ID3D11BlendState* m_pBlendState;
	float						m_blendFactor[ 4 ];
	UINT						m_sampleMask;
	ID3D11DepthStencilState* m_pDepthStencilState;
	UINT						m_stencilRef;
	ID3D11RasterizerState* m_pRasterizerState;
	ID3D11ShaderResourceView* m_pPSSRV;
	ID3D11SamplerState* m_pSamplerState;
	ID3D11VertexShader* m_pVS;
	ID3D11ClassInstance* m_pVSClassInstances[ 256 ];
	UINT						m_numVSClassInstances;
	ID3D11Buffer* m_pVSConstantBuffer;
	ID3D11GeometryShader* m_pGS;
	ID3D11ClassInstance* m_pGSClassInstances[ 256 ];
	UINT						m_numGSClassInstances;
	ID3D11Buffer* m_pGSConstantBuffer;
	ID3D11ShaderResourceView* m_pGSSRV;
	ID3D11PixelShader* m_pPS;
	ID3D11ClassInstance* m_pPSClassInstances[ 256 ];
	UINT						m_numPSClassInstances;
	ID3D11HullShader* m_pHS;
	ID3D11ClassInstance* m_pHSClassInstances[ 256 ];
	UINT						m_numHSClassInstances;
	ID3D11DomainShader* m_pDS;
	ID3D11ClassInstance* m_pDSClassInstances[ 256 ];
	UINT						m_numDSClassInstances;
	ID3D11Buffer* m_pVB;
	UINT						m_vertexStride;
	UINT						m_vertexOffset;
	ID3D11Buffer* m_pIndexBuffer;
	DXGI_FORMAT					m_indexFormat;
	UINT						m_indexOffset;

	D3D11StateSaver( const D3D11StateSaver& );
	D3D11StateSaver& operator=( const D3D11StateSaver& );

public:
	D3D11StateSaver();
	~D3D11StateSaver();

	HRESULT saveCurrentState( ID3D11DeviceContext* pContext );
	HRESULT restoreSavedState();
	void releaseSavedState();
};
```