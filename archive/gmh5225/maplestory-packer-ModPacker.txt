Project Path: arc_gmh5225_maplestory-packer-ModPacker_mx2vtzcg

Source Tree:

```txt
arc_gmh5225_maplestory-packer-ModPacker_mx2vtzcg
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── ModPacker
│   ├── CMakeLists.txt
│   ├── ModPacker.cpp
│   └── ModPacker.h
└── README.md

```

`CMakeLists.txt`:

```txt
# CMakeList.txt : 최상위 CMake 프로젝트 파일, 전역 구성을 수행하고
# 여기에 하위 프로젝트를 포함합니다.
#
cmake_minimum_required (VERSION 3.8)

# Enable Hot Reload for MSVC compilers if supported.
if (POLICY CMP0141)
  cmake_policy(SET CMP0141 NEW)
  set(CMAKE_MSVC_DEBUG_INFORMATION_FORMAT "$<IF:$<AND:$<C_COMPILER_ID:MSVC>,$<CXX_COMPILER_ID:MSVC>>,$<$<CONFIG:Debug,RelWithDebInfo>:EditAndContinue>,$<$<CONFIG:Debug,RelWithDebInfo>:ProgramDatabase>>")
endif()

project ("ModPacker")

# 하위 프로젝트를 포함합니다.
add_subdirectory ("ModPacker")

```

`CMakePresets.json`:

```json
{
    "version": 3,
    "configurePresets": [
        {
            "name": "windows-base",
            "hidden": true,
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/out/build/${presetName}",
            "installDir": "${sourceDir}/out/install/${presetName}",
            "cacheVariables": {
                "CMAKE_C_COMPILER": "cl.exe",
                "CMAKE_CXX_COMPILER": "cl.exe"
            },
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            }
        },
        {
            "name": "x64-debug",
            "displayName": "x64 Debug",
            "inherits": "windows-base",
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "x64-release",
            "displayName": "x64 Release",
            "inherits": "x64-debug",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },
        {
            "name": "x86-debug",
            "displayName": "x86 Debug",
            "inherits": "windows-base",
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "x86-release",
            "displayName": "x86 Release",
            "inherits": "x86-debug",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        }
    ]
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 SeokguKim

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`ModPacker/CMakeLists.txt`:

```txt
# CMakeList.txt: ModPacker에 대한 CMake 프로젝트, 여기에 소스를 포함하고
# 프로젝트 특정 논리를 정의합니다.
#

# 이 프로젝트의 실행 파일에 소스를 추가합니다.
add_executable (ModPacker "ModPacker.cpp" "ModPacker.h")

if (CMAKE_VERSION VERSION_GREATER 3.12)
  set_property(TARGET ModPacker PROPERTY CXX_STANDARD 20)
endif()

# TODO: 필요한 경우 테스트를 추가하고 대상을 설치합니다.

```

`ModPacker/ModPacker.cpp`:

```cpp
#include "ModPacker.h"
using namespace std;

int extensioncheck(string mypath, string& outpath) {
	int idx = mypath.find_last_of(".");
	if (idx == -1) {
		if (!filesystem::exists(mypath)) return 0;
		outpath = mypath + ".mod";
		return 2;
	}

	string ext = mypath.substr(idx + 1), base = mypath.substr(0, idx);
	if (ext == "mod") {
		outpath = base;
		return 1;
	}
	return 0;
}

int getlength(unsigned char*& data, int& idx) {
	int plen = 0, f = 1;

	while (data[++idx] & 128) {
		plen += (data[idx] & 127) * f;
		f *= 128;
	}
	plen += (data[idx++] & 127) * f;

	return plen;
}

string blockparser(unsigned char*& data, int& idx, int nxt) {
	string res = "";

	while (idx < nxt) {
		if (data[idx] != 18) res += data[idx++];
		else {
			int cur = getlength(data, idx);
			res += blockparser(data, idx, idx + cur);
			res += (unsigned char)0;
		}
	}

	return res;
}

string specialparser(unsigned char*& data, int& idx, int nxt) {
	string res = "";

	while (idx < nxt) {
		if (data[idx] != 18 && data[idx] != 26) res += data[idx++];
		else {
			res += (unsigned char)0;
			int cur = getlength(data, idx);
			res += specialparser(data, idx, idx + cur);
			res += (unsigned char)0;
			if (data[idx] == 34) getlength(data, idx);
		}
	}

	return res;
}

void modextract(string mypath, string outpath) {
	ifstream fin(mypath, ios_base::in | ios_base::binary);
	if (!fin) {
		cout << "Invalid File... Quitting Program...";
		exit(1);
	}

	fin.seekg(0, fin.end);
	int len = (int)fin.tellg();
	fin.seekg(0, fin.beg);

	unsigned char* data = (unsigned char*)malloc(len);
	fin.read((char*)data, len);
	fin.close();

	filesystem::remove_all(outpath);
	
	int depth = 0;
	int idx = 2;
	
	while (idx < len) {
		string resstr = "";
		int plen = getlength(data, idx);
		int nxt = idx + plen;
		
		while (data[idx] != 18) resstr += data[idx++];
		resstr += (unsigned char)0;

		int tmp = getlength(data, idx);
		while (data[idx] != 26) resstr += data[idx++];
		resstr += (unsigned char)0;

		int scriptlen = getlength(data, idx);
		string scriptid = "";
		while (scriptlen--) scriptid += data[idx++];
		resstr += scriptid;
		resstr += (unsigned char)0;

		int pathlen = getlength(data, idx);
		string innerpath = "";
		while (pathlen--) innerpath += data[idx++];
		resstr += innerpath;
		resstr += (unsigned char)0;
		
		string category = scriptid.substr(0, scriptid.find(":"));
		string entryid = scriptid.substr(scriptid.find_last_of("/") + 1);

		tmp = getlength(data, idx);
		if (data[idx] == 8) {
			tmp = getlength(data, idx);
			resstr += specialparser(data, idx, nxt);
		}
		else resstr += blockparser(data, idx, nxt);

		string newpath = outpath + "\\" + category;
		filesystem::create_directories(newpath);

		string newfile = newpath + "\\" + category + "-" + entryid + ".txt";
		ofstream fout(newfile, ios::binary | std::ios::trunc);
		fout << resstr;
		fout.close();
	}
}

string getbyte(int len) {
	string res = "";

	while (len) {
		unsigned char cur = len % 128;
		len /= 128;
		if (len) cur |= 128;
		res += cur;
	}

	return res;
}

string blockconcat(vector<string>& v) {
	string res = v[0];
	res += (unsigned char)18;
	res +=(unsigned char)32;
	res += v[1];
	res += (unsigned char)26;
	res += getbyte(v[2].size());
	res += v[2];
	res += (unsigned char)34;
	res += getbyte(v[3].size());
	res += v[3];
	
	string inner = "";
	inner += (unsigned char)18;
	inner += getbyte(v[4].size());
	inner += v[4];
	inner = '2' + getbyte(inner.size()) + inner;

	res += inner + v[5];
	res = getbyte(res.size()) + res;
	res.insert(0, 1, (unsigned char)18);

	return res;
}

string specialconcat(vector<string>& v) {
	string res = v[0];
	res += (unsigned char)18;
	res += (unsigned char)32;
	res += v[1];
	res += (unsigned char)26;
	res += getbyte(v[2].size());
	res += v[2];
	res += (unsigned char)34;
	res += getbyte(v[3].size());
	res += v[3];

	int idx = 4;
	string inner = "";
	inner += (unsigned char)8;
	inner += (unsigned char)1;
	while (idx < v.size() - 1) {
		string tmp = v[idx++];
		tmp += (unsigned char)18;
		tmp += getbyte(v[idx].size());
		tmp += v[idx++];
		tmp += (unsigned char)26;
		tmp += getbyte(v[idx].size());
		tmp += v[idx++];
		if (v[idx][0] != 26 && v[idx][0] != 88 && v[idx][1] != 1) {
			tmp += (unsigned char)34;
			tmp += getbyte(v[idx].size());
			tmp += v[idx++];
		}
		tmp = getbyte(tmp.size()) + tmp;
		tmp.insert(0, 1, (unsigned char)26);
		inner += tmp;
	}

	inner = '2' + getbyte(inner.size()) + inner;

	res += inner + v.back();
	res = getbyte(res.size()) + res;
	res.insert(0, 1, (unsigned char)18);

	return res;
}

void modpack(string mypath, string outpath) {
	filesystem::remove(outpath);
	ofstream fout(outpath, ios::binary);
	fout << (unsigned char)10 << (unsigned char)0;

	for (const auto& file : filesystem::recursive_directory_iterator(mypath)) {
		if (file.is_directory()) continue;
		string pn = file.path().string();
		string category = file.path().filename().string();
		category = category.substr(0,category.find("-"));

		ifstream fin(pn, ios_base::in | ios_base::binary);
		if (!fin) {
			cout << "Invalid File... Quitting Program...";
			exit(1);
		}

		fin.seekg(0, fin.end);
		int len = (int)fin.tellg();
		fin.seekg(0, fin.beg);

		unsigned char* data = (unsigned char*)malloc(len);
		fin.read((char*)data, len);
		fin.close();

		vector<string> v;
		string cur = "";
		for (int i = 0; i < len; i++) {
			if (data[i] != 0) cur += data[i];
			else if (cur.size()) {
				v.push_back(cur);
				cur = "";
			}
		}
		if (cur.size()) v.push_back(cur);

		if (category == "gamelogic" || category == "map" || category == "ui") fout << specialconcat(v);
		else fout << blockconcat(v);
	}
	fout.close();
}

int main(int argc, char** argv) {
	string mypath, outpath;
	if (argc >= 2) mypath = argv[1];
	else {
		cout << "Input Path to .mod or Directory and Press Enter...\n";
		getline(cin, mypath);
	}

	int ext = extensioncheck(mypath, outpath);
	if (!ext) {
		cout << "Invalid Extension or Path... Quitting Program...";
		return 1;
	}

	if (ext == 1) modextract(mypath, outpath);
	else modpack(mypath, outpath);

	cout << "Complete!";
}

```

`ModPacker/ModPacker.h`:

```h
// ModPacker.h: 표준 시스템 포함 파일
// 또는 프로젝트 특정 포함 파일이 들어 있는 포함 파일입니다.

#pragma once

#include <bits/stdc++.h>
#include <filesystem>

// TODO: 여기서 프로그램에 필요한 추가 헤더를 참조합니다.

```

`README.md`:

```md
# ModPacker
MapleStory Wolrds .mod file packing/unpacking tools  
메이플스토리 월드 .mod 파일 패킹/언패킹 도구

# Features
- Unpack .mod file to distinct .txt files.  
- .mod 파일을 각각의 고유한 .txt 파일들로 언패킹합니다.

- Repack unfolded .txt files to .mod file.  
- 언패킹된 .txt 파일들로부터 .mod 파일을 패킹합니다.

- Valid packing with scripts written in different worlds.  
- 각기 다른 월드에서 작성된 스크립트들을 합쳤을 때 유효하게 패킹됩니다.

# Quick Guide
1. Clone the repo and build your own with CMake or download [released](https://github.com/SeokguKim/ModPacker/releases) version of ModPacker.exe.
2. Execute "ModPacker.exe".
3. Input .mod file path or directory path contains vaild sources.
4. Done.
---
1. 리포지토리를 복제하여 CMake로 직접 빌드하거나 [릴리즈](https://github.com/SeokguKim/ModPacker/releases)된 버전의 ModPacker.exe를 다운로드합니다. 
2. "ModPacker.exe"를 실행합니다.
3. .mod나 유효한 파일들을 포함하는 디렉토리 경로를 입력합니다.
4. 끝.
---
**04/04/23**

Thanks to Munbin-Lee:
- You can drag-and-drop your .mod file or workspace directory to ModPacker.exe to pack/unpack.  
- ModPacker.exe 에 .mod 파일이나 워크스페이스 폴더를 드래그 앤 드롭 하는 것으로도 패킹/언패킹을 할 수 있습니다.

# Caution
- Not sure if its ok with git.  
- 아직 깃과 함께 사용했을 때의 상황에 대해 어떨지 모릅니다.

- When you are packing, files about directory path in "directory" folder is not necessary, you can sucessfully import packed file.  
- 패킹 시에 "directory" 폴더에 포함된 경로 관련 파일은 필수적이지 않습니다. 그렇게 패킹해도 정상적으로 임포트 됩니다.

# Contact
rokja97@naver.com

```