Project Path: arc_gmh5225_Vac-Emulator_a34_yug0

Source Tree:

```txt
arc_gmh5225_Vac-Emulator_a34_yug0
├── CMakeLists.txt
├── include
│   ├── common.h
│   ├── emu
│   │   └── emulator.h
│   ├── hooks
│   │   ├── hook_base.h
│   │   ├── ipc_dispatch.h
│   │   ├── load_validate.h
│   │   ├── parent_dispatch.h
│   │   ├── run_module.h
│   │   ├── run_module_async.h
│   │   └── validate_signature.h
│   ├── hooks.h
│   ├── ipc
│   │   ├── buffer.h
│   │   ├── messages.h
│   │   ├── parser.h
│   │   └── types.h
│   ├── ipc_parser.h
│   ├── ipc_types.h
│   ├── logger.h
│   ├── module
│   │   ├── manager.h
│   │   └── types.h
│   └── utils
│       ├── disasm.h
│       ├── logger.h
│       └── sigscan.h
├── libs
│   └── minhook-1.3.3
│       ├── AUTHORS.txt
│       ├── LICENSE.txt
│       ├── README.md
│       ├── dll_resources
│       │   ├── MinHook.def
│       │   └── MinHook.rc
│       ├── include
│       │   └── MinHook.h
│       └── src
│           ├── buffer.c
│           ├── buffer.h
│           ├── hde
│           │   ├── hde32.c
│           │   ├── hde32.h
│           │   ├── hde64.c
│           │   ├── hde64.h
│           │   ├── pstdint.h
│           │   ├── table32.h
│           │   └── table64.h
│           ├── hook.c
│           ├── trampoline.c
│           └── trampoline.h
└── src
    ├── dllmain.cpp
    ├── emu
    │   └── emulator.cpp
    ├── hooks
    │   ├── hooks_all.cpp
    │   ├── ipc_dispatch.cpp
    │   ├── load_validate.cpp
    │   ├── parent_dispatch.cpp
    │   ├── run_module.cpp
    │   ├── run_module_async.cpp
    │   └── validate_signature.cpp
    ├── hooks.cpp
    ├── injector.cpp
    ├── ipc
    │   └── parser.cpp
    ├── ipc_parser.cpp
    ├── logger.cpp
    ├── module
    │   └── manager.cpp
    └── utils
        ├── disasm.cpp
        ├── logger.cpp
        └── sigscan.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)
project(vac_ipc_logger VERSION 1.0.0 LANGUAGES CXX C)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find Zydis from vcpkg
find_package(zydis CONFIG REQUIRED)

# MinHook source
set(MINHOOK_DIR ${CMAKE_CURRENT_SOURCE_DIR}/libs/minhook-1.3.3)

# Main hook DLL (32-bit)
add_library(vac_ipc_logger SHARED
    src/dllmain.cpp
    src/ipc/parser.cpp
    src/utils/logger.cpp
    src/utils/disasm.cpp
    src/utils/sigscan.cpp
    src/emu/emulator.cpp
    src/module/manager.cpp
    # Hooks
    src/hooks/hooks_all.cpp
    src/hooks/parent_dispatch.cpp
    src/hooks/ipc_dispatch.cpp
    src/hooks/run_module.cpp
    src/hooks/run_module_async.cpp
    src/hooks/load_validate.cpp
    src/hooks/validate_signature.cpp
    # MinHook sources (statically compiled in)
    ${MINHOOK_DIR}/src/buffer.c
    ${MINHOOK_DIR}/src/hook.c
    ${MINHOOK_DIR}/src/trampoline.c
    ${MINHOOK_DIR}/src/hde/hde32.c
)

target_include_directories(vac_ipc_logger PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${MINHOOK_DIR}/include
)

target_link_libraries(vac_ipc_logger PRIVATE
    Psapi
    Zydis::Zydis
)

# Injector executable
add_executable(injector
    src/injector.cpp
)

target_link_libraries(injector PRIVATE
    Shlwapi
)

# Output to bin folder
set_target_properties(vac_ipc_logger PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
)

set_target_properties(injector PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
)

```

`include/common.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <cstdint>
#include <string>
#include <vector>
#include <mutex>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <chrono>

// SteamService.dll base address (loaded at runtime)
extern uintptr_t g_SteamServiceBase;

// IPC Magic Constants
namespace IPC {
    constexpr uint32_t MAGIC_LOAD_MODULE        = 0x24DF160F;
    constexpr uint32_t MAGIC_UNLOAD_MODULE      = 0xD2CB05FD;
    constexpr uint32_t MAGIC_CALL_FUNCTION      = 0xFDD7BB75;
    constexpr uint32_t MAGIC_CALL_FUNCTION_ASYNC = 0x7D2F2539;
    constexpr uint32_t MAGIC_POLL_RESPONSE_ASYNC = 0x59815F75;
    constexpr uint32_t MAGIC_SET_PROTON_ENV     = 0xFE43DF34;

    // Fence offsets
    constexpr uint32_t FENCE_LOAD_MODULE        = 1274445;
    constexpr uint32_t FENCE_UNLOAD_MODULE      = 1322832;
    constexpr uint32_t FENCE_CALL_FUNCTION      = 1484122;
    constexpr uint32_t FENCE_CALL_FUNCTION_ASYNC = 1726057;
    constexpr uint32_t FENCE_POLL_RESPONSE_ASYNC = 1855089;
    constexpr uint32_t FENCE_ALT                = 254;

    const char* GetMethodName(uint32_t magic);
}

// IPC Buffer structure (from reversing)
#pragma pack(push, 1)
struct IPCBuffer {
    void* data;           // +0x00: data pointer
    uint32_t allocCount;  // +0x04: allocation count (x86)
    uint32_t growSize;    // +0x08: grow size
    uint32_t getPos;      // +0x0C: read position
    uint32_t putPos;      // +0x10: write position
    uint32_t dataLen;     // +0x14: data length
    uint8_t reserved[2];  // +0x18
    uint8_t errorFlags;   // +0x1A: error flags
    uint8_t modeFlags;    // +0x1B: mode flags
};
#pragma pack(pop)

```

`include/emu/emulator.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>
#include "ipc/types.h"
#include "ipc/buffer.h"

namespace Emu {

//=============================================================================
// Emulation Mode
//=============================================================================
enum class Mode {
    LOG_ONLY,       // Just log traffic, forward to real service
    EMULATE_VAC,    // Emulate VAC (type 2) responses, forward others
    EMULATE_ALL,    // Emulate all IPC responses
};

//=============================================================================
// Response Builder - Crafts fake IPC responses
//=============================================================================
class ResponseBuilder {
public:
    ResponseBuilder(uint8_t* buffer, size_t maxSize);

    // Write primitives
    bool WriteU8(uint8_t val);
    bool WriteU32(uint32_t val);
    bool WriteU64(uint64_t val);
    bool WriteBytes(const uint8_t* data, size_t len);
    bool WriteString(const char* str);  // 1-byte length prefix

    // Get result
    size_t GetSize() const { return m_pos; }
    uint8_t* GetBuffer() { return m_buffer; }

private:
    uint8_t* m_buffer;
    size_t m_maxSize;
    size_t m_pos;
};

//=============================================================================
// VAC Emulator - Handles IClientModuleManager responses
//=============================================================================
namespace VAC {

// Emulated module state
struct EmulatedModule {
    uint32_t moduleId;
    bool loaded;
    uint64_t loadTime;
};

// Response crafting for each VAC method
bool EmulateLoadModule(uint32_t moduleId, uint32_t moduleSize,
                       uint8_t* responseBuffer, size_t* responseSize);

bool EmulateUnloadModule(uint32_t moduleId,
                         uint8_t* responseBuffer, size_t* responseSize);

// Response format: result(4) + outputBuffer(outputBufferSize) + actualSize(4)
bool EmulateCallFunction(uint32_t moduleId, uint32_t functionId,
                         uint32_t param, const uint8_t* inputData, uint32_t inputSize,
                         uint32_t outputBufferSize,
                         uint8_t* responseBuffer, size_t* responseSize);

// Response format: result(4)
bool EmulateCallFunctionAsync(uint32_t clientHandle, uint32_t moduleId,
                              uint32_t functionId, uint32_t param,
                              const uint8_t* inputData, uint32_t inputSize,
                              uint8_t* responseBuffer, size_t* responseSize);

// Response format: result(4) + outputBuffer(outputBufferSize) + actualSize(4)
bool EmulatePollResponseAsync(uint32_t outputBufferSize, uint32_t maxWaitMs,
                              uint8_t* responseBuffer, size_t* responseSize);

} // namespace VAC

//=============================================================================
// Registry Emulator - Handles IRegistryInterface responses
//=============================================================================
namespace Registry {

bool EmulateGetValueStr(uint32_t hRoot, const char* keyPath, const char* valueName,
                        uint8_t* responseBuffer, size_t* responseSize);

bool EmulateGetValueUint(uint32_t hRoot, const char* keyPath, const char* valueName,
                         uint8_t* responseBuffer, size_t* responseSize);

bool EmulateSetValue(uint8_t* responseBuffer, size_t* responseSize);

} // namespace Registry

//=============================================================================
// Main Emulator Interface
//=============================================================================
class Emulator {
public:
    static void SetMode(Mode mode);
    static Mode GetMode();

    // Returns true if the request was emulated (don't call original)
    // Returns false if we should forward to real service
    static bool HandleRequest(uint8_t dispatchType, uint32_t magic,
                              const uint8_t* requestData, size_t requestSize,
                              uint8_t* responseBuffer, size_t* responseSize);

private:
    static Mode s_mode;
};

} // namespace Emu

```

`include/hooks.h`:

```h
#pragma once
#include "common.h"

namespace Hooks {
    bool Init();
    void Shutdown();

    // Hook status
    bool IsInitialized();
}

```

`include/hooks/hook_base.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>
#include <MinHook.h>
#include "utils/logger.h"

namespace Hooks {

//=============================================================================
// Hook Helper - Creates and enables a hook with logging
//=============================================================================
inline bool CreateAndEnable(void* target, void* detour, void** original, const char* name) {
    MH_STATUS status = MH_CreateHook(target, detour, original);
    if (status != MH_OK) {
        Logger::Log("ERROR: MH_CreateHook %s failed: %d", name, status);
        return false;
    }
    status = MH_EnableHook(target);
    if (status != MH_OK) {
        Logger::Log("ERROR: MH_EnableHook %s failed: %d", name, status);
        return false;
    }
    Logger::Log("Hook %s enabled @ 0x%08X", name, reinterpret_cast<uintptr_t>(target));
    return true;
}

//=============================================================================
// SteamService.dll Offsets (from IDA reversing)
// Update these for different SteamService.dll versions
//=============================================================================
namespace Offsets {
    // IPC Dispatchers
    constexpr uintptr_t PARENT_DISPATCH         = 0x52680;  // CServiceEngine_IPC_ParentDispatch
    constexpr uintptr_t IPC_DISPATCH            = 0x549E0;  // IClientModuleManager_IPC_Dispatch

    // Module Management
    constexpr uintptr_t RUN_MODULE              = 0x5A900;  // CClientModuleManager_RunModule
    constexpr uintptr_t RUN_MODULE_ASYNC        = 0x59B60;  // CClientModuleManager_RunModuleAsync
    constexpr uintptr_t LOAD_VALIDATE           = 0x5B290;  // CClientModuleManager_LoadAndValidateModule
    constexpr uintptr_t FREE_MODULE             = 0x5B880;  // CClientModuleManager_FreeModule
    constexpr uintptr_t FIND_MODULE_INDEX       = 0x59DB0;  // CClientModuleManager_FindModuleIndex (estimated)

    // Async Result Handling
    constexpr uintptr_t ASYNC_GET_RESULT        = 0x59FB0;  // CClientModuleManagerAsync_GetResult

    // Module Validation & Loading
    constexpr uintptr_t VALIDATE_SIGNATURE      = 0x89110;  // Module_ValidateSignature (RSA check)
    constexpr uintptr_t MEMORY_MODULE_LOAD      = 0x88970;  // MemoryModule_LoadFromBuffer (estimated)
    constexpr uintptr_t MEMORY_MODULE_GET_PROC  = 0x4ED90;  // MemoryModule_GetProcAddress (estimated)
}

//=============================================================================
// Global State
//=============================================================================
extern uintptr_t g_SteamServiceBase;
extern bool g_EmulationEnabled;

// Initialize all hooks
bool InitializeAll(uintptr_t steamServiceBase);

// Cleanup all hooks
void ShutdownAll();

} // namespace Hooks

```

`include/hooks/ipc_dispatch.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace IPCDispatch {

// Hook: IClientModuleManager_IPC_Dispatch
// Called specifically for Type 2 (VAC ModuleManager) messages
// Useful for deeper inspection of VAC-specific traffic

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);
void Uninstall();

} // namespace IPCDispatch
} // namespace Hooks

```

`include/hooks/load_validate.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace LoadValidate {

// Hook: CClientModuleManager_LoadAndValidateModule
// Called when a VAC module PE is loaded and validated
// Performs RSA signature check and resolves _runfunc@20

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);
void Uninstall();

} // namespace LoadValidate
} // namespace Hooks

```

`include/hooks/parent_dispatch.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace ParentDispatch {

// Hook: CServiceEngine_IPC_ParentDispatch
// This is the main entry point for ALL IPC types (1-6)
// Intercepts traffic before it's dispatched to specific handlers

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);  // Install at specific address (from sig scan)
void Uninstall();

} // namespace ParentDispatch
} // namespace Hooks

```

`include/hooks/run_module.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace RunModule {

// Hook: CClientModuleManager_RunModule
// Called when a VAC module is executed synchronously
// This is where _runfunc@20 gets called with scan parameters

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);
void Uninstall();

} // namespace RunModule
} // namespace Hooks

```

`include/hooks/run_module_async.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace RunModuleAsync {

// Hook: CClientModuleManager_RunModuleAsync
// Called when a VAC module is executed asynchronously
// Queues work item for background execution

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);
void Uninstall();

} // namespace RunModuleAsync
} // namespace Hooks

```

`include/hooks/validate_signature.h`:

```h
#pragma once
#include <cstdint>

namespace Hooks {
namespace ValidateSignature {

// Hook: Module_ValidateSignature
// Called to verify RSA signature of VAC module PE data
// Returns 0 on success, non-zero on failure

bool Install(uintptr_t baseAddr);
bool InstallAt(uintptr_t targetAddr);
void Uninstall();

} // namespace ValidateSignature
} // namespace Hooks

```

`include/ipc/buffer.h`:

```h
#pragma once
#include <cstdint>
#include <cstring>

namespace IPC {

//=============================================================================
// CUtlBuffer - Steam's buffer class for IPC serialization
// Reversed from SteamService.dll
//=============================================================================
#pragma pack(push, 1)
struct CUtlBuffer {
    uint8_t* m_pData;       // +0x00: Pointer to buffer data
    uint32_t m_nCapacity;   // +0x04: Buffer capacity
    uint32_t m_nMaxPut;     // +0x08: Max write position reached
    uint32_t m_nGetPos;     // +0x0C: Current read position
    uint32_t m_nPutPos;     // +0x10: Current write position
    uint32_t m_nDataSize;   // +0x14: Total data size
    uint8_t  m_Reserved[2]; // +0x18: Reserved
    uint8_t  m_nErrorFlags; // +0x1A: Error flags
    uint8_t  m_nModeFlags;  // +0x1B: Mode flags (text/binary)

    // Helper methods
    inline uint8_t* GetData() const { return m_pData; }
    inline uint8_t* GetReadPtr() const { return m_pData + m_nGetPos; }
    inline size_t GetReadableSize() const {
        return (m_nPutPos > m_nGetPos) ? (m_nPutPos - m_nGetPos) : 0;
    }
    inline bool IsValid() const { return m_pData != nullptr; }
};
#pragma pack(pop)

//=============================================================================
// BufferReader - Safe buffer reading utility
//=============================================================================
class BufferReader {
public:
    BufferReader(const uint8_t* data, size_t size)
        : m_data(data), m_size(size), m_pos(0) {}

    BufferReader(const CUtlBuffer* buf)
        : m_data(buf ? buf->GetReadPtr() : nullptr)
        , m_size(buf ? buf->GetReadableSize() : 0)
        , m_pos(0) {}

    // Read primitive types
    template<typename T>
    bool Read(T& out) {
        if (m_pos + sizeof(T) > m_size) return false;
        memcpy(&out, m_data + m_pos, sizeof(T));
        m_pos += sizeof(T);
        return true;
    }

    // Read raw bytes
    bool ReadBytes(void* out, size_t count) {
        if (m_pos + count > m_size) return false;
        memcpy(out, m_data + m_pos, count);
        m_pos += count;
        return true;
    }

    // Read string with 4-byte length prefix
    bool ReadString32(const char*& out, uint32_t& len) {
        if (!Read(len)) return false;
        if (m_pos + len > m_size) return false;
        out = reinterpret_cast<const char*>(m_data + m_pos);
        m_pos += len;
        return true;
    }

    // Read string with 1-byte length prefix (Steam's common format)
    bool ReadString8(const char*& out, uint8_t& len) {
        if (!Read(len)) return false;
        if (m_pos + len > m_size) return false;
        out = reinterpret_cast<const char*>(m_data + m_pos);
        m_pos += len;
        return true;
    }

    // Convenience: read string with 1-byte prefix, return as uint32 length
    bool ReadString(const char*& out, uint32_t& len) {
        uint8_t len8;
        if (!Read(len8)) return false;
        len = len8;
        if (m_pos + len > m_size) return false;
        out = reinterpret_cast<const char*>(m_data + m_pos);
        m_pos += len;
        return true;
    }

    // Get pointer without advancing
    const uint8_t* Peek(size_t count) const {
        if (m_pos + count > m_size) return nullptr;
        return m_data + m_pos;
    }

    // Skip bytes
    bool Skip(size_t count) {
        if (m_pos + count > m_size) return false;
        m_pos += count;
        return true;
    }

    // Status
    size_t GetPosition() const { return m_pos; }
    size_t GetRemaining() const { return m_size - m_pos; }
    bool HasData(size_t count = 1) const { return m_pos + count <= m_size; }
    const uint8_t* GetData() const { return m_data; }
    size_t GetSize() const { return m_size; }

private:
    const uint8_t* m_data;
    size_t m_size;
    size_t m_pos;
};

} // namespace IPC

```

`include/ipc/messages.h`:

```h
#pragma once
#include <cstdint>

namespace IPC {

//=============================================================================
// Common IPC Message Header
//=============================================================================
#pragma pack(push, 1)
struct MessageHeader {
    uint8_t  dispatchType;  // Interface type (1-6)
    uint32_t unknown;       // Always 0x00000000 in observed traffic
    uint32_t magic;         // Method identifier
};
#pragma pack(pop)

//=============================================================================
// Type 1: IClientInstallUtils Messages
//=============================================================================
namespace InstallUtils {

// RunInstallScript request
struct RunInstallScriptMsg {
    // uint8_t scriptPathLen;
    // char scriptPath[scriptPathLen];
    // uint8_t installDirLen;
    // char installDir[installDirLen];
};

} // namespace InstallUtils

//=============================================================================
// Type 2: IClientModuleManager (VAC) Messages
//=============================================================================
namespace ModuleManager {

// LoadModule request
struct LoadModuleMsg {
    uint32_t moduleId;
    uint32_t moduleSize;
    // uint8_t moduleData[moduleSize]; // PE data follows
};

// UnloadModule request
struct UnloadModuleMsg {
    uint32_t moduleId;
};

// CallFunction request
struct CallFunctionMsg {
    uint32_t moduleId;
    uint32_t functionId;    // Usually 0 for _runfunc
    uint32_t param;         // Parameter passed to function
    uint32_t inputSize;
    // uint8_t inputData[inputSize];
    uint32_t outputBufferSize;
};

// CallFunctionAsync request
struct CallFunctionAsyncMsg {
    uint32_t clientHandle;  // Handle for async response
    uint32_t moduleId;
    uint32_t functionId;
    uint32_t param;
    uint32_t unknown1;
    uint32_t inputSize;
    // uint8_t inputData[inputSize];
    uint32_t outputBufferSize;
};

// PollResponseAsync request
struct PollResponseAsyncMsg {
    uint32_t outputBufferSize;
    uint32_t maxWaitMs;
    uint32_t unknown;
};

// SetProtonEnv request
struct SetProtonEnvMsg {
    uint32_t envId;
    // char envString[]; // Null-terminated
};

} // namespace ModuleManager

//=============================================================================
// Type 3: IRegistryInterface Messages
//=============================================================================
namespace Registry {

// Registry root types (ERegKeyRoot)
enum RegKeyRoot : uint32_t {
    ROOT_HKEY_CLASSES_ROOT   = 0,
    ROOT_HKEY_CURRENT_USER   = 1,
    ROOT_HKEY_LOCAL_MACHINE  = 2,
    ROOT_HKEY_USERS          = 3,
};

// BGetValueStr request
struct GetValueStrMsg {
    uint32_t hRoot;         // ERegKeyRoot
    // char keyPath[];      // Null-terminated string
    // char valueName[];    // Null-terminated string
    uint32_t bufferSize;    // Output buffer size
};

// BSetValueStr request
struct SetValueStrMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
    // char value[];        // Null-terminated string
};

// BGetValueUint request
struct GetValueUintMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
};

// BSetValueUint request
struct SetValueUintMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
    uint32_t value;
};

// BGetValueUint64 request
struct GetValueUint64Msg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
};

// BSetValueUint64 request
struct SetValueUint64Msg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
    uint64_t value;
};

// BGetValueBin request
struct GetValueBinMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
    uint32_t bufferSize;
};

// BSetValueBin request
struct SetValueBinMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
    uint32_t dataSize;
    // uint8_t data[dataSize];
};

// BDeleteValue request
struct DeleteValueMsg {
    uint32_t hRoot;
    // char keyPath[];
    // char valueName[];
};

// BDeleteKey request
struct DeleteKeyMsg {
    uint32_t hRoot;
    // char keyPath[];
};

// BKeyExists request
struct KeyExistsMsg {
    uint32_t hRoot;
    // char keyPath[];
};

// BEnumerateKey request
struct EnumerateKeyMsg {
    uint32_t hRoot;
    uint8_t  recurse;       // Boolean
    uint32_t index;
    uint32_t bufferSize;
};

// BEnumerateValue request
struct EnumerateValueMsg {
    uint32_t hRoot;
    // char keyPath[];
    uint32_t index;
    uint32_t nameBufferSize;
};

} // namespace Registry

//=============================================================================
// Type 4: IClientProcessMonitor Messages
//=============================================================================
namespace ProcessMonitor {

// RegisterProcess request
struct RegisterProcessMsg {
    uint32_t processId;
};

// UnregisterProcess request
struct UnregisterProcessMsg {
    uint32_t processId;
};

// TerminateProcess request
struct TerminateProcessMsg {
    uint32_t processId;
    uint32_t exitCode;
};

// SuspendProcess request
struct SuspendProcessMsg {
    uint32_t processId;
};

// ResumeProcess request
struct ResumeProcessMsg {
    uint32_t processId;
};

} // namespace ProcessMonitor

//=============================================================================
// Type 5: IClientSecureDesktop Messages
// (No additional parameters - just magic)
//=============================================================================
namespace SecureDesktop {
    // BStartStreaming - no params
    // StopStreaming - no params
    // SendSAS - no params
}

//=============================================================================
// Type 6: IClientWindowsHWMonitor Messages
// (No additional parameters - just magic)
//=============================================================================
namespace HWMonitor {
    // StartMonitoring - no params
    // StopMonitoring - no params
    // RefreshInformation - no params
    // GetCPUTemperature - returns int32_t
}

} // namespace IPC

```

`include/ipc/parser.h`:

```h
#pragma once
#include "types.h"
#include "buffer.h"
#include "messages.h"

namespace IPC {

//=============================================================================
// Name Lookup Functions
//=============================================================================
const char* GetDispatchTypeName(uint8_t type);
const char* GetMethodName(uint8_t dispatchType, uint32_t magic);

// Per-interface method name lookups
const char* GetInstallUtilsMethodName(uint32_t magic);
const char* GetModuleManagerMethodName(uint32_t magic);
const char* GetRegistryMethodName(uint32_t magic);
const char* GetProcessMonitorMethodName(uint32_t magic);
const char* GetSecureDesktopMethodName(uint32_t magic);
const char* GetHWMonitorMethodName(uint32_t magic);

//=============================================================================
// Message Parser - Parses and logs full message content
//=============================================================================
class MessageParser {
public:
    // Parse and log a complete IPC message
    static void ParseAndLog(const uint8_t* data, size_t size);

private:
    // Per-interface parsers
    static void ParseInstallUtilsMsg(uint32_t magic, BufferReader& reader);
    static void ParseModuleManagerMsg(uint32_t magic, BufferReader& reader);
    static void ParseRegistryMsg(uint32_t magic, BufferReader& reader);
    static void ParseProcessMonitorMsg(uint32_t magic, BufferReader& reader);
    static void ParseSecureDesktopMsg(uint32_t magic, BufferReader& reader);
    static void ParseHWMonitorMsg(uint32_t magic, BufferReader& reader);

    // Helper to read and log a string from buffer
    static bool ReadAndLogString(BufferReader& reader, const char* fieldName);
};

} // namespace IPC

```

`include/ipc/types.h`:

```h
#pragma once
#include <cstdint>

namespace IPC {

//=============================================================================
// Dispatch Types (first byte of IPC message)
//=============================================================================
enum DispatchType : uint8_t {
    TYPE_INSTALL_UTILS     = 1,  // IClientInstallUtils
    TYPE_MODULE_MANAGER    = 2,  // IClientModuleManager (VAC)
    TYPE_REGISTRY          = 3,  // IRegistryInterface
    TYPE_PROCESS_MONITOR   = 4,  // IClientProcessMonitor
    TYPE_SECURE_DESKTOP    = 5,  // IClientSecureDesktop
    TYPE_HW_MONITOR        = 6,  // IClientWindowsHWMonitor
};

//=============================================================================
// Type 1: IClientInstallUtils Magic Values
//=============================================================================
namespace InstallUtils {
    enum Magic : uint32_t {
        RUN_INSTALL_SCRIPT   = 0x1B7449C5,
    };
}

//=============================================================================
// Type 2: IClientModuleManager (VAC) Magic Values
//=============================================================================
namespace ModuleManager {
    enum Magic : uint32_t {
        LOAD_MODULE          = 0x24DF160F,
        UNLOAD_MODULE        = 0xD2CB05FD,
        CALL_FUNCTION        = 0xFDD7BB75,
        CALL_FUNCTION_ASYNC  = 0x7D2F2539,
        POLL_RESPONSE_ASYNC  = 0x59815F75,
        SET_PROTON_ENV       = 0xFE43DF34,
    };
}

//=============================================================================
// Type 3: IRegistryInterface Magic Values
//=============================================================================
namespace Registry {
    enum Magic : uint32_t {
        GET_VALUE_STR       = 0x34F301FB,
        GET_VALUE_STR_ALT   = 0xA160B500,
        GET_VALUE_UINT      = 0x23F82EF0,
        GET_VALUE_UINT64    = 0x3243D6A8,
        GET_VALUE_BIN       = 0x4C016FF1,
        SET_VALUE_STR       = 0x042EEA2D,
        SET_VALUE_UINT      = 0x91E95B0E,
        SET_VALUE_UINT64    = 0xD4484796,
        SET_VALUE_BIN       = 0xC6313E8A,
        DELETE_VALUE        = 0x78D4E725,
        DELETE_KEY          = 0x6C6CE4DB,
        KEY_EXISTS          = 0x26C8CADA,
        ENUMERATE_KEY       = 0x5B426CC8,
        ENUMERATE_VALUE     = 0x4C271288,
    };

    // Alternate small magic values (used in some messages)
    enum MagicAlt : uint8_t {
        ALT_GET_VALUE_STR     = 0x81,
        ALT_GET_VALUE_STR2    = 0x8B,
        ALT_GET_VALUE_UINT    = 0x94,
        ALT_GET_VALUE_UINT64  = 0x9D,
        ALT_GET_VALUE_BIN     = 0xA6,
        ALT_SET_VALUE_STR     = 0xB1,
        ALT_SET_VALUE_UINT    = 0xB2,
        ALT_SET_VALUE_UINT64  = 0xB3,
        ALT_SET_VALUE_BIN     = 0xB5,
        ALT_DELETE_VALUE      = 0xBE,
        ALT_DELETE_KEY        = 0xBF,
        ALT_KEY_EXISTS        = 0xC0,
        ALT_ENUMERATE_KEY     = 0xC2,
        ALT_ENUMERATE_VALUE   = 0xCC,
    };
}

//=============================================================================
// Type 4: IClientProcessMonitor Magic Values
//=============================================================================
namespace ProcessMonitor {
    enum Magic : uint32_t {
        REGISTER_PROCESS     = 0xAC8F3AC5,
        UNREGISTER_PROCESS   = 0x32F5547A,
        TERMINATE_PROCESS    = 0x4249BA42,
        SUSPEND_PROCESS      = 0x4D61F91A,
        RESUME_PROCESS       = 0x86C783C7,
    };

    enum MagicAlt : uint8_t {
        ALT_REGISTER_PROCESS   = 0xDE,
        ALT_UNREGISTER_PROCESS = 0xDF,
        ALT_TERMINATE_PROCESS  = 0xE0,
        ALT_SUSPEND_PROCESS    = 0xE1,
        ALT_RESUME_PROCESS     = 0xE2,
    };
}

//=============================================================================
// Type 5: IClientSecureDesktop Magic Values
//=============================================================================
namespace SecureDesktop {
    enum Magic : uint32_t {
        START_STREAMING = 0xF6F2E90B,
        STOP_STREAMING  = 0x89C744EF,
        SEND_SAS        = 0xF7A93F72,
    };

    enum MagicAlt : uint8_t {
        ALT_START_STREAMING = 0xEB,
        ALT_STOP_STREAMING  = 0xEC,
        ALT_SEND_SAS        = 0xED,
    };
}

//=============================================================================
// Type 6: IClientWindowsHWMonitor Magic Values
//=============================================================================
namespace HWMonitor {
    enum Magic : uint32_t {
        START_MONITORING     = 0x676A4541,
        STOP_MONITORING      = 0x4B4D73AB,
        REFRESH_INFORMATION  = 0xB1F6FDC4,
        GET_CPU_TEMPERATURE  = 0xB86FF113,
    };

    enum MagicAlt : uint8_t {
        ALT_START_MONITORING    = 0xF8,
        ALT_STOP_MONITORING     = 0xF9,
        ALT_REFRESH_INFORMATION = 0xFB,
        ALT_GET_CPU_TEMPERATURE = 0xFC,
    };
}

} // namespace IPC

```

`include/ipc_parser.h`:

```h
#pragma once
#include "common.h"

namespace IPCParser {

// Parsed request structures
struct LoadModuleRequest {
    uint32_t moduleId;
    uint32_t moduleSize;
    const void* moduleData;
};

struct UnloadModuleRequest {
    uint32_t moduleId;
};

struct CallFunctionRequest {
    uint32_t moduleId;
    uint32_t functionId;
    uint32_t param;
    uint32_t inputSize;
    const void* inputData;
    uint32_t outputBufferSize;
};

struct CallFunctionAsyncRequest {
    uint32_t clientHandle;
    uint32_t moduleId;
    uint32_t functionId;
    uint32_t param;
    uint32_t unknown1;
    uint32_t inputSize;
    const void* inputData;
    uint32_t outputBufferSize;
};

// Parse and log requests
void ParseAndLogRequest(uint32_t magic, const uint8_t* data, size_t dataSize);

// Parse specific request types
bool ParseLoadModule(const uint8_t* data, size_t size, LoadModuleRequest& out);
bool ParseUnloadModule(const uint8_t* data, size_t size, UnloadModuleRequest& out);
bool ParseCallFunction(const uint8_t* data, size_t size, CallFunctionRequest& out);
bool ParseCallFunctionAsync(const uint8_t* data, size_t size, CallFunctionAsyncRequest& out);

} // namespace IPCParser

```

`include/ipc_types.h`:

```h
#pragma once
#include <cstdint>

//=============================================================================
// Steam IPC Interface Types and Magic Values
// Reversed from SteamService.dll
//=============================================================================

namespace SteamIPC {

//-----------------------------------------------------------------------------
// IPC Dispatch Types (first byte of message)
//-----------------------------------------------------------------------------
enum class DispatchType : uint8_t {
    InstallUtils      = 1,  // IClientInstallUtils
    ModuleManager     = 2,  // IClientModuleManager (VAC)
    Registry          = 3,  // IRegistryInterface
    ProcessMonitor    = 4,  // IClientProcessMonitor
    SecureDesktop     = 5,  // IClientSecureDesktop
    WindowsHWMonitor  = 6,  // IClientWindowsHWMonitor
};

//-----------------------------------------------------------------------------
// Type 2: IClientModuleManager (VAC) - 0x100549E0
//-----------------------------------------------------------------------------
namespace ModuleManager {
    enum Magic : uint32_t {
        LoadModule         = 0x24DF160F,
        UnloadModule       = 0xD2CB05FD,
        CallFunction       = 0xFDD7BB75,
        CallFunctionAsync  = 0x7D2F2539,
        PollResponseAsync  = 0x59815F75,
        SetProtonEnv       = 0xFE43DF34,
    };

    // Fence offsets for validation
    enum Fence : uint32_t {
        FenceLoadModule        = 1274445,
        FenceUnloadModule      = 1322832,
        FenceCallFunction      = 1484122,
        FenceCallFunctionAsync = 1726057,
        FencePollResponseAsync = 1855089,
        FenceAlt               = 254,
    };
}

//-----------------------------------------------------------------------------
// Type 3: IRegistryInterface - 0x100563D0
//-----------------------------------------------------------------------------
namespace Registry {
    enum Magic : uint32_t {
        BGetValueStr      = 0x34F301FB,
        BGetValueStrAlt   = 0xA160B500,
        BGetValueUint     = 0x23F82EF0,
        BGetValueUint64   = 0x3243D6A8,
        BGetValueBin      = 0x4C016FF1,
        BSetValueStr      = 0x042EEA2D,
        BSetValueUint     = 0x91E95B0E,
        BSetValueUint64   = 0xD4484796,
        BSetValueBin      = 0xC6313E8A,
        BDeleteValue      = 0x78D4E725,
        BDeleteKey        = 0x6C6CE4DB,
        BKeyExists        = 0x26C8CADA,
        BEnumerateKey     = 0x5B426CC8,
        BEnumerateValue   = 0x4C271288,
    };

    // Alternate small magic values
    enum MagicAlt : uint8_t {
        AltBGetValueStr      = 0x81,
        AltBGetValueStrAlt   = 0x8B,
        AltBGetValueUint     = 0x94,
        AltBGetValueUint64   = 0x9D,
        AltBGetValueBin      = 0xA6,
        AltBSetValueStr      = 0xB1,
        AltBSetValueUint     = 0xB2,
        AltBSetValueUint64   = 0xB3,
        AltBSetValueBin      = 0xB5,
        AltBDeleteValue      = 0xBE,
        AltBDeleteKey        = 0xBF,
        AltBKeyExists        = 0xC0,
        AltBEnumerateKey     = 0xC2,
        AltBEnumerateValue   = 0xCC,
    };
}

//-----------------------------------------------------------------------------
// Type 4: IClientProcessMonitor - 0x100555E0
//-----------------------------------------------------------------------------
namespace ProcessMonitor {
    enum Magic : uint32_t {
        RegisterProcess   = 0xAC8F3AC5,
        UnregisterProcess = 0x32F5547A,
        TerminateProcess  = 0x4249BA42,
        SuspendProcess    = 0x4D61F91A,
        ResumeProcess     = 0x86C783C7,
    };

    enum MagicAlt : uint8_t {
        AltRegisterProcess   = 0xDE,
        AltUnregisterProcess = 0xDF,
        AltTerminateProcess  = 0xE0,
        AltSuspendProcess    = 0xE1,
        AltResumeProcess     = 0xE2,
    };
}

//-----------------------------------------------------------------------------
// Type 5: IClientSecureDesktop - 0x10055C00
//-----------------------------------------------------------------------------
namespace SecureDesktop {
    enum Magic : uint32_t {
        BStartStreaming = 0xF6F2E90B,
        StopStreaming   = 0x89C744EF,
        SendSAS         = 0xF7A93F72,
    };

    enum MagicAlt : uint8_t {
        AltBStartStreaming = 0xEB,
        AltStopStreaming   = 0xEC,
        AltSendSAS         = 0xED,
    };
}

//-----------------------------------------------------------------------------
// Type 6: IClientWindowsHWMonitor - 0x10055F80
//-----------------------------------------------------------------------------
namespace HWMonitor {
    enum Magic : uint32_t {
        StartMonitoring    = 0x676A4541,
        StopMonitoring     = 0x4B4D73AB,
        RefreshInformation = 0xB1F6FDC4,
        GetCPUTemperature  = 0xB86FF113,
    };

    enum MagicAlt : uint8_t {
        AltStartMonitoring    = 0xF8,
        AltStopMonitoring     = 0xF9,
        AltRefreshInformation = 0xFB,
        AltGetCPUTemperature  = 0xFC,
    };
}

//-----------------------------------------------------------------------------
// Type 1: IClientInstallUtils - 0x10052CA0
// (Partial - many methods)
//-----------------------------------------------------------------------------
namespace InstallUtils {
    // Method names found in binary (magic values TBD from traffic capture):
    // - RunInstallScript
    // - GetInstallScriptExitCode
    // - AddUninstallEntry
    // - RemoveUninstallEntry
    // - InstallXboxDriver
    // - UninstallXboxDriver
    // - InstallStreamingAudioDrivers
    // - AddInstallScriptToWhiteList
}

//-----------------------------------------------------------------------------
// CUtlBuffer Structure (Steam's buffer class)
//-----------------------------------------------------------------------------
#pragma pack(push, 1)
struct CUtlBuffer {
    void*    m_pData;       // +0x00: Pointer to buffer data
    uint32_t m_nCapacity;   // +0x04: Buffer capacity
    uint32_t m_nMaxPut;     // +0x08: Max write position
    uint32_t m_nGetPos;     // +0x0C: Current read position
    uint32_t m_nPutPos;     // +0x10: Current write position
    uint32_t m_nDataSize;   // +0x14: Total data size
    uint8_t  m_Reserved[2]; // +0x18: Reserved
    uint8_t  m_nErrorFlags; // +0x1A: Error flags
    uint8_t  m_nModeFlags;  // +0x1B: Mode flags (text/binary)
};
#pragma pack(pop)

//-----------------------------------------------------------------------------
// Helper Functions
//-----------------------------------------------------------------------------
inline const char* GetDispatchTypeName(uint8_t type) {
    switch (type) {
        case 1: return "IClientInstallUtils";
        case 2: return "IClientModuleManager";
        case 3: return "IRegistryInterface";
        case 4: return "IClientProcessMonitor";
        case 5: return "IClientSecureDesktop";
        case 6: return "IClientWindowsHWMonitor";
        default: return "Unknown";
    }
}

inline const char* GetModuleManagerMethod(uint32_t magic) {
    switch (magic) {
        case ModuleManager::LoadModule:        return "LoadModule";
        case ModuleManager::UnloadModule:      return "UnloadModule";
        case ModuleManager::CallFunction:      return "CallFunction";
        case ModuleManager::CallFunctionAsync: return "CallFunctionAsync";
        case ModuleManager::PollResponseAsync: return "PollResponseAsync";
        case ModuleManager::SetProtonEnv:      return "SetProtonEnv";
        default: return "Unknown";
    }
}

inline const char* GetRegistryMethod(uint32_t magic) {
    switch (magic) {
        case Registry::BGetValueStr:
        case Registry::BGetValueStrAlt:    return "BGetValueStr";
        case Registry::BGetValueUint:      return "BGetValueUint";
        case Registry::BGetValueUint64:    return "BGetValueUint64";
        case Registry::BGetValueBin:       return "BGetValueBin";
        case Registry::BSetValueStr:       return "BSetValueStr";
        case Registry::BSetValueUint:      return "BSetValueUint";
        case Registry::BSetValueUint64:    return "BSetValueUint64";
        case Registry::BSetValueBin:       return "BSetValueBin";
        case Registry::BDeleteValue:       return "BDeleteValue";
        case Registry::BDeleteKey:         return "BDeleteKey";
        case Registry::BKeyExists:         return "BKeyExists";
        case Registry::BEnumerateKey:      return "BEnumerateKey";
        case Registry::BEnumerateValue:    return "BEnumerateValue";
        default: return "Unknown";
    }
}

inline const char* GetProcessMonitorMethod(uint32_t magic) {
    switch (magic) {
        case ProcessMonitor::RegisterProcess:   return "RegisterProcess";
        case ProcessMonitor::UnregisterProcess: return "UnregisterProcess";
        case ProcessMonitor::TerminateProcess:  return "TerminateProcess";
        case ProcessMonitor::SuspendProcess:    return "SuspendProcess";
        case ProcessMonitor::ResumeProcess:     return "ResumeProcess";
        default: return "Unknown";
    }
}

inline const char* GetSecureDesktopMethod(uint32_t magic) {
    switch (magic) {
        case SecureDesktop::BStartStreaming: return "BStartStreaming";
        case SecureDesktop::StopStreaming:   return "StopStreaming";
        case SecureDesktop::SendSAS:         return "SendSAS";
        default: return "Unknown";
    }
}

inline const char* GetHWMonitorMethod(uint32_t magic) {
    switch (magic) {
        case HWMonitor::StartMonitoring:    return "StartMonitoring";
        case HWMonitor::StopMonitoring:     return "StopMonitoring";
        case HWMonitor::RefreshInformation: return "RefreshInformation";
        case HWMonitor::GetCPUTemperature:  return "GetCPUTemperature";
        default: return "Unknown";
    }
}

} // namespace SteamIPC

```

`include/logger.h`:

```h
#pragma once
#include "common.h"

namespace Logger {
    void Init(const std::string& logPath);
    void Shutdown();

    void Log(const char* format, ...);
    void LogHex(const char* prefix, const void* data, size_t size);
    void LogIPCRequest(uint32_t magic, const void* buffer, size_t size);
    void LogIPCResponse(uint32_t magic, const void* buffer, size_t size);

    // Flush immediately (for crash safety)
    void Flush();
}

```

`include/module/manager.h`:

```h
#pragma once
#include "module/types.h"
#include <cstdint>
#include <map>
#include <vector>

namespace Module {

//=============================================================================
// Module Manager - Tracks emulated VAC modules
//=============================================================================
class Manager {
public:
    static Manager& Instance();

    // Module lifecycle
    bool LoadModule(uint32_t moduleId, uint32_t moduleSize, const uint8_t* moduleData = nullptr);
    bool UnloadModule(uint32_t moduleId);
    bool IsModuleLoaded(uint32_t moduleId) const;

    // Synchronous execution
    ErrorCode CallFunction(uint32_t moduleId, uint32_t functionId, uint32_t param,
                          const uint8_t* inputData, uint32_t inputSize,
                          uint8_t* outputData, uint32_t outputSize, uint32_t* resultSize);

    // Asynchronous execution
    ErrorCode CallFunctionAsync(uint32_t clientHandle, uint32_t moduleId,
                               uint32_t functionId, uint32_t param,
                               const uint8_t* inputData, uint32_t inputSize,
                               uint32_t outputSize);

    ErrorCode PollAsyncResult(uint32_t* outClientHandle,
                             uint8_t* outputData, uint32_t outputSize,
                             uint32_t* resultSize, uint32_t maxWaitMs);

    // Stats
    size_t GetLoadedModuleCount() const { return m_modules.size(); }
    size_t GetPendingAsyncCount() const { return m_asyncResults.size(); }

private:
    Manager() = default;
    ~Manager() = default;
    Manager(const Manager&) = delete;
    Manager& operator=(const Manager&) = delete;

    // Emulated module tracking
    struct EmulatedModule {
        uint32_t moduleId;
        uint32_t moduleSize;
        uint64_t loadTime;
        bool     loaded;
        int32_t  lastResult;
    };

    std::map<uint32_t, EmulatedModule> m_modules;
    std::map<uint32_t, AsyncResult> m_asyncResults;
    uint32_t m_nextAsyncHandle = 1;
};

//=============================================================================
// Helper: Generate "clean" scan response
// VAC modules return detection data; we return empty = clean
//=============================================================================
struct CleanResponse {
    static constexpr int32_t RESULT_CLEAN = 1;  // Success, no detections
    static constexpr uint32_t OUTPUT_SIZE = 0;  // No output data

    // Build response buffer for CallFunction/PollResponseAsync
    // Format: result(4) + outputBuffer(requestedSize) + actualSize(4)
    static size_t Build(uint8_t* buffer, size_t bufferSize, uint32_t requestedOutputSize);
};

} // namespace Module

```

`include/module/types.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>

namespace Module {

//=============================================================================
// VAC Module Error Codes (from IDA reversing)
//=============================================================================
enum class ErrorCode : int32_t {
    SUCCESS             = 1,    // Module operation succeeded
    NO_RESULT_READY     = 0,    // Async: no result available yet
    MODULE_NOT_FOUND    = 2,    // Module ID not in loaded modules
    BUFFER_TOO_SMALL    = 5,    // Output buffer < 88 bytes minimum
    SIGNATURE_FAILED    = 11,   // RSA signature validation failed
    MODULE_DATA_MISSING = 12,   // Module PE data is null/empty
    EXECUTION_ERROR     = 13,   // Error during module execution
    TIMEOUT             = 14,   // Async thread not alive/timeout
    BUFFER_OVERFLOW     = 15,   // Result exceeds buffer capacity
    CALL_RESULT_NONE    = 16,   // Internal: no call result set
    MEMORY_INIT_FAILED  = 19,   // MemoryModule initialization failed
    DECOMPRESS_FAILED   = 21,   // Module decompression failed
    LOAD_FAILED         = 22,   // MemoryModule_LoadFromBuffer failed
    EXPORT_NOT_FOUND    = 23,   // _runfunc@20 export not found
    PROC_ADDR_FAILED    = 25,   // GetProcAddress failed
};

//=============================================================================
// VAC Module Structure (from IDA reversing CClientModuleManager)
// Size: ~44 bytes, stored in linked list at manager+0x2C
//=============================================================================
#pragma pack(push, 1)
struct ModuleInfo {
    uint32_t moduleId;          // +0x00: Unique module identifier
    void*    hMemModule;        // +0x04: MemoryModule handle (in-memory PE)
    void*    hLoadedDLL;        // +0x08: Alternative loaded DLL handle
    void*    pfnRunFunc;        // +0x0C: Pointer to _runfunc@20 entry point
    int32_t  resultCode;        // +0x10: Last execution result/status
    uint32_t moduleDataSize;    // +0x14: Size of raw module PE data
    void*    pModuleData;       // +0x18: Raw module PE data (RSA signed)
    uint32_t reserved1;         // +0x1C: Reserved/padding
    uint64_t loadTimestamp;     // +0x20: When module was loaded (QPC)
    char*    legacyDllPath;     // +0x28: Path for legacy compat execution
};
#pragma pack(pop)

//=============================================================================
// _runfunc@20 - VAC Module Entry Point Signature
// This is the function exported by all VAC modules
//=============================================================================
// Signature: int __stdcall _runfunc(void* in, uint32_t inSize,
//                                   void* out, uint32_t outSize, uint32_t* resultSize)
typedef int (__stdcall *RunFuncPtr)(
    void*     inputBuffer,      // Scan parameters/targets
    uint32_t  inputSize,        // Size of input data
    void*     outputBuffer,     // Detection results
    uint32_t  outputSize,       // Output buffer capacity (min 88 bytes)
    uint32_t* resultSize        // Actual output size written
);

//=============================================================================
// Minimum Output Buffer Size
// From IDA: CClientModuleManager_RunModule checks a8 < 0x58
//=============================================================================
constexpr uint32_t MIN_OUTPUT_BUFFER_SIZE = 0x58;  // 88 bytes

//=============================================================================
// IPC Fencepost Validation Values
// Used for message integrity checking: expected = magic + offset
//=============================================================================
namespace Fencepost {
    constexpr uint32_t LOAD_MODULE          = 0x137A4D;  // 1276493
    constexpr uint32_t UNLOAD_MODULE        = 0x142DF0;  // 1322832
    constexpr uint32_t CALL_FUNCTION        = 0x16A55A;  // 1484122
    constexpr uint32_t CALL_FUNCTION_ASYNC  = 0x1A5469;  // 1726057
    constexpr uint32_t POLL_RESPONSE_ASYNC  = 0x1C5271;  // 1855089
    constexpr uint32_t SET_PROTON_ENV       = 0x1D8A76;  // 1935734
    constexpr uint32_t FALLBACK             = 0xFE;     // 254 (alternate validation)
}

//=============================================================================
// Async Work Item States
//=============================================================================
enum class AsyncState : uint32_t {
    PENDING     = 0,    // Queued, not started
    RUNNING     = 1,    // Currently executing
    COMPLETED   = 2,    // Finished with result
    FAILED      = 3,    // Execution failed
};

//=============================================================================
// Async Call Result (from CClientModuleManagerAsync_GetResult)
//=============================================================================
struct AsyncResult {
    uint32_t    clientHandle;   // Handle provided by caller
    uint32_t    moduleId;       // Which module was called
    uint32_t    functionId;     // Which function (usually 0)
    int32_t     resultCode;     // Execution result (ErrorCode)
    void*       outputData;     // Result data buffer
    uint32_t    outputSize;     // Actual result size
    AsyncState  state;          // Current state
};

} // namespace Module

```

`include/utils/disasm.h`:

```h
#pragma once
#include <cstdint>
#include <string>
#include <vector>

namespace Disasm {

//=============================================================================
// Decoded Instruction
//=============================================================================
struct Instruction {
    uint64_t address;
    uint8_t  length;
    char     mnemonic[32];
    char     operands[128];
    uint8_t  bytes[15];
};

//=============================================================================
// Disassembler - Zydis wrapper for x86 disassembly
//=============================================================================
class Disassembler {
public:
    Disassembler();
    ~Disassembler();

    // Disassemble a single instruction
    bool DisassembleOne(const uint8_t* code, size_t size, uint64_t address, Instruction& out);

    // Disassemble multiple instructions
    std::vector<Instruction> Disassemble(const uint8_t* code, size_t size, uint64_t address, size_t maxInstructions = 50);

    // Format instruction as string
    static std::string Format(const Instruction& insn);

    // Log disassembly to logger
    static void LogDisassembly(const uint8_t* code, size_t size, uint64_t address, size_t maxInstructions = 20);

    // Log function prologue (first N instructions)
    static void LogFunctionPrologue(void* funcAddr, size_t maxInstructions = 10);

private:
    void* m_decoder;    // ZydisDecoder
    void* m_formatter;  // ZydisFormatter
    bool  m_initialized;
};

//=============================================================================
// Global Disassembler Instance
//=============================================================================
Disassembler& GetDisassembler();

} // namespace Disasm

```

`include/utils/logger.h`:

```h
#pragma once
#include <cstdint>
#include <cstdio>
#include <cstdarg>
#include <windows.h>

namespace Logger {

//=============================================================================
// Logger - Thread-safe file logging
//=============================================================================
void Init(const char* logPath);
void Shutdown();

// Logging functions
void Log(const char* fmt, ...);
void LogHex(const char* prefix, const uint8_t* data, size_t len, size_t maxLen = 128);
void LogIndent(int level, const char* fmt, ...);

// Flush immediately (for crash safety)
void Flush();

// Get log file handle (for direct writes)
FILE* GetFile();

} // namespace Logger

```

`include/utils/sigscan.h`:

```h
#pragma once
#include <cstdint>
#include <windows.h>

namespace SigScan {

//=============================================================================
// Pattern Scanning
// Supports ?? wildcards for unknown bytes
// Example: "55 8B EC 83 EC ?? 53 56"
//=============================================================================

// Scan for pattern in module, returns address or 0 if not found
uintptr_t FindPattern(uintptr_t moduleBase, size_t moduleSize, const char* pattern);

// Scan for pattern in a specific module by name
uintptr_t FindPatternInModule(const char* moduleName, const char* pattern);

// Scan SteamService.dll specifically
uintptr_t FindInSteamService(const char* pattern);

//=============================================================================
// VAC Function Signatures
// These patterns are more reliable than hardcoded offsets
//=============================================================================
namespace Signatures {
    // CServiceEngine_IPC_ParentDispatch - main IPC entry
    // push ebp; mov ebp,esp; push ebx; push esi; mov esi,[ebp+8]; push edi; mov edi,ecx; mov ecx,esi
    constexpr const char* PARENT_DISPATCH =
        "55 8B EC 53 56 8B 75 08 57 8B F9 8B CE";

    // IClientModuleManager_IPC_Dispatch - VAC module manager dispatcher
    // push ebp; mov ebp,esp; sub esp,68h; push ebx; push esi; push edi; mov edi,[ebp+0Ch]
    constexpr const char* IPC_DISPATCH =
        "55 8B EC 83 EC 68 53 56 57 8B 7D 0C 8D 45 F4 6A 04";

    // CClientModuleManager_RunModule - synchronous module execution
    // push ebp; mov ebp,esp; push -1; push SEH_handler; push except_handler3; mov eax,fs:[0]
    constexpr const char* RUN_MODULE =
        "55 8B EC 6A FF 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68";

    // CClientModuleManager_RunModuleAsync - async module execution
    // push ebp; mov ebp,esp; push ebx; push edi; mov edi,ecx; mov ecx,[edi+290h]
    constexpr const char* RUN_MODULE_ASYNC =
        "55 8B EC 53 57 8B F9 8B 8F ?? ?? 00 00 85 C9 75 ?? 6A 50";

    // CClientModuleManager_LoadAndValidateModule - loads module and resolves _runfunc@20
    // push ebp; mov ebp,esp; sub esp,24h; push ebx; push esi; mov esi,[ebp+8]; mov ebx,ecx
    constexpr const char* LOAD_VALIDATE =
        "55 8B EC 83 EC 24 53 56 8B 75 08 8B D9 83 7E 0C 00";

    // Module_ValidateSignature - RSA signature verification
    // push ebp; mov ebp,esp; push ds:rsa_key; push offset pubkey; push [ebp+0Ch]; push [ebp+8]; call verify
    constexpr const char* VALIDATE_SIGNATURE =
        "55 8B EC FF 35 ?? ?? ?? ?? 68 ?? ?? ?? ?? FF 75 0C FF 75 08 E8";

    // MemoryModule_LoadFromBuffer - in-memory PE loader
    // Look for reference to MemoryDefaultAlloc string or characteristic pattern
    constexpr const char* MEMORY_MODULE_LOAD =
        "55 8B EC 83 EC ?? 53 56 57 8B 7D ?? 85 FF 0F 84";

    // MemoryModule_GetProcAddress
    constexpr const char* MEMORY_MODULE_GET_PROC =
        "55 8B EC 8B 45 08 8B 48 3C 03 C8";
}

} // namespace SigScan

```

`libs/minhook-1.3.3/AUTHORS.txt`:

```txt
Tsuda Kageyu <tsuda.kageyu@gmail.com>
 Creator, maintainer

Michael Maltsev <leahcimmar@gmail.com>
 Added "Queue" functions. A lot of bug fixes.

Andrey Unis <uniskz@gmail.com>
 Rewrote the hook engine in plain C.

```

`libs/minhook-1.3.3/LICENSE.txt`:

```txt
MinHook - The Minimalistic API Hooking Library for x64/x86
Copyright (C) 2009-2017 Tsuda Kageyu.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

================================================================================
Portions of this software are Copyright (c) 2008-2009, Vyacheslav Patkov.
================================================================================
Hacker Disassembler Engine 32 C
Copyright (c) 2008-2009, Vyacheslav Patkov.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-------------------------------------------------------------------------------
Hacker Disassembler Engine 64 C
Copyright (c) 2008-2009, Vyacheslav Patkov.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`libs/minhook-1.3.3/README.md`:

```md
# MinHook

[![License](https://img.shields.io/badge/License-BSD%202--Clause-orange.svg)](https://opensource.org/licenses/BSD-2-Clause)

The Minimalistic x86/x64 API Hooking Library for Windows

http://www.codeproject.com/KB/winsdk/LibMinHook.aspx

### Donation please

I need some funds to continue developing this library. All contributions gratefully accepted.

<a href='https://pledgie.com/campaigns/27314'><img alt='Click here to lend your support to: MinHook - Help me continue to develop this library and make a donation at pledgie.com !' src='https://pledgie.com/campaigns/27314.png?skin_name=chrome' border='0' ></a>

### Version history

- ####v1.3.3 - 8 Jan 2017
  * Added a helper function ```MH_CreateHookApiEx```. (Thanks to asm256)
  * Support Visual Studio 2017 RC.

- ####v1.3.2.1 - 9 Nov 2015  (Nuget package only)
  * Fixed an insufficient support for Visual Studio 2015.

- ####v1.3.2 - 1 Nov 2015
  * Support Visual Studio 2015.
  * Support MinGW.

- ####v1.3.2-beta3 - 21 Jul 2015  (Nuget package only)
  * Support MinGW. (Experimental)

- ####v1.3.2-beta2 - 18 May 2015
  * Fixed some subtle bugs. (Thanks to RaMMicHaeL)
  * Added a helper function ```MH_StatusToString```. (Thanks to Jan Klass)

- ####v1.3.2-beta - 12 May 2015
  * Fixed a possible thread deadlock in x64 mode. (Thanks to Aleh Kazakevich)
  * Reduced the footprint a little more.
  * Support Visual Studio 2015 RC. (Experimental)

- ####v1.3.1.1 - 7 Apr 2015  (Nuget package only)
  * Support for WDK8.0 and 8.1.

- ####v1.3.1 - 19 Mar 2015
  * No major changes from v1.3.1-beta.

- ####v1.3.1-beta - 11 Mar 2015
  * Added a helper function ```MH_CreateHookApi```. (Thanks to uniskz).
  * Fixed a false memory leak reported by some tools.
  * Fixed a degradated compatibility issue. 

- ####v1.3 - 13 Sep 2014
  * No major changes from v1.3-beta3.

- ####v1.3-beta3 - 31 Jul 2014

  * Fixed some small bugs.
  * Improved the memory management.

- ####v1.3-beta2 - 21 Jul 2014

  * Changed the parameters to Windows-friendly types. (void* to LPVOID)
  * Fixed some small bugs.
  * Reorganized the source files.
  * Reduced the footprint a little more.

- ####v1.3-beta - 17 Jul 2014

  * Rewrote in plain C to reduce the footprint and memory usage. (suggested by Andrey Unis)
  * Simplified the overall code base to make it more readable and maintainable.
  * Changed the license from 3-clause to 2-clause BSD License.

- ####v1.2 - 28 Sep 2013
 
  * Removed boost dependency ([jarredholman](https://github.com/jarredholman/minhook)).
  * Fixed a small bug in the GetRelativeBranchDestination function ([pillbug99](http://www.codeproject.com/Messages/4058892/Small-Bug-Found.aspx)).
  * Added the ```MH_RemoveHook``` function, which removes a hook created with the ```MH_CreateHook``` function.
  * Added the following functions to enable or disable multiple hooks in one go: ```MH_QueueEnableHook```, ```MH_QueueDisableHook```, ```MH_ApplyQueued```. This is the preferred way of handling multiple hooks as every call to `MH_EnableHook` or `MH_DisableHook` suspends and resumes all threads.
  * Made the functions ```MH_EnableHook``` and ```MH_DisableHook``` enable/disable all created hooks when the ```MH_ALL_HOOKS``` parameter is passed. This, too, is an efficient way of handling multiple hooks.
  * If the target function is too small to be patched with a jump, MinHook tries to place the jump above the function. If that fails as well, the ```MH_CreateHook``` function returns ```MH_ERROR_UNSUPPORTED_FUNCTION```. This fixes an issue of hooking the LoadLibraryExW function on Windows 7 x64 ([reported by Obble](http://www.codeproject.com/Messages/4578613/Re-Bug-LoadLibraryExW-hook-fails-on-windows-2008-r.aspx)).

- ####v1.1 - 26 Nov 2009

  * Changed the interface to create a hook and a trampoline function in one go to prevent the detour function from being called before the trampoline function is created. ([reported by xliqz](http://www.codeproject.com/Messages/3280374/Unsafe.aspx))
  * Shortened the function names from ```MinHook_*``` to ```MH_*``` to make them handier.

- ####v1.0 - 22 Nov 2009
 
  * Initial release.

```

`libs/minhook-1.3.3/dll_resources/MinHook.def`:

```def
EXPORTS
    MH_Initialize
    MH_Uninitialize

    MH_CreateHook
    MH_CreateHookApi
    MH_CreateHookApiEx
    MH_RemoveHook
    MH_EnableHook
    MH_DisableHook
    MH_QueueEnableHook
    MH_QueueDisableHook
    MH_ApplyQueued
    MH_StatusToString

```

`libs/minhook-1.3.3/dll_resources/MinHook.rc`:

```rc
1 VERSIONINFO
 FILEVERSION 1,3,3,0
 PRODUCTVERSION 1,3,3,0
 FILEFLAGSMASK 0x17L
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Tsuda Kageyu"
            VALUE "FileDescription", "MinHook - The Minimalistic API Hook Library for x64/x86"
            VALUE "FileVersion", "1.3.3.0"
            VALUE "InternalName", "MinHookD"
            VALUE "LegalCopyright", "Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved."
            VALUE "LegalTrademarks", "Tsuda Kageyu"
            VALUE "ProductName", "MinHook DLL"
            VALUE "ProductVersion", "1.3.3.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

```

`libs/minhook-1.3.3/include/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`libs/minhook-1.3.3/src/buffer.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include "buffer.h"

// Size of each memory block. (= page size of VirtualAlloc)
#define MEMORY_BLOCK_SIZE 0x1000

// Max range for seeking a memory block. (= 1024MB)
#define MAX_MEMORY_RANGE 0x40000000

// Memory protection flags to check the executable address.
#define PAGE_EXECUTE_FLAGS \
    (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

// Memory slot.
typedef struct _MEMORY_SLOT
{
    union
    {
        struct _MEMORY_SLOT *pNext;
        UINT8 buffer[MEMORY_SLOT_SIZE];
    };
} MEMORY_SLOT, *PMEMORY_SLOT;

// Memory block info. Placed at the head of each block.
typedef struct _MEMORY_BLOCK
{
    struct _MEMORY_BLOCK *pNext;
    PMEMORY_SLOT pFree;         // First element of the free slot list.
    UINT usedCount;
} MEMORY_BLOCK, *PMEMORY_BLOCK;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// First element of the memory block list.
PMEMORY_BLOCK g_pMemoryBlocks;

//-------------------------------------------------------------------------
VOID InitializeBuffer(VOID)
{
    // Nothing to do for now.
}

//-------------------------------------------------------------------------
VOID UninitializeBuffer(VOID)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    g_pMemoryBlocks = NULL;

    while (pBlock)
    {
        PMEMORY_BLOCK pNext = pBlock->pNext;
        VirtualFree(pBlock, 0, MEM_RELEASE);
        pBlock = pNext;
    }
}

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindPrevFreeRegion(LPVOID pAddress, LPVOID pMinAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the previous allocation granularity multiply.
    tryAddr -= dwAllocationGranularity;

    while (tryAddr >= (ULONG_PTR)pMinAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        if ((ULONG_PTR)mbi.AllocationBase < dwAllocationGranularity)
            break;

        tryAddr = (ULONG_PTR)mbi.AllocationBase - dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindNextFreeRegion(LPVOID pAddress, LPVOID pMaxAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the next allocation granularity multiply.
    tryAddr += dwAllocationGranularity;

    while (tryAddr <= (ULONG_PTR)pMaxAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        tryAddr = (ULONG_PTR)mbi.BaseAddress + mbi.RegionSize;

        // Round up to the next allocation granularity.
        tryAddr += dwAllocationGranularity - 1;
        tryAddr -= tryAddr % dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin)
{
    PMEMORY_BLOCK pBlock;
#if defined(_M_X64) || defined(__x86_64__)
    ULONG_PTR minAddr;
    ULONG_PTR maxAddr;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;

    // pOrigin ± 512MB
    if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
        minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;

    if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
        maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;

    // Make room for MEMORY_BLOCK_SIZE bytes.
    maxAddr -= MEMORY_BLOCK_SIZE - 1;
#endif

    // Look the registered blocks for a reachable one.
    for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)
    {
#if defined(_M_X64) || defined(__x86_64__)
        // Ignore the blocks too far.
        if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
            continue;
#endif
        // The block has at least one unused slot.
        if (pBlock->pFree != NULL)
            return pBlock;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Alloc a new block above if not found.
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc >= minAddr)
        {
            pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }

    // Alloc a new block below if not found.
    if (pBlock == NULL)
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc <= maxAddr)
        {
            pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }
#else
    // In x86 mode, a memory block can be placed anywhere.
    pBlock = (PMEMORY_BLOCK)VirtualAlloc(
        NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#endif

    if (pBlock != NULL)
    {
        // Build a linked list of all the slots.
        PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;
        pBlock->pFree = NULL;
        pBlock->usedCount = 0;
        do
        {
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pSlot++;
        } while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

        pBlock->pNext = g_pMemoryBlocks;
        g_pMemoryBlocks = pBlock;
    }

    return pBlock;
}

//-------------------------------------------------------------------------
LPVOID AllocateBuffer(LPVOID pOrigin)
{
    PMEMORY_SLOT  pSlot;
    PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);
    if (pBlock == NULL)
        return NULL;

    // Remove an unused slot from the list.
    pSlot = pBlock->pFree;
    pBlock->pFree = pSlot->pNext;
    pBlock->usedCount++;
#ifdef _DEBUG
    // Fill the slot with INT3 for debugging.
    memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));
#endif
    return pSlot;
}

//-------------------------------------------------------------------------
VOID FreeBuffer(LPVOID pBuffer)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    PMEMORY_BLOCK pPrev = NULL;
    ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

    while (pBlock != NULL)
    {
        if ((ULONG_PTR)pBlock == pTargetBlock)
        {
            PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;
#ifdef _DEBUG
            // Clear the released slot for debugging.
            memset(pSlot, 0x00, sizeof(*pSlot));
#endif
            // Restore the released slot to the list.
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pBlock->usedCount--;

            // Free if unused.
            if (pBlock->usedCount == 0)
            {
                if (pPrev)
                    pPrev->pNext = pBlock->pNext;
                else
                    g_pMemoryBlocks = pBlock->pNext;

                VirtualFree(pBlock, 0, MEM_RELEASE);
            }

            break;
        }

        pPrev = pBlock;
        pBlock = pBlock->pNext;
    }
}

//-------------------------------------------------------------------------
BOOL IsExecutableAddress(LPVOID pAddress)
{
    MEMORY_BASIC_INFORMATION mi;
    VirtualQuery(pAddress, &mi, sizeof(mi));

    return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));
}

```

`libs/minhook-1.3.3/src/buffer.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
    #define MEMORY_SLOT_SIZE 64
#else
    #define MEMORY_SLOT_SIZE 32
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);

```

`libs/minhook-1.3.3/src/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_IX86) || defined(__i386__)

#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void *code, hde32s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde32s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde32s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde32_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde32_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde32_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde32_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde32_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde32_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde32_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (pref & PRE_66) {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
            p += 2;
        } else {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        }
    }

    if (cflags & C_IMM16) {
        if (hs->flags & F_IMM32) {
            hs->flags |= F_IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else if (hs->flags & F_IMM16) {
            hs->flags |= F_2IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
        }
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_IX86) || defined(__i386__)

```

`libs/minhook-1.3.3/src/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`libs/minhook-1.3.3/src/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_X64) || defined(__x86_64__)

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)

```

`libs/minhook-1.3.3/src/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`libs/minhook-1.3.3/src/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`libs/minhook-1.3.3/src/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`libs/minhook-1.3.3/src/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`libs/minhook-1.3.3/src/hook.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include <tlhelp32.h>
#include <limits.h>

#include "../include/MinHook.h"
#include "buffer.h"
#include "trampoline.h"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

// Initial capacity of the HOOK_ENTRY buffer.
#define INITIAL_HOOK_CAPACITY   32

// Initial capacity of the thread IDs buffer.
#define INITIAL_THREAD_CAPACITY 128

// Special hook position values.
#define INVALID_HOOK_POS UINT_MAX
#define ALL_HOOKS_POS    UINT_MAX

// Freeze() action argument defines.
#define ACTION_DISABLE      0
#define ACTION_ENABLE       1
#define ACTION_APPLY_QUEUED 2

// Thread access rights for suspending/resuming threads.
#define THREAD_ACCESS \
    (THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SET_CONTEXT)

// Hook information.
typedef struct _HOOK_ENTRY
{
    LPVOID pTarget;             // Address of the target function.
    LPVOID pDetour;             // Address of the detour or relay function.
    LPVOID pTrampoline;         // Address of the trampoline function.
    UINT8  backup[8];           // Original prologue of the target function.

    UINT8  patchAbove  : 1;     // Uses the hot patch area.
    UINT8  isEnabled   : 1;     // Enabled.
    UINT8  queueEnable : 1;     // Queued for enabling/disabling when != isEnabled.

    UINT   nIP : 4;             // Count of the instruction boundaries.
    UINT8  oldIPs[8];           // Instruction boundaries of the target function.
    UINT8  newIPs[8];           // Instruction boundaries of the trampoline function.
} HOOK_ENTRY, *PHOOK_ENTRY;

// Suspended threads for Freeze()/Unfreeze().
typedef struct _FROZEN_THREADS
{
    LPDWORD pItems;         // Data heap
    UINT    capacity;       // Size of allocated data heap, items
    UINT    size;           // Actual number of data items
} FROZEN_THREADS, *PFROZEN_THREADS;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// Spin lock flag for EnterSpinLock()/LeaveSpinLock().
volatile LONG g_isLocked = FALSE;

// Private heap handle. If not NULL, this library is initialized.
HANDLE g_hHeap = NULL;

// Hook entries.
struct
{
    PHOOK_ENTRY pItems;     // Data heap
    UINT        capacity;   // Size of allocated data heap, items
    UINT        size;       // Actual number of data items
} g_hooks;

//-------------------------------------------------------------------------
// Returns INVALID_HOOK_POS if not found.
static UINT FindHookEntry(LPVOID pTarget)
{
    UINT i;
    for (i = 0; i < g_hooks.size; ++i)
    {
        if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)
            return i;
    }

    return INVALID_HOOK_POS;
}

//-------------------------------------------------------------------------
static PHOOK_ENTRY AddHookEntry()
{
    if (g_hooks.pItems == NULL)
    {
        g_hooks.capacity = INITIAL_HOOK_CAPACITY;
        g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(
            g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
        if (g_hooks.pItems == NULL)
            return NULL;
    }
    else if (g_hooks.size >= g_hooks.capacity)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return NULL;

        g_hooks.capacity *= 2;
        g_hooks.pItems = p;
    }

    return &g_hooks.pItems[g_hooks.size++];
}

//-------------------------------------------------------------------------
static void DeleteHookEntry(UINT pos)
{
    if (pos < g_hooks.size - 1)
        g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

    g_hooks.size--;

    if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return;

        g_hooks.capacity /= 2;
        g_hooks.pItems = p;
    }
}

//-------------------------------------------------------------------------
static DWORD_PTR FindOldIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;

    if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))
        return (DWORD_PTR)pHook->pTarget;

    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))
            return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Check relay function.
    if (ip == (DWORD_PTR)pHook->pDetour)
        return (DWORD_PTR)pHook->pTarget;
#endif

    return 0;
}

//-------------------------------------------------------------------------
static DWORD_PTR FindNewIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;
    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))
            return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];
    }

    return 0;
}

//-------------------------------------------------------------------------
static void ProcessThreadIPs(HANDLE hThread, UINT pos, UINT action)
{
    // If the thread suspended in the overwritten area,
    // move IP to the proper address.

    CONTEXT c;
#if defined(_M_X64) || defined(__x86_64__)
    DWORD64 *pIP = &c.Rip;
#else
    DWORD   *pIP = &c.Eip;
#endif
    UINT count;

    c.ContextFlags = CONTEXT_CONTROL;
    if (!GetThreadContext(hThread, &c))
        return;

    if (pos == ALL_HOOKS_POS)
    {
        pos = 0;
        count = g_hooks.size;
    }
    else
    {
        count = pos + 1;
    }

    for (; pos < count; ++pos)
    {
        PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
        BOOL        enable;
        DWORD_PTR   ip;

        switch (action)
        {
        case ACTION_DISABLE:
            enable = FALSE;
            break;

        case ACTION_ENABLE:
            enable = TRUE;
            break;

        default: // ACTION_APPLY_QUEUED
            enable = pHook->queueEnable;
            break;
        }
        if (pHook->isEnabled == enable)
            continue;

        if (enable)
            ip = FindNewIP(pHook, *pIP);
        else
            ip = FindOldIP(pHook, *pIP);

        if (ip != 0)
        {
            *pIP = ip;
            SetThreadContext(hThread, &c);
        }
    }
}

//-------------------------------------------------------------------------
static VOID EnumerateThreads(PFROZEN_THREADS pThreads)
{
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te;
        te.dwSize = sizeof(THREADENTRY32);
        if (Thread32First(hSnapshot, &te))
        {
            do
            {
                if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
                    && te.th32OwnerProcessID == GetCurrentProcessId()
                    && te.th32ThreadID != GetCurrentThreadId())
                {
                    if (pThreads->pItems == NULL)
                    {
                        pThreads->capacity = INITIAL_THREAD_CAPACITY;
                        pThreads->pItems
                            = (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));
                        if (pThreads->pItems == NULL)
                            break;
                    }
                    else if (pThreads->size >= pThreads->capacity)
                    {
                        LPDWORD p = (LPDWORD)HeapReAlloc(
                            g_hHeap, 0, pThreads->pItems, (pThreads->capacity * 2) * sizeof(DWORD));
                        if (p == NULL)
                            break;

                        pThreads->capacity *= 2;
                        pThreads->pItems = p;
                    }
                    pThreads->pItems[pThreads->size++] = te.th32ThreadID;
                }

                te.dwSize = sizeof(THREADENTRY32);
            } while (Thread32Next(hSnapshot, &te));
        }
        CloseHandle(hSnapshot);
    }
}

//-------------------------------------------------------------------------
static VOID Freeze(PFROZEN_THREADS pThreads, UINT pos, UINT action)
{
    pThreads->pItems   = NULL;
    pThreads->capacity = 0;
    pThreads->size     = 0;
    EnumerateThreads(pThreads);

    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                SuspendThread(hThread);
                ProcessThreadIPs(hThread, pos, action);
                CloseHandle(hThread);
            }
        }
    }
}

//-------------------------------------------------------------------------
static VOID Unfreeze(PFROZEN_THREADS pThreads)
{
    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                ResumeThread(hThread);
                CloseHandle(hThread);
            }
        }

        HeapFree(g_hHeap, 0, pThreads->pItems);
    }
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHookLL(UINT pos, BOOL enable)
{
    PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
    DWORD  oldProtect;
    SIZE_T patchSize    = sizeof(JMP_REL);
    LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

    if (pHook->patchAbove)
    {
        pPatchTarget -= sizeof(JMP_REL);
        patchSize    += sizeof(JMP_REL_SHORT);
    }

    if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))
        return MH_ERROR_MEMORY_PROTECT;

    if (enable)
    {
        PJMP_REL pJmp = (PJMP_REL)pPatchTarget;
        pJmp->opcode = 0xE9;
        pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

        if (pHook->patchAbove)
        {
            PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;
            pShortJmp->opcode = 0xEB;
            pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));
        }
    }
    else
    {
        if (pHook->patchAbove)
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
        else
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));
    }

    VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

    // Just-in-case measure.
    FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

    pHook->isEnabled   = enable;
    pHook->queueEnable = enable;

    return MH_OK;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableAllHooksLL(BOOL enable)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    for (i = 0; i < g_hooks.size; ++i)
    {
        if (g_hooks.pItems[i].isEnabled != enable)
        {
            first = i;
            break;
        }
    }

    if (first != INVALID_HOOK_POS)
    {
        FROZEN_THREADS threads;
        Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);

        for (i = first; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != enable)
            {
                status = EnableHookLL(i, enable);
                if (status != MH_OK)
                    break;
            }
        }

        Unfreeze(&threads);
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID EnterSpinLock(VOID)
{
    SIZE_T spinCount = 0;

    // Wait until the flag is FALSE.
    while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)
    {
        // No need to generate a memory barrier here, since InterlockedCompareExchange()
        // generates a full memory barrier itself.

        // Prevent the loop from being too busy.
        if (spinCount < 32)
            Sleep(0);
        else
            Sleep(1);

        spinCount++;
    }
}

//-------------------------------------------------------------------------
static VOID LeaveSpinLock(VOID)
{
    // No need to generate a memory barrier here, since InterlockedExchange()
    // generates a full memory barrier itself.

    InterlockedExchange(&g_isLocked, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Initialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap == NULL)
    {
        g_hHeap = HeapCreate(0, 0, 0);
        if (g_hHeap != NULL)
        {
            // Initialize the internal function buffer.
            InitializeBuffer();
        }
        else
        {
            status = MH_ERROR_MEMORY_ALLOC;
        }
    }
    else
    {
        status = MH_ERROR_ALREADY_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Uninitialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        status = EnableAllHooksLL(FALSE);
        if (status == MH_OK)
        {
            // Free the internal function buffer.

            // HeapFree is actually not required, but some tools detect a false
            // memory leak without HeapFree.

            UninitializeBuffer();

            HeapFree(g_hHeap, 0, g_hooks.pItems);
            HeapDestroy(g_hHeap);

            g_hHeap = NULL;

            g_hooks.pItems   = NULL;
            g_hooks.capacity = 0;
            g_hooks.size     = 0;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos == INVALID_HOOK_POS)
            {
                LPVOID pBuffer = AllocateBuffer(pTarget);
                if (pBuffer != NULL)
                {
                    TRAMPOLINE ct;

                    ct.pTarget     = pTarget;
                    ct.pDetour     = pDetour;
                    ct.pTrampoline = pBuffer;
                    if (CreateTrampolineFunction(&ct))
                    {
                        PHOOK_ENTRY pHook = AddHookEntry();
                        if (pHook != NULL)
                        {
                            pHook->pTarget     = ct.pTarget;
#if defined(_M_X64) || defined(__x86_64__)
                            pHook->pDetour     = ct.pRelay;
#else
                            pHook->pDetour     = ct.pDetour;
#endif
                            pHook->pTrampoline = ct.pTrampoline;
                            pHook->patchAbove  = ct.patchAbove;
                            pHook->isEnabled   = FALSE;
                            pHook->queueEnable = FALSE;
                            pHook->nIP         = ct.nIP;
                            memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));
                            memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

                            // Back up the target function.

                            if (ct.patchAbove)
                            {
                                memcpy(
                                    pHook->backup,
                                    (LPBYTE)pTarget - sizeof(JMP_REL),
                                    sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
                            }
                            else
                            {
                                memcpy(pHook->backup, pTarget, sizeof(JMP_REL));
                            }

                            if (ppOriginal != NULL)
                                *ppOriginal = pHook->pTrampoline;
                        }
                        else
                        {
                            status = MH_ERROR_MEMORY_ALLOC;
                        }
                    }
                    else
                    {
                        status = MH_ERROR_UNSUPPORTED_FUNCTION;
                    }

                    if (status != MH_OK)
                    {
                        FreeBuffer(pBuffer);
                    }
                }
                else
                {
                    status = MH_ERROR_MEMORY_ALLOC;
                }
            }
            else
            {
                status = MH_ERROR_ALREADY_CREATED;
            }
        }
        else
        {
            status = MH_ERROR_NOT_EXECUTABLE;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        UINT pos = FindHookEntry(pTarget);
        if (pos != INVALID_HOOK_POS)
        {
            if (g_hooks.pItems[pos].isEnabled)
            {
                FROZEN_THREADS threads;
                Freeze(&threads, pos, ACTION_DISABLE);

                status = EnableHookLL(pos, FALSE);

                Unfreeze(&threads);
            }

            if (status == MH_OK)
            {
                FreeBuffer(g_hooks.pItems[pos].pTrampoline);
                DeleteHookEntry(pos);
            }
        }
        else
        {
            status = MH_ERROR_NOT_CREATED;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHook(LPVOID pTarget, BOOL enable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            status = EnableAllHooksLL(enable);
        }
        else
        {
            FROZEN_THREADS threads;
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                if (g_hooks.pItems[pos].isEnabled != enable)
                {
                    Freeze(&threads, pos, ACTION_ENABLE);

                    status = EnableHookLL(pos, enable);

                    Unfreeze(&threads);
                }
                else
                {
                    status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;
                }
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
static MH_STATUS QueueHook(LPVOID pTarget, BOOL queueEnable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            UINT i;
            for (i = 0; i < g_hooks.size; ++i)
                g_hooks.pItems[i].queueEnable = queueEnable;
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                g_hooks.pItems[pos].queueEnable = queueEnable;
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_ApplyQueued(VOID)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        for (i = 0; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != g_hooks.pItems[i].queueEnable)
            {
                first = i;
                break;
            }
        }

        if (first != INVALID_HOOK_POS)
        {
            FROZEN_THREADS threads;
            Freeze(&threads, ALL_HOOKS_POS, ACTION_APPLY_QUEUED);

            for (i = first; i < g_hooks.size; ++i)
            {
                PHOOK_ENTRY pHook = &g_hooks.pItems[i];
                if (pHook->isEnabled != pHook->queueEnable)
                {
                    status = EnableHookLL(i, pHook->queueEnable);
                    if (status != MH_OK)
                        break;
                }
            }

            Unfreeze(&threads);
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApiEx(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour,
    LPVOID *ppOriginal, LPVOID *ppTarget)
{
    HMODULE hModule;
    LPVOID  pTarget;

    hModule = GetModuleHandleW(pszModule);
    if (hModule == NULL)
        return MH_ERROR_MODULE_NOT_FOUND;

    pTarget = (LPVOID)GetProcAddress(hModule, pszProcName);
    if (pTarget == NULL)
        return MH_ERROR_FUNCTION_NOT_FOUND;

    if(ppTarget != NULL)
        *ppTarget = pTarget;

    return MH_CreateHook(pTarget, pDetour, ppOriginal);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApi(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal)
{
   return MH_CreateHookApiEx(pszModule, pszProcName, pDetour, ppOriginal, NULL);
}

//-------------------------------------------------------------------------
const char * WINAPI MH_StatusToString(MH_STATUS status)
{
#define MH_ST2STR(x)    \
    case x:             \
        return #x;

    switch (status) {
        MH_ST2STR(MH_UNKNOWN)
        MH_ST2STR(MH_OK)
        MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)
        MH_ST2STR(MH_ERROR_NOT_INITIALIZED)
        MH_ST2STR(MH_ERROR_ALREADY_CREATED)
        MH_ST2STR(MH_ERROR_NOT_CREATED)
        MH_ST2STR(MH_ERROR_ENABLED)
        MH_ST2STR(MH_ERROR_DISABLED)
        MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)
        MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)
        MH_ST2STR(MH_ERROR_MEMORY_ALLOC)
        MH_ST2STR(MH_ERROR_MEMORY_PROTECT)
        MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)
        MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)
    }

#undef MH_ST2STR

    return "(unknown)";
}

```

`libs/minhook-1.3.3/src/trampoline.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

#if defined(_M_X64) || defined(__x86_64__)
    #include "./hde/hde64.h"
    typedef hde64s HDE;
    #define HDE_DISASM(code, hs) hde64_disasm(code, hs)
#else
    #include "./hde/hde32.h"
    typedef hde32s HDE;
    #define HDE_DISASM(code, hs) hde32_disasm(code, hs)
#endif

#include "trampoline.h"
#include "buffer.h"

// Maximum size of a trampoline function.
#if defined(_M_X64) || defined(__x86_64__)
    #define TRAMPOLINE_MAX_SIZE (MEMORY_SLOT_SIZE - sizeof(JMP_ABS))
#else
    #define TRAMPOLINE_MAX_SIZE MEMORY_SLOT_SIZE
#endif

//-------------------------------------------------------------------------
static BOOL IsCodePadding(LPBYTE pInst, UINT size)
{
    UINT i;

    if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)
        return FALSE;

    for (i = 1; i < size; ++i)
    {
        if (pInst[i] != pInst[0])
            return FALSE;
    }
    return TRUE;
}

//-------------------------------------------------------------------------
BOOL CreateTrampolineFunction(PTRAMPOLINE ct)
{
#if defined(_M_X64) || defined(__x86_64__)
    CALL_ABS call = {
        0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
        0xEB, 0x08,             // EB 08:         JMP +10
        0x0000000000000000ULL   // Absolute destination address
    };
    JMP_ABS jmp = {
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
    JCC_ABS jcc = {
        0x70, 0x0E,             // 7* 0E:         J** +16
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
#else
    CALL_REL call = {
        0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JMP_REL jmp = {
        0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JCC_REL jcc = {
        0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
        0x00000000              // Relative destination address
    };
#endif

    UINT8     oldPos   = 0;
    UINT8     newPos   = 0;
    ULONG_PTR jmpDest  = 0;     // Destination address of an internal jump.
    BOOL      finished = FALSE; // Is the function completed?
#if defined(_M_X64) || defined(__x86_64__)
    UINT8     instBuf[16];
#endif

    ct->patchAbove = FALSE;
    ct->nIP        = 0;

    do
    {
        HDE       hs;
        UINT      copySize;
        LPVOID    pCopySrc;
        ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget     + oldPos;
        ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

        copySize = HDE_DISASM((LPVOID)pOldInst, &hs);
        if (hs.flags & F_ERROR)
            return FALSE;

        pCopySrc = (LPVOID)pOldInst;
        if (oldPos >= sizeof(JMP_REL))
        {
            // The trampoline function is long enough.
            // Complete the function with the jump to the target function.
#if defined(_M_X64) || defined(__x86_64__)
            jmp.address = pOldInst;
#else
            jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));
#endif
            pCopySrc = &jmp;
            copySize = sizeof(jmp);

            finished = TRUE;
        }
#if defined(_M_X64) || defined(__x86_64__)
        else if ((hs.modrm & 0xC7) == 0x05)
        {
            // Instructions using RIP relative addressing. (ModR/M = 00???101B)

            // Modify the RIP relative address.
            PUINT32 pRelAddr;

            // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
            memcpy(instBuf, (LPBYTE)pOldInst, copySize);
#else
            __movsb(instBuf, (LPBYTE)pOldInst, copySize);
#endif
            pCopySrc = instBuf;

            // Relative address is stored at (instruction length - immediate value length - 4).
            pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
            *pRelAddr
                = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));

            // Complete the function if JMP (FF /4).
            if (hs.opcode == 0xFF && hs.modrm_reg == 4)
                finished = TRUE;
        }
#endif
        else if (hs.opcode == 0xE8)
        {
            // Direct relative CALL
            ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;
#if defined(_M_X64) || defined(__x86_64__)
            call.address = dest;
#else
            call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));
#endif
            pCopySrc = &call;
            copySize = sizeof(call);
        }
        else if ((hs.opcode & 0xFD) == 0xE9)
        {
            // Direct relative JMP (EB or E9)
            ULONG_PTR dest = pOldInst + hs.len;

            if (hs.opcode == 0xEB) // isShort jmp
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else
            {
#if defined(_M_X64) || defined(__x86_64__)
                jmp.address = dest;
#else
                jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));
#endif
                pCopySrc = &jmp;
                copySize = sizeof(jmp);

                // Exit the function If it is not in the branch
                finished = (pOldInst >= jmpDest);
            }
        }
        else if ((hs.opcode & 0xF0) == 0x70
            || (hs.opcode & 0xFC) == 0xE0
            || (hs.opcode2 & 0xF0) == 0x80)
        {
            // Direct relative Jcc
            ULONG_PTR dest = pOldInst + hs.len;

            if ((hs.opcode & 0xF0) == 0x70      // Jcc
                || (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else if ((hs.opcode & 0xFC) == 0xE0)
            {
                // LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
                return FALSE;
            }
            else
            {
                UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);
#if defined(_M_X64) || defined(__x86_64__)
                // Invert the condition in x64 mode to simplify the conditional jump logic.
                jcc.opcode  = 0x71 ^ cond;
                jcc.address = dest;
#else
                jcc.opcode1 = 0x80 | cond;
                jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));
#endif
                pCopySrc = &jcc;
                copySize = sizeof(jcc);
            }
        }
        else if ((hs.opcode & 0xFE) == 0xC2)
        {
            // RET (C2 or C3)

            // Complete the function if not in a branch.
            finished = (pOldInst >= jmpDest);
        }

        // Can't alter the instruction length in a branch.
        if (pOldInst < jmpDest && copySize != hs.len)
            return FALSE;

        // Trampoline function is too large.
        if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)
            return FALSE;

        // Trampoline function has too many instructions.
        if (ct->nIP >= ARRAYSIZE(ct->oldIPs))
            return FALSE;

        ct->oldIPs[ct->nIP] = oldPos;
        ct->newIPs[ct->nIP] = newPos;
        ct->nIP++;

        // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
        memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#else
        __movsb((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#endif
        newPos += copySize;
        oldPos += hs.len;
    }
    while (!finished);

    // Is there enough place for a long jump?
    if (oldPos < sizeof(JMP_REL)
        && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))
    {
        // Is there enough place for a short jump?
        if (oldPos < sizeof(JMP_REL_SHORT)
            && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))
        {
            return FALSE;
        }

        // Can we place the long jump above the function?
        if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))
            return FALSE;

        if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))
            return FALSE;

        ct->patchAbove = TRUE;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Create a relay function.
    jmp.address = (ULONG_PTR)ct->pDetour;

    ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
    memcpy(ct->pRelay, &jmp, sizeof(jmp));
#endif

    return TRUE;
}

```

`libs/minhook-1.3.3/src/trampoline.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#pragma pack(push, 1)

// Structs for writing x86/x64 instructions.

// 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
    UINT8  opcode;      // EB xx: JMP +2+xx
    UINT8  operand;
} JMP_REL_SHORT, *PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
    UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
    UINT32 operand;     // Relative destination address
} JMP_REL, *PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
    UINT8  opcode0;     // FF25 00000000: JMP [+6]
    UINT8  opcode1;
    UINT32 dummy;
    UINT64 address;     // Absolute destination address
} JMP_ABS, *PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
    UINT8  opcode0;     // FF15 00000002: CALL [+6]
    UINT8  opcode1;
    UINT32 dummy0;
    UINT8  dummy1;      // EB 08:         JMP +10
    UINT8  dummy2;
    UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
    UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
    UINT8  opcode1;
    UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
    UINT8  opcode;      // 7* 0E:         J** +16
    UINT8  dummy0;
    UINT8  dummy1;      // FF25 00000000: JMP [+6]
    UINT8  dummy2;
    UINT32 dummy3;
    UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

typedef struct _TRAMPOLINE
{
    LPVOID pTarget;         // [In] Address of the target function.
    LPVOID pDetour;         // [In] Address of the detour function.
    LPVOID pTrampoline;     // [In] Buffer address for the trampoline and relay function.

#if defined(_M_X64) || defined(__x86_64__)
    LPVOID pRelay;          // [Out] Address of the relay function.
#endif
    BOOL   patchAbove;      // [Out] Should use the hot patch area?
    UINT   nIP;             // [Out] Number of the instruction boundaries.
    UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
    UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, *PTRAMPOLINE;

BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

```

`src/dllmain.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <Psapi.h>
#include <MinHook.h>

#include "hooks/hook_base.h"
#include "emu/emulator.h"
#include "utils/logger.h"

//=============================================================================
// Configuration
//=============================================================================
static constexpr bool EMULATION_ENABLED = true ;  // Set true to enable VAC emulation

//=============================================================================
// Find SteamService.dll Base Address
//=============================================================================
static uintptr_t FindSteamServiceDll() {
    HMODULE hMod = GetModuleHandleA("SteamService.dll");
    if (hMod) return reinterpret_cast<uintptr_t>(hMod);

    HMODULE modules[1024];
    DWORD  needed;
    if (EnumProcessModules(GetCurrentProcess(), modules, sizeof(modules), &needed)) {
        for (unsigned int i = 0; i < (needed / sizeof(HMODULE)); i++) {
            char modName[MAX_PATH];
            if (GetModuleBaseNameA(GetCurrentProcess(), modules[i], modName, sizeof(modName))) {
                if (_stricmp(modName, "SteamService.dll") == 0)
                    return reinterpret_cast<uintptr_t>(modules[i]);
            }
        }
    }
    return 0;
}

//=============================================================================
// Initialization Thread
//=============================================================================
static DWORD WINAPI InitThread(LPVOID lpParam) {
    Sleep(1000);  // Wait for SteamService.dll to fully load

    // Initialize logging
    Logger::Init("C:\\vac_ipc_log.txt");
    Logger::Log("========================================");
    Logger::Log("=== VAC Emulator ===");
    Logger::Log("PID: %d", GetCurrentProcessId());
    Logger::Log("========================================");

    // Set emulation mode
    Hooks::g_EmulationEnabled = EMULATION_ENABLED;
    if (EMULATION_ENABLED) {
        Emu::Emulator::SetMode(Emu::Mode::EMULATE_VAC);
        Logger::Log("MODE: EMULATION ENABLED");
    } else {
        Emu::Emulator::SetMode(Emu::Mode::LOG_ONLY);
        Logger::Log("MODE: LOG ONLY");
    }

    // Initialize MinHook
    if (MH_Initialize() != MH_OK) {
        Logger::Log("ERROR: MH_Initialize failed");
        return 1;
    }

    // Find SteamService.dll
    uintptr_t steamServiceBase = FindSteamServiceDll();
    if (!steamServiceBase) {
        Logger::Log("ERROR: SteamService.dll not found");
        return 1;
    }
    Logger::Log("SteamService.dll base: 0x%08X", steamServiceBase);

    // Install all hooks
    Hooks::InitializeAll(steamServiceBase);

    Logger::Log("========================================");
    Logger::Log("Waiting for IPC activity...");
    Logger::Log("========================================");

    return 0;
}

//=============================================================================
// DLL Entry Point
//=============================================================================
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        CreateThread(NULL, 0, InitThread, NULL, 0, NULL);
    }
    else if (ul_reason_for_call == DLL_PROCESS_DETACH && lpReserved == nullptr) {
        Hooks::ShutdownAll();
        MH_Uninitialize();
        Logger::Shutdown();
    }
    return TRUE;
}

```

`src/emu/emulator.cpp`:

```cpp
#include "emu/emulator.h"
#include "module/types.h"
#include "module/manager.h"
#include "utils/logger.h"
#include <cstring>
#include <map>

namespace Emu {

// Forward declaration
static bool HandleVACRequest(uint32_t magic, const uint8_t* requestData, size_t requestSize,
                             uint8_t* responseBuffer, size_t* responseSize);

//=============================================================================
// Static State
//=============================================================================
Mode Emulator::s_mode = Mode::LOG_ONLY;

// Track "loaded" modules for consistent responses
static std::map<uint32_t, VAC::EmulatedModule> g_emulatedModules;

// Async call tracking
static uint32_t g_nextAsyncHandle = 1;
struct AsyncCall {
    uint32_t clientHandle;
    uint32_t moduleId;
    uint32_t functionId;
    bool ready;
};
static std::map<uint32_t, AsyncCall> g_asyncCalls;

//=============================================================================
// ResponseBuilder Implementation
//=============================================================================
ResponseBuilder::ResponseBuilder(uint8_t* buffer, size_t maxSize)
    : m_buffer(buffer), m_maxSize(maxSize), m_pos(0) {}

bool ResponseBuilder::WriteU8(uint8_t val) {
    if (m_pos + 1 > m_maxSize) return false;
    m_buffer[m_pos++] = val;
    return true;
}

bool ResponseBuilder::WriteU32(uint32_t val) {
    if (m_pos + 4 > m_maxSize) return false;
    memcpy(m_buffer + m_pos, &val, 4);
    m_pos += 4;
    return true;
}

bool ResponseBuilder::WriteU64(uint64_t val) {
    if (m_pos + 8 > m_maxSize) return false;
    memcpy(m_buffer + m_pos, &val, 8);
    m_pos += 8;
    return true;
}

bool ResponseBuilder::WriteBytes(const uint8_t* data, size_t len) {
    if (m_pos + len > m_maxSize) return false;
    memcpy(m_buffer + m_pos, data, len);
    m_pos += len;
    return true;
}

bool ResponseBuilder::WriteString(const char* str) {
    size_t len = strlen(str) + 1;  // Include null terminator
    if (len > 255) len = 255;
    if (!WriteU8(static_cast<uint8_t>(len))) return false;
    return WriteBytes(reinterpret_cast<const uint8_t*>(str), len);
}

//=============================================================================
// Emulator Interface
//=============================================================================
void Emulator::SetMode(Mode mode) {
    s_mode = mode;
    const char* modeName = "Unknown";
    switch (mode) {
        case Mode::LOG_ONLY: modeName = "LOG_ONLY"; break;
        case Mode::EMULATE_VAC: modeName = "EMULATE_VAC"; break;
        case Mode::EMULATE_ALL: modeName = "EMULATE_ALL"; break;
    }
    Logger::Log("[EMU] Mode set to: %s", modeName);
}

Mode Emulator::GetMode() {
    return s_mode;
}

bool Emulator::HandleRequest(uint8_t dispatchType, uint32_t magic,
                             const uint8_t* requestData, size_t requestSize,
                             uint8_t* responseBuffer, size_t* responseSize) {
    // In LOG_ONLY mode, never emulate
    if (s_mode == Mode::LOG_ONLY) {
        return false;
    }

    // In EMULATE_VAC mode, only handle type 2 (ModuleManager)
    if (s_mode == Mode::EMULATE_VAC && dispatchType != IPC::TYPE_MODULE_MANAGER) {
        return false;
    }

    // Handle based on dispatch type
    switch (dispatchType) {
        case IPC::TYPE_MODULE_MANAGER:
            return HandleVACRequest(magic, requestData, requestSize, responseBuffer, responseSize);
        default:
            return false;
    }
}

//=============================================================================
// VAC Response Emulation
//=============================================================================
namespace VAC {

bool EmulateLoadModule(uint32_t moduleId, uint32_t moduleSize,
                       uint8_t* responseBuffer, size_t* responseSize) {
    Logger::Log("[EMU:VAC] Emulating LoadModule(id=%u, size=%u)", moduleId, moduleSize);

    // Track the "loaded" module
    EmulatedModule mod;
    mod.moduleId = moduleId;
    mod.loaded = true;
    mod.loadTime = GetTickCount64();
    g_emulatedModules[moduleId] = mod;

    // Response format (from reversing IClientModuleManager_IPC_Dispatch):
    //   uint8_t result (1 = success, 0 = fail)
    ResponseBuilder resp(responseBuffer, *responseSize);
    resp.WriteU8(1);  // Success
    *responseSize = resp.GetSize();

    Logger::Log("[EMU:VAC] LoadModule response: SUCCESS (1 byte)");
    return true;
}

bool EmulateUnloadModule(uint32_t moduleId,
                         uint8_t* responseBuffer, size_t* responseSize) {
    Logger::Log("[EMU:VAC] Emulating UnloadModule(id=%u)", moduleId);

    // Remove from tracked modules
    g_emulatedModules.erase(moduleId);

    // Response format: uint8_t result (1 = success, 0 = fail)
    ResponseBuilder resp(responseBuffer, *responseSize);
    resp.WriteU8(1);  // Success
    *responseSize = resp.GetSize();

    Logger::Log("[EMU:VAC] UnloadModule response: SUCCESS (1 byte)");
    return true;
}

bool EmulateCallFunction(uint32_t moduleId, uint32_t functionId,
                         uint32_t param, const uint8_t* inputData, uint32_t inputSize,
                         uint32_t outputBufferSize,
                         uint8_t* responseBuffer, size_t* responseSize) {
    Logger::Log("[EMU:VAC] Emulating CallFunction(mod=%u, func=%u, param=0x%X, inSize=%u, outBufSize=%u)",
                moduleId, functionId, param, inputSize, outputBufferSize);

    // VAC scan results - return "clean" (no detections)
    // Response format (from IDA reversing IClientModuleManager_IPC_Dispatch):
    //   uint32_t result (1 = success)
    //   uint8_t  outputBuffer[outputBufferSize]  // Zeros for clean scan
    //   uint32_t actualOutputSize  // 0 = no detections

    // Calculate total response size
    size_t totalSize = 4 + outputBufferSize + 4;
    if (*responseSize < totalSize) {
        Logger::Log("[EMU:VAC] CallFunction: response buffer too small (%zu < %zu)",
                    *responseSize, totalSize);
        return false;
    }

    ResponseBuilder resp(responseBuffer, *responseSize);
    resp.WriteU32(static_cast<uint32_t>(Module::ErrorCode::SUCCESS));  // Result = 1 (success)

    // Write empty output buffer (zeros = clean)
    for (uint32_t i = 0; i < outputBufferSize; i++) {
        resp.WriteU8(0);
    }

    resp.WriteU32(0);  // Actual output size = 0 (no detections)
    *responseSize = resp.GetSize();

    Logger::Log("[EMU:VAC] CallFunction response: CLEAN (result=1, actualSize=0, totalBytes=%zu)",
                *responseSize);
    return true;
}

bool EmulateCallFunctionAsync(uint32_t clientHandle, uint32_t moduleId,
                              uint32_t functionId, uint32_t param,
                              const uint8_t* inputData, uint32_t inputSize,
                              uint8_t* responseBuffer, size_t* responseSize) {
    Logger::Log("[EMU:VAC] Emulating CallFunctionAsync(client=0x%X, mod=%u, func=%u)",
                clientHandle, moduleId, functionId);

    // Track this async call
    AsyncCall call;
    call.clientHandle = clientHandle;
    call.moduleId = moduleId;
    call.functionId = functionId;
    call.ready = true;  // Immediately ready with "clean" result
    g_asyncCalls[clientHandle] = call;

    // Response: just acknowledge the request
    ResponseBuilder resp(responseBuffer, *responseSize);
    resp.WriteU32(0);  // Success (call queued)
    *responseSize = resp.GetSize();

    Logger::Log("[EMU:VAC] CallFunctionAsync response: QUEUED");
    return true;
}

bool EmulatePollResponseAsync(uint32_t outputBufferSize, uint32_t maxWaitMs,
                              uint8_t* responseBuffer, size_t* responseSize) {
    Logger::Log("[EMU:VAC] Emulating PollResponseAsync(outBufSize=%u, maxWait=%u)",
                outputBufferSize, maxWaitMs);

    // Response format (from IDA reversing IClientModuleManager_IPC_Dispatch):
    //   uint32_t result (0 = no result ready, non-zero = call result code)
    //   uint8_t  outputBuffer[outputBufferSize]  // Result data
    //   uint32_t actualOutputSize  // Actual data size

    // Calculate total response size
    size_t totalSize = 4 + outputBufferSize + 4;
    if (*responseSize < totalSize) {
        Logger::Log("[EMU:VAC] PollResponseAsync: response buffer too small (%zu < %zu)",
                    *responseSize, totalSize);
        return false;
    }

    // Check if we have any pending async calls
    for (auto it = g_asyncCalls.begin(); it != g_asyncCalls.end(); ) {
        if (it->second.ready) {
            uint32_t clientHandle = it->second.clientHandle;
            it = g_asyncCalls.erase(it);

            ResponseBuilder resp(responseBuffer, *responseSize);
            resp.WriteU32(static_cast<uint32_t>(Module::ErrorCode::SUCCESS));  // Result = 1 (success)

            // Write empty output buffer (zeros = clean)
            for (uint32_t i = 0; i < outputBufferSize; i++) {
                resp.WriteU8(0);
            }

            resp.WriteU32(0);  // Actual output size = 0 (no detections)
            *responseSize = resp.GetSize();

            Logger::Log("[EMU:VAC] PollResponseAsync response: READY, CLEAN (handle=0x%X, totalBytes=%zu)",
                        clientHandle, *responseSize);
            return true;
        } else {
            ++it;
        }
    }

    // No pending calls - return "nothing ready" (result=0)
    ResponseBuilder resp(responseBuffer, *responseSize);
    resp.WriteU32(static_cast<uint32_t>(Module::ErrorCode::NO_RESULT_READY));  // 0 = nothing ready

    // Still need to include the buffer space
    for (uint32_t i = 0; i < outputBufferSize; i++) {
        resp.WriteU8(0);
    }

    resp.WriteU32(0);  // Actual output size = 0
    *responseSize = resp.GetSize();

    Logger::Log("[EMU:VAC] PollResponseAsync response: NOTHING_READY (totalBytes=%zu)", *responseSize);
    return true;
}

} // namespace VAC

//=============================================================================
// Internal: Handle VAC request and generate response
//=============================================================================
static bool HandleVACRequest(uint32_t magic, const uint8_t* requestData, size_t requestSize,
                             uint8_t* responseBuffer, size_t* responseSize) {
    IPC::BufferReader reader(requestData, requestSize);

    switch (magic) {
        case IPC::ModuleManager::LOAD_MODULE: {
            uint32_t moduleId, moduleSize;
            if (reader.Read(moduleId) && reader.Read(moduleSize)) {
                return VAC::EmulateLoadModule(moduleId, moduleSize, responseBuffer, responseSize);
            }
            break;
        }

        case IPC::ModuleManager::UNLOAD_MODULE: {
            uint32_t moduleId;
            if (reader.Read(moduleId)) {
                return VAC::EmulateUnloadModule(moduleId, responseBuffer, responseSize);
            }
            break;
        }

        case IPC::ModuleManager::CALL_FUNCTION: {
            uint32_t moduleId, functionId, param, inputSize;
            if (reader.Read(moduleId) && reader.Read(functionId) &&
                reader.Read(param) && reader.Read(inputSize)) {
                const uint8_t* inputData = reader.Peek(inputSize);
                reader.Skip(inputSize);  // Skip past input data

                uint32_t outputBufferSize;
                if (reader.Read(outputBufferSize)) {
                    return VAC::EmulateCallFunction(moduleId, functionId, param,
                                                     inputData, inputSize,
                                                     outputBufferSize,
                                                     responseBuffer, responseSize);
                }
            }
            break;
        }

        case IPC::ModuleManager::CALL_FUNCTION_ASYNC: {
            uint32_t clientHandle, moduleId, functionId, param, unknown, inputSize;
            if (reader.Read(clientHandle) && reader.Read(moduleId) &&
                reader.Read(functionId) && reader.Read(param) &&
                reader.Read(unknown) && reader.Read(inputSize)) {
                const uint8_t* inputData = reader.Peek(inputSize);
                return VAC::EmulateCallFunctionAsync(clientHandle, moduleId, functionId, param,
                                                      inputData, inputSize,
                                                      responseBuffer, responseSize);
            }
            break;
        }

        case IPC::ModuleManager::POLL_RESPONSE_ASYNC: {
            uint32_t outputSize, maxWait, unknown;
            if (reader.Read(outputSize) && reader.Read(maxWait) && reader.Read(unknown)) {
                return VAC::EmulatePollResponseAsync(outputSize, maxWait,
                                                      responseBuffer, responseSize);
            }
            break;
        }

        default:
            Logger::Log("[EMU:VAC] Unknown VAC method 0x%08X - forwarding to real service", magic);
            return false;
    }

    return false;
}

} // namespace Emu

```

`src/hooks.cpp`:

```cpp
#include "hooks.h"

namespace Hooks {

bool Init() { return true; }
void Shutdown() {}
bool IsInitialized() { return false; }

}

```

`src/hooks/hooks_all.cpp`:

```cpp
#include "hooks/hook_base.h"
#include "hooks/parent_dispatch.h"
#include "hooks/ipc_dispatch.h"
#include "hooks/run_module.h"
#include "hooks/load_validate.h"
#include "hooks/run_module_async.h"
#include "hooks/validate_signature.h"
#include "utils/logger.h"
#include "utils/sigscan.h"

namespace Hooks {

//=============================================================================
// Global State
//=============================================================================
uintptr_t g_SteamServiceBase = 0;
bool g_EmulationEnabled = false;

//=============================================================================
// Initialize All Hooks using Signature Scanning
//=============================================================================
bool InitializeAll(uintptr_t steamServiceBase) {
    g_SteamServiceBase = steamServiceBase;
    Logger::Log("Installing hooks using signature scanning...");
    Logger::Log("SteamService.dll base: 0x%08X", steamServiceBase);

    bool allSuccess = true;
    uintptr_t addr;

    // ParentDispatch - main IPC entry point
    addr = SigScan::FindInSteamService(SigScan::Signatures::PARENT_DISPATCH);
    if (addr) {
        Logger::Log("Found ParentDispatch @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!ParentDispatch::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: ParentDispatch signature not found!");
        allSuccess = false;
    }

    // IPC_Dispatch - VAC module manager dispatcher
    addr = SigScan::FindInSteamService(SigScan::Signatures::IPC_DISPATCH);
    if (addr) {
        Logger::Log("Found IPC_Dispatch @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!IPCDispatch::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: IPC_Dispatch signature not found!");
        allSuccess = false;
    }

    // RunModule - synchronous module execution
    addr = SigScan::FindInSteamService(SigScan::Signatures::RUN_MODULE);
    if (addr) {
        Logger::Log("Found RunModule @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!RunModule::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: RunModule signature not found!");
        allSuccess = false;
    }

    // RunModuleAsync - async module execution
    addr = SigScan::FindInSteamService(SigScan::Signatures::RUN_MODULE_ASYNC);
    if (addr) {
        Logger::Log("Found RunModuleAsync @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!RunModuleAsync::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: RunModuleAsync signature not found!");
        allSuccess = false;
    }

    // LoadValidate - module loading and validation
    addr = SigScan::FindInSteamService(SigScan::Signatures::LOAD_VALIDATE);
    if (addr) {
        Logger::Log("Found LoadValidate @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!LoadValidate::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: LoadValidate signature not found!");
        allSuccess = false;
    }

    // ValidateSignature - RSA signature verification
    addr = SigScan::FindInSteamService(SigScan::Signatures::VALIDATE_SIGNATURE);
    if (addr) {
        Logger::Log("Found ValidateSignature @ 0x%08X (offset 0x%X)", addr, addr - steamServiceBase);
        if (!ValidateSignature::InstallAt(addr)) allSuccess = false;
    } else {
        Logger::Log("ERROR: ValidateSignature signature not found!");
        allSuccess = false;
    }

    if (allSuccess) {
        Logger::Log("All hooks installed successfully!");
    } else {
        Logger::Log("WARNING: Some hooks failed to install");
    }

    return allSuccess;
}

//=============================================================================
// Shutdown All Hooks
//=============================================================================
void ShutdownAll() {
    Logger::Log("Removing all hooks...");

    ParentDispatch::Uninstall();
    IPCDispatch::Uninstall();
    RunModule::Uninstall();
    RunModuleAsync::Uninstall();
    LoadValidate::Uninstall();
    ValidateSignature::Uninstall();

    Logger::Log("All hooks removed");
}

} // namespace Hooks

```

`src/hooks/ipc_dispatch.cpp`:

```cpp
#include "hooks/ipc_dispatch.h"
#include "hooks/hook_base.h"
#include "ipc/types.h"
#include "ipc/parser.h"
#include "utils/logger.h"
#include <cstring>

namespace Hooks {
namespace IPCDispatch {

//=============================================================================
// Function Signature
//=============================================================================
typedef int(__cdecl* Fn_t)(int a1, uint32_t* a2, int a3, void* a4);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static int __cdecl Hook(int a1, uint32_t* a2, int a3, void* a4) {
    __try {
        if (a2) {
            uint8_t* bufferData = reinterpret_cast<uint8_t*>(a2[0]);
            uint32_t getPos = a2[3];
            uint32_t putPos = a2[4];

            if (bufferData && putPos > getPos) {
                size_t bufferSize = putPos - getPos;
                uint32_t magic = 0;
                if (bufferSize >= 4) {
                    memcpy(&magic, bufferData + getPos, 4);
                }
                Logger::Log(">>> VAC IPC_Dispatch [%s] magic=0x%08X size=%zu",
                    IPC::GetModuleManagerMethodName(magic), magic, bufferSize);
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("!!! Exception in IPC_Dispatch hook");
    }

    int result = g_Original(a1, a2, a3, a4);
    Logger::Log("<<< IPC_Dispatch result: %d", result);
    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::IPC_DISPATCH);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "IPC_Dispatch");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "IPC_Dispatch");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace IPCDispatch
} // namespace Hooks

```

`src/hooks/load_validate.cpp`:

```cpp
#include "hooks/load_validate.h"
#include "hooks/hook_base.h"
#include "utils/logger.h"

namespace Hooks {
namespace LoadValidate {

//=============================================================================
// Function Signature (from IDA)
// char __stdcall CClientModuleManager_LoadAndValidateModule(moduleStruct*, flags)
//=============================================================================
typedef char(__stdcall* Fn_t)(void* moduleStruct, char flags);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static char __stdcall Hook(void* moduleStruct, char flags) {
    Logger::Log(">>> VAC LoadAndValidateModule moduleStruct=0x%p flags=0x%02X",
        moduleStruct, static_cast<uint8_t>(flags));

    __try {
        if (moduleStruct) {
            // Module struct layout (from IDA):
            // [0] = moduleId
            // [1] = hLoadedDLL
            // [2] = hMemModule
            // [3] = pfnRunFunc
            // [4] = resultCode
            // [5] = moduleDataSize
            // [6] = pModuleData
            uint32_t* m = reinterpret_cast<uint32_t*>(moduleStruct);
            Logger::Log("    Module: id=%u hDLL=0x%08X hMem=0x%08X pfnRun=0x%08X",
                m[0], m[1], m[2], m[3]);
            Logger::Log("    Module: result=%d dataSize=%u pData=0x%08X",
                static_cast<int>(m[4]), m[5], m[6]);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("    Exception reading module struct");
    }

    char result = g_Original(moduleStruct, flags);
    Logger::Log("<<< VAC LoadAndValidateModule result=%d", result);

    // Log the resolved _runfunc after loading
    __try {
        if (result && moduleStruct) {
            uint32_t* m = reinterpret_cast<uint32_t*>(moduleStruct);
            if (m[3]) {
                Logger::Log("    _runfunc@20 resolved at: 0x%08X", m[3]);
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::LOAD_VALIDATE);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "LoadValidate");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "LoadValidate");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace LoadValidate
} // namespace Hooks

```

`src/hooks/parent_dispatch.cpp`:

```cpp
#include "hooks/parent_dispatch.h"
#include "hooks/hook_base.h"
#include "ipc/types.h"
#include "ipc/parser.h"
#include "emu/emulator.h"
#include "utils/logger.h"
#include <cstring>

namespace Hooks {
namespace ParentDispatch {

//=============================================================================
// Function Signature
//=============================================================================
typedef char(__fastcall* Fn_t)(void* thisptr, void* edx, uint32_t* buffer, int a3);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static char __fastcall Hook(void* thisptr, void* edx, uint32_t* buffer, int a3) {
    uint8_t dispatchType = 0;
    uint32_t magic = 0;
    uint8_t* requestData = nullptr;
    size_t requestSize = 0;

    __try {
        if (buffer) {
            // CUtlBuffer layout: [0]=data, [1]=capacity, [2]=maxPut, [3]=getPos, [4]=putPos
            uint8_t* bufferData = reinterpret_cast<uint8_t*>(buffer[0]);
            uint32_t getPos = buffer[3];
            uint32_t putPos = buffer[4];

            if (bufferData && putPos > getPos) {
                requestSize = putPos - getPos;
                requestData = bufferData + getPos;

                // Parse header: type(1) + unknown(4) + magic(4)
                if (requestSize >= 9) {
                    dispatchType = requestData[0];
                    memcpy(&magic, requestData + 5, 4);
                }

                // Always log the request
                IPC::MessageParser::ParseAndLog(requestData, requestSize);

                // Check if we should emulate this request
                if (g_EmulationEnabled && dispatchType == IPC::TYPE_MODULE_MANAGER) {
                    uint8_t responseBuffer[4096];
                    size_t responseSize = sizeof(responseBuffer);

                    // Skip header to get message body
                    const uint8_t* msgBody = requestData + 9;
                    size_t msgBodySize = requestSize - 9;

                    if (Emu::Emulator::HandleRequest(dispatchType, magic,
                                                      msgBody, msgBodySize,
                                                      responseBuffer, &responseSize)) {
                        Logger::Log("[EMU] Emulated response, size=%zu", responseSize);

                        // Write response back to buffer
                        if (responseSize <= buffer[1]) {
                            memcpy(bufferData, responseBuffer, responseSize);
                            buffer[3] = 0;
                            buffer[4] = static_cast<uint32_t>(responseSize);
                            Logger::Log("<<< ParentDispatch EMULATED, returning 1");
                            return 1;
                        }
                    }
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("!!! Exception in ParentDispatch hook");
    }

    // Forward to original handler
    char result = g_Original(thisptr, edx, buffer, a3);
    Logger::Log("<<< ParentDispatch result: %d", result);
    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::PARENT_DISPATCH);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "ParentDispatch");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "ParentDispatch");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace ParentDispatch
} // namespace Hooks

```

`src/hooks/run_module.cpp`:

```cpp
#include "hooks/run_module.h"
#include "hooks/hook_base.h"
#include "utils/logger.h"

namespace Hooks {
namespace RunModule {

//=============================================================================
// Function Signature (from IDA)
// int __thiscall CClientModuleManager_RunModule(
//     this, moduleId, flags, inputBuf, inputSize,
//     outputBuf, outputSize, outputBufSize, resultSize)
//=============================================================================
typedef int(__fastcall* Fn_t)(void* thisptr, void* edx, int moduleId, char flags,
                               void* inBuf, uint32_t inSize, void* outBuf, uint32_t outSize,
                               uint32_t outBufSize, uint32_t* resultSize);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static int __fastcall Hook(void* thisptr, void* edx, int moduleId, char flags,
                            void* inBuf, uint32_t inSize, void* outBuf, uint32_t outSize,
                            uint32_t outBufSize, uint32_t* resultSize) {
    Logger::Log(">>> VAC RunModule moduleId=%d flags=0x%02X inSize=%u outBufSize=%u",
        moduleId, static_cast<uint8_t>(flags), inSize, outBufSize);

    if (inBuf && inSize > 0) {
        Logger::LogHex("    VAC Input", reinterpret_cast<uint8_t*>(inBuf), inSize);
    }

    int result = g_Original(thisptr, edx, moduleId, flags, inBuf, inSize,
                             outBuf, outSize, outBufSize, resultSize);

    uint32_t actualResultSize = resultSize ? *resultSize : 0;
    Logger::Log("<<< VAC RunModule result=%d resultSize=%u", result, actualResultSize);

    if (outBuf && actualResultSize > 0) {
        Logger::LogHex("    VAC Output", reinterpret_cast<uint8_t*>(outBuf), actualResultSize);
    }

    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::RUN_MODULE);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "RunModule");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "RunModule");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace RunModule
} // namespace Hooks

```

`src/hooks/run_module_async.cpp`:

```cpp
#include "hooks/run_module_async.h"
#include "hooks/hook_base.h"
#include "utils/logger.h"

namespace Hooks {
namespace RunModuleAsync {

//=============================================================================
// Function Signature (from IDA)
//=============================================================================
typedef int(__fastcall* Fn_t)(void* thisptr, void* edx, int a2, int a3, int a4, int a5,
                               int a6, int a7, void* src, int a9, int a10);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static int __fastcall Hook(void* thisptr, void* edx, int a2, int a3, int a4, int a5,
                            int a6, int a7, void* src, int a9, int a10) {
    Logger::Log(">>> VAC RunModuleAsync a2=%d a3=%d a4=%d a5=%d a6=%d a7=%d src=0x%p",
        a2, a3, a4, a5, a6, a7, src);

    int result = g_Original(thisptr, edx, a2, a3, a4, a5, a6, a7, src, a9, a10);
    Logger::Log("<<< VAC RunModuleAsync result=%d", result);
    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::RUN_MODULE_ASYNC);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "RunModuleAsync");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "RunModuleAsync");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace RunModuleAsync
} // namespace Hooks

```

`src/hooks/validate_signature.cpp`:

```cpp
#include "hooks/validate_signature.h"
#include "hooks/hook_base.h"
#include "utils/logger.h"

namespace Hooks {
namespace ValidateSignature {

//=============================================================================
// Function Signature (from IDA)
// int __cdecl Module_ValidateSignature(void* moduleData, uint32_t moduleSize)
// Returns 0 on valid signature, non-zero on failure
//=============================================================================
typedef int(__cdecl* Fn_t)(void* moduleData, uint32_t moduleSize);
static Fn_t g_Original = nullptr;
static void* g_Target = nullptr;

//=============================================================================
// Hook Implementation
//=============================================================================
static int __cdecl Hook(void* moduleData, uint32_t moduleSize) {
    Logger::Log(">>> Module_ValidateSignature data=0x%p size=%u", moduleData, moduleSize);

    // Log first bytes of module (PE header info)
    __try {
        if (moduleData && moduleSize >= 64) {
            uint8_t* data = reinterpret_cast<uint8_t*>(moduleData);
            // Check for MZ header
            if (data[0] == 'M' && data[1] == 'Z') {
                Logger::Log("    PE header detected (MZ signature)");
                // e_lfanew at offset 0x3C
                uint32_t peOffset = *reinterpret_cast<uint32_t*>(data + 0x3C);
                if (peOffset < moduleSize - 4) {
                    uint32_t peSignature = *reinterpret_cast<uint32_t*>(data + peOffset);
                    Logger::Log("    PE offset: 0x%X, signature: 0x%08X", peOffset, peSignature);
                }
            }
            Logger::LogHex("    Module header", data, 64);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("    Exception reading module data");
    }

    int result = g_Original(moduleData, moduleSize);

    if (result == 0) {
        Logger::Log("<<< Module_ValidateSignature: VALID (result=0)");
    } else {
        Logger::Log("<<< Module_ValidateSignature: INVALID (result=%d)", result);
    }

    return result;
}

//=============================================================================
// Install/Uninstall
//=============================================================================
bool Install(uintptr_t baseAddr) {
    g_Target = reinterpret_cast<void*>(baseAddr + Offsets::VALIDATE_SIGNATURE);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "ValidateSignature");
}

bool InstallAt(uintptr_t targetAddr) {
    g_Target = reinterpret_cast<void*>(targetAddr);
    return CreateAndEnable(g_Target, &Hook, reinterpret_cast<void**>(&g_Original), "ValidateSignature");
}

void Uninstall() {
    if (g_Target) {
        MH_DisableHook(g_Target);
        g_Target = nullptr;
    }
}

} // namespace ValidateSignature
} // namespace Hooks

```

`src/injector.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <tlhelp32.h>
#include <shlwapi.h>
#include <iostream>
#include <string>

#pragma comment(lib, "shlwapi.lib")

DWORD FindProcessByName(const char* processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(pe32);

    DWORD pid = 0;
    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (_stricmp(pe32.szExeFile, processName) == 0) {
                pid = pe32.th32ProcessID;
                break;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }

    CloseHandle(hSnapshot);
    return pid;
}

bool InjectDll(DWORD pid, const char* dllPath) {
    // Open target process
    HANDLE hProcess = OpenProcess(
        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
        FALSE, pid);

    if (!hProcess) {
        std::cerr << "Failed to open process. Error: " << GetLastError() << std::endl;
        return false;
    }

    // Allocate memory in target process for DLL path
    size_t pathLen = strlen(dllPath) + 1;
    LPVOID remotePath = VirtualAllocEx(hProcess, NULL, pathLen,
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!remotePath) {
        std::cerr << "Failed to allocate memory. Error: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return false;
    }

    // Write DLL path to target process
    if (!WriteProcessMemory(hProcess, remotePath, dllPath, pathLen, NULL)) {
        std::cerr << "Failed to write memory. Error: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remotePath, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // Get LoadLibraryA address
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    FARPROC pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryA");

    if (!pLoadLibrary) {
        std::cerr << "Failed to get LoadLibraryA address" << std::endl;
        VirtualFreeEx(hProcess, remotePath, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // Create remote thread to load DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
        (LPTHREAD_START_ROUTINE)pLoadLibrary, remotePath, 0, NULL);

    if (!hThread) {
        std::cerr << "Failed to create remote thread. Error: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remotePath, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // Wait for thread to complete
    WaitForSingleObject(hThread, 5000);

    // Check if DLL was loaded
    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, remotePath, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    return exitCode != 0;
}

int main(int argc, char* argv[]) {
    std::cout << "=== VAC IPC Logger Injector ===" << std::endl;

    // Get DLL path
    char dllPath[MAX_PATH];
    if (argc > 1) {
        strncpy_s(dllPath, argv[1], MAX_PATH);
    } else {
        // Default: same directory as injector
        GetModuleFileNameA(NULL, dllPath, MAX_PATH);
        PathRemoveFileSpecA(dllPath);
        strcat_s(dllPath, "\\vac_ipc_logger.dll");
    }

    std::cout << "DLL path: " << dllPath << std::endl;

    // Check if DLL exists
    if (GetFileAttributesA(dllPath) == INVALID_FILE_ATTRIBUTES) {
        std::cerr << "ERROR: DLL not found!" << std::endl;
        return 1;
    }

    // Find SteamService.exe
    std::cout << "Looking for SteamService.exe..." << std::endl;
    DWORD pid = FindProcessByName("SteamService.exe");

    if (!pid) {
        std::cerr << "SteamService.exe not found!" << std::endl;
        std::cout << "Make sure Steam is running." << std::endl;
        return 1;
    }

    std::cout << "Found SteamService.exe (PID: " << pid << ")" << std::endl;

    // Inject DLL
    std::cout << "Injecting DLL..." << std::endl;
    if (InjectDll(pid, dllPath)) {
        std::cout << "SUCCESS! DLL injected." << std::endl;
        std::cout << "Check your Desktop for vac_ipc_log.txt" << std::endl;
    } else {
        std::cerr << "FAILED to inject DLL!" << std::endl;
        std::cout << "Try running as Administrator." << std::endl;
        return 1;
    }

    return 0;
}

```

`src/ipc/parser.cpp`:

```cpp
#include "ipc/parser.h"
#include "utils/logger.h"

namespace IPC {

//=============================================================================
// Name Lookup Functions
//=============================================================================
const char* GetDispatchTypeName(uint8_t type) {
    switch (type) {
        case TYPE_INSTALL_UTILS:    return "IClientInstallUtils";
        case TYPE_MODULE_MANAGER:   return "IClientModuleManager";
        case TYPE_REGISTRY:         return "IRegistryInterface";
        case TYPE_PROCESS_MONITOR:  return "IClientProcessMonitor";
        case TYPE_SECURE_DESKTOP:   return "IClientSecureDesktop";
        case TYPE_HW_MONITOR:       return "IClientWindowsHWMonitor";
        default: return "Unknown";
    }
}

const char* GetInstallUtilsMethodName(uint32_t magic) {
    switch (magic) {
        case InstallUtils::RUN_INSTALL_SCRIPT: return "RunInstallScript";
        default: return "Unknown";
    }
}

const char* GetModuleManagerMethodName(uint32_t magic) {
    switch (magic) {
        case ModuleManager::LOAD_MODULE:         return "LoadModule";
        case ModuleManager::UNLOAD_MODULE:       return "UnloadModule";
        case ModuleManager::CALL_FUNCTION:       return "CallFunction";
        case ModuleManager::CALL_FUNCTION_ASYNC: return "CallFunctionAsync";
        case ModuleManager::POLL_RESPONSE_ASYNC: return "PollResponseAsync";
        case ModuleManager::SET_PROTON_ENV:      return "SetProtonEnv";
        default: return "Unknown";
    }
}

const char* GetRegistryMethodName(uint32_t magic) {
    switch (magic) {
        case Registry::GET_VALUE_STR:
        case Registry::GET_VALUE_STR_ALT:   return "BGetValueStr";
        case Registry::GET_VALUE_UINT:      return "BGetValueUint";
        case Registry::GET_VALUE_UINT64:    return "BGetValueUint64";
        case Registry::GET_VALUE_BIN:       return "BGetValueBin";
        case Registry::SET_VALUE_STR:       return "BSetValueStr";
        case Registry::SET_VALUE_UINT:      return "BSetValueUint";
        case Registry::SET_VALUE_UINT64:    return "BSetValueUint64";
        case Registry::SET_VALUE_BIN:       return "BSetValueBin";
        case Registry::DELETE_VALUE:        return "BDeleteValue";
        case Registry::DELETE_KEY:          return "BDeleteKey";
        case Registry::KEY_EXISTS:          return "BKeyExists";
        case Registry::ENUMERATE_KEY:       return "BEnumerateKey";
        case Registry::ENUMERATE_VALUE:     return "BEnumerateValue";
        default: return "Unknown";
    }
}

const char* GetProcessMonitorMethodName(uint32_t magic) {
    switch (magic) {
        case ProcessMonitor::REGISTER_PROCESS:   return "RegisterProcess";
        case ProcessMonitor::UNREGISTER_PROCESS: return "UnregisterProcess";
        case ProcessMonitor::TERMINATE_PROCESS:  return "TerminateProcess";
        case ProcessMonitor::SUSPEND_PROCESS:    return "SuspendProcess";
        case ProcessMonitor::RESUME_PROCESS:     return "ResumeProcess";
        default: return "Unknown";
    }
}

const char* GetSecureDesktopMethodName(uint32_t magic) {
    switch (magic) {
        case SecureDesktop::START_STREAMING: return "BStartStreaming";
        case SecureDesktop::STOP_STREAMING:  return "StopStreaming";
        case SecureDesktop::SEND_SAS:        return "SendSAS";
        default: return "Unknown";
    }
}

const char* GetHWMonitorMethodName(uint32_t magic) {
    switch (magic) {
        case HWMonitor::START_MONITORING:    return "StartMonitoring";
        case HWMonitor::STOP_MONITORING:     return "StopMonitoring";
        case HWMonitor::REFRESH_INFORMATION: return "RefreshInformation";
        case HWMonitor::GET_CPU_TEMPERATURE: return "GetCPUTemperature";
        default: return "Unknown";
    }
}

const char* GetMethodName(uint8_t dispatchType, uint32_t magic) {
    switch (dispatchType) {
        case TYPE_INSTALL_UTILS:   return GetInstallUtilsMethodName(magic);
        case TYPE_MODULE_MANAGER:  return GetModuleManagerMethodName(magic);
        case TYPE_REGISTRY:        return GetRegistryMethodName(magic);
        case TYPE_PROCESS_MONITOR: return GetProcessMonitorMethodName(magic);
        case TYPE_SECURE_DESKTOP:  return GetSecureDesktopMethodName(magic);
        case TYPE_HW_MONITOR:      return GetHWMonitorMethodName(magic);
        default: return "Unknown";
    }
}

//=============================================================================
// Helper Functions
//=============================================================================
bool MessageParser::ReadAndLogString(BufferReader& reader, const char* fieldName) {
    const char* str;
    uint32_t len;
    if (reader.ReadString(str, len)) {
        // Ensure null termination for logging
        char buf[256];
        size_t copyLen = (len < 255) ? len : 255;
        memcpy(buf, str, copyLen);
        buf[copyLen] = '\0';
        Logger::LogIndent(2, "%s: \"%s\" (len=%u)", fieldName, buf, len);
        return true;
    }
    return false;
}

//=============================================================================
// Main Parser
//=============================================================================
void MessageParser::ParseAndLog(const uint8_t* data, size_t size) {
    if (!data || size < 9) return;  // Need at least: type(1) + unknown(4) + magic(4)

    BufferReader reader(data, size);

    // Read dispatch type (1 byte)
    uint8_t dispatchType;
    if (!reader.Read(dispatchType)) return;

    // Skip unknown 4-byte field (always 0x00000000 in observed traffic)
    uint32_t unknown;
    if (!reader.Read(unknown)) return;

    // Read actual magic value (4 bytes)
    uint32_t magic;
    if (!reader.Read(magic)) return;

    // Log header
    const char* typeName = GetDispatchTypeName(dispatchType);
    const char* methodName = GetMethodName(dispatchType, magic);

    Logger::Log(">>> IPC [%s::%s] type=%d magic=0x%08X size=%zu",
                typeName, methodName, dispatchType, magic, size);

    // Dump raw hex
    Logger::LogHex("    Raw Data", data, size);

    // Parse message body based on type
    switch (dispatchType) {
        case TYPE_INSTALL_UTILS:
            ParseInstallUtilsMsg(magic, reader);
            break;
        case TYPE_MODULE_MANAGER:
            ParseModuleManagerMsg(magic, reader);
            break;
        case TYPE_REGISTRY:
            ParseRegistryMsg(magic, reader);
            break;
        case TYPE_PROCESS_MONITOR:
            ParseProcessMonitorMsg(magic, reader);
            break;
        case TYPE_SECURE_DESKTOP:
            ParseSecureDesktopMsg(magic, reader);
            break;
        case TYPE_HW_MONITOR:
            ParseHWMonitorMsg(magic, reader);
            break;
        default:
            Logger::LogIndent(1, "Unknown dispatch type");
            break;
    }
}

//=============================================================================
// Type 1: IClientInstallUtils Parser
//=============================================================================
void MessageParser::ParseInstallUtilsMsg(uint32_t magic, BufferReader& reader) {
    switch (magic) {
        case InstallUtils::RUN_INSTALL_SCRIPT: {
            Logger::LogIndent(1, "RunInstallScript:");
            ReadAndLogString(reader, "scriptPath");
            ReadAndLogString(reader, "installDir");
            break;
        }
        default:
            Logger::LogIndent(1, "Unknown InstallUtils method: 0x%08X", magic);
            break;
    }
}

//=============================================================================
// Type 2: IClientModuleManager Parser
//=============================================================================
void MessageParser::ParseModuleManagerMsg(uint32_t magic, BufferReader& reader) {
    switch (magic) {
        case ModuleManager::LOAD_MODULE: {
            uint32_t moduleId, moduleSize;
            if (reader.Read(moduleId) && reader.Read(moduleSize)) {
                Logger::LogIndent(1, "LoadModule:");
                Logger::LogIndent(2, "moduleId: %u", moduleId);
                Logger::LogIndent(2, "moduleSize: %u bytes", moduleSize);

                // Check for PE header
                const uint8_t* peData = reader.Peek(2);
                if (peData && peData[0] == 'M' && peData[1] == 'Z') {
                    Logger::LogIndent(2, "Module: Valid PE (MZ header detected)");
                }
            }
            break;
        }

        case ModuleManager::UNLOAD_MODULE: {
            uint32_t moduleId;
            if (reader.Read(moduleId)) {
                Logger::LogIndent(1, "UnloadModule:");
                Logger::LogIndent(2, "moduleId: %u", moduleId);
            }
            break;
        }

        case ModuleManager::CALL_FUNCTION: {
            uint32_t moduleId, functionId, param, inputSize, outputBufSize;
            if (reader.Read(moduleId) && reader.Read(functionId) &&
                reader.Read(param) && reader.Read(inputSize)) {

                Logger::LogIndent(1, "CallFunction:");
                Logger::LogIndent(2, "moduleId: %u", moduleId);
                Logger::LogIndent(2, "functionId: %u", functionId);
                Logger::LogIndent(2, "param: 0x%08X", param);
                Logger::LogIndent(2, "inputSize: %u bytes", inputSize);

                if (inputSize > 0 && reader.HasData(inputSize)) {
                    Logger::LogHex("    Input Data", reader.Peek(inputSize), inputSize, 64);
                    reader.Skip(inputSize);
                }

                if (reader.Read(outputBufSize)) {
                    Logger::LogIndent(2, "outputBufferSize: %u bytes", outputBufSize);
                }
            }
            break;
        }

        case ModuleManager::CALL_FUNCTION_ASYNC: {
            uint32_t clientHandle, moduleId, functionId, param, unknown, inputSize, outputBufSize;
            if (reader.Read(clientHandle) && reader.Read(moduleId) &&
                reader.Read(functionId) && reader.Read(param) &&
                reader.Read(unknown) && reader.Read(inputSize)) {

                Logger::LogIndent(1, "CallFunctionAsync:");
                Logger::LogIndent(2, "clientHandle: 0x%08X", clientHandle);
                Logger::LogIndent(2, "moduleId: %u", moduleId);
                Logger::LogIndent(2, "functionId: %u", functionId);
                Logger::LogIndent(2, "param: 0x%08X", param);
                Logger::LogIndent(2, "unknown: 0x%08X", unknown);
                Logger::LogIndent(2, "inputSize: %u bytes", inputSize);

                if (inputSize > 0 && reader.HasData(inputSize)) {
                    Logger::LogHex("    Input Data", reader.Peek(inputSize), inputSize, 64);
                    reader.Skip(inputSize);
                }

                if (reader.Read(outputBufSize)) {
                    Logger::LogIndent(2, "outputBufferSize: %u bytes", outputBufSize);
                }
            }
            break;
        }

        case ModuleManager::POLL_RESPONSE_ASYNC: {
            uint32_t outputSize, maxWait, unknown;
            if (reader.Read(outputSize) && reader.Read(maxWait) && reader.Read(unknown)) {
                Logger::LogIndent(1, "PollResponseAsync:");
                Logger::LogIndent(2, "outputSize: %u", outputSize);
                Logger::LogIndent(2, "maxWaitMs: %u", maxWait);
                Logger::LogIndent(2, "unknown: 0x%08X", unknown);
            }
            break;
        }

        case ModuleManager::SET_PROTON_ENV: {
            uint32_t envId;
            if (reader.Read(envId)) {
                Logger::LogIndent(1, "SetProtonEnv:");
                Logger::LogIndent(2, "envId: %u", envId);
                // String follows but format unclear
            }
            break;
        }
    }
}

//=============================================================================
// Type 3: IRegistryInterface Parser
//=============================================================================
void MessageParser::ParseRegistryMsg(uint32_t magic, BufferReader& reader) {
    const char* rootNames[] = {
        "HKEY_CLASSES_ROOT", "HKEY_CURRENT_USER",
        "HKEY_LOCAL_MACHINE", "HKEY_USERS"
    };

    // hRoot appears to have flags in upper bits, actual root key in lower 2 bits
    auto logRoot = [&](uint32_t rawRoot) {
        uint32_t root = rawRoot & 0x03;  // Lower 2 bits = actual root key
        uint32_t flags = rawRoot >> 2;   // Upper bits = flags
        if (root < 4) {
            if (flags != 0) {
                Logger::LogIndent(2, "hRoot: %s (raw=0x%X, flags=0x%X)", rootNames[root], rawRoot, flags);
            } else {
                Logger::LogIndent(2, "hRoot: %s (%u)", rootNames[root], root);
            }
        } else {
            Logger::LogIndent(2, "hRoot: Unknown (raw=0x%X)", rawRoot);
        }
    };

    switch (magic) {
        case Registry::GET_VALUE_STR:
        case Registry::GET_VALUE_STR_ALT: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BGetValueStr:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
                uint32_t bufSize;
                if (reader.Read(bufSize)) {
                    Logger::LogIndent(2, "bufferSize: %u", bufSize);
                }
            }
            break;
        }

        case Registry::SET_VALUE_STR: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BSetValueStr:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
                ReadAndLogString(reader, "value");
            }
            break;
        }

        case Registry::GET_VALUE_UINT: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BGetValueUint:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
            }
            break;
        }

        case Registry::SET_VALUE_UINT: {
            uint32_t hRoot, value;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BSetValueUint:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
                if (reader.Read(value)) {
                    Logger::LogIndent(2, "value: %u (0x%08X)", value, value);
                }
            }
            break;
        }

        case Registry::GET_VALUE_BIN: {
            uint32_t hRoot, bufSize;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BGetValueBin:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
                if (reader.Read(bufSize)) {
                    Logger::LogIndent(2, "bufferSize: %u", bufSize);
                }
            }
            break;
        }

        case Registry::KEY_EXISTS: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BKeyExists:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
            }
            break;
        }

        case Registry::DELETE_KEY: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BDeleteKey:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
            }
            break;
        }

        case Registry::DELETE_VALUE: {
            uint32_t hRoot;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BDeleteValue:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                ReadAndLogString(reader, "valueName");
            }
            break;
        }

        case Registry::ENUMERATE_KEY: {
            uint32_t hRoot;
            uint8_t recurse;
            uint32_t index, bufSize;
            if (reader.Read(hRoot) && reader.Read(recurse) &&
                reader.Read(index) && reader.Read(bufSize)) {
                Logger::LogIndent(1, "BEnumerateKey:");
                logRoot(hRoot);
                Logger::LogIndent(2, "recurse: %s", recurse ? "true" : "false");
                Logger::LogIndent(2, "index: %u", index);
                Logger::LogIndent(2, "bufferSize: %u", bufSize);
            }
            break;
        }

        case Registry::ENUMERATE_VALUE: {
            uint32_t hRoot, index, nameSize;
            if (reader.Read(hRoot)) {
                Logger::LogIndent(1, "BEnumerateValue:");
                logRoot(hRoot);
                ReadAndLogString(reader, "keyPath");
                if (reader.Read(index) && reader.Read(nameSize)) {
                    Logger::LogIndent(2, "index: %u", index);
                    Logger::LogIndent(2, "nameBufferSize: %u", nameSize);
                }
            }
            break;
        }

        default:
            Logger::LogIndent(1, "Unknown Registry method: 0x%08X", magic);
            break;
    }
}

//=============================================================================
// Type 4: IClientProcessMonitor Parser
//=============================================================================
void MessageParser::ParseProcessMonitorMsg(uint32_t magic, BufferReader& reader) {
    switch (magic) {
        case ProcessMonitor::REGISTER_PROCESS: {
            uint32_t pid;
            if (reader.Read(pid)) {
                Logger::LogIndent(1, "RegisterProcess:");
                Logger::LogIndent(2, "processId: %u", pid);
            }
            break;
        }

        case ProcessMonitor::UNREGISTER_PROCESS: {
            uint32_t pid;
            if (reader.Read(pid)) {
                Logger::LogIndent(1, "UnregisterProcess:");
                Logger::LogIndent(2, "processId: %u", pid);
            }
            break;
        }

        case ProcessMonitor::TERMINATE_PROCESS: {
            uint32_t pid, exitCode;
            if (reader.Read(pid) && reader.Read(exitCode)) {
                Logger::LogIndent(1, "TerminateProcess:");
                Logger::LogIndent(2, "processId: %u", pid);
                Logger::LogIndent(2, "exitCode: %u", exitCode);
            }
            break;
        }

        case ProcessMonitor::SUSPEND_PROCESS: {
            uint32_t pid;
            if (reader.Read(pid)) {
                Logger::LogIndent(1, "SuspendProcess:");
                Logger::LogIndent(2, "processId: %u", pid);
            }
            break;
        }

        case ProcessMonitor::RESUME_PROCESS: {
            uint32_t pid;
            if (reader.Read(pid)) {
                Logger::LogIndent(1, "ResumeProcess:");
                Logger::LogIndent(2, "processId: %u", pid);
            }
            break;
        }

        default:
            Logger::LogIndent(1, "Unknown ProcessMonitor method: 0x%08X", magic);
            break;
    }
}

//=============================================================================
// Type 5: IClientSecureDesktop Parser
//=============================================================================
void MessageParser::ParseSecureDesktopMsg(uint32_t magic, BufferReader& reader) {
    switch (magic) {
        case SecureDesktop::START_STREAMING:
            Logger::LogIndent(1, "BStartStreaming: (no params)");
            break;
        case SecureDesktop::STOP_STREAMING:
            Logger::LogIndent(1, "StopStreaming: (no params)");
            break;
        case SecureDesktop::SEND_SAS:
            Logger::LogIndent(1, "SendSAS: (no params)");
            break;
        default:
            Logger::LogIndent(1, "Unknown SecureDesktop method: 0x%08X", magic);
            break;
    }
}

//=============================================================================
// Type 6: IClientWindowsHWMonitor Parser
//=============================================================================
void MessageParser::ParseHWMonitorMsg(uint32_t magic, BufferReader& reader) {
    switch (magic) {
        case HWMonitor::START_MONITORING:
            Logger::LogIndent(1, "StartMonitoring: (no params)");
            break;
        case HWMonitor::STOP_MONITORING:
            Logger::LogIndent(1, "StopMonitoring: (no params)");
            break;
        case HWMonitor::REFRESH_INFORMATION:
            Logger::LogIndent(1, "RefreshInformation: (no params)");
            break;
        case HWMonitor::GET_CPU_TEMPERATURE:
            Logger::LogIndent(1, "GetCPUTemperature: (no params, returns int32)");
            break;
        default:
            Logger::LogIndent(1, "Unknown HWMonitor method: 0x%08X", magic);
            break;
    }
}

} // namespace IPC

```

`src/ipc_parser.cpp`:

```cpp
#include "ipc_parser.h"
#include "logger.h"

namespace IPCParser {

// Helper to safely read from buffer
template<typename T>
static bool SafeRead(const uint8_t*& ptr, const uint8_t* end, T& out) {
    if (ptr + sizeof(T) > end) return false;
    memcpy(&out, ptr, sizeof(T));
    ptr += sizeof(T);
    return true;
}

bool ParseLoadModule(const uint8_t* data, size_t size, LoadModuleRequest& out) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    // Skip magic (already read)
    if (!SafeRead(ptr, end, out.moduleId)) return false;
    if (!SafeRead(ptr, end, out.moduleSize)) return false;

    // Module data follows
    if (ptr + out.moduleSize > end) return false;
    out.moduleData = ptr;

    return true;
}

bool ParseUnloadModule(const uint8_t* data, size_t size, UnloadModuleRequest& out) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    if (!SafeRead(ptr, end, out.moduleId)) return false;
    return true;
}

bool ParseCallFunction(const uint8_t* data, size_t size, CallFunctionRequest& out) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    if (!SafeRead(ptr, end, out.moduleId)) return false;
    if (!SafeRead(ptr, end, out.functionId)) return false;
    if (!SafeRead(ptr, end, out.param)) return false;
    if (!SafeRead(ptr, end, out.inputSize)) return false;

    // Input data follows
    if (out.inputSize > 0) {
        if (ptr + out.inputSize > end) return false;
        out.inputData = ptr;
        ptr += out.inputSize;
    } else {
        out.inputData = nullptr;
    }

    if (!SafeRead(ptr, end, out.outputBufferSize)) return false;
    return true;
}

bool ParseCallFunctionAsync(const uint8_t* data, size_t size, CallFunctionAsyncRequest& out) {
    const uint8_t* ptr = data;
    const uint8_t* end = data + size;

    if (!SafeRead(ptr, end, out.clientHandle)) return false;
    if (!SafeRead(ptr, end, out.moduleId)) return false;
    if (!SafeRead(ptr, end, out.functionId)) return false;
    if (!SafeRead(ptr, end, out.param)) return false;
    if (!SafeRead(ptr, end, out.unknown1)) return false;
    if (!SafeRead(ptr, end, out.inputSize)) return false;

    // Input data follows
    if (out.inputSize > 0) {
        if (ptr + out.inputSize > end) return false;
        out.inputData = ptr;
        ptr += out.inputSize;
    } else {
        out.inputData = nullptr;
    }

    if (!SafeRead(ptr, end, out.outputBufferSize)) return false;
    return true;
}

void ParseAndLogRequest(uint32_t magic, const uint8_t* data, size_t dataSize) {
    switch (magic) {
        case IPC::MAGIC_LOAD_MODULE: {
            LoadModuleRequest req;
            if (ParseLoadModule(data, dataSize, req)) {
                Logger::Log("  LoadModule: moduleId=%u, size=%u bytes",
                    req.moduleId, req.moduleSize);

                // Log first bytes of module (PE header check)
                if (req.moduleSize >= 2 && req.moduleData) {
                    const uint8_t* pe = static_cast<const uint8_t*>(req.moduleData);
                    if (pe[0] == 'M' && pe[1] == 'Z') {
                        Logger::Log("  Module appears to be valid PE (MZ header)");
                    }
                }
            }
            break;
        }

        case IPC::MAGIC_UNLOAD_MODULE: {
            UnloadModuleRequest req;
            if (ParseUnloadModule(data, dataSize, req)) {
                Logger::Log("  UnloadModule: moduleId=%u", req.moduleId);
            }
            break;
        }

        case IPC::MAGIC_CALL_FUNCTION: {
            CallFunctionRequest req;
            if (ParseCallFunction(data, dataSize, req)) {
                Logger::Log("  CallFunction: moduleId=%u, funcId=%u, param=%u",
                    req.moduleId, req.functionId, req.param);
                Logger::Log("  Input: %u bytes, OutputBuffer: %u bytes",
                    req.inputSize, req.outputBufferSize);

                if (req.inputSize > 0 && req.inputData) {
                    Logger::LogHex("  Input Data", req.inputData,
                        req.inputSize > 64 ? 64 : req.inputSize);
                }
            }
            break;
        }

        case IPC::MAGIC_CALL_FUNCTION_ASYNC: {
            CallFunctionAsyncRequest req;
            if (ParseCallFunctionAsync(data, dataSize, req)) {
                Logger::Log("  CallFunctionAsync: handle=%u, moduleId=%u, funcId=%u, param=%u",
                    req.clientHandle, req.moduleId, req.functionId, req.param);
                Logger::Log("  Input: %u bytes, OutputBuffer: %u bytes",
                    req.inputSize, req.outputBufferSize);
            }
            break;
        }

        case IPC::MAGIC_POLL_RESPONSE_ASYNC: {
            if (dataSize >= 12) {
                uint32_t outputSize, maxWait, unknown;
                memcpy(&outputSize, data, 4);
                memcpy(&maxWait, data + 4, 4);
                memcpy(&unknown, data + 8, 4);
                Logger::Log("  PollResponseAsync: outputSize=%u, maxWait=%u, unk=%u",
                    outputSize, maxWait, unknown);
            }
            break;
        }

        case IPC::MAGIC_SET_PROTON_ENV: {
            if (dataSize >= 4) {
                uint32_t envId;
                memcpy(&envId, data, 4);
                Logger::Log("  SetProtonEnvironment: envId=%u", envId);
                // String follows but we'd need to parse it
            }
            break;
        }

        default:
            Logger::Log("  Unknown IPC method: 0x%08X", magic);
            break;
    }
}

} // namespace IPCParser

```

`src/logger.cpp`:

```cpp
#include "logger.h"
#include <cstdarg>
#include <ctime>

namespace Logger {

static std::ofstream g_logFile;
static std::mutex g_logMutex;
static bool g_initialized = false;

void Init(const std::string& logPath) {
    std::lock_guard<std::mutex> lock(g_logMutex);
    if (g_initialized) return;

    g_logFile.open(logPath, std::ios::out | std::ios::app);
    g_initialized = g_logFile.is_open();

    if (g_initialized) {
        Log("=== VAC IPC Logger Started ===");
        Log("Timestamp: %s", __TIMESTAMP__);
    }
}

void Shutdown() {
    std::lock_guard<std::mutex> lock(g_logMutex);
    if (g_initialized) {
        Log("=== VAC IPC Logger Shutdown ===");
        g_logFile.close();
        g_initialized = false;
    }
}

static std::string GetTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;

    std::tm tm_buf;
    localtime_s(&tm_buf, &time);

    std::ostringstream oss;
    oss << std::put_time(&tm_buf, "%H:%M:%S");
    oss << '.' << std::setfill('0') << std::setw(3) << ms.count();
    return oss.str();
}

void Log(const char* format, ...) {
    std::lock_guard<std::mutex> lock(g_logMutex);
    if (!g_initialized) return;

    char buffer[4096];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    g_logFile << "[" << GetTimestamp() << "] " << buffer << std::endl;

    // Also output to debugger
    OutputDebugStringA("[VAC_HOOK] ");
    OutputDebugStringA(buffer);
    OutputDebugStringA("\n");
}

void LogHex(const char* prefix, const void* data, size_t size) {
    std::lock_guard<std::mutex> lock(g_logMutex);
    if (!g_initialized || !data || size == 0) return;

    std::ostringstream oss;
    oss << prefix << " (" << size << " bytes):\n";

    const uint8_t* bytes = static_cast<const uint8_t*>(data);
    for (size_t i = 0; i < size; i += 16) {
        oss << "  " << std::hex << std::setfill('0') << std::setw(4) << i << ": ";

        // Hex bytes
        for (size_t j = 0; j < 16; j++) {
            if (i + j < size) {
                oss << std::setw(2) << static_cast<int>(bytes[i + j]) << " ";
            } else {
                oss << "   ";
            }
        }

        oss << " | ";

        // ASCII
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            char c = bytes[i + j];
            oss << (c >= 32 && c < 127 ? c : '.');
        }
        oss << "\n";
    }

    g_logFile << "[" << GetTimestamp() << "] " << oss.str();
}

void LogIPCRequest(uint32_t magic, const void* buffer, size_t size) {
    Log(">>> IPC REQUEST: %s (0x%08X)", IPC::GetMethodName(magic), magic);
    if (buffer && size > 0) {
        LogHex("  Request Data", buffer, size > 256 ? 256 : size);
        if (size > 256) {
            Log("  ... (%zu more bytes)", size - 256);
        }
    }
}

void LogIPCResponse(uint32_t magic, const void* buffer, size_t size) {
    Log("<<< IPC RESPONSE: %s (0x%08X)", IPC::GetMethodName(magic), magic);
    if (buffer && size > 0) {
        LogHex("  Response Data", buffer, size > 256 ? 256 : size);
        if (size > 256) {
            Log("  ... (%zu more bytes)", size - 256);
        }
    }
}

void Flush() {
    std::lock_guard<std::mutex> lock(g_logMutex);
    if (g_initialized) {
        g_logFile.flush();
    }
}

} // namespace Logger

// IPC method name lookup
namespace IPC {
    const char* GetMethodName(uint32_t magic) {
        switch (magic) {
            case MAGIC_LOAD_MODULE:         return "LoadModule";
            case MAGIC_UNLOAD_MODULE:       return "UnloadModule";
            case MAGIC_CALL_FUNCTION:       return "CallFunction";
            case MAGIC_CALL_FUNCTION_ASYNC: return "CallFunctionAsync";
            case MAGIC_POLL_RESPONSE_ASYNC: return "PollResponseAsync";
            case MAGIC_SET_PROTON_ENV:      return "SetProtonEnvironment";
            default:                        return "Unknown";
        }
    }
}

```

`src/module/manager.cpp`:

```cpp
#include "module/manager.h"
#include "utils/logger.h"
#include <cstring>

namespace Module {

//=============================================================================
// Singleton Instance
//=============================================================================
Manager& Manager::Instance() {
    static Manager instance;
    return instance;
}

//=============================================================================
// Module Lifecycle
//=============================================================================
bool Manager::LoadModule(uint32_t moduleId, uint32_t moduleSize, const uint8_t* moduleData) {
    Logger::Log("[Module] LoadModule(id=%u, size=%u)", moduleId, moduleSize);

    // Check if already loaded
    if (m_modules.find(moduleId) != m_modules.end()) {
        Logger::Log("[Module] Module %u already loaded", moduleId);
        return true;  // Already loaded is success
    }

    // Track the module (we don't actually load the PE - we're emulating)
    EmulatedModule mod;
    mod.moduleId = moduleId;
    mod.moduleSize = moduleSize;
    mod.loadTime = GetTickCount64();
    mod.loaded = true;
    mod.lastResult = static_cast<int32_t>(ErrorCode::SUCCESS);

    m_modules[moduleId] = mod;

    Logger::Log("[Module] Module %u loaded (emulated), total modules: %zu",
                moduleId, m_modules.size());
    return true;
}

bool Manager::UnloadModule(uint32_t moduleId) {
    Logger::Log("[Module] UnloadModule(id=%u)", moduleId);

    auto it = m_modules.find(moduleId);
    if (it == m_modules.end()) {
        Logger::Log("[Module] Module %u not found", moduleId);
        return false;
    }

    m_modules.erase(it);
    Logger::Log("[Module] Module %u unloaded, remaining: %zu",
                moduleId, m_modules.size());
    return true;
}

bool Manager::IsModuleLoaded(uint32_t moduleId) const {
    return m_modules.find(moduleId) != m_modules.end();
}

//=============================================================================
// Synchronous Execution
//=============================================================================
ErrorCode Manager::CallFunction(uint32_t moduleId, uint32_t functionId, uint32_t param,
                                const uint8_t* inputData, uint32_t inputSize,
                                uint8_t* outputData, uint32_t outputSize, uint32_t* resultSize) {
    Logger::Log("[Module] CallFunction(mod=%u, func=%u, param=0x%X, inSize=%u, outSize=%u)",
                moduleId, functionId, param, inputSize, outputSize);

    // Check module exists
    if (!IsModuleLoaded(moduleId)) {
        Logger::Log("[Module] CallFunction: module %u not loaded", moduleId);
        return ErrorCode::MODULE_NOT_FOUND;
    }

    // Check minimum output buffer size
    if (outputSize < MIN_OUTPUT_BUFFER_SIZE) {
        Logger::Log("[Module] CallFunction: buffer too small (%u < %u)",
                    outputSize, MIN_OUTPUT_BUFFER_SIZE);
        return ErrorCode::BUFFER_TOO_SMALL;
    }

    // Emulate "clean" scan result - no detections
    // Real VAC modules would scan memory/processes here
    if (outputData && outputSize > 0) {
        memset(outputData, 0, outputSize);
    }
    *resultSize = 0;  // No actual output data (clean)

    Logger::Log("[Module] CallFunction: returning CLEAN result");
    return ErrorCode::SUCCESS;
}

//=============================================================================
// Asynchronous Execution
//=============================================================================
ErrorCode Manager::CallFunctionAsync(uint32_t clientHandle, uint32_t moduleId,
                                     uint32_t functionId, uint32_t param,
                                     const uint8_t* inputData, uint32_t inputSize,
                                     uint32_t outputSize) {
    Logger::Log("[Module] CallFunctionAsync(client=0x%X, mod=%u, func=%u)",
                clientHandle, moduleId, functionId);

    // Check module exists
    if (!IsModuleLoaded(moduleId)) {
        Logger::Log("[Module] CallFunctionAsync: module %u not loaded", moduleId);
        return ErrorCode::MODULE_NOT_FOUND;
    }

    // Create async result entry (immediately "completed" with clean result)
    AsyncResult result;
    result.clientHandle = clientHandle;
    result.moduleId = moduleId;
    result.functionId = functionId;
    result.resultCode = static_cast<int32_t>(ErrorCode::SUCCESS);
    result.outputData = nullptr;
    result.outputSize = 0;  // Clean = no output
    result.state = AsyncState::COMPLETED;  // Immediately ready

    m_asyncResults[clientHandle] = result;

    Logger::Log("[Module] CallFunctionAsync: queued (immediately ready), pending=%zu",
                m_asyncResults.size());
    return ErrorCode::SUCCESS;
}

ErrorCode Manager::PollAsyncResult(uint32_t* outClientHandle,
                                   uint8_t* outputData, uint32_t outputSize,
                                   uint32_t* resultSize, uint32_t maxWaitMs) {
    Logger::Log("[Module] PollAsyncResult(outSize=%u, maxWait=%u, pending=%zu)",
                outputSize, maxWaitMs, m_asyncResults.size());

    // Find first completed result
    for (auto it = m_asyncResults.begin(); it != m_asyncResults.end(); ++it) {
        if (it->second.state == AsyncState::COMPLETED) {
            // Found a ready result
            *outClientHandle = it->second.clientHandle;
            *resultSize = it->second.outputSize;

            // Copy output data if any
            if (outputData && it->second.outputData && it->second.outputSize > 0) {
                uint32_t copySize = (it->second.outputSize < outputSize) ?
                                     it->second.outputSize : outputSize;
                memcpy(outputData, it->second.outputData, copySize);
            }

            ErrorCode result = static_cast<ErrorCode>(it->second.resultCode);

            // Remove from pending
            m_asyncResults.erase(it);

            Logger::Log("[Module] PollAsyncResult: found result for handle 0x%X, code=%d",
                        *outClientHandle, static_cast<int32_t>(result));
            return result;
        }
    }

    // Nothing ready
    Logger::Log("[Module] PollAsyncResult: no results ready");
    return ErrorCode::NO_RESULT_READY;
}

//=============================================================================
// Clean Response Builder
//=============================================================================
size_t CleanResponse::Build(uint8_t* buffer, size_t bufferSize, uint32_t requestedOutputSize) {
    // Response format: result(4) + outputBuffer(requestedSize) + actualSize(4)
    size_t totalSize = 4 + requestedOutputSize + 4;

    if (bufferSize < totalSize) {
        return 0;  // Buffer too small
    }

    size_t pos = 0;

    // Write result code (success = 1)
    int32_t resultCode = RESULT_CLEAN;
    memcpy(buffer + pos, &resultCode, 4);
    pos += 4;

    // Write empty output buffer
    memset(buffer + pos, 0, requestedOutputSize);
    pos += requestedOutputSize;

    // Write actual output size (0 = clean, no detections)
    uint32_t actualSize = OUTPUT_SIZE;
    memcpy(buffer + pos, &actualSize, 4);
    pos += 4;

    return pos;
}

} // namespace Module

```

`src/utils/disasm.cpp`:

```cpp
#include "utils/disasm.h"
#include "utils/logger.h"
#include <Zydis/Zydis.h>
#include <cstring>

namespace Disasm {

//=============================================================================
// Disassembler Implementation
//=============================================================================
Disassembler::Disassembler() : m_initialized(false) {
    m_decoder = new ZydisDecoder();
    m_formatter = new ZydisFormatter();

    // Initialize decoder for 32-bit mode (SteamService is x86)
    if (ZYAN_SUCCESS(ZydisDecoderInit(
            static_cast<ZydisDecoder*>(m_decoder),
            ZYDIS_MACHINE_MODE_LONG_COMPAT_32,
            ZYDIS_STACK_WIDTH_32))) {

        // Initialize formatter
        if (ZYAN_SUCCESS(ZydisFormatterInit(
                static_cast<ZydisFormatter*>(m_formatter),
                ZYDIS_FORMATTER_STYLE_INTEL))) {
            m_initialized = true;
        }
    }

    if (!m_initialized) {
        Logger::Log("[Disasm] Failed to initialize Zydis");
    }
}

Disassembler::~Disassembler() {
    delete static_cast<ZydisDecoder*>(m_decoder);
    delete static_cast<ZydisFormatter*>(m_formatter);
}

bool Disassembler::DisassembleOne(const uint8_t* code, size_t size, uint64_t address, Instruction& out) {
    if (!m_initialized || !code || size == 0) return false;

    ZydisDecodedInstruction instruction;
    ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];

    if (!ZYAN_SUCCESS(ZydisDecoderDecodeFull(
            static_cast<ZydisDecoder*>(m_decoder),
            code, size, &instruction, operands))) {
        return false;
    }

    // Fill output structure
    out.address = address;
    out.length = instruction.length;
    memcpy(out.bytes, code, instruction.length);

    // Get mnemonic
    const char* mnemonic = ZydisMnemonicGetString(instruction.mnemonic);
    strncpy(out.mnemonic, mnemonic ? mnemonic : "???", sizeof(out.mnemonic) - 1);
    out.mnemonic[sizeof(out.mnemonic) - 1] = '\0';

    // Format operands
    char buffer[256];
    if (ZYAN_SUCCESS(ZydisFormatterFormatInstruction(
            static_cast<ZydisFormatter*>(m_formatter),
            &instruction, operands, instruction.operand_count_visible,
            buffer, sizeof(buffer), address, ZYAN_NULL))) {
        // Skip the mnemonic part to get just operands
        const char* space = strchr(buffer, ' ');
        if (space) {
            strncpy(out.operands, space + 1, sizeof(out.operands) - 1);
        } else {
            out.operands[0] = '\0';
        }
    } else {
        out.operands[0] = '\0';
    }
    out.operands[sizeof(out.operands) - 1] = '\0';

    return true;
}

std::vector<Instruction> Disassembler::Disassemble(const uint8_t* code, size_t size, uint64_t address, size_t maxInstructions) {
    std::vector<Instruction> result;
    if (!m_initialized || !code || size == 0) return result;

    size_t offset = 0;
    while (offset < size && result.size() < maxInstructions) {
        Instruction insn;
        if (DisassembleOne(code + offset, size - offset, address + offset, insn)) {
            result.push_back(insn);
            offset += insn.length;
        } else {
            break;
        }
    }

    return result;
}

std::string Disassembler::Format(const Instruction& insn) {
    char buffer[256];
    char hexBytes[48] = "";

    // Format bytes as hex
    for (uint8_t i = 0; i < insn.length && i < 8; i++) {
        char byteStr[4];
        snprintf(byteStr, sizeof(byteStr), "%02X ", insn.bytes[i]);
        strcat(hexBytes, byteStr);
    }
    if (insn.length > 8) strcat(hexBytes, "...");

    // Format: address  bytes  mnemonic operands
    if (insn.operands[0]) {
        snprintf(buffer, sizeof(buffer), "%08X  %-24s %s %s",
                 static_cast<uint32_t>(insn.address), hexBytes, insn.mnemonic, insn.operands);
    } else {
        snprintf(buffer, sizeof(buffer), "%08X  %-24s %s",
                 static_cast<uint32_t>(insn.address), hexBytes, insn.mnemonic);
    }

    return buffer;
}

void Disassembler::LogDisassembly(const uint8_t* code, size_t size, uint64_t address, size_t maxInstructions) {
    auto& disasm = GetDisassembler();
    auto instructions = disasm.Disassemble(code, size, address, maxInstructions);

    for (const auto& insn : instructions) {
        Logger::Log("    %s", Format(insn).c_str());
    }
}

void Disassembler::LogFunctionPrologue(void* funcAddr, size_t maxInstructions) {
    if (!funcAddr) return;

    __try {
        Logger::Log("    Function prologue at 0x%08X:", reinterpret_cast<uintptr_t>(funcAddr));
        LogDisassembly(
            static_cast<const uint8_t*>(funcAddr),
            maxInstructions * 15,  // Max instruction size is 15 bytes
            reinterpret_cast<uint64_t>(funcAddr),
            maxInstructions
        );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("    Failed to disassemble (access violation)");
    }
}

//=============================================================================
// Global Instance
//=============================================================================
Disassembler& GetDisassembler() {
    static Disassembler instance;
    return instance;
}

} // namespace Disasm

```

`src/utils/logger.cpp`:

```cpp
#include "utils/logger.h"
#include <mutex>

namespace Logger {

static FILE* g_logFile = nullptr;
static CRITICAL_SECTION g_logCS;
static bool g_initialized = false;

void Init(const char* logPath) {
    if (g_initialized) return;

    InitializeCriticalSection(&g_logCS);
    g_logFile = fopen(logPath, "a");
    g_initialized = (g_logFile != nullptr);

    // Header is logged by dllmain.cpp
}

void Shutdown() {
    if (!g_initialized) return;

    EnterCriticalSection(&g_logCS);
    if (g_logFile) {
        Log("Shutting down...");
        fclose(g_logFile);
        g_logFile = nullptr;
    }
    LeaveCriticalSection(&g_logCS);

    DeleteCriticalSection(&g_logCS);
    g_initialized = false;
}

void Log(const char* fmt, ...) {
    if (!g_initialized || !g_logFile) return;

    EnterCriticalSection(&g_logCS);

    SYSTEMTIME st;
    GetLocalTime(&st);

    // Format timestamp
    char timePrefix[32];
    snprintf(timePrefix, sizeof(timePrefix), "[%02d:%02d:%02d.%03d] ",
             st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

    // Format message
    char msgBuffer[2048];
    va_list args;
    va_start(args, fmt);
    vsnprintf(msgBuffer, sizeof(msgBuffer), fmt, args);
    va_end(args);

    // Write to file
    fprintf(g_logFile, "%s%s\n", timePrefix, msgBuffer);
    fflush(g_logFile);

    // Also output to debugger (viewable with DebugView)
    char debugBuffer[2100];
    snprintf(debugBuffer, sizeof(debugBuffer), "[VAC] %s%s\n", timePrefix, msgBuffer);
    OutputDebugStringA(debugBuffer);

    LeaveCriticalSection(&g_logCS);
}

void LogIndent(int level, const char* fmt, ...) {
    if (!g_initialized || !g_logFile) return;

    EnterCriticalSection(&g_logCS);

    SYSTEMTIME st;
    GetLocalTime(&st);
    fprintf(g_logFile, "[%02d:%02d:%02d.%03d] ",
            st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

    // Add indentation
    for (int i = 0; i < level; i++) {
        fprintf(g_logFile, "  ");
    }

    va_list args;
    va_start(args, fmt);
    vfprintf(g_logFile, fmt, args);
    va_end(args);

    fprintf(g_logFile, "\n");
    fflush(g_logFile);

    LeaveCriticalSection(&g_logCS);
}

void LogHex(const char* prefix, const uint8_t* data, size_t len, size_t maxLen) {
    if (!g_initialized || !g_logFile || !data || len == 0) return;

    EnterCriticalSection(&g_logCS);

    SYSTEMTIME st;
    GetLocalTime(&st);
    fprintf(g_logFile, "[%02d:%02d:%02d.%03d] %s (%zu bytes):\n",
            st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, prefix, len);

    size_t displayLen = (len < maxLen) ? len : maxLen;

    for (size_t i = 0; i < displayLen; i += 16) {
        fprintf(g_logFile, "  %04zX: ", i);

        // Hex bytes
        for (size_t j = 0; j < 16; j++) {
            if (i + j < displayLen) {
                fprintf(g_logFile, "%02X ", data[i + j]);
            } else {
                fprintf(g_logFile, "   ");
            }
        }

        fprintf(g_logFile, " | ");

        // ASCII
        for (size_t j = 0; j < 16 && i + j < displayLen; j++) {
            char c = data[i + j];
            fprintf(g_logFile, "%c", (c >= 32 && c < 127) ? c : '.');
        }

        fprintf(g_logFile, "\n");
    }

    if (len > maxLen) {
        fprintf(g_logFile, "  ... (%zu more bytes)\n", len - maxLen);
    }

    fflush(g_logFile);
    LeaveCriticalSection(&g_logCS);
}

void Flush() {
    if (!g_initialized || !g_logFile) return;
    EnterCriticalSection(&g_logCS);
    fflush(g_logFile);
    LeaveCriticalSection(&g_logCS);
}

FILE* GetFile() {
    return g_logFile;
}

} // namespace Logger

```

`src/utils/sigscan.cpp`:

```cpp
#include "utils/sigscan.h"
#include "utils/logger.h"
#include <Psapi.h>
#include <vector>
#include <string>
#include <sstream>

namespace SigScan {

//=============================================================================
// Pattern Parsing - converts "55 8B EC ?? ??" to bytes + mask
//=============================================================================
static bool ParsePattern(const char* pattern, std::vector<uint8_t>& bytes, std::vector<uint8_t>& mask) {
    bytes.clear();
    mask.clear();

    std::istringstream iss(pattern);
    std::string token;

    while (iss >> token) {
        if (token == "??" || token == "?") {
            bytes.push_back(0);
            mask.push_back(false);  // wildcard - don't compare
        } else {
            try {
                uint8_t byte = static_cast<uint8_t>(std::stoul(token, nullptr, 16));
                bytes.push_back(byte);
                mask.push_back(true);  // must match
            } catch (...) {
                return false;
            }
        }
    }

    return !bytes.empty();
}

//=============================================================================
// Safe memory scan helper (separated for SEH compatibility)
//=============================================================================
static uintptr_t ScanMemorySafe(const uint8_t* start, const uint8_t* end,
                                 const uint8_t* bytes, const uint8_t* mask, size_t patternSize) {
    __try {
        for (const uint8_t* ptr = start; ptr < end; ptr++) {
            bool found = true;
            for (size_t i = 0; i < patternSize; i++) {
                if (mask[i] && ptr[i] != bytes[i]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                return reinterpret_cast<uintptr_t>(ptr);
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Logger::Log("[SigScan] Exception while scanning");
    }
    return 0;
}

//=============================================================================
// FindPattern - scans memory range for pattern
//=============================================================================
uintptr_t FindPattern(uintptr_t moduleBase, size_t moduleSize, const char* pattern) {
    std::vector<uint8_t> bytes;
    std::vector<uint8_t> mask;

    if (!ParsePattern(pattern, bytes, mask)) {
        Logger::Log("[SigScan] Failed to parse pattern: %s", pattern);
        return 0;
    }

    const uint8_t* start = reinterpret_cast<const uint8_t*>(moduleBase);
    const uint8_t* end = start + moduleSize - bytes.size();

    return ScanMemorySafe(start, end, bytes.data(), mask.data(), bytes.size());
}

//=============================================================================
// FindPatternInModule - scans a named module
//=============================================================================
uintptr_t FindPatternInModule(const char* moduleName, const char* pattern) {
    HMODULE hModule = GetModuleHandleA(moduleName);
    if (!hModule) {
        Logger::Log("[SigScan] Module not found: %s", moduleName);
        return 0;
    }

    MODULEINFO modInfo;
    if (!GetModuleInformation(GetCurrentProcess(), hModule, &modInfo, sizeof(modInfo))) {
        Logger::Log("[SigScan] Failed to get module info for: %s", moduleName);
        return 0;
    }

    return FindPattern(
        reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll),
        modInfo.SizeOfImage,
        pattern
    );
}

//=============================================================================
// FindInSteamService - convenience wrapper
//=============================================================================
uintptr_t FindInSteamService(const char* pattern) {
    return FindPatternInModule("SteamService.dll", pattern);
}

} // namespace SigScan

```